{
    "Shader": 
    {
        "ver": "0.1",
        "info": 
        {
            "id": "MddGzf",
            "date": "1451884800",
            "viewed": 10566,
            "name": "Bricks Game",
            "username": "iq",
            "description": "Use arrow keys or the mouse to move the paddle. Use space to restart. This shader uses the new Multipass system",
            "likes": 111,
            "published": 3,
            "flags": 112,
            "tags": 
            [
                "procedural",
                "2d",
                "game",
                "bricks",
                "multipass"
            ],

            "hasliked": 0
        },

        "renderpass": 
        [
            {
                "inputs": 
                [
                    {
                        "id": 257,
                        "src": "\/presets\/previz\/buffer00.png",
                        "ctype": "buffer",
                        "channel": 0,
                        "sampler": 
                        {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        }
                    },

                    {
                        "id": 552,
                        "src": "https:\/\/soundcloud.com\/algoritmos666\/tron-legacy-soundtrack-ost-03",
                        "ctype": "musicstream",
                        "channel": 1,
                        "sampler": 
                        {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        }
                    }
                ],

                "outputs": 
                [
                    {
                        "channel": "0"
                    }
                ],

                "code": "\/\/ Created by inigo quilez - iq\/2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\/\/\n\/\/ Game rendering. Regular 2D distance field rendering.\n\/\/\n\n\n\/\/ storage register\/texel addresses\nconst vec2 txBallPosVel = vec2(0.0,0.0);\nconst vec2 txPaddlePos  = vec2(1.0,0.0);\nconst vec2 txPoints     = vec2(2.0,0.0);\nconst vec2 txState      = vec2(3.0,0.0);\nconst vec2 txLastHit    = vec2(4.0,0.0);\nconst vec4 txBricks     = vec4(0.0,1.0,13.0,12.0);\n\nconst float ballRadius = 0.035;\nconst float paddleSize = 0.30;\nconst float paddleWidth = 0.06;\nconst float paddlePosY  = -0.90;\nconst float brickW = 2.0\/13.0;\nconst float brickH = 1.0\/15.0;\n\n\/\/----------------\n\nconst vec2 shadowOffset = vec2(-0.03,0.03);\n\n\/\/=================================================================================================\n\/\/ distance functions\n\/\/=================================================================================================\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat udHorizontalSegment( in vec2 p, in float xa, in float xb, in float y )\n{\n    vec2 pa = p - vec2(xa,y);\n    float ba = xb - xa;\n    pa.x -= ba*clamp( pa.x\/ba, 0.0, 1.0 );\n    return length( pa );\n}\n\nfloat udRoundBox( vec2 p, vec2 c, vec2 b, float r )\n{\n  return length(max(abs(p-c)-b,0.0))-r;\n}\n\n\/\/=================================================================================================\n\/\/ utility\n\/\/=================================================================================================\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*138.5453123);\n}\n\nfloat SampleDigit(const in float n, const in vec2 vUV)\n{\n    if( abs(vUV.x-0.5)>0.5 || abs(vUV.y-0.5)>0.5 ) return 0.0;\n\n    \/\/ digit data by P_Malin (https:\/\/www.shadertoy.com\/view\/4sf3RN)\n    float data = 0.0;\n         if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    else if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n    else if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n    else if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n    else if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n    else if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    else if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    \n    vec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n    float fIndex = vPixel.x + (vPixel.y * 4.0);\n    \n    return mod(floor(data \/ pow(2.0, fIndex)), 2.0);\n}\n\nfloat PrintInt( in vec2 uv, in float value )\n{\n    float res = 0.0;\n    float maxDigits = 1.0+ceil(.01+log2(value)\/log2(10.0));\n    float digitID = floor(uv.x);\n    if( digitID>0.0 && digitID<maxDigits )\n    {\n        float digitVa = mod( floor( value\/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n        res = SampleDigit( digitVa, vec2(fract(uv.x), uv.y) );\n    }\n\n    return res;\n}\n\n\/\/=================================================================================================\n\nfloat doBrick( in vec2 id, out vec3 col, out float glo, out vec2 cen )\n{\n    float alp = 0.0;\n    \n    glo = 0.0;\n    col = vec3(0.0);\n    cen = vec2(0.0);\n    \n    \/\/if( id.x>=0.0 && id.x<13.0 && id.y>=0.0 && id.y<12.0 )\n    if( abs(id.x-6.0)<=6.5 && abs(id.y-5.5)<6.0 )\n    {\n        vec2 brickHere = texture2D( iChannel0, (txBricks.xy+id+0.5)\/iChannelResolution[0].xy, -100.0 ).xy;\n\n        alp = 1.0;\n        glo = 0.0;\n        if( brickHere.x < 0.5 )\n        {\n            float t = max(0.0,iGlobalTime-brickHere.y-0.1);\n            alp = exp(-2.0*t );\n            glo = exp(-4.0*t );\n        }\n         \n        if( alp>0.001 )\n        {\n            float fid = hash1(id.x*3.0 + id.y*16.0);\n            col = vec3(0.5,0.5,0.6) + 0.4*sin( fid*2.0 + 4.5 + vec3(0.0,1.0,1.0) );\n            if( hash1(fid*13.1)>0.85 )\n            {\n                col = 1.0 - 0.9*col;\n                col.xy += 0.2;\n            }\n        }\n        \n        cen = vec2( -1.0 + float(id.x)*brickW + 0.5*brickW,\n                     1.0 - float(id.y)*brickH - 0.5*brickH );\n    }\n\n    return alp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord.xy) \/ iResolution.y;\n    float px = 2.0\/iResolution.y;\n    \n    \/\/------------------------\n    \/\/ load game state\n    \/\/------------------------\n    vec2  ballPos   = texture2D( iChannel0, (txBallPosVel+0.5)\/iChannelResolution[0].xy ).xy;\n    float paddlePos = texture2D( iChannel0, (txPaddlePos+0.5)\/iChannelResolution[0].xy ).x;\n    float points    = texture2D( iChannel0, (txPoints+0.5)\/iChannelResolution[0].xy ).x;\n    float state     = texture2D( iChannel0, (txState+0.5)\/iChannelResolution[0].xy ).x;\n    vec3  lastHit   = texture2D( iChannel0, (0.5+txLastHit)\/iChannelResolution[0].xy, -100.0 ).xyz;\n\n    \n    \/\/------------------------\n    \/\/ draw\n    \/\/------------------------\n    vec3 col = vec3(0.0);\n    vec3 emi = vec3(0.0);\n    \n    \/\/ board\n    {\n        col = 0.6*vec3(0.4,0.6,0.7)*(1.0-0.4*length( uv ));\n        col *= 1.0 - 0.1*smoothstep( 0.0,1.0,sin(uv.x*80.0)*sin(uv.y*80.0))*(1.0 - smoothstep( 1.0, 1.01, abs(uv.x) ) );\n    }    \n\n    \/\/ bricks\n    {\n        float b = brickW*0.17;\n\n        \/\/ soft shadow\n        {\n            vec2 st = uv + shadowOffset;\n            vec2 id = floor( vec2( (1.0+st.x)\/brickW, (1.0-st.y)\/brickH) );\n\n            vec3 bcol; vec2 bcen; float bglo;\n\n            float sha = 0.0;\n            for( int j=-1; j<=1; j++ )\n        \tfor( int i=-1; i<=1; i++ )\n        \t{\n                vec2 idr = id + vec2(float(i), float(j) );\n                float alp = doBrick( idr, bcol, bglo, bcen );\n                float f = udRoundBox( st, bcen, 0.5*vec2(brickW,brickH)-b, b );\n                float s = 1.0 - smoothstep( -brickH*0.5, brickH*1.0, f ); \n                s = mix( 0.0, s, alp );\n                sha = max( sha, s );\n            }\n            col = mix( col, col*0.4, sha );\n        }\n    \n\n        vec2 id = floor( vec2( (1.0+uv.x)\/brickW, (1.0-uv.y)\/brickH) );\n        \n        \/\/ shape\n        {\n            vec3 bcol; vec2 bcen; float bglo;\n            float alp = doBrick( id, bcol, bglo, bcen );\n            if( alp>0.0001 )\n            {\n                float f = udRoundBox( uv, bcen, 0.5*vec2(brickW,brickH)-b, b );\n                bglo  += 0.6*smoothstep( -4.0*px, 0.0, f );\n\n                bcol *= 0.7 + 0.3*smoothstep( -4.0*px, -2.0*px, f );\n                bcol *= 0.5 + 1.7*bglo;\n                col = mix( col, bcol, alp*(1.0-smoothstep( -px, px, f )) );\n            }\n        }\n        \n        \/\/ gather glow\n        for( int j=-1; j<=1; j++ )\n        for( int i=-1; i<=1; i++ )\n        {\n            vec2 idr = id + vec2(float(i), float(j) );\n            vec3 bcol = vec3(0.0); vec2 bcen; float bglo;\n            float alp = doBrick( idr, bcol, bglo, bcen );\n            float f = udRoundBox( uv, bcen, 0.5*vec2(brickW,brickH)-b, b );\n            emi += bcol*bglo*exp(-600.0*f*f);\n        }\n    }    \n    \n    \n    \/\/ ball \n    {\n        float hit = exp(-4.0*(iGlobalTime-lastHit.y) );\n\n        \/\/ shadow\n        float f = 1.0-smoothstep( ballRadius*0.5, ballRadius*2.0, length( uv - ballPos + shadowOffset ) );\n        col = mix( col, col*0.4, f );\n\n        \/\/ shape\n        f = length( uv - ballPos ) - ballRadius;\n        vec3 bcol = vec3(1.0,0.6,0.2);\n        bcol *= 1.0 + 0.7*smoothstep( -3.0*px, -1.0*px, f );\n        bcol *= 0.7 + 0.3*hit;\n        col = mix( col, bcol, 1.0-smoothstep( 0.0, px, f ) );\n        \n        emi  += bcol*0.75*hit*exp(-500.0*f*f );\n    }\n    \n    \n    \/\/ paddle\n    {\n        float hit = exp(-4.0*(iGlobalTime-lastHit.x) ) * sin(20.0*(iGlobalTime-lastHit.x));\n        float hit2 = exp(-4.0*(iGlobalTime-lastHit.x) );\n        float y = uv.y + 0.04*hit * (1.0-pow(abs(uv.x-paddlePos)\/(paddleSize*0.5),2.0));\n\n        \/\/ shadow\n        float f = udHorizontalSegment( vec2(uv.x,y)+shadowOffset, paddlePos-paddleSize*0.5,paddlePos+paddleSize*0.5,paddlePosY );\n        f = 1.0-smoothstep( paddleWidth*0.5*0.5, paddleWidth*0.5*2.0, f );\n        col = mix( col, col*0.4, f );\n\n        \/\/ shape\n        f = udHorizontalSegment( vec2(uv.x,y), paddlePos-paddleSize*0.5, paddlePos+paddleSize*0.5,paddlePosY ) - paddleWidth*0.5;\n        vec3 bcol = vec3(1.0,0.6,0.2);\n        bcol *= 1.0 + 0.7*smoothstep( -3.0*px, -1.0*px, f );\n        bcol *= 0.7 + 0.3*hit2;\n        col = mix( col, bcol, 1.0-smoothstep( -px, px, f ) );\n        emi  += bcol*0.75*hit2*exp( -500.0*f*f );\n\n    }\n\n    \n    \/\/ borders\n    {\n        float f = abs(abs(uv.x)-1.02);\n        f = min( f, udHorizontalSegment(uv,-1.0,1.0,1.0) );\n        f *= 2.0;\n        float a = 0.8 + 0.2*sin(2.6*iGlobalTime) + 0.1*sin(4.0*iGlobalTime);\n        float hit  = exp(-4.0*(iGlobalTime-lastHit.z) );\n        \/\/\n        a *= 1.0-0.3*hit;\n        col += a*0.5*vec3(0.6,0.30,0.1)*exp(- 30.0*f*f);\n        col += a*0.5*vec3(0.6,0.35,0.2)*exp(-150.0*f*f);\n        col += a*1.7*vec3(0.6,0.50,0.3)*exp(-900.0*f*f);\n    }\n    \n    \/\/ score\n    {\n        float f = PrintInt( (uv-vec2(-1.5,0.8))*10.0, points );\n        col = mix( col, vec3(1.0,1.0,1.0), f );\n    }\n    \n    \n    \/\/ add emmission\n    col += emi;\n    \n\n    \/\/------------------------\n    \/\/ game over\n    \/\/------------------------\n    col = mix( col, vec3(1.0,0.5,0.2), state * (0.5+0.5*sin(30.0*iGlobalTime)) );\n\n    fragColor = vec4(col,1.0);\n}",
                "name": "",
                "description": "",
                "type": "image"
            },

            {
                "inputs": 
                [
                    {
                        "id": 33,
                        "src": "\/presets\/tex00.jpg",
                        "ctype": "keyboard",
                        "channel": 1,
                        "sampler": 
                        {
                            "filter": "nearest",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        }
                    },

                    {
                        "id": 257,
                        "src": "\/presets\/previz\/buffer00.png",
                        "ctype": "buffer",
                        "channel": 0,
                        "sampler": 
                        {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        }
                    }
                ],

                "outputs": 
                [
                    {
                        "channel": "0"
                    }
                ],

                "code": "\/\/ Created by inigo quilez - iq\/2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\/\/\n\/\/ Gameplay computation.\n\/\/\n\/\/ The gameplay buffer is 14x14 pixels. The whole game is run\/played for each one of these\n\/\/ pixels. A filter in the end of the shader takes only the bit  of infomration that needs \n\/\/ to be stored in each texl of the game-logic texture.\n\n\/\/ storage register\/texel addresses\nconst vec2 txBallPosVel = vec2(0.0,0.0);\nconst vec2 txPaddlePos  = vec2(1.0,0.0);\nconst vec2 txPoints     = vec2(2.0,0.0);\nconst vec2 txState      = vec2(3.0,0.0);\nconst vec2 txLastHit    = vec2(4.0,0.0);\nconst vec4 txBricks     = vec4(0.0,1.0,13.0,12.0);\n\nconst float ballRadius = 0.035;\nconst float paddleSize = 0.30;\nconst float paddleWidth = 0.06;\nconst float paddlePosY  = -0.90;\nconst float brickW = 2.0\/13.0;\nconst float brickH = 1.0\/15.0;\n\nconst float gameSpeed =  3.0;\nconst float inputSpeed = 2.0;\n\nconst float KEY_SPACE = 32.5\/256.0;\nconst float KEY_LEFT  = 37.5\/256.0;\nconst float KEY_UP    = 38.5\/256.0;\nconst float KEY_RIGHT = 39.5\/256.0;\nconst float KEY_DOWN  = 40.5\/256.0;\n\n\/\/----------------------------------------------------------------------------------------------\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nfloat isInside( vec2 p, vec4 c ) { vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y); }\n\nfloat hash1( float n ) { return fract(sin(n)*138.5453123); }\n\n\/\/ intersect a disk sweept in a linear segment with a line\/plane. \nfloat iPlane( in vec2 ro, in vec2 rd, float rad, vec3 pla )\n{\n    float a = dot( rd, pla.xy );\n    if( a>0.0 ) return -1.0;\n    float t = (rad - pla.z - dot(ro,pla.xy)) \/ a;\n    if( t>=1.0 ) t=-1.0;\n    return t;\n}\n\n\/\/ intersect a disk sweept in a linear segment with a box \nvec3 iBox( in vec2 ro, in vec2 rd, in float rad, in vec2 bce, in vec2 bwi ) \n{\n    vec2 m = 1.0\/rd;\n    vec2 n = m*(ro - bce);\n    vec2 k = abs(m)*(bwi+rad);\n    vec2 t1 = -n - k;\n    vec2 t2 = -n + k;\n\tfloat tN = max( t1.x, t1.y );\n\tfloat tF = min( t2.x, t2.y );\n\tif( tN > tF || tF < 0.0) return vec3(-1.0);\n    if( tN>=1.0 ) return vec3(-1.0);\n\tvec2 nor = -sign(rd)*step(t1.yx,t1.xy);\n\treturn vec3( tN, nor );\n}\n\n\/\/----------------------------------------------------------------------------------------------\n\nvec4 loadValue( in vec2 re )\n{\n    return texture2D( iChannel0, (0.5+re) \/ iChannelResolution[0].xy, -100.0 );\n}\n\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\nvoid storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\n\/\/----------------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ don't compute gameplay outside of the data area\n    if( fragCoord.x > 14.0 || fragCoord.y>14.0 ) discard;\n    \n    \/\/---------------------------------------------------------------------------------   \n\t\/\/ load game state\n\t\/\/---------------------------------------------------------------------------------\n    vec4  balPosVel = loadValue( txBallPosVel );\n    float paddlePos = loadValue( txPaddlePos ).x;\n    float points    = loadValue( txPoints ).x;\n    float state     = loadValue( txState ).x;\n    vec3  lastHit   = loadValue( txLastHit ).xyz;        \/\/ paddle, brick, wall\n    vec2  brick     = loadValue( fragCoord.xy-0.5 ).xy;  \/\/ visible, hittime\n\t\n    \/\/---------------------------------------------------------------------------------\n    \/\/ reset\n\t\/\/---------------------------------------------------------------------------------\n\tif( iFrame==0 ) state = -1.0;\n\t\n    if( state < -0.5 )\n    {\n        state = 0.0;\n        balPosVel = vec4(0.0,paddlePosY+ballRadius+paddleWidth*0.5+0.001, 0.6,1.0);\n        paddlePos = 0.0;\n        points = 0.0;\n        state = 0.0;\n        brick = vec2(1.0,-5.0);\n        lastHit = vec3(-1.0);\n        \n        \n        if( fragCoord.x<1.0 || fragCoord.x>12.0 )\n        {\n            brick.x = 0.0;\n            brick.y = -10.0;\n        }\n        \n\n    }\n\n    \/\/---------------------------------------------------------------------------------\n    \/\/ do game\n    \/\/---------------------------------------------------------------------------------\n\n    \/\/ game over (or won), wait for space key press to resume\n    if( state > 0.5 )\n    {\n        float pressSpace = texture2D( iChannel1, vec2(KEY_SPACE,0.25) ).x;\n        if( pressSpace>0.5 )\n        {\n            state = -1.0;\n        }\n    }\n    \n    \/\/ if game mode (not game over), play game\n    else if( state < 0.5 ) \n\t{\n\n        \/\/-------------------\n        \/\/ paddle\n        \/\/-------------------\n        float oldPaddlePos = paddlePos;\n        if( iMouse.w>0.01 )\n        {\n            \/\/ move with mouse\n            paddlePos = (-1.0 + 2.0*iMouse.x\/iResolution.x)*iResolution.x\/iResolution.y;\n        }\n        else\n        {\n            \/\/ move with keyboard\n            float moveRight = texture2D( iChannel1, vec2(KEY_RIGHT,0.25) ).x;\n            float moveLeft  = texture2D( iChannel1, vec2(KEY_LEFT,0.25) ).x;\n            paddlePos += 0.02*inputSpeed*(moveRight - moveLeft);\n        }\n        paddlePos = clamp( paddlePos, -1.0+0.5*paddleSize+paddleWidth*0.5, 1.0-0.5*paddleSize-paddleWidth*0.5 );\n\n        float moveTotal = sign( paddlePos - oldPaddlePos );\n\n        \/\/-------------------\n        \/\/ ball\n\t\t\/\/-------------------\n        float dis = 0.01*gameSpeed;\n        \n        \/\/ do up to 3 sweep collision detections (usually 0 or 1 will happen only)\n        for( int j=0; j<3; j++ )\n        {\n            vec3 oid = vec3(-1.0);\n            vec2 nor;\n            float t = 1000.0;\n\n            \/\/ test walls\n            const vec3 pla1 = vec3(-1.0, 0.0,1.0 ); \n            const vec3 pla2 = vec3( 1.0, 0.0,1.0 ); \n            const vec3 pla3 = vec3( 0.0,-1.0,1.0 ); \n            float t1 = iPlane( balPosVel.xy, dis*balPosVel.zw, ballRadius, pla1 ); if( t1>0.0         ) { t=t1; nor = pla1.xy; oid.x=1.0; }\n            float t2 = iPlane( balPosVel.xy, dis*balPosVel.zw, ballRadius, pla2 ); if( t2>0.0 && t2<t ) { t=t2; nor = pla2.xy; oid.x=2.0; }\n            float t3 = iPlane( balPosVel.xy, dis*balPosVel.zw, ballRadius, pla3 ); if( t3>0.0 && t3<t ) { t=t3; nor = pla3.xy; oid.x=3.0; }\n            \n            \/\/ test paddle\n            vec3  t4 = iBox( balPosVel.xy, dis*balPosVel.zw, ballRadius, vec2(paddlePos,paddlePosY), vec2(paddleSize*0.5,paddleWidth*0.5) );\n            if( t4.x>0.0 && t4.x<t ) { t=t4.x; nor = t4.yz; oid.x=4.0;  }\n            \n            \/\/ test bricks\n            vec2 idr = floor( vec2( (1.0+balPosVel.x)\/brickW, (1.0-balPosVel.y)\/brickH) );\n            vec2 vs = sign(balPosVel.zw);\n            for( int j=0; j<3; j++ )\n            for( int i=0; i<3; i++ )\n            {\n                vec2 id = idr + vec2( vs.x*float(i),-vs.y*float(j));\n                if( id.x>=0.0 && id.x<13.0 && id.y>=0.0 && id.y<12.0 )\n                {\n                    float brickHere = texture2D( iChannel0, (0.5+txBricks.xy+id)\/iChannelResolution[0].xy, -100.0 ).x;\n                    if( brickHere>0.5 )\n                    {\n                        vec2 ce = vec2( -1.0 + float(id.x)*brickW + 0.5*brickW,\n                                         1.0 - float(id.y)*brickH - 0.5*brickH );\n                        vec3 t5 = iBox( balPosVel.xy, dis*balPosVel.zw, ballRadius, ce, 0.5*vec2(brickW,brickH) );\n                        if( t5.x>0.0 && t5.x<t )\n                        {\n                            oid = vec3(5.0,id);\n                            t = t5.x;\n                            nor = t5.yz;\n                        }\n                    }\n                }\n            }\n    \n            \/\/ no collisions\n            if( oid.x<0.0 ) break;\n\n            \n            \/\/ bounce\n            balPosVel.xy += t*dis*balPosVel.zw;\n            dis *= 1.0-t;\n            \n            \/\/ did hit walls\n            if( oid.x<3.5 )\n            {\n                balPosVel.zw = reflect( balPosVel.zw, nor );\n                lastHit.z = iGlobalTime;\n            }\n            \/\/ did hit paddle\n            else if( oid.x<4.5 )\n            {\n                balPosVel.zw = reflect( balPosVel.zw, nor );\n                \/\/ borders bounce back\n                     if( balPosVel.x > (paddlePos+paddleSize*0.5) ) balPosVel.z =  abs(balPosVel.z);\n                else if( balPosVel.x < (paddlePos-paddleSize*0.5) ) balPosVel.z = -abs(balPosVel.z);\n                balPosVel.z += 0.37*moveTotal;\n                balPosVel.z += 0.11*hash1( float(iFrame)*7.1 );\n                balPosVel.z = clamp( balPosVel.z, -0.9, 0.9 );\n                balPosVel.zw = normalize(balPosVel.zw);\n                \n                \/\/ \n                lastHit.x = iGlobalTime;\n                lastHit.y = iGlobalTime;\n            }\n            \/\/ did hit a brick\n            else if( oid.x<5.5 )\n            {\n                balPosVel.zw = reflect( balPosVel.zw, nor );\n                lastHit.y = iGlobalTime;\n                points += 1.0;\n                if( points>131.5 )\n                {\n                    state = 2.0; \/\/ won game!\n                }\n\n                if( isInside(fragCoord,txBricks.xy+oid.yz) > 0.0 )\n                {\n                    brick = vec2(0.0, iGlobalTime);\n                }\n            }\n        }\n        \n        balPosVel.xy += dis*balPosVel.zw;\n        \n        \/\/ detect miss\n        if( balPosVel.y<-1.0 )\n        {\n            state = 1.0; \/\/ game over\n        }\n    }\n    \n\t\/\/---------------------------------------------------------------------------------\n\t\/\/ store game state\n\t\/\/---------------------------------------------------------------------------------\n    fragColor = vec4(0.0);\n \n    storeValue( txBallPosVel, vec4(balPosVel),             fragColor, fragCoord );\n    storeValue( txPaddlePos,  vec4(paddlePos,0.0,0.0,0.0), fragColor, fragCoord );\n    storeValue( txPoints,     vec4(points,0.0,0.0,0.0),    fragColor, fragCoord );\n    storeValue( txState,      vec4(state,0.0,0.0,0.0),     fragColor, fragCoord );\n    storeValue( txLastHit,    vec4(lastHit,0.0),           fragColor, fragCoord );\n    storeValue( txBricks,     vec4(brick,0.0,0.0),         fragColor, fragCoord );\n}",
                "name": "",
                "description": "",
                "type": "buffer"
            }
        ]
    }
}