{"Shader":{"ver":"0.1","info":{"id":"lscGzB","date":"1450801571","viewed":252,"name":"TinyWings","username":"skaven","description":"Test shader that recreates visuals from Tiny Wings. Click in view to change palette.","likes":13,"published":3,"flags":0,"tags":["2d","wings","tiny"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\nfloat pi = 3.14159265358979;\n\n\/\/ parameters\nconst float gradientAngle = 25.0; \/\/ degrees\nconst vec2 lumSatOffset = vec2(0.1,0.0); \/\/ range [-1..1]\nconst float lumSatAngle = 110.0; \/\/ degrees\nconst float lumSatFactor = 0.4;\/\/ range [0..1]\nconst float NoiseFactor = 0.20; \/\/ range [0..1]\nconst float SmoothStepBase = 0.22; \/\/ range[0..0.25]\nconst float TextureSliceFactor = 0.4; \/\/ range [0..1]\nconst float StrideFactor = -3.1; \/\/ range[-inf..+inf]\nconst float GroundSaturation = 2.0; \/\/ range [0..1]\n\nvec3 hsv2rgb (in vec3 hsv) \n{\n    return hsv.z * (1.0 + 0.5 * hsv.y * (cos (6.2832 * (hsv.x + vec3 (0.0, 0.6667, 0.3333))) - 1.0));\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 \/ 3.0, 2.0 \/ 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) \/ (6.0 * d + e)), d \/ (q.x + e), q.x);\n}\n\nvec3 baseColor(vec2 uv)\n{\n\tvec3 col = vec3(max(uv.y,0.0)+max(uv.x,0.0),max(-uv.y,0.0)+max(uv.x,0.0),max(-uv.x,0.0));\n    return col;\n}\n\n\nvec2 screenToWorld(vec2 screenPos)\n{\n    vec2 uv = screenPos.xy \/ iResolution.xy - vec2(0.5);\n    uv *= vec2(iResolution.x\/iResolution.y, 1.0);\n    \/\/uv += vec2(0.4, 0.0);\n    return uv;\n}        \n\n\nvec2 rotate(vec2 xy, float angle)\n{\n    float sn = sin(angle);\n    float cs = cos(angle);\n    return vec2(xy.x*cs-xy.y*sn, xy.y*cs + xy.x*sn);\n}\n\nfloat degToRad(float angle)\n{\n    return angle * pi * (1.0\/180.0);\n}\n\n\/\/\/\/\/\/\/\n\nvec2 hash22(vec2 p)\n{\n    p = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)));\n    \n    return -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n}\n\n\nfloat hash21(vec2 p)\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\n\t\n    return -1.0 + 2.0 * fract(sin(h)*43758.5453123);\n}\n\nfloat perlin_noise(vec2 p)\n{\n    vec2 pi = floor(p);\n    vec2 pf = p - pi;\n    \n    vec2 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return mix(mix(dot(hash22(pi + vec2(0.0, 0.0)), pf - vec2(0.0, 0.0)), \n                   dot(hash22(pi + vec2(1.0, 0.0)), pf - vec2(1.0, 0.0)), w.x), \n               mix(dot(hash22(pi + vec2(0.0, 1.0)), pf - vec2(0.0, 1.0)), \n                   dot(hash22(pi + vec2(1.0, 1.0)), pf - vec2(1.0, 1.0)), w.x),\n               w.y);\n}\n\nfloat value_noise(vec2 p)\n{\n    vec2 pi = floor(p);\n    vec2 pf = p - pi;\n    \n    vec2 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return mix(mix(hash21(pi + vec2(0.0, 0.0)), hash21(pi + vec2(1.0, 0.0)), w.x),\n               mix(hash21(pi + vec2(0.0, 1.0)), hash21(pi + vec2(1.0, 1.0)), w.x),\n               w.y);\n}\n\nfloat getTex(float u)\n{\n    u = mod(u,1.0);\n    float v = u - mod(u, (TextureSliceFactor+abs(sin(u*6.15159))*0.01));\n    return v-mod(v, 0.1);\n}\n\nfloat getTex2(float u)\n{\n    float res = 0.0;\n    \n    for (int t = 0;t<6;t++)\n        res += getTex(u+float(t)*0.0011);\n    return res\/6.0;\n}\n\nfloat getGroundHeight(float x)\n{\n    return sin(x*3.0) * 0.2 + sin(x * 6.17+4740.14) * 0.1 + sin(x * 10.987+19.19) * 0.05 + 0.3;\n}\n\nvec3 getWorldColor(vec2 uv, vec2 hueSelection)\n{\n    float c = getTex2(uv.x*4.0 + uv.y*StrideFactor)+0.2; \n    \n    vec3 colPalette=vec3(0.0);\n    \n    float angles[4];\n    angles[0] = 0.0;\n\tangles[1] = gradientAngle;\n    angles[2] = 180.0;\n    angles[3] = 180.0+gradientAngle;\n    \n    for (int i=0;i<4;i++)\n    {\n        vec2 dir = rotate(hueSelection, degToRad(angles[i]));\n\t\tfloat ifl = float(i);\n        vec3 baseColorHSV = rgb2hsv(baseColor(dir));\n        colPalette = mix(colPalette, hsv2rgb(vec3(baseColorHSV.r, 0.3,0.6)), smoothstep(SmoothStepBase*ifl, 0.25*ifl, c));\n    }\n    colPalette = mix(colPalette, vec3(dot(colPalette, vec3(0.299, 0.587, 0.114))), 1.0-GroundSaturation);\n    uv.y = 1.0-uv.y;\n    vec2 noisePos = uv;\n    float noise = perlin_noise(noisePos*10.0) + perlin_noise(noisePos*20.0)*0.8 + perlin_noise(noisePos*40.0)*0.6 + perlin_noise(noisePos*80.0)*0.4;\n\n    \n    float intens = max(pow(0.5, (uv.y-0.10)*9.0), 0.20);\n    float unoise = noise*NoiseFactor+(1.0-NoiseFactor);\n    \n    vec3 recompBase = colPalette*intens*unoise;\n    vec3 recomp = mix(recompBase, vec3(1.0), max(intens*0.9-1.0, 0.0));\n    return recomp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    \n\tvec2 hueSelection = screenToWorld(iMouse.xy);\n    hueSelection = normalize(hueSelection);\n\n    vec3 colSkyHSV = rgb2hsv(baseColor(rotate(hueSelection, degToRad(-gradientAngle*1.5))));\n    vec3 colSky = hsv2rgb(vec3(colSkyHSV.r, 0.2, 0.65));\n    \n    const float globalTimeFactor = 0.6;\n    float iTime = iGlobalTime * globalTimeFactor;\n    \n    float pos1 = uv.x + iTime*0.3;\n    float pos2 = uv.x + iTime*0.1;\n    \n    float camHeight = (getGroundHeight(iTime*0.3 + 0.5) + getGroundHeight(iTime*0.3 + 0.1) + getGroundHeight(iTime*0.3 + 0.9)) \/ 3.0;\n        \n    float height1 = uv.y + getGroundHeight(pos1) + 0.6 - camHeight;\n    float height2 = uv.y + getGroundHeight(pos2) + 0.0 - camHeight*0.5;\n    \n    vec3 recomp1 = getWorldColor(vec2(pos1, height1), hueSelection);\n    vec3 recomp2 = mix(colSky, getWorldColor(vec2(pos2, height2), hueSelection), 0.4);\n\n    float pixelSize = 2.0\/iResolution.y;\n\n    \n\tvec3 layer1 = mix(colSky, mix(vec3(0.55), recomp2, smoothstep(0.0, pixelSize, 1.0-height2)), smoothstep(-pixelSize, 0.0, 1.0-height2));\n\tvec3 layer2 = mix(vec3(0.2), recomp1, smoothstep(0.0, pixelSize, 1.0-height1));\n\tfragColor = vec4(mix(layer1, layer2, smoothstep(-pixelSize, 0.0, 1.0-height1)), 1.0);\n}","name":"","description":"","type":"image"}]}}