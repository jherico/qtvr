{"Shader":{"ver":"0.1","info":{"id":"Ml23Dt","date":"1433798298","viewed":346,"name":"Interpolation: Bezier, Quadratic","username":"4rknova","description":"Quadratic Bezier interpolation.<br\/>Note that I use line segments, not the curve distance field.","likes":6,"published":3,"flags":0,"tags":["bezier","interpolation"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ by Nikos Papadopoulos, 4rknova \/ 2015\n\/\/ Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define ANIMATED\n#define SHOW_CONTROL_POINTS\n\/\/#define SHOW_SEGMENT_POINTS\n\/\/#define MOUSE_ENABLED \n\/\/#define AA 4.\n\n#define STEPS  20.\n#define STROKE .8\n\n#define EPS    .01\n\n#define COL0 vec3(.2, .35, .55)\n#define COL1 vec3(.9, .43, .34)\n#define COL3 vec3(1.)\n\nfloat df_circ(in vec2 p, in vec2 c, in float r)\n{\n    return abs(r - length(p - c));\n}\n\nfloat df_line(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) \/ dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\n\nfloat sharpen(in float d, in float w)\n{\n    float e = 1. \/ min(iResolution.y , iResolution.x);\n    return 1. - smoothstep(-e, e, d - w);\n}\n\nvec2 bezier(vec2 a, vec2 b, vec2 c, float p)\n{\n    vec2 v0 = mix(a, b, p);\n    vec2 v1 = mix(b, c, p);\n    return mix(v0, v1, p);\n}\n\nfloat ip_control(vec2 uv, vec2 a, vec2 b, vec2 c)\n{    \n    float cp = 0.;\n    \n#ifdef SHOW_CONTROL_POINTS    \n    float c0 = sharpen(df_circ(uv, a, .02), EPS * .75);\n    float c1 = sharpen(df_circ(uv, b, .02), EPS * .75);\n    float c2 = sharpen(df_circ(uv, c, .02), EPS * .75);\n    \n    float l0 = sharpen(df_line(uv, a, b), EPS * .6);\n    float l1 = sharpen(df_line(uv, b, c), EPS * .6);\n    \n    cp = max(max(max(c0, c1), c2),\n\t         max(l0, l1));\n#endif\n\n    return cp;\n}\n\nfloat ip_point(vec2 uv, vec2 a, vec2 b, vec2 c)\n{\n    vec2 p = bezier(a, b, c, mod(iGlobalTime * 2., 10.) \/ 10.);\n    return sharpen(df_circ(uv, p, .025), EPS * 1.);\n}\n\nfloat ip_bzcurve(vec2 uv, vec2 a, vec2 b, vec2 c)\n{ \n    float e = 0.;\n    for (float i = 0.; i < STEPS; ++i)\n    {\n        vec2  p0 = bezier(a, b, c, (i   ) \/ STEPS);\n        vec2  p1 = bezier(a, b, c, (i+1.) \/ STEPS);\n#ifdef SHOW_SEGMENT_POINTS        \n        float m = sharpen(df_circ(uv, p0, .01), EPS * .5);\n        float n = sharpen(df_circ(uv, p1, .01), EPS * .5);\n        e = max(e, max(m, n));\n#endif\n        float l = sharpen(df_line(uv, p0, p1), EPS * STROKE);\n        e = max(e, l);\n    }\n                \n    return e;\n}\n\nvec3 scene(in vec2 uv, in vec2 a, in vec2 b, in vec2 c)\n{\n    float d0 = ip_control(uv, a, b, c);\n    float point = 0.;\n    \n#ifdef ANIMATED\n    point = ip_point(uv, a, b, c);\n#endif\n    \n    float d1 = ip_bzcurve(uv, a, b, c);\n    float rs = max(d0, d1);\n    \n    return (point < .5)\n        ? rs * (d0 > d1 ? COL0 : COL1)\n        : point * COL3;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy \/ iResolution.xy * 2. - 1.);\n    uv.x *= iResolution.x \/ iResolution.y;\n    vec3 col = vec3(0);\n    \n    vec2 a = vec2(-.75,-.75);\n    vec2 b = vec2( .00, .75);\n    vec2 c = vec2( .75,-.75);\n    \n#ifdef MOUSE_ENABLED        \n    a = (iMouse.xy \/ iResolution.xy * 2. - 1.)\n           * vec2(iResolution.x \/ iResolution.y, 1.);\n#endif\n    \n#ifdef AA\n    \/\/ Antialiasing via supersampling\n    float e = 1. \/ min(iResolution.y , iResolution.x);    \n    for (float i = -AA; i < AA; ++i) {\n        for (float j = -AA; j < AA; ++j) {\n    \t\tcol += scene(uv + vec2(i, j) * (e\/AA), a, b, c) \/ (4.*AA*AA);\n        }\n    }\n#else\n    col += scene(uv, a, b, c);\n#endif \/* AA *\/\n    \n\tfragColor = vec4(col, 1);\n}","name":"","description":"","type":"image"}]}}