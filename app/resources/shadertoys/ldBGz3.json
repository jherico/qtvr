{"Shader":{"ver":"0.1","info":{"id":"ldBGz3","date":"1391752598","viewed":1319,"name":"Oren-Nayar","username":"iq","description":"Oren-Nayar diffuse model, compared to regular Lambert","likes":15,"published":3,"flags":0,"tags":["shading","model","material","orennayar"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/-----------------------------------------------------------------\n\nfloat Lambert( in vec3 l, in vec3 n )\n{\n    float nl = dot(n, l);\n\t\n    return max(0.0,nl);\n}\n\nfloat OrenNayar( in vec3 l, in vec3 n, in vec3 v, float r )\n{\n\t\n    float r2 = r*r;\n    float a = 1.0 - 0.5*(r2\/(r2+0.57));\n    float b = 0.45*(r2\/(r2+0.09));\n\n    float nl = dot(n, l);\n    float nv = dot(n, v);\n\n    float ga = dot(v-n*nv,n-n*nl);\n\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) \/ max(nl, nv));\n}\n\n\/\/-----------------------------------------------------------------\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\nfloat ssSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = sph.xyz - ro;\n    float b = dot( oc, rd );\n\t\n    float res = 1.0;\n    if( b>0.0 ) \/\/ este branch se puede quitar seguramente\n    {\n        float h = dot(oc,oc) - b*b - sph.w*sph.w;\n        res = clamp( 16.0 * h \/ b, 0.0, 1.0 );\n    }\n    return res;\n}\n\n\nfloat oSphere( in vec3 pos, in vec3 nor, in vec4 sph )\n{\n    vec3 di = sph.xyz - pos;\n    float l = length(di);\n    return 1.0 - max(0.0,dot(nor,di\/l))*sph.w*sph.w\/(l*l); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) \/ iResolution.y;\n\n\tvec3 lig = normalize( vec3( 0.6, 0.5, 0.4) );\n\tvec3 bac = normalize( vec3(-0.6, 0.0,-0.4) );\n\tvec3 bou = normalize( vec3( 0.0,-1.0, 0.0) );\n\t\n     \/\/ camera movement\t\n\tfloat an = 0.6 - 0.5*iGlobalTime;\n\tvec3 ro = vec3( 3.5*cos(an), 1.0, 3.5*sin(an) );\n    vec3 ta = vec3( 0.0, 1.0, 0.0 );\n    \/\/ camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t\/\/ create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    \/\/ sphere center\t\n\tvec4 sph1 = vec4(-1.2,1.0,0.0,1.0);\n\tvec4 sph2 = vec4( 1.2,1.0,0.0,1.0);\n\n    \/\/ raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tfloat occ = 1.0;\n\tvec3  pos = vec3(0.0);\n\tfloat obj = 0.0;\n\t\n\t\/\/ raytrace-plane\n\tfloat h = (0.0-ro.y)\/rd.y;\n\tif( h>0.0 ) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.0,1.0,0.0); \n\t\tpos = ro + h*rd;\n\t\tocc = oSphere( pos, nor, sph1 ) *\n\t\t\t  oSphere( pos, nor, sph2 );\n\t    obj = 0.0;\n\t}\n\n\t\/\/ raytrace-sphere\n\th = iSphere( ro, rd, sph1 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n\t\tpos = ro + h*rd;\n\t\tnor = normalize(pos-sph1.xyz); \n\t\tocc = (0.5 + 0.5*nor.y) *\n\t\t\t  oSphere( pos, nor, sph2 );\n\t    obj = 1.0;\n\t}\n\th = iSphere( ro, rd, sph2 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n\t\tpos = ro + h*rd;\n\t\tnor = normalize(pos-sph2.xyz); \n\t\tocc = (0.5 + 0.5*nor.y) *\n\t\t\t  oSphere( pos, nor, sph1 );\n\t    obj = 2.0;\n\t}\n\n    \/\/ shading\/lighting\t\n\tvec3 col = vec3(0.93);\n\tif( tmin<100.0 )\n\t{\n\t    pos = ro + tmin*rd;\n\t\t\n        \/\/ shadows\n\t\tfloat sha = 1.0;\n\t\tsha *= ssSphere( pos, lig, sph1 );\n\t\tsha *= ssSphere( pos, lig, sph2 );\n\n\t\tvec3 lin = vec3(0.0);\n\t\t\n\t\t\/\/ integrate irradiance with brdf times visibility\n\t\tvec3 diffColor = vec3(0.18);\n\t\tif( obj>1.5 )\n\t\t{\n            lin += vec3(0.5,0.7,1.0)*diffColor*occ;\n\t        lin += vec3(5.0,4.5,4.0)*diffColor*OrenNayar( lig, nor, rd, 1.0 )*sha;\n\t        lin += vec3(1.5,1.5,1.5)*diffColor*OrenNayar( bac, nor, rd, 1.0 )*occ;\n\t        lin += vec3(1.0,1.0,1.0)*diffColor*OrenNayar( bou, nor, rd, 1.0 )*occ;\n\t\t}\n\t\telse\n\t\t{\n            lin += vec3(0.5,0.7,1.0)*diffColor*occ;\n\t        lin += vec3(5.0,4.5,4.0)*diffColor*Lambert( lig, nor )*sha;\n\t        lin += vec3(1.5,1.5,1.5)*diffColor*Lambert( bac, nor )*occ;\n\t\t\tlin += vec3(1.0,1.0,1.0)*diffColor*Lambert( bou, nor )*occ;\n\t\t}\n\n\t\tcol = lin;\n\t\t\n\t\t\/\/ participating media\n\t\tcol = mix( col, vec3(0.93), 1.0-exp( -0.002*tmin*tmin ) );\n\t}\n\t\n    \/\/ gamma\t\n\tcol = pow( col, vec3(0.45) );\n\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}