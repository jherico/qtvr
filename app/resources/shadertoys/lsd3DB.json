{"Shader":{"ver":"0.1","info":{"id":"lsd3DB","date":"1452074148","viewed":289,"name":"JCVD 3D","username":"jackdavenport","description":"Use a chroma key to create an alpha mask, and then uses that alpha mask to texture a 3D object and create shadows. There's some oddities sometimes, but I'm pretty happy with the results.","likes":2,"published":3,"flags":32,"tags":["3d","shadow","lighting","raymarcher","mask","alpha","composite","jcvd"],"hasliked":0},"renderpass":[{"inputs":[{"id":22,"src":"\/presets\/cube00_0.jpg","ctype":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define MAX_ITERATIONS 256\n#define MIN_DISTANCE  .001\n#define LIGHT_DIR normalize(vec3(45.,60.,-45.))\n\nstruct Ray { vec3 ori; vec3 dir; };\nstruct Dist { float dst; int id; };\nstruct Hit { vec3 p; int id; };\n  \n\/\/ Source: http:\/\/stackoverflow.com\/questions\/4200224\/random-noise-functions-for-glsl\nfloat rand(vec2 co) {\n    \n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n\n}\n\nvec2 rot2D(vec2 p, float angle) {\n\n\tfloat s = sin(radians(angle));\n\tfloat c = cos(radians(angle));\n\treturn p * mat2(c,-s,s,c);\n\n}\n\nDist distBox(vec3 p, vec3 pos, vec3 box) {\n\n\treturn Dist(length(max(abs(pos - p) - box,0.)), 0);\n\n}\n\nDist distFloor(vec3 p, float y) {\n\n\treturn Dist(p.y - y, 1);\n\n}\n\nDist minDist(Dist a, Dist b) {\n\n\tif(a.dst < b.dst) {\n\t\n\t\treturn a;\n\t\n\t}\n\t\n\treturn b;\n\n}\n\nDist distScene(vec3 p) {\n\n\tDist d = distFloor(p, -0.1);\n\td = minDist(d, distBox(p, vec3(1.,1.,3.), vec3(1.,1.,0.05)));\n\n\treturn d;\n\n}\n\nHit raymarch(Ray ray) {\n\n\tvec3 p = ray.ori;\n\tint id = -1;\n\t\n\tfor(int i = 0; i < MAX_ITERATIONS; i++) {\n\t\n\t\tDist dst = distScene(p);\n\t\tp += ray.dir * dst.dst;\n\t\t\n\t\tif(dst.dst < MIN_DISTANCE) {\n\t\t\n\t\t\tid = dst.id;\n\t\t\tbreak;\n\t\t\n\t\t}\n\t\n\t}\n\t\n\treturn Hit(p,id);\n\n}\n\nvec3 calcNormal(vec3 p) {\n\n\tvec2 eps = vec2(.001,0.);\n\tvec3 n = vec3(distScene(p + eps.xyy).dst - distScene(p - eps.xyy).dst,\n\t\t\t\t  distScene(p + eps.yxy).dst - distScene(p - eps.yxy).dst,\n\t\t\t\t  distScene(p + eps.yyx).dst - distScene(p - eps.yyx).dst);\n\treturn normalize(n);\n\t\n}\n\nvec4 shadeJCVD(Hit scn, Ray ray, vec3 n) {\n \n    vec2 uv = mod(scn.p.xy \/ 2., 1.) - vec2(.0,.0);\n    vec4 c  = texture2D(iChannel0, uv);\n    \n    if(dot(n,ray.dir) == 0.) {\n     \n        c.a = 0.;\n        \n    }\n    \n    return c;\n    \n}\n\nvec3 calcLighting(Hit scn, Ray ray, vec3 n, bool shadowOnly) {\n\n\tfloat diff = max(dot(LIGHT_DIR,n), 0.);\n\tif(shadowOnly) diff = 1.;\n    \n\tif(scn.id == 1) {\n\t\n\t\tRay sr = Ray(scn.p + LIGHT_DIR * .003, LIGHT_DIR);\n\t\tHit sh = raymarch(sr);\n\t\n\t\tif(sh.id == 0) {\n\t\t\n            vec4 t = shadeJCVD(sh,sr,calcNormal(scn.p));    \n\t\t\tdiff = mix(diff,0.,t.a);\n\t\t\n\t\t}\n\t\n\t}\n\n    return vec3(diff);\n\treturn (shadowOnly ? vec3(1.) : vec3(1.,.98,.9)) * diff;\n\n}\n\nvec3 shadeFloor(Hit scn, Ray ray) {\n \n    vec3 n = calcNormal(scn.p);\n    vec2 uv = mod(scn.p.xz \/ 2., 1.);\n    \n\treturn textureCube(iChannel1, ray.dir).xyz * calcLighting(scn,ray,n,true);\n    \n}\n\nvec3 shade(Ray ray) {\n\n\tHit scn = raymarch(ray);\n\tvec3 col = textureCube(iChannel1,ray.dir).xyz;\n\n\tif(scn.id == 0) {\n\t\n        vec3 n   = calcNormal(scn.p);\n        vec4 tex = shadeJCVD(scn,ray,n);\n\t\n        tex.xyz *= calcLighting(scn,ray,n,false);\n        \n        if(tex.a < 1.) {\n         \n            Ray ar = Ray(scn.p + ray.dir * .11, ray.dir);\n            Hit ah = raymarch(ar);\n            vec3 bg = ah.id == 1 ? shadeFloor(ah,ar) : col;\n            \n            tex.xyz = mix(bg,tex.xyz,tex.a);\n            \n        }\n        \n        col = tex.xyz;\n        \n\t} else if(scn.id == 1) {\n\t\n\t\tcol = shadeFloor(scn,ray);\n\t\n\t}\n    \n\treturn col;\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\tvec2 uv = (fragCoord.xy - iResolution.xy \/ 2.) \/ iResolution.y;\n\tvec3 dir = vec3(uv, 1.);\n\t\n    \/\/vec2 m = iMouse.xy \/ iResolution.xy;\n\t\/\/dir.yz = rot2D(dir.yz, 15. * m.y);\n\t\/\/dir.xz = rot2D(dir.xz, m.x * 15.);\n\t\n\tvec3 scn = shade(Ray(vec3(1.,1.,1.),dir));\n\tfragColor = vec4(scn, 1.);\n\n}","name":"","description":"","type":"image"},{"inputs":[{"id":36,"src":"\/presets\/vid03.webm","ctype":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define THRESHOLD .6\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord \/ iResolution.xy;\n    vec4 col = texture2D(iChannel0, uv);\n    \n    vec3 diff = col.xyz - vec3(0.,1.,0.);\n    if(dot(diff,diff) < THRESHOLD) {\n     \n        col.a = 0.;\n        \n    }\n    \n    fragColor = col;\n}","name":"","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define BLUR_SIZE .01\n#define BLUR_SAMPLES 3\n\nfloat getBlurredAlpha(vec2 uv) {\n \n    float sum = 0.;\n    int iter = 0;\n    \n    for(int i = 0; i < BLUR_SAMPLES; i++) {\n    \n        \/\/float div = float(i) + 1.;\n        float div = 1.;\n        sum += texture2D(iChannel0, uv).a;\n        sum += texture2D(iChannel0, uv + vec2(BLUR_SIZE,0.) \/ div).a;\n        sum += texture2D(iChannel0, uv + vec2(BLUR_SIZE,0.) \/ 2. \/ div).a;\n        sum += texture2D(iChannel0, uv + vec2(BLUR_SIZE,0.) \/ 4. \/ div).a;\n        sum += texture2D(iChannel0, uv + vec2(BLUR_SIZE,0.) \/ 6. \/ div).a;\n        sum += texture2D(iChannel0, uv + vec2(0.,BLUR_SIZE) \/ div).a;\n        sum += texture2D(iChannel0, uv + vec2(0.,BLUR_SIZE) \/ 2. \/ div).a;\n        sum += texture2D(iChannel0, uv + vec2(0.,BLUR_SIZE) \/ 4. \/ div).a;\n        sum += texture2D(iChannel0, uv + vec2(0.,BLUR_SIZE) \/ 6. \/ div).a;\n        \n        iter += 9;\n        \n    }\n    \n    return sum \/ float(iter);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord \/ iResolution.xy;\n    \n    fragColor = texture2D(iChannel0, uv);\n    fragColor.a = getBlurredAlpha(uv);\n}","name":"","description":"","type":"buffer"}]}}