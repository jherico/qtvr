{"Shader":{"ver":"0.1","info":{"id":"Xdl3R4","date":"1364091442","viewed":4784,"name":"Cell","username":"iq","description":"Raymarched line segments, distorted and shaded to look like some sort of cells. Some (fakeish, thickness based) Subsurface Scattering happening too.","likes":43,"published":3,"flags":0,"tags":["procedural","3d","distancefield","sound","reactive","music","rayarching"],"hasliked":0},"renderpass":[{"inputs":[{"id":4,"src":"\/presets\/tex03.jpg","ctype":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":21,"src":"\/presets\/mzk04.mp3","ctype":"music","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":26,"src":"\/presets\/cube04_0.png","ctype":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat fbm( vec3 p, vec3 n )\n{\n\tp *= 0.15;\n\n\tfloat x = texture2D( iChannel3, p.yz ).x;\n\tfloat y = texture2D( iChannel3, p.zx ).x;\n\tfloat z = texture2D( iChannel3, p.xy ).x;\n\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\nvec2 sdSegment( vec3 a, vec3 b, vec3 p )\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn vec2( length( pa - ba*h ), h );\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\nvec3 snoise3( in float x )\n{\n#if 1    \n    return -1.0 + 2.0*texture2D( iChannel2, vec2(x,4.5)\/256.0 ).xyz;\n#else    \n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return -1.0 + 2.0*mix( hash3(p+0.0), hash3(p+1.0), f );\n#endif    \n}\n\nfloat freqs[16];\n\nvec4 map( vec3 pos )\n{\n\tpos += 0.04*sin(10.0*pos.yzx);\n\t\n\tvec3 qpos = mod( 1000.0 + pos+1.0, 2.0 )-1.0;\n\t\n    vec3 off3 = floor( 1000.0 + (pos+1.0)\/2.0 );\n\n\tqpos *= sign( cos( 0.5*3.1415927*pos.yzx ) );\n\t\n\tfloat off = abs( dot( off3, vec3(1.0, 13.0, 7.0 ) ) );\n\t\t\n\tfloat mindist = 10000.0;\n\tvec3 p = vec3(0.0);\n\tfloat h = 0.0;\n\tfloat rad = 0.04 + 0.15*freqs[0];\n\tfloat mint = 0.0;\n    for( int i=0; i<16; i++ )\n\t{\n\t\tvec3 op = p;\n\t\t\n\t\tp  = 0.9*normalize(snoise3( 8.0*h ));\n\n\t\tfloat orad = rad;\n\t\trad = (0.04 + 0.15*freqs[i])*1.5*1.1;\n\t\t\n\t\tvec2 disl = sdSegment( op, p, qpos );\n\t\tfloat t = h + disl.y\/16.0;\n\n\t\tfloat dis = disl.x - mix(orad,rad,disl.y);\n\t\t\n\t\tif( dis<mindist ){ mindist = dis; mint=t; }\n\t\th += (1.0\/16.0);\n\t}\n\n\tfloat dsp = sin(50.0*pos.x)*sin(50.0*pos.y)*sin(50.0*pos.z);\n\tdsp = dsp*dsp*dsp;\n\tmindist += -0.02*dsp;\n\t\n\tmindist += 0.01*sin(180.0*mint + iGlobalTime);\n\t\n\t\n    return vec4(mindist,1.0,dsp,mint);\n}\n\n\n\nconst float maxd = 8.0;\n\nvec4 castRay( in vec3 ro, in vec3 rd )\n{\n    const float precis = 0.001;\n    float h = 1.0;\n\n    float t = 0.1;\n    float sid = -1.0;\n\tfloat dsp = 0.0;\n\tfloat ttt = 0.0;\n    for( int i=0; i<50; i++ )\n    {\n        if( abs(h)<(precis*t) || t>maxd ) break;\n        t += min( h, 0.2 );\n\t    vec4 res = map( ro+rd*t );\n        h = res.x;\n\t    sid = res.y;\n\t\tdsp = res.z;\n\t\tttt = res.w;\n    }\n\n    return vec4( t, sid, dsp, ttt );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.05, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec3 doBumpMap( in vec3 pos, in vec3 nor, float amount )\n{\n    float e = 0.0015;\n    float b = 0.01;\n\n    float ref = fbm( 48.0*pos, nor );\n    vec3 gra = -b*vec3( fbm(48.0*vec3(pos.x+e, pos.y, pos.z),nor)-ref,\n                        fbm(48.0*vec3(pos.x, pos.y+e, pos.z),nor)-ref,\n                        fbm(48.0*vec3(pos.x, pos.y, pos.z+e),nor)-ref )\/e;\n\t\n\tvec3 tgrad = gra - nor * dot ( nor , gra );\n    return normalize ( nor - amount*tgrad );\n\n\t\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\n    float totao = 0.0;\n    for( int aoi=0; aoi<5; aoi++ )\n    {\n\t\tvec3 aopos = 0.1 * ( nor  + 0.7*(-1.0+2.0*hash3(143.13*float(aoi))) );\n        float dd = map( pos + aopos ).x;\n\t\ttotao += clamp(5.0*dd,0.0,1.0);\n    }\n    return pow( clamp( 1.5*totao\/5.0, 0.0, 1.0 ), 1.0 );\n}\n\n\nfloat calcSSS( in vec3 pos, in vec3 nor )\n{\n    float ao = 1.0;\n    float totao = 0.0;\n    float sca = 1.0;\n    for( int aoi=0; aoi<5; aoi++ )\n    {\n        float hr = 0.01 + 0.4*float(aoi)\/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        totao += (hr-min(dd,0.0))*sca;\n        sca *= 0.9;\n    }\n    return pow( clamp( 1.2 - 0.25*totao, 0.0, 1.0 ), 16.0 );\n}\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.0);\n\n\tvec4 res = castRay(ro,rd);\n    float t = res.x;\n    if( t<maxd )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n\t\tvec3 snor = nor;\n\t\tnor = doBumpMap( 0.5*pos, nor, 0.2*clamp(1.0-1.0*res.z,0.0,1.0) );\n\n\t\tvec3 ref = reflect( rd, nor );\n\t\tvec3 sref = reflect( rd, snor );\n\n\t\tcol = vec3(1.0);\n\t\tfloat pao = calcAO( pos, nor ); \n        float ao = 0.4 + 0.6*pao;\n        ao *= 1.0 + 0.3*max(res.z,0.0);\n\t\tfloat ss = calcSSS( pos-nor*0.01, rd ); \n  \n\t\tfloat kr = clamp( 1.0+dot( rd, nor ), 0.0, 1.0 );\n\n\t\tcol = mix( vec3(0.6,0.3,0.1), 1.4*vec3(1.0,0.8,0.6), kr*ss*ss );\n\n        col *= 0.7 + 0.3*ss;\n\t\t\n\t\tcol += 0.1*cos( 4.0*6.2831*res.w + vec3(1.0,0.5,0.7) );\n        col *= 0.6 + 0.6*fbm(pos,nor);\t\t\n        col = col*ao;\n\t\tcol += 0.15*(0.5+0.5*kr)*pow(textureCube( iChannel1, normalize(sref+ref) ).xyz, vec3(1.0) );\n\n\t\tcol *= exp( -0.0125*t*t*t );\n    }\n   \n\treturn vec3( col );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy\/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x\/iResolution.y;\n    vec2 mo = iMouse.xy\/iResolution.xy;\n\t\t \n\tfloat time = iGlobalTime + 80.0;\n\n\tfor( int i=0; i<16; i++ )\n\t    freqs[i] = clamp( 1.9*pow( texture2D( iChannel0, vec2( 0.02 + 0.5*float(i)\/16.0, 0.25 ) ).x, 3.0 ), 0.0, 1.0 );\n\t\n\t\/\/ camera\t\n\tvec3  ta  = 0.4*vec3( cos(0.115*time), 2.0*sin(0.1*time), sin(0.085*time) );\n\tvec3  ro = vec3( 1.0*cos(0.05*time+6.28*mo.x), 0.0, 1.0*sin(0.05*time+6.2831*mo.x) );\n\tfloat rl = 0.25*sin(0.1*time);\n\t\n\t\/\/ camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( sin(rl), cos(rl),0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 1.5*cw );\n\n    vec3 col = render( ro, rd );\n    \n    col = pow( col, vec3(0.6,0.9,1.0) );\n\n\tcol *= 0.25 + 0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15 );\n\n    fragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}