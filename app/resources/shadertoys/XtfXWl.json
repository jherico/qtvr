{"Shader":{"ver":"0.1","info":{"id":"XtfXWl","date":"1440375843","viewed":803,"name":"Metaeaux - Warp drive","username":"metaeaux","description":"Experimenting with modulating the focal length to distort the perspective.","likes":2,"published":3,"flags":0,"tags":["raymarching","distancefields","focallength"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"const vec4 ambientColor = vec4(0.15, 0.2, 0.32, 1.0);\nconst vec4 skyColor = 0.3 * vec4(0.31, 0.47, 0.67, 1.0);\nconst float PI = 3.14159;\n\nfloat sphere(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat cube(vec3 p, vec3 size)\n{\n\tvec3 d = abs(p) - size;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(abs(p) - size, vec3(0.0)));\n}\n\nfloat cylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nvec3 repeat( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 twist(vec3 p, float amount)\n{\n    float  c = cos(amount*p.y+amount);\n    float  s = sin(amount*p.y+amount);\n    mat2   m = mat2(c,-s,s,c);\n    return mix(p, vec3(m*p.xz,p.y), amount);\n}\n\nfloat intersection( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat distanceField(vec3 p) {\n    vec3 repeatedSpace = repeat(p, vec3(1.2));\n    float d1 = cube(repeatedSpace, vec3(.2));\n    float d2 = sphere(repeatedSpace, 0.25);\n    float d3 = mix(intersection(d2, d1), d2, -1.);\n    return d3;\n}\n\nvec3 getNormal(vec3 p)\n{\n\tfloat h = 0.0001;\n\n\treturn normalize(vec3(\n\t\tdistanceField(p + vec3(h, 0, 0)) - distanceField(p - vec3(h, 0, 0)),\n\t\tdistanceField(p + vec3(0, h, 0)) - distanceField(p - vec3(0, h, 0)),\n\t\tdistanceField(p + vec3(0, 0, h)) - distanceField(p - vec3(0, 0, h))));\n}\n\nvec4 lambert(vec3 p, vec3 normal, vec3 lightPos, vec4 lightColor)\n{\n\tfloat lightIntensity = 0.0;\n\tvec3 lightDirection = normalize(lightPos - p);\n    \n    \/\/ lambert shading\n\tlightIntensity = clamp(dot(normal, lightDirection), 0.0, 1.);\n\t\n\treturn lightColor * lightIntensity + ambientColor * (1.0 - lightIntensity);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 \/ 3.0, 2.0 \/ 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) \/ (6.0 * d + e)), d \/ (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float gridSize = 4.0;\n    float u = gl_FragCoord.x * gridSize \/ iResolution.x - gridSize \/ 2.;\n    float v = gl_FragCoord.y * gridSize \/ iResolution.y - gridSize \/ 2.;\n    float aspectRatio = iResolution.x \/ iResolution.y;\n    \n    vec3 camUp = vec3(0., 1., 0.);\n    vec3 camRight = vec3(1., 0., 0.);\n    vec3 camForward = vec3(0., 0., 1.);\n    \n    \/\/ modulate the focal length based on time\n    float maxFocalLength = 1.97;\n    float focalLength = maxFocalLength - (maxFocalLength - 0.01) * abs(sin(iGlobalTime * 0.5));\n    \n    float time = 15.0 + iGlobalTime;\n\n\t\/\/ camera\t\n    vec2 mo = iMouse.xy\/iResolution.xy;\n    vec3 ro = vec3( 3. - 6. * mo.x, 3. - 6. * mo.y, iGlobalTime);\n\tvec3 rd = normalize(camForward * focalLength + camRight * u * aspectRatio + camUp * v);\n    \n    vec4 color = skyColor;\n\n    float t = 0.0;\n    vec3 lightDirection = vec3(2.0, 1.0, -2.0);\n    vec4 lightColour;\n    const int maxSteps = 64;\n    for(int i = 0; i < maxSteps; ++i)\n    {\n        vec3 p = ro + rd * t;\n        float d = distanceField(p);\n        if(d < 0.0002)\n        {\n            vec3 normal = getNormal(p);\n            float far = 1. \/ t;\n\n            \/\/ focal length modulates the colour, a bit like the doppler effect\n            lightColour = vec4(hsv2rgb(vec3(fract(far * focalLength), 1.0, 1.0)), 1.0);\n            color = lambert(p, normal, lightDirection, lightColour);\n            \n            \/\/ fade to dark in the distance;\n            color *= far;\n            \n            break;\n        }\n        \n        if(t > 10.)\n        {\n            break;\n        }\n\n        t += d;\n    }\n\n    fragColor = color;\n}","name":"","description":"","type":"image"}]}}