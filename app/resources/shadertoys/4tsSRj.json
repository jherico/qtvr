{"Shader":{"ver":"0.1","info":{"id":"4tsSRj","date":"1438299299","viewed":798,"name":"No Man's Portal","username":"mech4rhork","description":"Portal effect from No Man's Sky: Portal gameplay trailer<br\/>https:\/\/www.youtube.com\/watch?v=WQhSP82uhY4","likes":1,"published":3,"flags":0,"tags":["procedural","2d","noise","lighting","bump"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define SCALING \t\t1.5\n#define SPEED\t\t\t0.19\n#define PORTAL_COUNT \t3\n#define PORTAL_SIZE\t\t1.6\n\/\/#define\tDIR_LIGHT\n#define\tANIM_LIGHT\n\n\/\/ -------------------------------------\n\/\/ rotation\n\/\/ -------------------------------------\nvec2 rotate( vec2 p, vec2 c, float t ) {\n    vec2 v = p - c;\n    mat2 rot = mat2( cos( t ), -sin( t ), sin( t ), cos( t ) );\n    return v * rot;\n}\n\/\/ -------------------------------------\n\/\/ swirl tansformation\n\/\/ -------------------------------------\nvec2 swirl( vec2 p, vec2 c, float t ) {\n    vec2 v = p - c;\n    float theta = 6.28 * sqrt( dot( v, v ) ) * 1.3;\n    mat2 f = mat2( cos( theta + t ), sin( theta + t ), -sin( theta + t ), cos( theta + t ) );\n    return v * f + c;\n}\n\/\/ -------------------------------------\n\/\/ from \"Hash without Sine\" by Dave_Hoskins\n\/\/ https:\/\/www.shadertoy.com\/view\/4djSRW\n\/\/ -------------------------------------\nfloat hash( vec2 p ) {\n\tp  = fract( p * vec2( 0.16632, 0.17369 ) );\n    p += dot( p.xy, p.yx + 19.19 );\n    return fract( p.x * p.y );\n}\n\/\/ -------------------------------------\n\/\/ from \"Noise - value - 2D\" by iq\n\/\/ https:\/\/www.shadertoy.com\/view\/lsf3WH\n\/\/ -------------------------------------\nfloat noise( vec2 p ) {\n\tvec2 i = floor( p );\n\tvec2 f = fract( p );\n\t\n\tf = f * f * ( 3.0 - 2.0 * f );\n\t\n\treturn mix(\n\t\tmix( hash( i + vec2( 0.0, 0.0 ) ), hash( i + vec2( 1.0, 0.0 ) ), f.x ),\n\t\tmix( hash( i + vec2( 0.0, 1.0 ) ), hash( i + vec2( 1.0, 1.0 ) ), f.x ),\n\t\tf.y\n\t);\n}\n\/\/ -------------------------------------\n\/\/ procedural texture ( clouds )\n\/\/ -------------------------------------\nvec3 proTex( vec2 p ) {\n    float d = 0.5;\n\tmat2 h = mat2( 1.6, 1.2, -1.2, 1.6 );\n\t\n\tfloat color = 0.0;\n\tfor( int i = 0; i < 3; i++ ) {\n\t\tcolor += d * noise( p * 200.0 );\n\t\tp *= h;\n\t\td \/= 2.0;\n\t}\n    \n    return vec3( pow( 0.5 + 0.75 * exp(-color*color), 2.5 ) );\n}\n\/\/ -------------------------------------\n\/\/ one portal\n\/\/ -------------------------------------\nvec4 portal( vec2 p, vec2 c, float s, vec4 t ) {\n    p -= c;\n    vec2 q = p;\n    p.y *= iResolution.y \/ iResolution.x; \/\/ ratio\n    p *= SCALING; \/\/ scaling\n    \n    t += c.xyxy * 9.0;\n    \n   \t\/\/ transformations\n    p = swirl( p, c, t.z );\n    p = rotate( p, c, 1.57 );\n    \n    float lenSqr = dot( p, p );\n    float len = sqrt( dot( p, p ) );\n    float size = 0.1 * s;\n    \n    float colMask = 1.0 - step( size, len ); \/\/ mask\n    vec3 col = proTex( ( p + vec2( t.z, 0.0 ) ) * 0.1 );\n    \n    \/\/ vignette (bump)\n    col = mix(\n        col,\n        1. - vec3( 0.5 + 0.75*pow( exp( -lenSqr * lenSqr ), 2048.0 ) ),\n        0.33\n    );\n    \n    \/\/ ring\n    if( len > size * 0.95 ) {\n        col = mix( col, vec3( 0.3 ), 1.0 );\n    }\n    \n\treturn vec4( col, colMask );\n}\n\/\/ -------------------------------------\n\/\/ image with all the portals\n\/\/ -------------------------------------\nvec4 getImage( vec2 uv, vec2 c, vec4 t ) {\n    vec4 col = vec4( 0.0 );\n    \n    vec2 centers[PORTAL_COUNT];\n    float size = PORTAL_SIZE;\n    c *= SCALING;\n    \n    for( int i = 0; i < PORTAL_COUNT; i++ ) {\n        centers[i] += vec2( float( i - ( PORTAL_COUNT \/ 2 ) ), 0.0 );\n        centers[i] *= size \/ SCALING;\n        vec4 prtl = portal( uv, ( centers[i] + c ) \/ size * 0.5, size, t );\n        col = mix( col, prtl, prtl.a );\n    }\n    \n\treturn col;\n}\n\/\/ -------------------------------------\n\/\/ from \"Normal map calculation\" by sergey_reznik\n\/\/ https:\/\/www.shadertoy.com\/view\/llS3WD\n\/\/ -------------------------------------\nfloat sampleHeight( vec2 coord, vec2 c, vec4 t ) {\n    return 0.046 * dot(\n        getImage( coord, c, t ).xyz,\n        vec3( 1.0 \/ 3.0, 1.0 \/ 3.0, 1.0 \/ 3.0 )\n    );\n}\n\/\/ -------------------------------------\n\/\/ also by sergey_reznik\n\/\/ -------------------------------------\nvec3 getNormal( vec2 uv, vec2 c, vec4 t ) {\n\tvec2 du = vec2( 1.0 \/ 1024.0, 0.0 );\n    vec2 dv = vec2( 0.0, 1.0 \/ 1024.0 );\n    \n    float hpx = sampleHeight( uv + du, c, t );\n    float hmx = sampleHeight( uv - du, c, t );\n    float hpy = sampleHeight( uv + dv, c, t );\n    float hmy = sampleHeight( uv - dv, c, t );\n    \n    float dHdU = ( hmx - hpx ) \/ ( 2.0 * du.x );\n    float dHdV = ( hmy - hpy ) \/ ( 2.0 * dv.y );\n    \n    return vec3( dHdU, dHdV, 1.0 );\n}\n\/*\n\t*\n*\/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    \n    \/\/ vignetting\n    float vignette = pow( uv.x * uv.y * ( 1.0 - uv.x ) * ( 1.0 - uv.y ), 0.025 );\n    \n    uv = ( uv * 2.0 ) - 1.0; \/\/ for using ( 0.0, 0.0 ) as the center\n    \n    \/\/ time\n\tvec4 t = SPEED * ( 0.15 * iGlobalTime * vec4( 0.5, 1.5, 6.0, 10.0 ) + vec4( 0.0, 0.0, 0.0, 0.0 ) );\n\n\t\/\/ center of scene\n\tvec2 center = vec2( 0.0, -0.25 );\n    \n    \/\/ image\n    fragColor.rgb = vec3( 0.149, 0.055, 0.149 ); \/\/ background color\n    vec4 image = getImage( uv, center, t );\n    \n    \/\/ lighting\n    float atten;\n    vec3 normal = 0.5 + 0.5 * normalize( getNormal( uv, center, t ) );\n    vec3 lightColor = vec3( 1.0, 0.988, 0.925 );\n    vec3 specularColor = vec3( 1.0, 0.996, 0.965 ) * 0.6;\n    vec3 ambient = vec3( 0.22, 0.153, 0.17 );\n    vec3 red = vec3( 0.584, 0.357, 0.510 );\n    \n    #ifdef DIR_LIGHT\n    vec3 lightVec = vec3( 0.67, 1.286, -1.0 ); \/\/ light direction\n    atten = 1.0;\n    #else\n    vec3 lightPos = vec3( vec2( -0.34, 1.6 ), -1.2 ); \/\/ vec3( -2.8, 3.33, -1.0 ); \/\/ light position\n    \n    #ifdef ANIM_LIGHT\n    lightPos *= vec3( 1.0 + 0.067 * cos( t.zw * 3.0 ), 1.0 ); \/\/ light position (animated)\n    #endif\n    \n    vec3 lightVec = vec3(\n        ( ( uv - center ) * vec2( 1.0, iResolution.y \/ iResolution.x ) ).xy * SCALING, 0.0\n    ) - lightPos; \/\/ light direction\n    atten = 1.0 \/ length( lightVec );\n    #endif\n    lightVec = normalize( lightVec );\n    \n    vec3 lighting = atten * lightColor * max( 0.0, dot( lightVec, normal ) );\n    lighting = mix( vec3( 0.0 ), vec3( lighting ), image.a );\n    lighting += vec3( 0.125 );\n    \n    \/\/ specular lighting\n    vec3 eyeVec = normalize( vec3( 1.77, 0.0, 1.0 ) ); \/\/ camera direction\n    vec3 specular = atten * specularColor * vec3( pow( max( 0.0, dot( reflect( -lightVec, normal ), eyeVec ) ), 0.44 ) );\n    \n    \/\/ ### TEST : red ambien lighting\n    vec3 redLightPos = vec3( vec2( -0.34, -2.2 ), -1.0 );\n    vec3 redLightVec = vec3( ( ( uv - center ) * vec2( 1.0, iResolution.y \/ iResolution.x ) ).xy * SCALING, 0.0 ) - redLightPos;\n    atten = 1.0 \/ length( redLightVec );\n    vec3 redLighting = atten * red * max( 0.0, dot( redLightVec, normal ) );\n    \/\/ ENDTEST ###\n    \n    fragColor = mix(\n        fragColor,\n        image * vec4( lighting + specular, 1.0 ) + vec4( vec3( ambient * redLighting ), 0.0 ),\n        image.a\n    );\n    fragColor *= vignette;\n}\n","name":"","description":"","type":"image"}]}}