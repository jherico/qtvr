{"Shader":{"ver":"0.1","info":{"id":"XljGDz","date":"1428379120","viewed":3793,"name":"Protophore","username":"otaviogood","description":"I put together this fractal and then watched some tutorials on how to light sports cars for photography. I think the key is to get the giant softbox up top with just the right fade at the edges. I also ray march 1 reflection.","likes":73,"published":3,"flags":0,"tags":["reflection","raymarch","lighting"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/*--------------------------------------------------------------------------------------\nLicense CC0 - http:\/\/creativecommons.org\/publicdomain\/zero\/1.0\/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^This means do anything you want with this code. Because we are programmers, not lawyers.\n\n-Otavio Good\n*\/\n\n\/\/ Number of times the fractal repeats\n#define RECURSION_LEVELS 4\n\/\/ Animation splits the sphere in different directions\n\/\/ This ended up running a significantly slower fps and not looking very different. :(\n\/\/#define SPLIT_ANIM\n\nfloat localTime = 0.0;\nfloat marchCount;\n\nfloat PI=3.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\n\n\/*vec3 GetEnvColor(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 tex = textureCube(iChannel0, rayDir).xyz;\n\ttex = tex * tex;\t\/\/ gamma correct\n    return tex;\n}*\/\n\n\/\/ This is a procedural environment map with a giant overhead softbox,\n\/\/ 4 lights in a horizontal circle, and a bottom-to-top fade.\nvec3 GetEnvColor2(vec3 rayDir, vec3 sunDir)\n{\n    \/\/ fade bottom to top so it looks like the softbox is casting light on a floor\n    \/\/ and it's bouncing back\n    vec3 final = vec3(1.0) * dot(-rayDir, sunDir) * 0.5 + 0.5;\n    final *= 0.125;\n    \/\/ overhead softbox, stretched to a rectangle\n    if ((rayDir.y > abs(rayDir.x)*1.0) && (rayDir.y > abs(rayDir.z*0.25))) final = vec3(2.0)*rayDir.y;\n    \/\/ fade the softbox at the edges with a rounded rectangle.\n    float roundBox = length(max(abs(rayDir.xz\/max(0.0,rayDir.y))-vec2(0.9, 4.0),0.0))-0.1;\n    final += vec3(0.8)* pow(saturate(1.0 - roundBox*0.5), 6.0);\n    \/\/ purple lights from side\n    final += vec3(8.0,6.0,7.0) * saturate(0.001\/(1.0 - abs(rayDir.x)));\n    \/\/ yellow lights from side\n    final += vec3(8.0,7.0,6.0) * saturate(0.001\/(1.0 - abs(rayDir.z)));\n    return vec3(final);\n}\n\n\/*vec3 GetEnvColorReflection(vec3 rayDir, vec3 sunDir, float ambient)\n{\n\tvec3 tex = textureCube(iChannel0, rayDir).xyz;\n\ttex = tex * tex;\n    vec3 texBack = textureCube(iChannel0, rayDir).xyz;\n    vec3 texDark = pow(texBack, vec3(50.0)).zzz;\t\/\/ fake hdr texture\n    texBack += texDark*0.5 * ambient;\n    return texBack*texBack*texBack;\n}*\/\n\nvec3 camPos = vec3(0.0), camFacing;\nvec3 camLookat=vec3(0,0.0,0);\n\n\/\/ polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)\/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 matMin(vec2 a, vec2 b)\n{\n\tif (a.x < b.x) return a;\n\telse return b;\n}\n\nfloat spinTime;\nvec3 diagN = normalize(vec3(-1.0));\nfloat cut = 0.77;\nfloat inner = 0.333;\nfloat outness = 1.414;\nfloat finWidth;\nfloat teeth;\nfloat globalTeeth;\n\nvec2 sphereIter(vec3 p, float radius, float subA)\n{\n    finWidth = 0.1;\n    teeth = globalTeeth;\n    float blender = 0.25;\n    vec2 final = vec2(1000000.0, 0.0);\n    for (int i = 0; i < RECURSION_LEVELS; i++)\n    {\n#ifdef SPLIT_ANIM\n        \/\/ rotate top and bottom of sphere opposite directions\n        p = RotateY(p, spinTime*sign(p.y)*0.05\/blender);\n#endif\n        \/\/ main sphere\n        float d = length(p) - radius*outness;\n#ifdef SPLIT_ANIM\n        \/\/ subtract out disc at the place where rotation happens so we don't have artifacts\n        d = max(d, -(max(length(p) - radius*outness + 0.1, abs(p.y) - finWidth*0.25)));\n#endif\n\n        \/\/ calc new position at 8 vertices of cube, scaled\n        vec3 corners = abs(p) + diagN * radius;\n        float lenCorners = length(corners);\n        \/\/ subtract out main sphere hole, mirrored on all axises\n        float subtracter = lenCorners - radius * subA;\n        \/\/ make mirrored fins that go through all vertices of the cube\n        vec3 ap = abs(-p) * 0.7071;\t\/\/ 1\/sqrt(2) to keep distance field normalized\n        subtracter = max(subtracter, -(abs(ap.x-ap.y) - finWidth));\n        subtracter = max(subtracter, -(abs(ap.y-ap.z) - finWidth));\n        subtracter = max(subtracter, -(abs(ap.z-ap.x) - finWidth));\n        \/\/ subtract sphere from fins so they don't intersect the inner spheres.\n        \/\/ also animate them so they are like teeth\n        subtracter = min(subtracter, lenCorners - radius * subA + teeth);\n        \/\/ smoothly subtract out that whole complex shape\n        d = -smin(-d, subtracter, blender);\n        \/\/vec2 sphereDist = sphereB(abs(p) + diagN * radius, radius * inner, cut);\t\/\/ recurse\n        \/\/ do a material-min with the last iteration\n        final = matMin(final, vec2(d, float(i)));\n\n#ifndef SPLIT_ANIM\n        corners = RotateY(corners, spinTime*0.25\/blender);\n#endif\n        \/\/ Simple rotate 90 degrees on X axis to keep things fresh\n        p = vec3(corners.x, corners.z, -corners.y);\n        \/\/ Scale things for the next iteration \/ recursion-like-thing\n        radius *= inner;\n        teeth *= inner;\n        finWidth *= inner;\n        blender *= inner;\n    }\n    \/\/ Bring in the final smallest-sized sphere\n    float d = length(p) - radius*outness;\n    final = matMin(final, vec2(d, 6.0));\n    return final;\n}\n\nvec2 DistanceToObject(vec3 p)\n{\n    vec2 distMat = sphereIter(p, 5.2 \/ outness, cut);\n    return distMat;\n}\n\n\/\/ dirVec MUST BE NORMALIZED FIRST!!!!\nfloat SphereIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad)\n{\n    vec3 radialVec = pos - spherePos;\n    float b = dot(radialVec, dirVecPLZNormalizeMeFirst);\n    float c = dot(radialVec, radialVec) - rad * rad;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    return -b - sqrt(h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    localTime = iGlobalTime - 0.0;\n\t\/\/ ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv = fragCoord.xy\/iResolution.xy * 2.0 - 1.0;\n    float zoom = 1.7;\n    uv \/= zoom;\n\n\t\/\/ Camera up vector.\n\tvec3 camUp=vec3(0,1,0);\n\n\t\/\/ Camera lookat.\n\tcamLookat=vec3(0,0.0,0);\n\n    \/\/ debugging camera\n    float mx=iMouse.x\/iResolution.x*PI*2.0-0.7 + localTime*3.1415 * 0.0625*0.666;\n\tfloat my=-iMouse.y\/iResolution.y*10.0 - sin(localTime * 0.31)*0.5;\/\/*PI\/2.01;\n\tcamPos += vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(12.2);\n\n\t\/\/ Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x\/iResolution.y) + uv.y * upNorm;\n\tvec3 rayVec = normalize(worldPix - camPos);\n\n\t\/\/ ----------------------------------- Animate ------------------------------------\n    localTime = iGlobalTime*0.5;\n    \/\/ This is a wave function like a triangle wave, but with flat tops and bottoms.\n    \/\/ period is 1.0\n    float rampStep = min(3.0,max(1.0, abs((fract(localTime)-0.5)*1.0)*8.0))*0.5-0.5;\n    rampStep = smoothstep(0.0, 1.0, rampStep);\n    \/\/ lopsided triangle wave - goes up for 3 time units, down for 1.\n    float step31 = (max(0.0, (fract(localTime+0.125)-0.25)) - min(0.0,(fract(localTime+0.125)-0.25))*3.0)*0.333;\n\n    spinTime = step31 + localTime;\n    \/\/globalTeeth = 0.0 + max(0.0, sin(localTime*3.0))*0.9;\n    globalTeeth = rampStep*0.99;\n    cut = max(0.48, min(0.77, localTime));\n\t\/\/ --------------------------------------------------------------------------------\n\tvec2 distAndMat = vec2(0.5, 0.0);\n\tfloat t = 0.0;\n\t\/\/float inc = 0.02;\n\tfloat maxDepth = 24.0;\n\tvec3 pos = vec3(0,0,0);\n    marchCount = 0.0;\n    \/\/ intersect with sphere first as optimization so we don't ray march more than is needed.\n    float hit = SphereIntersect(camPos, rayVec, vec3(0.0), 5.6);\n    if (hit >= 0.0)\n    {\n        t = hit;\n        \/\/ ray marching time\n        for (int i = 0; i < 290; i++)\t\/\/ This is the count of the max times the ray actually marches.\n        {\n            pos = camPos + rayVec * t;\n            \/\/ *******************************************************\n            \/\/ This is _the_ function that defines the \"distance field\".\n            \/\/ It's really what makes the scene geometry.\n            \/\/ *******************************************************\n            distAndMat = DistanceToObject(pos);\n            \/\/ adjust by constant because deformations mess up distance function.\n            t += distAndMat.x * 0.7;\n            \/\/if (t > maxDepth) break;\n            if ((t > maxDepth) || (abs(distAndMat.x) < 0.0025)) break;\n            marchCount+= 1.0;\n        }\n    }\n    else\n    {\n        t = maxDepth + 1.0;\n        distAndMat.x = 1000000.0;\n    }\n    \/\/ --------------------------------------------------------------------------------\n\t\/\/ Now that we have done our ray marching, let's put some color on this geometry.\n\n\tvec3 sunDir = normalize(vec3(3.93, 10.82, -1.5));\n\tvec3 finalColor = vec3(0.0);\n\n\t\/\/ If a ray actually hit the object, let's light it.\n\t\/\/if (abs(distAndMat.x) < 0.75)\n    if (t <= maxDepth)\n\t{\n        \/\/ calculate the normal from the distance field. The distance field is a volume, so if you\n        \/\/ sample the current point and neighboring points, you can use the difference to get\n        \/\/ the normal.\n        vec3 smallVec = vec3(0.005, 0, 0);\n        vec3 normalU = vec3(distAndMat.x - DistanceToObject(pos - smallVec.xyy).x,\n                           distAndMat.x - DistanceToObject(pos - smallVec.yxy).x,\n                           distAndMat.x - DistanceToObject(pos - smallVec.yyx).x);\n\n        vec3 normal = normalize(normalU);\n\n        \/\/ calculate 2 ambient occlusion values. One for global stuff and one\n        \/\/ for local stuff\n        float ambientS = 1.0;\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1).x*10.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2).x*5.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4).x*2.5);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.8).x*1.25);\n        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6).x*1.25*0.5);\n        ambient *= saturate(DistanceToObject(pos + normal * 3.2).x*1.25*0.25);\n        ambient *= saturate(DistanceToObject(pos + normal * 6.4).x*1.25*0.125);\n        ambient = max(0.035, pow(ambient, 0.3));\t\/\/ tone down ambient with a pow and min clamp it.\n        ambient = saturate(ambient);\n\n        \/\/ calculate the reflection vector for highlights\n        vec3 ref = reflect(rayVec, normal);\n        ref = normalize(ref);\n\n        \/\/ Trace a ray for the reflection\n        float sunShadow = 1.0;\n        float iter = 0.1;\n        vec3 nudgePos = pos + normal*0.02;\t\/\/ don't start tracing too close or inside the object\n\t\tfor (int i = 0; i < 40; i++)\n        {\n            float tempDist = DistanceToObject(nudgePos + ref * iter).x;\n\t        sunShadow *= saturate(tempDist*50.0);\n            if (tempDist <= 0.0) break;\n            \/\/iter *= 1.5;\t\/\/ constant is more reliable than distance-based\n            iter += max(0.00, tempDist)*1.0;\n            if (iter > 4.2) break;\n        }\n        sunShadow = saturate(sunShadow);\n\n        \/\/ ------ Calculate texture color ------\n        vec3 texColor;\n        texColor = vec3(1.0);\/\/ vec3(0.65, 0.5, 0.4)*0.1;\n        texColor = vec3(0.85, 0.945 - distAndMat.y * 0.15, 0.93 + distAndMat.y * 0.35)*0.951;\n        if (distAndMat.y == 6.0) texColor = vec3(0.91, 0.1, 0.41)*10.5;\n        \/\/texColor *= mix(vec3(0.3), vec3(1.0), tex3d(pos*0.5, normal).xxx);\n        texColor = max(texColor, vec3(0.0));\n        texColor *= 0.25;\n\n        \/\/ ------ Calculate lighting color ------\n        \/\/ Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = vec3(0.0);\/\/ sunCol * saturate(dot(sunDir, normal)) * sunShadow*14.0;\n        \/\/ sky color, hemisphere light equation approximation, ambient occlusion\n        lightColor += vec3(0.1,0.35,0.95) * (normal.y * 0.5 + 0.5) * ambient * 0.2;\n        \/\/ ground color - another hemisphere light\n        lightColor += vec3(1.0) * ((-normal.y) * 0.5 + 0.5) * ambient * 0.2;\n\n\n        \/\/ finally, apply the light to the texture.\n        finalColor = texColor * lightColor;\n        \/\/if (distAndMat.y == ceil(mod(localTime, 4.0))) finalColor += vec3(0.0, 0.41, 0.72)*0.925;\n\n        \/\/ reflection environment map - this is most of the light\n        vec3 refColor = GetEnvColor2(ref, sunDir)*sunShadow;\n        finalColor += refColor * 0.35 * ambient;\/\/ * sunCol * sunShadow * 9.0 * texColor.g;\n\n        \/\/ fog\n\t\tfinalColor = mix(vec3(1.0, 0.41, 0.41) + vec3(1.0), finalColor, exp(-t*0.0007));\n        \/\/ visualize length of gradient of distance field to check distance field correctness\n        \/\/finalColor = vec3(0.5) * (length(normalU) \/ smallVec.x);\n\t}\n    else\n    {\n\t    finalColor = GetEnvColor2(rayVec, sunDir);\/\/ + vec3(0.1, 0.1, 0.1);\n    }\n    \/\/finalColor += marchCount * vec3(1.0, 0.3, 0.91) * 0.001;\n\n    \/\/ vignette?\n    \/\/finalColor *= vec3(1.0) * saturate(1.0 - length(uv\/2.5));\n    \/\/finalColor *= 1.95;\n\n\t\/\/ output the final color with sqrt for \"gamma correction\"\n\tfragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n","name":"","description":"","type":"image"}]}}