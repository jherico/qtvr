{"Shader":{"ver":"0.1","info":{"id":"XtXXRH","date":"1434309667","viewed":835,"name":"metamonolith","username":"ryk","description":"Some code-duplication for the sake of self-reflections, no regrets.","likes":14,"published":3,"flags":0,"tags":["3d","reflection","raymarch","glow"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"float time;\nvec2 size;\n#define PI 3.141592653589\n\nstruct Ray\n{\n\tvec3 org;\n\tvec3 dir;\n};\n\nmat3 rotateX(float a){\n    return mat3(1.,0.,0.,\n                0.,cos(a), -sin(a),\n                0.,sin(a), cos(a));\n}\n\nmat3 rotateY(float a){\n    return mat3(cos(a), 0., -sin(a),\n                0.,1.,0.,\n                sin(a), 0., cos(a));\n}\n\nmat3 rotation;\n\nfloat hash(float f)\n{\n    return fract(sin(f*32.34182) * 43758.5453);\n}\n\nfloat hash(vec2 p)\n{\n    return fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 grid(vec3 dir, bool vert){\n    vec2 p = dir.xy \/ max(0.001, abs(dir.z));\n    p *= 3.;\n    p.y *= 0.06;\n    p.y += time * 20.3;\n    vert = hash(floor(p.y\/5. + 0.5)) < 0.5 ? vert : !vert;\n    p += 0.5;\n    float h = hash(floor(p*sign(dir.z)));\n    float h2 = hash(floor(p.y\/6.));\n    float h3 = hash(floor(p.y\/20.)+sign(dir.z));\n    float band = abs(p.x) < 2. + floor(30.*h3*h3) ? 1. : 0.;\n    p = mod(p, vec2(1.));\n    p -= 0.5;\n    float f = h2 < 0.5 ? smoothstep(0.6, 0.0,length(p))*6. : 2.;\n    h = h < h2\/1.2 + 0.1 && vert ? 1. : 0.;\n    vec3 acc = hsv2rgb(vec3(h2\/5.+time\/30.,.9,0.9))*h*band*3.*f;\n    return acc*pow(abs(dir.z),.5);\n}\n\nvec3 background(vec3 dir){\n    return grid(dir.zxy, true) + grid(dir.yxz, false);\n}\n\nfloat box(vec3 p, vec3 w){\n    p = abs(p);\n    return max(p.x-w.x, max(p.y-w.y, p.z-w.z));\n}\n\nfloat map(vec3 p){\n    for (int i = 0; i < 3; i++){\n        p = abs(p*rotation + vec3(0.1, .0, .0));\n        p.x -= (sin(time\/8.) + 1.)\/2.;\n        p.y -= (sin(time\/7.) + 1.)\/3.;\n        p.z -= (sin(time\/3.) + 1.)\/4.;\n    }\n    return box(p, vec3(0.8, 4.4, 0.4));\n}\n\nvec3 normal(vec3 pos)\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(map(pos+eps.xyy) - map(pos-eps.xyy),\n                    map(pos+eps.yxy) - map(pos-eps.yxy),\n                    map(pos+eps.yyx) - map(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\nvec3 selfReflect(Ray ray){\n    float dist = 0.01;\n    vec3 pos;\n    float minDist = 1000.;\n    float curMap;\n    for (int i = 0; i < 30; i++){\n        pos = ray.org + dist*ray.dir;\n        curMap = map(pos);\n        dist+=curMap;\n        if(i > 7){\n            minDist = min(minDist,curMap);\n        }\n    }\n    float m = map(pos);\n    if (m < 0.01){\n        vec3 n = normal(pos);\n        vec3 r = reflect(ray.dir, n);\n        vec3 refl = background(r);\n        float rf = 0.8-abs(dot(ray.dir, n))*.4;\n        rf *= rf;\n        return refl*rf*1.3; \n    }\n    float glow = 0.02\/minDist;\n\n    return background(ray.dir)*0.5 + glow * vec3(1.9, 2.4, 3.2);\n}\n\nvec3 render(Ray ray){\n    float dist = 0.;\n    vec3 pos;\n    float minDist = 1000.;\n    float curMap;\n    for (int i = 0; i < 40; i++){\n        pos = ray.org + dist*ray.dir;\n        curMap = map(pos);\n        dist+=curMap;\n        minDist = min(minDist,curMap);\n    }\n    float m = map(pos);\n    if (m < 0.01){\n        vec3 n = normal(pos);\n        vec3 r = reflect(ray.dir, n);\n        vec3 refl = selfReflect(Ray(pos, r));\n        float rf = 0.8-abs(dot(ray.dir, n))*.4;\n        rf *= rf;\n        return refl*rf*1.3; \n    }\n    float glow = 0.02\/minDist;\n\n    return background(ray.dir)*0.5 + glow * vec3(1.9, 2.4, 3.2);\n}\n\nRay createRay(vec3 center, vec3 lookAt, vec3 up, vec2 uv, float fov, float aspect)\n{\n\tRay ray;\n\tray.org = center;\n\tvec3 dir = normalize(lookAt - center);\n\tup = normalize(up - dir*dot(dir,up));\n\tvec3 right = cross(dir, up);\n\tuv = 2.*uv - vec2(1.);\n\tfov = fov * 3.1415\/180.;\n\tray.dir = dir + tan(fov\/2.) * right * uv.x + tan(fov\/2.) \/ aspect * up * uv.y;\n\tray.dir = normalize(ray.dir);\t\n\treturn ray;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    size.xy = iResolution.xy;\n    time = iGlobalTime;\n    vec2 p = fragCoord \/ size;\n\tvec3 cameraPos = vec3(-8.,2.*sin(time\/10.),-4.*sin(time\/4.));\n\tvec3 lookAt = vec3(0.);\n\tvec3 up = vec3(0.,0.,1.);\n\tfloat aspect = size.x\/size.y;\n    float xt = floor(time\/8.) + clamp(fract(time\/8.)*20.,0.,1.);\n    float yt = floor(time\/2.) + clamp(fract(time\/2.)*5.,0.,1.);\n    rotation = rotateX(xt*PI\/4.)*rotateY(yt*PI\/2.);\n\tRay ray = createRay(cameraPos, lookAt, up, p, 90., aspect);\n    vec3 col = render(ray);\n    col = clamp(col, 0., 1.);\n    fragColor = vec4(col, 1.);\n}\n\n","name":"","description":"","type":"image"}]}}