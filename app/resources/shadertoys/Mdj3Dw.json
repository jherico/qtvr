{"Shader":{"ver":"0.1","info":{"id":"Mdj3Dw","date":"1389640710","viewed":798,"name":"Quintic B\u00e9zier Distance","username":"HLorenzi","description":"Quintic B\u00e9zier curve distance approximation! Described at http:\/\/pomax.github.io\/bezierinfo\/ The shader got broken recently...","likes":4,"published":3,"flags":0,"tags":["bezier","line","distance","curve","quintic","fifth","order"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Is it fast for everyone? 60 FPS here.\n\/\/ I tried some obvious optimizations, but it hurt performance badly. (Line 49)\n\/\/ Looks like some obscure compiler behavior, I have no idea.\n\n\/\/ Also, is step()+mix() faster than if blocks? (Line 111)\n\/\/ Perhaps step() is translated into if blocks internally...\n\n\n\n\/\/ The higher the better!\n#define INITIAL_APPROXIMATION 32\n#define FINE_APPROXIMATION 6\n\n\/\/ Early out distance limit after initial approximation\n#define EARLY_OUT 0.6\n\n\n\nfloat time;\n\nfloat hash(float x)\n{\n    return fract(sin(x) * 43758.5453) * 2.0 - 1.0;\n}\n\nfloat noise(float t)\n{\n\treturn mix(hash(floor(t)),hash(floor(t + 1.0)),fract(t));\n}\n\nvec4 HSVtoRGB(vec3 c)\n{\n    c.x \/= 360.0;\n    vec4 K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return vec4( c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y), 1.0 );\n}\n\nvec2 bezier(float t) \n{\n\t\/\/ I tried moving this to global scope, computing the points\n\t\/\/ only once per pixel, but it actually ruined performance... \n\tvec2 p[6];\n\tfor(int i = 0; i < 6; i++)\n\t{\n\t\tp[i] = vec2(noise(time + (float(i) * 1.3 + 2.4)) * 1.5,\n\t\t\t\t\t\t noise(time + (float(i) * 2.3 + 3.4)));\n\t}\n\t\n\treturn pow(1.0 - t, 5.0) * p[0] +\n\t\t\t5.0 * t * pow(1.0 - t, 4.0) * p[1] +\n\t\t\t10.0 * pow(t, 2.0) * pow(1.0 - t, 3.0) * p[2] +\n\t\t\t10.0 * pow(t, 3.0) * pow(1.0 - t, 2.0) * p[3] +\n\t\t\t5.0 * pow(t, 4.0) * (1.0 - t) * p[4] +\n\t\t\tpow(t, 5.0) * p[5];\n}\n\nfloat distanceToSegment(vec2 p, vec2 a, vec2 b) {\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nvoid drawSegment(vec2 p, vec2 p0, vec2 p1, float r, vec4 color, inout vec4 c)\n{\n\tif (distanceToSegment(p, p0, p1) < r) c = color;\n}\n\nfloat sqrdistance(vec2 v)\n{\n\treturn dot(v,v);\n}\n\nfloat distanceToBezier(vec2 p)\n{\n\tfloat bestT = 0.0;\n\tfloat bestDist = 1e30;\n\t\n\tconst int iter = INITIAL_APPROXIMATION;\n\t\n\tfor(int i = 0; i <= iter; i++)\n\t{\n\t\tfloat t = float(i) \/ float(iter);\n\t\tfloat d = sqrdistance(p - bezier(t));\n\t\tfloat p = step(d, bestDist);\n\t\tbestT = mix(bestT, t, p);\n\t\tbestDist = mix(bestDist, d, p);\n\t}\n\t\n\t\/\/ Early out; return approximation\n\tif (bestDist > EARLY_OUT * EARLY_OUT) return sqrt(bestDist);\n\t\n\tfloat interval = 1.0 \/ (float(iter) * 2.0);\n\t\t\n\tfor(int i = 0; i < FINE_APPROXIMATION; i++)\n\t{\n\t\tfloat tu = min(bestT + interval, 1.0);\n\t\tfloat tb = max(bestT - interval, 0.0);\n\t\tfloat du = sqrdistance(p - bezier(tu));\n\t\tfloat db = sqrdistance(p - bezier(tb));\n\t\t\n\t\t\/\/ Inline inequality tests and logical AND\n\t\tfloat pu = step(du, bestDist) * step(du, db);\n\t\tfloat pb = step(db, bestDist) * step(db, du);\n\t\t\n\t\t\/\/ Inline conditional execution\n\t\tbestT = mix(bestT, tu, pu);\n\t\tbestDist = mix(bestDist, du, pu);\n\t\t\n\t\tbestT = mix(bestT, tb, pb);\n\t\tbestDist = mix(bestDist, db, pb);\n\t\t\n\t\tinterval = mix(interval, interval * 0.5, 1.0 - pu - pb);\n\t}\n\n\treturn sqrt(bestDist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\ttime = iGlobalTime - 10.0 + 25.49;\n\t\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\tuv *= 2.0;\n\tuv -= 1.0;\n\tuv.x *= iResolution.x \/ iResolution.y;\n\t\n\t\n\tfloat d = distanceToBezier(uv);\n\t\n\tvec4 rainbow = HSVtoRGB(vec3(d * 900.0,1,1));\n\t\n\tvec4 line = vec4(1,1,1,1);\n\tif (d < 0.02) line = vec4(1,0,0,1);\n\t\n\tvec2 last = vec2(noise(time + (2.4)) * 1.5, noise(time + (3.4)));\n\tfor(int i = 1; i < 6; i++)\n\t{\n\t\tvec2 next = vec2(noise(time + (float(i) * 1.3 + 2.4)) * 1.5, \n\t\t\t\t\t\t noise(time + (float(i) * 2.3 + 3.4)));\n\t\t\n\t\tdrawSegment(uv, last, next, 0.005, vec4(0,0,float(i) \/ 5.0,1), line); \n\t\tlast = next;\n\t}\n\t\n\t\n\tfragColor = mix(rainbow, line, clamp((cos(time) * 1.5 + 0.5),0.0,1.0));\n\t\n}","name":"","description":"","type":"image"}]}}