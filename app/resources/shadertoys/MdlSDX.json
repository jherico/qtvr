{"Shader":{"ver":"0.1","info":{"id":"MdlSDX","date":"1407459297","viewed":1084,"name":"Derivatives - boundaries","username":"iq","description":"A demonstration of how GPU derivatives don't work across 2x2 render tile boundaries. GPUs render in tiles of 2x2 pixels, and derivatives can only be computed within it. Signal changes that occur between to tiles can't be detected by dFdx()\/dFdy()\/fwidth()","likes":4,"published":3,"flags":0,"tags":["2d","glsl","derivatives"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ I create a vertical line pattern which is 8 white pixels wide and 8 black pixels wide. \n\/\/ The pattern is moving one pixel to the left every second.\n\/\/\n\/\/ Line 19 tries to detect edges in the iamge (the pattern) by taking derivatives\/differences\n\/\/ of the pixel colros by using GLSL's dFdx() derivative operator. However, the operator only\n\/\/ detects the edges when the pattern is aligned to an odd pxiel (ever other second), but it\n\/\/ fails to detect it when the edge happens at the tile boundaries (even pixels)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float off = iGlobalTime;\n    \n    vec2 ti = floor((fragCoord.xy+off)\/8.0);\n    \n    float f = mod( ti.x, 2.0 );\n    \n    if( fragCoord.x>(iResolution.x\/2.0) )\n        f = clamp( 10.0*abs(dFdx(f)), 0.0, 1.0 );\n    \n\tfragColor = vec4(f,f,f,1.0);\n}","name":"","description":"","type":"image"}]}}