{"Shader":{"ver":"0.1","info":{"id":"4tfGzr","date":"1417683449","viewed":944,"name":"Toy Train","username":"dr2","description":"In the predigital age every kid wanted a toy train; here is the virtual version (every so often there is a closeup view).","likes":15,"published":3,"flags":0,"tags":["raymarching","train"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ \"Toy Train\" by dr2 - 2014\n\/\/ License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, cHashA3.xy)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nvec3 BrickSurfCol (vec2 p) {\n  vec2 q = p * (1. \/ 20.);\n  vec2 i = floor (q);\n  if (2. * floor (i.y \/ 2.) != i.y) {\n    q.x += 0.5;\n    i = floor (q);\n  }\n  q = smoothstep (0.015, 0.025, abs (fract (q + 0.5) - 0.5));\n  return (1. + Noisefv2 (10. * p)) * (0.3 + 0.7 * q.x * q.y) *\n     (0.3 + 0.2 * sin (2. * Hashfv2 (i) + vec3 (1., 1.2, 1.4)));\n}\n\nvec3 BrickCol (vec3 p, vec3 n)\n{\n  n = abs (n);\n  p *= 150.;\n  return BrickSurfCol (p.zy) * n.x + BrickSurfCol (p.xz) * n.y +\n     BrickSurfCol (p.xy) * n.z;\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z \/ h, -1., 1.))) - r;\n}\n\nint idObj;\nmat3 trainMat[3], trMat;\nvec3 trainPos[3], trPos, qHit, ltDir;\nfloat tCur, tRun, trVel, trkRad, trkLin, trkWid;\nconst float dstFar = 40., sFac = 0.2;\nbool onTrk, sigStop;\nconst float pi = 3.14159;\n\nconst int idEng = 1, idCabin = 2, idCoal = 3, idBase = 4, idBand = 4,\n   idAxle = 4, idCar = 5, idRoof = 6, idWheel = 7, idSpoke = 7, idCrod = 8,\n   idFunl = 9, idFunt = 10, idStripe = 10, idLamp = 11, idRail = 12,\n   idTie = 13, idPlat = 14, idSig = 15, idCpl = 16, idGrnd = 17;\n\nfloat EngDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d, aw, a;\n  float wRad = 0.8;\n  q = p;\n  q -= vec3 (0., -0.2, 0.5);\n  d = PrCapsDf (q, 1., 2.);\n  d = max (d, - (q.z + 1.7));\n  if (d < dHit) { dHit = d;  idObj = idEng; }\n  q = p;\n  q.z = abs (q.z - 0.85);\n  q -= vec3 (0., -0.2, 1.8);\n  d = PrCylDf (q, 1.05, 0.05);\n  if (d < dHit) { dHit = d;  idObj = idBand; }\n  q = p;\n  q -= vec3 (0., -1.3, -0.25);\n  d = PrBoxDf (q, vec3 (1., 0.1, 3.2));\n  if (d < dHit) { dHit = d;  idObj = idBase; }\n  q = p;\n  q -= vec3 (0., -1.4, 3.);\n  d = PrBoxDf (q, vec3 (1.1, 0.2, 0.07));\n  if (d < dHit) { dHit = d;  idObj = idBase; }\n  q.x = abs (q.x);\n  q -= vec3 (0.6, 0., 0.1);\n  d = PrCylDf (q, 0.2, 0.1);\n  if (d < dHit) { dHit = d;  idObj = idRoof; }\n  q = p;\n  q -= vec3 (0., 0.01, -1.75);\n  d = max (max (PrBoxDf (q, vec3 (1., 1.4, 0.6)),\n     - PrBoxDf (q - vec3 (0., 0., -0.2), vec3 (0.95, 1.3, 0.65))),\n     - PrBoxDf (q - vec3 (0., 0.7, 0.), vec3 (1.1, 0.4, 0.5)));\n  q.x = abs (q.x);\n  q -= vec3 (0.4, 1., 0.4);\n  d = max (d, - PrBoxDf (q, vec3 (0.35, 0.15, 0.3)));\n  if (d < dHit) { dHit = d;  idObj = idCabin;  qHit = q; }\n  q = p;\n  q -= vec3 (0., -2.4, -1.75);\n  d = max (PrCylDf (q, 4., 0.65), - (q.y - 3.75));\n  if (d < dHit) { dHit = d;  idObj = idRoof; }\n  q = p;\n  q -= vec3 (0., -0.5, -3.15);\n  d = PrBoxDf (q, vec3 (1., 0.7, 0.3));\n  if (d < dHit) { dHit = d;  idObj = idCoal;  qHit = q; }\n  q = p;\n  q -= vec3 (0., -1.4, -3.5);\n  d = PrCylDf (q.xzy, 0.4, 0.03);\n  if (d < dHit) { dHit = d;  idObj = idCpl; }\n  q = p;\n  q.xz = abs (q.xz);\n  q -= vec3 (trkWid - 0.12, -1.4, 1.1);\n  d = min (max (min (PrCylDf (q.zyx, wRad, 0.1),\n     PrCylDf (q.zyx - vec3 (0.,0., -0.07), wRad + 0.05, 0.03)),\n     - PrCylDf (q.zyx, wRad - 0.1, 0.12)), PrCylDf (q.zyx, 0.15, 0.10));\n  if (d < dHit) { dHit = d;  idObj = idWheel; }\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (trkWid - 0.17, -1.4, 1.1 * sign (q.z));\n  aw = - (trVel \/ wRad) * tRun;\n  q.yz = q.yz * cos (aw) * vec2 (1., 1.) + q.zy * sin (aw) * vec2 (-1., 1.);  \n  a = floor ((atan (q.y, q.z) + pi) * 8. \/ (2. * pi) + 0.5) \/ 8.;\n  q.yz = q.yz * cos (2. * pi * a) * vec2 (1., 1.) +\n     q.zy * sin (2. * pi * a) * vec2 (-1., 1.);\n  q.z += 0.5 * wRad;\n  d = PrCylDf (q, 0.05, 0.5 * wRad);\n  if (d < dHit) { dHit = d;  idObj = idSpoke; }\n  q = p;\n  float sx = sign (q.x);\n  q.x = abs (q.x);\n  q -= vec3 (trkWid + 0.08, -1.4, 0.);\n  aw -= 0.5 * pi * sx; \n  q.yz -= 0.3 * vec2 (cos (aw), - sin (aw));\n  d = PrCylDf (q, 0.04, 1.2);\n  if (d < dHit) { dHit = d;  idObj = idCrod; }\n  q.z = abs (q.z);\n  q -= vec3 (-0.1, 0., 1.1);\n  d = PrCylDf (q.zyx, 0.06, 0.15);\n  if (d < dHit) { dHit = d;  idObj = idCrod; }\n  q = p;\n  q.z = abs (q.z);\n  q -= vec3 (0., -1.4, 1.1);\n  d = PrCylDf (q.zyx, 0.1, trkWid - 0.1);\n  if (d < dHit) { dHit = d;  idObj = idAxle; }\n  q = p;\n  q -= vec3 (0., 1.1, 2.15);\n  d = PrCylDf (q.xzy, 0.3, 0.5);\n  if (d < dHit) { dHit = d;  idObj = idFunl; }\n  q = p;\n  q -= vec3 (0., 1.5, 2.15);\n  d = max (PrCylDf (q.xzy, 0.4, 0.15), - PrCylDf (q.xzy, 0.3, 0.2));\n  if (d < dHit) { dHit = d;  idObj = idFunt; }\n  q = p;\n  q -= vec3 (0., 0.8, 0.55);\n  d = PrCapsDf (q.xzy, 0.3, 0.2);\n  if (d < dHit) { dHit = d;  idObj = idFunt; }\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (1., -0.2, 0.85);\n  d = PrBoxDf (q, vec3 (0.05, 0.1, 1.8));\n  if (d < dHit) { dHit = d;  idObj = idStripe; }\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (1., -0.2, -1.75);\n  d = PrBoxDf (q, vec3 (0.05, 0.1, 0.6));\n  if (d < dHit) { dHit = d;  idObj = idStripe; }\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (1., -0.2, -3.15);\n  d = PrBoxDf (q, vec3 (0.05, 0.1, 0.3));\n  if (d < dHit) { dHit = d;  idObj = idStripe; }\n  q = p;\n  q -= vec3 (0., -0.2, 3.5);\n  d = PrCylDf (q, 0.2, 0.1);\n  if (d < dHit) { dHit = d;  idObj = idLamp; }\n  return dHit;\n}\n\nfloat CarDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d;\n  float wRad = 0.35;\n  q = p;\n  d = max (max (PrBoxDf (q, vec3 (1.3, 1.4, 2.8)),\n     - PrBoxDf (q, vec3 (1.2, 1.3, 2.7))),\n     - PrBoxDf (q, vec3 (0.5, 1., 2.9)));\n  q.z = abs (q.z);\n  q -= vec3 (0., 0.6, 1.2);\n  d = max (d, - PrBoxDf (q, vec3 (1.4, 0.7, 1.1)));\n  if (d < dHit) { dHit = d;  idObj = idCar; qHit = q; }\n  q = p; \n  q.y -= -2.35;\n  d = max (PrCylDf (q, 4., 2.8), - (q.y - 3.75));\n  if (d < dHit) { dHit = d;  idObj = idRoof; }\n  q = p;\n  q.z = abs (q.z);\n  q -= vec3 (0., -0.2, 2.75);\n  d = PrCylDf (q.zyx, 0.05, 0.5);\n  if (d < dHit) { dHit = d;  idObj = idRoof;  qHit = q; }\n  q = p;\n  q.y -= -1.6;\n  d = PrBoxDf (q, vec3 (0.8, 0.3, 2.));\n  if (d < dHit) { dHit = d;  idObj = idBase; }\n  q = p;\n  q.z = abs (q.z);\n  q -= vec3 (0., -1.4, 2.9);\n  d = PrCylDf (q.xzy, 0.4, 0.03);\n  if (d < dHit) { dHit = d;  idObj = idCpl; }\n  q = p;\n  q.xz = abs (q.xz);\n  q -= vec3 (trkWid - 0.12, -1.85, 1.1);\n  d = min (min (PrCylDf (q.zyx, wRad, 0.1),\n     PrCylDf (q.zyx - vec3 (0.,0., -0.07), wRad + 0.05, 0.03)),\n     PrCylDf (q.zyx, 0.15, 0.10));\n  q.x -= 0.1;\n  d = max (d, - (PrCylDf (q.zyx, 0.2, 0.05)));\n  if (d < dHit) { dHit = d;  idObj = idWheel; }\n  q = p;\n  q.z = abs (q.z);\n  q -= vec3 (0., -1.85, 1.1);\n  d = PrCylDf (q.zyx, 0.1, trkWid - 0.15);\n  if (d < dHit) { dHit = d;  idObj = idAxle; }\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (1.3, -0.2, 0.);\n  d = PrBoxDf (q, vec3 (0.05, 0.1, 2.8));\n  if (d < dHit) { dHit = d;  idObj = idStripe; }\n  return dHit;\n}\n\nfloat TrackDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d, nt;\n  float gHt = 2.8;\n  q = p;\n  if (onTrk) {\n    q.z -= 0.5 * trkLin * clamp (p.z \/ (0.5 * trkLin), -1., 1.);\n    q.x = abs (length (q.xz) - trkRad);\n    q -= vec3 (trkWid - 0.03, - gHt + 0.45, 0.);\n    d = length (max (abs (q.xy) - vec2 (0.07, 0.13), 0.));\n  } else {\n    q.x = abs (q.x);\n    q -= vec3 (trkWid - 0.03, - gHt + 0.45, 0.);\n    d = max (length (max (abs (q.xy) - vec2 (0.07, 0.13), 0.)),\n       abs (q.z) - 0.5 * trkLin);\n  }\n  if (d < dHit) { dHit = d;  idObj = idRail; }\n  q = p;\n  if (onTrk) q.x = abs (q.x) - trkRad;\n  q -= vec3 (0., - gHt + 0.2, 0.);\n  nt = 2.;\n  float gap = trkLin \/ nt;\n  q.z = mod (q.z + 0.5 * gap, gap) - 0.5 * gap;\n  d = PrBoxDf (q, vec3 (trkWid + 0.5, 0.2, 0.4));\n  q = p;\n  q.y -= - gHt + 0.2;\n  d = max (d, PrBoxDf (q, vec3 (trkRad + 3., 2., 0.5 * trkLin + 2.)));\n  if (d < dHit) { dHit = d;  idObj = idTie; }\n  if (onTrk) {\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (0., - gHt + 0.2, 0.5 * trkLin * sign (q.z));\n    nt = 12.;\n    float a = floor ((atan (q.x, q.z) + pi) * nt \/ (2. * pi) + 0.5) \/ nt;\n    q.xz = q.xz * cos (2. * pi * a) * vec2 (1., 1.) +\n       q.zx * sin (2. * pi * a) * vec2 (-1., 1.);\n    q.z -= - trkRad;\n    d = PrBoxDf (q, vec3 (0.4, 0.2, trkWid + 0.5));\n    q = p;\n    q.y -= - gHt + 0.2;\n    d = max (d, - PrBoxDf (q, vec3 (trkRad + 3., 2., 0.5 * trkLin + 2.)));\n    if (d < dHit) { dHit = d;  idObj = idTie; }\n    q = p;\n    q -= vec3 (trkRad - trkWid - 2., - gHt + 0.6, 0.);\n    d = max (PrBoxDf (q, vec3 (trkWid, 0.4, 14.)), 0.5 * (abs (q.z) - 7.) + q.y);\n    q -= vec3 (-1.2, 1.9, 0.);\n    d = min (d, PrBoxDf (q, vec3 (0.2, 1.8, 5.)));\n    q.z = abs (q.z) - 2.4;\n    d = max (d,  - PrBoxDf (q, vec3 (0.3, 1.3, 1.7)));\n    if (d < dHit) { dHit = d;  idObj = idPlat;  qHit = q; }\n    q = p;\n    q -= vec3 (trkRad - trkWid - 2.5, 0.8, 6.);\n    d = PrCylDf (q.xzy, 0.15, 3.);\n    if (d < dHit) { dHit = d;  idObj = idRail; }\n    q.y -= 3.;\n    d = PrSphDf (q, 0.35);\n    if (d < dHit) { dHit = d;  idObj = idSig; } \n    q = p;\n    q.y -= - gHt;\n    d = PrBoxDf (q, vec3 (trkRad + trkWid + 2.5, 0.1,\n       trkRad + 0.5 * trkLin + trkWid + 2.5));\n    if (d < dHit) { dHit = d;  idObj = idGrnd;  qHit = q; } \n  }\n  return dHit;\n}\n\nvoid TrainCarPM (float s)\n{\n  float a, ca, sa;\n  if (onTrk) {\n    s = mod (s, 2. * (pi * trkRad + trkLin));\n    if (s < trkLin) {\n      trPos = vec3 (trkRad, 0., s - 0.5 * trkLin);\n      ca = 1.;  sa = 0.;\n    } else if (s < trkLin + pi * trkRad) {\n      a = (s - trkLin) \/ trkRad;\n      ca = cos (a);  sa = sin (a);\n      trPos = vec3 (trkRad * ca, 0., 0.5 * trkLin + trkRad * sa);\n    } else if (s < 2. * trkLin + pi * trkRad) {\n      trPos = vec3 (- trkRad, 0., 1.5 * trkLin + pi * trkRad - s);\n      ca = -1.;  sa = 0.;\n    } else {\n      a = (s - (pi * trkRad + 2. * trkLin)) \/ trkRad + pi;\n      ca = cos (a);  sa = sin (a);\n      trPos = vec3 (trkRad * ca, 0., - 0.5 * trkLin + trkRad * sa);\n    }\n  } else {\n    trPos = vec3 (0., 0., 0.3 * trkLin + s);\n    ca = 1.;  sa = 0.;\n  }\n  trMat = mat3 (ca, 0., - sa, 0., 1., 0., sa, 0., ca);\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dHit = dstFar \/ sFac;\n  p \/= sFac;\n  dHit = EngDf (trainMat[0] * (p - trainPos[0]), dHit);\n  dHit = CarDf (trainMat[1] * (p - trainPos[1]), dHit);\n  dHit = CarDf (trainMat[2] * (p - trainPos[2]), dHit);\n  dHit = TrackDf (p, dHit);\n  return dHit * sFac;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  const float dTol = 0.001;\n  float d;\n  float dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < dTol || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  float v0 = ObjDf (p + e.xxx);\n  float v1 = ObjDf (p + e.xyy);\n  float v2 = ObjDf (p + e.yxy);\n  float v3 = ObjDf (p + e.yyx);\n  return normalize (vec3 (v0 - v1 - v2 - v3) + 2. * vec3 (v1, v2, v3));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh = 1.;\n  float d = 0.02;\n  for (int i = 0; i < 30; i++) {\n    float h = ObjDf (ro + rd * d);\n    sh = min (sh, 20. * h \/ d);\n    d += 0.02 + 0.01 * d;\n    if (h < 0.001) break;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao = 0.;\n  for (int i = 0; i < 8; i ++) {\n    float d = 0.1 + float (i) \/ 8.;\n    ao += max (0., d - 3. * ObjDf (ro + rd * d));\n  }\n  return clamp (1. - 0.1 * ao, 0., 1.);\n}\n\nvec4 ObjCol (vec3 n)\n{\n  const vec4 cLo = vec4 (0.4, 0.2, 0.1, 1.), cHi = vec4 (0., 1., 0., 1.),\n     cBlk = vec4 (vec3 (0.01), 0.1), cCab = vec4 (0.2, 0.2, 0.8, 1.),\n     cRf = vec4 (1., 0.1, 0.1, 1.);\n  vec4 col4;\n  if (idObj == idGrnd) col4 =\n     vec4 (0., 0.2, 0., 0.) + 0.03 * Noisefv2 (10. * qHit.xz);\n  else if (idObj == idEng) col4 = cHi;\n  else if (idObj == idCabin) col4 = (qHit.y > -1.3) ? cCab : cLo;\n  else if (idObj == idCoal)\n     col4 = (qHit.y > 0.3) ? ((n.y > 0.9) ? cBlk : cCab) : cLo;\n  else if (idObj == idBase || idObj == idBand || idObj == idAxle)\n     col4 = vec4 (0.3, 0.2, 0.2, 0.3);\n  else if (idObj == idCar) col4 = (qHit.y > -0.8) ? cHi : cLo;\n  else if (idObj == idRoof) col4 = cRf;\n  else if (idObj == idWheel || idObj == idSpoke) col4 = vec4 (0.5, 0.5, 0.6, 2.);\n  else if (idObj == idCrod) col4 = vec4 (0.7, 0.7, 0.1, 1.);\n  else if (idObj == idFunl) col4 = (n.y > 0.9) ? cBlk : cRf;\n  else if (idObj == idStripe || idObj == idFunt) col4 = vec4 (1., 1., 0., 1.);\n  else if (idObj == idLamp)\n     col4 = (mod (tCur, 2.) < 1.) ? vec4 (5.) : vec4 (1.);\n  else if (idObj == idRail) col4 = vec4 (0.8, 0.8, 0.8, 1.);\n  else if (idObj == idTie) col4 = vec4 (0.4, 0.2, 0.2, 0.3);\n  else if (idObj == idPlat)\n     col4 = vec4 (vec3 (0.5, 0.3, 0.3) * BrickCol (0.3 * qHit, n), 1.);\n  else if (idObj == idSig)\n    col4 = sigStop ? vec4 (1., 0., 0., 0.5) : vec4 (0., 1., 0., 0.5);\n  else if (idObj == idCpl) col4 = vec4 (0.2, 0.1, 0.2, 0.5);\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, objCol;\n  float dstHit;\n  vec3 col = vec3 (0., 0., 0.04);\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  if (idObj < 0) dstHit = dstFar;\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    int idObjT = idObj;\n    if (idObj != idGrnd) vn = ObjNf (ro);\n    else vn = vec3 (0., 1., 0.);\n    idObj = idObjT;\n    vec4 col4 = ObjCol (vn);\n    objCol = col4.xyz;\n    float spec = col4.w;\n    float dif = max (dot (vn, ltDir), 0.);\n    float ao = ObjAO (ro, vn);\n    float sh;\n    if (idObj != idGrnd || length (qHit.xy) > trkRad - 3. * trkWid)\n       sh = ObjSShadow (ro, ltDir);\n    else sh = 1.;\n    col = objCol * (0.2 * ao * (1. +\n       max (dot (vn, - normalize (vec3 (ltDir.x, 0., ltDir.z))), 0.)) +\n       max (0., dif) * sh * (dif + ao * spec *\n       pow (max (0., dot (ltDir, reflect (rd, vn))), 64.)));\n  }\n  col = sqrt (clamp (col, 0., 1.));\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy \/ iResolution.xy - 1.;\n  uv.x *= iResolution.x \/ iResolution.y;\n  float zmFac = 6.;\n  tCur = iGlobalTime;\n  float dist = 15.;\n  trkRad = 20.;\n  trkLin = 20.;\n  trkWid = 1.42;\n  trVel = 6.;\n  float tCyc = 2. * (pi * trkRad + trkLin) \/ trVel;\n  float tPause = 0.1 * tCyc;\n  tCyc += tPause;\n  onTrk = (mod (floor (tCur \/ tCyc), 10.) != 5.);\n  if (onTrk) {\n    tRun = mod (tCur, tCyc);\n    float tHalt = trkLin \/ trVel;\n    sigStop = (tRun < tHalt + 0.8 * tPause);\n    if (tRun > tHalt + tPause) tRun = tRun - tPause;\n    else if (tRun > tHalt) tRun = tHalt;\n  } else tRun = 0.;\n  TrainCarPM (trVel * tRun);\n  trainPos[0] = trPos;  trainMat[0] = trMat;\n  TrainCarPM (trVel * tRun - 7.);\n  trainPos[1] = trPos;  trainMat[1] = trMat;\n  TrainCarPM (trVel * tRun - 13.4);\n  trainPos[2] = trPos;  trainMat[2] = trMat;\n  vec3 ro, rd, vd;\n  if (onTrk) {\n    ro = vec3 (- dist, 0.4 * dist, 0.25 * (trainPos[0] + trainPos[1]).z * sFac);\n    vd = normalize (vec3 (- ro.xy, 0.));\n    ro.y -= 0.04 * dist;\n    vec3 u = - vd.y * vd;\n    float f = 1. \/ sqrt (1. - vd.y * vd.y);\n    mat3 scMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n    rd = scMat * normalize (vec3 (uv, zmFac));\n    ltDir = normalize (vec3 (-0.3, 1., -1.));\n  } else {\n    trVel = 1.;\n    tRun = tCur;\n    float ph = 2. * pi * tCur \/ tCyc;\n    float el = 0.2 - 0.25 * sin (ph);\n    float az = 0.5 * pi + ph;\n    float cEl = cos (el);\n    float sEl = sin (el);\n    float cAz = cos (az);\n    float sAz = sin (az);\n    mat3 vuMat = mat3 (1., 0., 0., 0., cEl, - sEl, 0., sEl, cEl) *\n       mat3 (cAz, 0., sAz, 0., 1., 0., - sAz, 0., cAz);\n    rd = normalize (vec3 (uv, 1.8 * zmFac)) * vuMat;\n    ro = - vec3 (0., 0.01 * dist, dist) * vuMat;\n    ltDir = normalize (vec3 (0.3, 0.5, -1.)) * vuMat;\n  }\n  vec3 col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n","name":"","description":"","type":"image"}]}}