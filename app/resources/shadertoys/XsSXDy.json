{"Shader":{"ver":"0.1","info":{"id":"XsSXDy","date":"1415342767","viewed":1181,"name":"Bicubic - comparison","username":"iq","description":"Comparison of BSpline, \"typical\" and  Catmull-Rom bicubic texture filtering. This is done the slow way (16 samples) instead of the optimized GPU bilinear based filtering. Bottom part shows derivatives of the above.","likes":10,"published":3,"flags":0,"tags":["2d","bicubicfiltering"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/*\nComparison of three bicubic filter kernels. B=Spline, Catmull-Rom and \"recommended\", as described\nin this article: http:\/\/http.developer.nvidia.com\/GPUGems\/gpugems_ch24.html\n\nDone the naive way with 16 samples rather than the smart way of performing bilinear filters. For\nthe fast way to do it, see Dave Hoskins' shader: https:\/\/www.shadertoy.com\/view\/4df3Dn\n\n\n\/\/ Mitchell Netravali Reconstruction Filter\n\/\/ B = 1,   C = 0   - cubic B-spline\n\/\/ B = 1\/3, C = 1\/3 - recommended\n\/\/ B = 0,   C = 1\/2 - Catmull-Rom spline\n\/\/\n\/\/ ca = {  12 - 9*B - 6*C,  -18 + 12*B + 6*C, 0, 6 - 2*B  } \/ 6;\n\/\/ cb = {  -B - 6*C, 6*B + 30*C, -12*B - 48*C, 8*B + 24*C } \/ 6;\n*\/\n\n\/\/-----------------------------------------------------------------------------------------\n\nvec4 BS_A = vec4(   3.0,  -6.0,   0.0,  4.0 ) \/  6.0;\nvec4 BS_B = vec4(  -1.0,   6.0, -12.0,  8.0 ) \/  6.0;\nvec4 RE_A = vec4(  21.0, -36.0,   0.0, 16.0 ) \/ 18.0;\nvec4 RE_B = vec4(  -7.0,  36.0, -60.0, 32.0 ) \/ 18.0;\nvec4 CR_A = vec4(   3.0,  -5.0,   0.0,  2.0 ) \/  2.0;\nvec4 CR_B = vec4(  -1.0,   5.0,  -8.0,  4.0 ) \/  2.0;\n        \nvec4 powers( float x ) { return vec4(x*x*x, x*x, x, 1.0); }\n\nvec4 ca, cb;\n\nvec4 spline( float x, vec4 c0, vec4 c1, vec4 c2, vec4 c3 )\n{\n    \/\/ We could expand the powers and build a matrix instead (twice as many coefficients\n    \/\/ would need to be stored, but it could be faster.\n    return c0 * dot( cb, powers(x + 1.0)) + \n           c1 * dot( ca, powers(x      )) +\n           c2 * dot( ca, powers(1.0 - x)) +\n           c3 * dot( cb, powers(2.0 - x));\n}\n\n#define SAM(a,b)  texture2D(iChannel0, (i+vec2(float(a),float(b))+0.5)\/res, -99.0)\n\nvec4 texture2D_Bicubic( sampler2D tex, vec2 t )\n{\n    vec2 res = iChannelResolution[0].xy;\n    vec2 p = res*t - 0.5;\n    vec2 f = fract(p);\n    vec2 i = floor(p);\n\n    return spline( f.y, spline( f.x, SAM(-1,-1), SAM( 0,-1), SAM( 1,-1), SAM( 2,-1)),\n                        spline( f.x, SAM(-1, 0), SAM( 0, 0), SAM( 1, 0), SAM( 2, 0)),\n                        spline( f.x, SAM(-1, 1), SAM( 0, 1), SAM( 1, 1), SAM( 2, 1)),\n                        spline( f.x, SAM(-1, 2), SAM( 0, 2), SAM( 1, 2), SAM( 2, 2)));\n}\n\n\/\/-----------------------------------------------------------------------------------------\n\nvec4 lerp( float x, vec4 a, vec4 b ) { return mix(a,b,x); }\n\nvec4 texture2D_Bilinear( sampler2D tex, vec2 t )\n{\n    vec2 res = iChannelResolution[0].xy;\n    vec2 p = res*t - 0.5;\n    vec2 f = fract(p);\n    vec2 i = floor(p);\n\n    return lerp( f.y, lerp( f.x, SAM(0,0), SAM(1,0)),\n                      lerp( f.x, SAM(0,1), SAM(1,1)) );\n}\n\n\/\/-----------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy\/iResolution.x;\n    vec2 q = fragCoord.xy\/iResolution.xy;\n    \n    vec2 uv = vec2(0.0);\n\n         if( q.x<0.33 ) { ca=BS_A; cb=BS_B; uv = p-vec2(0.00,0.0); }\n    else if( q.x<0.66 ) { ca=RE_A; cb=RE_B; uv = p-vec2(0.33,0.0); }\n    else                { ca=CR_A; cb=CR_B; uv = p-vec2(0.66,0.0); }\n\n    uv = uv * 0.06 + 0.001*iGlobalTime;\n\n  \/\/vec3 cola = texture2D(          iChannel0, uv ).xyz;\n    vec3 cola = texture2D_Bilinear( iChannel0, uv ).xyz;\n    vec3 colb = texture2D_Bicubic(  iChannel0, uv ).xyz;\n    \n    vec3 col = mix( cola, colb, smoothstep( -0.1, 0.1, sin(2.0*iGlobalTime)) );\n\n    float gre = dot(col,vec3(0.333));\n    \n    vec3 colc = 0.5 + 50.0*vec3( dFdx(gre), dFdy(gre), 0.0 );\n    \n    col = mix( col, colc, step(q.y,0.40) );\n    \n    col *= smoothstep( 0.0, 2.0\/iResolution.x, abs(p.x-0.33) );\n    col *= smoothstep( 0.0, 2.0\/iResolution.x, abs(p.x-0.66) );\n    col *= smoothstep( 0.0, 2.0\/iResolution.y, abs(q.y-0.40) );\n    \n\tfragColor = vec4( col, 1.0 );\n}\n","name":"","description":"","type":"image"}]}}