{"Shader":{"ver":"0.1","info":{"id":"ld3GDX","date":"1452432230","viewed":220,"name":"KMT","username":"seanstone","description":"Animated flag of the Kuomintang","likes":1,"published":3,"flags":32,"tags":["vector"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Reinder Nijhoff 2016\n\/\/ @reindernijhoff\n\/\/\n\/\/ https:\/\/www.shadertoy.com\/view\/ls3GWS\n\/\/\n\/\/ car model is made by Eiffie\n\/\/ shader 'Shiny Toy': https:\/\/www.shadertoy.com\/view\/ldsGWB\n\/\/\n\/\/ demonstrating post process FXAA applied to my shader 'Tokyo': \n\/\/ https:\/\/www.shadertoy.com\/view\/Xtf3zn\n\/\/\n\/\/ FXAA code from: http:\/\/www.geeks3d.com\/20110405\/fxaa-fast-approximate-anti-aliasing-demo-glsl-opengl-test-radeon-geforce\/3\/\n\/\/\n\n#define FXAA_SPAN_MAX 8.0\n#define FXAA_REDUCE_MUL   (1.0\/FXAA_SPAN_MAX)\n#define FXAA_REDUCE_MIN   (1.0\/128.0)\n#define FXAA_SUBPIX_SHIFT (1.0\/4.0)\n\nvec3 FxaaPixelShader( vec4 uv, sampler2D tex, vec2 rcpFrame) {\n    \n    vec3 rgbNW = texture2D(tex, uv.zw, 0.0).xyz;\n    vec3 rgbNE = texture2D(tex, uv.zw + vec2(1,0)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSW = texture2D(tex, uv.zw + vec2(0,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSE = texture2D(tex, uv.zw + vec2(1,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbM  = texture2D(tex, uv.xy, 0.0).xyz;\n\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max(\n        (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),\n        FXAA_REDUCE_MIN);\n    float rcpDirMin = 1.0\/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n    \n    dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\n          max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n          dir * rcpDirMin)) * rcpFrame.xy;\n\n    vec3 rgbA = (1.0\/2.0) * (\n        texture2D(tex, uv.xy + dir * (1.0\/3.0 - 0.5), 0.0).xyz +\n        texture2D(tex, uv.xy + dir * (2.0\/3.0 - 0.5), 0.0).xyz);\n    vec3 rgbB = rgbA * (1.0\/2.0) + (1.0\/4.0) * (\n        texture2D(tex, uv.xy + dir * (0.0\/3.0 - 0.5), 0.0).xyz +\n        texture2D(tex, uv.xy + dir * (3.0\/3.0 - 0.5), 0.0).xyz);\n    \n    float lumaB = dot(rgbB, luma);\n\n    if((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;\n    \n    return rgbB; \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 rcpFrame = 1.\/iResolution.xy;\n  \tvec2 uv2 = fragCoord.xy \/ iResolution.xy;\n        \n    float splitCoord = (iMouse.x == 0.0) ? iResolution.x\/2. + iResolution.x*cos(iGlobalTime*.5) : iMouse.x;\n    \n    vec3 col;\n    \n\tvec4 uv = vec4( uv2, uv2 - (rcpFrame * (0.5 + FXAA_SUBPIX_SHIFT)));\n    col = FxaaPixelShader( uv, iChannel0, 1.\/iResolution.xy );\n    \n    fragColor = vec4( col, 1. );\n}","name":"","description":"","type":"image"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"float norm(vec2 v)\n{\n    return sqrt(v.x*v.x + v.y*v.y);\n}\n\nfloat sign (vec2 p1, vec2 p2, vec2 p3)\n{\n    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n}\n\nvec2 rotate(vec2 v, float tht)\n{\n    return vec2(cos(tht)*v.x - sin(tht)*v.y, sin(tht)*v.x + cos(tht)*v.y);\n}\n\n\n\nbool inTri(vec2 pt, float tht)\n{\n    float AMP = 20.;\n    float SPEED = 2.;\n    vec2 v1 = rotate(vec2(12., 55.), tht);\n    vec2 v2 = rotate(vec2(-12., 55.), tht);\n    vec2 v3 = rotate(vec2(0., 102. + AMP*sin(SPEED*iGlobalTime)), tht);\n    \n    bool b1, b2, b3;\n\n    b1 = sign(pt, v1, v2) < 0.0;\n    b2 = sign(pt, v2, v3) < 0.0;\n    b3 = sign(pt, v3, v1) < 0.0;\n\n    return ((b1 == b2) && (b2 == b3));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float PI = 3.141592;\n    float TRI_MIN = 60.;\n    float SPEED = -0.8;\n\tvec2 uv = fragCoord.xy - iResolution.xy\/2.0;\n    if(norm(uv) < 50.0) fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    else if(inTri(uv, 0.*2.*PI\/12. + SPEED*iGlobalTime) && (norm(uv) > TRI_MIN)) fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    else if(inTri(uv, 1.*2.*PI\/12. + SPEED*iGlobalTime) && (norm(uv) > TRI_MIN)) fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    else if(inTri(uv, 2.*2.*PI\/12. + SPEED*iGlobalTime) && (norm(uv) > TRI_MIN)) fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    else if(inTri(uv, 3.*2.*PI\/12. + SPEED*iGlobalTime) && (norm(uv) > TRI_MIN)) fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    else if(inTri(uv, 4.*2.*PI\/12. + SPEED*iGlobalTime) && (norm(uv) > TRI_MIN)) fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    else if(inTri(uv, 5.*2.*PI\/12. + SPEED*iGlobalTime) && (norm(uv) > TRI_MIN)) fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    else if(inTri(uv, 6.*2.*PI\/12. + SPEED*iGlobalTime) && (norm(uv) > TRI_MIN)) fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    else if(inTri(uv, 7.*2.*PI\/12. + SPEED*iGlobalTime) && (norm(uv) > TRI_MIN)) fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    else if(inTri(uv, 8.*2.*PI\/12. + SPEED*iGlobalTime) && (norm(uv) > TRI_MIN)) fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    else if(inTri(uv, 9.*2.*PI\/12. + SPEED*iGlobalTime) && (norm(uv) > TRI_MIN)) fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    else if(inTri(uv, 10.*2.*PI\/12. + SPEED*iGlobalTime) && (norm(uv) > TRI_MIN)) fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    else if(inTri(uv, 11.*2.*PI\/12. + SPEED*iGlobalTime) && (norm(uv) > TRI_MIN)) fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n\telse fragColor = vec4(13.\/255., 35.\/255., 146.\/255., 1.0);\n}","name":"","description":"","type":"buffer"}]}}