{"Shader":{"ver":"0.1","info":{"id":"XllXzM","date":"1435353285","viewed":681,"name":"Julia Rotater","username":"spookdy","description":"Fast Julia Set Animator<br\/><br\/>Known Bugs: Orbit trap code returns black (???) for some hardware","likes":1,"published":3,"flags":0,"tags":["fractal","juliaset","animation","complex"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/JULIA ROTATOR GLSL 6-26-15\n\n\/*\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n} *\/\n\nvec3 yuv2rgb(vec3 c){\n    return vec3(dot(c,vec3(1,0,1.14)),dot(c,vec3(1,-0.395,-0.581)),dot(c,vec3(1,2.032,0)));\n}\n\n\n\/\/ # of iterations 6.0, 20.0 and 50.0 are my favorites\nconst float iter = 30.0;\n \n\/\/ Julia animation from IQ's Julia Trap 1 shader    \nvec2 c = 0.51*cos( vec2(0.0,1.5708) + 0.1*iGlobalTime ) - 0.25*cos( vec2(0.0,1.5708) + 0.2*iGlobalTime ); \n\n\/\/const float speed = 5.0;\n\/\/vec c = vec2(0.6*sin(iGlobalTime\/speed),0.8*cos(iGlobalTime\/speed));\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n   \n    \/\/translate from pixel coords to [-2,2]x[-2,2] meshgrid\n    vec4 z = vec4(fragCoord.xy - 0.5*iResolution.xy,1,1);\n    z = vec4(4.0 * z.xy \/ iResolution.xy,1,1);\n   \n    bool inset = true;\n    float col=0.0;\n    \n    \/\/main iteration loop\n    for(float i=0.0; i<iter; i++){\n        \n        \/\/z_n+1 = z_n^2 + c\n        \/\/Uses dual numbering for automatic differentiation\n        float tzx = z.x*z.x - z.y*z.y + c.x;\n        float tzy = 2.0*z.x*z.y + c.y;\n        float tzdx = 2.0*(z.x - z.y);\n        z.w = 2.0*(z.x + z.y);\n        z.x = tzx;\n        z.y = tzy;\n        z.z = tzdx;\n        \n        float mag = z.x*z.x+z.y*z.y;\n        \n        \/\/uses exponential sum coloring to smooth area outside of set\n        col = col + exp(-sqrt(mag));\n        \n        if((mag)>200.0){\n            col = col \/ 3.0; \/\/ for contrast\n            inset=false;\n            break;\n        }\n    }\n    \n    \/\/distance formula f(z) = |z|*log|z|\/|z'|\n    if(inset)col = 0.5*sqrt(dot(z.xy,z.xy)\/dot(z.zw,z.zw))*log(dot(z.xy,z.xy));\n    col = pow(col,0.25);\n    \n    \/\/Plots pixel using a quick YUV2RGB algorithm\n    fragColor = vec4(yuv2rgb(vec3(0.5+0.5*sin(col),0.8,-col)),1.0);\n\t\/\/fragColor = vec4(hsv2rgb(vec3(col+0.55,1,1)),1.0);\n}","name":"","description":"","type":"image"}]}}