{"Shader":{"ver":"0.1","info":{"id":"XdjXD1","date":"1411600656","viewed":700,"name":"Quadratic bezier curves","username":"Doublefresh","description":"Drawing some 2d quadratic bezier curves, the SLOW way. Rotating the control points gives some cool fx. Click to move one of the points.","likes":8,"published":3,"flags":0,"tags":["bezier","curve","analytic"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"const float Pi = 3.1415926535;\n\nfloat Point(vec2 uv, vec2 P)\n{\n    return smoothstep(0.035, 0.005, distance(uv, P));   \n}\n\nfloat cbrt(float x)\n{\n    return sign(x) * pow(abs(x), 1.0\/3.0);\n}\n\n\/\/ http:\/\/tog.acm.org\/resources\/GraphicsGems\/gems\/Roots3And4.c\n\/\/ Solve cubic ax^3 + bx^2 + cx + d = 0 \n\/\/ Returns amount of roots\nint SolveCubic(vec4 coeffs, out vec3 roots)\n{\n    int nS = 0;  \n    \/\/ normal form: x^3 + Ax^2 + Bx + C = 0 \n    vec4 N = coeffs \/ coeffs[0];\n\n    \/\/ substitute x = y - A\/3 \n    \/\/ depressed cubic: x^3 + px + q = 0 \n    float sqA = N[1]*N[1];\n    float p = (N[2] - sqA\/3.0) \/ 3.0;\n    float q = ( (N[1] * sqA)\/13.5 - (N[1] * N[2])\/3.0 + N[3]) * 0.5;\n\n    \/\/ Use Cardano's formula \n    float cbP = p * p * p;\n    float D = q * q + cbP;\n\n    if (abs(D) < 1e-20)\n    {\n\t\tif (q == 0.0)  \n            nS = 1;\n\t\t   \n\t\telse \/\/ one single and one double solution\n\t\t{\n\t\t    float u = cbrt(-q);\n\t\t    roots[0] = 2.0 * u;\n\t\t    roots[1] = -u;\n\t\t    nS = 2;\n\t\t}\n    }\n    \n    else if (D < 0.0) \/\/ Casus irreducibilis: three real solutions\n    {\n\t\tfloat phi = acos(-q \/ sqrt(-cbP)) \/ 3.0;\n\t\tfloat t = 2.0 * sqrt(-p);\t\n\t\troots[0] = t * cos(phi);\n\t\troots[1] = -t * cos(phi + Pi\/3.0);\n\t\troots[2] = -t * cos(phi - Pi\/3.0);\n\t\tnS = 3;\n    }\n    \n    else \/\/ one real solution \n    {\n\t\tfloat sqrtD = sqrt(D);\n\t\troots[0] = cbrt(sqrtD - q) - cbrt(sqrtD + q);\n\t\tnS = 1;\n    }\n\n    roots -= N[1] \/ 3.0;\n    \n    return nS;\n}\n\nvec2 QuadraticBezier(float t, vec2 p0, vec2 p1, vec2 p2)\n{\n\treturn mix((mix(p0, p1, t)),(mix(p1, p2, t)), t);\n}\n\n\/\/ x is a point\n\/\/ {a, b, c} are the control points\nfloat DistanceQuadraticBezier(vec2 x, vec2 a, vec2 b, vec2 c)\n{\n    float aa = dot(a,a);\tfloat bc = dot(b,c);\tfloat cc = dot(c,c);\n    float ab = dot(a,b);\tfloat bb = dot(b,b);   \tfloat cx = dot(c,x);\n    float ac = dot(a,c);\tfloat bx = dot(b,x);\n    float ax = dot(a,x);\n           \n    \/\/ Cubic coefficients\n    float cu = 4.0*(aa + cc) + 16.0*(bb - ab - bc) + 8.0*ac;\n    \/\/ Quadratic coefficients\n\tfloat qu = 12.0*(bc - ac - aa) - 24.0*bb + 36.0*ab;\n    \/\/ Linear coefficients\n    float li = 4.0*(ac - ax - cx) + 8.0*(bx + bb) + 12.0*aa - 24.0*ab;\n    \/\/ Constant terms\n    float C = 4.0*(ab + ax - aa - bx);\n    vec3 roots;\n    vec4 coeffs = vec4(cu, qu, li, C);\n    \n    int nS = SolveCubic(coeffs, roots);  \n    float t;\n\n   \tfloat Dist1 = distance(x, QuadraticBezier(clamp(roots.x, 0.0, 1.0), a, b, c));\n    float Dist2 = distance(x, QuadraticBezier(clamp(roots.y, 0.0, 1.0), a, b, c));\n    float Dist3 = distance(x, QuadraticBezier(clamp(roots.z, 0.0, 1.0), a, b, c));\n    \n    return min(Dist3, min(Dist1, Dist2));\n}                 \n\nvec2 Mouse()\n{\n    vec2 a = 2.0 *(iMouse.xy \/ iResolution.xy) - 1.0;\n    a.x *= iResolution.x \/ iResolution.y;\n    return a;\n    \n}\n\nvec3 Curves(vec2 uv)\n{\n    float t = iGlobalTime * 2.0;\n    \n    vec2 p1 = vec2(Mouse());\n    vec2 p2 = 0.7*vec2(sin(t), cos(t));    \n    vec2 p3 = vec2(sin(t*0.04), 0.6);\n    vec2 p4 = -p2;\n    vec2 p5 = vec2(-p2.y, p2.x);\n    vec2 p6 = vec2(p2.y, -p2.x);\n    \n    float d1 = smoothstep(0.03, 0.00, DistanceQuadraticBezier(uv, p1, p2, p3));\n    float d2 = smoothstep(0.03, 0.00, DistanceQuadraticBezier(uv, p1, p4, p3));\n    float d3 = smoothstep(0.03, 0.00, DistanceQuadraticBezier(uv, p1, p5, p3));\n    float d4 = smoothstep(0.03, 0.00, DistanceQuadraticBezier(uv, p1, p6, p3));\n       \n    float sP = Point(uv, p1) + Point(uv, p2) + Point(uv, p3) + \n        Point(uv, p4) + Point(uv, p5) + Point(uv, p6); \n    \n    vec3 L1 = d1 * vec3(0.7, 0.9, 0.2);\n    vec3 L2 = d2 * vec3(0.9, 0.4, 0.3);\n    vec3 L3 = d3 * vec3(0.2, 0.4, 0.7);\n\tvec3 L4 = d4 * vec3(0.1, 0.7, 0.2);\n    \n    return sP + L1 + L2 + L3 + L4;\n}   \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy \/ iResolution.xy;\n    vec2 q = 2.0*p - 1.0;\n    q.x *= iResolution.x \/ iResolution.y;   \n    \n    vec3 col = vec3(0.2, 0.2, 0.3);\n    col = max(col, Curves(q));\n       \n    \/\/col *= 1.5;\n    col = col * 1.5 * (1.0 - 0.3*dot(q,q));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"","description":"","type":"image"}]}}