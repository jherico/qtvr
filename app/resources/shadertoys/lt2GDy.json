{"Shader":{"ver":"0.1","info":{"id":"lt2GDy","date":"1432208425","viewed":863,"name":"Funky tentacles","username":"ManuManu","description":"Ok, I must confess it : it was totally out of control<br\/>I made this from testing something from this demo http:\/\/glslsandbox.com\/e#25403.2 and its parent here http:\/\/glslsandbox.com\/e#25400.0<br\/><br\/>original : http:\/\/glslsandbox.com\/e#25442.7","likes":10,"published":3,"flags":0,"tags":["raymarching"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n\n\/\/ Ok, I must confess it : it was totally out of control\n\/\/ I made this from testing something from this demo http:\/\/glslsandbox.com\/e#25403.2 and it's parent here http:\/\/glslsandbox.com\/e#25400.0\n\n\/\/ I didn't expect that, but it's really gorgious ( IMHO )\n\n\n\/\/ Note : I can't save with such a value :(\n\/\/#define MAX_STEP 100\n\/\/#define PRECISION .001\n#define MAX_STEP 200\n#define PRECISION .1\n\n\nvec3 pin(vec3 v)\n{\n\tvec3 q = vec3(0.0);\n\t\n\tq.x = sin(v.x)*0.5+0.5;\n\tq.y = sin(v.y+1.0471975511965977461542144610932)*0.5+0.5;\n\tq.z = sin(v.z+4.1887902047863909846168473723972)*0.5+0.5;\n\t\n\treturn normalize(q);\n}\n\nvec3 spin(vec3 v)\n{\n\tfor(int i = 0; i <3; i++)\n\t{\n\t\tv=pin(v.yzx*6.283185307179586476925286766559);\n\t}\n\treturn v.zxy;\n\n}\nfloat map(vec3 p) {\n\tvec3 val = spin(p);\n\tfloat k = val.x + val.y + val.z;\n\treturn (cos(p.x) + cos(p.y*0.75) + sin(p.z)*0.25)+k*1.2;\n}\n\nvec2 rot(vec2 r, float a) {\n\treturn vec2(\n\t\tcos(a) * r.x - sin(a) * r.y,\n\t\tsin(a) * r.x + cos(a) * r.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv  = ( gl_FragCoord.xy \/ iResolution.xy ) * 2.0 - 1.0;\n\tuv.x *= iResolution.x \/ iResolution.y ;\n\tvec3 dir = normalize(vec3(uv, 1.0));\n\tdir.zy = rot(dir.zy, iGlobalTime * 0.2);\n\tdir.xz = rot(dir.xz, iGlobalTime * 0.1); dir = dir.yzx;\n\n\tvec3 pos = vec3(0, 0, iGlobalTime * 2.0);\n\tfloat t = 0.0;\n\tfor(int i = 0 ; i < MAX_STEP; i++) {\n\t\tfloat temp = map(pos + dir * t) * 0.55;\n\t\tif(temp < PRECISION) break;\n\t\tt += temp;\n\t\tdir.xy=rot(dir.xy,temp*0.05);\n\t\tdir.yz=rot(dir.yz,temp*0.05);\n\t\tdir.zx=rot(dir.zx,temp*0.05);\n\t}\n\tvec3 ip = pos + dir * t;\n\tfragColor = vec4(vec3(max(0.01, map(ip + 0.2)) + t * 0.02) + (dir*spin(ip)), 1.0);\n\n}","name":"","description":"","type":"image"}]}}