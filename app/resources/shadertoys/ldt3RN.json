{"Shader":{"ver":"0.1","info":{"id":"ldt3RN","date":"1448631881","viewed":614,"name":"Bioorganic Wall","username":"Shane","description":"Raymarching a textured XY plane. Basically, just an excuse to try out the new pebbled texture.","likes":43,"published":3,"flags":0,"tags":["raymarching","texture","plane"],"hasliked":0},"renderpass":[{"inputs":[{"id":47,"src":"\/presets\/tex19.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/*\n\n\tBioorganic Wall\n\t---------------\n\n\tRaymarching a textured XY plane. Basically, just an excuse to try out the new pebbled texture.\n\n*\/\n\n\n\/\/ Tri-Planar blending function. Based on an old Nvidia writeup:\n\/\/ GPU Gems 3 - Ryan Geiss: http:\/\/http.developer.nvidia.com\/GPUGems3\/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    n = max(n*n, 0.001);\n    n \/= (n.x + n.y + n.z );  \n    \n\treturn (texture2D(tex, p.yz)*n.x + texture2D(tex, p.zx)*n.y + texture2D(tex, p.xy)*n.z).xyz;\n}\n\n\/\/ Raymarching a textured XY-plane, with a bit of distortion thrown in.\nfloat map(vec3 p){\n\n    \/\/ A bit of cheap, lame distortion for the heaving in and out effect.\n    p.xy += sin(p.xy*7. + cos(p.yx*13. + iGlobalTime))*.01;\n    \n    \/\/ Back plane, placed at vec3(0., 0., 1.), with plane normal vec3(0., 0., -1).\n    \/\/ Adding some height to the plane from the texture. Not much else to it.\n    return 1. - p.z - texture2D(iChannel0, p.xy).x*.1;\n\n    \n    \/\/ Flattened tops.\n    \/\/float t = texture2D(iChannel0, p.xy).x;\n    \/\/return 1. - p.z - smoothstep(0., .7, t)*.06 - t*t*.03;\n    \n}\n\n\n\/\/ Tetrahedral normal, courtesy of IQ.\nvec3 getNormal( in vec3 pos )\n{\n    vec2 e = vec2(0.002, -0.002);\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\n\/\/ Ambient occlusion, for that self shadowed look.\n\/\/ Based on the original by IQ.\nfloat calculateAO(vec3 p, vec3 n){\n\n   const float AO_SAMPLES = 5.0;\n   float r = 1.0, w = 1.0, d0;\n    \n   for (float i=1.0; i<=AO_SAMPLES; i++){\n   \n      d0 = i\/AO_SAMPLES;\n      r += w * (map(p + n * d0) - d0);\n      w *= 0.5;\n   }\n   return clamp(r, 0.0, 1.0);\n}\n\n\/\/ Cool curve function, by Shadertoy user, Nimitz.\n\/\/\n\/\/ It gives you a scalar curvature value for an object's signed distance function, which \n\/\/ is pretty handy for all kinds of things. Here, it's used to darken the crevices.\n\/\/\n\/\/ From an intuitive sense, the function returns a weighted difference between a surface \n\/\/ value and some surrounding values - arranged in a simplex tetrahedral fashion for minimal\n\/\/ calculations, I'm assuming. Almost common sense... almost. :)\n\/\/\n\/\/ Original usage (I think?) - Cheap curvature: https:\/\/www.shadertoy.com\/view\/Xts3WM\n\/\/ Other usage: Xyptonjtroz: https:\/\/www.shadertoy.com\/view\/4ts3z2\nfloat curve(in vec3 p){\n\n    const float eps = 0.0225, amp = 7.5, ampInit = 0.525;\n\n    vec2 e = vec2(-1., 1.)*eps; \/\/0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return clamp((t1 + t2 + t3 + t4 - 4.*map(p))*amp + ampInit, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n    \/\/ Unit directional ray.\n    vec3 rd = normalize(vec3(fragCoord - iResolution.xy*.5, iResolution.y*1.5));\n    \n    \n    \/\/ Rotating the XY-plane back and forth, for a bit of variance.\n    \/\/ Compact 2D rotation matrix, courtesy of Shadertoy user, \"Fabrice Neyret.\"\n    vec2 a = sin(vec2(1.5707963, 0) + sin(iGlobalTime\/4.)*.3);\n    rd.xy = mat2(a, -a.y, a.x)*rd.xy;\n    \n    \/\/ Ray origin. Moving in the X-direction to the right.\n    vec3 ro = vec3(iGlobalTime*.25, 0., 0.);\n    \n    \n    \/\/ Light position, hovering around camera.\n    vec3 lp = ro + vec3(cos(iGlobalTime\/2.)*.5, sin(iGlobalTime\/2.)*.5, 0.);\n    \n    \/\/ Standard raymarching segment. Because of the straight forward setup, very few \n    \/\/ iterations are needed.\n    float d, t=0.;\n    for(int j=0;j<16;j++){\n      \n        d = map(ro + rd*t); \/\/ distance to the function.\n        t += d*.7; \/\/ Total distance from the camera to the surface.\n        \n        \/\/ The plane \"is\" the far plane, so no far plane break is needed.\n        if(d<0.001) break; \n    \n    }\n    \n   \n    \/\/ Surface postion, surface normal and light direction.\n    vec3 sp = ro + rd*t;\n    vec3 sn = getNormal(sp);\n    vec3 ld = lp - sp;\n    \n    \n    \/\/ Retrieving the texel at the surface postion. A tri-planar mapping method is used to\n    \/\/ give a little extra dimension. The time component is responsible for the texture movement.\n    float c = 1. - tex3D(iChannel0, sp*8. - vec3(sp.x, sp.y, iGlobalTime\/4.+sp.x+sp.y), sn).x;\n    \n    \/\/ Taking the original grey texel shade and colorizing it. Most of the folowing lines are\n    \/\/ a mixture of theory and trial and error. There are so many ways to go about it.\n    \/\/\n    vec3 orange = vec3(min(c*1.5, 1.), pow(c, 2.), pow(c, 8.)); \/\/ Cheap, orangey palette.\n    \n    vec3 oC = orange; \/\/ Initializing the object (bumpy wall) color.\n    \n    \/\/ Old trick to shift the colors around a bit. Most of the figures are trial and error.\n    oC = mix(oC, oC.zxy, cos(rd.zxy*6.283 + sin(sp.yzx*6.283))*.25+.75);\n    oC = mix(oC.yxz, oC, (sn)*.5+.5); \/\/ Using the normal to colorize.\n    \n    oC = mix(orange, oC, (sn)*.25+.75);\n    \n    \/\/ Plain, old black and white. In some ways, I prefer it. Be sure to comment out the above, though.\n    \/\/vec3 oC = vec3(pow(c, 1.25)); \n    \n    \n    \/\/ Lighting.\n    \/\/\n    float lDist = max(length(ld), 0.001); \/\/ Light distance.\n    float atten = 1.\/(1. + lDist*.25); \/\/ Light attenuation.\n    \n    ld \/= lDist; \/\/ Normalizing the light direction vector.\n    \n    float diff = max(dot(ld, sn), 0.); \/\/ Diffuse.\n    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 16.); \/\/ Specular.\n    float fre = clamp(dot(sn, rd) + 1., .0, 1.); \/\/ Fake fresnel, for the glow.\n\n    \n    \/\/ Shading.\n    \/\/\n    \/\/ Note, there are no actual shadows. The camera is front on, so the following two \n    \/\/ functions are enough to give a shadowy appearance.\n    float crv = curve(sp); \/\/ Curve value, to darken the crevices.\n    float ao = calculateAO(sp, sn); \/\/ Ambient occlusion, for self shadowing.\n\n    \/\/ Not all that necessary, but adds a bit of green to the crevice color to give a fake,\n    \/\/ slimey appearance.\n    vec3 crvC = vec3(crv, crv*1.3, crv*.7)*.25 + crv*.75;\n    \n    \/\/ Combining the terms above to light up and colorize the texel.\n    vec3 col = (oC*(diff + .75) + vec3(.5, .75, 1.)*spec*2.) + vec3(.3, .7, 1.)*fre*fre*3.;\n    \/\/ Applying the shades.\n    col *= (atten*crvC*ao);\n    \n    \/\/ I might be stating the obvious here, but if you ever want to see what effect each individual\n    \/\/ component has on the overall scene, just put the variable in at the end, by itself.\n    \/\/col = vec3(ao); \/\/ col = vec3(crv); \/\/ etc.\n\n    \/\/ Presenting to the screen.\n\tfragColor = vec4(col, 1.);\n}","name":"","description":"","type":"image"}]}}