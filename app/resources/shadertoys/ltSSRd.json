{"Shader":{"ver":"0.1","info":{"id":"ltSSRd","date":"1445813378","viewed":490,"name":"Sub","username":"ValXp","description":"Just my subwoofer.","likes":5,"published":3,"flags":0,"tags":["raymarching"],"hasliked":0},"renderpass":[{"inputs":[{"id":6,"src":"\/presets\/tex05.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":34,"src":"\/presets\/mzk05.mp3","ctype":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define MAX_ITERATIONS 80.0\n#define MAX_RAY_DISTANCE 30.0\n#define M_PI 3.1415926535897932384626433832795\n\n#define LOW_FREQUENCY 20.0\n#define LOW_LIMIT 0.5\n\n\/\/#define JUST_BEATS\n\nvec3 lightPosition;\nmat4 rotation;\nmat4 coneRotation;\nvec3 diffuseColor = vec3(0.9, 0.02, 0.05);\nvec3 specularColor = vec3(0.1, 0.3, 0.6);\nvec3 ambientColor = vec3(0.01, 0.01, 0.01);\nfloat shininess = 20.0;\nfloat screenGamma = 2.2;\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           -5.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n\n\/\/ polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)\/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nvec2 matMin(vec2 left, vec2 right)\n{\n    return left.x > right.x ? right : left;\n}\n\n\n\/\/ Distance field equation for a sphere.\nfloat sphereDist(vec3 position, float radius)\n{\n    return length(position) - radius;\n}\n\nfloat coneDist( vec3 position, vec2 cone )\n{\n    \/\/ c must be normalized\n    float q = length(position.xy);\n    return dot(cone,vec2(q,position.z));\n}\n\nfloat sdCappedCone( in vec3 position, in vec3 cone )\n{\n    vec2 q = vec2( length(position.xz), position.y );\n    vec2 v = vec2( cone.z*cone.y\/cone.x, -cone.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv\/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\nfloat sdTorus( vec3 position, vec2 torus )\n{\n  vec2 q = vec2(length(position.xz)-torus.x,position.y);\n  return length(q)-torus.y;\n}\n\nfloat udRoundBox( vec3 position, vec3 box, float radius )\n{\n  return length(max(abs(position)-box,0.0))-radius;\n}\n\nfloat sdCappedCylinder( vec3 position, vec2 cylinder )\n{\n  vec2 d = abs(vec2(length(position.xz),position.y)) - cylinder;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\/\/ Distance field.\n\/\/ Takes a 3D position and gives the distance value in the field.\nvec2 map(vec3 position)\n{\n    position.z -= 10.0;\n    position = (rotation * vec4(position, 0.0)).xyz;\n\n    vec3 boxPosition = position;\n    boxPosition.z -= 1.3;\n    float box = udRoundBox(boxPosition, vec3(4.0, 5.0, 3.0), 0.5);\n    \n    vec3 holesPosition = (coneRotation * vec4(position, 0.0)).xyz;\n    holesPosition.z -= 3.5;\n    holesPosition.x += 2.5;\n    float hole1 = sdCappedCylinder(holesPosition, vec2(1.0, 4.0));\n    \n    float holes;\n    vec3 torusPosition = holesPosition;\n    torusPosition.y += 2.15;\n    float hole1Entrance = sdTorus(torusPosition, vec2(1.0, 0.1));\n    float hole1Tube = sdCappedCylinder(holesPosition, vec2(0.95, 2.2));\n    float hole1TubeHole = sdCappedCylinder(holesPosition, vec2(0.85, 3));\n    \n    holes = smin(hole1Entrance, max(hole1Tube, -hole1TubeHole), 0.2);\n    \n    holesPosition.x -= 5.0;\n    float hole2 = sdCappedCylinder(holesPosition, vec2(1.0, 4.0));\n    box = max(max(box, -hole1), -hole2);\n    \n    torusPosition = holesPosition;\n    torusPosition.y += 2.15;\n    float hole2Entrance = sdTorus(torusPosition, vec2(1.0, 0.1));\n    float hole2Tube = sdCappedCylinder(holesPosition, vec2(0.95, 2.2));\n    float hole2TubeHole = sdCappedCylinder(holesPosition, vec2(0.85, 3));\n    \n    holes = min(holes, smin(hole2Entrance, max(hole2Tube, -hole2TubeHole), 0.2));\n    \n    \n    boxPosition.z += 0.2;\n    boxPosition.y -= 1.0;\n    boxPosition = (coneRotation * vec4(boxPosition, 0.0)).xyz;\n    float coneNeg = sdCappedCone(boxPosition, vec3(0.5, 0.5, 4.0));\n    box = max(box, -coneNeg);\n    \n    position.y -= 1.0;\n    float value = texture2D( iChannel0, vec2( 0.001, 0.25 ) ).x \/ 2.0;\n#ifdef JUST_BEATS\n    position.z += value;\n#else\n    float rawWave = sin(LOW_FREQUENCY * 2.0 * M_PI * iChannelTime[0]);\n\tfloat wave = rawWave * LOW_LIMIT * 0.5 + 0.5;\n\tposition.z += clamp(wave * value, 0.0, 1.0);\n#endif\n    \n    float centerSphere = sphereDist(position, 1.3);\n    position.z -= 1.0;\n    position = (coneRotation * vec4(position, 0.0)).xyz;\n    \n    float cone = sdCappedCone(position, vec3(0.5, 0.5, 3.0));\n    position.y += 0.1;\n    float coneNegative = sdCappedCone(position, vec3(0.5, 0.5, 3.0));\n    cone = max(cone, -coneNegative);\n    \n    position.y += 2.8;\n\tfloat torus = sdTorus(position, vec2(3.0, 0.3));\n\tcone = min(cone, torus);\n    \n    \n    return matMin(vec2(min(smin(centerSphere, cone, 0.2), holes), 1.0), vec2(box, 2.0));\n}\n\nfloat mapf(vec3 position)\n{\n    return map(position).x;\n}\n\n\/\/ Ray marching.\n\/\/ Given a start point and a direction. Sample the distance field until collision with an object.\n\/\/ Return this 3D collision point.\nvec4 rayMarch(vec3 start, vec3 direction)\n{\n    float rayPrecision = 0.008;\n    float rayLength = 0.0;\n    vec3 intersection = vec3(0.0);\n    float material = 0.0;\n    for (float i = 0.0; i < MAX_ITERATIONS; i++)\n    {\n        vec3 intersection = start + (direction * rayLength);\n        vec2 ret = map(intersection);\n        \/\/ ret.x -> Distance. ret.y -> material\n        if (abs(ret.x) < rayPrecision)\n            return vec4(intersection, ret.y);\n        if (ret.x > MAX_RAY_DISTANCE)\n            return vec4(0.0);\n        rayLength += ret.x * .85;\n        material = ret.y;\n    }\n    return vec4(intersection, material);\n}\n\n\n\/\/ Calculate normal of a point.\n\/\/ Samples the distance field to find the direction at which the distance increases in 3D space.\nvec3 calcNormal(vec3 point)\n{\n    vec3 delta = vec3(0.001, 0.001, 0.001);\n    float x0 = mapf(point);\n    float xn = mapf(vec3(point.x + delta.x, point.yz)) - x0;\/\/mapf(vec3(point.x - delta.x, point.yz));\n    float yn = mapf(vec3(point.x, point.y + delta.y, point.z)) - x0;\/\/mapf(vec3(point.x, point.y - delta.y, point.z));   \n    float zn = mapf(vec3(point.xy, point.z + delta.z)) - x0;\/\/mapf(vec3(point.xy, point.z - delta.z));\n    return normalize(vec3(xn, yn, zn));\n}\n\n\/\/ Simple shading function\nvec4 shade(vec4 intersection)\n{\n    vec3 point = intersection.xyz;\n    vec3 normal = calcNormal(point);\n    vec3 lightDir = normalize(lightPosition - point);\n    \n    float lambertian = max(dot(lightDir, normal), 0.0);\n    float specular = 0.0;\n    \n    if (lambertian > 0.0)\n    {\n        vec3 viewDir = normalize(-point);\n        \n        vec3 halfDir = normalize(lightDir + viewDir);\n        float specAngle = max(dot(halfDir, normal), 0.0);\n        specular = pow(specAngle, shininess);\n    }\n    \n    vec3 diffuse = vec3(0.0);\n    if (intersection.a == 2.0) \/\/ box\n    {\n        diffuse = diffuseColor;\n        diffuse = texture2D(iChannel1, vec2(intersection.x \/ 4.0, intersection.y \/ 4.0)).xyz * 0.6;\n    } else if (intersection.a == 1.0) \/\/ Woofer\n    {\n        diffuse = vec3(0.02, 0.02, 0.02);\n        specular \/= 10.0;\n    }\n    \n    vec3 colorLinear = ambientColor;\n    colorLinear += specular * specularColor;\n    colorLinear += lambertian * diffuse;\n      \n    return vec4(colorLinear, 1.0);\n}\n                     \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    lightPosition = vec3(5.0 * sin(iGlobalTime\/2.0), 1.0 * sin(iGlobalTime*4.0), 5.0 * cos(iGlobalTime\/2.0));\n    rotation = rotationMatrix(vec3(0.0, 1.0, 0.0), cos(5.0 + (iMouse.x \/ iResolution.x) * 6.3));\n    coneRotation = rotationMatrix(vec3(1.0, 0.0, 0.0), M_PI \/ 2.0);\n    \n    float screenZ = 3.0;\n    vec2 screenUV = fragCoord.xy \/ iResolution.xy;\n    screenUV.x *= iResolution.x\/iResolution.y;\n    \n    vec3 eye = vec3(1.0, 0.5, 2.6);\n\tvec3 pixelLoc = vec3(screenUV, screenZ);\n    \n    vec3 ray = normalize(pixelLoc - eye);\n    vec4 intersection = rayMarch(pixelLoc, ray);\n    \n    fragColor = vec4(ambientColor, 1.0);\n    if (intersection.xyz != vec3(0.0)) {\n    \t\/\/float depth = (intersection.z-3.0)\/5.0;\n    \t\/\/fragColor = vec4(depth, depth, 0.0, 1.0);\n        \/\/fragColor = vec4(calcNormal(intersection.xyz), 1.0);\n        \n        fragColor = shade(intersection);\n    }\n    fragColor = vec4(pow(fragColor.xyz, vec3(1.0 \/ screenGamma)), 1.0);\n}\n","name":"","description":"","type":"image"}]}}