{"Shader":{"ver":"0.1","info":{"id":"ll2SWW","date":"1443821542","viewed":830,"name":"Pharmacie de la Gare","username":"Klems","description":"The LED size doesn't change with the resolution so you get more details on fullscreen. This is the last time I'm making a shader with a clock, it's kinda scary watching the time passes as you're coding it.","likes":15,"published":3,"flags":0,"tags":["2d","retro","led","dithering"],"hasliked":0},"renderpass":[{"inputs":[{"id":5,"src":"\/presets\/tex04.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":28,"src":"\/presets\/tex15.png","ctype":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\n#define EFFECT_LENGTH 5.0\n#define PI 3.1415926535\n#define LED_SIZE 2.0\n#define CELL_SIZE 3.0\n#define SIZE (LED_SIZE*CELL_SIZE)\n\nmat2 rot( in float a ) {\n    float c = cos(a);\n    float s = sin(a);\n\treturn mat2(c,s,-s,c);\t\n}\n\nfloat crossDist(vec2 p) {\n    vec2 absp = abs(p);\n    float mi = min(absp.x, absp.y);\n    float ma = absp.x+absp.y-mi;\n    float crossv = max(0.4 - mi, 0.0);\n    float square = max(0.9 - ma, 0.0);\n    return min(square, crossv);\n}\n\n\/\/ some screen effects\n\n\/\/ uv is between -1 and 1 on y, aspect ratio is preserved on x\n\/\/ frac is between 0 and 1, 0 when the effect starts, 0 when it ends\n\/\/ feel free to add yor own in the comments!\n\nfloat effectStar( in vec2 uv ) {\n    float theta = atan(uv.y+1.2, uv.x);\n    float temp = sin(theta*12.0+iGlobalTime*7.45)*0.5+0.5;\n    return temp;\n}\n\nfloat effectSpiral( in vec2 uv ) {\n    vec2 polar = vec2(atan(uv.y, uv.x)\/PI*5.0, log(length(uv)+1.0)*4.0);\n    polar.x -= iGlobalTime*0.6;\n    polar.y += polar.x*0.5 - iGlobalTime * 1.2;\n    vec2 f = fract(polar);\n    return max(f.x, f.y);\n}\n\nfloat effectWave( in vec2 uv, in float frac ) {\n    float base = sin(uv.y-frac*2.0*PI+1.5*PI)*0.5+0.5;\n    base += sin(uv.x*10.0 - uv.y*4.0-iGlobalTime*1.2)*0.025;\n    return base;\n}\n\nfloat effectBorder( in vec2 p  ) {\n    float crossd = crossDist(p);\n    return sin(crossd*60.0+iGlobalTime*10.0)*0.5+0.5;\n}\n\nfloat effectPacman( in vec2 uv, in float frac ) {\n    float value = 0.0;\n    uv *= 4.0;\n    vec2 pacmanCenter = vec2(4.7-frac*12.0, 0.0);\n    vec2 delta = uv-pacmanCenter;\n    float theta = abs(atan(delta.y, -delta.x));\n    float mouth = step(max(0.0, sin(iGlobalTime*10.0)*0.4+0.35), theta);\n    value += max(0.0, 20.0-distance(uv, pacmanCenter)*20.0)*mouth;\n    if (uv.x > pacmanCenter.x+0.5) return value;\n    vec2 center = vec2(floor(uv.x)+0.5, 0.0);\n    value += max(0.0, 5.0-distance(uv, center)*20.0);\n    return value;\n}\n\n\/\/ eyeball effect\n\nfloat irisColor( in vec3 norm, in float frac, float theta ) {\n    float color = 1.0;\n    if (norm.z > 0.99+smoothstep(0.0, 0.7, frac)*0.009) {\n        color = 0.0;\n    } else if (norm.z > 0.9) {\n        color = 0.7*(1.0-smoothstep(0.0, 0.1, distance(0.98, norm.z)))*(sin(theta*6.0)*0.3+0.7);\n    }\n    return color;\n}\n\nfloat effectIris( in vec2 uv, in float frac ) {\n    uv *= 1.5;\n    float r = length(uv);\n\tif (r > 1.0) {\n\t\treturn 0.0;\n\t} else {\n\t\tvec3 l = normalize(vec3(1, 1, 2));\n\t\tvec3 p = vec3(uv, sqrt(1.0 - r*r));\n        float angle = cos(iGlobalTime*0.02914)*15.115;\n        mat2 rotxy = rot(angle);\n        mat2 rotxz = rot(sin(iGlobalTime*0.447)*0.117);\n \t\tl.xy *= rotxy;\n        p.xy *= rotxy;\n        l.xz *= rotxz;\n        p.xz *= rotxz;\n        float d = dot(l, p);\n        float theta = atan(p.x, p.y)-angle;\n\t\treturn (d*0.5+d*d*0.3+0.3)*irisColor(p, frac, theta);\n\t}\n}\n\n\/\/ clock\n\n\/\/ Thanks P_Malin, see https:\/\/www.shadertoy.com\/view\/4sf3RN\n\nconst float kCharBlank = 12.0;\nconst float kCharMinus = 11.0;\nconst float kCharDecimalPoint = 10.0;\nfloat InRect(const in vec2 vUV, const in vec4 vRect) {\n\tvec2 vTestMin = step(vRect.xy, vUV.xy);\n\tvec2 vTestMax = step(vUV.xy, vRect.zw);\t\n\tvec2 vTest = vTestMin * vTestMax;\n\treturn vTest.x * vTest.y;\n}\nfloat SampleDigit(const in float fDigit, const in vec2 vUV) {\n\tconst float x0 = 0.0 \/ 4.0;\n\tconst float x1 = 1.0 \/ 4.0;\n\tconst float x2 = 2.0 \/ 4.0;\n\tconst float x3 = 3.0 \/ 4.0;\n\tconst float x4 = 4.0 \/ 4.0;\n\tconst float y0 = 0.0 \/ 5.0;\n\tconst float y1 = 1.0 \/ 5.0;\n\tconst float y2 = 2.0 \/ 5.0;\n\tconst float y3 = 3.0 \/ 5.0;\n\tconst float y4 = 4.0 \/ 5.0;\n\tconst float y5 = 5.0 \/ 5.0;\n\tvec4 vRect0 = vec4(0.0);\n\tvec4 vRect1 = vec4(0.0);\n\tvec4 vRect2 = vec4(0.0);\n\tif(fDigit < 0.5) {\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y1, x2, y4);\n\t} else if(fDigit < 1.5) {\n\t\tvRect0 = vec4(x1, y0, x2, y5); vRect1 = vec4(x0, y0, x0, y0);\n\t} else if(fDigit < 2.5) {\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x0, y3, x2, y4); vRect2 = vec4(x1, y1, x3, y2);\n\t} else if(fDigit < 3.5) {\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x0, y3, x2, y4); vRect2 = vec4(x0, y1, x2, y2);\n\t} else if(fDigit < 4.5) {\n\t\tvRect0 = vec4(x0, y1, x2, y5); vRect1 = vec4(x1, y2, x2, y5); vRect2 = vec4(x2, y0, x3, y3);\n\t} else if(fDigit < 5.5) {\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y3, x3, y4); vRect2 = vec4(x0, y1, x2, y2);\n\t} else if(fDigit < 6.5) {\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y3, x3, y4); vRect2 = vec4(x1, y1, x2, y2);\n\t} else if(fDigit < 7.5) {\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x0, y0, x2, y4);\n\t} else if(fDigit < 8.5) {\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y1, x2, y2); vRect2 = vec4(x1, y3, x2, y4);\n\t} else if(fDigit < 9.5) {\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y3, x2, y4); vRect2 = vec4(x0, y1, x2, y2);\n\t} else if(fDigit < 10.5) {\n\t\tvRect0 = vec4(x1, y0, x2, y1);\n\t} else if(fDigit < 11.5) {\n\t\tvRect0 = vec4(x0, y2, x3, y3);\n\t}\t\n\t\n\tfloat fResult = InRect(vUV, vRect0) + InRect(vUV, vRect1) + InRect(vUV, vRect2);\n\treturn mod(fResult, 2.0);\n}\nfloat effectClock( in vec2 p ) {\n    float value = 0.0;\n    float temp = length(p);\n    value += smoothstep(0.75, 0.80, temp) * (1.0-smoothstep(0.80, 0.85, temp));\n    vec2 push = p;\n    p *= rot(-floor(mod(iDate.w, 60.0)) \/ 60.0 * 2.0 * PI);\n   \tfloat sbar = 0.0;\n    if (p.x < 0.02 && p.x > -0.02 && p.y > -0.05 && p.y < 0.7) sbar = 1.0;\n    value += sbar;\n    p = push;\n    p.y += 0.2;\n    p.x -= 0.03;\n    float minutes = mod(iDate.w \/ 60.0, 60.0);\n    float hour = mod(iDate.w \/ (60.0*60.0), 24.0);\n    if (hour > 13.0) hour -= 12.0;\n    p.y *= 0.7;\n    p.x += 0.7;\n    float print = 0.0;\n    if ( hour >= 10.0 )\n    \tprint += SampleDigit(floor(hour\/10.0), p*3.3);\n    p.x -= 0.3;\n    print += SampleDigit(floor(mod(hour, 10.0)), p*3.3);\n    push = p;\n    p.y = -p.y + 0.22;\n    p.x = -p.x + 0.44;\n    print += SampleDigit(4.0, p*4.5);\n    value = print * 0.5 + value * (0.5+0.5*(1.0-print));\n    p = push;\n    p.x -= 0.5;\n    print = SampleDigit(floor(minutes\/10.0), p*3.3);\n    p.x -= 0.3;\n    print += SampleDigit(floor(mod(minutes, 10.0)), p*3.3);\n    value = print * 0.5 + value * (0.5+0.5-0.5*print);\n    return value;\n}\n\n\/\/ rotating capsule\n\nfloat sdCapsule( in vec3 p, in vec3 a, in vec3 b ) {\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - 1.0;\n}\nfloat de( in vec3 p ) {\n    const vec3 a = vec3(1.5,0.0,0.0);\n    const vec3 b = vec3(-1.5,0.0,0.0);\n    return sdCapsule(p, a, b);\n}\nvec3 normal( in vec3 p ) {\n\tvec3 e = vec3(0.0, 0.001, 0.0);\n\treturn normalize(vec3(\n\t\tde(p+e.yxx)-de(p-e.yxx),\n\t\tde(p+e.xyx)-de(p-e.xyx),\n\t\tde(p+e.xxy)-de(p-e.xxy)));\t\n}\nfloat colorCap( in vec3 p ) {\n    if (p.x > 0.2) return 0.435;\n    else if (p.x < -0.2) return 0.65;\n    else return 0.9;\n}\nfloat effectCapsule( in vec2 uv ) {\n    vec3 dir = normalize(vec3(uv * 0.7, 1.0));\n    vec3 forward = vec3(0, 0, 1);\n    mat2 rotxy = rot(iGlobalTime*0.235+0.5);\n    mat2 rotzx = rot(iGlobalTime*0.412-0.7);\n    dir.xy *= rotxy;\n    forward.xy *= rotxy;\n    dir.zx *= rotzx;\n    forward.zx *= rotzx;\n    vec3 light = normalize(-forward);\n    vec3 from = -forward*5.0;\n   \tfloat totdist = 0.0;\n    float mindist = 99999.9;\n\tbool set = false;\n    float color = 0.25;\n\tfor (int steps = 0 ; steps < 30 ; steps++) {\n\t\tvec3 p = from + totdist * dir;\n\t\tfloat dist = de(p);\n        mindist = min(mindist, dist);\n\t\ttotdist += dist;\n\t\tif (dist < 0.04) {\n            color = (dot(normal(p), light)*0.5+0.5)*colorCap(p);\n            set = true;\n            break;\n\t\t}\n\t}\n    if ( !set && mindist < 0.25 ) return 0.0;\n   \treturn color;\n}\n\n\n\/\/ now put all of this together\n\n\/\/ choose the screen to show\nfloat getScreenFX( int fx, vec2 uv, float frac ) {\n    fx = int(fract(float(fx)*1.61456)*9.0);\n    int temp = fx \/ 8;\n    fx -= temp * 8;\n    float value = 0.0;\n         if (fx == 0) value = effectStar( uv );\n    else if (fx == 1) value = effectSpiral( uv );\n    else if (fx == 2) value = effectBorder( uv );\n    else if (fx == 3) value = effectClock( uv );\n    else if (fx == 4) value = effectWave( uv, frac );\n    else if (fx == 5) value = effectCapsule( uv );\n    else if (fx == 6) value = effectIris( uv, frac );\n    else              value = effectPacman( uv, frac );\n   \treturn value;\n}\n\n\/\/ blend at transitions\nfloat getScreenOutput( in vec2 uv ) {\n    int fx = int(iGlobalTime\/EFFECT_LENGTH);\n    float frac = mod(iGlobalTime, EFFECT_LENGTH) \/ EFFECT_LENGTH;\n    float valueA = getScreenFX(fx, uv, 0.0);\n    float valueB = getScreenFX(fx-1, uv, frac);\n    return mix(valueB, valueA, smoothstep(0.7, 1.0, frac)); \n}\n\n\/\/ take the screen output and get the led brightness\nfloat toLED( vec2 frag ) {\n    \/\/ 1 value for each cells\n    vec2 cell = floor((frag+2.0)\/SIZE)*SIZE*2.0-iResolution.xy;\n    cell \/= iResolution.y;\n    \/\/ do dithering\n    float brightness = getScreenOutput(cell);\n    if (brightness < 1.0\/5.0) return 0.0;\n    vec2 pixel = floor(mod(frag.xy\/LED_SIZE, CELL_SIZE));\n    int x = int(pixel.x);\n    int y = int(pixel.y);\n    \/\/ keep a black border\n    if (x == 0 || y == 0) return 0.0;\n    if (brightness > 4.0\/5.0) return 1.0;\n    bool result = false;\n    \/\/ do the dithering by hand here\n    if ((x == 1 && y == 2 && brightness > 3.0\/5.0) ||\n    \t(x == 1 && y == 1 && brightness > 2.0\/5.0) ||\n    \t(x == 2 && y == 2 && brightness > 1.0\/5.0)) return 1.0;\n    return 0.0;\n}\n\n\/\/ colored background\nfloat getBackgroundColor( in vec2 uv ) {\n    vec2 viguv = uv*2.0-1.0;\n    float vignette = max(0.0, dot(viguv, viguv)*0.2-0.1)*1.7;\n    uv.x *= iResolution.x\/iResolution.y*0.72;\n    uv.y = -uv.y;\n    uv *= 0.6;\n    uv *= 1.0 + sin(iGlobalTime*0.0345)*0.1+0.1;\n    uv.x += sin(iGlobalTime*0.0542)*0.1+0.1;\n    uv.y -= sin(iGlobalTime*0.0151)*0.15+0.15;\n    vec2 color = texture2D(iChannel0, uv).rg;\n    return (color.r+color.g+color.g)\/3.0-vignette;\n}\n\n\/\/ dithered background\nvec3 getBackground( in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    float brightness = getBackgroundColor(uv);\n    vec2 pixel = mod(floor(fragCoord\/LED_SIZE), 8.0)\/8.0;\n    float value = 0.0;\n    if (brightness > texture2D(iChannel1, pixel).r) value = 1.0;\n   \treturn vec3(0.05, value*0.1+0.05, 0.05);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy \/ iResolution.xy*2.0-1.0;\n    uv.x *= iResolution.x\/iResolution.y;\n    uv *= 1.0;\n    \n    fragColor.a = 1.0;\n    \n    float crossd = crossDist(uv);\n    if (crossd > 0.0) {\n        float value = 0.0;\n        if (crossd < 0.02) value = 1.0;\n        else if (crossd < 0.05) value = 0.0;\n        else value = toLED(fragCoord);\n        fragColor.rgb = vec3(0.05, value+0.05, 0.05);\n    } else {\n        fragColor.rgb = getBackground(fragCoord);\n        \n    }\n    \n}","name":"","description":"","type":"image"}]}}