{"Shader":{"ver":"0.1","info":{"id":"Xd33Df","date":"1452407216","viewed":198,"name":"Erosion Compute","username":"Alway_PanicButton","description":"A simple erosion process. Over time, water is added and removed. Arrow keys to move. Still some bugs and rendered with the equivalent of a room full of monkeys with typewriters. Comment out the first line in Image shader for more monkeys.","likes":6,"published":3,"flags":48,"tags":["erosion"],"hasliked":0},"renderpass":[{"inputs":[{"id":15,"src":"\/presets\/tex10.png","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":260,"src":"\/presets\/previz\/buffer03.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define FASTER_RENDER\n\nvoid rot2( inout vec2 r, float theta )\n{\n    float co = cos(theta);\n    float si = sin(theta);\n    r = vec2( r.x * co + r.y * si,\n             -r.x * si + r.y * co );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec4 c = vec4( 0., 0., 0., 0. );\n    \n    vec3 p = vec3( 0.5, -0.20, 3.2 );\n    p.xy = texture2D( iChannel1, vec2( 258.5, 0.5 ) \/ iResolution.xy ).xy;\n    vec3 d = normalize( vec3( uv.x - .5, 1.0, uv.y - 1.5 ) );\n    \n    if( iMouse.w > 0.)\n    {\n    rot2( d.yz, iMouse.y \/ iResolution.y * 1.-.5 );\n    rot2( d.yx, iMouse.x \/ iResolution.x * 1.-.5 );\n    }\n    \n    vec3 w = vec3(0.);\n    if( iGlobalTime > 0.25 )\n    {\n#ifndef FASTER_RENDER\n    for( int i = 0; i < 512; i++ )\n#else\n    for( int i = 0; i < 128; i++ )\n#endif\n    {\n        vec2 p256 = p.xy * 256.;\n        if( p256.x < 0. || p256.y < 0. || p256.x > 255. || p256.y > 249. )\n            p256.xy = vec2(5.);\n        vec4 t = texture2D( iChannel1, p256 \/ iResolution.xy );\n        if( w.x == 0. && t.x + t.y + t.z > p.z*2. && t.z > 0.001 )\n        {\n            c.b += 10. * t.z;\n            c.rgb += t.w \/ (t.z + 0.1);  \/\/ light-blue-white for sediment-rich water\n            float sum = t.x + t.y + t.z;\n        \tvec4 tx = texture2D( iChannel1, p256 \/ iResolution.xy + vec2( 1. \/ iResolution.x, 0. ) );\n        \tvec4 ty = texture2D( iChannel1, p256 \/ iResolution.xy + vec2( 0., 1. \/ iResolution.y ) );\n            vec3 norm = normalize( vec3(tx.x + tx.y + tx.z - sum, ty.x + ty.y + ty.z - sum, 1. \/ iResolution.x) );\n            c += abs( dot( norm, vec3( 0., 0., 1. ) ) ) * .2 * (t.z < .01 ? t.z*100. : 1.);\n            c.rgb += min(1., t.z * 100.) * abs(length(texture2D( iChannel0, p256 \/ iResolution.xy ).xy)*4.) * 50.;\n            \/\/vec2 Vel = texture2D( iChannel0, (p256 ) \/ iResolution.xy ).xy;\n            \/\/float d = texture2D( iChannel1, (p256 ) \/ iResolution.xy ).y;\n            \/\/c.rgb *= 0.5+texture2D( iChannel2, mod((Vel\/max(d,0.001) * iGlobalTime*0.1 + 0.01*mod(p256, 1.0)), 0.01)).rgb;\n            \n            w = p;\n        }\n        if( t.x + t.y > p.z*2.0 )\n        {\n            float sum = t.x + t.y;\n        \tvec4 tx = texture2D( iChannel1, p256 \/ iResolution.xy + vec2( 1. \/ iResolution.x, 0. ) );\n        \tvec4 ty = texture2D( iChannel1, p256 \/ iResolution.xy + vec2( 0., 1. \/ iResolution.y ) );\n            vec3 norm = normalize( vec3(tx.x + tx.y - sum, ty.x + ty.y + - sum, 20. \/ iResolution.x) );\n            float l = abs( dot( norm, vec3( 0., 0., 1. ) ) );\n            if( t.y > 0.01 )\n            {\n                if( w.x == 0. )\n                \tc.rg += vec2(0.5,0.4) * l * (0.95+0.1*texture2D( iChannel2, p256*0.1 ).r);\n                else\n                    c.rg += vec2(0.5,0.4) \/ (max(length( w - p ) * 35., 1.0)) * l;\n            }\n            else\n            {\n                if( w.x == 0. )\n                \tc.rgb += 0.4 * l * (0.95+0.1*texture2D( iChannel2, p256*0.1 ).r);\n                else\n                    c.rgb += 0.4 \/ (max(length( w - p ) * 35., 1.0 )) * l;\n            }\n            w = p;\n            break;\n        }\n        \/\/ a heuristic to encourage better use of render time.\n        float convergeFaster = ( p.z*2.0 - (t.x + t.y + t.w) > 0.1 ) ? 2. : 0.5;\n#ifndef FASTER_RENDER\n        p += d * 0.0025 * convergeFaster;\n#else\n        p += d * 0.0075 * convergeFaster;\n#endif\n    }\n    }\n    if( w.x == 0. )\n    {\n    \tif( mod(iGlobalTime, 30.) < 5. )\n        {\n            c = vec4( 0.3, 0.3, 0.3, 1.0 );\n        }\n    \telse if( iGlobalTime > 20. && mod(iGlobalTime, 30.) > 15. && mod(iGlobalTime, 30.) < 22.)\n        {\n            c = vec4( 0.6, 0.6, 0.8, 1. );\n        }\n        else\n        {\n            c = vec4( 0.4, 0.4, 0.9, 1. );\n        }\n    }\n    \n\tfragColor = c;\n}","name":"","description":"","type":"image"},{"inputs":[{"id":8,"src":"\/presets\/tex07.jpg","ctype":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":47,"src":"\/presets\/tex19.png","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":259,"src":"\/presets\/previz\/buffer02.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":260,"src":"\/presets\/previz\/buffer03.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ erode & deposit\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tiles = 256.;\n    if( (fragCoord.x > tiles || fragCoord.y > tiles) && !( fragCoord.x > 257.9 && fragCoord.x < 258.9 && fragCoord.y < 0.9 ))\n        discard;\n    \n    vec2 i = fragCoord \/ iResolution.xy;\n    \n    \/\/ h0, h1, wh, d\n    vec4 t = texture2D( iChannel0, i );\n    \n    if( fragCoord.x > 257.9 && fragCoord.x < 258.9 && fragCoord.y < 0.9 )\n    {\n        if( t.x <= .0 )\n        {\n            fragColor.rgb = vec3(0.5, -0.40, 1.3);\n            return;\n        }\n        fragColor = texture2D( iChannel0, fragCoord.xy\/iResolution.xy ).rgba;\n        return;\n    }\n        \n    \/\/ Initialize terrain.\n    if( t.x <= 0. )\n    {\n        \/\/ Previously had problems with the images asynchronously loading in after initializing ran.\n        \/\/ This ensures both have been loaded in before we use them to initialize so we don't get a blank map.\n    \tfloat TestForLoadComplete = texture2D( iChannel2, i ).x * texture2D( iChannel3, i ).x;\n        if( TestForLoadComplete != 0. )\n        {\n        \tfragColor = vec4(max(0., texture2D( iChannel2, i ).x*0.5 + (0.8*i.y)), texture2D( iChannel3, i ).x*.5, 0.01, 0.);\n        \tfragColor.r += 5.;\n        \tfragColor.g = max(fragColor.g - 0.0, 0. );\n        }\n        else\n            fragColor = vec4(0.,0.,0.,0.);\n        return;\n    }\n    \n    if( fragCoord.y - 2. < 0. || fragCoord.y > 250. )\n    {\n        fragColor = vec4( 0., 0., 0., 0. );\n        return;\n    }\n        \n        \n    \/\/ vx, vy\n    vec2 v = texture2D( iChannel1, i ).xy;\n    v.x += texture2D( iChannel1, i + vec2( -1. \/ iResolution.x, 0. ) ).x;\n    v.y += texture2D( iChannel1, i + vec2( 0., -1. \/ iResolution.y ) ).y;\n    float s = (abs(v.x) + abs(v.y));\n    s = s - t.w * 1.5;\n    \/\/deposit\n    {\n        float d = t.w * .01;\n        t.y += d;\n        t.z -= d;\n        t.w -= d;\n    }\n    if( t.y > 0.00001 )\t\/\/ erode l1\n    {\n        s = min( t.y, s * 0.002 );\n        t.y -= s;\n        t.z += s;\n        t.w += s;\n    }\n    else\t\/\/ erode l2\n    {\n        s = min( t.x, s * 0.0002 );\n        t.x -= s;\n        t.z += s+t.y;\n        t.w += s+t.y;\n        t.y = 0.;\n    }\n    \n    \n    if( i.y - 3. \/ iResolution.y < 0. )\n    {\n        t.zw = vec2(0.);\n    }\n    \n    fragColor = t;\n}","name":"","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":259,"src":"\/presets\/previz\/buffer02.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ update flow volumes\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tiles = 256.;\n    if( fragCoord.x > tiles || fragCoord.y > tiles )\n        discard;\n        \n    vec2 i = fragCoord \/ iResolution.xy;\n        \n    \/\/ h0, h1, wh, d\n    \/\/ vx, vy\n    \n    \n    \/\/ Initialize flow.\n    vec4 t = texture2D( iChannel0, i );\n    if( t.x <= 0. || fragCoord.x > tiles - 1. || fragCoord.y > tiles - 1. )\n    {\n    \tfragColor = vec4(0., 0., 0., 0.);\n        return;\n    }\n    vec2 v = texture2D( iChannel1, i ).zw;\n        \n    float sum = t.x + t.y + t.z;\n    \n    for( int id = 0; id < 2; id++ )\n    {\n        vec4 o;\n        if( id != 1 )\n            o = texture2D( iChannel0, i + vec2( 1. \/ iResolution.x, 0. ) );\n        else\n            o = texture2D( iChannel0, i + vec2( 0., 1. \/ iResolution.y ) );\n        float diff = sum - (o.x + o.y + o.z);\n        if( diff > 0. )\n            diff = min( diff, t.z );\n        else\n            diff = max( diff, -o.z );\n        if( id != 1 )\n        {\n            v.x += diff * 0.0025;\n        \tif( v.x > 0. )\n        \t    v.x = min( v.x, t.z*.24 );\n        \telse\n        \t    v.x = max( v.x, -o.z*.24 );\n        }\n        else\n        {\n            v.y += diff * 0.0025;\n        \tif( v.y > 0. )\n        \t    v.y = min( v.y, t.z*.24 );\n        \telse\n        \t    v.y = max( v.y, -o.z*.24 );\n        }\n    }\n    fragColor = vec4(v.xy*.998,0.,1.0);\n}","name":"","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ transport fluid and disolved material\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tiles = 256.;\n    if( fragCoord.x > tiles || fragCoord.y > tiles )\n        discard;\n        \n    vec2 i = fragCoord \/ iResolution.xy;\n    \n    \n    \/\/ h0, h1, wh, d\n    \/\/ vx, vy\n    vec4 t = texture2D( iChannel0, i );\n    vec2 to = t.zw;\n    vec2 vo = texture2D( iChannel1, i ).xy;\n    vec2 v = vo;\n    \n    vec2 inflow = vec2( 0. );\n    \n    if( v.x > 0. )\n    {\n        float p = v.x \/ max(t.z, 0.00001);\n        inflow -= abs(p * t.zw);\n    }\n    else\n    {\n        vec4 ot = texture2D( iChannel0, i + vec2( 1. \/ iResolution.x, 0. ) );\n        float p = v.x \/ max(ot.z, 0.00001);\n        inflow += abs(p * ot.zw);\n    }\n    if( v.y > 0. )\n    {\n        float p = v.y \/ max(t.z, 0.00001);\n        inflow -= abs(p * t.zw);\n    }\n    else\n    {\n        vec4 ot = texture2D( iChannel0, i + vec2( 0., 1. \/ iResolution.y ) );\n        float p = v.y \/ max(ot.z, 0.00001);\n        inflow += abs(p * ot.zw);\n    }\n    \n    if( i.x - 1. \/ iResolution.x >= 0. )\n    {\n    v = texture2D( iChannel1, i - vec2( 1. \/ iResolution.x, 0. ) ).xy;\n    if( v.x < 0. )\n    {\n        float p = v.x \/ max(t.z, 0.00001);\n        inflow -= abs(p * t.zw);\n    }\n    else\n    {\n        vec4 ot = texture2D( iChannel0, i - vec2( 1. \/ iResolution.x, 0. ) );\n        float p = v.x \/ max(ot.z, 0.00001);\n        inflow += abs(p * ot.zw);\n    }\n    }\n    \n    if( i.y - 1. \/ iResolution.y >= 0. )\n    {\n    v = texture2D( iChannel1, i - vec2( 0., 1. \/ iResolution.y ) ).xy;\n    if( v.y < 0. )\n    {\n        float p = v.y \/ max(t.z, 0.00001);\n        inflow -= abs(p * t.zw);\n    }\n    else\n    {\n        vec4 ot = texture2D( iChannel0, i - vec2( 0., 1. \/ iResolution.y ) );\n        float p = v.y \/ max(ot.z, 0.00001);\n        inflow += abs(p * ot.zw);\n    }\n    }\n    \n    to.xy += inflow.xy;\n    fragColor = vec4(to.xy, vo.xy);\n}","name":"","description":"","type":"buffer"},{"inputs":[{"id":10,"src":"\/presets\/tex09.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":259,"src":"\/presets\/previz\/buffer02.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ reduce parts a,c->d for render and next cycle\n\/\/ and some landslides too so we get smoother erosion\n\n#define SLIP_FACTOR 0.01\nconst float KEY_LEFT  = 37.5\/256.0;\nconst float KEY_UP    = 38.5\/256.0;\nconst float KEY_RIGHT = 39.5\/256.0;\nconst float KEY_DOWN  = 40.5\/256.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tiles = 256.;\n    if( (fragCoord.x > tiles || fragCoord.y > tiles) && !( fragCoord.x > 257.9 && fragCoord.x < 258.9 && fragCoord.y < 0.9 ) )\n        discard;\n    \n    if( fragCoord.x > 257.9 && fragCoord.x < 258.9 && fragCoord.y < 0.9 )\n    {\n        \n        vec3 value = texture2D( iChannel0, fragCoord.xy \/ iResolution.xy ).rgb;\n        if( value.x == 0.0 || iGlobalTime < 0.25)\n        {\n            fragColor.rgb = vec3(0.5, -0.30, 6.3);\n            return;\n        }\n        else\n        {\n        \tfloat key = texture2D( iChannel3, vec2( KEY_DOWN, 0.25 ) ).x;\n        \tif( key > .5 )\n        \t    value.y -= 0.004;\n        \tkey = texture2D( iChannel3, vec2( KEY_UP, 0.25 ) ).x;\n        \tif( key > .5 )\n        \t    value.y += 0.004;\n        \tkey = texture2D( iChannel3, vec2( KEY_RIGHT, 0.25 ) ).x;\n        \tif( key > .5 )\n        \t    value.x += 0.004;\n        \tkey = texture2D( iChannel3, vec2( KEY_LEFT, 0.25 ) ).x;\n        \tif( key > .5 )\n        \t    value.x -= 0.004;\n        \tfragColor = vec4(value, 1.0);\n        \treturn;\n        }\n    }\n        \n    vec2 i = fragCoord \/ iResolution.xy;\n        \n    \/\/ h0, h1\n    \/\/ wh, d\n    vec2 b = texture2D(iChannel0, i).xy;\n    vec2 c = texture2D(iChannel1, i).xy;\n    \n    \/\/ when a max slope is exceeded by terrain layer 1, slide some material down it\n    float s1 = texture2D(iChannel2,i).r * SLIP_FACTOR + SLIP_FACTOR;\n    vec2 bo = b;\n    {\n    \tfor( float j = 0.; j < 1.9; j+=1. )\n    \t{\n    \t    float si = mod(j, 2.)*2.-1.;\n    \t\tvec2 bn = texture2D( iChannel0, min(vec2((tiles-1.)\/iResolution.x,1.),max(vec2(0.,2.\/iResolution.x),i+si*vec2(1.\/iResolution.x, 0. ))) ).xy;\n    \t\tfloat s2 = texture2D(iChannel2,min(vec2((tiles-1.)\/iResolution.x,1.),max(vec2(0.,2.\/iResolution.x),i+si*vec2(1.\/iResolution.x, 0. )))).r * SLIP_FACTOR + SLIP_FACTOR;\n    \t\tfloat diff = (bn.x + bn.y) - (b.x + b.y);\n    \t\tif( abs(diff) > s1+s2 )\n    \t\t{\n    \t        si = ((diff > 0.) ? 1. : -1.);\n    \t\t    float a = ((diff > 0.) ? bn.y : b.y);\n    \t\t    bo.y += si * min( a * .25, abs(diff * .25) );\n    \t\t}\n    \t}\n    \tfor( float j = 0.; j < 1.9; j+=1. )\n    \t{\n    \t    float si = mod(j, 2.)*2.-1.;\n    \t\tvec2 bn = texture2D( iChannel0, min(vec2(1.,(tiles-1.)\/iResolution.y),max(vec2(0.,2.\/iResolution.y),i+si*vec2(0., 1.\/iResolution.y ))) ).xy;\n    \t\tfloat s2 = texture2D(iChannel2,min(vec2(1.,(tiles-1.)\/iResolution.y),max(vec2(0.,2.\/iResolution.y),i+si*vec2(0., 1.\/iResolution.y )))).r * SLIP_FACTOR + SLIP_FACTOR;\n    \t\tfloat diff = (bn.x + bn.y) - (b.x + b.y);\n    \t\tif( abs(diff) > s1+s2 )\n    \t\t{\n    \t        si = ((diff > 0.) ? 1. : -1.);\n    \t\t    float a = ((diff > 0.) ? bn.y : b.y);\n    \t\t    bo.y += si * min( a * .25, abs(diff * .25) );\n    \t\t}\n    \t}\n    }\n    \n    \/\/ rain\n    if( mod(iGlobalTime, 30.) < 5. )\n    {\n    \tc.x += 0.000010;\n    }\n    else if( iGlobalTime > 20. && mod(iGlobalTime, 30.) > 15. && mod(iGlobalTime, 30.) < 22.)\n    {\n        \/\/ evaporate a bit\n        if( c.x > 0.002 && c.x > c.y + 0.00003 )\n        {\n            c.x -= 0.000005;\n        }\n    }\n    fragColor = vec4(bo,c);\n}","name":"","description":"","type":"buffer"}]}}