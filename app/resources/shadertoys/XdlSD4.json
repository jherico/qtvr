{"Shader":{"ver":"0.1","info":{"id":"XdlSD4","date":"1401530999","viewed":507,"name":"mandelbox_ryu","username":"EvilRyu","description":"mandelbox, see http:\/\/blog.hvidtfeldts.net\/index.php\/2011\/11\/distance-estimated-3d-fractals-vi-the-mandelbox\/","likes":5,"published":3,"flags":0,"tags":["fractal","mandelbox"],"hasliked":0},"renderpass":[{"inputs":[{"id":17,"src":"\/presets\/tex12.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\nfloat stime, ctime, time;\nvoid ry(inout vec3 p, float a){  \n\tfloat c,s;vec3 q=p;  \n\tc = cos(a); s = sin(a);  \n\tp.x = c * q.x + s * q.z;  \n  \tp.z = -s * q.x + c * q.z; \n}  \n\nfloat fixed_radius2 = 1.9;\nfloat min_radius2 = 0.1;\nfloat folding_limit = 1.0;\nfloat scale = -2.8;\nvec3 mtl = vec3(1.0, 1.3, 1.23)*0.8;\n\nvoid sphere_fold(inout vec3 z, inout float dz) {\n    float r2 = dot(z, z);\n    if(r2 < min_radius2) {\n        float temp = (fixed_radius2 \/ min_radius2);\n        z *= temp;\n        dz *= temp;\n    }else if(r2 < fixed_radius2) {\n        float temp = (fixed_radius2 \/ r2);\n        z *= temp;\n        dz *= temp;\n    }\n}\n\nvoid box_fold(inout vec3 z, inout float dz) {\n    z = clamp(z, -folding_limit, folding_limit) * 2.0 - z;\n}\n\nfloat mb(vec3 z) {\n    vec3 offset = z;\n    float dr = 1.0;\n    for(int n = 0; n < 15; ++n) {\n        box_fold(z, dr);\n        sphere_fold(z, dr);\n\n        z = scale * z + offset;\n        dr = dr * abs(scale) + 1.0;\n\t\t\/\/scale = -2.8 - 0.2 * stime;\n    }\n    float r = length(z);\n    return r \/ abs(dr);\n}\n\nfloat f(vec3 p){ \n\try(p, stime);\n    return mb(p); \n} \n\n\nfloat softshadow(vec3 ro, vec3 rd, float k ){ \n     float akuma=1.0,h=0.0; \n\t float t = 0.01;\n     for(int i=0; i < 50; ++i){ \n         h=f(ro+rd*t); \n         if(h<0.001)return 0.02; \n         akuma=min(akuma, k*h\/t); \n \t\t t+=clamp(h,0.01,2.0); \n     } \n     return akuma; \n} \n\n\nfloat pixel_size;\n\nvec2 intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 1.0;\n    float tm = 0.0;\n    float dm = 1000.0;\n\tfloat d = 1.0;\n    float pd = 100.0;\n    float os = 0.0;\n    float s = 0.0;\n    \n    for( int i=0; i<48; i++ )\n    {\n        if( d < pixel_size * t || t > 20.0 )\n        {}else{\n            d = f(ro + rd*t);\n\n            if(d > os)\n            {\n                os = 0.4 * d*d\/pd;\n                s = d + os;\n                pd = d;\n            }\n            else\n            {\n                s =-os; os = 0.0; pd = 100.0; d = 1.0;\n            }\n\n            if(d < dm * t) \n            {\n                tm = t;\n                dm = d;\n            }\n\n\t\t\t\n       \n            t += s;\n        }\n    }\n    return vec2(tm,dm);\n}\n\nvec3 lighting(vec3 p,vec3 rd, float ps) {\n\t\n\tvec3 l1_dir = normalize(vec3(0.8, 0.8, 0.4)); \n    vec3 l1_col = vec3(1.37, 0.99, 0.79);\n\tvec3 l2_dir = normalize(vec3(-0.8, 0.5, 0.3));\n    vec3 l2_col = vec3(0.89, 0.99, 1.3); \n    \n    vec3 e=vec3(0.5 * ps,0.0,0.0); \n \tvec3 n = normalize(vec3(f(p+e.xyy)-f(p-e.xyy), \n \t\t\t\t\t\t  f(p+e.yxy)-f(p-e.yxy), \n \t\t\t\t\t\t  f(p+e.yyx)-f(p-e.yyx)));\n\t\n\tfloat shadow = softshadow(p, l1_dir, 10.0 );\n\n    float dif1 = max(0.0, dot(n, l1_col));\n\tfloat dif2 = max(0.0, dot(n, l2_col));\n\tfloat bac1 = max(0.3 + 0.7 * dot(vec3(-l1_dir.x, -1.0, -l1_dir.z), n), 0.0);\n\tfloat bac2 = max(0.2 + 0.8 * dot(vec3(-l2_dir.x, -1.0, -l2_dir.z), n), 0.0);\n    float spe = max(0.0, pow(clamp(dot(l1_dir, reflect(rd, n)), 0.0, 1.0), 10.0)); \n\n    vec3 col = 1.5 * l1_col * dif1 * shadow;\n\tcol += 1.1 * l2_col * dif2;\n\tcol += 0.3 * bac1 * l1_col;\n\tcol += 0.3 * bac2 * l2_col; \n    col += 4.0 * spe; \n\t\n    float t=mod(p.y+0.1*texture2D(iChannel0,p.xz).x-time*150.0, 5.0);\n    col = mix(col, vec3(6.0, 6.0, 8.0), \n              pow(smoothstep(0.0, .3, t) * smoothstep(0.6, .3, t), 15.0));;\n\treturn col;\n}\n\nvec3 post(vec3 col, vec2 q) {\n\t \/\/ post\n    col=pow(clamp(col,0.0,1.0),vec3(0.45)); \n    col=col*0.6+0.4*col*col*(3.0-2.0*col);  \/\/ contrast\n    col=mix(col, vec3(dot(col, vec3(0.33))), -0.5);  \/\/ satuation\n    col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  \/\/ vigneting\n\treturn col;\n}\n\n\nvec3 get_background_color(vec2 uv, vec3 ro, vec3 rd) {\n\tvec3 bg = vec3(1.0); \n\treturn bg;\n}\nvec3 camera(float t){\n\tvec3 p=vec3(3.0*stime,2.0*ctime,5.0+1.0*stime);\n    return p;\n} \n void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n { \n    vec2 q=fragCoord.xy\/iResolution.xy; \n \tvec2 uv = -1.0 + 2.0*q; \n \tuv.x*=iResolution.x\/iResolution.y; \n    pixel_size = 1.0 \/ (iResolution.y * 2.8);\n\t\/\/ camera\n \tstime=sin(iGlobalTime*0.1); \n \tctime=cos(iGlobalTime*0.1); \n    time=iGlobalTime*0.01;\n\n \tvec3 ta=vec3(0.0,0.0,0.0); \n\t\/\/vec3 ro = vec3(0.0, 2.0, 5.9);\n    vec3 ro=camera(time);\n \tvec3 cf = normalize(ta-ro); \n    vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n    vec3 cu = normalize(cross(cs,cf)); \n \tvec3 rd = normalize(uv.x*cs + uv.y*cu + 2.8*cf);  \/\/ transform from view to world\n\n    \n\tvec3 bg = get_background_color(uv, ro, rd); \n    vec3 col = bg;\n\n    vec3 p=ro; \n\t \n\tvec2 res = intersect(ro, rd);\n\tfloat t = res.x, d = res.y;\n\tif(d < pixel_size * t){\n\t\tp = ro + t * rd;\n        col = lighting(p, rd, pixel_size * t)*mtl*0.2; \n        col = mix(col, bg, 1.0-exp(-0.001*t*t)); \n    } \n\n   \tcol=post(col, q);\n \tfragColor=vec4(col.x,col.y,col.z,1.0); \n }","name":"","description":"","type":"image"}]}}