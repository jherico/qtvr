{"Shader":{"ver":"0.1","info":{"id":"4lSXD1","date":"1443129300","viewed":1480,"name":"Dusty nebula 1","username":"Duke","description":"My attempt at creating something that looked like a nebula. The code is messy. I was just having fun.<br\/>Upd.: switch to iq's noise because it work faster","likes":22,"published":3,"flags":0,"tags":["explosion","nebula","dust"],"hasliked":0},"renderpass":[{"inputs":[{"id":28,"src":"\/presets\/tex15.png","ctype":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/Most of the code come from https:\/\/www.shadertoy.com\/view\/Xss3DS\n\/\/noise from here https:\/\/www.shadertoy.com\/view\/MtXSzS\n\/\/License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\/\/ change this to get different nebulas :)\n#define EXPLOSION_SEED 2.\n\n\n\/\/ the bounding sphere of the nebula. this is less general but means that\n\/\/ ray cast is only performed for nearby pixels, and raycast can begin from the sphere\n\/\/ (instead of walking out from the camera)\nfloat expRadius = 2.7;\nvec3 expCenter = vec3(0.,expRadius,0.);\n\n\/* original\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 \/ 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 \/ 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r){ return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat noise(vec3 v)\n{\n\tconst vec2  C = vec2(1.0\/6.0, 1.0\/3.0);\n\tconst vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\t\/\/ First corner\n\tvec3 i  = floor(v + dot(v, C.yyy));\n\tvec3 x0 = v - i + dot(i, C.xxx);\n\t\/\/ Other corners\n\tvec3 g = step(x0.yzx, x0.xyz);\n\tvec3 l = 1.0 - g;\n\tvec3 i1 = min(g.xyz, l.zxy);\n\tvec3 i2 = max(g.xyz, l.zxy);\n\tvec3 x1 = x0 - i1 + C.xxx;\n\tvec3 x2 = x0 - i2 + C.yyy; \/\/ 2.0*C.x = 1\/3 = C.y\n\tvec3 x3 = x0 - D.yyy;      \/\/ -1.0+3.0*C.x = -0.5 = -D.y\n\t\/\/ Permutations\n\ti = mod289(i);\n\tvec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\t\/\/ Gradients: 7x7 points over a square, mapped onto an octahedron.\n\t\/\/ The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n\tfloat n_ = 0.142857142857; \/\/ 1.0\/7.0\n\tvec3  ns = n_ * D.wyz - D.xzx;\n\tvec4 j = p - 49.0 * floor(p * ns.z * ns.z);  \/\/  mod(p,7*7)\n\tvec4 x_ = floor(j * ns.z);\n\tvec4 y_ = floor(j - 7.0 * x_);    \/\/ mod(j,N)\n\tvec4 x = x_ *ns.x + ns.yyyy;\n\tvec4 y = y_ *ns.x + ns.yyyy;\n\tvec4 h = 1.0 - abs(x) - abs(y);\n\tvec4 b0 = vec4(x.xy, y.xy);\n\tvec4 b1 = vec4(x.zw, y.zw);\n\tvec4 s0 = floor(b0) * 2.0 + 1.0;\n\tvec4 s1 = floor(b1) * 2.0 + 1.0;\n\tvec4 sh = -step(h, vec4(0.0));\n\tvec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n\tvec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\tvec3 p0 = vec3(a0.xy, h.x);\n\tvec3 p1 = vec3(a0.zw, h.y);\n\tvec3 p2 = vec3(a1.xy, h.z);\n\tvec3 p3 = vec3(a1.zw, h.w);\n\t\/\/Normalise gradients\n\tvec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\t\/\/ Mix final noise value\n\tvec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n\tm = m * m;\n\treturn 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n*\/\n\n\/\/ iq's noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D( iChannel1, (uv+ 0.5)\/256.0, -100.0 ).yx;\n\treturn -1.0+2.0*mix( rg.x, rg.y, f.z );\n}\n\n\/\/ assign colour to the media\nvec3 computeColour( float density, float radius )\n{\n\t\/\/ these are almost identical to the values used by iq\n\t\n\t\/\/ colour based on density alone. gives impression of occlusion within\n\t\/\/ the media\n\tvec3 result = mix( 1.1*vec3(1.0,0.9,0.8), vec3(0.4,0.15,0.1), density );\n\t\n\t\/\/ colour added for nebula\n\tvec3 colBottom = 3.1*vec3(0.8,1.0,1.0);\n\tvec3 colTop = 2.*vec3(0.48,0.53,0.5);\n\tresult *= mix( colBottom*2.0, colTop, min( (radius+.5)\/1.7, 1.0 ) );\n\t\n\treturn result;\n}\n\n\/\/ maps 3d position to colour and density\nfloat densityFn( in vec3 p, in float r, out float rawDens, in float rayAlpha )\n{\n    float l = length(p);\n\t\/\/ density has dependency on mouse y coordinate (linear radial ramp)\n\tfloat mouseIn = 0.75;\n\tif( iMouse.z > 0.0 )\n\t\tmouseIn = iMouse.y\/iResolution.y;\n\tfloat mouseY = 1.0 - mouseIn;\n    float den = 1. - 1.5*r*(4.*mouseY+.5);\n    \n\t\/\/ offset noise based on seed\n    float t = EXPLOSION_SEED;\n    vec3 dir = vec3(0.,1.,0.);\n    \n    \/\/ participating media    \n    float f;\n    vec3 q = p - dir* t; f  = 0.50000*noise( q );\n\tq = q*2.02 - dir* t; f += 0.25000*noise( q );\n\tq = q*2.03 - dir* t; f += 0.12500*noise( q );\n\tq = q*2.40 - dir* t; f += 0.06250*noise( q );\n    q = q*2.50 - dir* t; f += 0.03125*noise( q );\n    \n\t\/\/ add in noise with scale factor\n\trawDens = den + 4.0*f*l;\n\t\n    den = clamp( rawDens, 0.0, 1.0 );\n    \n    \/\/if (den>0.9) den = -3.*den;\n    \n\t\/\/ thin out the volume at the far extends of the bounding sphere to avoid\n\t\/\/ clipping with the bounding sphere\n\tden *= l*0.6-smoothstep(0.8,0.,r\/expRadius);\n\t\n\treturn den;\n}\n\nvec4 raymarch( in vec3 rayo, in vec3 rayd, in float expInter, in vec2 fragCoord )\n{\n    vec4 sum = vec4( 0.0 );\n     \n    float step = 0.075;\n     \n    \/\/ dither start pos to break up aliasing\n\tvec3 pos = rayo + rayd * (expInter + step*texture2D( iChannel0, fragCoord.xy\/iChannelResolution[0].x ).x);\n\t\n    for( int i=0; i<48; i++ )\n    {\n        if( sum.a > 0.99 ) continue;\n\t\t\n\t\tfloat radiusFromExpCenter = length(pos - expCenter);\n\t\t\n\t\tif( radiusFromExpCenter > expRadius+0.01 ) continue;\n\t\t\n\t\tfloat dens, rawDens;\n\t\t\n        dens = densityFn( pos, radiusFromExpCenter, rawDens, sum.a );\n\t\t\n\t\tvec4 col = vec4( computeColour(dens,radiusFromExpCenter), dens );\n\t\t\n\t\t\/\/ uniform scale density\n\t\tcol.a *= 0.2;\n\t\t\n\t\t\/\/ colour by alpha\n\t\tcol.rgb *= col.a\/0.8;\n\t\t\n\t\t\/\/ alpha blend in contribution\n\t\tsum = sum + col*(1.0 - sum.a);  \n\t\t\n\t\t\/\/ take larger steps through negative densities.\n\t\t\/\/ something like using the density function as a SDF.\n\t\tfloat stepMult = 1. + 2.5*(1.-clamp(rawDens+1.,1.,1.));\n\t\t\n\t\t\/\/ step along ray\n\t\tpos += rayd * step * stepMult;\n    }\n\t\n    return clamp( sum, 0.0, 1.0 );\n}\n\n\n\/\/ iq's sphere intersection\nfloat iSphere(in vec3 ro, in vec3 rd, in vec4 sph)\n{\n\t\/\/sphere at origin has equation |xyz| = r\n\t\/\/sp |xyz|^2 = r^2.\n\t\/\/Since |xyz| = ro + t*rd (where t is the parameter to move along the ray),\n\t\/\/we have ro^2 + 2*ro*rd*t + t^2 - r2. This is a quadratic equation, so:\n\tvec3 oc = ro - sph.xyz; \/\/distance ray origin - sphere center\n\t\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - sph.w * sph.w; \/\/sph.w is radius\n\tfloat h = b*b - c; \/\/ delta\n\tif(h < 0.0) \n\t\treturn -1.0;\n\tfloat t = (-b - sqrt(h)); \/\/Again a = 1.\n\n\treturn t;\n}\n\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos )\n{\n    \/\/ camera orbits around nebula\n\t\n    float camRadius = 3.8;\n\t\/\/ use mouse x coord\n\tfloat a = iGlobalTime*20.;\n\tif( iMouse.z > 0. )\n\t\ta = iMouse.x;\n\tfloat theta = -(a-iResolution.x)\/80.;\n    float xoff = camRadius * cos(theta);\n    float zoff = camRadius * sin(theta);\n    cameraPos = vec3(xoff,expCenter.y,zoff);\n     \n    \/\/ camera target\n    vec3 target = vec3(0.,expCenter.y,0.);\n     \n    \/\/ camera frame\n    vec3 fo = normalize(target-cameraPos);\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\n    vec3 up = normalize(cross(fo,ri));\n     \n    \/\/ multiplier to emulate a fov control\n    float fov = .5;\n\t\n    \/\/ ray direction\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\n\t\n\treturn rayDir;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\/\/ get aspect corrected normalized pixel coordinate\n    vec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x \/ iResolution.y;\n    \n\tvec3 rayDir, cameraPos;\n\t\n    rayDir = computePixelRay( p, cameraPos );\n\t\n\tvec4 col = vec4(0.);\n\t\n    \/\/ does pixel ray intersect with exp bounding sphere?\n\tfloat boundingSphereInter = iSphere( cameraPos, rayDir, vec4(expCenter,expRadius) );\n\tif( boundingSphereInter > 0. )\n\t{\n\t\t\/\/ yes, cast ray\n\t    col = raymarch( cameraPos, rayDir, boundingSphereInter,fragCoord );\n\t}\n\t\n    \/\/ smoothstep final color to add contrast\n    fragColor = vec4(col.xyz*col.xyz*(3.0-2.0*col.xyz),1.0);\n}\n","name":"","description":"","type":"image"}]}}