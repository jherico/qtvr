{"Shader":{"ver":"0.1","info":{"id":"4ls3zM","date":"1428189012","viewed":3913,"name":"Manta Ray","username":"dakrunch","description":"v2.0: <br\/>Improving the distance functions (tail still todo)<br\/>Worked on the anatomy.<br\/>Added gills.<br\/>Need to work on tracing the wings more efficiently.","likes":58,"published":3,"flags":0,"tags":["procedural"],"hasliked":0},"renderpass":[{"inputs":[{"id":3,"src":"\/presets\/tex02.jpg","ctype":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":4,"src":"\/presets\/tex03.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":16,"src":"\/presets\/tex11.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ version 2.0 = new anatomy, improved distance functions\n\/\/ version 1.5 = trying to make the water surface and the sea floor more interesting\n\/\/ version 1.3 = changed wing primitives and adding front flaps\n\/\/ version 1.2 = working on improving the shape\n\/\/ version 1.1 = multiple mantas. Added scattering attributes\n\/\/ Version 1.0 = creation. Added a background. Single manta swim loop\n\n\nconst vec3 sun = vec3(-0.6, 0.4,-0.3);\nfloat time = iGlobalTime+32.2;\nvec3 lightDir = normalize(vec3(.1,.7, .2));\n#define csb(f, con, sat, bri) mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), f*bri)), f*bri, sat), con)\n#define MATERIAL_DEBUG 2.0\n#define MATERIAL_SKIN 1.0\n#define MATERIAL_NONE 0.0\n\n\/\/ Quality modifiers\n#define SPACING 3.5\n#define BBSIZE 1.75\n#define MAXDIST 40.\n#define MAXSTEPS 300\n#define TRACEMULT .3\n\n\/\/ debug\n#define DEBUG 0\n\n\/\/--------------------------------------------------------------------------------------\n\/\/ Utilities....\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nvec3 Rotate_Y(vec3 v, float angle)\n{\n\tvec3 vo = v; float cosa = cos(angle); float sina = sin(angle);\n\tv.x = cosa*vo.x - sina*vo.z;\n\tv.z = sina*vo.x + cosa*vo.z;\n\treturn v;\n}\n\n\/\/ stolen from IQ.\nfloat softMin(float a, float b, float k)\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    \/\/ calculate deformed radius, not exact but decent estimate\n    float smallestSize = min(min(r.x,r.y),r.z);\n    vec3 deformedP = p\/r;\n    float d = length(deformedP) - 1.0;\n    \/\/ renormalize - ish\n   \treturn d * smallestSize;\n}\n\nfloat wings(in vec3 p) \n{   \n    vec3 r = vec3(1.5, 0.15, 0.55);\n    \/\/vec3 r = vec3(1.0);\n    float smallestSize = min(min(r.x,r.y),r.z);\n    \/\/ scale and position\n    vec3 dp = p\/r;\n    dp.z -= dp.x*dp.x*0.8; \/\/bend backward\n    dp.z -= (dp.x-0.6)*(dp.x-0.5);\n    dp.y -= 0.6; \/\/ lift up\n    \/\/ shape\n    \/\/float d = length(dp.zy);\n    float d = (dp.y*dp.y + dp.z*dp.z);\n    d += abs(dp.x);\n    d -= 1.0; \/\/ radius\n    \n    return d * smallestSize;\n}\n\nfloat mantabody(in vec3 p)\n{\n    \/\/ body\n    float d = sdEllipsoid(p, vec3(0.4,0.3,0.8));\n    \/\/float d = 10.;\n    \n    \/\/ wings\n    if (p.z < 1.0 && p.z > -1.4 &&\n       \tp.y < 1.0 && p.y > -0.2) \n    {\n    \td = softMin(d, wings(p), 0.4);\n        \/\/d = wings(p);\n    }\n    \n    vec3 flapsP;\n    vec3 flapsScale;\n    \n    \/\/ bottom flaps\n    if (p.x < 1.0 && \n        p.z < -0.2 && p.z > -1.4 &&\n       \tp.y < 0.2 && p.y > -0.2) \n    {\n        flapsP = p;\n    \tflapsP += vec3(-0.5-p.z*0.2,0.3-p.x*0.5,1.0-p.x*0.2);\n\t    flapsScale = vec3(.09,.08,.25);\n    \td = softMin(d, sdEllipsoid(flapsP,flapsScale),0.2);\n    }\n    \n    \/\/ dorsal fin\n    if (p.x < 0.2 && \n        p.z > 0.3 && p.z < 1.0 &&\n       \tp.y > 0.1 && p.y < 0.5) \n    {\n\t    flapsP = p;\n    \tflapsP += vec3(0.,-0.15- 0.2*p.z,-0.7);\n\t    flapsScale = vec3(.03,.1,.2);\n    \td = softMin(d, sdEllipsoid(flapsP,flapsScale),0.15);\n    }\n    \n    \/\/\n    if (p.z>0.0) {    \n\t    float taild = length(p.xy);\n    \td = softMin(d,taild,0.1);\n        d = max(d, smoothstep(2.3,2.5,p.z));\n    }\n    \n    \n    return d;\n}\n\nfloat GetMantaScale(in float rowId, in float columnId)\n{\n\treturn 0.6 + 0.6*hash(7.*rowId + 11.* columnId);\n}\n\n\nfloat animatedManta(in vec3 p, in float rowId, in float columnId) \n{   \n    float size = GetMantaScale(rowId, columnId);\n    \n    \/\/ animate\n    float timeloop = time * 2.5 \/ (size-0.25) + \/\/ loop speed\n        hash(rowId+3.*columnId) * 10.; \/\/ random offset\n    p.y+= -sin(timeloop-0.5)*.25 * size;\n    p.y+= sin(time*0.5 + hash(37.*rowId+11.*columnId)*17.) * 2.5;\n    \n \tvec3 mantap = p\/size;\n    mantap.x = abs(mantap.x);    \n \n    float animation = sin(timeloop-3. - 1.3*mantap.z);\n    float animationAmount = pow(mantap.x,1.5);\n    animationAmount = min(animationAmount, 2.5); \/\/ cap max deformation to avoid alias on wings\n    mantap.y += animation * (0.3*animationAmount + 0.15);\n    \n    float d = mantabody(mantap);\n    \n    return d*size;\n}\n\n\n\/\/--------------------------------------------------------------------------------------\nvec2 Scene(vec3 p, in int includeNeighbors, in int debug)\n{\n    p.z+= time;\n\tfloat mat = MATERIAL_SKIN;\n    \n    \/\/ Repeat\n    vec3 loopP = p;\n    loopP.x = mod(loopP.x+BBSIZE, SPACING)-BBSIZE;\n    loopP.z = mod(loopP.z+BBSIZE, SPACING)-BBSIZE;\n\n    \/\/scramble\n    float rowId = floor((p.x+ BBSIZE)\/SPACING);\n    float columnId = floor((p.z+ BBSIZE)\/SPACING);\n    \n    float d = animatedManta(loopP, rowId, columnId);\n    \/\/ careful about BB edges!\n    if (includeNeighbors == 1) \n    {\n        d = min(d, BBSIZE+0.1-abs(loopP.x));\n        d = min(d, BBSIZE+0.1-abs(loopP.z));\n    }\n    \n    \n    if (debug == 1) \n    {\n        float planeD = abs(p.y - 2.*sin(time));\n        \n        \/\/if (planeD < d) {\n            d = planeD;\n            mat = MATERIAL_DEBUG;\n        \/\/}\n    }\n\n\treturn vec2(d, mat);\n}\n\n\/\/--------------------------------------------------------------------------------------\nvec4 Trace(vec3 rayOrigin, vec3 rayDirection, out float hit)\n{\n\tconst float minStep = 0.005;\n    hit = 0.0;\n\t\n    vec2 ret = vec2(0.0, 0.0);\n    vec3 pos = rayOrigin;\n\tfloat dist = 0.0;\n    for(int i=0; i < MAXSTEPS; i++){\n\t\tif (hit == 0.0 && dist < MAXDIST && pos.y<10.0 && pos.y > -10.0 )\n        {\n            pos = rayOrigin + dist * rayDirection;\n            \n            \/\/ ret.x: distance, ret.y: material type\n            ret = Scene(pos, 1, DEBUG);\n            \n            if (ret.x < 0.01)\n                hit = ret.y;\n\n            \/\/ increment\n            if (ret.y >= 2.0)\n                dist += ret.x * 10.0;\n            else \n            {\n            \tfloat increment = ret.x*TRACEMULT;\n                increment = max(minStep, increment);\n                dist += increment;\n            }\n        }\n    }\n    return vec4(pos, ret.y);\n}\n\n\/\/--------------------------------------------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tvec3 eps = vec3(0.0001,0.0,0.0);\n\treturn normalize(vec3(Scene(p+eps.xyy,0, 0).x-Scene(p-eps.xyy,0, 0).x,\n\t\t\t\t\t\t  Scene(p+eps.yxy,0, 0).x-Scene(p-eps.yxy,0, 0).x,\n\t\t\t\t\t\t  Scene(p+eps.yyx,0, 0).x-Scene(p-eps.yyx,0, 0).x ));\n}\n\n\/\/--------------------------------------------------------------------------------------\nvec3 GetColour(vec4 p, vec3 n, vec3 org, vec3 dir)\n{\n    vec3 localP = vec3(p) + vec3(0.,0.,time);\n    vec3 loopP = localP;\n    loopP.x = mod(loopP.x+BBSIZE, SPACING)-BBSIZE;\n    loopP.z = mod(loopP.z+BBSIZE, SPACING)-BBSIZE; \n\n    \/\/scramble\n    float rowId = floor((localP.x+0.5*SPACING)\/SPACING);\n    float columnId = floor((localP.z+0.5*SPACING)\/SPACING);\n    float size = GetMantaScale(rowId, columnId);\n    vec2 coord = loopP.xz;\n    loopP\/=size;\n    \n\tvec3 colour = vec3(0.0);\n\tif (p.w < 1.5)\n    {\n\t\tfloat v = clamp(-(n.y-.1)*6.2, 0.3, 1.0);\n\t\tv+=.35;\n\t\tcolour = vec3(v*.8, v*.9, v*1.0);\n\t}\n    \n    vec3 colorUp = colour;\n    if (n.y < 0.4) \n    {    \n\t    float stainsUp = texture2D(iChannel1, coord).x;\n    \tstainsUp *= stainsUp * 2.;\n\t    stainsUp = 1.-stainsUp;\n\t\tstainsUp += smoothstep(2.,-2.,loopP.z);\n\t    stainsUp = clamp(stainsUp, 0., 1.);\n        \n        float gillsV = loopP.z*60.;\n        float gillsU = abs(loopP.x*0.7);\n        float maskV = (loopP.z+0.1*size)*1.2;\n        gillsV += gillsU*16.0; \/\/bend\n        float mask = 1.5-(10.0*gillsU*gillsU)-(10.0*maskV*maskV);\n        mask *= min(gillsU*10., 1.0);\n        mask = clamp(mask, 0.0, 1.0);\n        float gills = 1.1 + sin(gillsV)*0.6;\n        gills = clamp(gills, 0.1, 1.0);\n        gills = mix(1.0, gills, mask);\n        stainsUp *= gills;\n        \n    \tcolorUp *= stainsUp;\n    }\n    \n    vec3 colorDown = colour;\n    if (n.y > -0.4)\n    {\n    \tfloat stainsDown = texture2D(iChannel1, coord*0.4).x;\n\t    stainsDown *= stainsDown;\n\t    stainsDown = clamp(stainsDown, 0., 1.);\n        \n    \tcolorDown *= vec3(stainsDown);\n    }\n    \n    colour = mix(colorUp, colorDown, smoothstep(-0.4,0.4,n.y));   \n\n    \/\/ Water caustics\n    vec2 wat = p.xz*1.;\n    wat +=  (texture2D(iChannel0, (wat*5.0+time*.04)*.1, 3.0).z -\n             texture2D(iChannel0, wat*.3-time*.03, 2.0).y) * .4;\n    float causticLight = texture2D(iChannel0, wat* .04, 0.0).x;\n    causticLight = pow(max(0.0, causticLight-.2), 1.0) * 20. * smoothstep(-5.,3.,p.y);\n    colour *= vec3(1.0) + vec3(causticLight*.5, causticLight, causticLight)*max(n.y, 0.0); \n    \n    \/\/ shadow\n    float diff = dot(n,lightDir);\n    \/\/ light properties\n    vec3 brightLight = vec3(0.7,0.7,0.8);\n    vec3 shade = vec3(0.12,0.15,0.22);\n    colour *= mix(shade,brightLight,max(diff*0.5+0.5,0.0));\n    \n    return colour;\n}\n\n\n\/\/--------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 col;\t\n\tvec2 uv = (fragCoord.xy \/ iResolution.xy) - vec2(.5);\n\tuv.x*=iResolution.x\/iResolution.y;\n\tvec3 dir = normalize(vec3(uv, -1.0));\n\t\n\t\/\/vec3 pos = vec3(1.3, sin(time+4.3)*.18-.05, sin(-time*.15)*5.0-1.35);\n    vec3 pos = (sin(time*0.14)*2.+4.5)*vec3(sin(time*.5), 0.0, cos(time*.5));\n    pos.z -= time;\n    pos.y += 0.7 * sin(time * 0.2);\n    float rot = -time*0.5;\n\tdir = Rotate_Y(dir, rot);\n\n    \/\/ Sun...\n\tfloat i = max(0.0, 1.\/(length(sun-dir)+1.0));\n\tcol = vec3(pow(i, 1.9), pow(i, 1.0), pow(i, .8)) * 1.3;\n\t\n\t\/\/ Water depth colour...\n\tcol = mix(col, vec3(0.0, .25, .45), ((1.0-uv.y)*.45) * 1.8);\n\t\n    float d;\n\tif (uv.y >= 0.0)\n\t{\n\t\t\/\/ Add water ripples...\n        d = (3.0-pos.y) \/ -uv.y;\n\t\t\n        vec2 wat = (dir * d).xz-pos.xz;\n        d += 1.*sin(wat.x + time);\n        wat = (dir * d).xz-pos.xz;\n        wat = wat * 0.1 + 0.2* texture2D(iChannel0, wat, 0.0).xy;\n        \n\t\ti = texture2D(iChannel3, wat, 0.0).x;\n        \n\t\tcol += vec3(i) * max(2.\/-d, 0.0);\n\t}\n\telse\t\t\n\t{\n\t\t\/\/ Do floor stuff...\n\t\td = (-3.0-pos.y) \/ uv.y;\n\t\tvec2 coord = pos.xz+(dir.xz * d);\n\t\tvec3 sand = texture2D(iChannel3, coord* .1).rgb * 1.5  + \n\t\t\t\t\ttexture2D(iChannel3, coord* .23).rgb;\n        sand *= 0.5;\n\t\t\n\t\tfloat f = ((-uv.y-0.3 +sin(time*0.1)*0.2)*2.45) * .4;\n\t\tf = clamp(f, 0.0, 1.0);\n\t\t\n\t\tcol = mix(col, sand, f);\n\t}\n\n\tfloat hit = 0.0;\n\tvec4 loc = Trace(pos, dir, hit);\n    float material = loc.w;\n\tif (hit > 0.0)\n\t{\n        if (material == MATERIAL_DEBUG) \n        {\n            col = vec3(1.,0.,0.0);\n            vec2 ret = Scene(loc.xyz, 0, 0);\n            float d = ret.x;\n            col = vec3(mod(d,1.0), mod(d*10.0,1.0), 0.0);\n        } \n        else \n        {    \n            vec3 norm = GetNormal(loc.xyz);\n            vec3 foundColor = GetColour(loc, norm, pos, dir);\n            vec3 backgroundColor = col;\n\n            \/\/ total water reflection\n            float facing = -dot(norm,dir);\n            float upfacing = clamp(norm.y, 0.,1.);\n            float fresnel = 1.0-facing;\n            fresnel = clamp(pow(fresnel, 1.0), 0.0,1.0);\n            foundColor = mix(foundColor, backgroundColor*2.0, 0.5 * (0.5 + upfacing*upfacing) * fresnel);\n\n            \/\/ atmos\n            float dis = length(pos-loc.xyz);\n            float fogAmount = clamp(max((dis-.5),0.0)\/MAXDIST, 0.0, 1.0);\n\n            col = mix(foundColor, backgroundColor, fogAmount );\n        }\n\t}\n\t\n    \/\/ Contrast, saturation and brightness...\n\tcol = csb(col, 1.1, 1.05, 1.22);\n\tfragColor = vec4(col, 10);\n}\n","name":"","description":"","type":"image"}]}}