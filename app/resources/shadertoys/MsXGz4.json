{"Shader":{"ver":"0.1","info":{"id":"MsXGz4","date":"1363595124","viewed":3371,"name":"Cubemaps","username":"iq","description":"Note that the reflection is properly occluded (see the reflection shadow of the sphere on the plane)","likes":49,"published":3,"flags":0,"tags":["3d","raymarching","distancefield","cubemap"],"hasliked":0},"renderpass":[{"inputs":[{"id":2,"src":"\/presets\/tex01.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":7,"src":"\/presets\/tex06.jpg","ctype":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":22,"src":"\/presets\/cube00_0.jpg","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"id":23,"src":"\/presets\/cube01_0.png","ctype":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nvec2 map( vec3 p )\n{\n    vec2 d2 = vec2( p.y+1.0, 2.0 );\n\n\tfloat r = 1.0;\n\tfloat f = smoothstep( 0.0, 0.5, sin(3.0+iGlobalTime) );\n\tfloat d = 0.5 + 0.5*sin( 4.0*p.x + 0.13*iGlobalTime)*\n\t\t                sin( 4.0*p.y + 0.11*iGlobalTime)*\n\t\t                sin( 4.0*p.z + 0.17*iGlobalTime);\n    r += f*0.4*pow(d,4.0);\/\/*(0.5-0.5*p.y);\n    vec2 d1 = vec2( length(p) - r, 1.0 );\n\n    if( d2.x<d1.x) d1=d2;\n\n\tp = vec3( length(p.xz)-2.0, p.y, mod(iGlobalTime + 6.0*atan(p.z,p.x)\/3.14,1.0)-0.5 );\n\t\/\/p -= vec3( 1.5, 0.0, 0.0 );\n    vec2 d3 = vec2( 0.5*(length(p) - 0.2), 3.0 );\n    if( d3.x<d1.x) d1=d3;\n\n\t\n\treturn d1;\n}\n\n\nvec4 sphereColor( in vec3 pos, in vec3 nor )\n{\n\tvec2 uv = vec2( atan( nor.x, nor.z ), acos(nor.y) );\n    vec3 col = (texture2D( iChannel3, uv ).xyz);\n    float ao = clamp( 0.75 + 0.25*nor.y, 0.0, 1.0 );\n    return vec4( col, ao );\n}\n\nvec4 satelitesColor( in vec3 pos, in vec3 nor )\n{\n\tvec2 uv = vec2( atan( nor.x, nor.z ), acos(nor.y) );\n    vec3 col = (texture2D( iChannel3, uv ).xyz);\n    float ao = 1.0;\n    return vec4( col, ao );\n}\n\nvec4 floorColor( in vec3 pos, in vec3 nor )\n{\n    vec3 col = texture2D( iChannel2, 0.5*pos.xz ).xyz;\n\t\n    \/\/ fake ao\n    float f = smoothstep( 0.1, 1.75, length(pos.xz) );\n\n\treturn vec4( col, 0.5*f+0.5*f*f );\n}\n\nconst float precis = 0.001;\nvec2 intersect( in vec3 ro, in vec3 rd )\n{\n\tfloat h=precis*2.0;\n    vec3 c;\n    float t = 0.0;\n\tfloat maxd = 9.0;\n    float sid = -1.0;\n    for( int i=0; i<100; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) continue;\/\/break;\n        t += h;\n\t    vec2 res = map( ro+rd*t );\n        h = res.x;\n\t    sid = res.y;\n    }\n\n    if( t>maxd ) sid=-1.0;\n    return vec2( t, sid );\n}\n\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3  eps = vec3(precis,0.0,0.0);\n    vec3 nor;\n    nor.x = map(pos+eps.xyy).x - map(pos-eps.xyy).x;\n    nor.y = map(pos+eps.yxy).x - map(pos-eps.yxy).x;\n    nor.z = map(pos+eps.yyx).x - map(pos-eps.yyx).x;\n    return normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x\/iResolution.y;\n    vec2 mo = iMouse.xy\/iResolution.xy;\n\t\n    \/\/ camera\n\tfloat an1 = 0.2*iGlobalTime-6.2831*mo.x;\n\tfloat an2 = clamp( 0.8 + 0.6*sin(2.2+iGlobalTime*0.11)  + 1.0*mo.y, 0.3, 1.35 );\n    vec3 ro = 2.5*normalize(vec3(sin(an2)*cos(an1), cos(an2)-0.5, sin(an2)*sin(an1)));\n    vec3 ww = normalize(vec3(0.0,0.0,0.0) - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.4*ww );\n\n    \/\/ raymarch\n    vec3 col = textureCube( iChannel0, rd ).xyz;\n\t\n    vec2 tmat = intersect(ro,rd);\n    if( tmat.y>0.5 )\n    {\n        \/\/ geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormal(pos);\n        vec3 ref = reflect(rd,nor);\n\n\t\tfloat rim = pow(clamp(1.0+dot(nor,rd),0.0,1.0),4.0);\n\n        col = textureCube( iChannel1, nor ).xyz;\n\n        \/\/ color\n        vec4 mate = vec4(0.0);\n        if( tmat.y<1.5 )\n            mate = sphereColor(pos,nor);\n        else if( tmat.y<2.5 )\n            mate = floorColor(pos,nor);\n        else\n            mate = satelitesColor(pos,nor);\n\t\t\n        col += 2.0*rim*pow(mate.w,3.0);\n\t\tcol *= mate.w;\n\t\tcol *= mate.xyz;\n\n\t\t\/\/ reflection occlusion\t\t\n\t\tvec2 tref = intersect(pos+nor*0.001,ref);\n\t\tif( tref.y<0.5 )\n\t\t{\n\t\t\tfloat fre = 0.3 + 0.7*pow( clamp( 1.0 + dot( rd, nor ), 0.0, 1.0 ), 5.0 );\n\t\t    vec3 sss = textureCube( iChannel0, ref ).xyz;\n\t\t    col += 2.0*mate.w*pow(sss,vec3(4.0))*fre;\n\t\t}\n\n        col = sqrt(col);\n    }\n\n    col *= 0.25 + 0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15 );\n\n    fragColor = vec4(col,1.0);\n}","name":"","description":"","type":"image"}]}}