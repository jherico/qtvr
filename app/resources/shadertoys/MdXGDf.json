{"Shader":{"ver":"0.1","info":{"id":"MdXGDf","date":"1380560205","viewed":1667,"name":"Trig Calculator","username":"eiffie","description":"A handy desktop emergency trig calculator. Use the mouse to select the angle. Performs the functions Sine, Cosine, ArcSine, ArcCosine and calculates PI (if you lay the rulers on the table). It has an attachable Tangent ruler but it is a bit unwieldly.","likes":15,"published":3,"flags":0,"tags":["trigonometry"],"hasliked":0},"renderpass":[{"inputs":[{"id":6,"src":"\/presets\/tex05.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Trig Calculator by eiffie\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nconst int MarchSteps=48,ShadowSteps=24;\/\/the soft shadow code was a little unique, the rest bleh\nconst float FudgeFactor=1.0,shadows=0.6,contrast=0.6;\nconst float spec=1.0,specExp=64.0,HitDistance=0.001,maxDepth=10.0;\nconst vec3 dirLight=vec3(0.577,0.577,-0.577),colLight=vec3(1.0,0.9,0.7);\nbool bColoring=false;\nfloat px;\nmat2 rmx;\nvec3 pg,pg2,dc;\n\n#define tex iChannel0\n#define size iResolution\n#define time iGlobalTime\nfloat RBox(in vec3 z, in vec4 r){return length(max(abs(z)-r.xyz,0.0))-r.w;}\nfloat RCyl(in vec3 z, in vec3 r){return length(max(vec2(abs(z.z)-r.y,length(z.xy)-r.x),0.0))-r.z;}\nfloat DE(in vec3 z){\/\/thingy\n\tfloat dT=RBox(z-vec3(-1.0,-1.3,3.0),vec4(5.0,0.245,3.1,0.05));\n\tfloat dW=RCyl(z-vec3(-px,0.0,0.25),vec3(0.95,0.245,0.05));\n\tfloat dA=RCyl((z-vec3(-px,-0.45,-0.1)).xzy,vec3(0.0,0.45,0.025));\n\tdA=min(dA,RCyl(z-vec3(-px,0.0,0.0),vec3(0.0,0.05,0.025)));\n\tfloat dA2=RBox(z-pg-vec3(0.0,-1.0,-0.15),vec4(0.025,1.0,-0.04,0.05));\n\tfloat dA3=RBox(z-pg2-vec3(0.0,-1.0,-0.2),vec4(0.025,1.0,-0.04,0.05));\n\tfloat dP=RCyl(z-pg,vec3(0.0,0.15,0.015));\n\tdP=min(dP,RCyl(z-pg2,vec3(0.0,0.2,0.015)));\n\tfloat dS=min(dP,min(min(dT,dW),min(dA,min(dA2,dA3))));\n\tif(bColoring){\/\/since all the pixels get colored at once\n\t\tbColoring=false;\n\t\tif(dS==dT){\/\/table\n\t\t\tdc=vec3(0.5);\n\t\t\tif(z.z<-0.13)dc=vec3(0.1,0.2,0.3);\n\t\t\telse if(z.z<0.0 && z.x<=0.0){\n\t\t\t\tfloat d=mod(z.x,1.0);\n\t\t\t\tif(z.z<-0.1){d=mod(d,0.025);}else if(z.z<-0.07)d=mod(d,0.1);\n\t\t\t\tdc=mix(vec3(0.0),dc,smoothstep(0.0,0.02,d));\n\t\t\t}\n \t\t}else if(dS==dW){\/\/wheel\n\t\t\tvec3 p=z-vec3(-px,0.0,0.0);\n\t\t\tp.xy=p.xy*rmx;\n\t\t\tdc=texture2D(tex,p.xy+vec2(0.0,sin(p.y+p.z*(10.0-p.x*3.0))*0.02)).rgb;\n\t\t\tdc=mix(vec3(0.0),dc,smoothstep(0.0,0.01,abs(length(p.xy+vec2(0.0,0.7))-0.03)));\n\t\t\tfloat r=length(p.xy);\n\t\t\tif(r>0.75 && r<0.975){\n\t\t\t\tfloat d=atan(p.y,p.x)*0.318;\n\t\t\t\tif(r>0.85){d=mod(d,0.02777777);}else d=mod(d,0.25);\n\t\t\t\tdc=mix(vec3(0.0),dc,smoothstep(0.0,0.01,d));\n\t\t\t}\n\t\t}else if(dS==dA)dc=vec3(1.0,0.0,0.0);\/\/angle marker\n\t\telse if(dS==dA2 || dS==dA3){\/\/sine and cosine rulers\n\t\t\tdc=vec3(0.75);\n\t\t\tif(dS==dA3){pg=pg2;dc=vec3(0.9,0.6,0.3);}\n \t\t\tvec3 p=z-pg-vec3(0.0,-1.0,-0.15);\n\t\t\tdc=mix(vec3(0.0),dc,smoothstep(0.0,0.01,min(abs(length(p.xy)-0.03),max(abs(p.x),abs(p.y-1.0)-0.025))));\n\t\t\tif(p.x<0.0){\n \t\t\t\tfloat d=p.y;\n\t\t\t\tif(p.x<-0.025){d=mod(d,0.025);}else d=mod(d,0.1);\n \t\t\t\tdc=mix(vec3(0.0),dc,smoothstep(0.0,0.02,d));\n\t\t\t}\n\t\t}else dc=vec3(0.25);\/\/pegs\n\t}\n\treturn dS;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\/\/using the number of steps as the major contributor \n \/\/but then doing something like iq's trick at the end to reduce banding\n\tfloat t=mint*10.0,d=1.0,fStep=0.0;\n\tfor( int i=0; i<ShadowSteps; i++ ){\n\t\tif(t>maxt || d<0.001)continue;\n\t\tt+=d=DE(ro+rd*t);\n\t\tfStep+=1.0;\n\t}\n\tif(d<0.01)return 0.0;\n\treturn 1.0-(fStep-d*k\/t)\/float(ShadowSteps);\/\/no rationale, just seems to work\n}\n\nvec3 scene( vec3 ro, vec3 rd )\n{\/\/ find color of scene\n\tvec3 col=vec3(0.2+rd.y*0.5);\n\tfloat t=0.0,d=10.0;\n\tfor(int i=0;i<MarchSteps;i++){\n\t\tif(t>maxDepth || d<HitDistance)continue;\n\t\tt+=d=DE(ro+rd*t)*FudgeFactor;\n\t}\n\tif(d<0.02){\n\t\tbColoring=true;\n\t\tt+=d=DE(ro+rd*t);\n\t\tro+=rd*(t-HitDistance);\n\t\tconst vec2 ve=vec2(0.0002,0.0);\n\t\tvec3 nor=normalize(vec3(-DE(ro-ve.xyy)+DE(ro+ve.xyy),\n\t\t\t-DE(ro-ve.yxy)+DE(ro+ve.yxy),-DE(ro-ve.yyx)+DE(ro+ve.yyx)));\n\t\tfloat dif=max(0.0, dot(dirLight, nor)),shad=0.0;\n\t\tif(shadows>0.0 && dif>0.0)shad=softshadow(ro,dirLight,HitDistance,maxDepth,12.0);\n\t\tcol=dc*(1.0-shadows+shad*shadows)*(1.0-contrast+dif*contrast)\n\t\t\t+colLight*shad*spec*pow(max(0.0,dot(rd,reflect(dirLight,nor))),specExp);\n\t}\n\treturn clamp(col,0.0,1.0);\n}\t \n\nmat3 lookat(vec3 fw,vec3 up){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,normalize(up)));return mat3(rt,cross(rt,fw),fw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tpx=5.0*iMouse.x\/size.x;\n\tfloat f=0.0,cx=cos(px-f),sx=sin(px-f);\n\trmx=mat2(cx,sx,-sx,cx);\n\tpg=vec3(rmx*vec2(-1.0,0.0),0.0)-vec3(px,0.0,0.0);\n\tpg2=vec3(rmx*vec2(0.0,-1.0),0.0)-vec3(px,0.0,0.0);\n\tvec3 clr=vec3(0.0);\n\tvec3 ro=vec3(-2.0,0.5,-3.0);\n\tmat3 rotCam=lookat(vec3(-px,-0.5,0.0)-ro,vec3(0.0,1.0,0.0));\n\tvec3 rd=rotCam*normalize(vec3((2.0*(fragCoord.xy)-size.xy)\/size.y,2.0));\n\tfragColor = vec4(scene(ro,rd),1.0);\n}\n\n\n\n  ","name":"","description":"","type":"image"}]}}