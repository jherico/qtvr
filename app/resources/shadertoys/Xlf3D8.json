{"Shader":{"ver":"0.1","info":{"id":"Xlf3D8","date":"1421287180","viewed":907,"name":"scifi","username":"bergi","description":"More explorations of the Kali set. <br\/>Watch for at least 5 hours, or play with the offset in line 39.","likes":5,"published":3,"flags":0,"tags":["raymarching","space","alien","science"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/*  i like artefacts\n    \n\tAnother nice island in the absdot world\n    https:\/\/www.shadertoy.com\/view\/4tX3W8\n\t(lengthy fractal forums url ommitted for style)\n\n\taGPL3 \/ (c) 2014 stefan berke\n\n\tWatch for at least 5 hours, or play with the offset in line 39.\n\tBut beware, this is like those Planetarium shows where the camera \n\ttravels with approximately 1000 light years per second to show us \n\tthe beauty of the milky way.\n\tIt's not related to our daily experience. \n\tThe Kali set gets really interesting when we zoom in on a particular\n\tspot. We just need the coordinates!\n*\/\n\n#define PATH 3\t\t\t\t\/\/ 1-3\n#define NUM_ITER 19\t\t\t\/\/ very depended value\n#define NUM_TEX_ITER 60\t\t\/\/ iterations for texture\n#define NORM_EPS 0.002\t\n#define NUM_TRACE 100\n#define PRECISSION 0.1\n#define FOG_DIST 0.05\n#define DIMENSIONS 3\t\t\/\/ 3 or 4 - complexity switch\n\n#if DIMENSIONS == 3\n\/\/ 3 coordinates to navigate through the sets\n\/\/ be careful! this is probably where arthur dent lost fenchurch.\n#define MAGIC_PARAM vec3(-.4+0.3*sin(sec\/7.), -.8, -1.5 + 0.01*sin(sec\/3.))\n\n#elif DIMENSIONS == 4\n\/\/ a 4 dimensional key to our three-dimensional space\n#define MAGIC_PARAM vec4(-.4+0.3*sin(sec\/17.), -.31, -1.5 + 0.01*sin(sec\/13.3), -0.5)\n#endif\n\n\/\/ shader-local global animation time\n\/\/ add an offset to jump to other places\nfloat sec = iGlobalTime \/ 5. + 124.;\n\n\n\/\/ -------------------------- fractal -----------------------------\n\n#if DIMENSIONS == 3\n\/\/ kali set\n\/\/ position range depending on parameters\n\/\/ but usually at least +\/- 0.01 to 2.0 or even (even much) larger\n\/\/ check the camera path's in main(), it's tiny!\nfloat duckball_s(in vec3 p) \n{\n\tfloat mag;\n\tfor (int i = 0; i < NUM_ITER; ++i) \n\t{\n\t\tmag = dot(p, p);\n\t\tp = abs(p) \/ mag + MAGIC_PARAM;\n\t}\n\treturn mag;\n}\n\n\/\/ same as above but in 'some' color\nvec3 duckball_color(in vec3 p) \n{\n    vec3 col = vec3(0.);\n\tfloat mag;\n\tfor (int i = 0; i < NUM_TEX_ITER; ++i) \n\t{\n\t\tmag = dot(p, p);\n\t\tp = abs(p) \/ mag + MAGIC_PARAM;\n        col += p;\n\t}\n\treturn min(vec3(1.), 2.0 * col \/ float(NUM_TEX_ITER));\n}\n\n#elif DIMENSIONS == 4\n\nfloat duckball_s(in vec3 pos) \n{\n    vec4 p = vec4(pos, 0.1);\n\tfloat mag;\n\tfor (int i = 0; i < NUM_ITER; ++i) \n\t{\n\t\tmag = dot(p, p);\n\t\tp = abs(p) \/ mag + MAGIC_PARAM;\n\t}\n    \/\/ it seems much more crowded in 4d\n    \/\/ so increase the distance to surfaces\n\treturn mag * 2.7;\n}\n\nvec3 duckball_color(in vec3 pos) \n{\n    vec4 p = vec4(pos, 0.1), col = vec4(0.);\n\tfloat mag;\n\tfor (int i = 0; i < NUM_TEX_ITER; ++i) \n\t{\n\t\tmag = dot(p, p);\n\t\tp = abs(p) \/ mag + MAGIC_PARAM;\n        col += p;\n\t}\n\treturn min(vec3(1.), col.xyz \/ float(NUM_TEX_ITER));\n}\n\n#endif\n\n\/\/ ---- canonical shader magic ----\n\nfloat scene_d(in vec3 p)\n{\n\treturn min(50.1+50.*sin(sec\/12.), duckball_s(p)*0.01-0.004);\n}\n\nvec3 scene_n(in vec3 p)\n{\n\tconst vec3 e = vec3(NORM_EPS, 0., 0.);\n\treturn normalize(vec3(\n\t\t\tscene_d(p + e.xyy) - scene_d(p - e.xyy),\n\t\t\tscene_d(p + e.yxy) - scene_d(p - e.yxy),\n\t\t\tscene_d(p + e.yyx) - scene_d(p - e.yyx) ));\n}\n\nvec3 scene_color(in vec3 p)\n{\n\tvec3 ambcol = \n        vec3(0.9,0.5,0.1) * (0.2+duckball_color(p));\n    \n    \/\/ lighting\n\tfloat dull = max(0., dot(vec3(1.), scene_n(p)));\n\treturn ambcol * (0.3+0.7*dull);\n}\n\nvec3 sky_color(in vec3 pos, in vec3 dir)\n{\n\tvec3 c = vec3(0.2,0.6,0.9);\n    return c * 0.5 + 0.1 * duckball_color(dir + 0.3 * pos);\n}\n\nvec3 traceRay(in vec3 pos, in vec3 dir)\n{\n\tvec3 p;\n\tfloat t = 0.;\n\tfor (int i=0; i<NUM_TRACE; ++i)\n\t{\n\t\tp = pos + t * dir;\n\t\tfloat d = scene_d(p);\n\n        \/\/ increase distance for too close surfaces\n        d += 0.01*(1. - smoothstep(0.01, 0.011, t));\n\n\t\/\/\tif (d < 0.001)\n\t\/\/\t\tbreak;\n\n\t\tt += d * PRECISSION;\n\t}\n\t\n\treturn mix(scene_color(p), sky_color(p, dir), min(2.6, t\/FOG_DIST));\n}\n\n\n\n\n\/\/ ---------- helper --------\n\nvec2 rotate(in vec2 v, float r)\n{\n\tfloat s = sin(r), c = cos(r);\n    \treturn vec2(v.x * c - v.y * s, v.x * s + v.y * c);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy \/ iResolution.xy * 2. - 1.;\n    \tuv.x *= float(iResolution.x) \/ float(iResolution.y);\n    \n\t\/\/ ray direction (cheap sphere section)\n\tvec3 dir = normalize(vec3(uv, 1.5));\n\n    vec3 pos = vec3(0.   + 0.25 * sin(sec\/47.), \n                    0.   + 0.85 * sin(sec\/17.), \n                    1.   + 0.95 * sin(sec\/20.));\n    dir.xy = rotate(dir.xy, sec*0.7 + sin(sec*0.41));\n    dir.xz = rotate(dir.xz, sec*0.6);\n    \n    \t\/\/ run\n\tvec3 col = traceRay(pos, dir);\n  \n   \tfragColor = vec4(traceRay(pos, dir),1.0);\n}","name":"","description":"","type":"image"}]}}