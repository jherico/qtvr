{"Shader":{"ver":"0.1","info":{"id":"MllSzl","date":"1439073657","viewed":744,"name":"TileSquare","username":"GrosPoulet","description":"Inspired by <a href=\"http:\/\/glslsandbox.com\/e#25778.0\" class=\"regular\" target=\"_blank\">http:\/\/glslsandbox.com\/e#25778.0<\/a>","likes":6,"published":3,"flags":0,"tags":["square","tile"],"hasliked":0},"renderpass":[{"inputs":[{"id":8,"src":"\/presets\/tex07.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Inspired by http:\/\/glslsandbox.com\/e#25778.0\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ defines\n\/\/ Max size of square in pixels\n#define SIZE 50.0\n\/\/ The bigger, the flatter tiles are\n#define CORNER 20.0\n\/\/ Time in second(s) to zoom in or out\n#define ZOOM_TIME 10.0\n\n\/\/ Light direction\n#define LIGHT_DIR vec3(0.65, 0.57, 2.0) \n\n#define pi 3.1415926535897932384626433832795\n#define hfpi 1.5707963267948966192313216916398\n#define PI pi\n#define HFPI hfpi\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ methods\nfloat AnimateSize()\n{\n    float i = floor(iGlobalTime \/ ZOOM_TIME);\n    float r = (iGlobalTime - ZOOM_TIME * i) \/ ZOOM_TIME;\n    float sinr = pow(sin(HFPI * r), 2.0);\n    float k = ( mod(i, 2.0) == 0.0 ? sinr : 1.0 - sinr );\n \treturn max(k*SIZE, 2.0);\n}\n\nvec3 TileSquare(vec2 posSample)\n{   \t\t\n\tfloat size = AnimateSize();\n    float halfSize = size \/ 2.0;\n    \n    vec2 screenPos = posSample*iResolution.xy - (iResolution.xy \/ 2.0) - vec2(halfSize);\n    vec2 pos = mod(screenPos, vec2(size)) - vec2(halfSize);\n\t\t\n    vec2 uv = posSample - pos\/iResolution.xy;\n   \n\tvec3 texColorSample = texture2D(iChannel0, uv).rgb;\n\t\n\tvec3 normal = normalize(vec3(tan((pos.x\/size) * PI), tan((pos.y\/size) * PI), CORNER));\n    \/\/vec3 normal = normalize(vec3(pos.x\/halfSize, pos.y\/halfSize, smoothstep(0.0, halfSize, halfSize - sqrt(pos.x*pos.x + pos.y*pos.y))*CORNER)); \/\/nice\n   \n\tfloat bright = dot(normal, normalize(LIGHT_DIR));\n\t\n\tbright = pow(bright, 0.5);\n\t\n    vec3 colFinal = texColorSample * bright;\n    \n\tvec3 heif = normalize(LIGHT_DIR + vec3(0.0, 0.0, 0.1));\n\t\n\tfloat spec = pow(dot(heif, normal), 96.0);\n\t\n\tcolFinal += vec3(spec);\n\t\t\n    \/\/ Set the final fragment color.\n\treturn colFinal;\n} \n\n\/\/ Sample a procedural texture (anti-aliasing)\n\/\/ Stolen from IQ: https:\/\/www.shadertoy.com\/view\/MdjGR1\nvec3 TileSquareAA( vec2 uv )\n{\n\t#define SAMPLING_STRENGTH 1000000000.0\n\t#define NB_SAMPLES 3 \/\/0: no anti-aliasing\n\t\n\tif (NB_SAMPLES == 0)\n\t{\n\t\treturn TileSquare( uv );\n\t}\n\telse\n\t{\n\t\t\/\/ calc texture sampling footprint\t\t\n\t\tvec2 ddx = dFdx( uv ); \n\t\tvec2 ddy = dFdy( uv ); \n\t\n\t\tint sx = 1 + int( clamp( SAMPLING_STRENGTH*length(ddx), 0.0, float(NB_SAMPLES-1) ) );\n\t\tint sy = 1 + int( clamp( SAMPLING_STRENGTH*length(ddy), 0.0, float(NB_SAMPLES-1) ) );\n\n\t\tvec3 no = vec3(0.0);\n\n\t\tfor( int j=0; j<NB_SAMPLES; j++ )\n\t\tfor( int i=0; i<NB_SAMPLES; i++ )\n\t\t{\n\t\t\tif( j<sy && i<sx )\n\t\t\t{\n\t\t\t\tvec2 st = vec2( float(i), float(j) ) \/ vec2( float(sx),float(sy) );\n\t\t\t\tno += TileSquare( uv + st.x*ddx + st.y*ddy );\n\t\t\t}\n\t\t}\n\n\t\treturn no \/ float(sx*sy);\n\t}\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;   \n    \n    \/\/pan\n  \tuv -= iMouse.xy \/ iResolution.xy;\n\t\t\n\tvec3 col = TileSquareAA( uv );\n\t\n    \/\/ Set the final fragment color.\n\tfragColor = vec4(col,1.0);\n}","name":"","description":"","type":"image"}]}}