{"Shader":{"ver":"0.1","info":{"id":"XssGRs","date":"1377128402","viewed":1181,"name":"Into The Sponge","username":"fb39ca4","description":"I tried to make this as close to a perfect loop as possible. If you get a black screen, and you are using Windows, try disabling ANGLE in your browser. https:\/\/github.com\/mrdoob\/three.js\/wiki\/How-to-use-OpenGL-or-ANGLE-rendering-on-Windows","likes":15,"published":3,"flags":0,"tags":["raymarching","menger","loop","sponge"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"const int MAX_RAY_STEPS = 24;\nconst float RAY_STOP_TRESHOLD = 0.0001;\nconst int MENGER_ITERATIONS = 5;\nconst float PI = 3.14159265359;\n\nfloat maxcomp(vec2 v) { return max(v.x, v.y); }\n\nvec2 rot2D(vec2 v, float angle) {\n\tfloat sinA = sin(angle);\n\tfloat cosA = cos(angle);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\n}\n\nfloat sdCross(vec3 p, float w) {\n\tp = abs(p);\n\tvec3 d = vec3(max(p.x, p.y),\n\t\t\t\t  max(p.y, p.z),\n\t\t\t\t  max(p.z, p.x));\n\treturn min(d.x, min(d.y, d.z)) - w;\n}\n\nfloat sdCrossRep(vec3 p, float w) {\n\tvec3 q = mod(p + 1.0, 2.0) - 1.0;\n\treturn sdCross(q, w);\n}\n\nfloat sdCrossRepScale(vec3 p, float s, float w) {\n\treturn sdCrossRep(p * s, w) \/ s;\t\n}\n\nfloat scene(vec3 p, float t) {\n\tfloat scale = 1.0;\n\tfloat dist = 0.0;\n\tfor (int i = 0; i < MENGER_ITERATIONS; i++) {\n\t\tdist = max(dist, -sdCrossRepScale(p, scale, 1.0 \/ 3.0));\n\t\tscale *= 3.0;\n\t}\n\tdist = max(dist, -sdCrossRepScale(p, scale, pow(t, 0.2) \/ 3.0));\n\treturn dist;\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 colorize(float c) {\n\tfloat hue = mix(0.6, 1.15, min(c * 1.2 - 0.05, 1.0));\n\tfloat sat = 1.0 - pow(c, 4.0);\n\tfloat lum = c;\n\tvec3 hsv = vec3(hue, sat, lum);\n\tvec3 rgb = hsv2rgb(hsv);\n\treturn vec4(rgb, 1.0);\t\n}\n\nvec3 cameraPath(float t) {\n\tt *= PI \/ 2.0;\n\treturn 2.0 \/ 3.0 * vec3(0.0, 1.0 - cos(t), sin(t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 screenPos = fragCoord.xy \/ iResolution.xy * 2.0 - 1.0;\n\tvec2 mousePos = iMouse.xy \/ iResolution.xy * 2.0 - 1.0;\n\tfloat s = mod(iGlobalTime * 0.25, 1.0);\n\tfloat t = 0.5 * (3.0 * s - s * s);\n\n\tvec3 cameraPos1 = vec3(0.0, 0.0, 0.0);\n\tvec3 cameraPos2 = vec3(0.0, 2.0 \/ 3.0, 2.0 \/ 3.0);\n\t\n\tfloat mixAmount = sin(iGlobalTime) * 0.5 + 0.5;\n\t\n\n\tvec3 cameraPos = cameraPath(t);\n\t\/\/cameraPos = vec3(0.0);\n\t\n\tvec3 cameraDir = vec3(0.0, 0.0, 1.0);\n\tvec3 cameraPlaneU = vec3(1.0, 0.0, 0.0);\n\tvec3 cameraPlaneV = vec3(0.0, 1.0, 0.0) * (iResolution.y \/ iResolution.x);\n\n\tvec3 rayPos = cameraPos;\n\tvec3 rayDir = cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;\n\trayDir.yz = rot2D(rayDir.yz, (-PI \/ 2.0) * s - PI \/ 12.0);\n\t\n\trayDir = normalize(rayDir);\n\t\n\tfloat rayStopTreshold = RAY_STOP_TRESHOLD * pow(3.0, -t);\n\trayStopTreshold = mix(RAY_STOP_TRESHOLD, RAY_STOP_TRESHOLD \/ 3.0, t);\n\t\n\tfloat dist = scene(rayPos, t);\n\tint stepsTaken;\n\tfor (int i = 0; i < MAX_RAY_STEPS; i++) {\n\t\tif (dist < rayStopTreshold) {\n\t\t\tcontinue;\n\t\t}\n\t\trayPos += rayDir * dist * 0.9;\n\t\tdist = scene(rayPos, t);\n\t\tstepsTaken = i;\n\t}\n\t\n\tfloat fractSteps = 0.0;\n\t\n\tvec4 color = colorize(pow((float(stepsTaken) + fractSteps) \/ float(MAX_RAY_STEPS), 0.9));\n\t\t\n\tfragColor = color;\n}","name":"","description":"","type":"image"}]}}