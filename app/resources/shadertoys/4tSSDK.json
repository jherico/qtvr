{"Shader":{"ver":"0.1","info":{"id":"4tSSDK","date":"1446383899","viewed":649,"name":"Tornado 1","username":"Duke","description":"Port of tornado example from this <a href=\"http:\/\/www.html5rocks.com\/en\/tutorials\/casestudies\/oz\/\" class=\"regular\" target=\"_blank\">http:\/\/www.html5rocks.com\/en\/tutorials\/casestudies\/oz\/<\/a> topic with some optimizations.","likes":16,"published":3,"flags":0,"tags":["noise","vortex","tornado","compute"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Port of tornado example from this http:\/\/www.html5rocks.com\/en\/tutorials\/casestudies\/oz\/ topic with some optimizations.\n\/\/ I express deep gratitude to Dmytry Lavrov for creating and assistance in porting this shader\n\n\/\/The \"Storm Shader\" by Dmytry Lavrov, Copyright 2012 (http:\/\/dmytry.com\/) with permission from Moritz Helmsteadter at\n\/\/The Max Plank Institute is licensed under a Creative Commons attribution license http:\/\/creativecommons.org\/licenses\/by\/3.0\/\n\/\/free to share and remix for any purpose as long as it includes this note.\n\/\/Uses 'Computed noise' by Flavien Brebion.\n\/\/License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nconst float spin_speed=1.0;\n\nconst int number_of_steps=160; \/\/ number of isosurface raytracing steps\nconst float base_step_scaling=0.6; \/\/ Larger values allow for faster rendering but cause rendering artifacts. When stepping the isosurface, the value is multiplied by this number to obtain the distance of each step\nconst float min_step_size=0.4; \/\/ Minimal step size, this value is added to the step size, larger values allow to speed up the rendering at expense of artifacts.\n\nconst float tornado_bounding_radius=35.0;\n\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n\/* original noise\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\/\/\/ 'Computed noise' by Flavien Brebion.\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0+p.z*137.0;\n    float res = 1.0-2.0*mix(\n\t    mix(mix( hash(n+  0.0), hash(n+  1.0),f.x), mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n\t    mix(mix( hash(n+  137.0), hash(n+  138.0),f.x), mix( hash(n+ 57.0+137.0), hash(n+ 58.0+137.0),f.x),f.y),\n\t    f.z\n    );\n    return res;\n}\n*\/\n\n\/\/ iq's noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D( iChannel0, (uv+ 0.5)\/256.0, -100.0 ).yx;\n\treturn -1.0+2.4*mix( rg.x, rg.y, f.z );\n}\n\nmat2 Spin(float angle){\n\treturn mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n}\n\nfloat ridged(float f){\n\treturn 1.0-2.0*abs(f);\n}\n\n\/\/ The isosurface shape function, the surface is at o(q)=0\nfloat Shape(vec3 q)\n{\n    q.y += 45.0;\n    float h = 90.0;\n\tfloat t=spin_speed*iGlobalTime;\n\t\/\/if(q.y<0.0)return length(q);\n\tvec3 spin_pos=vec3(Spin(t-sqrt(q.y))*q.xz,q.y-t*5.0);\n\tfloat zcurve=pow(q.y,1.5)*0.03;\n\tfloat v=abs(length(q.xz)-zcurve)-5.5-clamp(zcurve*0.2,0.1,1.0)*noise(spin_pos*vec3(0.1,0.1,0.1))*5.0;\n\tv=v-ridged(noise(vec3(Spin(t*1.5+0.1*q.y)*q.xz,q.y-t*4.0)*0.3))*1.2;\n    v=max(v, q.y - h);\n\treturn min(max(v, -q.y),0.0)+max(v, -q.y);\n}\n\n\/\/ Calculates fog colour, and the multiplier for the colour of item behind the fog. \n\/\/ If you do two intervals consecutively it will calculate the result correctly.\nvoid FogStep(float dist, vec3 fog_absorb, vec3 fog_reemit, inout vec3 colour, inout vec3 multiplier)\n{\n    vec3 fog=exp(-dist*fog_absorb);\n\tcolour+=multiplier*(vec3(1.0)-fog)*fog_reemit;\n\tmultiplier*=fog;\n}\n\nvoid RaytraceFoggy(vec3 org, vec3 dir, float min_dist, float max_dist, inout vec3 colour, inout vec3 multiplier)\n{\n    \/\/ camera\n    vec3 q=vec3(0.0);\n\n\tfloat d=0.0;\n\tfloat dist=min_dist;\n\n\tfloat step_scaling=base_step_scaling;\n\n\tconst float extra_step=min_step_size;\n\tfor(int i=0;i<number_of_steps;i++)\n\t{\n        q=org+dist*dir;\n\t\tfloat shape_value=Shape(q);\n\t\tfloat density=-shape_value;\n\t\td=max(shape_value*step_scaling,0.0);\n\t\tfloat step_dist=d+extra_step;\n\t\tif(density>0.0){\n\t\t\tfloat brightness=exp(-0.6*density);\n\t\t\tFogStep(step_dist*0.2, clamp(density, 0.0, 1.0)*vec3(1,1,1),vec3(1)*brightness, colour, multiplier);\n\t\t}\n\n\t\tif(dist>max_dist || multiplier.x<0.01){\n\t\t\treturn;\n\t\t}\n\t\tdist+=step_dist;\n\t}\n\treturn;\n}\n\n\/\/ bounding cylinder from Dmytry Lavrov\nbool RayCylinderIntersect(vec3 org, vec3 dir, out float min_dist, out float max_dist)\n{ \n\tvec2 p=org.xz;\n\tvec2 d=dir.xz;\n\tfloat r=tornado_bounding_radius;\n\tfloat a=dot(d,d)+1.0E-10;\/\/\/ A in quadratic formula , with a small constant to avoid division by zero issue\n\tfloat det, b;\n\tb = -dot(p,d); \/\/\/ -B\/2 in quadratic formula\n\t\/\/\/ AC = (p.x*p.x + p.y*p.y + p.z*p.z)*dd + r*r*dd \n\tdet=(b*b) - dot(p,p)*a + r*r*a;\/\/\/ B^2\/4 - AC = determinant \/ 4\n\tif (det<0.0){\n\t\treturn false;\n\t}\n\tdet= sqrt(det); \/\/\/ already divided by 2 here\n\tmin_dist= (b - det)\/a; \/\/\/ still needs to be divided by A\n\tmax_dist= (b + det)\/a;\t\n\t\n\tif(max_dist>0.0){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 background_color=vec3(0.4, 0.4, 0.7);\n    vec3 org = vec3(0., 0., -100.);  \n    vec3 dir = normalize(vec3((fragCoord.xy-0.5*iResolution.xy)\/iResolution.y, 1.));\n    R(dir.yz, -iMouse.y*0.01*pi*2.);\n    R(dir.xz, iMouse.x*0.01*pi*2.);\n    R(org.yz, -iMouse.y*0.01*pi*2.);\n    R(org.xz, iMouse.x*0.01*pi*2.);\n\n    \/\/Raymarching the isosurface:\n\tfloat dist=0.0;\n\tvec3 multiplier=vec3(1.0);\n\tvec3 color=vec3(0.0);\n    float min_dist=0.0;\n    float max_dist=200.0;\n\n    if(RayCylinderIntersect(org, dir, min_dist, max_dist))\n    {\n        min_dist=max(min_dist,0.0);    \n        RaytraceFoggy(org, dir, min_dist, max_dist, color, multiplier);\n        vec3 col=color*0.5+multiplier*background_color;    \n\t\tfragColor=vec4(col , 1.0);\n    }\n    else\n    {\n        fragColor=vec4(background_color, 1.0);\n    }\n}\n","name":"","description":"","type":"image"}]}}