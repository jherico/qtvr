{"Shader":{"ver":"0.1","info":{"id":"MlXXDB","date":"1439447562","viewed":969,"name":"Minimalist","username":"mgattis","description":"My first try at path tracing. Casting more rays give amazing results. Had to give it a try. Special thanks to: http:\/\/blog.hvidtfeldts.net\/. Here is a nice SW rendered image of the above: https:\/\/dl.dropboxusercontent.com\/u\/8746356\/minimalist.png.","likes":9,"published":3,"flags":0,"tags":["raymarching","pathtracing"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ mgattis\n\n#define MAX_DISTANCE        (8.0)\n#define MIN_DELTA           (0.004)\n#define MAX_RAYITERATIONS   (96)\n#define MAX_RAYSAMPLES      (4)\n#define MAX_RAYREFLECTIONS  (8)\n\n#ifndef M_PI\n#define M_PI                (3.1415926535897932384626433832795)\n#endif\n\nvec2 seed;\n\nvec2 rand2n() {\n    seed+=vec2(-1,1);\n\t\/\/ implementation based on: lumina.sourceforge.net\/Tutorials\/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n\t\tfract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n \nvec3 ortho(vec3 v) {\n    \/\/  See : http:\/\/lolengine.net\/blog\/2013\/09\/21\/picking-orthogonal-vector-combing-coconuts\n    return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)  : vec3(0.0, -v.z, v.y);\n}\n\nvec3 getSampleBiased(vec3  dir, float power) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = rand2n();\n\tr.x=r.x*2.*M_PI;\n\tr.y=pow(r.y,1.0\/(power+1.0));\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n \nvec3 getSample(vec3 dir) {\n\treturn getSampleBiased(dir,0.0); \/\/ <- unbiased!\n}\n\nvec3 getCosineWeightedSample(vec3 dir) {\n\treturn getSampleBiased(dir,1.0);\n}\n\nvec3 getConeSample(vec3 dir, float extent) {\n    \/\/ Formula 34 in GI Compendium\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r =  rand2n();\n\tr.x=r.x*2.*M_PI;\n\tr.y=1.0-r.y*extent;\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\nvec3 vRotateY(vec3 p, float angle) {\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\treturn vec3(c*p.x-s*p.z, p.y, s*p.x+c*p.z);\n}\n\nfloat sphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat plane(in vec3 p, in float y) {\n    return p.y - y;\n}\n\nfloat udBox(in vec3 p, in vec3 b) {\n\treturn length(max(abs(p)-b,0.0));\n}\n\nfloat getMap(in vec3 position, out int object) {\n    float rayDelta;\n    float temp;\n    \n    vec3 p = position;\n    \n    rayDelta = sphere(p - vec3(0.0, 0.2, 0.0), 1.0);\n    object = 1;\n    \n    temp = udBox(p - vec3(0.0, -1.8, 0.0), vec3(1.0, 1.0, 1.0));\n    if (temp < rayDelta) {\n        rayDelta = temp;\n        object = 1;\n    }\n    \n    temp = plane(p, -1.0);\n    if (temp < rayDelta) {\n        rayDelta = temp;\n        object = 1;\n    }\n    \n    return rayDelta;\n}\n\nvec3 getNormal(vec3 p) {\n    vec3 s = p;\n    float h = MIN_DELTA;\n    int object;\n    return normalize(vec3(\n            getMap(p + vec3(h, 0.0, 0.0), object) - getMap(p - vec3(h, 0.0, 0.0), object),\n            getMap(p + vec3(0.0, h, 0.0), object) - getMap(p - vec3(0.0, h, 0.0), object),\n            getMap(p + vec3(0.0, 0.0, h), object) - getMap(p - vec3(0.0, 0.0, h), object)));\n}\n\nfloat castRay(in vec3 origin, in vec3 direction, out int object, out int iterations) {\n    float rayDistance = 0.0;\n    float rayDelta = 0.0;\n    vec3 rayPosition;\n    \n    rayPosition = origin;\n    \n    for (int i = 0; i < MAX_RAYITERATIONS; i++) {\n        iterations += 1;\n        \n        rayDelta = getMap(rayPosition, object);\n        \n        rayDistance += rayDelta;\n        rayPosition = origin + direction * rayDistance;\n        if (rayDelta <= MIN_DELTA) {\n            return rayDistance;\n        }\n        if (rayDistance >= MAX_DISTANCE) {\n            object = 0;\n\t\t\treturn MAX_DISTANCE;\n        }\n    }\n    \n    object = 0;\n    return MAX_DISTANCE;\n}\n\nvec3 getBackground(in vec3 direction) {\n    vec3 color = vec3(0.8, 0.9, 1.0);\n    \n    vec3 bgDirection = normalize(vec3(1.0, 1.0, -1.0));\n    float bgVal = max(0.0, dot(bgDirection, direction));\n    color = mix(color, vec3(1.0, 1.0, 1.0), bgVal);\n                      \n    return color;\n}\n\nvec3 getColor(in vec3 position, in vec3 direction, in int object) {\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    if (object == 0) {\n        color = getBackground(direction);\n    }\n    else if (object == 1) {\n        color = vec3(1.0, 1.0, 1.0);\n    }\n    \n    return color;\n}\n\nvec3 castFullRay(in vec3 origin, in vec3 direction, in int subframe) {\n    vec3 color = vec3(1.0, 1.0, 1.0);\n    vec3 directLight = vec3(0.0, 0.0, 0.0);\n    float Albedo = 0.4;\n    int iterations = 0;\n    int object = 0;\n    \n    vec3 rayOrigin = origin;\n    vec3 rayDirection = direction;\n    \n    seed = direction.xy * (float(subframe) + iGlobalTime + 1.0);\n    \n    for (int i = 0; i < MAX_RAYREFLECTIONS; i++) {\n        float rayDistance = castRay(rayOrigin, rayDirection, object, iterations);\n        if (object != 0) {            \n            vec3 rayPosition = rayOrigin + rayDirection * rayDistance;\n            vec3 rayNormal = getNormal(rayPosition);\n            vec3 newDirection = normalize(getSample(rayNormal));\n\n            color *= getColor(rayPosition, rayDirection, object) * Albedo * 2.0;\n            \n            rayOrigin = rayPosition + rayNormal * MIN_DELTA * 4.0;\n            rayDirection = newDirection;\n            \n            vec3 sunDirection = normalize(vec3(1.0, 1.0, -1.0));\n            vec3 sunSampleDirection = getConeSample(sunDirection, 0.0001);\n            float sunLight = dot(rayNormal, sunSampleDirection);\n            if (sunLight > 0.0) {\n                castRay(rayOrigin, sunSampleDirection, object, iterations);\n                if (object == 0) {\n                    directLight += color * sunLight * 1.0;\n                    \/\/return vec3(1.0, 0.0, 0.0);\n                }\n            }\n        }\n        else {\n            return directLight + color * getBackground(rayDirection);\n        }\n    }\n    \n    return vec3(0.0, 0.0, 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    vec2 uv = 2.0 * fragCoord.xy \/ iResolution.y;\n    uv -= vec2(iResolution.x \/ iResolution.y, 1.0);\n    \n    float myLocalTime = iGlobalTime * 0.2 + 2.0;\n    \n    vec3 origin = vRotateY(vec3(0.0, 0.0, -4.0), myLocalTime);\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    for (int i = 0; i < MAX_RAYSAMPLES; i++) {\n        seed = uv.xy * (float(i) + 1.0);\n        vec3 direction = normalize(vec3(uv.xy + rand2n() \/ iResolution.y * 2.0, 2.0));\n        direction = vRotateY(direction, myLocalTime);\n    \tcolor += castFullRay(origin, direction, i);\n    }\n    \n    color = color \/ float(MAX_RAYSAMPLES);\n    \n    fragColor = vec4(color,1.0);\n}","name":"","description":"","type":"image"}]}}