{"Shader":{"ver":"0.1","info":{"id":"MtsXzf","date":"1438956985","viewed":1567,"name":"[SIG15] Matrix Lobby Scene","username":"reinder","description":"PLEASE REWIND ON FIRST LOAD (\u23ea), TO MAKE SURE AUDIO IS IN SYNC.","likes":22,"published":3,"flags":8,"tags":["matrix","scene","sig15","lobby"],"hasliked":0},"renderpass":[{"inputs":[{"id":7,"src":"\/presets\/tex06.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":10,"src":"\/presets\/tex09.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Reinder Nijhoff 2015\n\/\/ @reindernijhoff\n\/\/\n\/\/ https:\/\/www.shadertoy.com\/view\/MtsXzf\n\/\/\n\n#define HIGHQUALITY 1\n#define RENDERDEBRIS 0\n#define REFLECTIONS 1\n\n#define MARCHSTEPS 90\n#define MARCHSTEPSREFLECTION 30\n#define DEBRISCOUNT 8\n\n#define BPM             (140.0)\n#define STEP            (4.0 * BPM \/ 60.0)\n#define ISTEP           (1.\/STEP)\n#define STT(t)\t\t\t(t*(60.0\/BPM))\n\nfloat damageMod;\nvec4 ep1, ep2, ep3, ep4, ep5;  \n\n\/\/-----------------------------------------------------\n\/\/ noise functions\n\n#define MOD2 vec2(.16632,.17369)\nfloat hash(float p) { \/\/ by Dave Hoskins\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);\n}\n\nfloat noise( const in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D( iChannel0, (uv+ 0.5)\/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat noise( const in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn texture2D( iChannel0, (uv+118.4)\/256.0, -100.0 ).x;\n}\n\n\/\/-----------------------------------------------------\n\/\/ intersection functions\n\nvec3 nSphere( in vec3 pos, in vec4 sph ) {\n    return (pos-sph.xyz)\/sph.w;\n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.;\n\treturn -b - sqrt( h );\n}\n\n\/\/----------------------------------------------------------------------\n\/\/ distance primitives\n\nfloat sdBox( const in vec3 p, const in vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdColumn( const in vec3 p, const in vec2 b ) {\n    vec2 d = abs(p.xz) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\/\/----------------------------------------------------------------------\n\/\/ distance operators\n\nfloat opU( float d2, float d1 ) { return min( d1,d2); }\nfloat opS( float d2, float d1 ) { return max(-d1,d2); }\n    \n\/\/--------------------------------------------\n\/\/ map\n\nfloat tileId( const in vec3 p, const in vec3 nor ) { \n    if( abs(nor.y) > .9 ) return 0.;\n    \n    float x, y;\n    if( abs(nor.z) < abs(nor.x)) {\n        x = p.z-6.;\n    } else {\n        x = abs(p.x)-16.;\n    }\n    if( p.y < 2.5 ) {\n    \treturn floor( x \/ 3.6 ) * sign(p.x);\n    }\n    return floor( x \/ 1.8 ) * sign(p.x) * (floor( (p.y+7.5) \/ 5. ));\n}\n\n\nvec3 bumpMapNormal( const in vec3 pos, in vec3 nor ) {\n    float i = tileId( pos, nor );\n    if( i > 0. ) {\n        nor+= 0.0125 * vec3( hash(i), hash(i+5.), hash(i+13.) );\n        nor = normalize( nor );\n    }\n    return nor;\n}\n\nfloat map( const in vec3 p ) {\n    float d = -sdBox( p, vec3( 28., 14., 63. ) );\n\n    vec3 pm = vec3( abs( p.x ) - 17.8, p.y, mod( p.z, 12.6 ) - 6.);    \n    vec3 pm2 = abs(p) - vec3( 14., 25.25, 0. );\n    vec3 pm3 = abs(p) - vec3( 6.8, 0., 56.4 );      \n\n    d = opU( d, sdColumn( pm, vec2( 1.8, 1.8 ) ) );        \n    d = opS( d, sdBox( p,  vec3( 2.5, 9.5, 74. ) ) );    \n    d = opS( d, sdBox( p,  vec3( 5., 18., 73. ) ) );\n    d = opS( d, sdBox( p,  vec3( 13.8, 14.88, 63. ) ) );\n    d = opS( d, sdBox( p,  vec3( 13.2, 25., 63. ) ) );\n    d = opS( d, sdColumn( p,  vec2( 9.5, 63. ) ) ); \n    d = opU( d, sdColumn( pm3, vec2( 1.8, 1.8 ) ) );\n    d = opU( d, sdBox( pm2, vec3( 5., .45, 200. ) ) );\n    \n    return d;\n}\n\nfloat mapDamage( vec3 p ) {\n    float d = map( p );\n\n    float n = max( max( 1.-abs(p.z*.01), 0. )*\n                   max( 1.-abs(p.y*.2-1.2), 0. ) *\n                   noise( p*.3 )* (noise( p*2.3 ) +.2 )-.2 - damageMod, 0.);\n   \n\treturn d + n;\n}\n\nfloat mapDamageHigh( vec3 p ) {\n    float d = map( p );\n    \n    float p1 = noise( p*2.3 );\n    float p2 = noise( p*5.3 );\n    \n    float n = max( max( 1.-abs(p.z*.01), 0. )*\n                   max( 1.-abs(p.y*.2-1.2), 0. ) *\n                   noise( p*.3 )* (p1 +.2 )-.2 - damageMod, 0.);\n  \n    float ne = 0.;\n    ne += smoothstep( -0.7, 0., -distance( p, ep1.xyz ) );\n    ne += smoothstep( -0.7, 0., -distance( p, ep2.xyz ) );\n    ne += smoothstep( -0.7, 0., -distance( p, ep3.xyz ) );\n    ne += smoothstep( -0.7, 0., -distance( p, ep4.xyz ) );\n    ne += smoothstep( -0.7, 0., -distance( p, ep5.xyz ) );\n    \n    n += .5 * max((ne - p2 ),0.) * ne;\n  \n    if( p.y < .1 ) {\n        n += max(.1*(1.-abs(d)+7.*noise( p*.7 )+.9*p1+.5*p2)-4.5*damageMod,0.);\n    }\n    \n    if( abs(n) > 0.0 ) {\n        n += noise( p*11.) * .05;\n        n += noise( p*23.) * .03;\n    }\n    \n\treturn d + n;\n}\n\n\nvec3 calcNormalDamage( in vec3 pos, in float eps ) {\n    if( pos.y < 0.001 && (mapDamageHigh(pos)-map(pos)) < eps ) {   \t\t\n\t        return vec3( 0., 1., 0. );\n    }\n    \n    vec2 e = vec2(1.0,-1.0)*(0.5773*eps);\n    vec3 n =  normalize( e.xyy*mapDamageHigh( pos + e.xyy ) + \n\t\t\t     \t\t e.yyx*mapDamageHigh( pos + e.yyx ) + \n\t\t\t\t\t  \t e.yxy*mapDamageHigh( pos + e.yxy ) + \n\t\t\t\t\t  \t e.xxx*mapDamageHigh( pos + e.xxx ) );\n    n = bumpMapNormal( pos, n );\n    return n;    \n}\n\n\/\/----------------------------------------------------------------------\n\/\/ lighting\n\nfloat calcAO( in vec3 pos, in vec3 nor ) {\n\tfloat occ = 0.0;\n    for( int i=0; i<6; i++ ) {\n        float h = 0.1 + 1.2*float(i);\n        occ += (h-map( pos + h*nor ));\n    }\n    return clamp( 1.0 - occ*0.025, 0.0, 1.0 );    \n}\n\nfloat calcFakeAOAndShadow( in vec3 pos ) { \n    float r = (1.-abs(pos.x)\/30.5);\n    \n    r *= max( min( .35-pos.z \/ 40., 1.), 0.65);\n    r *= .5+.5*smoothstep( -66., -.65, pos.z);\n    \n    if( pos.y < 25. ) r *= 1.-smoothstep( 18., 25., .5*pos.y+abs(pos.x) ) * (.6+pos.y\/25.);\n    r *= 1.-smoothstep(5., 8., abs(pos.x) ) * .75 * (smoothstep( 60.,63.,abs(pos.z)));\n    \n    return clamp(r, 0., 1.);\n}\n\n\/\/----------------------------------------------------------------------\n\/\/ materials\n\nfloat matMarble( in vec3 pos, in vec3 nor ) {\n    float i = tileId( pos, nor );\n    \n    return .072*(hash(i)+noise(pos*7.))+.12*noise(pos*25.);\n}\n\nfloat matSideLamp( in vec3 pos, in vec3 nor ) {\n    float l = (1.-smoothstep(0.05,0.15, abs( pos.y-13.75 ) ))\n        \t* (1.-smoothstep(1.5,1.7, abs( mod(pos.z, 3.6)-1.8 ) ));\n    return 5. * l;\n}\n\nfloat matOutdoorLight( in vec3 pos, in vec3 nor ) {\n    float l = ( smoothstep( 0.03, 0.1, abs( mod( pos.x, 1.8 ) \/ 1.8 - .5) ))\n\t\t\t* ( smoothstep( 0.03, 0.1, abs( mod( pos.y, 3.6 ) \/ 3.6 - .5) ));\n    return mix( 8.,12., l);\n}\n\nvec2 shade( in vec3 pos, in vec3 nor, in float m, in float t, in bool reflection ) {\n    float refl = 0.1;\n    float mate = 0.;\n \tfloat light = 0.;            \n    float col = 0.;\n    \n    if( m < .5 ) {\n   \t\tif( pos.y < .01 ) {\n\t    \tmate = .05 * (.25+.2*texture2D( iChannel1, pos.xz*.05 ).r);\n            float x = abs(pos.x);\n            if( (x > 12. && x < 14.8) ||  (x > 3.2 && x < 6.8) || abs(pos.z) > 68.4 ) mate *= 0.25;\n        } else if( pos.y > 13.5 && pos.y < 13.99 && abs( pos.x ) > 27.99 ) {\n            light = matSideLamp( pos, nor ); \n        } else if( pos.z > 62. && pos.y > 52. ) {\n            light = matOutdoorLight( pos, nor );\n        } else {\n \t\t\tmate = matMarble( pos, nor );\n            refl = 0.05;\n   \t\t}\n        if( abs(mapDamageHigh(pos)-map(pos)) > 0.0001 * t ) {\n            refl = 0.;\n            mate = 0.21;\n        }\n        if( abs( pos.z ) > 73.1 ) {\n            mate = 0.02;\n            if( mod( abs( pos.x ), 2.25 ) < .3 ||\n            \tmod( abs( pos.y ), 2.25 ) < .3 ) mate = 0.0025;\n            refl = 0.02;\n        }\n            \n        if( nor.y < -0.8 && pos.y > 13.49 ) {\n            col += mate * (0.4 * pow( max( (abs(pos.x*.38)-7.2),0.), 2.));\n        }        \n    } \n#if RENDERDEBRIS\n    else if( m < 1.5 ) {\n            refl = 0.;\n            mate = 0.1 * noise(pos);\n    }\n#endif\n    \n    col += mate * (\n        25. * ( 0.02 +\n        .2 * min(1., max( -nor.x * sign(pos.x), 0.)) + \n        .5 * min(1., max( nor.y, 0. )) +\n        .05 * abs( nor.z ) ) * calcFakeAOAndShadow( pos ) );\n    \n    col *= calcAO( pos, nor );\n    col += light;\n    \n    return vec2( col, refl );\n}\n\n\/\/----------------------------------------------------------------------\n\/\/ intersection code\n\nfloat intersect( in vec3 ro, in vec3 rd ) {\n\tconst float precis = 0.00125;\n    float h = precis*2.0;\n    float t = 0.1;\n        \n    float d = -(ro.y)\/rd.y;\n    float maxdist = d>0.?d:500.;\n    \n\tfor( int i=0; i < MARCHSTEPS; i++ ) {\n#if HIGHQUALITY\n        h = .9*mapDamage( ro+rd*t );\n#else\n        h = map( ro+rd*t );\n#endif\n        if( h < precis ) {\n            return t;\n        } \n        t += h+0.00005*t;\n        if( t > maxdist ) {\n            return maxdist;\n        }\n    }\n    return -1.;\n}\n\n\nfloat intersectReflection( in vec3 ro, in vec3 rd ) {\n\tconst float precis = 0.00125;\n    float h = precis*2.0;\n    float t = 0.;\n        \n    float d = -(ro.y)\/rd.y;\n    float maxdist = d>0.?d:500.;\n    \n\tfor( int i=0; i < MARCHSTEPSREFLECTION; i++ ) {\n        h = map( ro+rd*t );\n        if( h < precis ) {\n            return t;\n        } \n        t += h+0.01*t;\n        if( t > maxdist ) {\n            return maxdist;\n        }\n    }\n    return -1.;\n}\n\n\/\/----------------------------------------------------------------------\n\/\/ render functions\n\nfloat renderExplosionDebris( const in vec3 ro, const in vec3 rd, in float maxdist, const in vec4 ep, inout vec3 nor, \n                             const in float time ) {\n    float maxRadius = 30.*(time - ep.w - .025);\n    float minRadius = 0.2 * maxRadius;\n    if( maxRadius > 30. ) return maxdist;\n    \n    for( int i=0; i<DEBRISCOUNT; i++ ) {\n        float id = hash(  ep.w+float(i) );\n        vec3 dir = normalize( -1.+2.*vec3( id, hash(  ep.w+.5*float(i) ), hash(  ep.w+1.5*float(i) ) ) - vec3( 2.*sign(ep.x), 0., 0.) );\n        vec3 pos = ep.xyz + dir*mix( minRadius, maxRadius, id ) + vec3(0.,-maxRadius*sin( maxRadius*0.005 ),0.);\n        float d = iSphere( ro, rd, vec4( pos, 0.1*id+0.003 ) );\n        if( d > 0. && d < maxdist ) {\n            maxdist = d;\n            nor = nSphere( ro+rd*d, vec4( pos, 0.1*id+0.003 ) );\n        }\n    }\n    \n    return maxdist;\n}\n\nvoid renderExplosionDust( const in vec3 ro, const in vec3 rd, in float dist, const in vec4 ep, inout vec2 col, \n                          const in float time, const in vec3 grd ) {\n    float maxRadius = 10.*(time - ep.w + .25);\n    if( maxRadius > 40. ) return ;\n    \n    float dens = 0.;\n    float ho = hash( ep.w ); \/\/ id of explosion\n    float fade = pow( 2., -maxRadius*0.11-2.);\n    float zoom = 2.5\/maxRadius;\n    vec2 down = vec2(sin(maxRadius*0.005+.1), 0.);\n                     \n\t\/\/ intersect planes\n    vec2 d = -(ro.xz - ep.xz )\/rd.xz;\n    if( d.x > 0. ) {\n        vec3 pos = ro+d.x*rd;\n        float radius = distance( ep.yz, pos.yz );\n        if( radius < maxRadius  ) {\n            float l = max( 0.025*(dist-d.x) + .5, 0. ) \n                        \t\t\t* fade \n                      \t\t\t\t* abs( grd.x )\n                     \t\t\t\t* (1.-smoothstep( 0.8*maxRadius, maxRadius, radius ));            \n\t        float excol = mix( col.x, 1., pow( max(1.-2.*texture2D( iChannel2,ho+(pos.yz-ep.yz)*zoom + down, -100.0 ).x,0.),3.) );               \n    \t    col.x = mix( col.x, excol, l);\n            col.y += l;\n        }\n    }\n    \n    if( d.y > 0. ) {\n        vec3 pos = ro+d.y*rd;\n        float radius = distance( ep.yx, pos.yx );\n        if( radius < maxRadius  ) {\n            float l = max( 0.025*(dist-d.y) + .5, 0. ) \n                        \t\t\t* fade \n                      \t\t\t\t* abs( grd.z )\n                     \t\t\t\t* (1.-smoothstep( 0.8*maxRadius, maxRadius, radius ));\n\t        float excol = mix( col.x, 1., pow( max(1.-2.*texture2D( iChannel2,ho+(pos.yx-ep.yx)*zoom + down, -100.0 ).x,0.),3.) );   \n    \t    col.x = mix( col.x, excol, l);\n            col.y += l;\n        }\n    }\n}\n\nvec3 render( const in vec3 ro, const in vec3 rd, in float time, const in float fog, const in vec3 grd ) {\n    const float eps = 0.01;\n    vec2 col = vec2(0.);\n    \n    float t = intersect( ro, rd );\n    if( time > STT(98.) ) {\n        time = STT(95.5)+.4*(time-STT(95.5)); \/\/ slow motion\n    }\n    time += .03*hash( rd.x + rd.y*5341.1231 ); \/\/ motionblur\n    \n    if( t > 0. ) {\n        vec3 nor;\n        float m = 0.;\n\n#if RENDERDEBRIS\n        float d = renderExplosionDebris( ro, rd, t, ep1, nor, time );\n        d = renderExplosionDebris( ro, rd, d, ep3, nor, time );\n        d = renderExplosionDebris( ro, rd, d, ep5, nor, time );\n#if HIGHQUALITY \n        d = renderExplosionDebris( ro, rd, d, ep2, nor, time );\n        d = renderExplosionDebris( ro, rd, d, ep4, nor, time );\n#endif\n        if( d < t ) {\n            m = 1.;\n            t = d;\n        } \n#endif\n   \n        vec3 pos = ro + t*rd;\n        if( m < .5 ) {\n\t        nor = calcNormalDamage( pos, eps );\n        }\n        col = shade( pos, nor, m, t, false );\n\n#if REFLECTIONS        \n        vec3 rdReflect = reflect( rd, -nor );\n        float tReflect = intersectReflection( pos + eps*rdReflect, rdReflect );\n\n        if( tReflect >= 0. && col.y > 0. ) {\n            vec3 posReflect = pos + tReflect*rdReflect;\n            vec3 norReflect = calcNormalDamage( posReflect, eps );\n\n            col += shade( posReflect, norReflect, 0., tReflect, true ) * col.y;\n        }\n#endif\n    } else {\n        t = 60.;\n    }\n\n    col.y = 0.; \n    renderExplosionDust( ro, rd, t, ep1, col, time, grd );\n    renderExplosionDust( ro, rd, t, ep2, col, time, grd );\n    renderExplosionDust( ro, rd, t, ep3, col, time, grd );\n    renderExplosionDust( ro, rd, t, ep4, col, time, grd );\n    renderExplosionDust( ro, rd, t, ep5, col, time, grd );\n    \n \/\/ add fog\n    vec3 dcol = vec3( max(col.x,0.) );\n \tdcol = mix( vec3(.5), dcol, exp( -t*(.02*fog+.005*col.y) ) );\n        \n    return pow( dcol, vec3(0.45) );\n}\n\n\/\/----------------------------------------------------------------------\n\/\/ explosions\n\n#define E1(a,b,c,d) t+=a;if( time >= t ){ep1 = vec4(b,c,d,t);}\n#define E2(a,b,c,d) t+=a;if( time >= t ){ep2 = vec4(b,c,d,t);}\n#define E3(a,b,c,d) t+=a;if( time >= t ){ep3 = vec4(b,c,d,t);}\n#define E4(a,b,c,d) t+=a;if( time >= t ){ep4 = vec4(b,c,d,t);}\n#define E5(a,b,c,d) t+=a;if( time >= t ){ep5 = vec4(b,c,d,t);}\n\nvoid initExplosions( const in float time ) {\n\tep1 = ep2 = ep3 = ep4 = ep5 = vec4(-1000.);\n    \n    float t = 0.;    \n    E1(STT(21.), 16., 3.9, 8.2 );\n    E2(.7, 16., 5.4, 6.1 );\n    E3(.3, 16., 6.3, 7.7 );\n    E4(1., 16., 4.8, 8.2 );\n    E5(.7, 16., 5.7, 7.3 );\n    \n    t = 0.;\n    E1(STT(34.), -16., 3.9, 5.2 );\n    E2(.5, -16., 5.4, 5.1 );\n    E3(.7, -16., 6.3, 6.7 );\n    E4(.5, -16., 4.8, 7.2 );\n    E5(.4, -16., 5.7, 6.3 );\n        \n    t = 0.;\n    E1(STT(42.), -19.1, 3.9, -4.5 );\n    E2(1.3, -17.4, 5.4, -4.5 );\n    E3(.3, -18.2, 6.3, -4.5 );\n    E4(.4, -17.7, 4.8, -4.5 );\n    E5(.3, -16.7, 5.7, -4.5 );\n  \n    E3(.3, -18.2, 6.3, -4.5 );\n    E2(.2, -17.4, 5.4, -4.5 );\n    E3(.1, -18.2, 6.3, -4.5 );\n    E4(.2, -17.7, 4.8, -4.5 );\n    E5(.1, -16.7, 5.7, -4.5 );\n    \n    E1(.9, -16., 3.9, -5.2 );\n    E2(.5, -16., 5.4, -5.1 );\n    E3(.3, -16., 6.3, -6.7 );\n    E4(.5, -16., 4.8, -7.2 );\n    E5(.4, -16., 5.7, -6.3 );    \n    \n    t = 0.;    \n    E1(STT(58.), 16., 3.9, 2.2 );\n    E2(.2, 16., 5.4, 4.1 );\n    E3(.3, 24., 6.3, 3.7 );\n    E4(.5, 16., 4.8, 8.2 );\n    E5(.7, 24., 5.7, 4.3 );\n    E1(.1, 16., 1.9, 8.2 );\n    E2(.2, 24., 5.4, -2.1 );\n    \n    t = 0.;\n    E1(STT(66.), 16., 3.9, 6.5 );\n    E2(.2, 16., 5.4, 6.1 );\n    E5(.3, 16., 6.7, 7.3 );\n    E3(.3, 16., 6.3, 5.7 );\n    E4(.2, 16., 7.8, 6.2 );\n        \n    E5(.1, 16., 5.7, 4.7 );\n    E1(.2, 16., 3.9, -6.2 );\n    E2(.3, 17., 6.4, -4.5 );\n    E3(.3, 16., 6.3, -5.7 );\n    E4(.5, 16., 7.8, -6.2 );    \n    E5(.3, 16., 5.7, -7.7 );\n    E1(.2, 16., 3.9, -6.2 );\n    E2(.3, 16., 6.4, -4.5 );\n   \n    t = 0.;\n    E1(STT(78.), -17.1, 3.9, -4.5 );\n    E2(.3, -17.4, 5.4, -4.5 );\n    E3(.3, -18.2, 6.3, -4.5 );\n    E4(.4, -17.7, 4.8, -4.5 );\n    E5(.3, -16.7, 5.7, -4.5 );\n  \n    E3(1.3, -18.2, 6.3, -4.5 );\n    E2(.2, -17.4, 5.4, -4.5 );\n    E3(.1, -18.2, 6.3, -4.5 );\n    E4(.2, -17.7, 4.8, -4.5 );\n    E5(.1, -16.7, 5.7, -4.5 );\n    \n    E2(.5, -19.6, 5.4, -5.1 );\n    E1(.9, -19.6, 3.9, -5.2 );\n    E3(.3, -19.6, 6.3, -6.7 );\n    E4(.5, -19.6, 4.8, -7.2 );\n    E5(.4, -19.6, 5.7, -6.3 );\n}\n\n\/\/----------------------------------------------------------------------\n\/\/ camera\n\nmat3 setCamera( const in vec3 ro, const in vec3 rt, const in float cr, const in float fl ) {\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -fl*cw );\n}\n\n#define SCAM(a,j,h,i,f,g,b,c,d,e) if(time >= t ){damageMod=j;sro=b;ero=c;sta=d;eta=e;st=t;dt=a;sfog=h;efog=i;}t+=a;\n#define CCAM(a,j,h,i,f,g,b,c,d,e) if(time >= t ){sro=ero;ero=c;sta=eta;eta=e;st=t;dt=a;sfog=efog;efog=i;}t+=a;\n\nvoid getCamPath( const in float time, inout vec3 ro, inout vec3 ta, inout float fl, inout float fog ) {\n    vec3 sro, sta, ero, eta;\n    float st = 0., dt, t = 0., sfog, efog;\n    \n    SCAM(STT(12.), 0., 0.,    0., 1.5, 1.5, vec3( 0., 5., 22.5 ), vec3( 0., 5.,  18.5 ), vec3( 0., 5., 0. ), vec3( 0., 5., 0. ) ); \n    SCAM(STT(7.5), 0., 0.,    0., 1.5, 1.5, vec3( -14., 5.,  18.5 ), vec3( 18., 4., 11. ), vec3( 10., 5., -50. ), vec3( 0., 5., -50. ) ); \n    CCAM(STT(7.5), 0., 0.,  0.05, 1.5, 1.5, vec3( 18., 4., 11. ), vec3( 21.5, 4., 11.5 ),  vec3( 0., 5., -50. ), vec3( -4., 7., 0. ) ); \n    CCAM(STT(2.5), 0., 0.05, 0.1, 1.5, 1.5, vec3( 21.5, 4., 11.5 ), vec3( 21.5, 4., 11.5 ),  vec3( -4., 7., 0. ), vec3( -16., 7., 8. ) ); \n    CCAM(STT(4.), 0.,  0.1, 0.15, 1.5, 4.5, vec3( 21.5, 4., 11.5 ), vec3( 10., 4.25, 11.35 ),  vec3( -16., 7., 8. ), vec3( -16., 6., 8. ) ); \n    \n    SCAM(STT(7.5),  0., 0.1,  0.3, 1.5, 1.5, vec3( -11., 5.25, 7.05 ), vec3( -13., 5., 9. ),  vec3( -19., 5.2, 7. ), vec3( -16.5, 5., 5.3 ) );     \n    SCAM(STT(13.), .4, 0.1,  0.5, 1.5, 1.5, vec3( -18., 5., 4.05 ), vec3( -10., 5.25, -6. ),  vec3( -17., 5.5, 0. ), vec3( -15.5, 5.25, -7.3 ) );     \n\tCCAM(STT(4.), .45, 0.5,  0.65, 1.5, 1.2, vec3( -10., 5.25, -6. ), vec3( -12., 5.25, -9. ),  vec3( -15.5, 5.25, -7.3 ), vec3( -13.5, 6.25, 2.3 ) );     \n\n    SCAM(STT(7.5), .95, 0.4,  1.9, 1.5, 1.5, vec3( 18., 4., 11. ), vec3( 25.5, 4., 11.5 ),  vec3( 0., 5., -50. ), vec3( -4., 7., 0. ) ); \n\n    SCAM(STT(12.2), .95, 0.8,  1.3, 1.5, 1.5, vec3( 10., 4.7, 4. ), vec3( 10., 5., -7.5 ),  vec3( 50., 5., 2. ), vec3( 40., 5., -20. ) ); \n    \n    SCAM(STT(16.25), 1., 0.4,  0.8, 1.5, 1.5, vec3( -18., 4.5, 4.05 ), vec3( -26., 3.25, -6. ),  vec3( -17., 5.5, 0. ), vec3( -15.5, 6.25, -7.3 ) );     \n    CCAM(STT(4.),  1., 0.8,  0.6, 1.5, 1.5, vec3( -26., 3.25, -6. ), vec3( -26., 3.25, -6. ),  vec3( -15.5, 6.25, -7.3 ), vec3( -15.5, 6.25, -7.3 ) );     \n\n    SCAM(STT(16.), 1.1, 0.4, 0.05, 1.5, 1.5, vec3( 0., 5.,  18.5 ), vec3( 0., 5.,  18.5 ), vec3( 0., 5., 0. ), vec3( 0., 5., 0. ) ); \n  \n    dt = clamp( (time-st)\/dt, 0., 1. );\n\n    if(  time > STT(65.5) && time < STT(77.75)  ) {\n\t    ro = mix( sro, ero, dt);\n    \tta = mix( sta, eta, dt);\n    } else {\n\t    ro = mix( sro, ero, smoothstep(0.,1., dt));\n    \tta = mix( sta, eta, smoothstep(0.,1., dt));\n    }\n\t\n    fl = 1.5;    \n    if( time > STT(29.5) && time < STT(33.5) ) {\n        fl = mix( 1.5, 4.5, smoothstep( STT(29.5), STT(33.5), time ) );\n    }\n    \n   \tfog = mix( sfog, efog, dt);\n    damageMod = .4-.4*damageMod;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = mod(iGlobalTime, 60.);\n\n    vec2 q = fragCoord.xy\/iResolution.xy;\n\t    \n    \/\/ letterbox\n    if( abs(2.*fragCoord.y-iResolution.y) > iResolution.x * 0.42 ) {\n        fragColor = vec4( 0., 0., 0., 1. );\n        return;\n    }\n    vec3 ro, ta;\n    float fl, fog;\n      \n    getCamPath( time, ro, ta, fl, fog );\n        \n    initExplosions( time );\n    \n    mat3 ca = setCamera( ro, ta, 0.0, (1.\/1.5) );    \n    vec2 p = (-iResolution.xy+2.*(fragCoord.xy))\/iResolution.x;\n    vec3 rd = normalize( ca * vec3(p,-fl) );\n\n    vec3 col = render( ro, rd, time, fog, normalize( ta-ro ) );\n    \n    col *= vec3(0.704,0.778,0.704);    \n\tcol = col*0.8 + 0.2*col*col*(3.0-2.0*col);\n\tcol *= vec3(1.378,1.56,1.3);\n        \n    \/\/ vignette\n    col *= 0.15 + 0.85*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\n    \/\/ flicker\n    col *= 1.0 + 0.015*fract( 17.1*sin( 13.1*floor(12.0*iGlobalTime) ));\n    \n\t\/\/ fade in\n    col *= clamp( time*.7, 0., 1. );\n    col *= clamp( abs(time-STT(12.)), 0., 1. );\n    if( time < STT(33.5) ) col *= clamp( (STT(33.5)-time-.5), 0., 1. );\n    col *= clamp( abs(time-STT(98.)), 0., 1. );\n    \n    fragColor = vec4( col, 1.0 );\n}\n","name":"","description":"","type":"image"},{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Reinder Nijhoff 2015\n\/\/ @reindernijhoff\n\/\/\n\/\/ https:\/\/www.shadertoy.com\/view\/MtsXzf\n\/\/\n\n#define HIGHQUALITY 1\n\n#define N(a) if(t>b)x=b;b+=a;\n#define NF(a,c,g) if(t>b){x=b;f=c;v=g;d=a;}b+=a;\n\n\/\/----------------------------------------------------------------------------------------\n\n#define BPM             (140.0)\n#define STEP            (4.0 * BPM \/ 60.0)\n#define ISTEP           (1.\/STEP)\n#define LOOPCOUNT\t\t(16.)\n#define STT(t)\t\t\t(t*(60.0\/BPM))\n\n#define PI2 6.283185307179586476925286766559\n\n#define D 36.71\n#define A 55.00\t\n#define B 61.74\n#define C 65.41\n\n\/\/-----------------------------------------------------\n\/\/ noise functions\n\n#define MOD2 vec2(.16632,.17369)\nfloat hash(const in float p) { \/\/ by Dave Hoskins\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);\n}\n\nfloat sine(const in float x) {\n    return sin(PI2 * x);\n}\n\nfloat loop(const in float t, const in float steps) {\n    return mod(t, steps * ISTEP);\n}\n\nfloat distortion(const in float s, const in float d) {\n\treturn clamp(s * d, -1.0, 1.0);\n}\n\nfloat quan(const in float s, const in float c) {\n\treturn floor(s \/ c) * c;\n}\n\nbool inLoop( float time, float s, float e ) {\n    float t = (time * (STEP \/ LOOPCOUNT));\n    return ( t >= s && t < e );\n}\n\n\/\/-----------------------------------------------------\n\/\/ instruments by iq and And\n\nfloat snare(const in float t, const in float f0) {\n    float op3 = sine((t * f0) * 2.8020) * exp(-t * 1.0);\n    float op2 = sine((t * f0) * 2.5000 + op3 * 1.00);\n    float op1 = sine((t * f0) * 18.000 + op2 * 0.72);\n\n    return op1 * exp(-t * 5.5);\n}\n\nfloat kick(float tb) {\n\tconst float aa = 5.0;\n\ttb = sqrt(tb * aa) \/ aa;\n\t\n\tfloat amp = exp(max(tb - 0.015, 0.0) * -5.0);\n\tfloat v = sine(tb * 100.0) * amp;\n\tv += distortion(v, 4.0) * amp;\n\treturn v;\n}\n\nfloat bass(const in float time, const in float freq, const in float duration) {\n    float ph = 1.0;\n    ph *= sin(6.2831*freq*time);\n    ph *= 0.1+0.9*max(0.0,6.0-0.01*freq);\n    ph *= exp(-time*freq*0.3);\n    \n    \n    float y = 0.;\n    y += 0.70*sin(1.00*PI2*freq*time+ph);\/\/*exp(-0.07*time);\n    y += 0.90*sin(2.01*PI2*freq*time+ph);\/\/*exp(-0.11*time);\n\n    y += 0.145*y*y*y;   \n\n    y *= 1.-smoothstep( duration*0.9, duration, time * STEP );\n\n    return y;\n}\n\nfloat bell(const in float t, const in float f0) {\n    float op3 = sine((f0 * t) * 6.0000             ) * exp(-t * 5.0);\n    float op2 = sine((f0 * t) * 7.2364 + op3 * 0.20);\n    float op1 = sine((f0 * t) * 2.0000 + op2 * 0.13) * exp(-t * 2.0);\n\n    return op1;\n}\n\nfloat lift(float time) {\n    return sin(PI2*D*32.*time)*exp(-6.0*time) + bell(time, D*32.);\n}\n\nfloat gun(float time, float f, const in float d) {\n    return distortion( texture2D( iChannel0, vec2(time*5.7864, time*6.9732)*f, -99. ).x *exp(-10.0*time)\n                       * smoothstep(0.,0.1,time) * (1.-smoothstep(0.5,.6,time)), d);\n}\n\n\/\/-----------------------------------------------------\n\/\/ loops\n\nfloat loopBass(const in float t, const in float m) {\n    float x = 0., b = 0., f = 0., v = 0., d;\n                \n    NF(2.,D,0.9);NF(2.,D,1.);NF(1.,D,0.5);NF(1.,D,0.6);NF(1.,D,0.5);\n    NF(2.,A,1.05);NF(1.,D,0.5);NF(2.,B,0.9);NF(1.,D,0.5); NF(3.,C,1.);\n    f *= m;\n    \n    return v * bass( (t-x)*ISTEP, f, d );\n\n}\n    \nfloat loopBassIntro(const in float t) {\n    float x = 0., b = 0., f = 0., v = 0., d;\n    NF(4.,A,.5);NF(2.,D,.8);NF(8.,D,1.);NF(2.,D,.25);\n    \n    return v * bass( (t-x)*ISTEP, f*.5, d );\n}\n\nfloat loopDrums(const in float t) {\n    float x = 0., b = 0., r;\n    \n    \/\/ base\n    N(3.);N(7.);N(1.);N(5.);\n\tr = kick( (t-x)*ISTEP*1.2 );\n    \n    \/\/ bell\n    x = b = 0.;\n    N(4.);N(4.);N(4.);N(2.);N(2.);\n    r += .25 * bell( (t-x)*ISTEP*8., 100. );\n    \n    \/\/ hihat\n    x = b = 0.;\n    N(3.);N(3.);N(2.);N(2.);N(4.);\n    r += .35 * snare( (t-x)*ISTEP*2., 200.+t );\n    \n    \/\/ snare\n    x = b = 0.;\n    N(4.);N(3.);N(2.);N(3.);N(1.);N(3.);\n    r += .75 * snare( (t-x)*ISTEP*8., 10. );\n\n    return r;\n}\n\nfloat loopDrumsIntro(const in float t) {\n    float x = 0., b = 0.;\n    \n    \/\/ snare\n    N(1.);N(3.);N(3.);N(2.);N(1.);N(1.);N(1.);N(1.);N(1.);N(1.);N(1.);\n    return (t\/24.) * snare( (t-x)*ISTEP*8., 10. ) + kick(  (t)*ISTEP*1.2 );\n}\n\nfloat loopGun( const in float time, const in float interval, const in float numshots, \n               const in float shotdelay, const in float minf, const in float maxf ) {\n    float it = mod( time, interval );\n\n#if HIGHQUALITY\n    float m = 0.;\n    for( float sh = 0.; sh<2.5; sh+=1.) {\n        if( sh < numshots ) {\n            float g = (0.5+0.5*hash(sh+.5))*gun( it - sh*shotdelay - .5*shotdelay*hash(sh), mix(minf, maxf, hash(sh+.25)), 1.5 );\n    \t\tm = m+g - abs(m)*g;\n        }\n    }\n \n    return m;\n#else\n    float sh = floor( it\/shotdelay );\n    if( sh < numshots ) {\n        return (0.5+0.5*hash(sh+.5))*gun( it - sh*shotdelay - .5*shotdelay*hash(sh), mix(minf, maxf, hash(sh+.25)), 1.5 );\n    }\n    return 0.;\n#endif\n}\n\n\n\n\/\/-----------------------------------------------------\n\/\/ music\n\nfloat loopMusic(const in float time) {\n\tfloat mtime = loop( time, 16. );\n    float t = mtime * STEP;\n    float m = 1.;\n    \n    float d = 0.;\n    float b = 0.;\n    \n    if( inLoop( time, 2., 36. ) && !inLoop( time, 6., 8. ) && !inLoop( time, 15., 16. )  ) {\n        d = loopDrums( t );\n    }\n    \n    if( inLoop( time, 1., 2. ) || inLoop( time, 7., 8. ) || inLoop( time, 11., 12. ) ) {\n        d += loopDrumsIntro( t );\n    }\n    \n    if( inLoop( time, 10., 12. ) ) {\n        m = B\/D;\n    }\n\n    return loopBass( t, m ) + .5*d;\n}\n\nfloat loopIntro(const in float time) {\n\tfloat mtime = loop( time, 16. );\n    float t = mtime * STEP;\n    \n\tif( inLoop( time, .74, 5.25 ) ) {\n        return loopBassIntro( t );\n    }\n    return 0.;\n}\n    \nfloat loopBackground( const in float time ) {\n    float m = 0., g = 0.;\n    g = .5 * loopGun( time, 2., 3., .21, 1., 1.5 );\n    m = m+g - abs(m)*g;\n    \n    g = .95 * loopGun( time-4.123, 3., 1., 1.5, 1., 1.5 );\n    m = m+g - abs(m)*g;\n    \n    g = .7 * loopGun( time-3., 3.2, 2., .41, 1., 1.5 );\n    m = m+g - abs(m)*g;\n    \n    return m;\n}\n\nvoid initExplosions( in float time );\nfloat exTime1, exTime2;\n\n\/\/-----------------------------------------------------\n\/\/ main\n    \nvec2 mainSound(float time) {\n        \n    initExplosions(time);\n    \/\/ align with music\n    exTime1 = floor( exTime1 \/ ISTEP * 2.)*ISTEP*.5;\n    exTime2 = floor( exTime2 \/ ISTEP * 2.)*ISTEP*.5;\n    \n    float m = 0., music = 0., gun1 = 0., gun2 = 0., bg = 0.;\n    \n    if( time < STT(34.) ) {\n        music = loopIntro( time );\n    } else if( time < STT(98.) ){\n        music = loopMusic( time-STT(34.) );\n    }\n    music *= .25;\n    \n    gun1 = gun( time-exTime1, mix(1.,1.5,hash(exTime1)), 3. );\n    gun2 = gun( time-exTime2, mix(1.,1.5,hash(exTime2)), 3. );\n    \n    if( time > STT(34.) && time < STT(84.)  ) {\n        bg = loopBackground(time);\n    }\n    \n    m = m+bg - abs(m)*bg;\n    m = m+music - abs(m)*music;\n    \n    m = m+gun1 - abs(m)*gun1;\n    m = m+gun2 - abs(m)*gun2;\n    \n    m *= 1.5;\n    \n    if( time > 44.5 ) m += .0625*lift( time-44.5);\n    \n    return vec2( clamp(m, -1., 1.) );\n}\n\n\n\/\/----------------------------------------------------------------------\n\/\/ explosions\n\n#define E1(a,b,c,d) t+=a;if( time >= t ){exTime2=exTime1;exTime1=t;}\n#define E2(a,b,c,d) t+=a;if( time >= t ){exTime2=exTime1;exTime1=t;}\n#define E3(a,b,c,d) t+=a;if( time >= t ){exTime2=exTime1;exTime1=t;}\n#define E4(a,b,c,d) t+=a;if( time >= t ){exTime2=exTime1;exTime1=t;}\n#define E5(a,b,c,d) t+=a;if( time >= t ){exTime2=exTime1;exTime1=t;}\n\nvoid initExplosions( in float time ) {\n\texTime1 = exTime2 = -1000.;\n    \n    float t = 0.;    \n    E1(STT(21.), 16., 3.9, 8.2 );\n    E2(.7, 16., 5.4, 6.1 );\n    E3(.3, 16., 6.3, 7.7 );\n    E4(1., 16., 4.8, 8.2 );\n    E5(.7, 16., 5.7, 7.3 );\n    \n    t = 0.;\n    E1(STT(34.), -16., 3.9, 5.2 );\n    E2(.5, -16., 5.4, 5.1 );\n    E3(.7, -16., 6.3, 6.7 );\n    E4(.5, -16., 4.8, 7.2 );\n    E5(.4, -16., 5.7, 6.3 );\n        \n    t = 0.;\n    E1(STT(42.), -19.1, 3.9, -4.5 );\n    E2(1.3, -17.4, 5.4, -4.5 );\n    E3(.3, -18.2, 6.3, -4.5 );\n    E4(.4, -17.7, 4.8, -4.5 );\n    E5(.3, -16.7, 5.7, -4.5 );\n  \n    E3(.3, -18.2, 6.3, -4.5 );\n    E2(.2, -17.4, 5.4, -4.5 );\n    E3(.1, -18.2, 6.3, -4.5 );\n    E4(.2, -17.7, 4.8, -4.5 );\n    E5(.1, -16.7, 5.7, -4.5 );\n    \n    E1(.9, -16., 3.9, -5.2 );\n    E2(.5, -16., 5.4, -5.1 );\n    E3(.3, -16., 6.3, -6.7 );\n    E4(.5, -16., 4.8, -7.2 );\n    E5(.4, -16., 5.7, -6.3 );    \n    \n    t = 0.;    \n    E1(STT(58.), 16., 3.9, 2.2 );\n    E2(.2, 16., 5.4, 4.1 );\n    E3(.3, 24., 6.3, 3.7 );\n    E4(.5, 16., 4.8, 8.2 );\n    E5(.7, 24., 5.7, 4.3 );\n    E1(.1, 16., 1.9, 8.2 );\n    E2(.2, 24., 5.4, -2.1 );\n    \n    t = 0.;\n    E1(STT(66.), 16., 3.9, 6.5 );\n    E2(.2, 16., 5.4, 6.1 );\n    E5(.3, 16., 6.7, 7.3 );\n    E3(.3, 16., 6.3, 5.7 );\n    E4(.2, 16., 7.8, 6.2 );\n        \n    E5(.1, 16., 5.7, 4.7 );\n    E1(.2, 16., 3.9, -6.2 );\n    E2(.3, 17., 6.4, -4.5 );\n    E3(.3, 16., 6.3, -5.7 );\n    E4(.5, 16., 7.8, -6.2 );    \n    E5(.3, 16., 5.7, -7.7 );\n    E1(.2, 16., 3.9, -6.2 );\n    E2(.3, 16., 6.4, -4.5 );\n   \n    t = 0.;\n    E1(STT(78.), -17.1, 3.9, -4.5 );\n    E2(.3, -17.4, 5.4, -4.5 );\n    E3(.3, -18.2, 6.3, -4.5 );\n    E4(.4, -17.7, 4.8, -4.5 );\n    E5(.3, -16.7, 5.7, -4.5 );\n  \n    E3(1.3, -18.2, 6.3, -4.5 );\n    E2(.2, -17.4, 5.4, -4.5 );\n    E3(.1, -18.2, 6.3, -4.5 );\n    E4(.2, -17.7, 4.8, -4.5 );\n    E5(.1, -16.7, 5.7, -4.5 );\n    \n    E2(.5, -19.6, 5.4, -5.1 );\n    E1(.9, -19.6, 3.9, -5.2 );\n    E3(.3, -19.6, 6.3, -6.7 );\n    E4(.5, -19.6, 4.8, -7.2 );\n    E5(.4, -19.6, 5.7, -6.3 );\n}\n\n","name":"","description":"","type":"sound"}]}}