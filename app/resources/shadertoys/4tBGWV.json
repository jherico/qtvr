{"Shader":{"ver":"0.1","info":{"id":"4tBGWV","date":"1432318147","viewed":849,"name":"test loading screen","username":"skaven","description":"the loading screen for my pet project. click inside gl view for changing \"loading progress\" value.","likes":7,"published":3,"flags":0,"tags":["loadingscreencube"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Made with things shamelessly stolen from Iq, Hugo Campos, Zavie and GLTracy\n\/\/ ray marching\nconst int max_iterations = 255;\nconst float stop_threshold = 0.001;\nconst float grad_step = 0.001;\nconst float clip_far = 1000.0;\n\n\/\/ math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI \/ 180.0;\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\n\/\/ distance function\nfloat dist_sphere( vec3 pos, float r ) {\n\treturn length( pos ) - r;\n}\n\nfloat dist_roundbox( vec3 pos, vec3 size, float r )\n{\n  return length(max(abs(pos)-size,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nfloat dist_box( vec3 pos, vec3 size ) {\n\treturn dist_roundbox( pos, size, 0.2);\n    \/\/return sdTorus( pos, vec2(size.x, size.x * 0.5));\n}\n\nfloat Vignette(vec2 uv)\n{\n\tfloat OuterVig = 1.5;\n\t\n\tfloat InnerVig = 0.03;\n\t\n\tvec2 center = vec2(0.5,0.5);\n\tfloat dist  = distance(center,uv );\n\tfloat vig = clamp((OuterVig-dist) \/ (OuterVig-InnerVig),0.0,1.0);\n\t\n\treturn vig;\n}\n\nfloat boxSize;\n\nfloat dist_plan( vec3 pos, vec4 plan )\n{\n    return dot(pos, plan.xyz) + plan.w;\n}\nvec3 camd;\n\n\/\/ get distance in the world\nfloat dist_field( vec3 pos ) {\n\t\/\/ ...add objects here...\n\t\n\t\/\/ object 0 : sphere\n\t\/\/float d0 = dist_sphere( pos, 2.6 );\n\t\n\t\/\/ object 1 : cube\n\tfloat d1 = dist_box( pos, vec3( 2.0 ) * boxSize );\n\t\t\/*\n    float d2 = dist_plan( pos, vec4(-camd.xyz,0.0));\n    d2 += smoothstep(0.1,0.5,sin(d1*4.0-iGlobalTime*0.4));\n    \n    \n    float d2b = dist_plan( pos, vec4(-camd.xyz,0.0));\n    d2b += smoothstep(0.1,0.5,sin(d1*4.0-iGlobalTime*0.4))*0.9;\n    \n    \n    float dband = max(d2,d2b);\n\t\/\/ union     : min( d0,  d1 )\n\t\/\/ intersect : max( d0,  d1 )\n\t\/\/ subtract  : max( d1, -d0 )\n\treturn min(d1, d2);\n*\/\n    return d1;\/\/max(d1,-d0);\n}\n\n\/\/ phong shading\nvec3 shading( vec3 v, vec3 n, vec3 eye ) {\n\t\/\/ ...add lights here...\n\t\n\tfloat shininess = 8.0;\n\t\n\tvec3 final = vec3( 0.0 );\n\t\n\tvec3 ev = normalize( v - eye );\n\tvec3 ref_ev = reflect( ev, n );\n\t\n\t\/\/ light 0\n\t{\n\t\tvec3 light_pos   = vec3( 10.0, 10.0, 20.0 );\n\t\tvec3 light_color = vec3( 1.1, 1.1, 1.1 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * ( diffuse+specular ); \n\t}\n\t\n\t\/\/ light 1\n\t{\n\t\tvec3 light_pos   = vec3( -10.0, -10.0, 0.0 );\n\t\tvec3 light_color = vec3( 0.4, 0.4, 0.5 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * ( diffuse  ); \n\t}\n\/\/ light 2\n\t{\n\t\tvec3 light_pos   = vec3( 00.0, 0.0, -10.0 );\n\t\tvec3 light_color = vec3( 0.5, 0.4, 0.3 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * ( diffuse  ); \n\t}\n\treturn final;\n}\n\n\/\/ get gradient in the world\nvec3 gradient( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tdist_field( pos + dx ) - dist_field( pos - dx ),\n\t\t\tdist_field( pos + dy ) - dist_field( pos - dy ),\n\t\t\tdist_field( pos + dz ) - dist_field( pos - dz )\t\t\t\n\t\t)\n\t);\n}\n\n\/\/ ray marching\nfloat ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\tfloat depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n\t\tfloat dist = dist_field( origin + dir * depth );\n\t\tif ( dist < stop_threshold ) {\n\t\t\treturn depth;\n\t\t}\n\t\tdepth += dist;\n\t\tif ( depth >= end) {\n\t\t\treturn end;\n\t\t}\n\t}\n\treturn end;\n}\n\n\/\/ get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n\/\/ camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nfloat hash( vec2 p )\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\n\t\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\n\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02; p.y += 0.02*iGlobalTime;\n    f += 0.2500*noise( p ); p = m*p*2.03; p.y -= 0.02*iGlobalTime;\n    f += 0.1250*noise( p ); p = m*p*2.01; p.y += 0.02*iGlobalTime;\n    f += 0.0625*noise( p );\n    return f\/0.9375;\n}\n\nvec2 fbm2( vec2 p )\n{\n    return vec2( fbm(p.xy), fbm(p.yx) );\n}\nvec3 fbm3( vec3 p )\n{\n    return vec3( fbm(p.xy), fbm(p.yx), fbm(p.yz) );\n}\n\nfloat easeOut (float t, float b, float c, float d)\n{\n  float s = 1.70158;\n  float p = 0.0;\n  float a = c;\n\n\tif (t == 0.0) return b;\n\tif ((t \/= d) == 1.0) return b + c;\n\tif (p == 0.0) p = d * 0.3;\n\tif (a < abs(c))\n\t{\n\t\ta = c;\n\t\ts = p \/ 4.0;\n\t}\n\telse s = p \/ (2.0 * PI) * asin (c \/ a);\n\treturn a * pow(2.0, -10.0 * t) * sin((t * d - s) * (2.0 * PI) \/ p ) + c + b;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float progress = min(iMouse.x\/iResolution.x + 0.25, 1.0);\n\t\n\t\n\t\/\/ default ray origin\n    float distanceToCube = 20.0;\n\tvec3 eye = vec3( 7.0, -4.0, distanceToCube );\n\n\t\/\/ rotate camera\n\tmat3 rot = rotationXY( vec2( -0.6, iGlobalTime ) );\n\t\n\teye = rot * eye;\n    \n\tfloat locTime = iGlobalTime * (1.0+progress*0.5); \n\t\/\/ ray marching\n    boxSize = easeOut(mod(locTime,1.0), 0.3,0.41,1.0)*0.6+0.4;\n    \n    float o1 = 0.25;\n    float o2 = 0.75;\n    vec2 msaa[4];\n    msaa[0] = vec2( o1,  o2);\n    msaa[1] = vec2( o2, -o1);\n    msaa[2] = vec2(-o1, -o2);\n    msaa[3] = vec2(-o2,  o1);\n    \n    vec4 resColor = vec4(0.0);\n    \n    for (int i = 0;i<1;i++)\n    {\n        vec3 offset = vec3(msaa[i] \/ iResolution.y, 0.);\n\t\tvec3 dir = rot * ray_dir( 45.0, iResolution.xy, fragCoord.xy ) + offset;\n        camd = dir;\n        \n        float depth = ray_marching( eye + offset, dir, 0.0, clip_far );\n\n        if ( depth >= clip_far ) \n        {\n            \/\/float distToPlan = dot(eye,-camd.xyz);\n            vec3 pos = eye + distanceToCube * camd;\n\n            float dist2box = dist_box( pos, vec3( boxSize*0.66+0.33 )  );\n            vec2 fbmv = fbm2((pos.xy + pos.yz) * 0.02) * pow(dist2box,0.8);\n            float d1 = dist2box + fbmv.x; \n            float d1b = sin(dist2box) + fbmv.y*0.1;\n            \/\/float d2 = dist_plan( pos, vec4(-camd.xyz,0.0));\n            float thres = smoothstep(0.45,0.55,sin(d1*2.0-locTime*2.0*PI + 2.0))*0.4;\n            float thresb = smoothstep(0.45,0.55,sin(d1b*2.0-locTime*2.0*PI + 2.0))*0.03;\n            float wave = 0.6 * (thres - thresb) * max( 1.0 - (dist2box\/ 10.0)+(progress*2.5-1.0), 0.0);\n            resColor += vec4(wave  + 0.6);\n            \/\/return;\n        }\n\t\telse\n        {\n            \/\/ shading\n            vec3 pos = eye + dir * depth;\n            vec3 n = gradient( pos );\n            float attn = 1.0;\/\/smoothstep(0.3,0.32, abs(sin(length(pos\/boxSize)*2.0 - iGlobalTime*4.0))) * 0.1 + 0.9;\n\n            resColor += vec4( max(shading( pos, normalize(rot * -n), rot * eye ),0.2) * attn, 1.0 );\n        }\n    }\n    vec2 tc = fragCoord.xy \/ iResolution.xy;\n\tfragColor = resColor * vec4(Vignette(tc + fbm2(tc*500.0)*0.02)); \/\/ remove vignette banding with some noise\n}\n","name":"","description":"","type":"image"}]}}