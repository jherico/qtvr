{"Shader":{"ver":"0.1","info":{"id":"Xsd3Rs","date":"1451797870","viewed":293,"name":"Everyday003 - IceCube","username":"Makio64","description":"Everyday003 - IceCube<br\/><br\/>Test SSS Technic & HG_SDF ","likes":14,"published":3,"flags":0,"tags":["noise","sss","ice","hgsdf"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Everyday003 - IceCube\n\/\/ By David Ronai \/ @Makio64\n\n\/\/ Thanks to XT95 to implement SSS in this shadertoy:\n\/\/ https:\/\/www.shadertoy.com\/view\/MsdGz2\n\/\/ Base on this papper :\n\/\/ http:\/\/colinbarrebrisebois.com\/2011\/03\/07\/gdc-2011-approximating-translucency-for-a-fast\n\n\/\/------------------------------------------------------------------ VISUAL QUALITY\n#define POSTPROCESS\n#define RAYMARCHING_STEP 35\n#define RAYMARCHING_JUMP 1.\n\/\/------------------------------------------------------------------ DEBUG\n\/\/#define RENDER_DEPTH\n\/\/#define RENDER_NORMAL\n\/\/#define RENDER_AO\n\nconst float PI = 3.14159265359;\nfloat snoise(vec3 v);\n\n\/\/------------------------------------------------------------------  SIGNED PRIMITIVES\nfloat vmax(vec3 v) {return max(max(v.x, v.y), v.z);}\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.\/repetitions*PI;\n\tfloat a = atan(p.y, p.x) + angle\/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a\/angle);\n\ta = mod(a,angle) - angle\/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\tif (abs(c) >= (repetitions\/2.)) c = abs(c);\n\treturn c;\n}\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\n\/\/------------------------------------------------------------------ MAP\nfloat map( in vec3 pos ) {\n\tfloat d = pos.y;\n    pos -= snoise(pos*0.15);\n    vec3 q = pos-vec3(0.,5.,0.);\n    pModPolar(q.xz, 6.);\n    q -= vec3(30,0,0);\n\td = fOpUnionRound(d, fBox(q,vec3(5.)),4.4);\n    q = pos;\n    pModPolar(q.xz,8.);\n\td = fOpUnionRound(d, fBox(q,vec3(6.,20.,6.)),6.);\n\treturn d;\n}\n\n\/\/------------------------------------------------------------------ RAYMARCHING\n\n#ifdef RENDER_DEPTH\nfloat castRay( in vec3 ro, in vec3 rd, inout float depth )\n#else\nfloat castRay( in vec3 ro, in vec3 rd )\n#endif\n{\n\tfloat t = 0.0;\n\tfloat res;\n\tfor( int i=0; i<RAYMARCHING_STEP; i++ )\n\t{\n\t\tvec3 pos = ro+rd*t;\n\t\tres = map( pos );\n\t\tif( res < 0.01 || t > 100. ) break;\n\t\tt += res*RAYMARCHING_JUMP;\n\t\t#ifdef RENDER_DEPTH\n\t\tdepth += 1.\/float(RAYMARCHING_STEP);\n\t\t#endif\n\t}\n\treturn t;\n}\n\nvec3 calcNormal(vec3 p) {\n\tfloat eps = 0.01;\n\tconst vec3 v1 = vec3( 1.0,-1.0,-1.0);\n\tconst vec3 v2 = vec3(-1.0,-1.0, 1.0);\n\tconst vec3 v3 = vec3(-1.0, 1.0,-1.0);\n\tconst vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\treturn normalize( v1 * map( p + v1*eps ) +\n\t\t\t\t\t  v2 * map( p + v2*eps ) +\n\t\t\t\t\t  v3 * map( p + v3*eps ) +\n\t\t\t\t\t  v4 * map( p + v4*eps ) );\n}\n\n\nfloat hash( float n ){\n\treturn fract(sin(n)*3538.5453);\n}\n\nfloat calcAO( in vec3 p, in vec3 n, float maxDist, float falloff ){\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = n*l;\n\t\tao += (l - map( p + rd )) \/ pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao\/float(nbIte), 0., 1.);\n}\n\n\/\/ calculate local thickness\n\/\/ base on AO but : inverse the normale(line117) & inverse the color(line 118)\nfloat thickness( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = -n*l;\n\t\tao += (l + map( p + rd )) \/ pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao\/float(nbIte), 0., 1.);\n}\n\n\/\/------------------------------------------------------------------ POSTEFFECTS\n\n#ifdef POSTPROCESS\nvec3 postEffects( in vec3 col, in vec2 uv, in float time )\n{\n\t\/\/ gamma correction\n\t\/\/ col = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\t\/\/ vigneting\n\tcol *= 0.7+0.3*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.15 );\n\treturn col;\n}\n#endif\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv )\n{\n\tvec3 col = vec3(.0,.0,1.2);\n\n\t#ifdef RENDER_DEPTH\n\tfloat depth = 0.;\n\tfloat t = castRay(ro,rd,depth);\n\t#else\n\tfloat t = castRay(ro,rd);\n\t#endif\n\n\t#ifdef RENDER_DEPTH\n\treturn vec3(depth\/10.,depth\/5.,depth);\n\t#endif\n\n\tvec3 pos = ro + t * rd;\n\tvec3 nor = calcNormal(pos);\n\n\t#ifdef RENDER_NORMAL\n\treturn nor;\n\t#endif\n\n\tfloat ao = calcAO(pos,nor,10.,1.2);\n\t#ifdef RENDER_AO\n\treturn vec3(ao);\n\t#endif\n\n    float thi = thickness(pos, nor, 6., 1.5);\n\n    vec3 lpos1 = vec3(0.0,15.+sin(iGlobalTime)*5.,0.0);\n\tvec3 ldir1 = normalize(lpos1-pos);\n\tfloat latt1 = pow( length(lpos1-pos)*.1, 1.5 );\n    float trans1 =  pow( clamp( dot(-rd, -ldir1+nor), 0., 1.), 1.) + 1.;\n\tvec3 diff1 = vec3(.0,.5,1.) * (max(dot(nor,ldir1),0.) ) \/ latt1;\n\tcol =  diff1;\n\tcol += vec3(.3,.2,.05) * (trans1\/latt1)*thi;\n\n    for(int i = 0; i<6; i++){\n        float angle = float(i)\/6.*PI*2.;\n        float radius = 30.;\n        vec3 lpos1 = vec3(cos(angle)*radius,5.,sin(angle)*radius);\n\t\tvec3 ldir1 = normalize(lpos1-pos);\n\t\tfloat latt1 = pow( length(lpos1-pos)*(.3+abs(sin(iGlobalTime)*2.)), 1. );\n    \tfloat trans1 =  pow( clamp( dot(-rd, -ldir1+nor), 0., 1.), 1.) + 1.;\n\t\tcol += vec3(.2,.2,.4) * (trans1\/latt1)*thi;\n\t}\n    \n\tcol = max(vec3(.05),col);\n\tcol *= ao;\n\treturn col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\treturn mat3( cu, cv, cw );\n}\n\nvec3 orbit(float phi, float theta, float radius)\n{\n\treturn vec3(\n\t\tradius * sin( phi ) * cos( theta ),\n\t\tradius * cos( phi ),\n\t\tradius * sin( phi ) * sin( theta )\n\t);\n}\n\n\/\/------------------------------------------------------------------ MAIN\nvoid mainImage( out vec4 fragColor, in vec2 coords )\n{\n\tfloat time = iGlobalTime;\n\tvec2 uv = coords.xy \/ iResolution.xy;\n\tvec2 mouse = iMouse.xy \/ iResolution.xy;\n\tvec2 q = coords.xy\/iResolution.xy;\n\tvec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x\/iResolution.y;\n\n\t\/\/Camera\n\tfloat radius = 50.;\n\tvec3 ro = orbit(PI\/2.-.5,PI\/2.+time,radius);\n\tvec3 ta  = vec3(0.0, 0., 0.0);\n\tmat3 ca = setCamera( ro, ta, 0. );\n\tvec3 rd = ca * normalize( vec3(p.xy,1.6) );\n\n\t\/\/ Raymarching\n\tvec3 color = render( ro, rd, uv );\n\t#ifdef POSTPROCESS\n\tcolor = postEffects( color, uv, time );\n\t#endif\n\tfragColor = vec4(color,1.0);\n}\n\n\/\/------------------------------------------------------------------ NOISE\n\/\/AshimaOptim https:\/\/www.shadertoy.com\/view\/Xd3GRf\nvec4 permute(vec4 x){return mod(x*x*34.0+x,289.);}\nfloat snoise(vec3 v){\n  const vec2  C = vec2(0.166666667, 0.33333333333) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 = v - i + dot(i, C.xxx) ;\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n  i = mod(i,289.);\n  vec4 p = permute( permute( permute(\n\t  i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n\t+ i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n\t+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n  vec3 ns = 0.142857142857 * D.wyz - D.xzx;\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n  vec4 x_ = floor(j * ns.z);\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = floor(j - 7.0 * x_ ) *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n  vec4 norm = inversesqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m * m;\n  return .5 + 12.0 * dot( m, vec4( dot(p0,x0), dot(p1,x1),dot(p2,x2), dot(p3,x3) ) );\n}","name":"","description":"","type":"image"}]}}