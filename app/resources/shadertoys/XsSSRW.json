{
	"Shader": 
	[
		{
			"ver": "0.1",
			"info": 
			{
				"id": "XsSSRW",
				"date": "1409422111",
				"viewed": 3408,
				"name": "Abandoned base",
				"username": "reinder",
				"description": "My entry to the in-official, nonexistent st mine compo <img src=\"\/img\/emoticonHappy.png\"\/> If you like shiny things, define 'GOLD' at line 3. Use your mouse to look around.",
				"likes": 49,
				"published": 3,
				"tags": 
				[
					"raymarching",
					"distancefield",
					"water",
					"reflections"
				],

				"hasliked": 0
			},

			"renderpass": 
			[
				{
					"inputs": 
					[
						{
							"id": 3,
							"src": "\/presets\/tex02.jpg",
							"ctype": "texture",
							"channel": 0
						}
					],

					"outputs": 
					[
						{
							"channel": "0",
							"dst": "-1"
						}
					],

					"code": "#pragma vr\n// Created by Reinder Nijhoff 2014\n\n// #define GOLD\n#define BUMPMAP\n#define MARCHSTEPS 128\n#define MARCHSTEPSREFLECTION 64\n#define SPHERE\n\n//----------------------------------------------------------------------\nconst vec2 dropPosition = vec2(1.05,2.1);\nconst vec3 backgroundColor = vec3(0.9,0.5,0.2);\nfloat time = iGlobalTime;\nfloat stime2 = sin(time*2.), ctime2 = cos(time*2.);\n\n//----------------------------------------------------------------------\n// noises\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*157.0;\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nfloat fbm( vec2 p ) {\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m2*p*2.02;\n    f += 0.2500*noise( p ); p = m2*p*2.03;\n    f += 0.1250*noise( p ); p = m2*p*2.01;\n    f += 0.0625*noise( p );\n    \n    return f/0.9375;\n}\n\nmat2 rot(const in float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));  \n}\n\n//----------------------------------------------------------------------\n// distance primitives\n\nfloat sdBox( in vec3 p, in vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere( in vec3 p, in float s ) {\n    return length(p)-s;\n}\n\nfloat sdCylinder( in vec3 p, in vec2 h ) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPipe( in vec3 p, in vec3 h ) {\n    return length(h.xy-p.xy) - h.z;\n}\n\nfloat sdPPipe( in vec3 p, in vec3 h ) {\n    return length(h.xy-p.xy) - h.z - 0.02*(max(sin(p.z*20.)-0.8,0.));\n}\n\n//----------------------------------------------------------------------\n// distance operators\n\nfloat opU( float d2, float d1 ) { return min( d1,d2); }\nfloat opS( float d2, float d1 ) { return max(-d1,d2); }\nvec2  opU( vec2  d2, vec2  d1 ) { return mix(d1,d2,step(d2.x,d1.x)); }//( d2.x<d1.x)? d2:d1; }\nvec2  opS( vec2  d2, vec2  d1 ) { return mix(-d1,d2,step(-d1.x,d2.x)); }//(-d1.x>d2.x)?-d1:d2; }\n\n//----------------------------------------------------------------------\n// Map functions\n\n#ifdef SPHERE\nvec3 sP;\n#endif\n\nfloat xoffset( float z) { \n    return 2.1*sin(z*0.1);\n}\n\nvec2 getSectorId( float z ) {\n    float id = floor( (z+6.)/12.);\n    return vec2( id, hash(id) );\n}\n\nfloat map( vec3 p ) {\n    float zorig = p.z;\n    p = vec3( p.x+xoffset(p.z), p.y-2., mod( p.z + 6., 12. ) - 6.);\n    \n    float x = p.x*2., y = p.y-0.8, z = p.z;\n    float d =  -sdBox( vec3((x+y)*0.7071, (y-x)*0.7071, z), vec3(3.8,3.8,20.) );\n\n    d = opS( d, sdBox( p, vec3( 2.5, 2., 5.75 ) )  ); \n    d = opU( d, sdPPipe( vec3(abs(p.x),p.y,p.z), vec3( 2.2, -1.7, 0.25 ) ) );\n    d = opU( d, sdPipe( vec3(p.x,abs(p.y-0.2),p.z), vec3( 2.4, 1.5, 0.1 ) ) ); \n    d = opU( d, sdPipe( vec3(p.x,p.y+0.6*cos(p.z*3.1415926/12.),p.z), vec3( -2.4, 1.8, 0.12 ) ) );\n    \n    d = opU( d, 2.2-p.y );\n    float l = distance( p.xz, dropPosition );\n    p.y += 0.003*sin(40.*l-6.*time)*exp(-4.*l);\n    \n    d = opU( d, p.y+2.03 );  \n    d = opU( d,  sdSphere( vec3( p.x, p.y-2.3, p.z*0.3), 0.2) );\n    \n    if( getSectorId(zorig).y > 0.75 ) {\n        d = opS( d,  sdCylinder( vec3(p.x, p.y-9., p.z), vec2(1.5,10.) ) );\n\n        vec3 pr = vec3( stime2*p.x+ctime2*p.z, p.y-2.4, stime2*p.z-ctime2*p.x);\n        d = opU( d, sdBox( pr, vec3(3.0,0.1,0.1) ) );\n        d = opU( d, sdBox( pr, vec3(0.1,0.1,3.0) ) );\n    } \n#ifdef SPHERE\n    d = opU( d,  sdSphere( vec3( p.x, p.y, zorig)-sP, 0.2) );\n#endif    \n    return d;\n}\n\nfloat mapMaterial( vec3 p ) {\n    float zorig = p.z;\n    p = vec3( p.x+xoffset(p.z), p.y-2., mod( p.z + 6., 12. ) - 6.);\n    \n    float x = p.x*2., y = p.y-0.8, z = p.z;\n    vec2 d = vec2( -sdBox( vec3((x+y)*0.7071, (y-x)*0.7071, z), vec3(3.8,3.8,20.) ), 5.);\n\n    d = opS( d, vec2( sdBox( p, vec3( 2.5, 2., 5.75 ) ), 3. ) );\n    d = opU( d, vec2( sdPPipe( vec3(abs(p.x),p.y,p.z), vec3( 2.2, -1.7, 0.25 ) ), 1. ) );    \n    d = opU( d, vec2( sdPipe( vec3(p.x,abs(p.y-0.2),p.z), vec3( 2.4, 1.5, 0.1 ) ), 4. ) );\n    d = opU( d, vec2( sdPipe( vec3(p.x,p.y+0.6*cos(p.z*3.1415926/12.),p.z), vec3( -2.4, 1.8, 0.12 ) ), 4. ) );\n    \n\n    d = opU( d, vec2( 2.2-p.y, 5. ) );\n    d = opU( d, vec2( p.y+2.03, 2. ) );  \n    d = opU( d, vec2( sdSphere( vec3( p.x, p.y-2.3, p.z*0.3), 0.2), 6.) );\n    \n    if( getSectorId(zorig).y > 0.75 ) {\n        d = opS( d, vec2( sdCylinder( vec3(p.x, p.y-4., p.z), vec2(1.5,2.) ), 5.) );\n\n        vec3 pr = vec3( stime2*p.x+ctime2*p.z, p.y-2.4, stime2*p.z-ctime2*p.x);\n        d = opU( d, vec2( sdBox( pr, vec3(3.0,0.1,0.1) ), 4.) );\n        d = opU( d, vec2( sdBox( pr, vec3(0.1,0.1,3.0) ), 4.) );\n    } \n    \n#ifdef SPHERE\n    d = opU( d,  vec2( sdSphere( vec3( p.x, p.y, zorig)-sP, 0.2), 7.) );\n#endif\n    \n    return abs(d.y);\n}\n\n//----------------------------------------------------------------------\n\nvec3 calcNormal( in vec3 pos ) {\n    const vec2 e = vec2(1.0,-1.0)*0.005;\n\n    vec3 n = normalize( e.xyy*map( pos + e.xyy ) + \n                        e.yyx*map( pos + e.yyx )   + \n                        e.yxy*map( pos + e.yxy )   + \n                        e.xxx*map( pos + e.xxx )   );  \n    \n#ifdef BUMPMAP\n    vec3 p = pos * 20.;\n    if( abs(pos.x+xoffset(pos.z))>2.48 )n = normalize( n + 0.1*vec3(0.,fbm(p.yz)-0.5,fbm(p.zy)-0.5));\n#endif\n    \n    return n;\n}\n\nvec3 int1, int2;\n\nfloat intersect( in vec3 ro, in vec3 rd ) {\n    const float maxd = 60.0;\n    const float precis = 0.001;\n    float h = precis*2.0;\n    float t = 0.;\n    float refl = -1.;\n    \n    for( int i=0; i < MARCHSTEPS; i++ ) {\n        if( h < precis ) {\n            int1 = ro+rd*t;\n            refl = 1.; \n            break;\n        } \n        h = map( ro+rd*t );\n        t += h;\n    }\n    if( refl < 0. ) return -1.;\n\n    ro = ro + rd*t;\n    vec3 nor = calcNormal(ro);           \n    rd = reflect( rd, nor );\n    ro += 0.1 * nor;\n    t = 0.0;\n    h = precis*2.0;\n    \n    for( int i=0; i < MARCHSTEPSREFLECTION; i++ ) {\n        if( h < precis ) {\n            int2 = ro+rd*t;\n            return 1.;\n        }   \n        h = map( ro+rd*t );\n        t += h;\n    }\n\n    return 0.;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k ) {\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ ) {\n        if( t>maxt ) break;\n        float h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += 0.03 + h;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nfloat calcOcc( in vec3 pos, in vec3 nor ) {\n    float totao = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.02 + float(i)/4.0;\n        float d = map( pos + h*nor );\n        totao += clamp(h-d,0.0,1.0)*sca;\n        sca *= 0.4;\n    }\n    return clamp( 1.0 - 2.0*totao, 0.0, 1.0 );\n}\n\n\n//----------------------------------------------------------------------\n// shade\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n    vec4 x = texture2D( sam, p.yz );\n    vec4 y = texture2D( sam, p.zx );\n    vec4 z = texture2D( sam, p.xy );\n    return x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\nfloat calcLightning( in vec3 pos, in vec3 light, in vec3 nor, in float maxDist, in bool shadow ) {\n    float sh = 1.;\n    vec3 lig = ( light-pos );\n    float im = length( lig );\n    lig /= im;\n    if(shadow) sh = softshadow( pos, lig, 1.02, im, 32.0  );\n    sh /= im;\n    sh *= clamp(dot(nor,lig),0.,1.);\n    return sh * (1.-smoothstep(0.,maxDist,im));\n}\n\nvec3 shade( in vec3 ro, in vec3 pos, in bool shadow, in float m, in float r ) {\n    vec3 light, col = vec3(0.);\n    vec3 nor = calcNormal(pos);\n    \n    vec2 id = getSectorId(pos.z);\n\n    float occ = calcOcc( pos, nor );\n    float dist, sh = 1., xo = xoffset(pos.z);\n\n    float rc = hash(id.x+43.);\n    float gc = hash(id.x+153.);\n    vec3 lc = normalize(vec3( max(rc,gc), min(rc,gc), 0.1 ) );\n    \n    if( id.y > 0.75 ) {\n        light = vec3( -xo, 6.5, id*12. );\n        light.xz += vec2( hash(id.x+56423.), hash(id.x+124.) ) - 0.5;\n        sh =  8.;\n        dist = 8.;\n    } else {\n        light = vec3( -xo, 3.9, id*12. );\n        sh = 3.;\n        dist = 5.3;\n        if( hash(id.x+234.) < 0.15 ) lc *= 1.-clamp( 10.*(fbm( vec2(time*10., id.x) )-2.5*id.y), 0., 1.);\n        if( pos.y > 4. ) sh*=0.5;\n    }\n    \n    sh *=  calcLightning( pos, light, nor, dist, shadow );\n    \n       \n    if( m < 6.5 ) col = texcube( iChannel0, pos*0.5, nor ).xyz;\n    if( m == 1. ) col *= 0.05;\n    if( m == 4. && pos.y > 2. ) col *= vec3(0.1,0.,0.);\n    if( m == 4. && pos.y < 2. ) col *= vec3(0.1,0.4,1.2);\n    \n    if( m == 5. ) col *= (1.+0.5*fbm(pos.yz*2.))*vec3(0.2,0.1,0.05);\n    if( m == 2. ) col *= vec3(0.8,0.6,0.4);\n    \n    col *= lc * occ * sh;  \n    \n    if( m == 6. ) col = mix( 0.1*col, col*fbm(pos.xz*10.) + 0.8*lc, \n                           (1.-smoothstep( 4.15, 4.2,pos.y)) *\n                           smoothstep( 0.01, 0.04,abs(mod(pos.z+0.15,0.3)-0.15)) *\n                           smoothstep( 0.01, 0.02,abs(pos.x+xo)));\n\n    col *= clamp(1.-2.*r, 0.65, 1.);\n    \n    col = mix(  0.05*backgroundColor, col, exp( -0.04*distance(pos, ro) ) );\n  \n\n    return col;\n}\n\n//----------------------------------------------------------------------\n// main\n\nvoid main( void ) {    \n    vec2 q = gl_FragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x / iResolution.y;\n        \n//    if (q.y < .12 || q.y >= .88) {\n//        gl_FragColor=vec4(vec4(0.0));\n//        return;\n//    }\n    \n    // camera\n    float o = 0.2*noise(vec2(time,0.));\n    float z = 2.*time+o;\n    float x = -0.95*xoffset(z);\n    vec3 ro = vec3(x,1.7+0.02*sin(time*1.13*2.*3.1415926+o), z-1.);\n    vec3 ta = vec3(x,1.7, z+5.);\n    \n#ifdef SPHERE\n    sP = vec3(sin(time), 1.6*cos(time*0.4), ro.z+9.+6.*sin(time*0.15) );\n//    ta = mix(ta,sP+vec3(0.,2.,0.),0.2);\n#endif\n    \n    if (iMouse.z>=1.) {\n        ta.yz *= rot( -(0.5-iMouse.y/iResolution.y)*0.15 );\n        ta.xz *= rot( -(0.5-iMouse.x/iResolution.x)*0.5 );\n    }\n    \n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    // vec3 rd = normalize( -p.x*uu + p.y*vv + 2.2*ww );\n    vec3 rd = normalize( iDir );\n    rd.z *= -1.0;\n    \n    vec3 col = 0.035*backgroundColor;\n\n    // raymarch\n    float ints = intersect(ro ,rd );\n    if(  ints > -0.5 ) {\n        float m = mapMaterial(int1);        \n   \n#ifdef GOLD\n        float r = .8;\n#else        \n        float xo = xoffset(int1.z);\n        vec3 p = vec3( int1.x+xo, int1.y-2., mod( int1.z + 6., 12. ) - 6.);\n        float l = m == 2.?exp(-2.*distance( p.xz, dropPosition )):0.;\n        \n        float r = 0.6 * clamp(2.*(fbm( int1.xz )-0.6+l), 0.0125, 1.)*clamp(2.-int1.y, 0., 1.);\n        if(m == 1.) r = 0.05+0.3 * fbm( int1.xz * 20. );\n         if(m == 7.) r = .8;       \n        \n        if(abs(int1.x+xo) > 2.49) {\n            r = fbm(int1.yz*0.5)*0.4*\n            clamp(2.*(fbm( int1.yz*vec2(3.2,24.)+vec2(0.5*time,0.) )-0.5+l), 0.0, 1.)\n            *clamp(0.5*int1.y, 0., 1.);\n        }\n        if(m == 4.) { r = 0.1; }\n#endif\n        col = shade( ro, int1.xyz, true, m, r );\n        \n        if( ints > 0.5 ) {\n            col += r * shade( int1.xyz, int2.xyz, false, mapMaterial(int2), 0. );\n        }\n    }\n    \n    // gamma\n    col = pow( clamp(col*2.,0.0,1.0), vec3(0.4545) );\n    col *= 1.2*vec3(1.,0.99,0.95);   \n    col = clamp(1.06*col-0.03, 0., 1.);   \n\n    gl_FragColor = vec4( col, 1.0 );\n}\n",
					"name": "",
					"description": "",
					"type": "image"
				},

				{
					"inputs": 
					[
						{
							"id": 30,
							"src": "\/presets\/tex16.png",
							"ctype": "texture",
							"channel": 0
						}
					],

					"outputs": 
					[
						{
							"channel": "0",
							"dst": "-1"
						}
					],

					"code": "\/\/----------------------------------------------------------------------\n\/\/ noises\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*157.0;\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nfloat fbm( vec2 p ) {\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m2*p*2.32;\n    f += 0.2500*noise( p ); p = m2*p*2.23;\n    f += 0.1250*noise( p ); p = m2*p*2.31;\n    f += 0.0625*noise( p ); p = m2*p*2.21;\n    f += 0.03125*noise( p );\n  \n    return f;\n}\n\n\/\/----------------------------------------------------------------------\n\/\/ Wind function by Dave Hoskins https:\/\/www.shadertoy.com\/view\/4ssXW2\n\nvec2 Hash( vec2 n)\n{\n\tvec4 p = texture2D( iChannel0, n*vec2(.78271, .32837), -100.0 );\n    return (p.xy + p.zw) * .5; \n}\n\n\n\/\/--------------------------------------------------------------------------\nvec2 Noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 res = mix(mix( Hash(p + 0.0), Hash(p + vec2(1.0, 0.0)),f.x),\n                   mix( Hash(p + vec2(0.0, 1.0) ), Hash(p + vec2(1.0, 1.0)),f.x),f.y);\n    return res-.5;\n}\n\n\/\/--------------------------------------------------------------------------\nvec2 FBM( vec2 p ) {\n    vec2 f;\n\tf  = 0.5000\t * Noise(p); p = p * 2.32;\n\tf += 0.2500  * Noise(p); p = p * 2.23;\n\tf += 0.1250  * Noise(p); p = p * 2.31;\n    f += 0.0625  * Noise(p); p = p * 2.28;\n    f += 0.03125 * Noise(p);\n    return f;\n}\n\n\/\/--------------------------------------------------------------------------\nvec2 Wind(float n) {\n    vec2 pos = vec2(n * (162.017331), n * (132.066927));\n    vec2 vol = Noise(vec2(n*23.131, -n*42.13254))*1.0 + 1.0;\n    \n    vec2 noise = vec2(FBM(pos*33.313))* vol.x *.5 + vec2(FBM(pos*4.519)) * vol.y;\n    \n\treturn noise;\n}\n\n\/\/----------------------------------------------------------------------\n\nvec2 getSectorId( float z ) {\n    float id = floor( (z+6.)\/12.);\n    return vec2( id, hash(id) );\n}\n\nfloat soundLampExist(in float z) {\n    vec2 id = getSectorId(z);\n    if( hash(id.x+234.) < 0.15 && id.y < 0.75) return 1.;\n\treturn 0.;\n}\n\nfloat soundCeilExist(in float z) { \n    vec2 id = getSectorId(z);\n    if( id.y < 0.75) return 0.;\n\treturn 1.;\n}\n\nvec2 soundLamp(in float t) {\n    float l = 1. - clamp(2.*fbm( vec2(t*10., 2.) ), 0., 1.);\n\treturn 0.1*vec2( hash(t*0.001), hash(t*0.001+0.1) ) * l;\n}\n\nvec2 soundCeil(in float t) {\n\treturn (Wind(t*0.025) + Wind(t*4.)*0.15) * (0.75+0.2*sin(t*8.));\n}\n\nvec2 soundStep(in float t) {\n    float o = 0.2*noise(vec2(t,0.));\n    float i = fract(t*1.23+o);\n    \n    return Wind(t*0.025) * clamp(i*10.,0.,1.) * clamp(1.-i*6., 0., 1.);\n}\n\nvec2 getSound(in vec2 sl, in vec2 sc, in float z) {\n    return 0.9*soundLampExist(z)*sl + 0.2*soundCeilExist(z)*sc;\n}\n\nvec2 mixSounds(in float t, in float z) {\n    float zm = floor( (z+6.)\/12. ) * 12.;\n    \n    vec2 sound = vec2(0.);\n    vec2 sl = soundLamp(t);\n    vec2 sc = soundCeil(t);\n    \n    sound += getSound(sl, sc, zm-24.) * pow( mix(1., 0., clamp( abs(zm-24. - z)\/24., 0., 1. ) ), 2.);\n    sound += getSound(sl, sc, zm+24.) * pow( mix(1., 0., clamp( abs(zm+24. - z)\/24., 0., 1. ) ), 2.);\n    sound += getSound(sl, sc, zm-12.) * pow( mix(1., 0., clamp( abs(zm-12. - z)\/24., 0., 1. ) ), 2.);\n    sound += getSound(sl, sc, zm+12.) * pow( mix(1., 0., clamp( abs(zm+12. - z)\/24., 0., 1. ) ), 2.);\n    sound += getSound(sl, sc, zm)     * pow( mix(1., 0., clamp( abs(zm - z)\/24., 0., 1. ) ), 2.);\n    \n    return sound + soundStep(t);    \n}\n\nvec2 getSounds(in float t, in float z) {\n    vec2 m2 = mixSounds(t, z); \n    \n    return 6.*m2;\n}\n\nvec2 mainSound(float time) {\n    float z = time*2.;\n\treturn getSounds(time, z);\n}",
					"name": "",
					"description": "",
					"type": "sound"
				}
			]
		}
	]
}