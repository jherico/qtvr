{"Shader":{"ver":"0.1","info":{"id":"XlfXR4","date":"1434657962","viewed":1927,"name":"Curvature - Parametric 3D","username":"iq","description":"Curvature computation for parametric curves (same as <a href=\"https:\/\/www.shadertoy.com\/view\/Mlf3zl\" class=\"regular\" target=\"_blank\">https:\/\/www.shadertoy.com\/view\/Mlf3zl<\/a>. but in 3D in this case), and displays it with colors (red is high curvature, yellow is medium, green is low)","likes":24,"published":3,"flags":0,"tags":["3d","curvature","parametric"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\/\/\n\/\/ Computes the curvature of a parametric curve f(x) as \n\/\/\n\/\/ c(f) = |f'|^3 \/ | f' x f''|\n\/\/\n\/\/ More info here: https:\/\/en.wikipedia.org\/wiki\/Curvature\n\/\/\n\n\n\/\/----------------------------------------\n\nvec3 a = vec3(1.85,1.25,1.85) + 0.1*cos(5.0+0.7*iGlobalTime + vec3(0.5,1.0,2.0) );\nvec3 b = vec3(0.60,0.60,0.60) + 0.1*cos(4.0+0.5*iGlobalTime + vec3(2.5,5.0,3.0) );\nvec3 c = vec3(0.40,0.40,0.40) + 0.1*cos(1.0+0.3*iGlobalTime + vec3(6.0,2.0,4.2) );\nvec3 m = cos( 0.11*iGlobalTime + vec3(2.0,0.0,5.0) );\nvec3 n = cos( 0.17*iGlobalTime + vec3(3.0,1.0,4.0) );\n\n\/\/ curve\nvec3 mapD0(float t)\n{\n    return 0.25 + a*cos(t+m)*(b+c*cos(t*7.0+n));\n}\n\/\/ curve derivative (velocity)\nvec3 mapD1(float t)\n{\n    return -7.0*a*c*cos(t+m)*sin(7.0*t+n) - a*sin(t+m)*(b+c*cos(7.0*t+n));\n}\n\/\/ curve second derivative (acceleration)\nvec3 mapD2(float t)\n{\n    return 14.0*a*c*sin(t+m)*sin(7.0*t+n) - a*cos(t+m)*(b+c*cos(7.0*t+n)) - 49.0*a*c*cos(t+m)*cos(7.0*t+n);\n}\n\n\/\/----------------------------------------\n\nfloat curvature( float t )\n{\n    vec3 r1 = mapD1(t); \/\/ first derivative\n    vec3 r2 = mapD2(t); \/\/ second derivative\n    return pow(length(r1),3.0) \/ length(cross(r1,r2));\n}\n\n\/\/-----------------------------------------\n\n\/\/ unsigned squared distance between ray and segment\nvec3 usqdLineSegment( vec3 a, vec3 b, vec3 o, vec3 d )\n{\n\tvec3 ba = b - a;\n\tvec3 oa = o - a;\n\t\n\tfloat oad  = dot( oa,  d );\n\tfloat dba  = dot(  d, ba );\n\tfloat baba = dot( ba, ba );\n\tfloat oaba = dot( oa, ba );\n\t\n\tvec2 th = vec2( -oad*baba + dba*oaba, oaba - oad*dba ) \/ (baba - dba*dba);\n\t\n\tth.x = max(   th.x, 0.0 );\n\tth.y = clamp( th.y, 0.0, 1.0 );\n\t\n\tvec3 p = a + ba*th.y;\n\tvec3 q = o + d*th.x;\n\t\n\treturn vec3( dot( p-q, p-q ), th );\n}\n\nvec2 usqdPointSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\tvec3 q = pa - ba*h;\n\treturn vec2( dot(q,q), h );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy+2.0*fragCoord.xy)\/iResolution.y;\n \n    vec3 ro = vec3( 0.0, 0.0, 4.0 );\n    vec3 rd = normalize( vec3(p.xy, -2.0) );\n\n    vec3 col = vec3(0.0);\n    \n    vec3  gp = vec3(0.0);\n    float pt = (-1.0-ro.y)\/rd.y;\n    vec3 gc = vec3(0.0);\n    if( pt>0.0 )\n    {\n        gp = ro + pt*rd;\n        gc = vec3(1.0) * (0.2 + 0.1*smoothstep(-0.01,0.01,sin(4.0*gp.x)*sin(4.0*gp.z)));\n        col = 0.3*gc*exp(-0.05*pt);\n    }\n\n    \n    float dt = 6.2831\/150.0;\n\tfloat t = 0.0;\n    float mint = 1e10;\n    vec3  xb = mapD0(t);\n    \n    t += dt;\n    for( int i=0; i<150; i++ )\n    {\n        vec3 xc = mapD0(t);\n        xc.y = max(-1.0,xc.y); \/\/ clip to ground\n        vec3 ds = usqdLineSegment( xb, xc, ro, rd );\n\n        \/\/ compute curvature\n        float h = t - dt + dt*ds.z;\n        float c = curvature( h );\n\n        vec3  cc = clamp( 0.25 + 0.75*cos( -clamp(3.0*c,0.0,2.0) + 1.0 + vec3(0.0,1.5,2.0) ), 0.0, 1.0 );\n        cc *= 5.5*exp( -0.5*ds.y );\n        \n        col += 1.0*cc*exp( -500.0*ds.x );\n        col += 0.1*cc*exp( -25.0*ds.x );\n\n        \/\/ light ground\n        if( pt > 0.0 )\n        {\n            vec2 sd = usqdPointSegment( gp, xb, xc );\n            col += gc*0.8*cc*exp(-2.0*sd.x)*exp( -0.05*pt );\n        }\n        \n\t\tt += dt;\n        xb = xc;\n\t}\n    \n\n    \n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}