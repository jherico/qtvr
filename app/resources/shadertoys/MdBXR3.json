{"Shader":{"ver":"0.1","info":{"id":"MdBXR3","date":"1414360243","viewed":6248,"name":"Jack-o'-lantern","username":"P_Malin","description":"A shader doodle for halloween","likes":70,"published":3,"flags":0,"tags":["halloween","pumpkin"],"hasliked":0},"renderpass":[{"inputs":[{"id":2,"src":"\/presets\/tex01.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":4,"src":"\/presets\/tex03.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Jack-o'-lantern\n\/\/ @P_Malin\n\n\/\/ A little shadertoy doodle for halloween\n\n#define kRaymarchMaxIter 64\n\n#define kBounceCount 1\n\n\/\/#define SCENE_DOMAIN_REPEAT\n\nfloat kFarClip=100.0;\n\nvec2 GetWindowCoord( const in vec2 vUV );\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget );\nvec3 GetSceneColour( in vec3 vRayOrigin,  in vec3 vRayDir );\nvec3 ApplyPostFX( const in vec2 vUV, const in vec3 vInput );\n\nfloat GetCarving2dDistance(const in vec2 vPos );\n\nvec3 vLightPos = vec3(0.0, -0.5, 0.0);\t\t\t\nvec3 vLightColour = vec3(1.0, 0.8, 0.4);\n\nfloat fCarving = 1.0;\n\n\/\/ from https:\/\/www.shadertoy.com\/view\/4djSRW\nfloat hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vUV = fragCoord.xy \/ iResolution.xy;\n\n    vLightColour *= hash(iGlobalTime) * 0.2 + 0.8;\n    float fDist = 7.0;\n\n    float fAngle = radians(190.0) + sin(iGlobalTime * 0.25) * 0.2;\n    float fHeight = 2.0 + sin(iGlobalTime * 0.1567) * 1.5;\n    \n\tvec2 vMouse = iMouse.xy \/ iResolution.xy;\n\t\n    \n    if(iMouse.z > 0.0)\n    {\n        fAngle = vMouse.x * 2.0 * 3.14;\n        fHeight = vMouse.y * fDist;\n    }\n    \n\tvec3 vCameraPos = vec3(sin(fAngle) * fDist, fHeight, cos(fAngle) * fDist);\n\tvec3 vCameraTarget = vec3(0.0, -0.5, 0.0);\n\n\tvec3 vRayOrigin = vCameraPos;\n\tvec3 vRayDir = GetCameraRayDir( GetWindowCoord(vUV), vCameraPos, vCameraTarget );\n\t\n\tvec3 vResult = GetSceneColour(vRayOrigin, vRayDir);\n\t    \n\tvec3 vFinal = ApplyPostFX( vUV, vResult );\n\t\n\tfragColor = vec4(vFinal, 1.0);\n}\n\n\/\/ CAMERA\n\nvec2 GetWindowCoord( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x \/ iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget )\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\t\t\t\t\t\t  \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * 1.5);\n\n\treturn vDir;\n}\n\n\/\/ POSTFX\n\nvec3 ApplyVignetting( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0);\n\t\n\tfloat fDist = dot(vOffset, vOffset);\n\t\n\tconst float kStrength = 0.95;\n\tconst float kPower = 1.5;\n\n\treturn vInput * ((1.0 - kStrength) +  kStrength * pow(1.0 - fDist, kPower));\n}\n\nvec3 ApplyTonemap( const in vec3 vLinear )\n{\n\tfloat kExposure = 1.0;\n    \n    if(iGlobalTime < 2.0)\n    {\n        kExposure = iGlobalTime \/ 2.0;\n    }\n    \t\n\treturn 1.0 - exp2(vLinear * -kExposure);\t\n}\n\nvec3 ApplyGamma( const in vec3 vLinear )\n{\n\tconst float kGamma = 2.2;\n\n\treturn pow(vLinear, vec3(1.0\/kGamma));\t\n}\n\nvec3 ApplyBlackLevel( const in vec3 vColour )\n{\n    float fBlackLevel = 0.1;\n    return vColour \/ (1.0 - fBlackLevel) - fBlackLevel;\n}\n\nvec3 ApplyPostFX( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec3 vTemp = ApplyVignetting( vUV, vInput );\t\n\t\n\tvTemp = ApplyTonemap(vTemp);\n\t\n\tvTemp = ApplyGamma(vTemp);\t\t\n    \n    vTemp = ApplyBlackLevel(vTemp);\n    \n    return vTemp;\n}\n\t\n\/\/ RAYTRACE\n\nstruct C_Intersection\n{\n\tvec3 vPos;\n\tfloat fDist;\t\n\tvec3 vNormal;\n\tvec3 vUVW;\n\tfloat fObjectId;\n};\n\nfloat GetCarving2dDistance(const in vec2 vPos )\n{\n    if(fCarving < 0.0)\n        return 10.0;\n    \n\tfloat fMouthDist = length(vPos.xy + vec2(0.0, -0.5)) - 1.5;\n\tfloat fMouthDist2 = length(vPos.xy + vec2(0.0, -1.1 - 0.5)) - 2.0;\n\t\n\tif(-fMouthDist2 > fMouthDist )\n\t{\n\t\tfMouthDist = -fMouthDist2;\n\t}\n\n    float fFaceDist = fMouthDist;\n\n    vec2 vNosePos = vPos.xy + vec2(0.0, -0.5);\n    vNosePos.x = abs(vNosePos.x);\n    float fNoseDist = dot(vNosePos.xy, normalize(vec2(1.0, 0.5)));\n    fNoseDist = max(fNoseDist, -(vNosePos.y + 0.5));\n    if(fNoseDist < fFaceDist)\n    {\n        fFaceDist = fNoseDist;\n    }\n\n\n    vec2 vEyePos = vPos.xy;\n    vEyePos.x = abs(vEyePos.x);\n    vEyePos.x -= 1.0;\n    vEyePos.y -= 1.0;\n    float fEyeDist = dot(vEyePos.xy, normalize(vec2(-1.0, 1.5)));\n    fEyeDist = max(fEyeDist, dot(vEyePos.xy, normalize(vec2(1.0, 0.5))));\n    fEyeDist = max(fEyeDist, -0.5+dot(vEyePos.xy, normalize(vec2(0.0, -1.0))));\n    if(fEyeDist < fFaceDist)\n    {\n        fFaceDist = fEyeDist;\n    }\n    \n    return fFaceDist;\n}\n\nfloat GetCarvingDistance(const in vec3 vPos )\n{\n\tfloat fDist = (length(vPos * vec3(1.0, 1.4, 1.0)) - 2.7) \/ 1.5;\n\n    float fFaceDist = GetCarving2dDistance(vPos.xy);\n    \n\tfloat fRearDist = vPos.z;\n\t\n\tif(fRearDist > fFaceDist)\n\t{\n\t\tfFaceDist = fRearDist;\n\t}\t\n\t\n\tif(fFaceDist < fDist )\n\t{\n\t\tfDist = fFaceDist;\n\t}\n\n    float fR = length(vPos.xz);\n    \n    float fLidDist = dot( vec2(fR, vPos.y), normalize(vec2(1.0, -1.5)));\n    \n    fLidDist = abs(fLidDist) - 0.03;\n\tif(fLidDist < fDist )\n\t{\n\t\tfDist = fLidDist;\n\t}\n    \n\treturn fDist;\n}\n\nfloat GetPumpkinDistance( out vec4 vOutUVW_Id, const in vec3 vPos )\n{\n    vec3 vSphereOrigin = vec3(0.0, 0.0, 0.0);\n    float fSphereRadius = 3.0;\n\n\tvec3 vOffset = vPos - vSphereOrigin;\n\tfloat fFirstDist = length(vOffset);\n\t\n\tfloat fOutDist;\n\tif(fFirstDist > 3.5)\n\t{\n\t\tfOutDist = fFirstDist - fSphereRadius;\n\t}\n\telse\n\t{\n\t\tfloat fAngle1 = atan(vOffset.x, vOffset.z);\n\t\tfloat fSin = sin(fAngle1 * 10.0);\n\t\tfSin = 1.0 - sqrt(abs(fSin));\n\t\tvOffset *= 1.0 + fSin * vec3(0.05, 0.025, 0.05);\n\t\tvOffset.y *= 1.0 + 0.5 * (fSphereRadius - length(vOffset.xz)) \/ fSphereRadius;\n\t\tfOutDist = length(vOffset) - fSphereRadius;\n\t}\n\t\n\n\tvec4 vSphere1UVW_Id = vec4(normalize(vPos - vSphereOrigin), 3.0);\n\tvOutUVW_Id = vSphere1UVW_Id;\n\t\n\tvec3 vStalkOffset = vPos;\n\tvStalkOffset.x += -(vStalkOffset.y - fSphereRadius) * 0.1;\n\tfloat fDist2d = length(vStalkOffset.xz);\n\tfloat fStalkDist = fDist2d - 0.2;\n\tfStalkDist = max(fStalkDist, vPos.y - 2.5 + vPos.x * 0.25);\n\tfStalkDist = max(fStalkDist, -vPos.y);\n\tif( fStalkDist < fOutDist )\n\t{\n\t\tfOutDist = fStalkDist;\n\t\tvOutUVW_Id = vSphere1UVW_Id;\n\t\tvOutUVW_Id.w = 2.0;\n\t}\n\n\treturn fOutDist;\n}\n\nfloat GetSceneDistance( out vec4 vOutUVW_Id, const in vec3 vPos )\n{\n\tfloat fFloorDist = vPos.y + 2.0;\n\tvec4 vFloorUVW_Id = vec4(vPos.xz, 0.0, 1.0);\n\n\t\n\tvec3 vPumpkinDomain = vPos;\n\n#ifdef SCENE_DOMAIN_REPEAT\n\tfloat fRepeat = 12.0;\n\tfloat fOffset = (fRepeat * 0.5);\n\tvPumpkinDomain.xz = fract((vPos.xz + fOffset) \/ fRepeat) * fRepeat - fOffset;\n#endif \n    \n\tfloat fOutDist = fFloorDist;\n\tvOutUVW_Id = vFloorUVW_Id;\n\n\tvec4 vPumpkinUVW_Id;\n\tfloat fPumpkinDist = GetPumpkinDistance( vPumpkinUVW_Id, vPumpkinDomain );\n\n\tfloat fCarvingDist = GetCarvingDistance( vPumpkinDomain );\n\t\n\tif(-fCarvingDist > fPumpkinDist)\n\t{\n\t\tfPumpkinDist = -fCarvingDist;\n\t\tvPumpkinUVW_Id = vec4(4.0);\n\t}\n\n\t\n\tif(fPumpkinDist < fOutDist)\n\t{\n\t\tfOutDist = fPumpkinDist;\n\t\tvOutUVW_Id = vPumpkinUVW_Id;\n\t}\n\t\n\treturn fOutDist;\n}\n\nvec3 GetSceneNormal(const in vec3 vPos)\n{\n    const float fDelta = 0.001;\n\n    vec3 vDir1 = vec3( 1.0, -1.0, -1.0);\n    vec3 vDir2 = vec3(-1.0, -1.0,  1.0);\n    vec3 vDir3 = vec3(-1.0,  1.0, -1.0);\n    vec3 vDir4 = vec3( 1.0,  1.0,  1.0);\n\t\n    vec3 vOffset1 = vDir1 * fDelta;\n    vec3 vOffset2 = vDir2 * fDelta;\n    vec3 vOffset3 = vDir3 * fDelta;\n    vec3 vOffset4 = vDir4 * fDelta;\n\n\tvec4 vUnused;\n    float f1 = GetSceneDistance( vUnused, vPos + vOffset1 );\n    float f2 = GetSceneDistance( vUnused, vPos + vOffset2 );\n    float f3 = GetSceneDistance( vUnused, vPos + vOffset3 );\n    float f4 = GetSceneDistance( vUnused, vPos + vOffset4 );\n\t\n    vec3 vNormal = vDir1 * f1 + vDir2 * f2 + vDir3 * f3 + vDir4 * f4;\t\n\t\t\n    return normalize( vNormal );\n}\n\nvoid TraceScene( out C_Intersection outIntersection, const in vec3 vOrigin, const in vec3 vDir )\n{\t\n\tvec4 vUVW_Id = vec4(0.0);\t\t\n\tvec3 vPos = vec3(0.0);\n\t\n\tfloat t = 0.01;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\n\t\tvPos = vOrigin + vDir * t;\n\t\tfloat fDist = GetSceneDistance(vUVW_Id, vPos);\t\t\n\t\tt += fDist;\n\t\tif(abs(fDist) < 0.001)\n\t\t{\n\t\t\tbreak;\n\t\t}\t\t\n\t\tif(t > 100.0)\n\t\t{\n\t\t\tt = kFarClip;\n\t\t\tvPos = vOrigin + vDir * t;\n\t\t\tvUVW_Id = vec4(0.0);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\toutIntersection.fDist = t;\n\toutIntersection.vPos = vPos;\n\toutIntersection.vNormal = GetSceneNormal(vPos);\n\toutIntersection.vUVW = vUVW_Id.xyz;\n\toutIntersection.fObjectId = vUVW_Id.w;\n}\n\n\nfloat TraceShadow( const in vec3 vOrigin, const in vec3 vDir, const in float fDist )\n{\n    C_Intersection shadowIntersection;\n\tTraceScene(shadowIntersection, vOrigin, vDir);\n\tif(shadowIntersection.fDist < fDist) \n\t{\n\t\treturn 0.0;\t\t\n\t}\n\t\n\treturn 1.0;\n}\n\nfloat GetSSS( const in vec3 vPos, const in vec3 vLightPos )\n{\n    vec3 vLightToPos = vPos - vLightPos;\n    vec3 vDir = normalize(vLightToPos);\n    \n\tC_Intersection intersection;\n\tTraceScene(intersection, vLightPos, vDir);\n\tfloat fOpticalDepth = length(vLightToPos) - intersection.fDist;\n\n    fOpticalDepth = max(0.00001, fOpticalDepth);\n    \n\treturn exp2( fOpticalDepth * -8.0 );\n}\n\n\/\/ LIGHTING\n\nfloat GIV( float dotNV, float k)\n{\n\treturn 1.0 \/ ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\nvoid AddLighting(inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightColour)\n{\n\tvec3 vH = normalize( -vViewDir + vLightDir );\n\tfloat fNDotL = clamp(dot(vLightDir, vNormal), 0.0, 1.0);\n\tfloat fNDotV = clamp(dot(-vViewDir, vNormal), 0.0, 1.0);\n\tfloat fNDotH = clamp(dot(vNormal, vH), 0.0, 1.0);\n\t\n\tfloat alpha = 1.0 - fSmoothness;\n\talpha = alpha * alpha;\n\t\/\/ D\n\n\tfloat alphaSqr = alpha * alpha;\n\tfloat pi = 3.14159;\n\tfloat denom = fNDotH * fNDotH * (alphaSqr - 1.0) + 1.0;\n\tfloat d = alphaSqr \/ (pi * denom * denom);\n\n\tfloat k = alpha \/ 2.0;\n\tfloat vis = GIV(fNDotL, k) * GIV(fNDotV, k);\n\n\tfloat fSpecularIntensity = d * vis * fNDotL;\n\tvSpecularLight += vLightColour * fSpecularIntensity;\n\n\tvDiffuseLight += vLightColour * fNDotL;\n}\n\nvoid AddPointLight(inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vPos, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightPos, const in vec3 vLightColour)\n{\n\tvec3 vToLight = vLightPos - vPos;\t\n\tfloat fDistance2 = dot(vToLight, vToLight);\n\tfloat fAttenuation = 100.0 \/ (fDistance2);\n\tvec3 vLightDir = normalize(vToLight);\n\t\n\tvec3 vShadowRayDir = vLightDir;\n\tvec3 vShadowRayOrigin = vPos + vShadowRayDir * 0.01;\n\tfloat fShadowFactor = TraceShadow(vShadowRayOrigin, vShadowRayDir, length(vToLight));\n\t\n\tAddLighting(vDiffuseLight, vSpecularLight, vViewDir, vLightDir, vNormal, fSmoothness, vLightColour * fShadowFactor * fAttenuation);\n}\n\nfloat AddDirectionalLight(inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vPos, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightDir, const in vec3 vLightColour)\n{\t\n\tfloat fAttenuation = 1.0;\n\n\tvec3 vShadowRayDir = -vLightDir;\n\tvec3 vShadowRayOrigin = vPos + vShadowRayDir * 0.01;\n\tfloat fShadowFactor = TraceShadow(vShadowRayOrigin, vShadowRayDir, 10.0);\n\t\n\tAddLighting(vDiffuseLight, vSpecularLight, vViewDir, -vLightDir, vNormal, fSmoothness, vLightColour * fShadowFactor * fAttenuation);\t\n    \n    return fShadowFactor;\n}\n\nvoid AddDirectionalLightFlareToFog(inout vec3 vFogColour, const in vec3 vRayDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fDirDot = clamp(dot(-vLightDir, vRayDir), 0.0, 1.0);\n\tfloat kSpreadPower = 4.0;\n\tvFogColour += vLightColour * pow(fDirDot, kSpreadPower);\n}\n\n\/\/ SCENE MATERIALS\n\nvoid GetSurfaceInfo(out vec3 vOutAlbedo, out vec3 vOutR0, out float fOutSmoothness, out vec3 vOutBumpNormal, const in C_Intersection intersection )\n{\n\tvOutBumpNormal = intersection.vNormal;\n\t\n\tif(intersection.fObjectId == 1.0)\n\t{\n\t\tvec2 vUV = intersection.vUVW.xy * 0.1;\n\t\tvOutAlbedo = texture2D(iChannel0, vUV).rgb;\n\t\tfloat fBumpScale = 10.0;\n\t\t\n\t\tvec2 vRes = iChannelResolution[0].xy;\n\t\tvec2 vDU = vec2(1.0, 0.0) \/ vRes;\n\t\tvec2 vDV = vec2(0.0, 1.0) \/ vRes;\n\t\t\n\t\tfloat fSampleW = texture2D(iChannel0, vUV - vDU).r;\n\t\tfloat fSampleE = texture2D(iChannel0, vUV + vDU).r;\n\t\tfloat fSampleN = texture2D(iChannel0, vUV - vDV).r;\n\t\tfloat fSampleS = texture2D(iChannel0, vUV + vDV).r;\n\t\t\n\t\tvec3 vNormalDelta = vec3(0.0);\n\t\tvNormalDelta.x += \n\t\t\t( fSampleW * fSampleW\n\t\t\t - fSampleE * fSampleE) * fBumpScale;\n\t\tvNormalDelta.z += \n\t\t\t(fSampleN * fSampleN\n\t\t\t - fSampleS * fSampleS) * fBumpScale;\n\t\t\n\t\tvOutBumpNormal = normalize(vOutBumpNormal + vNormalDelta);\n\n\t\tvOutAlbedo = vOutAlbedo * vOutAlbedo;\t\n\t\tfOutSmoothness = clamp((0.8 - vOutAlbedo.r * 4.0), 0.0, 1.0);\n\t\t\n\t\tvOutR0 = vec3(0.01) * vOutAlbedo.g;\n\t}\n\telse if(intersection.fObjectId == 2.0)\n\t{\n\t\tvOutAlbedo = vec3(0.5, 0.5, 0.2);\n\t\tfOutSmoothness = 0.4;\n\t\tvOutR0 = vec3(0.05);\n\t}\n\telse if(intersection.fObjectId == 3.0)\n\t{\n        float fAngle = atan(intersection.vUVW.x, intersection.vUVW.z);\n        vec2 vUV = vec2(fAngle, intersection.vUVW.y) * vec2(1.0, 0.2) * 8.0;\n\t\tvOutAlbedo = texture2D(iChannel1, vUV).rgb;\n\t\tfOutSmoothness = clamp(1.0 - vOutAlbedo.r * vOutAlbedo.r * 2.0, 0.0, 1.0);\t\t\t\n\t\tvec3 vCol1 = vec3(1.0, 0.5, 0.0);\n\t\tvec3 vCol2 = vec3(0.5, 0.06, 0.0);\n\t\tvOutAlbedo = mix(vCol1, vCol2, vOutAlbedo.r * 0.5).rgb;\n\t\tvOutR0 = vec3(0.05);\n\t}\n\telse if(intersection.fObjectId == 4.0)\n    {\n\t\tvOutAlbedo = vec3(1.0, 0.824, 0.301);\n\t\tfOutSmoothness = 0.4;\n\t\tvOutR0 = vec3(0.05);\n\t}\n}\n\nvec3 GetSkyColour( const in vec3 vDir )\n{\t\n\tvec3 vResult = mix(vec3(0.02, 0.04, 0.06), vec3(0.1, 0.5, 0.8), abs(vDir.y));\n\t\n\treturn vResult;\t\n}\n\nfloat GetFogFactor(const in float fDist)\n{\n\tfloat kFogDensity = 0.025;\n\treturn exp(fDist * -kFogDensity);\t\n}\n\nvec3 GetFogColour(const in vec3 vDir)\n{\n\treturn vec3(0.01);\t\t\n}\n\nvec3 vSunLightColour = vec3(0.1, 0.2, 0.3) * 5.0;\nvec3 vSunLightDir = normalize(vec3(0.4, -0.3, -0.5));\n\t\nvoid ApplyAtmosphere(inout vec3 vColour, const in float fDist, const in vec3 vRayOrigin, const in vec3 vRayDir)\n{\t\t\n\tfloat fFogFactor = GetFogFactor(fDist);\n\tvec3 vFogColour = GetFogColour(vRayDir);\t\t\t\n\tAddDirectionalLightFlareToFog(vFogColour, vRayDir, vSunLightDir, vSunLightColour);\n\t\n\tvColour = mix(vFogColour, vColour, fFogFactor);\t\n}\n\n\/\/ TRACING LOOP\n\n\t\nvec3 GetSceneColour( in vec3 _vRayOrigin,  in vec3 _vRayDir )\n{\n    vec3 vRayOrigin = _vRayOrigin;\n    vec3 vRayDir = _vRayDir;\n\tvec3 vColour = vec3(0.0);\n\tvec3 vRemaining = vec3(1.0);\n\t\n    float fLastShadow = 1.0;\n    \n\tfor(int i=0; i<kBounceCount; i++)\n\t{\t\n\t\tvec3 vCurrRemaining = vRemaining;\n\t\tfloat fShouldApply = 1.0;\n\t\t\n\t\tC_Intersection intersection;\t\t\t\t\n\t\tTraceScene( intersection, vRayOrigin, vRayDir );\n\n\t\tvec3 vResult = vec3(0.0);\n\t\tvec3 vBlendFactor = vec3(0.0);\n\t\t\t\t\t\t\n\t\tif(intersection.fObjectId == 0.0)\n\t\t{\n\t\t\tvBlendFactor = vec3(1.0);\n\t\t\tfShouldApply = 0.0;\n\t\t}\n\t\telse\n\t\t{\t\t\n\t\t\tvec3 vAlbedo;\n\t\t\tvec3 vR0;\n\t\t\tfloat fSmoothness;\n\t\t\tvec3 vBumpNormal;\n\t\t\t\n\t\t\tGetSurfaceInfo( vAlbedo, vR0, fSmoothness, vBumpNormal, intersection );\t\t\t\n\t\t\n\t\t\tvec3 vDiffuseLight = vec3(0.0);\n\t\t\tvec3 vSpecularLight = vec3(0.0);\n\n            fLastShadow = AddDirectionalLight(vDiffuseLight, vSpecularLight, vRayDir, intersection.vPos, vBumpNormal, fSmoothness, vSunLightDir, vSunLightColour);\t\t\t\t\t\t\t\t\n\n            vec3 vPointLightPos = vLightPos;\n            #ifdef SCENE_DOMAIN_REPEAT\n                float fRepeat = 12.0;\n                float fOffset = (fRepeat * 0.5);\n                vec2 vTile = floor((intersection.vPos.xz + fOffset) \/ fRepeat);\n            \tvPointLightPos.xz += vTile * fRepeat;\n            #endif             \n            \n\t\t\tAddPointLight(vDiffuseLight, vSpecularLight, vRayDir, intersection.vPos, vBumpNormal, fSmoothness, vPointLightPos, vLightColour);\t\t\t\t\t\t\t\t\n\n            if(intersection.fObjectId >= 3.0)\n            {\n                vDiffuseLight += GetSSS(intersection.vPos, vPointLightPos) * vLightColour;\n            }\n            else\n            {\n                vec3 vToLight = vPointLightPos - intersection.vPos;\n                float fNdotL = dot(normalize(vToLight), vBumpNormal) * 0.5 + 0.5;\n\t\t\t\tvDiffuseLight += max(0.0, 1.0 - length(vToLight)\/5.0) * vLightColour * fNdotL;                \n            }\n\n\t\t\tfloat fSmoothFactor = fSmoothness * 0.9 + 0.1;\n            float fFresnelClamp = 0.25; \/\/ too much fresnel produces sparkly artefacts\n            float fNdotD = clamp(dot(vBumpNormal, -vRayDir), fFresnelClamp, 1.0);\n\t\t\tvec3 vFresnel = vR0 + (1.0 - vR0) * pow(1.0 - fNdotD, 5.0) * fSmoothFactor;\n\n            \n\t\t\tvResult = mix(vAlbedo * vDiffuseLight, vSpecularLight, vFresnel);\t\t\n\t\t\tvBlendFactor = vFresnel;\n\t\t\t\n\t\t\tApplyAtmosphere(vResult, intersection.fDist, vRayOrigin, vRayDir);\t\t\n\t\t\t\n\t\t\tvRemaining *= vBlendFactor;\t\t\t\t\n\t\t\tvRayDir = normalize(reflect(vRayDir, vBumpNormal));\n\t\t\tvRayOrigin = intersection.vPos;\n\t\t}\t\t\t\n\n\t\tvColour += vResult * vCurrRemaining * fShouldApply;\t\n\t}\n\n\tvec3 vSkyColor = GetSkyColour(vRayDir);\n\t\n\tApplyAtmosphere(vSkyColor, kFarClip, vRayOrigin, vRayDir);\t\t\n\t\n    \/\/ Hack for this scene when using 1 bounce.\n    \/\/ remove final sky reflection when in shadow\n    vSkyColor *= fLastShadow; \n    \n\tvColour += vSkyColor * vRemaining;\n\t\n    \/\/ Face glow\n    float t = -(_vRayOrigin.z + 2.8) \/ _vRayDir.z;\n    \n    if( t > 0.0 )\n    {\n        vec3 vPos = _vRayOrigin + _vRayDir * t;\n\n        float fDist = abs(GetCarving2dDistance(vPos.xy * vec2(1.0, 1.0)));\n        float fDot = max(0.0, _vRayDir.z);\n        fDot = fDot * fDot;\n        vColour += exp2(-fDist * 10.0) * fDot * vLightColour * 0.25;\n    }\n    \n    \n\treturn vColour;\n}\n","name":"","description":"","type":"image"}]}}