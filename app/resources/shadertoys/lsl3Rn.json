{"Shader":{"ver":"0.1","info":{"id":"lsl3Rn","date":"1361825690","viewed":3517,"name":"R Tape loading error, 0:1","username":"P_Malin","description":"ZX Spectrum loading sequence fragment shader","likes":43,"published":3,"flags":8,"tags":["retro","spectrum"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":" \r\n\/\/ R Tape loading error, 0:1\r\n \r\n\/\/ @P_Malin\r\n\r\n\/\/#define LOADING_LOOP\r\n \r\nvec2 kResolution = vec2(256.0, 192.0);\r\n \r\n\/\/ Border phases\r\n\r\nfloat kPhaseBlank = 0.0;\r\nfloat kPhaseSilent = 1.0;\r\nfloat kPhaseHeader = 2.0;\r\nfloat kPhaseData = 3.0;\r\nfloat kPhaseRunning = 4.0;\r\n \r\n\/\/ Loading phases\r\n\r\nvec3 vTimeSilent1  = vec3(1.0,\t5.0,                       kPhaseSilent);\r\nvec3 vTimeHeader1  = vec3(2.0,  vTimeSilent1.y + 2.0,      kPhaseHeader);\r\nvec3 vTimeData1    = vec3(3.0,  vTimeHeader1.y + 0.125,    kPhaseData);\r\n \r\nvec3 vTimeBlank2   = vec3(4.0,  vTimeData1.y + 1.0,        kPhaseBlank);\r\nvec3 vTimeSilent2  = vec3(5.0,  vTimeBlank2.y + 2.0,       kPhaseSilent);\r\nvec3 vTimeHeader2  = vec3(6.0,  vTimeSilent2.y + 2.0,      kPhaseHeader);\r\nvec3 vTimeData2    = vec3(7.0,  vTimeHeader2.y + 1.0,      kPhaseData);\r\n \r\nvec3 vTimeSilent3  = vec3(8.0,  vTimeData2.y + 2.0,        kPhaseSilent);\r\nvec3 vTimeHeader3  = vec3(9.0,  vTimeSilent3.y + 2.0,      kPhaseHeader);\r\nvec3 vTimeData3    = vec3(10.0, vTimeHeader3.y + 0.125,    kPhaseData);\r\n \r\nvec3 vTimeSilent4  = vec3(11.0, vTimeData3.y + 2.0,        kPhaseSilent);\r\nvec3 vTimeHeader4  = vec3(12.0, vTimeSilent4.y + 2.0,      kPhaseHeader);\r\nvec3 vTimeData4    = vec3(13.0, vTimeHeader4.y + 38.0,     kPhaseData);\r\n \r\nvec3 vTimeRunning  = vec3(14.0, vTimeData4.y + 10.0,       kPhaseRunning);\r\n \r\nvec3 vTimeTotal    = vec3(15.0, vTimeRunning.y,            kPhaseBlank);\r\n       \r\nvec4 GetPhase(float fTime)\r\n{             \r\n        vec3 vResult = vTimeRunning;\r\n                \r\n        vResult = mix( vResult, vTimeData4, step(fTime, vTimeData4.y ) );\r\n        vResult = mix( vResult, vTimeHeader4, step(fTime, vTimeHeader4.y ) );\r\n        vResult = mix( vResult, vTimeSilent4, step(fTime, vTimeSilent4.y ) );\r\n \r\n        vResult = mix( vResult, vTimeData3, step(fTime, vTimeData3.y ) );\r\n        vResult = mix( vResult, vTimeHeader3, step(fTime, vTimeHeader3.y ) );\r\n        vResult = mix( vResult, vTimeSilent3, step(fTime, vTimeSilent3.y ) );\r\n               \r\n        vResult = mix( vResult, vTimeData2, step(fTime, vTimeData2.y ) );\r\n        vResult = mix( vResult, vTimeHeader2, step(fTime, vTimeHeader2.y ) );\r\n        vResult = mix( vResult, vTimeSilent2, step(fTime, vTimeSilent2.y ) );\r\n        vResult = mix( vResult, vTimeBlank2, step(fTime, vTimeBlank2.y ) );\r\n \r\n        vResult = mix( vResult, vTimeData1, step(fTime, vTimeData1.y ) );\r\n        vResult = mix( vResult, vTimeHeader1, step(fTime, vTimeHeader1.y ) );\r\n        vResult = mix( vResult, vTimeSilent1, step(fTime, vTimeSilent1.y ) );\r\n               \r\n        return vec4(vResult.z, vResult.x, fTime - vResult.y, vResult.y);\r\n}\r\n \r\nfloat GetRasterPosition(in vec2 fragCoord)\r\n{\r\n        return (fragCoord.x + fragCoord.y * iResolution.x) \/ (iResolution.x * iResolution.y);\r\n}\r\n \r\nfloat IsBorder(vec2 vScreenUV)\r\n{\r\n        if(vScreenUV.x < 0.0)\r\n                        return 1.0;\r\n        if(vScreenUV.x >= 1.0)\r\n                        return 1.0;\r\n        if(vScreenUV.y < 0.0)\r\n                        return 1.0;\r\n        if(vScreenUV.y >= 1.0)\r\n                        return 1.0;\r\n       \r\n        return 0.0;\r\n}\r\n \r\n \r\nvec3 GetBorderColour(float fPhase,in vec2 fragCoord)\r\n{\r\n\tfloat raster = GetRasterPosition(fragCoord);\r\n\t\r\n\tvec3 vCol = vec3(0.0);\r\n\t\r\n\tif(fPhase == kPhaseBlank)\r\n\t{                       \r\n\t\tvCol = vec3(1.0);           \r\n\t}\r\n\telse  \r\n\tif(fPhase == kPhaseSilent)\r\n\t{\r\n\t\tfloat fBlend = step(fract(iGlobalTime * 0.5), 0.5);\r\n\t\tvCol = mix( vec3(0.0, 1.0, 1.0), vec3(1.0, 0.0, 0.0), fBlend);           \r\n\t}\r\n\telse\r\n\tif(fPhase == kPhaseHeader)\r\n\t{\r\n\t\tfloat fBarSize = 12.0;\r\n\t\tfloat fScrollSpeed = 10.0;\r\n\t\tfloat fBlend = step(fract(raster * fBarSize + iGlobalTime * fScrollSpeed), 0.5);\r\n\t\tvCol = mix( vec3(0.0, 1.0, 1.0), vec3(1.0, 0.0, 0.0), fBlend);           \r\n\t}\r\n\telse\r\n\tif(fPhase == kPhaseData)\r\n\t{\r\n\t\tfloat fBarSize = 25.0;\r\n\t\tfloat fScrollSpeed = 1.0;\r\n\t\tfloat fBlend = step(fract(raster * fBarSize + iGlobalTime * fScrollSpeed + sin(iGlobalTime * 20.0 + raster * 16.0)), 0.5);\r\n\t\tvCol = mix(vec3(1.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0), fBlend);                     \r\n\t}\r\n\t\r\n\treturn vCol;\r\n}\r\n \r\n \r\nfloat GetLoadingScreenIntensity( vec2 vPos )\r\n{\r\n\tvec2 vUV = vPos \/ kResolution;\r\n\tfloat r = 0.25;\r\n\tvec2 vDist = (vUV - 0.5) \/ r;\r\n\tfloat len = length(vDist);\r\n\tvec3 vNormal = vec3(vDist.x, sqrt(1.0 - len * len), vDist.y);\r\n\tvec3 vLight = normalize( vec3(1.0, 1.0, -1.0) );\r\n\tif(len < 1.0)\r\n\t{\r\n\t\treturn max(0.0, dot(vNormal, vLight));\r\n\t}\r\n\t\r\n\treturn 0.7 - vUV.y * 0.6;\r\n}\r\n \r\nfloat CrossHatch(float fIntensity, vec2 vPos)\r\n{\r\n\tvec2 vGridPos = mod(vPos, 4.0);\r\n\t\r\n\tfloat fThreshold = fract(vGridPos.x * 0.25 + vGridPos.y * 0.5) * 0.75 + fract(vGridPos.y * 0.25 + vGridPos.x * 0.5) * 0.25;\r\n\t\r\n\treturn step(fIntensity, fThreshold);\r\n}\r\n \r\nfloat GetLoadingScreenPixel( vec2 vPos )\r\n{\r\n        return CrossHatch(GetLoadingScreenIntensity(vPos), vPos);\r\n}\r\n \r\nvec2 GetScreenPixelCoord( vec2 vScreenUV )\r\n{\r\n        vec2 vPixelPos = floor(vScreenUV * kResolution);\r\n        vPixelPos.y = 192.0 - vPixelPos.y;\r\n       \r\n        return vPixelPos;\r\n}\r\n \r\nfloat PixelAddress( vec2 vPixelPos )\r\n{               \r\n        float fBand = floor(vPixelPos.y \/ 64.0);\r\n       \r\n        float fBandPos = mod(vPixelPos.y, 64.0);\r\n \r\n        float fCharRow = mod(fBandPos, 8.0);\r\n        float fCharPos = floor(fBandPos \/ 8.0);\r\n \r\n        float fBytePos = floor(vPixelPos.x \/ 8.0);\r\n \r\n        float fLineTime = fBand * 64.0 + fCharRow * 8.0 + fCharPos;\r\n        return (fBytePos + fLineTime * (256.0 \/ 8.0));\r\n}\r\n \r\nfloat AttributeAddress(vec2 vCharPos)\r\n{             \r\n\tfloat kAttributeStart = 256.0 * 192.0 \/ 8.0;\r\n\treturn kAttributeStart + vCharPos.x + vCharPos.y * 32.0;\r\n}\r\n \r\nfloat GetCharByte(const in float value)\r\n{\r\n        float result = 0.0;\r\n        result = mix(result, 0.0, step(value, 919.0) );\r\n        result = mix(result, 32.0, step(value, 918.5) );\r\n        result = mix(result, 28.0, step(value, 914.5) );\r\n        result = mix(result, 0.0, step(value, 913.5) );\r\n        result = mix(result, 56.0, step(value, 894.5) );\r\n        result = mix(result, 68.0, step(value, 893.5) );\r\n        result = mix(result, 56.0, step(value, 890.5) );\r\n        result = mix(result, 0.0, step(value, 889.5) );\r\n        result = mix(result, 84.0, step(value, 878.5) );\r\n        result = mix(result, 104.0, step(value, 874.5) );\r\n        result = mix(result, 0.0, step(value, 873.5) );\r\n        result = mix(result, 56.0, step(value, 851.5) );\r\n        result = mix(result, 4.0, step(value, 830.5) );\r\n        result = mix(result, 60.0, step(value, 829.5) );\r\n        result = mix(result, 68.0, step(value, 828.5) );\r\n        result = mix(result, 60.0, step(value, 826.5) );\r\n        result = mix(result, 0.0, step(value, 825.5) );\r\n        result = mix(result, 60.0, step(value, 782.5) );\r\n        result = mix(result, 68.0, step(value, 781.5) );\r\n        result = mix(result, 60.0, step(value, 780.5) );\r\n        result = mix(result, 4.0, step(value, 779.5) );\r\n        result = mix(result, 56.0, step(value, 778.5) );\r\n        result = mix(result, 0.0, step(value, 777.5) );\r\n        result = mix(result, 60.0, step(value, 670.5) );\r\n        result = mix(result, 66.0, step(value, 669.5) );\r\n        result = mix(result, 2.0, step(value, 668.5) );\r\n        result = mix(result, 60.0, step(value, 667.5) );\r\n        result = mix(result, 64.0, step(value, 666.5) );\r\n        result = mix(result, 60.0, step(value, 665.5) );\r\n        result = mix(result, 0.0, step(value, 664.5) );\r\n        result = mix(result, 64.0, step(value, 646.5) );\r\n        result = mix(result, 124.0, step(value, 644.5) );\r\n        result = mix(result, 66.0, step(value, 643.5) );\r\n        result = mix(result, 124.0, step(value, 641.5) );\r\n        result = mix(result, 0.0, step(value, 640.5) );\r\n        result = mix(result, 60.0, step(value, 638.5) );\r\n        result = mix(result, 66.0, step(value, 637.5) );\r\n        result = mix(result, 60.0, step(value, 633.5) );\r\n        result = mix(result, 0.0, step(value, 632.5) );\r\n        result = mix(result, 66.0, step(value, 630.5) );\r\n        result = mix(result, 70.0, step(value, 629.5) );\r\n        result = mix(result, 74.0, step(value, 628.5) );\r\n        result = mix(result, 82.0, step(value, 627.5) );\r\n        result = mix(result, 98.0, step(value, 626.5) );\r\n        result = mix(result, 66.0, step(value, 625.5) );\r\n        result = mix(result, 0.0, step(value, 624.5) );\r\n        result = mix(result, 126.0, step(value, 614.5) );\r\n        result = mix(result, 64.0, step(value, 613.5) );\r\n        result = mix(result, 0.0, step(value, 608.5) );\r\n        result = mix(result, 62.0, step(value, 590.5) );\r\n        result = mix(result, 8.0, step(value, 589.5) );\r\n        result = mix(result, 62.0, step(value, 585.5) );\r\n        result = mix(result, 0.0, step(value, 584.5) );\r\n        result = mix(result, 60.0, step(value, 574.5) );\r\n        result = mix(result, 66.0, step(value, 573.5) );\r\n        result = mix(result, 78.0, step(value, 572.5) );\r\n        result = mix(result, 64.0, step(value, 571.5) );\r\n        result = mix(result, 66.0, step(value, 570.5) );\r\n        result = mix(result, 60.0, step(value, 569.5) );\r\n        result = mix(result, 0.0, step(value, 568.5) );\r\n        result = mix(result, 120.0, step(value, 550.5) );\r\n        result = mix(result, 68.0, step(value, 549.5) );\r\n        result = mix(result, 66.0, step(value, 548.5) );\r\n        result = mix(result, 68.0, step(value, 546.5) );\r\n        result = mix(result, 120.0, step(value, 545.5) );\r\n        result = mix(result, 0.0, step(value, 544.5) );\r\n        result = mix(result, 66.0, step(value, 526.5) );\r\n        result = mix(result, 126.0, step(value, 524.5) );\r\n        result = mix(result, 66.0, step(value, 523.5) );\r\n        result = mix(result, 60.0, step(value, 521.5) );\r\n        result = mix(result, 0.0, step(value, 520.5) );\r\n        result = mix(result, 16.0, step(value, 470.5) );\r\n        result = mix(result, 0.0, step(value, 469.5) );\r\n        result = mix(result, 16.0, step(value, 467.5) );\r\n        result = mix(result, 0.0, step(value, 466.5) );\r\n        return result;   \r\n}\r\n \r\nfloat GetBit( float fByte, float fBit )\r\n{\r\n        return mod(floor(fByte \/ pow(2.0, 7.0-fBit)), 2.0) ;\r\n}\r\n \r\nfloat GetCharPixel( float fChar, vec2 vPos )\r\n{\r\n        float fCharAddress = fChar * 8.0 + vPos.y;\r\n       \r\n        float fCharBin = GetCharByte(fCharAddress);\r\n       \r\n        return GetBit(fCharBin, vPos.x);\r\n}\r\n \r\nfloat GetProgramStringChar(float fPos)\r\n{\r\n        float fChar = 32.0;    \r\n        fChar = mix(fChar, 76.0, step(fPos, 12.5) );\r\n        fChar = mix(fChar, 83.0, step(fPos, 11.5) );\r\n        fChar = mix(fChar, 76.0, step(fPos, 10.5) );\r\n        fChar = mix(fChar, 71.0, step(fPos, 9.5) );\r\n        fChar = mix(fChar, 32.0, step(fPos, 8.5) );\r\n        fChar = mix(fChar, 58.0, step(fPos, 7.5) );\r\n        fChar = mix(fChar, 109.0, step(fPos, 6.5) );\r\n        fChar = mix(fChar, 97.0, step(fPos, 5.5) );\r\n        fChar = mix(fChar, 114.0, step(fPos, 4.5) );\r\n        fChar = mix(fChar, 103.0, step(fPos, 3.5) );\r\n        fChar = mix(fChar, 111.0, step(fPos, 2.5) );\r\n        fChar = mix(fChar, 114.0, step(fPos, 1.5) );\r\n        fChar = mix(fChar, 80.0, step(fPos, 0.5) );\r\n        return fChar;\r\n}\r\n \r\nfloat GetLoadingStringChar(float fPos)\r\n{\r\n        float fChar = 32.0;    \r\n        fChar = mix(fChar, 76.0, step(fPos, 11.0) );\r\n        fChar = mix(fChar, 83.0, step(fPos, 10.5) );\r\n        fChar = mix(fChar, 76.0, step(fPos, 9.5) );\r\n        fChar = mix(fChar, 71.0, step(fPos, 8.5) );\r\n        fChar = mix(fChar, 32.0, step(fPos, 7.5) );\r\n        fChar = mix(fChar, 71.0, step(fPos, 6.5) );\r\n        fChar = mix(fChar, 78.0, step(fPos, 5.5) );\r\n        fChar = mix(fChar, 73.0, step(fPos, 4.5) );\r\n        fChar = mix(fChar, 68.0, step(fPos, 3.5) );\r\n        fChar = mix(fChar, 65.0, step(fPos, 2.5) );\r\n        fChar = mix(fChar, 79.0, step(fPos, 1.5) );\r\n        fChar = mix(fChar, 76.0, step(fPos, 0.5) );\r\n        return fChar;\r\n}\r\n \r\nfloat GetProgramText(vec2 vPixelPos)\r\n{     \r\n        vec2 vCharCoord = floor(vPixelPos \/ 8.0);\r\n       \r\n        float fChar = GetProgramStringChar(vCharCoord.x);\r\n       \r\n        if(vCharCoord.y != 0.0)\r\n                fChar = 32.0;\r\n       \r\n        return GetCharPixel(fChar, mod(vPixelPos, 8.0));\r\n}\r\n \r\nfloat GetLoadingText(vec2 vPixelPos)\r\n{     \r\n        vec2 vCharCoord = floor(vPixelPos \/ 8.0);\r\n       \r\n        float fChar = GetLoadingStringChar(vCharCoord.x);\r\n       \r\n        float inString = 1.0;\r\n        if(vCharCoord.x < 0.0)\r\n                fChar = 32.0;\r\n       \r\n        if(vCharCoord.y != 0.0)\r\n                fChar = 32.0;\r\n       \r\n        return GetCharPixel(fChar, mod(vPixelPos, 8.0));\r\n}\r\n \r\nfloat GetScreenPixel(vec2 vScreenPixel)\r\n{\r\n\t\/\/ plasma thing\r\n\tfloat f = sin(vScreenPixel.x *0.0432 + sin(vScreenPixel.y * 0.0423)+ iGlobalTime * 3.0);\r\n\tf = f + sin(vScreenPixel.y * 0.0454513 + sin(vScreenPixel.x * 0.07213) + iGlobalTime * 5.0);\r\n\tf = f + sin(vScreenPixel.x * 0.043353 + sin(vScreenPixel.y * 0.043413) + iGlobalTime * 8.0);\r\n\tf = f + sin(vScreenPixel.y * 0.0443513 + sin(vScreenPixel.x * 0.036313) + iGlobalTime * 10.0);\r\n\tf = f * 0.125 + 0.5;\r\n\t\r\n\treturn CrossHatch(f, vScreenPixel);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{           \r\n\tfloat fSequenceTime = iGlobalTime;\r\n\t\r\n\t#ifdef LOADING_LOOP\r\n\tfSequenceTime = mod(fSequenceTime, vTimeTotal.y);\r\n\t#endif\r\n\t\r\n\tvec3 col = vec3(1.0);\r\n\t\r\n\tvec4 vPhase = GetPhase(fSequenceTime);\r\n\t\r\n\tvec2 vUV = ( fragCoord.xy \/ iResolution.xy );\r\n\tvec2 vScreenUV = (vUV - 0.1) \/ 0.8;\r\n\tif(IsBorder(vScreenUV) > 0.0)\r\n\t{\r\n\t\tcol = GetBorderColour(vPhase.x, fragCoord);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tvec2 vScreenCoord = GetScreenPixelCoord(vScreenUV);\r\n\t\tvec2 vAttribCoord = floor(vScreenCoord \/ 8.0);\r\n\r\n\t\tfloat fPixelValue = 0.0;\r\n\t\tvec3 vInk = vec3(0.0);\r\n\t\tvec3 vPaper = vec3(1.0);\r\n\t\t\r\n\t\tif(vPhase.x != kPhaseRunning)\r\n\t\t{\r\n\t\t\t\/\/ loading\r\n\t\t\tfloat fLoadScreenTime = fSequenceTime - vTimeHeader4.y;\r\n\t\t\t\t\t\t\t\t\t\t       \r\n\t\t\tfloat fAddressLoaded = fLoadScreenTime * 192.0;\r\n\t\t\tif(PixelAddress(vScreenCoord) > fAddressLoaded)\r\n\t\t\t{\r\n\t\t\t\tif(vPhase.y < 4.0)\r\n\t\t\t\t{\r\n\t\t\t\t\tcol = vec3(1.0);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\tif(vPhase.y < 8.0)\r\n\t\t\t\t{\r\n\t\t\t\t\tvec2 vTextPos = vec2(0.0, 8.0);\r\n\t\t\t\t\tfPixelValue = GetProgramText(vScreenCoord - vTextPos);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tvec2 vTextPos = vec2(10.0 * 8.0, 19.0 * 8.0);\r\n\t\t\t\t\tfPixelValue = GetLoadingText(vScreenCoord - vTextPos);\r\n\t\t\t\t}\t\t\t\t\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t\/\/ loading screen\r\n\t\t\t\tfPixelValue = GetLoadingScreenPixel(vScreenCoord);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t}\r\n\t\t\r\n\t\t\tif(AttributeAddress(vAttribCoord) < fAddressLoaded)\r\n\t\t\t{\r\n\t\t\t\tvInk = vec3(0.0, 0.0, 1.0);\r\n\t\t\t\tvPaper = vec3(1.0, 1.0, 0.0);\r\n\t\t\t}\t\t\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t\/\/ running\r\n\t\t\tfPixelValue = GetScreenPixel(vScreenCoord);\r\n\t\t\t\r\n\t\t\tvec2 vTextPos = vec2(-8.0 * 8.0, 8.0);\r\n\t\t\tfloat fAttribValue = GetLoadingText(vAttribCoord - vTextPos );\r\n\t\t\tvPaper = mix(vec3(0.0, 1.0, 1.0), vec3(1.0, 0.0, 0.0), fAttribValue);\r\n\t\t\tvInk = vec3(0.0, 0.0, 1.0);\r\n\t\t}     \r\n\t\r\n\t\t\/\/fPixelValue = GetScreenPixel(vScreenCoord); \/\/ force final effect\t\t\t\r\n\t\t\/\/fPixelValue = GetLoadingScreenPixel( vScreenCoord); \/\/ force loading screen\r\n\t\r\n\t\tcol = mix(vPaper, vInk, fPixelValue);\r\n\t\t\r\n\t}\r\n\r\n\tfloat kBrightness = 0.8;\r\n\tfragColor = vec4( col * kBrightness, 1.0 );  \r\n}","name":"","description":"","type":"image"},{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Border phases\n\nfloat kPhaseBlank = 0.0;\nfloat kPhaseSilent = 1.0;\nfloat kPhaseHeader = 2.0;\nfloat kPhaseData = 3.0;\nfloat kPhaseRunning = 4.0;\n \n\/\/ Loading phases\n\nvec3 vTimeSilent1  = vec3(1.0,\t5.0,                       kPhaseSilent);\nvec3 vTimeHeader1  = vec3(2.0,  vTimeSilent1.y + 2.0,      kPhaseHeader);\nvec3 vTimeData1    = vec3(3.0,  vTimeHeader1.y + 0.125,    kPhaseData);\n \nvec3 vTimeBlank2   = vec3(4.0,  vTimeData1.y + 1.0,        kPhaseBlank);\nvec3 vTimeSilent2  = vec3(5.0,  vTimeBlank2.y + 2.0,       kPhaseSilent);\nvec3 vTimeHeader2  = vec3(6.0,  vTimeSilent2.y + 2.0,      kPhaseHeader);\nvec3 vTimeData2    = vec3(7.0,  vTimeHeader2.y + 1.0,      kPhaseData);\n \nvec3 vTimeSilent3  = vec3(8.0,  vTimeData2.y + 2.0,        kPhaseSilent);\nvec3 vTimeHeader3  = vec3(9.0,  vTimeSilent3.y + 2.0,      kPhaseHeader);\nvec3 vTimeData3    = vec3(10.0, vTimeHeader3.y + 0.125,    kPhaseData);\n \nvec3 vTimeSilent4  = vec3(11.0, vTimeData3.y + 2.0,        kPhaseSilent);\nvec3 vTimeHeader4  = vec3(12.0, vTimeSilent4.y + 2.0,      kPhaseHeader);\nvec3 vTimeData4    = vec3(13.0, vTimeHeader4.y + 38.0,     kPhaseData);\n \nvec3 vTimeRunning  = vec3(14.0, vTimeData4.y + 10.0,       kPhaseRunning);\n \nvec3 vTimeTotal    = vec3(15.0, vTimeRunning.y,            kPhaseBlank);\n       \nvec4 GetPhase(float fTime)\n{             \n    vec3 vResult = vTimeRunning;\n\n    vResult = mix( vResult, vTimeData4, step(fTime, vTimeData4.y ) );\n    vResult = mix( vResult, vTimeHeader4, step(fTime, vTimeHeader4.y ) );\n    vResult = mix( vResult, vTimeSilent4, step(fTime, vTimeSilent4.y ) );\n\n    vResult = mix( vResult, vTimeData3, step(fTime, vTimeData3.y ) );\n    vResult = mix( vResult, vTimeHeader3, step(fTime, vTimeHeader3.y ) );\n    vResult = mix( vResult, vTimeSilent3, step(fTime, vTimeSilent3.y ) );\n\n    vResult = mix( vResult, vTimeData2, step(fTime, vTimeData2.y ) );\n    vResult = mix( vResult, vTimeHeader2, step(fTime, vTimeHeader2.y ) );\n    vResult = mix( vResult, vTimeSilent2, step(fTime, vTimeSilent2.y ) );\n    vResult = mix( vResult, vTimeBlank2, step(fTime, vTimeBlank2.y ) );\n\n    vResult = mix( vResult, vTimeData1, step(fTime, vTimeData1.y ) );\n    vResult = mix( vResult, vTimeHeader1, step(fTime, vTimeHeader1.y ) );\n    vResult = mix( vResult, vTimeSilent1, step(fTime, vTimeSilent1.y ) );\n\n    return vec4(vResult.z, vResult.x, fTime - vResult.y, vResult.y);\n}\n\n\/\/ Thanks Dave_Hoskins for the hash - https:\/\/www.shadertoy.com\/view\/4djSRW\nfloat hash(const in float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nfloat GetAudio(float fTime)\n{\n    float fPhase = GetPhase(fTime).x;\n\t\n    float fLoadScreenTime = fTime - vTimeHeader4.y;\n    \n    float fSignal = 0.0;\n\t\n\tif(fPhase == kPhaseBlank)\n\t{                       \n\t\tfSignal = 0.0;           \n\t}\n\telse  \n\tif(fPhase == kPhaseSilent)\n\t{\n\t\tfSignal = 0.0;          \n\t}\n\telse\n\tif(fPhase == kPhaseHeader)\n\t{\n\t\tfloat fFreq = 3500000.0 \/ 2168.0;\n        fFreq *= 0.5;\n\t\tfloat fBlend = step(fract(fTime * fFreq), 0.5);\n\t\tfSignal = fBlend;           \n\t}\n\telse\n\tif(fPhase == kPhaseData)\n\t{\n\t\tfloat fFreq = 3500000.0 \/ 1710.0;\n        float fWaveTime = fTime * fFreq;\n\n        float fDataHashPos = floor(fWaveTime);\n        \n        \/\/ Attribute loading sounds\n        float kAttributeStart = 256.0 * 192.0 \/ 8.0;    \n        float kAttributeEnd = kAttributeStart + (32.0 * 24.0);    \n        float fAddressLoaded = fLoadScreenTime * 192.0;\n\t\tif( (fAddressLoaded > kAttributeStart) && (fAddressLoaded < kAttributeEnd) )\n        {\n            fDataHashPos = mod(fDataHashPos, 8.0);\n        }\n\n        \n        float fValue = hash(fDataHashPos);\n        \n        \n        float fr = fract(fWaveTime);\n        if(fValue > 0.5)\n        {\n            fr = fract(fr * 2.0);\n        }\n        float fBlend = step(fr, 0.5);\n\n\t\tfSignal = fBlend;                   \n\t}\n\t\n\treturn fSignal;\n}\n \n\nvec2 mainSound(float time)\n{\n    return vec2( GetAudio(time) * 2.0 - 1.0 ) * 0.2;\n}","name":"","description":"","type":"sound"}]}}