{"Shader":{"ver":"0.1","info":{"id":"XsK3RR","date":"1453044878","viewed":230,"name":"1D Radial Lightmap Test","username":"Flyguy","description":" Testing 2D lightmaps rendered as 1D distance fields which contain the distance to intersection at a given angle around the light. This is based off the method shown here: https:\/\/git.io\/vzWmd","likes":12,"published":3,"flags":32,"tags":["2d","shadow","light","distance"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define NUM_LIGHTS 6\n#define WALL_COLOR vec3(1.0, 0.5, 0.1)\n#define FLOOR_COLOR vec3(0.4, 0.4, 0.4)\n#define AMBIENT_LIGHT vec3(0.1, 0.1, 0.1)\n\/\/#define SHOW_SHADOWMAP\n\n#define INF 1e8\n#define EPS 1e-3\nfloat tau = atan(1.0)*8.0;\n\n\/\/Globals\nvec2 res = vec2(0); \/\/Y-Normalized resolution\nvec2 mouse = vec2(0); \/\/Mouse coords (form center)\nfloat psz = 0.0; \/\/Pixel size\nvec2 hpo = vec2(0); \/\/Half pixel offset\n\n\/\/ Shapes\nfloat sdCircle(float r, vec2 uv)\n{\n\treturn length(uv) - r;    \n}\n\nfloat sdRing(float ir, float or, vec2 uv)\n{\n\treturn abs(length(uv) - (ir+or)\/2.0) - (or - ir);   \n}\n\nfloat sdBox(float s, vec2 uv)\n{\n\treturn max(abs(uv.x), abs(uv.y)) - s;   \n}\n\nfloat sdRect(vec2 s, vec2 uv)\n{\n    uv = abs(uv) - s;\n\treturn max(uv.x, uv.y);\n}\n\nfloat sdPlane(vec2 dir, vec2 uv)\n{\n\treturn dot(normalize(dir), uv);   \n}\n\n\/\/ Operations\nfloat opU(float a, float b)\n{\n\treturn min(a, b);   \n}\n\nfloat opI(float a, float b)\n{\n\treturn max(a, b);   \n}\n\nfloat opS(float a, float b)\n{\n\treturn max(-a, b);   \n}\n\n\/\/Domain modifiers\nmat2 Rotate(float a)\n{\n\treturn mat2(cos(a), sin(a),-sin(a), cos(a));   \n}\n\nvec2 Rep1(vec2 uv, float r)\n{\n\tuv.x = mod(uv.x, r) - r\/2.0;\n    return uv;\n}\n\nvec2 Rep2(vec2 uv, vec2 r)\n{\n\treturn mod(uv, r) - r\/2.0;  \n}\n\n\/\/ Scene function (must be changed in both tabs)\nfloat Scene(vec2 uv)\n{\n\tfloat d = -sdRect(res\/2.0 - 0.05, uv);\n    \n    vec2 rp = Rep2(uv, vec2(0.2));\n    \n    d = opU(sdCircle(0.02, rp), d);\n    \n    rp = Rep1(uv, 0.2);\n    \n    d = opU(sdRect(vec2(0.005,0.1), rp), d);\n    \n    d = opS(sdBox(0.2, uv), d);\n    \n    d = opU(sdRing(0.08, 0.09, uv), d);\n    \n    d = opS(sdRect(vec2(0.11,0.03), uv * Rotate(iGlobalTime)), d);\n    \n    return d;\n}\n\nvec2 LightOrigin(int id)\n{\n\treturn texture2D(iChannel0,vec2(0, float(id))\/iResolution.xy + hpo).yz;   \n}\n\nvec3 LightColor(int id)\n{\n\treturn texture2D(iChannel0,vec2(1, float(id))\/iResolution.xy + hpo).yzw;   \n}\n\nfloat SampleShadow(int id, vec2 uv)\n{\n    float a = atan(uv.y, uv.x)\/tau + 0.5;\n    float r = length(uv);\n    \n    float idn = float(id)\/iResolution.y;\n    \n    float s = texture2D(iChannel0, vec2(a, idn) + hpo).x;\n    \n    return 1.0-smoothstep(s, s+0.02, length(uv));    \n}\n\n\/\/Reads lights from light buffer and combines them.\nvec3 MixLights(vec2 uv)\n{\n    vec3 b = AMBIENT_LIGHT;\n    \n\tfor(int i = 0;i < NUM_LIGHTS;i++)\n    {\n        vec2 o = LightOrigin(i);\n        vec3 c = LightColor(i);\n        \n        float l = 0.01 \/ pow(length(vec3(uv - o, 0.1)), 2.0);\n        l *= SampleShadow(i, uv-o);\n        b += c * l;\n    }\n    \n    return b;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    hpo = 0.5 \/ iResolution.xy;\n    res = iResolution.xy \/ iResolution.y;\n    psz = 1.0 \/ iResolution.y;\n\tvec2 uv = fragCoord.xy \/ iResolution.y - res\/2.0;\n    \n    mouse = iMouse.xy \/ iResolution.y - res\/2.0;\n    \n    vec3 col = vec3(0);\n    \n    float d = Scene(uv);\n    \n    col = mix(FLOOR_COLOR, WALL_COLOR, smoothstep(psz, 0.0, d));\n    \n    col *= MixLights(uv);\n    \n    #ifdef SHOW_SHADOWMAP\n    col = texture2D(iChannel0, fragCoord\/iResolution.xy).rgb;\n    #endif\n    \n\tfragColor = vec4(col, 1.0);\n} ","name":"","description":"","type":"image"},{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/1D Distance field shadow map.\n\/\/Each row is a radial shadow map for a light.\n\/\/r = distance\n\/\/gba = light info (position \/ color)\n\n#define MAX_STEPS 48\n#define INF 1e8\n#define EPS 1e-4\nfloat tau = atan(1.0)*8.0;\n\n\/\/Globals\nvec2 res = vec2(0);\nvec2 mouse = vec2(0);\n\n\/\/ Shapes\nfloat sdCircle(float r, vec2 uv)\n{\n\treturn length(uv) - r;    \n}\n\nfloat sdRing(float ir, float or, vec2 uv)\n{\n\treturn abs(length(uv) - (ir+or)\/2.0) - (or - ir);   \n}\n\nfloat sdBox(float s, vec2 uv)\n{\n\treturn max(abs(uv.x), abs(uv.y)) - s;   \n}\n\nfloat sdRect(vec2 s, vec2 uv)\n{\n    uv = abs(uv) - s;\n\treturn max(uv.x, uv.y);\n}\n\nfloat sdPlane(vec2 dir, vec2 uv)\n{\n\treturn dot(normalize(dir), uv);   \n}\n\n\/\/ Operations\nfloat opU(float a, float b)\n{\n\treturn min(a, b);   \n}\n\nfloat opI(float a, float b)\n{\n\treturn max(a, b);   \n}\n\nfloat opS(float a, float b)\n{\n\treturn max(-a, b);   \n}\n\n\/\/Domain modifiers\nmat2 Rotate(float a)\n{\n\treturn mat2(cos(a), sin(a),-sin(a), cos(a));   \n}\n\nvec2 Rep1(vec2 uv, float r)\n{\n\tuv.x = mod(uv.x, r) - r\/2.0;\n    return uv;\n}\n\nvec2 Rep2(vec2 uv, vec2 r)\n{\n\treturn mod(uv, r) - r\/2.0;  \n}\n\n\/\/ Scene function (must be changed in both tabs)\nfloat Scene(vec2 uv)\n{\n\tfloat d = -sdRect(res\/2.0 - 0.05, uv);\n    \n    vec2 rp = Rep2(uv, vec2(0.2));\n    \n    d = opU(sdCircle(0.02, rp), d);\n    \n    rp = Rep1(uv, 0.2);\n    \n    d = opU(sdRect(vec2(0.005,0.1), rp), d);\n    \n    d = opS(sdBox(0.2, uv), d);\n    \n    d = opU(sdRing(0.08, 0.09, uv), d);\n    \n    d = opS(sdRect(vec2(0.11,0.03), uv * Rotate(iGlobalTime)), d);\n    \n    return d;\n}\n\nfloat MarchShadow(vec2 orig, vec2 dir)\n{\n    float d = 0.0;\n    \n    for(int i = 0;i < MAX_STEPS;i++)\n    {\n        float ds = Scene(dir * d - orig);\n        \n        d += ds;\n        \n        if(ds < EPS)\n        {\n        \tbreak;   \n        }\n    }\n    \n    return d;\n}\n\n\/\/Data slots\n#define SLOT_POSITION 0\n#define SLOT_COLOR 1\n\nstruct Light\n{\n\tvec2 origin;\n    vec3 color;\n    float brightness;\n    \n};\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    res = iResolution.xy \/ iResolution.y;  \n    mouse = iMouse.xy \/ iResolution.y - res\/2.0;\n    \n    float a = (fragCoord.x \/ iResolution.x) * tau;\n    vec2 dir = vec2(cos(a), sin(a));\n    \n    int id = int(fragCoord.y);\n    \n    Light light;\n    \n    light.origin = vec2(0);\n    light.color = vec3(0);\n    light.brightness = 0.0;\n    \n    if(id == 0)\n    {\n    \tlight.origin = vec2(0);\n        light.color = vec3(1.0, 0.2, 0.2);\n        light.brightness = sin(iGlobalTime * 4.0) * 2.0 + 2.0;\n    }\n    \n    if(id == 1)\n    {\n    \tlight.origin = mouse;\n        light.color = vec3(1.0, 0.6, 0.6);\n        light.brightness = 2.0;\n    }\n    if(id == 2)\n    {\n    \tlight.origin = -mouse;\n        light.color = vec3(0.6, 1.0, 0.6);\n        light.brightness = 2.0;\n    }\n    if(id == 3)\n    {\n        float a = -iGlobalTime * 0.3;\n    \tlight.origin = vec2(cos(a), sin(a)) * 0.2; \n        light.color = vec3(0.4, 0.4, 1.0);\n        light.brightness = 4.0;\n    }\n    if(id == 4)\n    {\n    \tlight.origin = vec2(0.4, sin(3.0*iGlobalTime-tau\/4.0)*0.2); \n        light.color = vec3(1.0, 1.0, 0.4);\n        light.brightness = 1.0;\n    }\n    if(id == 5)\n    {\n    \tlight.origin = vec2(-0.4, sin(3.0*iGlobalTime)*0.2); \n        light.color = vec3(1.0, 0.4, 1.0);\n        light.brightness = 1.0;\n    }\n    \n    int slot = int(fragCoord.x);\n    vec3 data = vec3(0);\n    \n    if(slot == SLOT_POSITION)\n    {\n        data = vec3(light.origin,0);\n    }\n    \n    if(slot == SLOT_COLOR)\n    {\n    \tdata = light.brightness * light.color;   \n    }\n    \n    float dist = MarchShadow(light.origin, dir);\n     \n\tfragColor = vec4(dist, data);\n} ","name":"","description":"","type":"buffer"}]}}