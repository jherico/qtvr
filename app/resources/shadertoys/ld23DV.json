{"Shader":{"ver":"0.1","info":{"id":"ld23DV","date":"1393881136","viewed":1435,"name":"Box - intersection","username":"iq","description":"Intersection of a ray and a box. The ray is transformed to box space, and the returned normal is converted back to ray space upon intersection. If there were many boxes to be intersected oriented the same way, the transformations should be done only once.","likes":16,"published":3,"flags":0,"tags":["3d","raytracing","box"],"hasliked":0},"renderpass":[{"inputs":[{"id":3,"src":"\/presets\/tex02.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Ray-Box intersection, by convertig the ray to the local space of the box.\n\/\/\n\/\/ If this was used to raytace many equally orietned boxes (saym you are traversing a BVH,\n\/\/ then the transformations in line 15 and 16, and the computations of m and n could be\n\/\/ precomputed for the whole set of cubes. You probably wouldn't need line 31 and 35 either.\n\n\n\/\/ returns t and normal\nvec4 iBox( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n    \/\/ convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t\/\/ ray-box intersection in box space\n    vec3 m = 1.0\/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec4(-1.0);\n\n\tvec3 nor = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    \/\/ convert to ray space\n\t\n\tnor = (txi * vec4(nor,0.0)).xyz;\n\n\treturn vec4( tN, nor );\n}\n\n\nfloat sBox( in vec3 ro, in vec3 rd, in mat4 txx, in vec3 rad ) \n{\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n    vec3 m = 1.0\/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return -1.0;\n\t\n\treturn tN;\n}\n\n\n\/\/-----------------------------------------------------------------------------------------\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\nmat4 inverse( in mat4 m )\n{\n\treturn mat4(\n        m[0][0], m[1][0], m[2][0], 0.0,\n        m[0][1], m[1][1], m[2][1], 0.0,\n        m[0][2], m[1][2], m[2][2], 0.0,\n        -dot(m[0].xyz,m[3].xyz),\n        -dot(m[1].xyz,m[3].xyz),\n        -dot(m[2].xyz,m[3].xyz),\n        1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) \/ iResolution.y;\n\n     \/\/ camera movement\t\n\tfloat an = 0.4*iGlobalTime;\n\tvec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 0.8, 0.0 );\n    \/\/ camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t\/\/ create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n    \/\/ rotate and translate box\t\n\tmat4 rot = rotationAxisAngle( normalize(vec3(1.0,1.0,0.0)), iGlobalTime );\n\tmat4 tra = translate( 0.0, 1.0, 0.0 );\n\tmat4 txi = tra * rot; \n\tmat4 txx = inverse( txi );\n\n    \/\/ raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tvec3  pos = vec3(0.0);\n\t\n\t\/\/ raytrace-plane\n\tfloat oid = 0.0;\n\tfloat h = (0.0-ro.y)\/rd.y;\n\tif( h>0.0 ) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.0,1.0,0.0); \n\t\toid = 1.0;\n\t}\n\n\t\/\/ raytrace box\n\tvec3 box = vec3(0.4,0.6,0.8) ;\n\tvec4 res = iBox( ro, rd, txx, txi, box);\n\tif( res.x>0.0 && res.x<tmin )\n\t{\n\t\ttmin = res.x; \n\t\tnor = res.yzw;\n\t\toid = 2.0;\n\t}\n\n    \/\/ shading\/lighting\t\n\tvec3 col = vec3(0.9);\n\tif( tmin<100.0 )\n\t{\n        vec3 lig = normalize(vec3(-0.8,0.4,0.1));\n\t\tpos = ro + tmin*rd;\n\t\t\n        \/\/ material\n\t\tfloat occ = 1.0;\n\t\tvec3  mate = vec3(1.0);\n\t\tif( oid<1.5 ) \/\/ plane\n\t\t{\n\t\t    mate = texture2D( iChannel0, 0.25*pos.xz ).xyz;\n\t\t\tocc = 0.2 + 0.8*smoothstep( 0.0, 1.5, length(pos.xz) );\n\t\t}\t\t\t\n\t\telse \/\/ box\n\t\t{\n            \/\/ recover box space data (we want to do shading in object space)\t\t\t\n\t\t    vec3 opos = (txx*vec4(pos,1.0)).xyz;\n\t\t\tvec3 onor = (txx*vec4(nor,0.0)).xyz;\n\t\t    mate = abs(onor.x)*texture2D( iChannel0, 0.5*opos.yz ).xyz + \n                   abs(onor.y)*texture2D( iChannel0, 0.5*opos.zx ).xyz + \n                   abs(onor.z)*texture2D( iChannel0, 0.5*opos.xy ).xyz;\n\t\t\t\n\t\t\t\/\/ wireframe\n\t\t\tmate *= 1.0 - (1.0-abs(onor.x))*smoothstep( box.x-0.04, box.x-0.02, abs(opos.x) );\n\t\t\tmate *= 1.0 - (1.0-abs(onor.y))*smoothstep( box.y-0.04, box.y-0.02, abs(opos.y) );\n\t\t\tmate *= 1.0 - (1.0-abs(onor.z))*smoothstep( box.z-0.04, box.z-0.02, abs(opos.z) );\n\n\t\t\tocc = 0.6 + 0.4*nor.y;\n\t\t}\t\t\n\t\tmate = mate*mate*1.5;\n\t\t\n\t\t\/\/ lighting\n\t\tfloat dif = clamp( dot(nor,lig), 0.0, 1.0 );\n\t\tdif *= step( sBox( pos+0.01*nor, lig, txx, box ), 0.0 );\n\t\tcol = vec3(0.13,0.17,0.2)*occ*3.0 + 1.5*dif*vec3(1.0,0.9,0.8);\n\n        \/\/ material * lighting\t\t\n\t\tcol *= mate;\n\n        \/\/ fog\n\t\tcol = mix( col, vec3(0.9), 1.0-exp( -0.003*tmin*tmin ) );\n\t}\n\t\n\tcol = sqrt( col );\n\n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}