{"Shader":{"ver":"0.1","info":{"id":"MlsSzf","date":"1439221890","viewed":3003,"name":"[SIG15] The DeLorean","username":"P_Malin","description":"Ironically running out of time to do everything I wanted - I should have started this a lot sooner. <br\/>Thanks to my wife for her infinite patience.","likes":43,"published":3,"flags":8,"tags":["sig15","delorean"],"hasliked":0},"renderpass":[{"inputs":[{"id":4,"src":"\/presets\/tex03.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":27,"src":"\/presets\/cube05_0.png","ctype":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ [SIG15] The DeLorean\n\/\/ @P_Malin\n\n\/\/ Entry for @shadertoy [SIG15] competition\n\n\/\/ Ironically running out of time to do everything I wanted - I should have started this a lot sooner. \n\/\/ Thanks to my wife for her infinite patience.\n\n\/\/ Performance\n\/\/#define SIMPLE_CAR\n\/\/#define EFFECTS_DISABLED\n\n\/\/ Slow & not working\n\/\/#define REFLECT_EFFECTS\n\n#define kRaymarchMaxIter 48\n#define kEffectMaxIter 150\n\n#define kBounceCount 2\n\n\/\/ Debug\n\/\/#define TIME_SLIDER\n\/\/#define DISPLAY_TIME\n\/\/#define ORBIT_CAM\n\n\/\/#define DISABLE_MOTION_BLUR\n\nfloat kFarClip=1000.0; \n\nvec3 vLightPos = vec3(0.0, -0.5, 0.0);\t\t\t\nvec3 vLightColour = vec3(1.0, 0.8, 0.4);\n\nfloat gTimeDither;\nfloat gTime;\n\nfloat pixelRandom;\n\n\/\/ Sequence globals\n\nvec3 g_vCameraPos = vec3(0.0);\nvec3 g_vCameraTarget = vec3(0.0, 0.0, -1.0);\nvec3 g_vCarPos = vec3(0.0);\nfloat fFieldOfView = 5.0;\n\nfloat fSmoke = 0.0;\nfloat fSpeedDisplay = -1.0;\nfloat fGlowEffect = -1.0;\nfloat g_fPanelDisplay = -1.0;\nfloat gFogCoeff = 0.05;\nfloat gEffectBegin = 0.0;\nfloat gDrawCar = 1.0;\nfloat gFlameEffect = -1.0;\nvec3 g_vFlamePos = vec3(0.0);\nfloat gFlameEffectEnd = 0.0;\nfloat gFlameWidth = 0.3;\nfloat gExplode = -1.0;\nfloat gTextFade = 0.0;\nfloat gEffectScale = 1.0;\n\nfloat gFlash = 0.0;\n\nfloat gWheelRotation = 0.0;\n\n\nvec2 GetWindowCoord( const in vec2 vUV );\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget );\nvec3 GetSceneColour( in vec3 vRayOrigin,  in vec3 vRayDir );\nvec3 ApplyPostFX( const in vec2 vUV, const in vec3 vInput );\n\nfloat Debug_PrintFloatApprox( const in vec2 uv, const in vec2 fontSize, const in float value, const in float maxDigits, const in float decimalPlaces );\n\nfloat noise( in vec2 x );\nfloat noise( in vec3 x );\n\nfloat kAccelTime = 13.0;\n\nfloat kFinalDistance = 1000.0;\n\nfloat CarZAtTravelTime( float t )\n{\n    float z = 0.0;\n  \n    if( t > kAccelTime )\n    {\n        float nt = t \/ kAccelTime;\n        float kFinalSpeed = 100.0;\n        z = kFinalDistance + t * kFinalSpeed;\n    }\n    else\n    {\n        \/\/ smoothstep shaped velocity curve v = nt * nt * nt - nt * nt * nt * nt * 0.5;         \n   \n        float _t = t \/ kAccelTime;\n        z = (_t + 1.0) * log(_t + 1.0)  - _t;\n        z = z * kFinalDistance;\n    }\n\n    return z;\n}\n\n\nvec3 CarPosAtTime( float t )\n{\n\tfloat z = CarZAtTravelTime( max( 0.0, t - 5.0 ) );\n    \n\treturn vec3(0.0, -0.015, z );\n}\n\nvoid CameraSequence()\n{    \n    float kShotTyreSmokeTime= 0.0;\n    float kShotStartMoveTime= 5.0;\n    float kShotTrackStartAccelTime = 7.0;\n    float kShotCarPovTime = 8.5;\n    float kShotCarApproachTime = 10.0;\n    float kShotCarZoomPastTime = 11.3;\n    float kShotSpeedDisplayTime = 12.0;\n    float kShotPanelsTime = 14.0;\n    float kShotGlowEffectsTime = 15.0;\n    float kShotEventSideOnTime = 18.0 + 1.0;\n    float kShotFlameTrailsTime = 19.0 + 1.5;\n    float kTextFadeTime = 26.0 + 1.5;\n\n    \/\/float kShotEventSideOnTime = 18.0;\n    \/\/float kShotFlameTrailsTime = 19.0;\n    \/\/float kTextFadeTime = 26.0;\n    \n    float kEventTime = kShotEventSideOnTime + 1.0;\n    \n    g_vCarPos = CarPosAtTime(gTimeDither);\n    g_vCarPos.y += noise(g_vCarPos) * 0.01;\n    \n    gWheelRotation = g_vCarPos.z * 3.14 \/ 0.3;\n    \n    float fCameraShake = 0.0;\n    \n    if( gTime < kShotStartMoveTime )\n    {\n        \/\/ Static + tyre smoke        \n        fSmoke = 1.0;\n        \n    \tg_vCameraPos = g_vCarPos + vec3( 2.0, 0.5, 1.0 );\n\t    \/\/g_vCameraTarget = g_vCarPos + vec3( 0.846435, 0.327574, -1.187590 ) ;\n        g_vCameraTarget = g_vCarPos + vec3( 0.846435, 0.1, -1.187590 ) ;\n        \n        g_vCarPos.x += sin(gTimeDither) * 0.05;\n        \n        \n    \tfFieldOfView = 5.0; \n        \n        gWheelRotation = gTimeDither * 10.0;\n    }\n    else if( gTime < kShotTrackStartAccelTime )\n    {\n        \/\/ Start Moving\n        fSmoke = max( 1.0 - (gTime - kShotStartMoveTime), 0.0);\n        \n        g_vCameraPos = vec3( 3.0, 0.2, 10.0 );\n        g_vCameraTarget = vec3(-2.0, 1.0, 0.0);\n        fFieldOfView = 4.0;\n    }\n    else if( gTime < kShotCarPovTime )\n    {\n        \/\/ Tracking acceleration\n        vec3 vSeqStartCarPos = CarPosAtTime( kShotTrackStartAccelTime ); \n            \n        g_vCameraPos = vSeqStartCarPos + vec3( 5.0, 0.2, 20.0 );\n        g_vCameraTarget = g_vCarPos + vec3(0.0, 0.5, 2.0);\n        fFieldOfView = 3.0;\n    }\n    else if( gTime < kShotCarApproachTime )\n    {\n        \/\/ Car POV\n        vec3 vSeqStartCarPos = CarPosAtTime( kShotCarPovTime ); \n            \n        \/\/g_vCameraPos = g_vCarPos + vec3( 0.0, 1.5, -2.0 );\n        \/\/g_vCameraTarget = g_vCarPos + vec3(0.0, -30.0, 100.0);\n        \/\/fFieldOfView = 3.0;\n        g_vCameraPos = g_vCarPos + vec3( 0.0, 1.5, 10.0 );\n        g_vCameraTarget = g_vCarPos + vec3(0.0, 0.5, 1.0);\n        fFieldOfView = 5.0;\n        \n        fCameraShake = 1.0;\n    }\n    else if( gTime < kShotCarZoomPastTime )\n    {\n        \/\/ Head-on Car Approach\n        vec3 vSeqStartCarPos = CarPosAtTime( kShotCarApproachTime ); \n            \n        g_vCameraPos = vSeqStartCarPos + vec3( 0.1, 0.1, 40.0 );\n        g_vCameraTarget = g_vCarPos + vec3(0.0, 0.5, 2.0);\n        fFieldOfView = 3.0;\n    }\n    else if( gTime < kShotSpeedDisplayTime )\n    {\n        \/\/ Car zoom past\n        vec3 vSeqStartCarPos = CarPosAtTime( kShotCarZoomPastTime ); \n            \n        g_vCameraPos = vSeqStartCarPos + vec3( 2.0, 0.5, 9.5 );\n        g_vCameraTarget = vSeqStartCarPos + vec3(0.0, 0.5, 7.5);\n        fFieldOfView = 5.0;\n    }\n    else if( gTime < kShotPanelsTime )\n    {    \n        \/\/ Speed Display\n        \n        fSpeedDisplay = 88.4 + (gTime - kShotPanelsTime) * 2.0;\n        \n        g_vCameraTarget = vec3( 0.02, 1.1, 0.01 );\n        g_vCameraPos = g_vCameraTarget + vec3( 0.0, 0.4, 0.02 );\n        fFieldOfView = 9.0;\n        \n    }\n    else if( gTime < kShotGlowEffectsTime )\n    {\n        \/\/ Time Travel Instrument Panels\n\n        g_fPanelDisplay = gTime - kShotPanelsTime;\n        \n        g_vCameraTarget = vec3( 0.0, 1.0, 0.0 );\n        g_vCameraPos = g_vCameraTarget + vec3( 0.3, 0.0, 1.5 );\n        fFieldOfView = 4.0;\n                \n    }    \n    else if (gTime < kShotEventSideOnTime)\n    {\n        \/\/ Glow Effects\n        g_vCameraPos = g_vCarPos + vec3( 2.0, 0.6, 4.0 ) * 2.0;\n        g_vCameraPos.x += (gTime - kShotGlowEffectsTime) * 0.1;\n        g_vCameraTarget = g_vCarPos + vec3(0.0, 0.7, 1.0);\n        fFieldOfView = 5.0;   \n        \n        fGlowEffect = gTime - kShotGlowEffectsTime;\n        \n        gFlash = min( abs(gTime - 16.3) + 0.01, abs(gTime - 16.6) + 0.01 );\n        \n        g_vCarPos.x += sin(gTimeDither * 3.0) * 0.25;\n        \n        fCameraShake = 0.5;\n    }\n    else if (gTime < kShotFlameTrailsTime)\n    {\n        \/\/ Event Side On\n        \n        vec3 vEventCarPos = CarPosAtTime( kEventTime ); \n        \n        g_vCameraTarget = vEventCarPos + vec3(0.0, 0.5, 0.0);\n        g_vCameraPos = g_vCameraTarget + vec3( 70.0, 1.1, 0.0 );\n        \n        g_vCameraTarget.y += 10.0;\n\n        fFieldOfView = 3.0;   \n        \n        fGlowEffect = gTime - kShotGlowEffectsTime;\n        \n        gFogCoeff = 0.01;\n        \n        gEffectBegin = 69.0;\n        \n        gExplode = (gTime - kEventTime) + 0.1;\n\n        gEffectScale = 4.0;\n        \n        g_vFlamePos = vEventCarPos;\n        gFlameWidth = 1.0;\n        \n        if( gTime > kEventTime )\n        {\n            gDrawCar = -1.0;\n            fGlowEffect = 0.0;\n            \n            gFlameEffect = gTime - kEventTime;\n            \n            gFlameEffectEnd = g_vCarPos.z - g_vFlamePos.z;\n        }    \n        \n        gFlash = abs(gTime - kEventTime) + 0.01;\n    }        \n    else\n    {\n        \/\/ Flame Tracks\n        \n        vec3 vSeqStartCarPos = CarPosAtTime( kShotFlameTrailsTime ); \n        \n        g_vCameraPos = vSeqStartCarPos + vec3(0.0, 1.0, 0.0); \n        g_vCameraTarget = g_vCameraPos + vec3(0.0, -8.0, 100.0);\n        \n        g_vFlamePos = vSeqStartCarPos;\n        gFlameEffect = gTime - kShotFlameTrailsTime;\n        \n        gDrawCar = -1.0;\n        fGlowEffect = 0.0;\n        gFlameEffectEnd = (g_vCarPos.z - g_vFlamePos.z) * 0.25;\n    }\n    \n    if( gTime > kTextFadeTime )\n    {\n        gTextFade = clamp((gTime -kTextFadeTime) * 0.2, 0.0, 1.0);\n    }\n            \n    g_vCameraTarget.y += (noise(g_vCameraPos * 0.2) - 0.5) * fCameraShake \/ length(g_vCameraTarget - g_vCameraPos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    pixelRandom = noise(fragCoord + iGlobalTime);\n\tvec2 vUV = (fragCoord.xy) \/ iResolution.xy;\n\n    \/\/gTime = iGlobalTime;\n    gTime = max(0.0, iGlobalTime - 5.0);\n\n    \/\/gTime = 6.0;\n    \n#ifdef TIME_SLIDER\n    float kSliderRange = 30.0;\n    gTime = (iMouse.x \/ iResolution.x) * kSliderRange;\n#endif\n    \n    gTimeDither = gTime;\n    \n#ifndef DISABLE_MOTION_BLUR\n    gTimeDither -= pixelRandom * 1.0 \/ 60.0;\n#endif    \n    \n    CameraSequence();\n\n#ifdef ORBIT_CAM    \n    float fDist = 6.0;\n\n    float fAngle = radians(-30.0) + sin(iGlobalTime * 0.25) * 0.2;\n    float fHeight = 2.0 + sin(iGlobalTime * 0.1567) * 1.5;\n    \n\tvec2 vMouse = iMouse.xy \/ iResolution.xy;\n\t\n    \n    if(iMouse.z > 0.0)\n    {\n        fAngle = vMouse.x * 2.0 * 3.14;\n        fHeight = vMouse.y * fDist;\n    }\n    \n\tg_vCameraPos = g_vCarPos + vec3(sin(fAngle) * fDist, fHeight, cos(fAngle) * fDist);\n\tg_vCameraTarget = g_vCarPos + vec3(0.0, 0.5, 0.0);\n    \n    fFieldOfView = 3.0;\n#endif \n    \n\tvec3 vRayOrigin = g_vCameraPos;\n\tvec3 vRayDir = GetCameraRayDir( GetWindowCoord(vUV), g_vCameraPos, g_vCameraTarget );\n\t\n\tvec3 vResult = GetSceneColour(vRayOrigin, vRayDir);\n\t\n    if ( gFlash > 0.0 )\n    {\n    \tvResult += clamp( 1.0 - gFlash \/ 0.1, 0.0, 1.0) * 3.0;\n    }\n    \n\tvec3 vFinal = ApplyPostFX( vUV, vResult );\n\n    vec3 vText = vec3(0.0);\n    vec2 vTextUV = vUV.xy - vec2(0.5 - 0.1 * 2.5, 0.2);\n    vTextUV = vTextUV \/ vec2(0.1, 0.2);\n    if( vTextUV. y > 0.0 && vTextUV.y < 3.0)\n    {\n        vec3 vTextCol = vec3(0.5, 0.5, 0.0);\n        if( vTextUV.y > 2.0 )\n        {\n            vTextCol = vec3(0.5, 0.0, 0.0);\n        }\n        else if( vTextUV.y > 1.0 )\n        {\n            vTextCol = vec3(0.0, 0.5, 0.0);\n        }\n        vec2 vTextUVWrap = vTextUV;\n        vTextUVWrap.y = fract(vTextUVWrap.y);\n        vText += vTextCol * Debug_PrintFloatApprox( vTextUVWrap, vec2(1.0, 1.0), 516.151, 3.0, 2.0 ) * 4.0;\n    }\n    \n    vFinal = mix( vFinal, vText, gTextFade);            \n    \n#ifdef DISPLAY_TIME\n    vFinal.r += Debug_PrintFloatApprox( fragCoord.xy, vec2(32.0, 48.0), gTime, 3.0, 2.0 ) * 4.0;    \n#endif\n    \n#ifdef TIME_SLIDER\n    {\n        float screenX = gTime \/ kSliderRange;\n        if ( length(vec2(screenX, 0.02) - vUV)  < 0.01 )\n        {\n            vFinal.g = 1.0;\n        }\n    }\n#endif    \n\tfragColor = vec4(vFinal, 1.0);\n}\n\n\/\/ CAMERA\n\nvec2 GetWindowCoord( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x \/ iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget )\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\t\t\t\t\t\t  \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fFieldOfView);\n\n\treturn vDir;\n}\n\n\/\/ POSTFX\n\nvec3 ApplyVignetting( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0);\n\t\n\tfloat fDist = dot(vOffset, vOffset);\n\t\n\tconst float kStrength = 0.95;\n\tconst float kPower = 1.5;\n\n\treturn vInput * ((1.0 - kStrength) +  kStrength * pow(1.0 - fDist, kPower));\n}\n\nvec3 ApplyTonemap( const in vec3 vLinear )\n{\n\tfloat kExposure = 0.5;\n    \n    if(gTime < 2.0)\n    {\n        kExposure *= gTime \/ 2.0;\n    }\n    \t\n\treturn 1.0 - exp2(vLinear * -kExposure);\t\n}\n\nvec3 ApplyGamma( const in vec3 vLinear )\n{\n\tconst float kGamma = 2.2;\n\n\treturn pow(vLinear, vec3(1.0\/kGamma));\t\n}\n\nvec3 ApplyBlackLevel( const in vec3 vColour )\n{\n    float fBlackLevel = 0.1;\n    return vColour \/ (1.0 - fBlackLevel) - fBlackLevel;\n}\n\nvec3 ApplyPostFX( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec3 vTemp = ApplyVignetting( vUV, vInput );\t\n\t\n\tvTemp = ApplyTonemap(vTemp);\n\t\n\tvTemp = ApplyGamma(vTemp);\t\t\n    \n    vTemp = ApplyBlackLevel(vTemp);\n    \n    return vTemp;\n}\n\n\/\/ Scene materials\n#define MAT_ROAD \t\t\t 1.0\n#define MAT_CAR_BODY \t\t 2.0\n#define MAT_CAR_WINDOW \t\t 3.0\n#define MAT_CAR_HEADLIGHT \t 4.0\n#define MAT_CAR_WHEEL\t\t 5.0\n#define MAT_SPEED_DISPLAY\t 6.0\n#define MAT_BLACK_PLASTIC    7.0\n#define MAT_CHROME\t\t\t 8.0\n#define MAT_CHARGE_DISPLAY   9.0\n#define MAT_FLUX_CAPACITOR \t10.0\n#define MAT_GRILL\t\t \t11.0\n\n\/\/ RAYTRACE\n\nstruct C_Intersection\n{\n\tvec3 vPos;\n\tfloat fDist;\t\n\tvec3 vNormal;\n\tvec3 vUVW;\n\tfloat fObjectId;\n};\n    \n   \nfloat PlaneDist( const in vec3 vPos, const in vec4 vPlane )\n{\n    return dot(vPlane.xyz, vPos) - vPlane.w;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)\/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat CarBodyMin( float a, float b )\n{\n    return smin(a, b, 0.03);\n}\n  \nfloat CarBodyMax( float a, float b )\n{\n    return -CarBodyMin(-a, -b);\n}\n\nfloat WheelArchCombine( float a, float b )\n{\n    float size = 0.04;\n    float r= clamp( 1.0 - abs(b) \/ size, 0.0, 1.0);\n    a -= r * r * size;\n    \n    return CarBodyMax(a, b);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat GetWheelArchDist( vec3 vPos )\n{\n    vPos.y = max( vPos.y, 0.0 );\n    return  0.32 - length( vPos.zy );\n}\n\nfloat GetWheelDist( vec3 vPos )\n{\n    float bevel = 0.03;\n    float r = length( vPos.zy );\n    \n    float x = vPos.x + 0.1;\n    \n    if( r < 0.15 )\n    {\n        float unitr = r \/ 0.15;\n    \tx = x - sqrt(1.0 - unitr * unitr) * 0.01;\n        x = x + 0.002;\n    }\n    \n    vec2 rx = vec2( r,x );\n\n    return length( max( abs(rx) - vec2(0.28 -bevel, 0.075), 0.0)) - bevel;\n}\n    \nfloat CarBodyDisance( out vec4 vOutUVW_Id, const in vec3 _vPos )\n{\n    vec3 vCarPos = _vPos;\n    \n    vec3 vBodyPos = vCarPos;\n    vBodyPos.x = abs(vBodyPos.x);\n\tvOutUVW_Id = vec4(vBodyPos.xyz, MAT_CAR_BODY);\n    \n    float distBonnet0 = PlaneDist(vBodyPos, vec4( -0.005687, 0.994044, 0.108829, 0.891393 ) );\n    float distRoof0 = PlaneDist(vBodyPos, vec4( 0.004004, 0.999946, 0.009596, 1.124596 ) );\n    float distFrontWindow0 = PlaneDist(vBodyPos, vec4( -0.002180, 0.918728, 0.394886, 1.033900 ) );\n    float distDoorWindow0 = PlaneDist(vBodyPos, vec4( 0.765404, 0.643545, -0.002593, 1.145616 ) );\n    float distSmallWindow0 = PlaneDist(vBodyPos, vec4( 0.760709, 0.645945, -0.063856, 1.201365 ) );\n    float distDoorUpper0 = PlaneDist(vBodyPos, vec4( 0.945737, 0.324923, -0.002605, 1.045727 ) );\n    float distDoorLower0 = PlaneDist(vBodyPos, vec4( 0.985543, -0.169304, 0.006400, 0.805219 ) );\n    float distFront0 = PlaneDist(vBodyPos, vec4( 0.001169, 0.393724, 0.919228, 2.167077 ) );\n    float distBase0 = PlaneDist(vBodyPos, vec4( -0.002855, -0.999987, 0.004094, -0.132802 ) );\n    float distRearWindow0 = PlaneDist(vBodyPos, vec4( 0.001012, 0.976084, -0.217392, 1.302470 ) );\n    float distRear0 = PlaneDist(vBodyPos, vec4( -0.000983, 0.100691, -0.994917, 2.116753 ) );\n    float distFrontBase0 = PlaneDist(vBodyPos, vec4( 0.000408, -0.940669, 0.339326, 0.348749 ) );\n    float distRearBase0 = PlaneDist(vBodyPos, vec4( 0.120237, -0.941372, -0.315218, 0.256832 ) );\n    float distTopRearPanel0 = PlaneDist(vBodyPos, vec4( 0.909642, 0.405237, -0.091298, 1.161221 ) );\n    float distBottomRearPanel0 = PlaneDist(vBodyPos, vec4( 0.974792, -0.205007, -0.088053, 0.849642 ) );\n\n    float topCurveX = abs(vBodyPos.x);\n    topCurveX = topCurveX * topCurveX;\n    distBonnet0 += topCurveX * 0.05;\n    distRoof0 += topCurveX * 0.1;\n    distFrontWindow0 += topCurveX * 0.01;\n    distRearWindow0 += topCurveX * 0.01;\n\n    float topCurveZ = abs(vBodyPos.z);\n    topCurveZ = topCurveZ * topCurveZ;\n    distRoof0 += topCurveZ * 0.05;\n\n    float result = -100000.0;\n    \n    result = CarBodyMax( result, distRoof0 );\n    result = CarBodyMax( result, distDoorWindow0 );\n    result = CarBodyMax( result, distSmallWindow0 );\n    result = CarBodyMax( result, distDoorUpper0 );\n    result = CarBodyMax( result, distDoorLower0 );\n    result = CarBodyMax( result, distFront0 );\n    result = CarBodyMax( result, distBase0 );\n    result = CarBodyMax( result, distRearWindow0 );\n    result = CarBodyMax( result, distRear0 );\n    result = CarBodyMax( result, distFrontBase0 );\n    result = CarBodyMax( result, distRearBase0 );\n    result = CarBodyMax( result, distTopRearPanel0 );\n    result = CarBodyMax( result, distBottomRearPanel0 );\n\n    float distBonnetWindow = CarBodyMin(distBonnet0, distFrontWindow0);    \n    result = CarBodyMax( result, distBonnetWindow );\n\n#ifndef SIMPLE_CAR\n    \n    \n    bool isGlass = false;\n    \n    if ( abs( distFrontWindow0 - result ) < 0.001 )\n    {\n        \/\/if( abs(min(min(distBonnet0, -distRoof0), -distDoorWindow0)) > 0.01 )\n        {\n            isGlass = true;\n        }\n    }\n\n    if ( abs( distDoorWindow0 - result ) < 0.001 )\n    {\n        \/\/if( abs(min(min(distFrontWindow0, -distRoof0), -distSmallWindow0)) > 0.01 )\n        {\n            isGlass = true;\n        }\n    }\n\n    \/*if ( abs( distSmallWindow0 - result ) < 0.001 )\n    {\n        \/\/if( abs(distRear0) > 0.5 && abs(distRearWindow0) > 0.1)\n        {\n            isGlass = true;\n        }\n    }*\/\n\n    if( isGlass )\n    {\n    \tvOutUVW_Id.w = MAT_CAR_WINDOW;\n    }\n    \n    \/\/float trimHeight = 0.5;\n    \/\/float trimLineDist = clamp( 0.05 - (vBodyPos.y - trimHeight), 0.0, 0.05 );\n    \/\/result -= trimLineDist;\n\n    \n    \/\/ TODO - replace with measured one\n    {\n        vec3 vBumperPos = vBodyPos - vec3(0.0, 0.25, 1.8);\n                \n    \tfloat fBumperDist = udRoundBox( vBumperPos, vec3(0.8, 0.1, 0.24) , 0.01 );\n        fBumperDist -= clamp( -vBumperPos.y, 0.0, 0.04 );\n        if( fBumperDist < result )\n        {\n            result = fBumperDist;\n            vOutUVW_Id.w = MAT_CAR_BODY;\n        }\n    }\n\n    \n    \n    vec3 vFrontWheelPos = -vec3( -0.853643, -0.289475, -1.271860 ) ;\n    vec3 vRearWheelPos = -vec3( -0.846435, -0.327574, 1.187590 ) ;\n\n    vec3 vWheelPos = vBodyPos - vFrontWheelPos;\n    \n    float fSeparation = (vFrontWheelPos.z - vRearWheelPos.z) * 0.5;\n    vWheelPos.z = abs(vWheelPos.z + fSeparation ) - fSeparation;\n    \n    float fWheelArchDist = GetWheelArchDist( vWheelPos );\n    \n    result = WheelArchCombine( result, fWheelArchDist );\n    \n    float fWheelDist = GetWheelDist( vWheelPos );\n    if ( fWheelDist < result )\n    {\n        result = fWheelDist;\n    \tvOutUVW_Id.xy =  vWheelPos.yz;\n    \tvOutUVW_Id.w =  5.0;\n    }\n\n    {\n        vec3 vGrillPos = vBodyPos - vec3(0.0, 0.58, 2.03);\n        vGrillPos.z += vGrillPos.y * 0.45;      \n        \n        vec3 vSize = vec3(0.45, 0.05, 0.1);\n    \tfloat fGrillDist = udRoundBox( vGrillPos, vSize , 0.02 );\n        if( fGrillDist < result )\n        {\n            result = fGrillDist;\n            vOutUVW_Id.xyz = vGrillPos \/ vSize;\n            vOutUVW_Id.w = MAT_GRILL;\n        }\n    }    \n\n    {\n        vec3 vMirrorPos = vBodyPos - vec3(0.9, 0.85, 0.5);\n        \n    \tfloat fMirrorDist = udRoundBox( vMirrorPos, vec3(0.06, 0.04, 0.02) , 0.03 );\n        if( fMirrorDist < result )\n        {\n            result = fMirrorDist;\n            vOutUVW_Id.w = MAT_BLACK_PLASTIC;\n            \n        }\n    }    \n    \n    \/\/ TODO: Replace with measured\n    {\n        vec3 vHeadlightMountingDomain = vBodyPos - vec3(0.68, 0.58, 2.05);\n\n        float headlightRecessDist = udRoundBox( vHeadlightMountingDomain, vec3(0.36 * 0.5, 0.04, 0.2) , 0.01 );\n\n        result = max(result, -headlightRecessDist);\n                \n        vec3 vHeadlightPos = vHeadlightMountingDomain;\n        \n        bool off = false;\n        if( vHeadlightPos.x < 0.0)\n        {\n            off = true;\n        }\n        \n        float fSeparation = 0.1;\n        vHeadlightPos.x = abs(vHeadlightPos.x) - fSeparation;\n        \n    \tfloat headlightDist = udRoundBox( vHeadlightPos, vec3(0.06, 0.03, 0.05) , 0.01 );\n        if( headlightDist < result )\n        {\n            result = headlightDist;\n            vOutUVW_Id.w = MAT_CAR_HEADLIGHT;\n            if ( off )\n            {\n                vOutUVW_Id.w = MAT_CHROME;\n            }\n\n        }\n\n    }\n\n    #endif \/\/SIMPLE_CAR\n    \n    return result;\n}\n\nvoid GetPanelDist( inout float fOutDist, inout vec4 vOutUVW_Id, const in vec3 vPos, const in vec3 vPanelPos, const in vec3 vPanelSize, const in float fMaterial )\n{\n    vec3 vPanelDomain = vPos - vPanelPos;\n\tfloat fPanelDist = sdBox( vPanelDomain, vPanelSize );\n\n    if( fPanelDist < fOutDist )\n    {\n        fOutDist = fPanelDist;\n        vOutUVW_Id = vec4(vPanelDomain.xzy * (0.5 \/ vPanelSize.xzy) + 0.5, fMaterial);\n    }        \n}\n\n\nfloat GetSceneDistance( out vec4 vOutUVW_Id, const in vec3 vPos )\n{\n\t\n\tfloat fOutDist = 10000.0;\n    vOutUVW_Id = vec4(vPos.xz, 0.0, 0.0);\n\n    if ( gDrawCar > 0.0 )\n    {\n        vec4 vCarBodyUVW_Id;\n        float fCarBodyDisance = CarBodyDisance( vCarBodyUVW_Id, vPos - g_vCarPos );\n        if( fCarBodyDisance < fOutDist )\n        {\n            fOutDist = fCarBodyDisance;\n            vOutUVW_Id = vCarBodyUVW_Id;\n        }\n    }\n    \n    if ( fSpeedDisplay > 0.0 )\n    {\n        GetPanelDist( fOutDist, vOutUVW_Id, vPos, vec3( 0.0, 1.0, 0.0), vec3(0.1, 0.1, 0.1), MAT_SPEED_DISPLAY );\n    }\n    \n    if ( g_fPanelDisplay > 0.0 )\n    {\n        GetPanelDist( fOutDist, vOutUVW_Id, vPos, vec3( 0.0, 1.0, 0.0), vec3(1.0, 1.0, 0.2), MAT_BLACK_PLASTIC );\n        GetPanelDist( fOutDist, vOutUVW_Id, vPos, vec3( 0.25, 1.0, 0.0), vec3(0.15, 0.1, 0.3), MAT_CHARGE_DISPLAY );\n        GetPanelDist( fOutDist, vOutUVW_Id, vPos, vec3( -0.25, 1.0, 0.0), vec3(0.1, 0.1, 0.3), MAT_FLUX_CAPACITOR );\n    }\n    \n\treturn fOutDist;\n}\n\nvec3 GetSceneNormal(const in vec3 vPos)\n{\n    const float fDelta = 0.001;\n\n    vec3 vDir1 = vec3( 1.0, -1.0, -1.0);\n    vec3 vDir2 = vec3(-1.0, -1.0,  1.0);\n    vec3 vDir3 = vec3(-1.0,  1.0, -1.0);\n    vec3 vDir4 = vec3( 1.0,  1.0,  1.0);\n\t\n    vec3 vOffset1 = vDir1 * fDelta;\n    vec3 vOffset2 = vDir2 * fDelta;\n    vec3 vOffset3 = vDir3 * fDelta;\n    vec3 vOffset4 = vDir4 * fDelta;\n\n\tvec4 vUnused;\n    float f1 = GetSceneDistance( vUnused, vPos + vOffset1 );\n    float f2 = GetSceneDistance( vUnused, vPos + vOffset2 );\n    float f3 = GetSceneDistance( vUnused, vPos + vOffset3 );\n    float f4 = GetSceneDistance( vUnused, vPos + vOffset4 );\n\t\n    vec3 vNormal = vDir1 * f1 + vDir2 * f2 + vDir3 * f3 + vDir4 * f4;\t\n\t\t\n    return normalize( vNormal );\n}\n\n\nvoid TraceFloor( inout C_Intersection inoutIntersection, const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fFloorHeight, const in float fObjectId )\n{\n\tfloat fDh = fFloorHeight - vRayOrigin.y;\n\tfloat t = fDh \/ vRayDir.y;\n\t\n\tif(vRayDir.y < 0.0)\n\t{\n\t\tif((t > 0.0) && (t < inoutIntersection.fDist))\n\t\t{\n\t\t\tinoutIntersection.fDist = t;\n\t\t\tinoutIntersection.vPos = vRayOrigin + vRayDir * t;\n\t\t\tinoutIntersection.vNormal = vec3(0.0, 1.0, 0.0);\n\t\t\tinoutIntersection.vUVW = vec3(inoutIntersection.vPos.xz, 0.0);\n\t\t\tinoutIntersection.fObjectId = fObjectId;\n\t\t}\t\n\t}\n}\n\nvoid RaymarchScene( out C_Intersection outIntersection, const in vec3 vOrigin, const in vec3 vDir )\n{\n\tvec4 vUVW_Id = vec4(0.0);\t\t\n\tvec3 vPos = vec3(0.0);\n    \n\tfloat t = 0.01;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\n\t\tvPos = vOrigin + vDir * t;\n\t\tfloat fDist = GetSceneDistance(vUVW_Id, vPos);\t\t\n\t\tt += fDist;\n\t\tif(abs(fDist) < 0.001)\n\t\t{\n\t\t\tbreak;\n\t\t}\t\t\n\t\tif(t > 100.0)\n\t\t{\n\t\t\tt = kFarClip;\n\t\t\tvPos = vOrigin + vDir * t;\n\t\t\tvUVW_Id = vec4(0.0);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\toutIntersection.fDist = t;\n\toutIntersection.vPos = vPos;\n\toutIntersection.vNormal = GetSceneNormal(vPos);\n\toutIntersection.vUVW = vUVW_Id.xyz;\n\toutIntersection.fObjectId = vUVW_Id.w;\n}\n\n\nvoid TraceScene( out C_Intersection outIntersection, const in vec3 vOrigin, const in vec3 vDir )\n{\t\n    RaymarchScene( outIntersection, vOrigin, vDir );\n    \n    TraceFloor( outIntersection, vOrigin, vDir, 0.0, MAT_ROAD );\n}\n\n\nfloat TraceShadow( const in vec3 vOrigin, const in vec3 vDir, const in float fDist )\n{\n    C_Intersection shadowIntersection;\n\tRaymarchScene(shadowIntersection, vOrigin, vDir);\n\tif(shadowIntersection.fDist < fDist) \n\t{\n\t\treturn 0.0;\t\t\n\t}\n\t\n\treturn 1.0;\n}\n\n\/\/ LIGHTING\n\nfloat GIV( float dotNV, float k)\n{\n\treturn 1.0 \/ ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\nvoid AddLighting(inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightColour)\n{\n\tvec3 vH = normalize( -vViewDir + vLightDir );\n\tfloat fNDotL = clamp(dot(vLightDir, vNormal), 0.0, 1.0);\n\tfloat fNDotV = clamp(dot(-vViewDir, vNormal), 0.0, 1.0);\n\tfloat fNDotH = clamp(dot(vNormal, vH), 0.0, 1.0);\n\t\n\tfloat alpha = 1.0 - fSmoothness;\n\talpha = alpha * alpha;\n\t\/\/ D\n\n\tfloat alphaSqr = alpha * alpha;\n\tfloat pi = 3.14159;\n\tfloat denom = fNDotH * fNDotH * (alphaSqr - 1.0) + 1.0;\n\tfloat d = alphaSqr \/ (pi * denom * denom);\n\n\tfloat k = alpha \/ 2.0;\n\tfloat vis = GIV(fNDotL, k) * GIV(fNDotV, k);\n\n\tfloat fSpecularIntensity = d * vis * fNDotL;\n\tvSpecularLight += vLightColour * fSpecularIntensity;\n\n\tvDiffuseLight += vLightColour * fNDotL;\n}\n\nvoid AddPointLight(inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vPos, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightPos, const in vec3 vLightColour)\n{\n\tvec3 vToLight = vLightPos - vPos;\t\n\tfloat fDistance2 = dot(vToLight, vToLight);\n\tfloat fAttenuation = 100.0 \/ (fDistance2);\n\tvec3 vLightDir = normalize(vToLight);\n\t\n\tvec3 vShadowRayDir = vLightDir;\n\tvec3 vShadowRayOrigin = vPos + vShadowRayDir * 0.01;\n\tfloat fShadowFactor = TraceShadow(vShadowRayOrigin, vShadowRayDir, length(vToLight));\n\t\n\tAddLighting(vDiffuseLight, vSpecularLight, vViewDir, vLightDir, vNormal, fSmoothness, vLightColour * fShadowFactor * fAttenuation);\n}\n\nfloat AddDirectionalLight(inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vPos, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightDir, const in vec3 vLightColour)\n{\t\n\tfloat fAttenuation = 1.0;\n\n\tvec3 vShadowRayDir = -vLightDir;\n\tvec3 vShadowRayOrigin = vPos + vShadowRayDir * 0.01;\n\tfloat fShadowFactor = TraceShadow(vShadowRayOrigin, vShadowRayDir, 10.0);\n\t\n\tAddLighting(vDiffuseLight, vSpecularLight, vViewDir, -vLightDir, vNormal, fSmoothness, vLightColour * fShadowFactor * fAttenuation);\t\n    \n    return fShadowFactor;\n}\n\n\/\/ SCENE MATERIALS\n\nvec3 GetChargeDisplayColor( vec2 vUV, float fTime )\n{\n    float fAmount = clamp( (fTime - 0.25) * 2.5, 0.0, 1.0 );\n    \n    vec2 vSegmentUV = vUV * vec2(20.0, 16.0);\n    vec2 vSegmentPos = fract(vSegmentUV - 0.1);\n    vec2 vSegmentID = floor(vSegmentUV);\n    \n    vec2 vIsSegment= step(vSegmentPos, vec2(0.8));\n    float fIsSegment = vIsSegment.x * vIsSegment.y;\n    \n    vec3 vCol = vec3(0.01, 1.0, 0.01) * 2.0;\n    \n    if ( vSegmentID.y > 10.0 )\n    {\n        vCol = vec3(1.0, 0.01, 0.01) * 2.0;\n    }\n    \n    float fLit = 0.0;\n    \n    float threshold = sin(vSegmentID.x * 0.2) * 0.3 + 0.2;\n    threshold = mix(threshold, 1.0, fAmount);\n    if( (vSegmentID.y \/ 16.0) < threshold )\n    {\n        fLit = 1.0;\n    }\n    \n    return fLit * vCol * fIsSegment + 0.01;\n}\n\nvec3 GetFluxCapacitorColor( vec2 vUV, float fTime )\n{\n    float fAmount = clamp( (fTime - 0.25) * 2.5, 0.0, 1.0 );\n    \n    vec2 vOffsetUV = vUV * 2.0 - 1.0;\n    float theta = atan(vOffsetUV.x, vOffsetUV.y);\n    \n    float segAngle = 3.0 * (theta \/ radians(360.0));\n    float segment = abs(fract(segAngle) - 0.5);\n    \/\/float isSegment = step(segment, 0.1);\n    \n    float isSegment = clamp(1.0 - (segment \/ 0.1), 0.0, 1.0);\n    \n    float len = length(vOffsetUV);\n    \n    if ( len > 0.8 )\n    {\n        isSegment = 0.0;\n    }\n    if ( len < 0.2 )\n    {\n        isSegment = 1.0;\n    }\n    \n    vec3 vLightCol = vec3(0.4, 0.2, 0.001);\n    vec3 vPulseCol = vLightCol * (1.0 + fAmount * 3.0);\n    \n    float fPulseTime = gTimeDither * (1.0 + fAmount * 10.0);\n    \n    float pulse = abs(sin( (len - fPulseTime) * 10.0 ) * 0.4 + 0.6);\n\treturn vec3(0.1) + vPulseCol * pulse * isSegment * fAmount + fAmount * vLightCol * (1.0 - len * 0.5) * 3.0;\n}\n\nvoid GetSurfaceInfo(out vec3 vOutAlbedo, out vec3 vOutR0, out float fOutSmoothness, out vec3 vOutBumpNormal, const in C_Intersection intersection )\n{\n\tvOutBumpNormal = intersection.vNormal;\n\t\n\tif(intersection.fObjectId == MAT_ROAD)\n\t{\n\t\tvec2 vUV = intersection.vUVW.xy * 0.5;\n        \/\/vUV.y += gTimeDither * 10.0;\n\t\tvOutAlbedo = texture2D(iChannel0, vUV).rgb;\n\t\t\n        float fBumpScale = -10.0;\n\t\t\n\t\tvec2 vRes = iChannelResolution[0].xy;\n\t\tvec2 vDU = vec2(1.0, 0.0) \/ vRes;\n\t\tvec2 vDV = vec2(0.0, 1.0) \/ vRes;\n\t\t\n\t\tfloat fSampleW = texture2D(iChannel0, vUV - vDU).r;\n\t\tfloat fSampleE = texture2D(iChannel0, vUV + vDU).r;\n\t\tfloat fSampleN = texture2D(iChannel0, vUV - vDV).r;\n\t\tfloat fSampleS = texture2D(iChannel0, vUV + vDV).r;\n\t\t\n\t\tvec3 vNormalDelta = vec3(0.0);\n\t\tvNormalDelta.x += \n\t\t\t( fSampleW * fSampleW\n\t\t\t - fSampleE * fSampleE) * fBumpScale;\n\t\tvNormalDelta.z += \n\t\t\t(fSampleN * fSampleN\n\t\t\t - fSampleS * fSampleS) * fBumpScale;\n\t\t\n\t\tvOutBumpNormal = normalize(vOutBumpNormal + vNormalDelta);\n\t\t\n\t\tvOutAlbedo = vOutAlbedo * vOutAlbedo;\t\n\t\tfOutSmoothness = clamp((0.5 - vOutAlbedo.r * 4.0), 0.0, 1.0);\n\t\t\n\t\tvOutR0 = vec3(0.01) * vOutAlbedo.g;\n\t}\n\telse if(intersection.fObjectId == MAT_CAR_BODY)\n\t{\n\t\tvOutAlbedo = vec3(0.1, 0.1, 0.1);\n\t\tfOutSmoothness = 0.4;\n\t\tvOutR0 = vec3(0.3);\n        \n        \/\/ hack the normal for a rougher looking car body\n        vec3 vRandom = normalize( vec3( sin(pixelRandom*10.0), sin(pixelRandom * 20.0), sin(pixelRandom * 25.0)));\n        vOutBumpNormal += vRandom * 0.025;\n        vOutBumpNormal = normalize(vOutBumpNormal);\n        \n        if( abs((intersection.vUVW.y) - 0.5) < 0.01 )\n        {\n            vOutR0 = vec3(0.0);\n            fOutSmoothness = 0.1;\n        }\n\n        if( abs(intersection.vUVW.z - intersection.vUVW.y * 0.3 - 0.5) < 0.01 )\n        {\n            vOutR0 = vec3(0.0);\n            fOutSmoothness = 0.1;\n        }\n\n        if( abs(intersection.vUVW.z + sqrt(intersection.vUVW.y ) * 0.5 + 0.3) < 0.01 )\n        {\n            vOutR0 = vec3(0.0);\n            fOutSmoothness = 0.1;\n        }\n\n        if( intersection.vUVW.z > 2.0 && intersection.vUVW.y > 0.35)\n        {\n            vOutR0 = vec3(0.0);\n            fOutSmoothness = 0.1;\n        }\n\t}\n\telse if(intersection.fObjectId == MAT_CAR_WINDOW)\n\t{\n\t\tvOutAlbedo = vec3(0.1, 0.15, 0.15);\n\t\tfOutSmoothness = 1.0;\n\t\tvOutR0 = vec3(0.01);\n\t}\n\telse if(intersection.fObjectId == MAT_CAR_HEADLIGHT)\n\t{\n\t\tvOutAlbedo = vec3(1.0, 1.0, 0.6) * 100.0;\n\t\tfOutSmoothness = 1.0;\n\t\tvOutR0 = vec3(0.01);\n\t}\n    else if(intersection.fObjectId == MAT_CHROME)\n    {\n\t\tvOutAlbedo = vec3(0.01);\n\t\tfOutSmoothness = 1.0;\n\t\tvOutR0 = vec3(1.0);\n    }\n    else if(intersection.fObjectId == MAT_BLACK_PLASTIC)\n    {\n\t\tvOutAlbedo = vec3(0.05);\n\t\tfOutSmoothness = 0.3;\n\t\tvOutR0 = vec3(0.01);\n    }\n    else if(intersection.fObjectId == MAT_GRILL)\n    {\n\t\tvOutAlbedo = vec3(0.05);\n\t\tfOutSmoothness = 0.3;\n\t\tvOutR0 = vec3(0.01);\n        \n        float fStripe = step( fract(intersection.vUVW.y * 2.0), 0.5);\n        vOutAlbedo *= fStripe;\n        \n        if( abs(intersection.vUVW.x) < 0.1 && abs(intersection.vUVW.y) < 0.2)\n        {\n            vOutR0 = vec3(0.9);\n        }\n    }\n\telse if(intersection.fObjectId == MAT_CAR_WHEEL)\n\t{\n\t\tvOutAlbedo = vec3(0.01, 0.01, 0.01);\n\t\tfOutSmoothness = 0.0;\n\t\tvOutR0 = vec3(0.01);\n        \n        float r= length( intersection.vUVW.xy );\n        float theta = atan( intersection.vUVW.x, intersection.vUVW.y );\n        theta -= gWheelRotation;\n        \n        if( r < 0.15 )\n        {\n            fOutSmoothness = 0.9;\n            vOutR0 = vec3(0.8);\n            \n            if( r < 0.13 && r > 0.04)\n            {\n                float alternate = theta * 16.0 \/ radians(360.0);\n                if( fract(alternate) < 0.5 )\n                {\n                    vOutAlbedo = vec3(0.0);\n                    fOutSmoothness = 0.0;\n                    vOutR0 = vec3(0.0);\n                }\n            }\n        }\n        else\n        {\n            vOutAlbedo = texture2D( iChannel0, vec2(r, theta \/ 3.14) ).rgb;\n            vOutAlbedo = vOutAlbedo * vOutAlbedo * 0.2 + 0.015;\n        }\n\t}\n\telse if(intersection.fObjectId == MAT_SPEED_DISPLAY)\n    {\n\t\tvOutAlbedo = vec3(0.4, 0.2, 0.1) * 2.0;\n\t\tfOutSmoothness = 0.0;\n\t\tvOutR0 = vec3(0.01);\n        \n        vec2 vUV = intersection.vUVW.xy;\n        vUV.x = 0.95 - vUV.x;\n        vUV.y = 1.0 - vUV.y;\n        vUV.y -= 0.25;\n        \n        vec3 vDigitCol = vec3(1.0, 0.3, 0.05) * 8.0;\n        vOutAlbedo += vDigitCol * Debug_PrintFloatApprox( vUV, vec2(0.3, 0.5), fSpeedDisplay, 2.0, 1.0 );\n    }\n    else if(intersection.fObjectId == MAT_CHARGE_DISPLAY)\n    {\n\t\tvOutAlbedo = GetChargeDisplayColor(intersection.vUVW.xz, g_fPanelDisplay);\n\t\tfOutSmoothness = 0.0;\n\t\tvOutR0 = vec3(0.01);\n    }\n    else if(intersection.fObjectId == MAT_FLUX_CAPACITOR)\n    {\n\t\tvOutAlbedo = GetFluxCapacitorColor(intersection.vUVW.xz, g_fPanelDisplay);\n\t\tfOutSmoothness = 0.0;\n\t\tvOutR0 = vec3(0.01);\n    }            \n}\n\nvec3 GetSkyLightDir(const in vec3 vDir)\n{\n    float fBackdropAngle = atan( vDir.x, vDir.z ) \/ radians(360.0);\n\n    float fBackdropLightAngle = (floor(fBackdropAngle * 16.0) + 0.5) \/ 16.0 * radians(360.0);\n    \n    \/\/float fBackdropLightAngle = fBackdropAngle;\n    fBackdropLightAngle = fBackdropLightAngle + 3.14;\n    \n    vec3 vBackdropLightPos = vec3(sin(fBackdropLightAngle), -0.2 -0.1 * sin(fBackdropLightAngle * 12.345), cos(fBackdropLightAngle));\n    \n    vBackdropLightPos = normalize(vBackdropLightPos);    \n    return vBackdropLightPos;\n}\n\nvec3 GetSkyColour( const in vec3 vDir )\n{\t\n\t\/\/vec3 vResult = mix(vec3(0.02, 0.04, 0.06), vec3(0.1, 0.5, 0.8), abs(vDir.y));\n    \n    vec3 vResult = textureCube( iChannel1, vDir ).rgb;\n    \n    vResult = vResult * vResult;\n    \n    return vResult * 0.25;\n    \n}\n\n\nvec3 GetSkyLight( const in vec3 vDir, float fSpread )\n{\n \tvec3 vBackdropLightPos = GetSkyLightDir(vDir);\n    \n    \/\/vBackdropLightPos = vec3(0.0, 0.0, 1.0);\n    \/*\n    vec2 vBackdropUV = vDir.xy \/ vDir.z;\n    vBackdropUV.y -= 0.25;\n\n    vec2 vBackdropLightUV = floor(vBackdropUV) + 0.5;\n    vBackdropLightUV.y += 0.25;\n    \n    vec3 vBackdropLightPos = normalize(vec3(vBackdropLightUV, sign(vDir.z)));\n*\/\n\t\n    float fDist = dot(vBackdropLightPos, vDir) + 1.0;\n    \/\/float fDist = length(vBackdropUV - vBackdropLightPos);\n\n    float r = fSpread * 0.001; \n    \n    float fShade = 0.0;\/\/clamp( (r - fDist) \/ r, 0.0, 1.0);\n    \n    fShade = clamp( 1.0 - fDist \/ r, 0.0, 1.0 );\n        \n    fShade = (1.0 - pow(1.0 - fShade, 4.0));\n    \n    \n\treturn vec3(fShade) * vec3(0.5, 0.8, 1.0);\t\n   \n}\n\nvec3 vSunLightColour = vec3(0.1, 0.2, 0.3) * 5.0;\nvec3 vSunLightDir = normalize(vec3(0.4, -0.3, -0.5));\n\t\nvoid ApplyAtmosphere(inout vec3 vColour, const in float fDist, const in vec3 vRayOrigin, const in vec3 vRayDir)\n{\t\t\n    vec3 vSkyColor = GetSkyColour(vRayDir);\n        vColour = mix( vColour, vSkyColor, 1.0 - exp(fDist * -gFogCoeff));\n    \n    \/\/vColour *= 1.0 - exp(fDist * -10.0);\n}\n\n#ifndef EFFECTS_DISABLED\nvec4 EffectColDensity( vec3 vPos )\n{\n    vec3 vCol;\n    float fDensity = 0.0;\n    vec3 vNoisePos = vPos;\n    vec3 vCarDomain = vPos - g_vCarPos;\n    \n    if( fSmoke > 0.0 )\n    {\n        \/\/vNoisePos.z -= 1.6;\n        \/\/vNoisePos.z = vNoisePos.z * vNoisePos.z ;\n        vNoisePos *= 16.0;\n        vNoisePos.x -= gTimeDither * sign(vPos.x) * 4.0;\n        vNoisePos.z += gTimeDither * 6.0;\/\/ + vNoisePos.x ;\n    }\n    \n    if( fGlowEffect > 0.0 )\n    {                \n        if( fGlowEffect < 1.0 )\n        {\n        }\n    \telse\n        {\n            vNoisePos = vCarDomain;\n            \/\/vNoisePos.z = sqrt(max(vNoisePos.z + 2.0, 0.0) \/ 6.0) * 2.0 + 2.0;\n            vNoisePos.z \/= 1.0 + vNoisePos.z * 0.15;\n            vNoisePos *= 4.0;\n            vNoisePos.z += gTimeDither * 20.0;\n        }\n    }\n    \n    if( gFlameEffect > 0.0 )\n    {\n        vNoisePos *= 10.0;\n        vNoisePos.y -= gTimeDither * 10.0 + (vPos.y * 0.01);\n    }\n    \n    float fNoise = noise(vNoisePos);\n    \n    if( fSmoke > 0.0 )\n    {\n        float fShade = clamp( (fNoise - noise(vNoisePos + 0.1)), 0.0, 1.0);\n        vCol = vSunLightColour * fShade * 4.0 + vec3(0.25);\n        \n        vec3 vDensityDomain = vPos;\n        vDensityDomain.y *= 4.0;\n        vDensityDomain.x = abs( vDensityDomain.x );\n         \n        vDensityDomain -= vec3(1.4, 0.0, -1.8);\n        fDensity = clamp( 1.0 - length(vDensityDomain), 0.0, 1.0 );\n        fDensity *= fNoise * 4.0 * fSmoke;\n    }\n    \n    if( gFlameEffect > 0.0 )\n    {\n        vec3 vFlameDomain = vPos - g_vFlamePos;\n        vFlameDomain.x -= vFlameDomain.y * 0.1;\n        float fColBlend= clamp(1.0 - vFlameDomain.y * 2.0, 0.0, 1.0);\n        fColBlend = fColBlend * fColBlend;\n        vCol = mix(vec3(1.0, 0.5, 0.1) * 80.0,\n                         vec3(0.0, 0.0, 1.0) * 10.0,\n                        fColBlend);\n        \n        float fHeightFade = clamp( 0.5 - vFlameDomain.y, 0.0, 1.0);    \n        \n        float fTyreDomain = abs(vFlameDomain.x) - 0.8;\n        float fTyreTrackPosDensity = clamp( gFlameWidth - abs(fTyreDomain) * 2.0, 0.0, 1.0) ;\n\n        float fEndFade = gFlameEffectEnd - vFlameDomain.z;\n        float fBeginFade = vFlameDomain.z;\n        float fLengthFade = clamp( min(fBeginFade, fEndFade), 0.0, 1.0 );\n        \n        fDensity = fTyreTrackPosDensity * fHeightFade * fLengthFade- fNoise * 0.1;\n    }\n    \n    if( fGlowEffect > 0.0 )\n    {                \n\n        float fTopGlow = clamp( fGlowEffect, 0.0, 1.0 );\n        if( fTopGlow > 0.0 )\n        {\n            fTopGlow = fTopGlow * fTopGlow;\n            {\n                vec3 vGlowDomain = vCarDomain - vec3(0.0, 0.95, 0.2);\n                vec3 vClampedPos = vec3(clamp(vGlowDomain.x, -0.6, 0.6), 0.0, 0.0);\n                float fGlowDist = length(vGlowDomain - vClampedPos);\n\n                float fInvRadius = 1.0 \/ 0.2;\n                float fGlowDensity = clamp(1.0 - fGlowDist * fInvRadius, 0.0, 1.0);               \n                fGlowDensity *= fTopGlow;\n                fDensity = max( fDensity, fGlowDensity);\n\n                if( fGlowDensity > 0.0)\n                {\n                    vCol = vec3(1.0, 4.0, 4.0) * 4.0; \n                }\n            }\n            {\n                vec3 vGlowDomain = vCarDomain - vec3(0.0, 0.5, 2.2);\n                vec3 vClampedPos = vec3(clamp(vGlowDomain.x, -0.9, 0.9), 0.0, 0.0);\n                float fGlowDist = length(vGlowDomain - vClampedPos);\n\n                float fInvRadius = 1.0 \/ 0.1;\n                float fGlowDensity = clamp(1.0 - fGlowDist * fInvRadius, 0.0, 1.0);               \n                fGlowDensity *= fTopGlow;\n                fDensity = max( fDensity, fGlowDensity);\n\n                if( fGlowDensity > 0.0)\n                {\n                    vCol = vec3(1.0, 4.0, 4.0) * 4.0; \n                }\n            }\n        }      \n        \n        float fBolt = clamp( (fGlowEffect - 1.25) \/ 0.4, 0.0, 1.0 );\n        \n        if( fBolt >= 1.0 )\n        {\n        \tfBolt = clamp( (fGlowEffect - 1.6) \/ 0.4, 0.0, 1.0 );\n        }\n        \n        if ( fBolt > 0.0 && fBolt < 1.0 )\n        {\n            float fStartMoveTime = 0.2;\n            float fTravelTime = 0.6;\n\n            float fTravel = clamp( (fBolt - fStartMoveTime) \/ fTravelTime, 0.0, 1.0);\n            vec3 vBoltPos = mix( vec3( 0.0, 1.2, 0.3), vec3( 0.0, 0.7, 2.5), fTravel );\n\n            float fFadeInA = fBolt \/ fStartMoveTime;\n            float fFadeInB = (1.0 - fBolt) \/ fStartMoveTime;\n            float fFadeIn = clamp( min(fFadeInA, fFadeInB), 0.0, 1.0);\n            float fBoltSize = 0.1 + (1.0 - fFadeIn) * 1.0;\n            \n            float fBoltDensity = clamp(1.0 - length(vCarDomain - vBoltPos) \/ fBoltSize, 0.0, 1.0);\n\t\t\tfBoltDensity *= fFadeIn * fFadeIn * fFadeIn;\n            \n            fDensity = max( fDensity, fBoltDensity);\n\n            if( fBoltDensity > 0.0)\n            {\n                vCol = vec3(1.0, 4.0, 4.0) * 4.0; \n            }\n        }\n        \n        if( fGlowEffect > 1.9 )\n        {              \n            float fCurveFadein = clamp( (fGlowEffect - 1.9) * 0.5, 0.0, 1.0);\n            vec3 vCurveGlowDomain = vCarDomain;\n            vCurveGlowDomain.z *= 0.7;\n            vCurveGlowDomain.y *= 1.5;\n            vCurveGlowDomain.y -= 0.5;\n\n            float d = length(vCurveGlowDomain);\n            float fCurveGlowDensity = max(0.0, 1.0 - abs(d - 2.0) * 5.0);\n\n            fCurveGlowDensity -= fNoise * (clamp( 2.0-vCurveGlowDomain.z, 0.0, 1.0)) * 5.0;        \n            fCurveGlowDensity *= fCurveFadein;\n\n            fDensity = max(fDensity, fCurveGlowDensity);\n            if ( fCurveGlowDensity > 0.0 )\n            {\n\t            vCol = vec3(4.0, 2.5, 4.0) * 8.0;\n            \tvCol += fCurveGlowDensity;\n            }\n        }        \n    }  \n    \n    if ( gExplode > 0.0 )\n    {\n        vec3 vExplodePos = g_vFlamePos + vec3(0.0, 2.0, 0.0);\n        vec3 vExplodeDomain = vPos - vExplodePos;\n        \n        float fSize = max( gExplode \/ 0.1, 0.0) * 6.0;       \n\n        float fExplodeDensity = clamp(1.0 - length(vExplodeDomain) \/ fSize, 0.0, 1.0);\n        \n        float fFade = max( (0.2 - gExplode) \/ 0.2, 0.0);       \n        \n        fExplodeDensity = fExplodeDensity * fFade;\n        \n        fDensity = max(fDensity, fExplodeDensity);\n\t\tif( fExplodeDensity > 0.0 )\n        {\n            vCol = vec3(1.0, 1.0, 1.0) * 8.0;\n        }\n    }\n    \n    fDensity = clamp(fDensity, 0.0, 1.0);\n    return vec4( vCol, fDensity );\n}\n#endif \/\/ EFFECTS_DISABLED\n\nvoid ApplyEffects( inout vec3 vColour, const in vec3 vRayOrigin, vec3 vRayDir, float fDist )\n{\n   #ifndef EFFECTS_DISABLED\n    float t= gEffectBegin + pixelRandom * 0.03;\n    float f = 1.0;\n    for(int iter=0; iter<kEffectMaxIter; iter++)\n    {\n        if( t > fDist )\n        {\n            break;\n        }\n        \n        vec3 p = vRayOrigin + vRayDir * t;\n        vec4 vEffect = EffectColDensity( p );\n        \n        vColour = mix(vColour, vEffect.rgb, f * vEffect.w);\n        f = f * (1.0 - vEffect.w);\n        \n\t\tt += (0.04+t*0.012);        \n    }\n    #endif \/\/ EFFECTS_DISABLED\n}\n\n\/\/ TRACING LOOP\n\n\t\nvec3 GetSceneColour( in vec3 _vRayOrigin,  in vec3 _vRayDir )\n{\n    vec3 vRayOrigin = _vRayOrigin;\n    vec3 vRayDir = _vRayDir;\n\tvec3 vColour = vec3(0.0);\n\tvec3 vRemaining = vec3(1.0);\n\t\n    float fLastShadow = 1.0;\n    \n    float firstHitDist = kFarClip;\n    bool hitSomething = false;\n    \n\tfor(int i=0; i<kBounceCount; i++)\n\t{\t\n\t\tvec3 vCurrRemaining = vRemaining;\n\t\tfloat fShouldApply = 1.0;\n\t\t\n\t\tC_Intersection intersection;\t\t\t\t\n\t\tTraceScene( intersection, vRayOrigin, vRayDir );\n\n\t\tvec3 vResult = vec3(0.0);\n\t\tvec3 vBlendFactor = vec3(0.0);\n\t\t\t\t\t\t\n\t\tif(intersection.fObjectId == 0.0)\n\t\t{\n\t\t\tvBlendFactor = vec3(1.0);\n\t\t\tfShouldApply = 0.0;\n\t\t}\n\t\telse\n\t\t{\t\t\n\t\t\tvec3 vAlbedo;\n\t\t\tvec3 vR0;\n\t\t\tfloat fSmoothness;\n\t\t\tvec3 vBumpNormal;\n\t\t\t\n\t\t\tGetSurfaceInfo( vAlbedo, vR0, fSmoothness, vBumpNormal, intersection );\t\t\t\n\t\t\n\t\t\tvec3 vDiffuseLight = vec3(0.0);\n\t\t\tvec3 vSpecularLight = vec3(0.0);\n\n            fLastShadow = AddDirectionalLight(vDiffuseLight, vSpecularLight, vRayDir, intersection.vPos, vBumpNormal, fSmoothness, vSunLightDir, vSunLightColour);\t\t\t\t\t\t\t\t\n\n            vec3 vReflectDir = normalize(reflect(vRayDir, vBumpNormal));\n            \n            AddDirectionalLight(vDiffuseLight, vSpecularLight, vRayDir, intersection.vPos, vBumpNormal, fSmoothness * 0.5 + 0.5, GetSkyLightDir(vReflectDir), vSunLightColour);\t\t\t\t\t\t\t\t\n            \n\n            \/*\n            vec3 vPointLightPos = vLightPos;           \n            \n\t\t\tAddPointLight(vDiffuseLight, vSpecularLight, vRayDir, intersection.vPos, vBumpNormal, fSmoothness, vPointLightPos, vLightColour);\t\t\t\t\t\t\t\t\n\n            vec3 vToLight = vPointLightPos - intersection.vPos;\n            float fNdotL = dot(normalize(vToLight), vBumpNormal) * 0.5 + 0.5;\n            vDiffuseLight += max(0.0, 1.0 - length(vToLight)\/5.0) * vLightColour * fNdotL;                \n\t\t\t*\/\n\n\t\t\tfloat fSmoothFactor = fSmoothness * 0.9 + 0.1;\n            float fFresnelClamp = 0.25; \/\/ too much fresnel produces sparkly artefacts\n            float fNdotD = clamp(dot(vBumpNormal, -vRayDir), fFresnelClamp, 1.0);\n\t\t\tvec3 vFresnel = vR0 + (1.0 - vR0) * pow(1.0 - fNdotD, 5.0) * fSmoothFactor;\n\n\t\t\tvResult = mix(vAlbedo * vDiffuseLight, vSpecularLight, vFresnel);\t\t\n\t\t\tvBlendFactor = vFresnel;\n\n\t\t\tApplyAtmosphere(vResult, intersection.fDist, vRayOrigin, vRayDir);\t\t\n\n#ifdef REFLECT_EFFECTS\n            ApplyEffects( vResult, vRayOrigin, vRayDir, intersection.fDist );\n#endif\n            \n\t\t\tvRemaining *= vBlendFactor;\t\t\t\t\n\t\t\tvRayDir = vReflectDir;\n\t\t\tvRayOrigin = intersection.vPos;\n            \n            hitSomething = true;\n            if( i== 0)\n            {\n            \tfirstHitDist = intersection.fDist;\n            }\n\t\t}\t\t\t\n\n\t\tvColour += vResult * vCurrRemaining * fShouldApply;\t\n\t}\n\n    if(!hitSomething)\n    {        \n       vColour = GetSkyColour(_vRayDir)+ GetSkyLight(_vRayDir, 2.0);        \n    }\n\n    \n#ifdef REFLECT_EFFECTS\n    if(!hitSomething)\n#endif\n    ApplyEffects( vColour, _vRayOrigin, _vRayDir, firstHitDist );\n    \n\treturn vColour;\n}\n\n\/\/ ---- 8< -------- 8< -------- 8< -------- 8< ----\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy) + f.xy;\n\treturn texture2D( iChannel2, (uv+ 0.5)\/256.0, -100.0 ).x;\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D( iChannel2, (uv+ 0.5)\/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\/\/ ---- 8< -------- 8< -------- 8< -------- 8< ----\n\n#define float2 vec2\n#define frac fract\n#define fmod mod\n#define ddx dFdx\n#define ddy dFdy\n\nfloat Debug_SevenSegmentSegment( const in float2 inUV, const in float segmentLength, const in float segmentWidth )\n{\n    float2 clampedUV = inUV;\n    clampedUV.x -= clamp(clampedUV.x, 0.0, segmentLength);\n    \n    float2 absUV = abs(clampedUV);\n    float dist = absUV.y + absUV.x;\n    \n    float result = (1.0 - (dist \/  segmentWidth)) * segmentWidth;\n\n    float2 deltas = max( ddx(inUV.xy), ddy(inUV.xy) );            \n    result = result \/ max(deltas.x, deltas.y);\n    \n    return clamp(result, 0.0, 1.0);\n}\n\n\nfloat Debug_SevenSegmentDecimalPoint( const in float2 inUV, const float size )\n{\n    float dist = length( inUV );\n                        \n    float result = (1.0 - (dist \/ size)) * size;\n\n    float2 deltas = max( ddx(inUV.xy), ddy(inUV.xy) );    \n    result = result \/ max(deltas.x, deltas.y);\n    \n    return clamp(result, 0.0, 1.0);\n}\n\n#define DEBUG_SEGMENT_A  0x01\n#define DEBUG_SEGMENT_B  0x02\n#define DEBUG_SEGMENT_C  0x04\n#define DEBUG_SEGMENT_D  0x08\n#define DEBUG_SEGMENT_E  0x10\n#define DEBUG_SEGMENT_F  0x20\n#define DEBUG_SEGMENT_G  0x40\n\n#define DEBUG_7SEGMENT_CODE_BLANK \t0\n#define DEBUG_7SEGMENT_CODE_MINUS \tDEBUG_SEGMENT_G\n\n#define DEBUG_7SEGMENT_CODE_0 (DEBUG_SEGMENT_A + DEBUG_SEGMENT_B + DEBUG_SEGMENT_C + DEBUG_SEGMENT_D + DEBUG_SEGMENT_E + DEBUG_SEGMENT_F)\n#define DEBUG_7SEGMENT_CODE_1 (DEBUG_SEGMENT_B + DEBUG_SEGMENT_C)\n#define DEBUG_7SEGMENT_CODE_2 (DEBUG_SEGMENT_A + DEBUG_SEGMENT_B + DEBUG_SEGMENT_D +  DEBUG_SEGMENT_E + DEBUG_SEGMENT_G)\n#define DEBUG_7SEGMENT_CODE_3 (DEBUG_SEGMENT_A + DEBUG_SEGMENT_B + DEBUG_SEGMENT_C + DEBUG_SEGMENT_D + DEBUG_SEGMENT_G)\n#define DEBUG_7SEGMENT_CODE_4 (DEBUG_SEGMENT_B + DEBUG_SEGMENT_C + DEBUG_SEGMENT_F + DEBUG_SEGMENT_G)\n#define DEBUG_7SEGMENT_CODE_5 (DEBUG_SEGMENT_A + DEBUG_SEGMENT_C + DEBUG_SEGMENT_D +  DEBUG_SEGMENT_F + DEBUG_SEGMENT_G)\n#define DEBUG_7SEGMENT_CODE_6 (DEBUG_SEGMENT_A + DEBUG_SEGMENT_C + DEBUG_SEGMENT_D + DEBUG_SEGMENT_E + DEBUG_SEGMENT_F + DEBUG_SEGMENT_G)\n#define DEBUG_7SEGMENT_CODE_7 (DEBUG_SEGMENT_A + DEBUG_SEGMENT_B + DEBUG_SEGMENT_C)\n#define DEBUG_7SEGMENT_CODE_8 (DEBUG_SEGMENT_A + DEBUG_SEGMENT_B + DEBUG_SEGMENT_C + DEBUG_SEGMENT_D + DEBUG_SEGMENT_E + DEBUG_SEGMENT_F + DEBUG_SEGMENT_G)\n#define DEBUG_7SEGMENT_CODE_9 (DEBUG_SEGMENT_A + DEBUG_SEGMENT_B + DEBUG_SEGMENT_C + DEBUG_SEGMENT_D + DEBUG_SEGMENT_F + DEBUG_SEGMENT_G)\n\n\nint Debug_DigitCode(const in int x)\n{\n    return \tx==0?DEBUG_7SEGMENT_CODE_0\n    :x==1?DEBUG_7SEGMENT_CODE_1\n    :x==2?DEBUG_7SEGMENT_CODE_2\n    :x==3?DEBUG_7SEGMENT_CODE_3\n    :x==4?DEBUG_7SEGMENT_CODE_4\n    :x==5?DEBUG_7SEGMENT_CODE_5\n    :x==6?DEBUG_7SEGMENT_CODE_6\n    :x==7?DEBUG_7SEGMENT_CODE_7\n    :x==8?DEBUG_7SEGMENT_CODE_8\n    :x==9?DEBUG_7SEGMENT_CODE_9:\n    DEBUG_7SEGMENT_CODE_BLANK;\n}\n\n\nbool TestBin( int a, int b )\n{\n    float fa = float(a);\n    float fb = float(b);\n    return fmod( floor(fa \/ fb), 2.0 ) > 0.0;\n}\n\n\nfloat SegmentBrightness( bool enabled )\n{\n    if( enabled ) return 1.0;\n    else \n        return 0.0;\n}\n\n\nfloat Debug_PrintDigit( const in float2 inUV, int digit, bool decimalPoint )\n{\n    const float fThickness = 0.06;    \n    const float fSegSize = 0.2;\n    const float fSpacing = 0.075;\n    const float decimalPointThickness = 0.095;    \n    \n    float fShade = 0.0;\n    \n    float2 uv = inUV * float2(0.7, 1.0);\n    uv.x += uv.y * -0.2;\n    \n    fShade += Debug_SevenSegmentSegment( ( uv - float2(fSpacing * 2.0, fSpacing * 5.0 + fSegSize * 2.0) ), fSegSize, fThickness) * SegmentBrightness( TestBin(digit, DEBUG_SEGMENT_A) );\n    fShade += Debug_SevenSegmentSegment( ( uv - float2(fSpacing * 3.0 + fSegSize, fSpacing * 4.0 + fSegSize) ).yx, fSegSize, fThickness) * SegmentBrightness( TestBin(digit, DEBUG_SEGMENT_B) );\n    fShade += Debug_SevenSegmentSegment( ( uv - float2(fSpacing * 3.0 + fSegSize, fSpacing * 2.0) ).yx, fSegSize, fThickness) * SegmentBrightness( TestBin(digit, DEBUG_SEGMENT_C) );    \n    fShade += Debug_SevenSegmentSegment( ( uv - float2(fSpacing * 2.0, fSpacing) ), fSegSize, fThickness) * SegmentBrightness( TestBin(digit, DEBUG_SEGMENT_D) );\n    fShade += Debug_SevenSegmentSegment( ( uv - float2(fSpacing, fSpacing * 2.0) ).yx, fSegSize, fThickness) * SegmentBrightness( TestBin(digit, DEBUG_SEGMENT_E) );\n    fShade += Debug_SevenSegmentSegment( ( uv - float2(fSpacing, fSpacing * 4.0 + fSegSize ) ).yx, fSegSize, fThickness) * SegmentBrightness( TestBin(digit, DEBUG_SEGMENT_F) );    \n    fShade += Debug_SevenSegmentSegment( ( uv - float2(fSpacing * 2.0, fSpacing * 3.0 + fSegSize) ), fSegSize, fThickness) * SegmentBrightness( TestBin(digit, DEBUG_SEGMENT_G) );\n    fShade += Debug_SevenSegmentDecimalPoint( inUV - float2(0.9, 0.1), decimalPointThickness) * SegmentBrightness( decimalPoint );\n    \n    fShade = clamp(fShade, 0.0, 1.0);\n    return sqrt(fShade);\n}\n\n\nfloat Debug_PrintInteger( const in float2 uv, const in float2 fontSize, const in float value, const in float maxDigits )\n{\n    float2 stringCharCoords = uv \/ fontSize;\n    if ((stringCharCoords.y < 0.0) || (stringCharCoords.y >= 1.0)) return 0.0;\n    \n\tfloat fLog10Value = log2(abs(value)) \/ log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = maxDigits - ceil(stringCharCoords.x);\n\tint charCode = 0;\n\n    if(fDigitIndex < 0.0) \n    {\n    \treturn 0.0;\n    }\n\n    if(fDigitIndex > (fBiggestIndex + ((value < 0.0) ? 1.0 : 0.0)) ) \n    {\n        return 0.0;\n    }\n\n    if(fDigitIndex > fBiggestIndex) \n    {\n        if ((value < 0.0) && (fDigitIndex < (fBiggestIndex+1.5)))\n        {\n            charCode = DEBUG_7SEGMENT_CODE_MINUS;\n        }\n    }\n    else \n    {\t\t\n        float fDigitValue = (abs(value \/ (pow(10.0, fDigitIndex))));\n        float kFix = 0.0001;\n        charCode = Debug_DigitCode(int(floor(fmod(kFix+fDigitValue, 10.0))));\n    }\n    \n    float result = Debug_PrintDigit( frac(stringCharCoords), charCode, false );\n\n    return result;\n    \n}\n\nfloat Debug_PrintFloatApprox( const in float2 uv, const in float2 fontSize, const in float value, const in float maxDigits, const in float decimalPlaces )\n{\n    float2 stringCharCoords = uv \/ fontSize;\n    if ((stringCharCoords.y < 0.0) || (stringCharCoords.y >= 1.0)) return 0.0;\n    \n\tfloat fLog10Value = log2(abs(value)) \/ log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = maxDigits - ceil(stringCharCoords.x);\n\tint charCode = 0;\n    bool decimalPoint = false;\n\tif(fDigitIndex <= (-decimalPlaces - 0.5)) \n    {\n    \treturn 0.0;\n    }\n\n    if(fDigitIndex > (fBiggestIndex + ((value < 0.0) ? 1.0 : 0.0)) ) \n    {\n        return 0.0;\n    }\n\n    if(fDigitIndex > fBiggestIndex) \n    {\n        if ((value < 0.0) && (fDigitIndex < (fBiggestIndex+1.5)))\n        {\n            charCode = DEBUG_7SEGMENT_CODE_MINUS;\n        }\n    }\n    else \n    {\t\t\n        if(fDigitIndex == 0.0 && decimalPlaces > 0.0 ) \n        {\n            decimalPoint = true;\n        }\n        float fDigitValue = (abs(value \/ (pow(10.0, fDigitIndex))));\n        float kFix = 0.0001;\n        charCode = Debug_DigitCode(int(floor(fmod(kFix+fDigitValue, 10.0))));\n    }\n    \n    float result = Debug_PrintDigit( frac(stringCharCoords), charCode, decimalPoint );\n\n    return result;\n}\n\n","name":"","description":"","type":"image"},{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/#define DISABLE_SOUND \n\n#define N(T,N) t+=float(T); if(x>t) r=vec2(N,t);\n#define L(T,N,X) t+=float(T); if((x>t) && (x<(t+float(X)))) r=vec2(N,t);\n\n\/* Start of main()\nHeader.id='MThd'\nHeader.size=6\nReading MThd Chunk\nType: 1, trackCount: 8, timeBase: 96\nHeader.id='MTrk'\nHeader.size=99\nReading MTrk Chunk\nTime signature\nTempo\nTime signature\nTime signature\nTime signature\nTime signature\nTempo\nTime signature\nTime signature\nTime signature\nTime signature\nEnd of track\nHeader.id='MTrk'\nHeader.size=4158\nReading MTrk Chunk\nTrack Name:'Trumpet'\nTime signature\nTempo\nTime signature\nTime signature\nTime signature\nTime signature\nTempo\nTime signature\nTime signature\nTime signature\nTime signature\nEnd of track\nHeader.id='MTrk'\nHeader.size=4318\nReading MTrk Chunk\nTrack Name:'Trombone'\nTime signature\nTempo\nTime signature\nTime signature\nTime signature\nTime signature\nTempo\nTime signature\nTime signature\nTime signature\nTime signature\nEnd of track\nHeader.id='MTrk'\nHeader.size=10524\nReading MTrk Chunk\nTrack Name:'Treble Strings'\nTime signature\nTempo\nTime signature\nTime signature\nTime signature\nTime signature\nTempo\nTime signature\nTime signature\nTime signature\nTime signature\nEnd of track\nHeader.id='MTrk'\nHeader.size=13845\nReading MTrk Chunk\nTrack Name:'Contrabass'\nTime signature\nTempo\nTime signature\nTime signature\nTime signature\nTime signature\nTempo\nTime signature\nTime signature\nTime signature\nTime signature\nEnd of track\nHeader.id='MTrk'\nHeader.size=2291\nReading MTrk Chunk\nTrack Name:'Timpani'\nTime signature\nTempo\nTime signature\nTime signature\nTime signature\nTime signature\nTempo\nTime signature\nTime signature\nTime signature\nTime signature\nEnd of track\nHeader.id='MTrk'\nHeader.size=2303\nReading MTrk Chunk\nTrack Name:'Tuba'\nTime signature\nTempo\nTime signature\nTime signature\nTime signature\nTime signature\nTempo\nTime signature\nTime signature\nTime signature\nTime signature\nEnd of track\nHeader.id='MTrk'\nHeader.size=2280\nReading MTrk Chunk\nTrack Name:'Pizzicato strings'\nTime signature\nTempo\nTime signature\nTime signature\nTime signature\nTime signature\nTempo\nTime signature\nTime signature\nTime signature\nTime signature\nEnd of track\n*\/\nvec2 GetTrack0Note(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    return r;\n}\n\nvec2 GetTrack1ANote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(0,67) N(48,72) N(48,67) N(48,74) N(48,79) N(48,72) N(192,65) N(192,71) N(336,72) N(24,74) N(24,72)\n    N(64,69) N(64,65) N(64,71) N(144,72) N(24,74) N(24,72) N(96,67) N(96,72) N(96,79) N(96,79) N(192,78)\n    N(144,76) N(24,78) N(24,79) N(768,74) N(128,76) N(32,74) N(32,72) N(64,74) N(64,72) N(64,74) N(288,79)\n    N(96,77) N(128,76) N(32,74) N(32,76) N(64,74) N(64,72) N(64,74) N(192,62) N(64,69) N(64,71) N(64,72)\n    N(128,76) N(64,79) N(128,81) N(64,82) N(64,74) N(64,77) N(64,77) N(64,72) N(64,77) N(64,74) N(128,72)\n    N(32,70) N(32,70) N(576,72) N(128,70) N(32,68) N(32,68) N(576,58) N(128,56) N(32,54) N(32,54) N(192,70)\n    return r;\n}\n\nvec2 GetTrack1BNote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(2928,77) N(192,76) N(1920,81) N(192,77) N(128,75) N(32,74) N(32,74) N(576,75) N(128,73) N(32,72)\n    N(32,72) N(576,61) N(128,59) N(32,58) N(32,58) N(192,73)\n    return r;\n}\n\nvec2 GetTrack2ANote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(0,55) N(48,60) N(48,55) N(48,62) N(48,67) N(48,60) N(192,57) N(192,59) N(384,60) N(64,57) N(64,53)\n    N(64,55) N(192,60) N(96,55) N(96,57) N(96,57) N(96,69) N(192,62) N(192,62) N(768,62) N(192,60) N(192,67)\n    N(128,67) N(32,67) N(32,67) N(192,58) N(192,55) N(192,62) N(128,62) N(32,62) N(32,62) N(64,69) N(64,71)\n    N(64,72) N(128,71) N(32,69) N(32,71) N(64,67) N(64,74) N(64,74) N(64,74) N(64,72) N(32,70) N(32,72)\n    N(64,72) N(64,77) N(64,74) N(128,72) N(32,70) N(32,70) N(576,72) N(128,70) N(32,68) N(32,68) N(576,61)\n    N(128,59) N(32,58) N(32,58) N(192,70)\n    return r;\n}\n\nvec2 GetTrack2BNote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(240,65) N(192,53) N(192,62) N(384,65) N(64,65) N(64,65) N(64,59) N(192,64) N(96,60) N(96,64) N(96,64)\n    N(96,72) N(192,69) N(192,67) N(768,69) N(192,67) N(192,72) N(128,72) N(32,72) N(32,71) N(192,70) N(192,67)\n    return r;\n}\n\nvec2 GetTrack2CNote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(240,69) N(192,60) N(192,67) N(384,69) N(64,69) N(128,62) N(192,67) N(96,64) N(96,69) N(96,72) N(288,74)\n    N(192,71) N(1536,74)\n    return r;\n}\n\nvec2 GetTrack2DNote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(1200,67) N(288,67) N(192,76)\n    return r;\n}\n\nvec2 GetTrack3ANote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(0,79) N(48,84) N(48,79) N(48,86) N(48,91) N(48,77) N(192,65) N(192,71) N(336,84) N(24,86) N(24,84)\n    N(64,81) N(64,77) N(64,83) N(144,84) N(24,86) N(24,76) N(96,72) N(96,67) N(96,76) N(96,72) N(192,69)\n    N(144,76) N(24,78) N(24,67) N(768,69) N(128,76) N(32,74) N(32,67) N(64,67) N(64,67) N(64,60) N(192,59)\n    N(192,74) N(128,76) N(32,74) N(32,64) N(64,62) N(64,60) N(64,62) N(192,74) N(192,72) N(192,71) N(192,82)\n    N(192,81) N(192,62) N(384,68) N(384,60) N(384,66) N(384,58) N(384,73)\n    return r;\n}\n\nvec2 GetTrack3BNote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(240,81) N(192,72) N(192,79) N(768,79) N(96,76) N(96,72) N(96,81) N(96,69) N(192,74) N(144,88) N(24,90)\n    N(24,86) N(768,77) N(192,76) N(64,74) N(64,72) N(64,72) N(192,67) N(192,70) N(192,67) N(64,67) N(64,72)\n    N(64,66) N(192,62) N(384,67) N(192,74) N(192,72) N(192,77) N(384,74) N(384,75) N(384,72) N(384,73)\n    return r;\n}\n\nvec2 GetTrack3CNote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(240,84) N(192,77) N(192,83) N(768,84) N(96,79) N(96,84) N(96,91) N(96,81) N(192,81) N(192,91) N(768,74)\n    N(192,72) N(192,74) N(192,71) N(192,77) N(192,76) N(64,74)\n    return r;\n}\n\nvec2 GetTrack3DNote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(1776,91) N(192,90)\n    return r;\n}\n\nvec2 GetTrack4ANote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(0,43) N(48,48) N(48,43) N(48,50) N(48,57) L(48,53,12) L(24,41,12) L(24,53,12) L(24,41,12) L(24,53,12)\n    L(24,53,12) L(24,53,12) L(24,53,12) L(24,53,12) L(24,53,12) L(24,53,12) L(24,53,12) L(24,53,12) L(24,53,12)\n    L(24,53,12) L(24,53,12) L(24,41,12) L(24,53,12) L(24,41,12) L(24,53,12) L(24,41,12) L(24,41,12) L(24,41,12)\n    L(24,41,12) L(24,41,12) L(24,41,12) L(24,41,12) L(24,41,12) L(24,41,12) L(24,41,12) L(24,41,12) L(24,41,12)\n    N(24,48) N(192,55) N(96,50) N(192,40) N(192,45) N(192,45) N(144,54) N(96,57) L(48,43,12) L(24,31,12)\n    L(24,43,12) L(24,31,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12)\n    L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,31,12) L(24,43,12) L(24,31,12)\n    L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12)\n    L(24,43,12) L(24,43,12) L(24,43,12) N(24,57) N(192,55) L(192,43,12) L(24,55,12) L(24,43,12) L(24,55,12)\n    L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12)\n    L(24,43,12) L(24,43,12) L(24,43,12) L(24,55,12) L(24,43,12) L(24,55,12) L(24,43,12) L(24,55,12) L(24,55,12)\n    L(24,55,12) L(24,55,12) L(24,55,12) L(24,55,12) L(24,55,12) L(24,55,12) L(24,55,12) L(24,55,12) L(24,55,12)\n    L(24,55,12) N(24,54) N(192,57) N(192,41) N(192,40) N(192,39) N(192,38) N(384,32) L(192,44,12) L(24,32,12)\n    L(24,44,12) L(24,32,12) L(24,44,12) L(24,44,12) L(24,44,12) L(24,44,12) L(24,44,12) L(24,44,12) L(24,44,12)\n    L(24,44,12) L(24,44,12) L(24,44,12) L(24,44,12) L(24,44,12) N(216,42) L(192,30,12) L(24,42,12) L(24,30,12)\n    L(24,42,12) L(24,30,12) L(24,30,12) L(24,30,12) L(24,30,12) L(24,30,12) L(24,30,12) L(24,30,12) L(24,30,12)\n    L(24,30,12) L(24,30,12) L(24,30,12) L(24,30,12) N(216,28) L(192,40,12) L(24,28,12) L(24,40,12)\n    return r;\n}\n\nvec2 GetTrack4BNote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    L(240,41,12) L(24,53,12) L(24,41,12) L(24,53,12) L(24,41,12) L(24,41,12) L(24,41,12) L(24,41,12) L(24,41,12)\n    L(24,41,12) L(24,41,12) L(24,41,12) L(24,41,12) L(24,41,12) L(24,41,12) L(24,41,12) L(24,53,12) L(24,41,12)\n    L(24,53,12) L(24,41,12) L(24,53,12) L(24,53,12) L(24,53,12) L(24,53,12) L(24,53,12) L(24,53,12) L(24,53,12)\n    L(24,53,12) L(24,53,12) L(24,53,12) L(24,53,12) L(24,53,12) N(24,41) N(192,41) N(96,41) N(576,38)\n    N(144,38) N(96,38) L(48,31,12) L(24,43,12) L(24,31,12) L(24,43,12) L(24,31,12) L(24,31,12) L(24,31,12)\n    L(24,31,12) L(24,31,12) L(24,31,12) L(24,31,12) L(24,31,12) L(24,31,12) L(24,31,12) L(24,31,12) L(24,31,12)\n    L(24,31,12) L(24,43,12) L(24,31,12) L(24,43,12) L(24,31,12) L(24,31,12) L(24,31,12) L(24,31,12) L(24,31,12)\n    L(24,31,12) L(24,31,12) L(24,31,12) L(24,31,12) L(24,31,12) L(24,31,12) L(24,31,12) N(24,38) N(192,40)\n    L(192,55,12) L(24,43,12) L(24,55,12) L(24,43,12) L(24,55,12) L(24,55,12) L(24,55,12) L(24,55,12) L(24,55,12)\n    L(24,55,12) L(24,55,12) L(24,55,12) L(24,55,12) L(24,55,12) L(24,55,12) L(24,55,12) L(24,43,12) L(24,55,12)\n    L(24,43,12) L(24,55,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12)\n    L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) N(24,50) N(192,52) N(192,53) N(192,52)\n    N(192,51) N(192,50) N(384,44) L(192,32,12) L(24,44,12) L(24,32,12) L(24,44,12) L(24,32,12) L(24,32,12)\n    L(24,32,12) L(24,32,12) L(24,32,12) L(24,32,12) L(24,32,12) L(24,32,12) L(24,32,12) L(24,32,12) L(24,32,12)\n    L(24,32,12) N(216,30) L(192,42,12) L(24,30,12) L(24,42,12) L(24,30,12) L(24,42,12) L(24,42,12) L(24,42,12)\n    L(24,42,12) L(24,42,12) L(24,42,12) L(24,42,12) L(24,42,12) L(24,42,12) L(24,42,12) L(24,42,12) L(24,42,12)\n    N(216,40) L(192,28,12) L(24,40,12) L(24,28,12)\n    return r;\n}\n\nvec2 GetTrack4CNote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    L(252,41,12) L(24,41,12) L(24,53,12) L(24,53,12) L(24,53,12) L(24,53,12) L(24,53,12) L(24,53,12) L(24,53,12)\n    L(24,53,12) L(24,53,12) L(24,53,12) L(24,53,12) L(24,53,12) L(24,53,12) L(24,53,12) L(24,53,12) L(24,53,12)\n    L(24,41,12) L(24,41,12) L(24,41,12) L(24,41,12) L(24,41,12) L(24,41,12) L(24,41,12) L(24,41,12) L(24,41,12)\n    L(24,41,12) L(24,41,12) L(24,41,12) L(24,41,12) L(24,41,12) N(204,50) L(972,31,12) L(24,31,12) L(24,43,12)\n    L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12)\n    L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,31,12) L(24,31,12) L(24,43,12) L(24,43,12) L(24,43,12)\n    L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12)\n    L(24,43,12) N(24,43) N(204,52) L(204,55,12) L(24,55,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12)\n    L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12)\n    L(24,43,12) L(24,43,12) L(24,43,12) L(24,55,12) L(24,55,12) L(24,55,12) L(24,55,12) L(24,55,12) L(24,55,12)\n    L(24,55,12) L(24,55,12) L(24,55,12) L(24,55,12) L(24,55,12) L(24,55,12) L(24,55,12) N(24,55) L(1560,32,12)\n    L(24,32,12) L(24,44,12) L(24,44,12) L(24,44,12) L(24,44,12) L(24,44,12) L(24,44,12) L(24,44,12) L(24,44,12)\n    L(24,44,12) L(24,44,12) L(24,44,12) L(24,44,12) L(24,44,12) N(24,44) L(408,42,12) L(24,42,12) L(24,30,12)\n    L(24,30,12) L(24,30,12) L(24,30,12) L(24,30,12) L(24,30,12) L(24,30,12) L(24,30,12) L(24,30,12) L(24,30,12)\n    L(24,30,12) L(24,30,12) L(24,30,12) N(24,30) L(408,28,12) L(24,28,12)\n    return r;\n}\n\nvec2 GetTrack4DNote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    L(252,53,12) L(24,53,12) L(24,41,12) L(24,41,12) L(24,41,12) L(24,41,12) L(24,41,12) L(24,41,12) L(24,41,12)\n    L(24,41,12) L(24,41,12) L(24,41,12) L(24,41,12) L(24,41,12) L(24,41,12) L(24,41,12) L(24,41,12) L(24,41,12)\n    L(24,53,12) L(24,53,12) L(24,53,12) L(24,53,12) L(24,53,12) L(24,53,12) L(24,53,12) L(24,53,12) L(24,53,12)\n    L(24,53,12) L(24,53,12) L(24,53,12) L(24,53,12) N(24,53) L(1176,43,12) L(24,43,12) L(24,31,12) L(24,31,12)\n    L(24,31,12) L(24,31,12) L(24,31,12) L(24,31,12) L(24,31,12) L(24,31,12) L(24,31,12) L(24,31,12) L(24,31,12)\n    L(24,31,12) L(24,31,12) L(24,31,12) L(24,43,12) L(24,43,12) L(24,31,12) L(24,31,12) L(24,31,12) L(24,31,12)\n    L(24,31,12) L(24,31,12) L(24,31,12) L(24,31,12) L(24,31,12) L(24,31,12) L(24,31,12) L(24,31,12) L(24,31,12)\n    N(24,31) L(408,43,12) L(24,43,12) L(24,55,12) L(24,55,12) L(24,55,12) L(24,55,12) L(24,55,12) L(24,55,12)\n    L(24,55,12) L(24,55,12) L(24,55,12) L(24,55,12) L(24,55,12) L(24,55,12) L(24,55,12) L(24,55,12) L(24,55,12)\n    L(24,55,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12)\n    L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) L(24,43,12) N(24,43) L(1560,44,12) L(24,44,12) L(24,32,12)\n    L(24,32,12) L(24,32,12) L(24,32,12) L(24,32,12) L(24,32,12) L(24,32,12) L(24,32,12) L(24,32,12) L(24,32,12)\n    L(24,32,12) L(24,32,12) L(24,32,12) N(24,32) L(408,30,12) L(24,30,12) L(24,42,12) L(24,42,12) L(24,42,12)\n    L(24,42,12) L(24,42,12) L(24,42,12) L(24,42,12) L(24,42,12) L(24,42,12) L(24,42,12) L(24,42,12) L(24,42,12)\n    L(24,42,12) N(24,42) L(408,40,12) L(24,40,12)\n    return r;\n}\n\nvec2 GetTrack4ENote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(2928,50)\n    return r;\n}\n\nvec2 GetTrack5ANote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(1008,36) N(288,41) N(192,40) N(192,45) N(192,38) N(144,38) N(96,38) N(48,43) N(24,43) N(24,43) N(24,43)\n    N(24,43) N(24,43) N(24,43) N(24,43) N(24,43) N(24,43) N(24,43) N(24,43) N(24,43) N(24,43) N(24,43)\n    N(24,43) N(24,43) N(96,43) N(96,43) N(96,43) N(96,50) N(192,52) N(192,55) N(384,46) N(192,48) N(192,38)\n    return r;\n}\n\nvec2 GetTrack5BNote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(1008,41) N(288,50) N(876,38) N(24,38) N(24,38) N(24,38) N(24,38) N(24,38) N(24,38) N(24,38) N(24,38)\n    N(24,38) N(24,38) N(24,38) N(24,38) N(24,38) N(24,38) N(24,38) N(396,38) N(192,40) N(192,43) N(768,50)\n    return r;\n}\n\nvec2 GetTrack6ANote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(240,53) N(384,59) N(384,48) N(288,50) N(192,40) N(192,45) N(192,50) N(144,50) N(96,50) N(48,55)\n    N(768,38) N(192,40) N(192,55) N(384,34) N(192,36) N(192,50) N(192,40) N(192,41) N(192,40) N(192,39)\n    N(192,38) N(384,32) N(768,30) N(768,28)\n    return r;\n}\n\nvec2 GetTrack6BNote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(240,41) N(384,41) N(384,41) N(288,41) N(576,38) N(144,38) N(96,38) N(48,43) N(1152,43) N(384,53)\n    N(192,48) N(192,38) N(192,52) N(192,53) N(192,52) N(192,51) N(192,50) N(384,44) N(768,42) N(768,40)\n    return r;\n}\n\nvec2 GetTrack6CNote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(3696,46)\n    return r;\n}\n\nvec2 GetTrack7Note(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    return r;\n}\n\n\n\/\/ ------------------- 8< ------------------- 8< ------------------- 8< -------------------\n\n\n#define PI radians(180.0)\n#define TWO_PI radians(360.0)\n\nfloat NoteToHz(float n)\n{  \t\n\treturn 440.0*pow( 2.0, (n-69.0)\/12.0 );\n}\n\nfloat Tri( float t )\n{\n\treturn abs(fract( t ) * 4.0 - 2.0) - 1.0;\n}\n\nfloat Saw( float t )\n{\n\treturn fract( t ) * 2.0 - 1.0;\n}\n\nvec4 Saw4( vec4 x )\n{\n\treturn fract( x ) * 2.0 - 1.0;\n}\n\nfloat Sin( float t )\n{\n\treturn sin( t * radians(360.0) );\n}\n\nfloat Cos( float t )\n{\n\treturn cos( t * radians(360.0) );\n}\n\nvec4 Cos4( vec4 x )\n{\n\tx = abs(fract(x) * 2.0 - 1.0);\n\tvec4 x2 = x*x;\n\treturn x2 * 6.0 - x2*x * 4.0  - 1.0;\n}\n\nfloat Square( float t )\n{\n\treturn step( fract(t), 0.5 ) * 2.0 - 1.0;\n}\n\n\/\/ Thanks to Dave_Hoskins for the hash\nfloat Hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nfloat Noise( float x )\n{\n\treturn Hash( floor(x * 32.0) ) * 2.0 - 1.0;\n}\n\nfloat SmoothNoise( float t )\n{\n\tfloat noiset = t * 32.0;\n\tfloat tfloor = floor(noiset);\n\tfloat ffract = fract(noiset);\n\t\n\tfloat n0 = Hash(tfloor);\n\tfloat n1 = Hash(tfloor + 1.0);\n\tfloat blend = ffract*ffract*(3.0 - 2.0*ffract);\n\treturn mix(n0, n1, blend) * 2.0 - 1.0;\n}\n\nfloat FBM( float t, float persistence )\n{\n    float result = 0.0;\n    \n    float a = 1.0;\n    float tot = 0.0;\n    result += SmoothNoise(t) * a; tot += a; t *= 2.02; a *= persistence;\n    result += SmoothNoise(t) * a; tot += a; t *= 2.02; a *= persistence; \n    result += SmoothNoise(t) * a; tot += a; t *= 2.02; a *= persistence; \n    result += SmoothNoise(t) * a; tot += a; t *= 2.02; a *= persistence; \n    tot += a; \n    return result \/ tot;\n}\n\n\nfloat StepNoise( float t, float freq )\n{\n\tfloat noiset = t * freq;\n\tfloat tfloor = floor(noiset);\n\t\n\tfloat n = Hash(tfloor);\n\treturn n * 2.0 - 1.0;\n}\n\nfloat Cos4(float x, vec4 phase, vec4 freq, vec4 amp)\n{\n\treturn dot(Cos4((x+phase) * freq), amp);\n}\n\nfloat Saw4(float x, vec4 phase, vec4 freq, vec4 amp)\n{\n\treturn dot(Saw4((x+phase) * freq), amp);\n}\n\n\nfloat Test( float t )\n{\n\treturn Saw4(t, vec4(0.0, 0.5, 0.1, 0.4), vec4(1.0, 1.50, 2.00, -3.00), vec4(1.0, 0.5, 0.25, 0.125));\n}\n\nfloat Envelope( float time, float decay )\n{\t\n\treturn exp2( -time * (5.0 \/ decay) );\n}\n\nfloat Envelope( float time, float attack, float decay )\n{\n\tif( time < attack )\n\t{\n\t\treturn time\/attack;\n\t}\n\n\ttime -= attack;\n\n\treturn Envelope( time, decay );\n}\n\nfloat Test2(float f)\n{\n    return Test(f) + Test(f - 0.0454) * 0.4 + Test(f - 0.1123) * 0.3 + Test(f - 0.1523) * 0.1;\n}\n\nfloat Instrument( const in vec2 vFreqTime )\n{\n    float f = vFreqTime.x;\n    float t = vFreqTime.y;\n    \n    if( t < 0.0 )\n        return 0.0;\n    float x = 0.0;\n    float a = 0.5;\n    float h = 1.0;\n    float p = 0.0;\n    for(int i=0; i<8; i++)\n    {\n        x += Sin( f * t * h + p ) * exp2( t * -a );\n        x += Sin( f * (t+0.005) * h * 0.5 + p ) * exp2( t * -a * 2.0 ) ;\n        \/\/x += Sin( f * t * h + p ) * exp2( t * -a );\n        \/\/x += Sin( f * (t+0.005) * h * 0.5 + p ) * exp2( t * -a * 2.0 ) ;\n        h = h + 1.01;\n        a = a * 2.0;\n        p += 0.1;\n    }\n    \n    return x;\n}\n\nfloat Instr( const in vec2 vFreqTime )\n{\n    float f = vFreqTime.x;\n    float t = vFreqTime.y;\n    \n    float d = f * t + Sin(f * t * 0.5) * exp2(t * -5.0) * 2.0;\n    float x = Sin(d);\n    \n    return x * exp2(t * -1.0) * 2.0;\n}\n\n\nfloat Track1Instrument( const in vec2 vFreqTime )\n{\n    return Instr( vFreqTime );\n}\n\nfloat Track2Instrument( const in vec2 vFreqTime )\n{\n    return Instrument( vFreqTime ) * 0.5;\n}\n\nfloat Track3Instrument( const in vec2 vFreqTime )\n{\n    return 2.0 * (Tri(vFreqTime.x * vFreqTime.y) + Saw(vFreqTime.x * vFreqTime.y * 0.5 + 0.01) * 0.5) * Envelope(vFreqTime.y, 4.0);\n}\n\nfloat Track4Instrument( const in vec2 vFreqTime )\n{\n     return Instrument( vFreqTime ) * 0.2;\n}\n\n\nconst float kMidiTimebase = 240.0;\nconst float kInvMidiTimebase = 1.0 \/ kMidiTimebase;\n\nvec2 GetNoteData( const in vec2 vMidiResult, const in float fMidiTime )\n{\n    return vec2( NoteToHz(vMidiResult.x), abs(fMidiTime - vMidiResult.y) * kInvMidiTimebase );\n}\n\nfloat PlayMidi( const in float time )\n{\n#ifdef DISABLE_SOUND\n\treturn 0.0;\n#else\n    if(time < 0.0)\n\t\treturn 0.0;\n    \n    float fMidiTime = time * kMidiTimebase;\n    \n    float fResult = 0.0;\n    \n    fResult += Track1Instrument( GetNoteData( GetTrack1ANote(fMidiTime), fMidiTime ) );\n    fResult += Track1Instrument( GetNoteData( GetTrack1BNote(fMidiTime), fMidiTime ) );\n    \/\/fResult += Track1Instrument( GetNoteData( GetTrack1CNote(fMidiTime), fMidiTime ) );\n\n    fResult += Track2Instrument( GetNoteData( GetTrack2ANote(fMidiTime), fMidiTime ) );\n    fResult += Track2Instrument( GetNoteData( GetTrack2BNote(fMidiTime), fMidiTime ) );\n    fResult += Track2Instrument( GetNoteData( GetTrack2CNote(fMidiTime), fMidiTime ) );\n    fResult += Track2Instrument( GetNoteData( GetTrack2DNote(fMidiTime), fMidiTime ) );\n\n    fResult += Track3Instrument( GetNoteData( GetTrack3ANote(fMidiTime), fMidiTime ) );\n    fResult += Track3Instrument( GetNoteData( GetTrack3BNote(fMidiTime), fMidiTime ) );\n    fResult += Track3Instrument( GetNoteData( GetTrack3CNote(fMidiTime), fMidiTime ) );\n    fResult += Track3Instrument( GetNoteData( GetTrack3DNote(fMidiTime), fMidiTime ) );\n\n    fResult += Track4Instrument( GetNoteData( GetTrack4ANote(fMidiTime), fMidiTime ) );\n    fResult += Track4Instrument( GetNoteData( GetTrack4BNote(fMidiTime), fMidiTime ) );\n    fResult += Track4Instrument( GetNoteData( GetTrack4CNote(fMidiTime), fMidiTime ) );\n    fResult += Track4Instrument( GetNoteData( GetTrack4DNote(fMidiTime), fMidiTime ) );\n\n    fResult += Track2Instrument( GetNoteData( GetTrack5ANote(fMidiTime), fMidiTime ) );\n    fResult += Track2Instrument( GetNoteData( GetTrack5BNote(fMidiTime), fMidiTime ) );\n    \/\/fResult += Track2Instrument( GetNoteData( GetTrack5CNote(fMidiTime), fMidiTime ) );\n    \/\/fResult += Track2Instrument( GetNoteData( GetTrack5DNote(fMidiTime), fMidiTime ) );\n\n    fResult += Track4Instrument( GetNoteData( GetTrack6ANote(fMidiTime), fMidiTime ) );\n    fResult += Track4Instrument( GetNoteData( GetTrack6BNote(fMidiTime), fMidiTime ) );\n    \n    fResult = clamp(fResult * 0.05, -1.0, 1.0);\n    \/*\n    float fFadeEnd = 20.0 * 240.0 \/ kMidiTimebase;\n    float fFadeTime = 5.0;\n    float fFade = (time - (fFadeEnd - fFadeTime)) \/ fFadeTime;    \n    fResult *= clamp(1.0 - fFade, 0.0, 1.0);\n    *\/\n    return fResult;\n#endif\n}\n\nvec2 mainSound(float time)\n{\n    return vec2( PlayMidi(time ) );\n}\n\n\/\/#define IMAGE_SHADER\n\n#ifdef IMAGE_SHADER\n\nfloat Function( float x )\n{\n\treturn mainSound( iGlobalTime + x \/ (44100.0 \/ 60.0) ).x * 0.5 + 0.5;\n}\n\nfloat Plot( vec2 uv )\n{\n\tfloat y = Function(uv.x);\n\t\n\treturn abs(y - uv.y) * iResolution.y;\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\t\n\tvec3 vResult = vec3(0.0);\n\t\n\tvResult += Plot(uv);\n\t\n\tfragColor = vec4((vResult),1.0);\n}\n#endif\n","name":"","description":"","type":"sound"}]}}