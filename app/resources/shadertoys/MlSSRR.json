{"Shader":{"ver":"0.1","info":{"id":"MlSSRR","date":"1440891864","viewed":912,"name":"Noise Tutorial","username":"akaitora","description":"This tutorial teaches how to generate noise procedurally in a shader.","likes":10,"published":3,"flags":0,"tags":["noise","tutorial","fbm","fractionbrownianmotion"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ GLSL Noise Tutorial\n\/\/ By: Brandon Fogerty\n\/\/ bfogerty at gmail dot com\n\/\/ xdpixel.com\n\/\/ Special thanks to IQ and Scratch a Pixel!\n\n\/\/ Noise can be used to generate various kinds of effects in computer graphics.\n\/\/ Learning how to generate noise in a shader will help you greatly in\n\/\/ creating cool glsl shader effects!\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\/\/ GLSL doesn't have a random function.  So we have to create one ourself.\n\/\/ We would like a random number somewhere between 0.0 and 1.0.\n\/\/ We can get that by using the fract function which returns the fractional\n\/\/ component of a number.  The constant numbers in this function don't matter\n\/\/ too much.  They just need to be random.\nfloat hash( vec2 p )\n{\n    return fract( sin( dot(p, vec2( 15.79, 81.93  ) ) * 45678.9123 ) );\n}\n\n\/\/ Our valueNoise function will bilinearly interpolate a lattice (aka grid)\n\/\/ and return a smoothed value. This function will essentially allow us to generate\n\/\/ 2D static.  Bilinear interpolation basically allows us to transform our 1D hash function to a value based on a 2D grid.\n\/\/ This will eventually be run through an fbm to help us generate a \n\/\/ cloud like pattern.\n\/\/ For more information about biliear filtering, check out Scratch A Pixel's article.\n\/\/ http:\/\/www.scratchapixel.com\/old\/lessons\/3d-advanced-lessons\/interpolation\/bilinear-interpolation\/\n\/\/ For more info on Value based noise check this url out\n\/\/ http:\/\/www.scratchapixel.com\/old\/lessons\/3d-advanced-lessons\/noise-part-1\/creating-a-simple-2d-noise\/\nfloat valueNoise( vec2 p )\n{\n    \/\/ i is an integer that allow us to move along grid points.\n    vec2 i = floor( p );\n    \/\/ f will be used as an offset between the grid points.\n    vec2 f = fract( p );\n    \n    \/\/ Hermite Curve.\n    \/\/ The formula 3f^2 - 2f^3 generates an S curve between 0.0 and 1.0.\n    \/\/ If we factor out the variable f, we get f*f*(3.0 - 2.0*f)\n    \/\/ This allows us to smoothly interpolate along an s curve between our grid points.\n    \/\/ To see the S curve graph, go to the following url.\n    \/\/ https:\/\/www.desmos.com\/calculator\/mnrgw3yias\n    f = f*f*(3.0 - 2.0*f);\n    \n    \/\/ Interpolate the along the bottom of our grid.\n    float bottomOfGrid =    mix( hash( i + vec2( 0.0, 0.0 ) ), hash( i + vec2( 1.0, 0.0 ) ), f.x );\n    \/\/ Interpolate the along the top of our grid.\n    float topOfGrid =       mix( hash( i + vec2( 0.0, 1.0 ) ), hash( i + vec2( 1.0, 1.0 ) ), f.x );\n\n    \/\/ We have now interpolated the horizontal top and bottom grid lines.\n    \/\/ We will now interpolate the vertical line between those 2 horizontal points\n    \/\/ to get our final value for noise.\n    float t = mix( bottomOfGrid, topOfGrid, f.y );\n    \n    return t;\n}\n\n\/\/ fbm stands for \"Fractional Brownian Motion\".\n\/\/ Essentially this function calls our valueNoise function multiple\n\/\/ times and adds up the results.  By adding various frequences of noise \n\/\/ at different amplitudes, we can generate a simple cloud like pattern.\nfloat fbm( vec2 uv )\n{\n    float sum = 0.00;\n    float amp = 0.7;\n    \n    for( int i = 0; i < 4; ++i )\n    {\n        sum += valueNoise( uv ) * amp;\n        uv += uv * 1.2;\n        amp *= 0.4;\n    }\n    \n    return sum;\n}\n\n\/\/ This is where everything starts!\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \/\/ fragCoord.xy is the coordinate of the current pixel being rendered.\n    \/\/ It is in screen space.  For example if you resolution is 800x600, gl_FragCoord.xy\n    \/\/ could be (300,400).  By dividing the fragcoord by the resolution, we get normalized\n    \/\/ coordinates between 0.0 and 1.0.  I would like to work in a -1.0 to 1.0 space\n    \/\/ so I multiply the result by 2.0 and subtract 1.0 from it.\n    \/\/ if (fragCoord.xy \/ iResolution.xy) equals 0.0, then 0.0 * 2.0 - 1.0 = -1.0\n    \/\/ if (fragCoord.xy \/ iResolution.xy) equals 1.0, then 1.0 * 2.0 - 1.0 =  1.0\n    vec2 uv = ( gl_FragCoord.xy \/ iResolution.xy ) * 2.0 - 1.0;\n\n    \/\/ I am assuming you have more pixels horizontally than vertically so I am multiplying\n    \/\/ the x coordinate by the aspect ratio.  This means that the magnitude of x coordinate will probably\n    \/\/ be larger than 1.0.  This allows our image to not look squashed. \n    uv.x *= iResolution.x \/ iResolution.y;\n\n    \/\/ Pass in a coordinate and get a cloud based scalar value back.\n    \/\/ We will use this value to generate a gray-scale based color to display our cloud.\n    float t = fbm( uv * 2.0 );\n    \n    vec3 finalColor = vec3( t, t, t );\n\n    \/\/ If you want to add color to your cloud, multiply each t red\/green\/blue component by some weight.\n    \/\/ You can uncomment the following line to see and example.\n    \/\/finalColor = vec3( t * 2.0, t * 4.0, t * 8.0 ) * 0.3; \n\n    \/\/ And voila!  We are done!  We should now have a cloud!  =D\n    \/\/ fragColor is the final color we want to render for whatever pixel we are currently rendering.\n    fragColor = vec4( finalColor, 1.0 );\n}","name":"","description":"","type":"image"}]}}