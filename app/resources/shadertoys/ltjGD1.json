{"Shader":{"ver":"0.1","info":{"id":"ltjGD1","date":"1428753508","viewed":2638,"name":"Rocket Science","username":"mu6k","description":"Rotate with mouse. Shader version of the revision rocket. I wanted to do something more similar to this in the live-coding competition at revision. However 25 minutes are just not enough.","likes":29,"published":3,"flags":0,"tags":["3d","flat","raymarch","model"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/*by musk License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.*\/\n\n\/\/#define EXHAUST_LIGHT\n\nfloat time = iGlobalTime+99.0; \/\/i hate the name in the uniforms\nfloat pi = 3.14159265359;\n\nvoid angularRepeat(const float a, inout vec2 v)\n{\n    float an = atan(v.y,v.x);\n    float len = length(v);\n    an = mod(an+a*.5,a)-a*.5;\n    v = vec2(cos(an),sin(an))*len;\n}\n\n\nvoid angularRepeat(const float a, const float offset, inout vec2 v)\n{\n    float an = atan(v.y,v.x);\n    float len = length(v);\n    an = mod(an+a*.5,a)-a*.5;\n    an+=offset;\n    v = vec2(cos(an),sin(an))*len;\n}\n\nfloat mBox(vec3 p, vec3 b)\n{\n\treturn max(max(abs(p.x)-b.x,abs(p.y)-b.y),abs(p.z)-b.z);\n}\n\nfloat mSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\n\nvec2 frot(const float a, in vec2 v)\n{\n    float cs = cos(a), ss = sin(a);\n    vec2 u = v;\n    v.x = u.x*cs + u.y*ss;\n    v.y = u.x*-ss+ u.y*cs;\n    return v;\n}\n\nvoid rotate(const float a, inout vec2 v)\n{\n    float cs = cos(a), ss = sin(a);\n    vec2 u = v;\n    v.x = u.x*cs + u.y*ss;\n    v.y = u.x*-ss+ u.y*cs;\n}\n\nfloat rocketRotation = sin(time)*.1;\n\nfloat dfRocketBody(vec3 p)\n{\n    rotate(rocketRotation,p.yz);\n    \n    vec3 p2 = p;\n    vec3 pWindow = p;\n    \n    angularRepeat(pi*.25,p2.zy);\n    float d = p2.z;\n    d = max(d, frot(pi*-.125, p2.xz+vec2(-.7,0)).y);\n    d = max(d, frot(pi*-.25*.75, p2.xz+vec2(-0.95,0)).y);\n    d = max(d, frot(pi*-.125*.5, p2.xz+vec2(-0.4,0)).y);\n    d = max(d, frot(pi*.125*.25, p2.xz+vec2(+0.2,0)).y);\n    d = max(d, frot(pi*.125*.8, p2.xz+vec2(.55,0)).y);\n    d = max(d,-.8-p.x);\n    d -= .5;\n    \n    vec3 pThruster = p2;\n    pThruster -= vec3(-1.46,.0,.0);\n    rotate(pi*-.2,pThruster.xz);\n    d = min(d,mBox(pThruster,vec3(.1,.4,.27)));\n    d = min(d,mBox(pThruster-vec3(-.09,.0,.0),vec3(.1,.3,.07)));\n    \n    \n    pWindow -= vec3(.1,.0,.0);\n    angularRepeat(pi*.25,pWindow.xy);\n    pWindow -= vec3(.17,.0,.0);\n    d = min(d,mBox(pWindow,vec3(.03,.2,.55)));\n    \n  \treturn d;\n}\n\nfloat dfRocketFins(vec3 p)\n{\n    rotate(rocketRotation,p.yz);\n    \n    vec3 pFins = p;\n    angularRepeat(pi*.5,pFins.zy);\n    pFins -= vec3(-1.0+cos(p.x+.2)*.5,.0,.0);\n    rotate(pi*.25,pFins.xz);\n    float scale = 1.0-pFins.z*.5;\n    float d =mBox(pFins,vec3(.17,.03,3.0)*scale)*.5;\n    return d;\n}\n\nfloat dfRocket(vec3 p)\n{\n    float proxy = mBox(p,vec3(2.5,.8,.8));\n    if (proxy>1.0)\n    \treturn proxy;\n    return min(dfRocketBody(p),dfRocketFins(p));\n}\n\nfloat dfTrailPart(vec3 p, float t)\n{\n    vec3 pm = p;\n    pm.x = mod(p.x+1.0+t,2.0)-1.0;\n    float index = p.x-pm.x;\n    \n    float rpos =(-1.7-index);\n    \n    \n    float i2 = rpos;\n    \n    float rs = .5;\n    \n    float rtime1 = (t*.32 + i2*0.2)*rs;\n\tfloat rtime2 = (t*.47 + i2*0.3)*rs;\n\tfloat rtime3 = (t*.53 + i2*0.1)*rs;\n\tmat3 rot = mat3(cos(rtime1),0,sin(rtime1),0,1,0,-sin(rtime1),0,cos(rtime1))*\n    mat3(cos(rtime2),sin(rtime2),.0,-sin(rtime2),cos(rtime2),.0,0,0,1)*\n    mat3(1,0,0,0,cos(rtime3),sin(rtime3),0,-sin(rtime3),cos(rtime3));\n    \n    \/\/p -= vec3(-2.0,.0,.0);\n    float size = .6-.5\/(1.0+rpos);\n    size = min(size,.6-.5\/(17.0-rpos));\n    size = max(size,.0);\n    return mBox(pm*rot,vec3(size));\n}\n\nfloat dfTrail(vec3 p)\n{\n    float clip = max(p.x+1.7, -1.7-16.0-p.x);\n    float proxy = max(abs(p.y)-1.0, abs(p.z)-1.0);\n    float proxy2 = max(clip,proxy);\n    if (proxy2>0.5) return proxy2;\n    \n    float d = 999.0;\n    for (int i=0; i<3; i++)\n    {\n        d=min(d,dfTrailPart(p,time*6.0+float(i)*21.33));\n    }\n        \n    return max(d,clip);\n}\n\nfloat dfTerraHills(vec3 p)\n{\n    p.y+=sin(p.x*.05)*2.0+1.0;\n    vec3 pm = p;\n    pm.xz = mod(pm.xz+vec2(8.0),16.0)-vec2(8.0);\n    pm = abs(pm);\n    return p.y*.8+3.0+pm.x*.1+pm.z*.1;\n}\n\nfloat dfTerra(vec3 p)\n{\n    p.x+=time*4.0;\n    vec3 p2 = p;\n    \n    float height = (sin(p.x*.1)+sin(p.z*.1));\n    rotate(.6,p2.xz);\n    return max(dfTerraHills(p2),dfTerraHills(p))+height;\n}\n\nfloat df(vec3 p)\n{\n    return min(min(dfRocket(p),dfTrail(p)),dfTerra(p));\n}\n\nvec3 nf(vec3 p)\n{\n    vec2 e = vec2(0,0.005);\n    return normalize(vec3(df(p+e.yxx),df(p+e.xyx),df(p+e.xxy)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-iResolution.xy*.5) \/ iResolution.yy;\n    vec2 mouse = (iMouse.xy-iResolution.xy*.5) \/ iResolution.yy;\n    \n    vec3 pos = vec3(.1,.1,-5);\n    \/\/vec3 dir = normalize(vec3(uv,1.0));\n    vec3 dir = normalize(vec3(uv,1.0));\n    \n    float rx = -mouse.x*8.0 + time*.04 -2.7;\n    float ry = mouse.y*8.0 + time*.024+1.2;\n     \n    rotate(ry,pos.yz);\n    rotate(ry,dir.yz);\n    rotate(-rx,pos.xz);\n    rotate(-rx,dir.xz);  \n    rotate(.1,pos.xy);\n    rotate(.1,dir.xy);  \n    pos*=(pos.y*.25+1.5)*.6;\n    \n    float dist,tdist = .0;\n    \n    for (int i=0; i<100; i++)\n    {\n     \tdist = df(pos);\n       \tpos += dist*dir;\n        tdist+=dist;\n        if (dist<0.000001||dist>20.0)break;\n    }\n    \n    vec3 light = normalize(vec3(1,2,3));\n    \n    \n    vec3 skyColor = vec3(.1,.3,.7)*.7;\n    \n    vec3 ambientColor = skyColor*.07;\n    vec3 materialColor = vec3(.5,.5,.5);\n    vec3 emissiveColor = vec3(.0,.0,.0);\n    \n    float dTerra = dfTerra(pos);\n    float dTrail = dfTrail(pos);\n    float dRocketBody = dfRocketBody(pos);\n    float dRocketFins = dfRocketFins(pos);\n    float dRocket = min(dRocketBody, dRocketFins);\n    float dRocketTrail = min(dRocket, dTrail);\n    \n    \n    if (dTerra<dRocketTrail)\n    {\n        materialColor = vec3(.3,.4,.1);\n    }\n    else if (dTrail<dRocket)\n    {\n    \tmaterialColor = vec3(.1,.1,.1);\n        float tpos = (-pos.x-1.7)\/16.0;\n        emissiveColor = vec3(1.9,.9,.2)*pow((1.0-tpos),8.0);\n    }\n    else \n    {\n        \/\/rocket\n        ambientColor = mix(skyColor,vec3(.3,.1,.3)*.4,.5);\n        if (dfRocketBody(pos)<dfRocketFins(pos))\n        {\n            if (pos.x<-.85 || pos.x>1.0)\n                if (pos.x<-1.31)\n                    materialColor = vec3(.25,.25,.25);\n                else\n                    materialColor = vec3(.9,.1,.1);\n            else\n            {\n                materialColor = vec3(.8,.8,.8);\n            }\n        }\n        else\n            materialColor = vec3(.9,.1,.1);\n    }\n    \n    float value = \n        df(pos+light)+\n        df(pos+light*.5)*2.0+\n        df(pos+light*.25)*4.0+\n        df(pos+light*.125)*8.0+\n        df(pos+light*.06125)*16.0;\n    \n    value=value*.2+.04;\n    value=min(value,1.0);\n    value=max(.0,value);\n    \n    vec3 normal = nf(pos);\n   \n    vec3 ref = reflect(dir,nf(pos));\n    \/\/float ro = min(max(min(min(df(pos+ref),df(pos+ref*0.25)*4.0), df(pos+ref*.5)*2.0)*.5,.0),1.0);\n   \tfloat ro=1.0;\n    \n    float ao = df(pos+normal*.125)*8.0 +\n        df(pos+normal*.5)*2.0 +\n    \tdf(pos+normal*.25)*4.0 +\n    \tdf(pos+normal*.06125)*16.0;\n    \n    ao=ao*.125+.5;\n    \n    float fres = pow((dot(dir,normal)*.5+.5),2.0);\n    vec3 color = vec3(.0,.0,.0); \n    #ifdef EXHAUST_LIGHT\n    vec3 exhaustLightDir = vec3(-1.9+sin(time*14.0)*.02,+cos(time*20.0)*.02,+sin(time*20.0)*.02)-pos;\n    float exhaustLightDistance = length(exhaustLightDir);\n    exhaustLightDir\/=exhaustLightDistance;\n    \/\/compute exhaust direct light\n    float exhaustLightDiffuse = max(.0,dot(normal,exhaustLightDir)*.8+.2)\/(0.5+exhaustLightDistance*exhaustLightDistance);\n    exhaustLightDiffuse*=max(.0,min(df(pos+exhaustLightDir*.1)*10.0*.8+.2,df(pos+exhaustLightDir*.05)*20.0*.8+.2)*.8+.2); \/\/occlude exhaust light\n    color += exhaustLightDiffuse*vec3(1.9,.9,.2)*.7;\n    #endif\n    \n   \n    color +=(value*vec3(dot(nf(pos),light)*.5+.5)*.5+ambientColor*ao)*materialColor +fres*.25;\n    color += emissiveColor;\n   \n    vec3 cSky = skyColor + pow(dot(dir,light)*.5+.5,8.0);\n    if (dist>1.0) color = cSky;\n    else color = mix(cSky,color,1.0\/(1.0+tdist*.005));\n    \n    color*=1.3; \/\/boost\n    color -= pow(length(uv),2.0)*.07;\n    color = mix(color,vec3(length(color)),length(color)*.5);\n    \n\tfragColor = vec4(pow(color,vec3(1.0\/2.2)),1.0);\n    \/\/fragColor = vec4(ro);\n    \/\/fragColor = vec4(ao);\n    \/\/fragColor = vec4(value);\n}","name":"","description":"","type":"image"}]}}