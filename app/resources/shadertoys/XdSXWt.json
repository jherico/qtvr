{"Shader":{"ver":"0.1","info":{"id":"XdSXWt","date":"1416917739","viewed":1705,"name":"Logistic Map - Complex","username":"iq","description":"Logistic map in complex numbers (real numbers superimposed in yellow). It becomes a quadratic, so it's isomorphic to the Mandelbrot set. The smooth iteration count, given by the Green Function, is sn = n + 1 - log2( log2|c| + log2|z| )","likes":7,"published":3,"flags":0,"tags":["2d","fractal","logistic","bifurcation","feigenbaum"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\/\/ The Logistic Map in complex numbers. Since it's a quadratic funcion, it's isomorphic\n\/\/ to the Mandelbrot Set.\n\/\/\n\/\/ The bifurcation diagram for the Logistic Map in real numbers is superimposed to better\n\/\/ see the overlap in the dynamics across the x axis.\n\/\/\n\/\/ Since f(z) = h\u00b7z\u00b7(1-z), as |Zn| approaches infinity we have that Z = h^(2^n-1) \u00b7 Zo^(2^n)\n\/\/ Hence the normalization map phi = (Zn\u00b7h)^(1\/2^n). \n\/\/ The Green function is therefore G = log|phi| = (log|Zn|+log|h|)\/(2^n) \n\n\n\/\/ supersampling factor (1 for slow machines, 5 for monsters!)\n#define AA 2\n\n\/\/ complex number operations\nvec2 cadd( float s, vec2 a ) { return vec2( a.x+s, a.y ); }\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int jj=0; jj<AA; jj++ )\n    for( int ii=0; ii<AA; ii++ )\n    #else\n    int ii = 1, jj = 1;\n    #endif\n    {\n        vec2 q = fragCoord.xy+vec2(float(ii),float(jj))\/float(AA);\n        vec2 p = (-iResolution.xy + 2.0*q)\/iResolution.y;\n\n        \/\/ zoom\n        float zoo = 0.62 + 0.38*cos(.02*iGlobalTime);\n        float coa = cos( 0.1*(1.0-zoo)*iGlobalTime );\n        float sia = sin( 0.1*(1.0-zoo)*iGlobalTime );\n        zoo = pow( zoo,8.0);\n        vec2 xy = vec2( p.x*coa-p.y*sia, p.x*sia+p.y*coa);\n        vec2 cc = vec2(1.0,0.0)+smoothstep(1.0,0.5,zoo)*vec2(0.24814,0.7369) + xy*zoo*2.0;\n\n        vec3 col = vec3( 0.0 );\n        \n        \/\/---------------------------------\n        \/\/ logistic map in complex numbers\n        \/\/---------------------------------\n        \n        vec2 sc = vec2( abs(cc.x-1.0)-1.0,cc.y);\n        if( dot(sc,sc)<1.0 )\n        {\n            \/\/ trick: in order to accelerate the rendering, we can detect if we\n            \/\/ are inside the convergent part of the set (any of the two bulbs of period 1).\n            \/\/col = vec3(0.2);\n        }\n        else\n        {\n            float co = 0.0;\n            vec2 z  = vec2(0.5,0.0);\n            for( int i=0; i<256; i++ )\n            {\n                if( dot(z,z)>1024.0 ) break;\n                z = cmul(cc, cmul( z, cadd(1.0,-z) ) );\n                co += 1.0;\n            }\n\n            \/\/ smooth interation count = n + 1 - log2( log2|h| + log2|z| );\n            float sco = co + 1.0 - log2( 0.5*(log2(dot(cc,cc)) + log2(dot(z,z))) );\n\n            col = 0.5 + 0.5*cos( 3.0 + sco*0.1 + vec3(0.0,0.5,1.0));\n            if( co>255.5 ) col = vec3(0.0);\n        }\n\n        \/\/ Hubbard-Douady potential, |G|\n        \/\/float d = (log(length(z)) + log(length(cc)))\/pow(2.0,co);\n\n\n        \/\/---------------------------------\n        \/\/ logic map in real numbers    \n        \/\/---------------------------------\n        if( abs(cc.x-1.0)<3.0 )\n        {\n            float al = smoothstep( 17.0, 12.0, iGlobalTime );\n            col = clamp(col,0.0,1.0);\n            float x = 0.5;\n            for( int i=0; i<200; i++ )\n            x = cc.x*x*(1.0-x);\n            for( int i=0; i<200; i++ )\n            {\n                x = cc.x*x*(1.0-x);\n                col = mix( col, vec3(1.0,1.0,0.0), \n                           (0.15+0.85*pow(clamp(abs(sc.x+1.0)*0.4,0.0,1.0),4.0))*al*\n                           0.06*exp(-15000.0*(cc.y-x)*(cc.y-x)) );\n            }\n        }\n\n        tot += col;\n    }\n    \n    tot = tot\/float(AA*AA);\n    \n\tfragColor = vec4( tot, 1.0 );\n}","name":"","description":"","type":"image"}]}}