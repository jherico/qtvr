{"Shader":{"ver":"0.1","info":{"id":"llf3Wn","date":"1421323739","viewed":840,"name":"Ray Marching Experiment 0","username":"aiekick","description":"x mouse axis => control roughness (rugosity)<br\/>y mouse axis => control cells density<br\/>","likes":5,"published":3,"flags":0,"tags":["raymarchingexperiment0"],"hasliked":0},"renderpass":[{"inputs":[{"id":23,"src":"\/presets\/cube01_0.png","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Stephane Cuillerdier - Aiekick\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n#define ITERATIONS_MAX 100\n#define RUGOSITY_DENSITY_MAX 10.\n#define RUGOSITY_DENSITY_DEFAULT 7.\n#define ROT_SPEED 0.6\n#define TIME_RATIO iGlobalTime\nfloat voroRatio = 1.5;\n\n\/\/ VORONOI based on IQ shader https:\/\/www.shadertoy.com\/view\/ldl3W8\n\/\/vec2 getHash2BasedTex(vec2 p) {return texture2D( iChannel0, (p+0.5)\/256.0, -100.0 ).xy;}\/\/texture based white noise\nvec2 getHash2BasedProc(vec2 p)\n{\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453); \/\/procedural white noise\n}\n\nvec3 getVoronoi(vec2 x)\n{\n    vec2 n=floor(x),f=fract(x),mr;\n    float md=5.;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ ){\n        vec2 g=vec2(float(i),float(j));\n\t\tvec2 o=0.5+0.5*sin(TIME_RATIO+6.2831*getHash2BasedProc(n+g));\/\/animated\n        vec2 r=g+o-f;\n        float d=dot(r,r);\n        if( d<md ) {md=d;mr=r;} }\n    return vec3(md,mr);\n}\n\n\/\/ sphere mapping of v2 voronoi\nvec3 voronoiSphereMapping(vec3 n)\n{\n\tvec2 uv=vec2(atan(n.x,n.z),acos(n.y));\n    if ( iMouse.z > 0. ) {voroRatio=iMouse.y\/iResolution.y * 10.;}\n    return getVoronoi(voroRatio*uv);\n}\n\nfloat RotY=0.0,RotX=0.0;\nvec3 rotateX(vec3 pos, float alpha)\n{\n    mat4 trans= mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(alpha), -sin(alpha), 0.0, 0.0, sin(alpha), cos(alpha), 0.0, 0.0, 0.0, 0.0, 1.0);\n    return vec3(trans * vec4(pos, 1.0));\n}\nvec3 rotateY(vec3 pos, float alpha) \n{\n    mat4 trans2= mat4(cos(alpha), 0.0, sin(alpha), 0.0, 0.0, 1.0, 0.0, 0.0,-sin(alpha), 0.0, cos(alpha), 0.0, 0.0, 0.0, 0.0, 1.0);\n    return vec3(trans2 * vec4(pos, 1.0));\n}\n\n\/\/\/\/\/\/\/\/MAP\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nfloat density=RUGOSITY_DENSITY_DEFAULT;\n\nfloat map(vec3 p){\n    vec3 rotPX = rotateX(p, RotX*ROT_SPEED);\n    vec3 rotPXY = rotateY(rotPX, RotY*ROT_SPEED);\n    if ( iMouse.z > 0. ) {density=iMouse.x\/iResolution.x * RUGOSITY_DENSITY_MAX;}\n\tfloat rugosity=cos(density*rotPXY.x)*sin(density*rotPXY.y)*sin(density*rotPXY.z)*cos(256.1)*sin(0.8);\n\tfloat disp=length(vec4(voronoiSphereMapping(normalize(p)),1.))*0.4-0.8;\n    return length(p)-1.+disp+rugosity;}\n\n\/\/\/\/\/\/\/\/MAIN\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float cam_a = 0.; \/\/ angle z\n    float cam_e = 0.5; \/\/ elevation\n    float cam_d = 2.; \/\/ distance to origin axis\n    vec3 camUp=vec3(0,1,0);\/\/Change camere up vector here\n  \tvec3 camView=vec3(0,0,0); \/\/Change camere view here\n  \tfloat li = 0.6; \/\/ light intensity\n    float prec = 0.001; \/\/ ray marching precision\n    float maxd = 10.; \/\/ ray marching distance max\n    float refl_i = 0.8; \/\/ reflexion light intensity\n    float refr_a = 0.; \/\/ refraction angle\n    float refr_i = 0.2; \/\/ refraction light intensity\n    float bii = 0.35; \/\/ bright init intensity\n    \n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \n\tvec2 uv = fragCoord.xy \/ iResolution.xy *2.-1.;\n    uv.x*=iResolution.x\/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(-sin(cam_a)*cam_d, cam_e, cos(cam_a)*cam_d); \/\/\n  \tvec3 rov = normalize(camView-ro);\n    vec3 u = normalize(cross(camUp,rov));\n  \tvec3 v = cross(rov,u);\n  \tvec3 rd = normalize(rov + uv.x*u + uv.y*v);\n    \n    float b = bii;\n    float s = prec;\n    float d = 0.;\n    for(int i=0;i<150;i++)\n    {      \n        if (s<prec||s>maxd) break;\n        s = map(ro+rd*d);\n        d += s;\n    }\n    \n    if (d<maxd)\n    {\n        vec2 e = vec2(-1., 1.)*0.005; \n    \tvec3 p = ro+rd*d;\n        vec3 n = normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );\n        vec3 np = normalize(p);\n        \n        vec3 voroCol = voronoiSphereMapping(np);\n        vec3 marchCol = vec3(max(0.,2.3-d));\n        col = mix(marchCol,voroCol,0.7);   \n        \n        vec3 coln = normalize(col); \/\/ cell teinte\n        \n        b+=dot(n, np)*li;\n        \n        vec3 reflRay = reflect(rd, n);\n        vec3 refrRay = refract(rd, n, refr_a);\n        vec3 cubeRefl = textureCube(iChannel0, reflRay).rgb * refl_i * coln;\n        vec3 cubeRefr = textureCube(iChannel0, refrRay).rgb * refr_i * coln;\n        \n        col = cubeRefl+cubeRefr+pow(b,15.);  \n    }\n    else\n    {\n        b+=0.1;\n        col = textureCube(iChannel0, rd).rgb;\n    }\n    \n\tfragColor.rgb = col;\n}","name":"","description":"","type":"image"}]}}