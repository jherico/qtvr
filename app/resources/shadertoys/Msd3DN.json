{"Shader":{"ver":"0.1","info":{"id":"Msd3DN","date":"1450109165","viewed":2017,"name":"Christmas delivery","username":"iapafoto","description":"Christmas delivery<br\/>inspired by Rocket Science by mu6k (https:\/\/www.shadertoy.com\/view\/ltjGD1)","likes":45,"published":3,"flags":0,"tags":["cloud","modeling","speed"],"hasliked":0},"renderpass":[{"inputs":[{"id":9,"src":"\/presets\/tex08.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":17,"src":"\/presets\/tex12.png","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by sebastien durand - 2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/-----------------------------------------------------\n\n\/\/ Lightening, essentially based on one of incredible TekF shaders:\n\/\/ https:\/\/www.shadertoy.com\/view\/lslXRj\n\n\/\/ Pupils effect came from lexicobol shader: [famous iq tutorial]\n\/\/ https:\/\/www.shadertoy.com\/view\/XsjXz1\n\n\/\/ Smooth max from cabbibo shader:\n\/\/ https:\/\/www.shadertoy.com\/view\/Ml2XDw\n\n\n\n\/\/-----------------------------------------------------\n\n\/\/ Display distance field in a plane perpendicular to camera crossing pt(0,0,0)\n\n\n\/\/ Change this to improve quality (3 is good)\n\t#define ANTIALIASING 1\n\n#define CLOUD_FAST\n\nfloat g_time;\n\n\/\/ consts\nconst float tau = 6.2831853;\nconst float phi = 1.61803398875;\n\n\/\/ Isosurface Renderer\nconst int g_traceLimit=64;\nconst float g_traceSize=.005;\n\n\/\/ globals\nconst vec3 g_nozePos = vec3(0,-.28+.04,.47+.08);\nconst vec3 g_eyePos = vec3(.14,-.14,.29);\nconst float g_eyeSize = .09;\n\nvec3 g_envBrightness = vec3(.5,.6,.9); \/\/ Global ambiant color\nvec3 g_lightPos, g_deltaPast;\nmat2 ma, mb, mc, g_eyeRot, g_headRotH, rotTime;\n    \nbool g_bHead = true, g_bBody = true;\n\n\n\n\/\/ -----------------------------------------------------------------\n\n\nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D( iChannel0, (uv+ 0.5)\/256.0, -100.0 ).yx;\n\treturn -1.0+2.0*mix( rg.x, rg.y, f.z );\n}\n\nmat2 matRot(in float a) {\n    float ca = cos(a), sa = sin(a);\n    return mat2(ca,sa,-sa,ca);\n}\n\n\n\/\/ Smooth HSV to RGB conversion \n\/\/ [iq: https:\/\/www.shadertoy.com\/view\/MsS3Wc]\nvec3 hsv2rgb_smooth(float x, float y, float z) {\n    vec3 rgb = clamp( abs(mod(x*6.+vec3(0.,4.,2.),6.)-3.)-1., 0., 1.);\n\trgb = rgb*rgb*(3.-2.*rgb); \/\/ cubic smoothing\t\n\treturn z * mix( vec3(1), rgb, y);\n}\n\n\/\/ Distance from ray to point\nfloat distance(vec3 ro, vec3 rd, vec3 p) {\n\treturn length(cross(p-ro,rd));\n}\n\n\/\/ Intersection ray \/ sphere\nbool intersectSphere(in vec3 ro, in vec3 rd, in vec3 c, in float r, out float t0, out float t1) {\n    ro -= c;\n\tfloat b = dot(rd,ro), d = b*b - dot(ro,ro) + r*r;\n    if (d<0.) return false;\n\tfloat sd = sqrt(d);\n\tt0 = max(0., -b - sd);\n\tt1 = -b + sd;\n\treturn (t1 > 0.);\n}\n\n\n\n\/\/#ifdef NOISE_SKIN\n\/\/ By Shane -----\n\n\/\/ Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n    n = max((abs(n) - 0.2)*7., 0.001); \/\/ n = max(abs(n), 0.001), etc.\n    n \/= (n.x + n.y + n.z );  \n\treturn (texture2D(tex, p.yz)*n.x + texture2D(tex, p.zx)*n.y + texture2D(tex, p.xy)*n.z).xyz;\n}\n\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\n    const float eps = 0.001;\n    float ref = (tex3D(tex,  p , nor)).x;                 \n    vec3 grad = vec3( (tex3D(tex, vec3(p.x-eps, p.y, p.z), nor).x)-ref,\n                      (tex3D(tex, vec3(p.x, p.y-eps, p.z), nor).x)-ref,\n                      (tex3D(tex, vec3(p.x, p.y, p.z-eps), nor).x)-ref )\/eps;\n             \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n}\n\n\/\/#endif\n\n\n\/\/ -- Modeling Primitives ---------------------------------------------------\n\nfloat udRoundBox(in vec3 p,in vec3 b, in float r) {\n  return length(max(abs(p)-b,0.0))-r ;\n}\nfloat mBox(vec3 p, vec3 b){\n\treturn max(max(abs(p.x)-b.x,abs(p.y)-b.y),abs(p.z)-b.z);\n}\n\n\nfloat sdCapsule(in vec3 p, in vec3 a, in vec3 b, in float r0, in float r1 ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)\/dot(ba,ba), 0., 1.);\n    return length( pa - ba*h ) - mix(r0,r1,h);\n}\n\n\/\/ capsule with bump in the middle -> use for neck\nvec2 sdCapsule2(in vec3 p,in vec3 a,in vec3 b, in float r0,in float r1,in float bump) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)\/dot(ba,ba), 0., 1. );\n    float dd = bump*sin(3.14*h);  \/\/ Little adaptation\n    return vec2(length(pa - ba*h) - mix(r0,r1,h)*(1.+dd), 1.); \n}\n\nfloat smin(in float a, in float b, in float k ) {\n    float h = clamp( .5+.5*(b-a)\/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.-h);\n}\n\n\/\/ Smooth max from cabbibo shader:\n\/\/ https:\/\/www.shadertoy.com\/view\/Ml2XDw\nfloat smax(in float a, in float b, in float k) {\n    return log(exp(a\/k)+exp(b\/k))*k;\n}\n\n\nfloat smax2( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r) {\n    return (length(p\/r ) - 1.) * min(min(r.x,r.y),r.z);\n}\n\n\n\n\/\/ -- Modeling Head ---------------------------------------------------------\n\/*\nfloat dEar(in vec3 p, in float scale_ear) {\n    vec3 p_ear = scale_ear*p;\n    p_ear.xy *= ma;\n    p_ear.xz *= ma; \n    float d = max(-sdEllipsoid(p_ear-vec3(.005,.025,.02), vec3(.07,.11,.07)), \n                       sdEllipsoid(p_ear, vec3(.08,.12,.09)));\n    p_ear.yz *= mb; \n    d = max(p_ear.z, d); \n    d = smin(d, sdEllipsoid(p_ear+vec3(.035,.045,.01), vec3(.04,.04,.018)), .01);\n    return d\/scale_ear;\n}\n*\/\nfloat dSkinPart(in vec3 pgeneral, in vec3 p) {\n\n    float d = 1000.;\n   \n\/\/ Skull modeling -------------------------\n    d = sdEllipsoid(p-vec3(0,.05,.0), vec3(.39,.48,.46));\t\n    if (d > .2) return d;\n    \n \/\/   d = smin(d, sdEllipsoid(p-vec3(0.,.1,-.15), vec3(.42,.4,.4)),.1);     \n    d = smin(d, udRoundBox(p-vec3(0,-.28,.2), vec3(.07,.05,.05),.05),.4); \/\/ Basic jaw \n\/\/ Symetrie -------------------------------\n    p.x = abs(p.x);\n\/\/ Eye hole \n    d = smax(d, -sdEllipsoid(p-vec3(.12,-.16,.48), vec3(.09,.06,.09)), .07);\n\n\/\/ Noze ------------------------------------\n    d = smin(d, max(-(length(p-vec3(.032,-.325,.45))-.028),   \/\/ Noze hole\n                    smin(length(p-vec3(.043,-.29,.434))-.01,  \/\/ Nostrils\n                    sdCapsule(p, vec3(0,-.13,.39), vec3(0,-.28,.47), .01,.04), .05)) \/\/ Bridge of the nose\n            ,.065); \n   \n\/\/ Mouth -----------------------------------    \n    d = smin(d, length(p- vec3(.22,-.34,.08)), .17); \/\/ Jaw\n    d = smin(d, sdCapsule(p, vec3(.16,-.35,.2), vec3(-.16,-.35,.2), .06,.06), .15); \/\/ Cheeks\n   \n    d = smin(d, max(-length(p.xz-vec2(0,.427))+.015,  \t\/\/ Line under the noze\n        \t\tmax(-p.y-.41,   \t\t\t\t\t\t\/\/ Upper lip\n                    sdEllipsoid(p- vec3(0,-.34,.37), vec3(.08,.15,.05)))), \/\/ Mouth bump\n             .032);\n\n\/\/ Eyelid ---------------------------------\n\tvec3 p_eye1 = p - g_eyePos;\n    p_eye1.xz *= mb;\n    \n    vec3 p_eye2 = p_eye1;\n    float d_eye = length(p_eye1) - g_eyeSize;\n          \n\tp_eye1.yz *= g_eyeRot;\n\tp_eye2.zy *= mc;\n    \n    float d1 = min(max(-p_eye1.y,d_eye - .01),\n                   max(p_eye2.y,d_eye - .005));\n    d = smin(d,d1,.01);\n\n\treturn d; \n}\n\nfloat dEye(vec3 p_eye) {\n    p_eye.xz *= ma;     \n    return length(p_eye) - g_eyeSize;\n}\n\nvec2 min2(in vec2 dc1, in vec2 dc2) {\n\treturn dc1.x <= dc2.x ? dc1 : dc2; \n}\n\nfloat sdTorus(in vec3 p, in vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat dfTrailPart0(vec3 p, float t, float lineId)\n{\n    vec3 pm = p;\n    t*=20.;\n    t += hash(lineId);\n    pm.x = mod(p.x+t+1.6,3.2)-1.6;\n    \n    float index = (p.x+t)-pm.x;\n    float id = lineId*10. + floor(((index+1.6)\/3.2)+1.6);\n    vec3 size = (.2+.5*hash3(vec2(id, id+1.)));\/\/*smoothstep(3.,7.,-p.x);\n    \n    pm.z += .25*cos(id);\n    \/\/pm.xy *= rotTime;\n    pm.xz *= matRot(3.14*hash(id));\n    pm.yz *= rotTime;\n     \n    return  max(p.x+4., udRoundBox(pm,size,.025));\n}\n\n\nfloat spaceship0(vec3 p, float lineId) {\n    p += vec3(0.,1.7,.5);\n\tvec2 p2 = vec2(sqrt(dot(p,p)-p.z*p.z), p.z);\n\t\n    float d = length(p2-vec2(-6.,0))-7.5;\n    \n    d = min(d, max(p2.y, p2.x-.3+.2*(p2.y+3.)));\n    d = max(-p2.y-4., d);\n            \n    vec3 p3 = p;\n    p3.xy = abs(p3.xy);\n    p3-=vec3(1.,1.,-3.);\n    p3.xy *= mc;\n    \n    float d2 = mBox(p3, vec3(.05,.5,.8));\n    d2 = max(d2, length(p-vec3(0.,0.,-3.5))-1.8);\n    d = min(d, length(p - vec3(0,.95,1.1))-.83);\n    d = smax2(d, -length(p - vec3(0,.8,.8))+1., .15); \n    d = min(d,d2);\n    return min(d, dfTrailPart0(p.zxy, 5.*g_time, lineId)); \n}\n\nfloat dToga0(vec3 p) {\n\n    float move = -1.+2.*g_deltaPast.x;\n    \n    p.z -= .04;\n    p.y += .05;\n    float bonnet = length(p- vec3(0,.25,-.03)) - .42;\n    \n    bonnet = smin(bonnet, length(p-vec3(.15*move,.5,-.35)) - .18, .25);\n\n    vec3 sp = p-vec3(0.,-1.2,.15);\n    sp.yz *= ma;\n    bonnet = min(bonnet, udRoundBox(sp, vec3(.4,.5,0.), .4));\n        \n    sp = sin(111.*p);\n    float echarpe = length(p- vec3(.3*move,.45,-.57)) - .15 - .007*sp.x*sp.y*sp.z;\n    \n    \n    p -= vec3(0.,-.05,-.05);\n  \n    p.y = -abs(p.y);\n \n    p.zy *= mb;  \n    float dy = -.8+1.2*cos(p.x);\n    \n    echarpe =  min(echarpe, sdTorus(p+vec3(0,+dy,0), vec2(.42,.07)));\n    echarpe = smin(echarpe, sdTorus(p+vec3(0,-.2+dy,0), vec2(.46,.09)),.15);\n\tfloat result =  min(echarpe,bonnet);\n    result -= .001*sp.x*sp.y*sp.z;\n    return result *.8;\n}\n\nvec2 dfTrailPart(vec3 p, float t, float lineId)\n{\n    vec3 pm = p;\n    t*=20.;\n    t += hash(lineId);\n    pm.x = mod(p.x+t+1.6,3.2)-1.6;\n    \n    float index = (p.x+t)-pm.x;\n    float id = lineId*10. + floor(((index+1.6)\/3.2)+1.6);\n    vec3 size = (.2+.5*hash3(vec2(id, id+1.)));\/\/*smoothstep(4.,7.,-p.x);\n    \n    pm.z += .25*cos(id);  \n    \n    \/\/pm.xy *= rotTime;\n    pm.xz *= matRot(3.14*hash(id));\n    pm.yz *= rotTime;\n    \n    vec3 k3 = smoothstep(.08*size.x, .12*size.x, abs(pm));\n    float k = k3.x*k3.y*k3.z*.95;\n     \n    float d = max(p.x+4., udRoundBox(pm,size,.025));\n    return vec2(d, 40. + id + k);    \n}\n\n\nvec2 spaceship(vec3 p, float lineId) {\n    p += vec3(0.,1.7,.5);\n\t\n    vec2 p2 = vec2(sqrt(dot(p,p)-p.z*p.z), p.z);\n\tfloat d = length(p2-vec2(-6.,0))-7.5;\n    \n    d = min(d, max(p2.y, p2.x-.3+.2*(p2.y+3.)));\n    d = max(-p2.y-4., d);\n            \n    vec3 p3 = p;\n    p3.xy = abs(p3.xy);\n    p3-=vec3(1.,1.,-3.);\n    p3.xy *= mc;\n   \n    float d2 = mBox(p3, vec3(.05,.5,.8));\n    d2 = max(d2, length(p-vec3(0.,0.,-3.5))-1.8);\n\n    d = min(d, length(p - vec3(0,.95,1.1))-.83);\n\/\/\td = max(d, -length(p - vec3(0,.8,.8))+1.1);\n    d = smax2(d, -length(p - vec3(0,.8,.8))+1., .15); \n    \n    d = min(d,d2);\n    p = p.zxy;\n    \n    return min2(vec2(d,20.+ mod(lineId,3.) + .95*smoothstep(.8,.9,cos(5.*p.z*p.y))), dfTrailPart(p, 5.*g_time, lineId)); \n}\n\nvec2 dToga(vec3 p) {\n\n    float move = -1.+2.*g_deltaPast.x;\n    \n    p.z -= .04;\n    p.y += .05;\n    float bonnet = length(p- vec3(0,.25,-.03)) - .42;\n    bonnet = smin(bonnet, length(p-vec3(.15*move,.5,-.35)) - .18, .25);\n\n    vec3 sp = p-vec3(0.,-1.2,.15);\n    sp.yz *= ma;\n    bonnet = min(bonnet, udRoundBox(sp, vec3(.4,.5,0.), .4));\n        \n    sp = sin(111.*p);\n    float echarpe = length(p- vec3(.3*move,.45,-.57)) - .15 - .007*sp.x*sp.y*sp.z;\n    \n    \n    p -= vec3(0.,-.05,-.05);\n  \n    p.y = -abs(p.y);\n \n    p.zy *= mb;  \n    float dy = -.8+1.2*cos(p.x);\n    \n    echarpe =  min(echarpe, sdTorus(p+vec3(0,+dy,0), vec2(.42,.07)));\n    echarpe = smin(echarpe, sdTorus(p+vec3(0,-.2+dy,0), vec2(.46,.09)),.15);\n\tvec2 result =  min2(vec2(echarpe,0.), vec2(bonnet, 1.));\n    result.x -= .001*sp.x*sp.y*sp.z;\n    result.x *=.8;\n    return result;\n}\n\n\nvec3 headRotCenter = vec3(0,-.2,-.07);\nfloat map( vec3 p) {\n    \n    float px = mod(p.x+8.,16.)-8.;\n    \n    float lineId = floor((px-p.x+8.)\/16.);\n    p.x = px;\n    float rnd = hash(lineId+10.);\n    p.z += cos(g_time*rnd+2.*rnd)*rnd;\n    p.y += cos(g_time+5.*rnd)*rnd;\n    \n    float d = dToga0(p);\n    d = min(d, spaceship0(p, lineId));\n        \n    vec3 p0 = p;\n    p -= headRotCenter;\n    p.yz *= g_headRotH;\n    p += headRotCenter;\n    \n\td = min(d, dSkinPart(p0,p));\n    p.x = abs(p.x);\n    d = min(d, dEye(p- g_eyePos));\n\n    return d;\n}\n\n\n\/\/ render for color extraction\nfloat colorField(vec3 p) {\n\n    float px = mod(p.x+8.,16.)-8.;\n    \n    float lineId = floor((px-p.x+8.)\/16.);\n    p.x = px;\n    float rnd = hash(lineId+10.);\n    p.z += cos(g_time*rnd+2.*rnd)*rnd;\n    p.y += cos(g_time+5.*rnd)*rnd;\n    \n    vec2 dc = dToga(p);\n    dc = min2(dc, spaceship(p,lineId));\n    \n    vec3 p0 = p;\n    p -= headRotCenter;\n    p.yz *= g_headRotH;\n    p += headRotCenter;\n\n    dc = min2(vec2(dSkinPart(p0,p), 2.), dc);\n         \n    p.x = abs(p.x);\n\treturn min2(dc, vec2(dEye(p - g_eyePos), 3.)).y;\n}\n\n\n\/\/ ---------------------------------------------------------------------------\n\nfloat SmoothMax( float a, float b, float smoothing ) {\n\treturn a-sqrt(smoothing*smoothing + pow(max(.0,a-b),2.0));\n}\n\nvec3 Sky( vec3 ray) {\n\treturn g_envBrightness*mix( vec3(.8), vec3(0), exp2(-(1.0\/max(ray.y,.01))*vec3(.4,.6,1.0)) );\n}\n\n\n\n\/\/--------------------------------------------------------------------\n\nconst float cloudScale = .15;\n\nfloat map5( in vec3 p )\n{\n\tvec3 q = p*cloudScale;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q ); q = q*2.02;\n    f += 0.03125*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n\nfloat map4( in vec3 p )\n{\n\tvec3 q = p*cloudScale;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\nfloat map3( in vec3 p )\n{\n\tvec3 q = p*cloudScale;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\nfloat map2( in vec3 p )\n{\n\tvec3 q = p*cloudScale;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n\nvec3 sundir = normalize(vec3(.5,1.5,1.5)); \/\/normalize( vec3(-1.0,0.0,-1.0) );\n\n\nvec4 integrate( in vec4 sum, in float dif, in float den, in vec3 bgcol, in float t )\n{\n  \/\/  bgcol *= 1.2;\n    \/\/ lighting\n    vec3 lin = vec3(0.65,0.7,0.75)*1.4 + vec3(1.0, 0.6, 0.3)*dif;        \n    vec4 col = vec4( mix( vec3(1.0,0.95,0.8), vec3(0.25,0.3,0.35), den ), den );\n    col.xyz *= lin;\n    \/\/col.xyz = mix( col.xyz, bgcol, 1.0-exp(-0.00008*t*t) );\n    \/\/ front to back blending         \n\tcol.xyz = mix(bgcol, col.xyz, exp2(-t*vec3(.4,.6,1.0)\/39.) );\n    col.a *= 0.5;\n    col.rgb *= col.a;\n    return sum + col*(1.0-sum.a);\n}\n\n#ifdef CLOUD_FAST\n\n#define MARCH(STEPS,MAPLOD,TEND) for(int i=0; i<STEPS; i++) { vec3  pos = ro + t*rd; if( t>TEND || sum.a > 0.95 ) break; float den = MAPLOD( pos ); if( den>0.01 ) { float dif =  clamp((den - MAPLOD(pos+0.3*sundir))\/0.6, 0.0, 1.0 ); sum = integrate( sum, dif, den, bgcol, t ); } t += max(.3,0.2*t); }\n\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol, in float tend )\n{\n    ro.y *= .3;\n    rd.y *= .3;\n    \n\tvec4 sum = vec4(0.0);\n\n\tfloat t = 0.0;\n\/\/    MARCH(30,map5, tend);\n    MARCH(30,map4, tend);\n\/\/    MARCH(30,map3, tend);\n    MARCH(30,map2, tend);\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\n#else\n\n#define MARCH(STEPS,MAPLOD,TEND) for(int i=0; i<STEPS; i++) { vec3  pos = ro + t*rd; if( t>TEND || sum.a > 0.95 ) break; float den = MAPLOD( pos ); if( den>0.01 ) { float dif =  clamp((den - MAPLOD(pos+0.3*sundir))\/0.6, 0.0, 1.0 ); sum = integrate( sum, dif, den, bgcol, t ); } t += max(.3,0.06*t); }\n\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol, in float tend )\n{\n    ro.y *= .3;\n    rd.y *= .3;\n    \n\tvec4 sum = vec4(0.0);\n\n\tfloat t = 0.0;\n    MARCH(30,map5, tend);\n    MARCH(30,map4, tend);\n    MARCH(30,map3, tend);\n    MARCH(30,map2, tend);\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\n#endif \/\/ CLOUD_FAST\n\n\n\n\n\n\n\n\n\/\/ -------------------------------------------------------------------\n\/\/ pupils effect came from lexicobol shader:\n\/\/ https:\/\/www.shadertoy.com\/view\/XsjXz1\n\/\/ -------------------------------------------------------------------\n\n\nfloat iqnoise( in vec2 x, float u, float v )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tfloat k = 1.0+63.0*pow(1.0-v,4.0);\n\tfloat va = 0.0;\n\tfloat wt = 0.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ ) {\n        vec2 g = vec2(i,j);\n\t\tvec3 o = hash3( p + g )*vec3(u,u,1.0);\n\t\tvec2 r = g - f + o.xy;\n\t\tfloat d = dot(r,r);\n\t\tfloat ww = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n\t\tva += o.z*ww;\n\t\twt += ww;\n    }\n\t\n    return va\/wt;\n}\n\nfloat noise ( vec2 x)\n{\n\treturn iqnoise(x, 0.0, 1.0);\n}\n\nmat2 m = mat2( 0.8, 0.6, -0.6, 0.8);\n\nfloat fbm( vec2 p)\n{\n\tfloat f = 0.0;\n    f += 0.5000 * noise(p); p *= m* 2.02;\n    f += 0.2500 * noise(p); p *= m* 2.03;\n    f += 0.1250 * noise(p); p *= m* 2.01;\n    f += 0.0625 * noise(p); p *= m* 2.04;\n    f \/= 0.9375;\n    return f;\n}\n\n\nvec3 iris(vec2 p, float open)\n{\n    float background = 1.0;\/\/ smoothstep(-0.25, 0.25, p.x);\n    \n    float r = sqrt( dot (p,p));\n    float r_pupil = .15 + .15*smoothstep(.5,2.,open);\n\n    float a = atan(p.y, p.x); \/\/ + 0.01*g_time;\n    vec3 col = vec3(1.0);\n    \n    float ss = 0.5;\/\/ + 0.5 * sin(g_time * 2.0);\n    float anim = 1.0 + 0.05*ss* clamp(1.0-r, 0.0, 1.0);\n    r *= anim;\n        \n    if( r< .8) {\n\t\tcol = vec3(0.12, 0.60, 0.57);\n        float f = fbm(5.0 * p);\n        col = mix(col, vec3(0.12,0.52, 0.60), f); \/\/ iris bluish green mix\n        \n        f = 1.0 - smoothstep( r_pupil, r_pupil+.2, r);\n        col = mix(col, vec3(0.60,0.44,0.12), f); \/\/yellow\n        \n        a += 0.05 * fbm(20.0*p);\n        \n        f = smoothstep(0.3, 1.0, fbm(vec2(5.0 * r, 20.0 * a))); \/\/ white highlight\n        col = mix(col, vec3(1.0), f);\n        \n        f = smoothstep(0.3, 1.0, fbm(vec2(5.0 * r, 5.0 * a))); \/\/ yellow highlight\n        col = mix(col, vec3(0.60,0.44,0.12), f);\n        \n        f = smoothstep(0.5, 1.0, fbm(vec2(5.0 * r, 15.0 * a))); \/\/ dark highlight\n        col *= 1.0 - f;\n        \n        f = smoothstep(0.55, 0.8, r); \/\/dark at edge\n        col *= 1.0 - 0.6*f;\n        \n        f = smoothstep( r_pupil, r_pupil + .05, r); \/\/pupil\n        col *= f; \n        \n        f = smoothstep(0.75, 0.8, r);\n        col = .5*mix(col, vec3(1.0), f);\n    }\n    \n\treturn col * background;\n}\n\n\/\/ -------------------------------------------------------------------\n\nfloat lineSegDist( vec2 uv, vec2 ba, vec2 a, float r ) {\n    vec2 pa = uv - a - ba*r; ba = -ba*r;\n    return length( pa - ba*clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 ) );\n}\n\nfloat snowFlake(vec2 p) {\n    p*= 8.;\n    if (length(p)>2.2) return 0.;\n    p.y = -abs(p.y);\n\n    float d2 = lineSegDist(p, vec2(-1., 0.), vec2(-1.2,-.5), 1.2); \n    d2 = min(d2, lineSegDist(p, vec2(-1., 0.), vec2(-1.6,-.15), .8)); \n\n    p.x = abs(p.x);\n    \n\n    float a = .6;\n    float d = lineSegDist(p, vec2(1., 0.), vec2(.0,0.), 1.);\n    d = min(d, lineSegDist(p, vec2(.5, -.866), vec2(0.,0.), 1.));\n    d = min(d, lineSegDist(p, vec2(.5, -.866), vec2(a,0.), .25));\n    d = min(d, lineSegDist(p, vec2(-.5, -.866), vec2(a*.5,-.866*a), .25));\n    d = min(d, lineSegDist(p, vec2(1., 0.), vec2(a*.5,-.866*a), .25));\n\t\n    return (1.-smoothstep(.05,.08,abs(d-.15))) + \n        (1.-smoothstep(.0,.03,d2-.05));\n}\n\n\n\/\/ -------------------------------------------------------------------\n\n\n\nvec3 Shade( vec3 pos, vec3 ray, vec3 normal, vec3 lightDir1, vec3 lightDir2, vec3 lightCol1, vec3 lightCol2, float shadowMask1, float shadowMask2, float distance )\n{\n    \n    float colorId = colorField(pos);\n    \n\tvec3 ambient = g_envBrightness*mix( vec3(.2,.27,.4), vec3(.4), (-normal.y*.5+.5) ); \/\/ ambient\n    \n    \/\/ ambient occlusion, based on my DF Lighting: https:\/\/www.shadertoy.com\/view\/XdBGW3\n\tfloat aoRange = distance\/20.0;\n\t\n\tfloat occlusion = max( 0.0, 1.0 - map( pos + normal*aoRange )\/aoRange ); \/\/ can be > 1.0\n\tocclusion = exp2( -2.0*pow(occlusion,2.0) ); \/\/ tweak the curve\n    \n\tambient *= occlusion*.8+.2; \/\/ reduce occlusion to imply indirect sub surface scattering\n\n\tfloat ndotl1 = max(.0,dot(normal,lightDir1));\n\tfloat ndotl2 = max(.0,dot(normal,lightDir2));\n    \n\tfloat lightCut1 = smoothstep(.0,.1,ndotl1);\n\tfloat lightCut2 = smoothstep(.0,.1,ndotl2);\n\n\tvec3 light = vec3(0);\n    \n\n\tlight += lightCol1*shadowMask1*ndotl1;\n\tlight += lightCol2*shadowMask2*ndotl2;\n\n    \n\t\/\/ And sub surface scattering too! Because, why not?\n    float transmissionRange = distance\/10.0; \/\/ this really should be constant... right?\n    float transmission1 = map( pos + lightDir1*transmissionRange )\/transmissionRange;\n    float transmission2 = map( pos + lightDir2*transmissionRange )\/transmissionRange;\n    \n    vec3 sslight = lightCol1 * smoothstep(0.0,1.0,transmission1) + lightCol2 * smoothstep(0.0,1.0,transmission2);\n    vec3 subsurface = vec3(1,.8,.5) * sslight;\n\n    float specularity = .2; \n\tvec3 h1 = normalize(lightDir1-ray);\n\tvec3 h2 = normalize(lightDir2-ray);\n    \n\tfloat specPower;\n    specPower = exp2(3.0+5.0*specularity);\n\n    vec3 p = pos;\n    p -= headRotCenter;\n    p.yz *= g_headRotH;\n    p += headRotCenter;\n         \n    float px = mod(p.x+8.,16.)-8.;\n    float lineId = floor((px-p.x+8.)\/16.);\n    p.x = px;\n    float rnd = hash(lineId+10.);\n    p.z += cos(g_time*rnd+2.*rnd)*rnd;\n    p.y += cos(g_time+5.*rnd)*rnd;\n        \n     \n    vec3 albedo;\n\n    if (colorId < 1.5) {  \n        \/\/ closes\n        albedo = mix(vec3(.8),vec3(.7,0.,0.),colorId);\n        specPower = sqrt(specPower);\n    } else if (colorId < 2.5) {\n         \/\/ Skin color\n        albedo = vec3(.6,.43,.3); \n      \/\/  normal = doBumpMap(iChannel1, p, normal,.003); \n    } else if (colorId < 3.5) {\n\n        \/\/ Eye\n        if (p.z>0.) {\n            vec3 g_eyePosloc = g_eyePos;\n            g_eyePosloc.x *= sign(p.x);\n            \n            vec3 pe = p - g_eyePosloc;\n            \/\/ Light point in face coordinates\n        \tvec3 g_lightPos2 = g_lightPos - headRotCenter;\n    \t\tg_lightPos2.yz *= g_headRotH;\n    \t\t\/\/g_lightPos2.xz *= g_headRot;\n    \t\tg_lightPos2 += headRotCenter;\n\n            vec3 dir = normalize(g_lightPos2-g_eyePosloc);\n            \n            float a = clamp(atan(-dir.x, dir.z), -.2,.2), \n                  ca = cos(a), sa = sin(a);\n            pe.xz *= mat2(ca, sa, -sa, ca);\n\n            float b = clamp(atan(-dir.y, dir.z), -.1,.1), \n                  cb = cos(b), sb = sin(b);\n            pe.yz *= mat2(cb, sb, -sb, cb);\n            \n            \n            albedo = (pe.z>0.) ? iris(17.*(pe.xy), length(g_lightPos2-g_eyePosloc)) : vec3(1);\n        }\n        specPower *= specPower;\n    } else if (colorId < 39.5) {  \n        \/\/ spaceship\n        vec3 shipColor = hsv2rgb_smooth(.75+(colorId-20.)*.25,1.,.5);\n        albedo = mix(vec3(.8), shipColor,fract(colorId));\n        if (lineId == 0.)\n        \talbedo = mix(albedo, vec3(1), snowFlake((p.zy-vec2(-.06,-.8))));\n\n        normal = doBumpMap(iChannel2, p*1.2, normal,.01);\n       \/\/ specPower = sqrt(specPower);\n        specPower*=1.5;\n        \n        \n    } else {\n    \talbedo = mix(vec3(.7,.2,.2),hsv2rgb_smooth(hash(colorId),.6,1.), fract(colorId));  \n        specPower*2.;\/\/specPower;\n    }\n    \n\tvec3 specular1 = lightCol1*shadowMask1*pow(max(.0,dot(normal,h1))*lightCut1, specPower)*specPower\/32.0;\n\tvec3 specular2 = lightCol2*shadowMask2*pow(max(.0,dot(normal,h2))*lightCut2, specPower)*specPower\/32.0;\n    \n\tvec3 rray = reflect(ray,normal);\n\tvec3 reflection = Sky( rray );\n\t\n\t\/\/ specular occlusion, adjust the divisor for the gradient we expect\n\tfloat specOcclusion = max( 0.0, 1.0 - map( pos + rray*aoRange )\/(aoRange*max(.01,dot(rray,normal))) ); \/\/ can be > 1.0\n\tspecOcclusion = exp2( -2.0*pow(specOcclusion,2.0) ); \/\/ tweak the curve\n\t\n\t\/\/ prevent sparkles in heavily occluded areas\n\tspecOcclusion *= occlusion;\n\n\treflection *= specOcclusion; \/\/ could fire an additional ray for more accurate results\n    \n\tfloat fresnel = pow( 1.0+dot(normal,ray), 5.0 );\n\tfresnel = mix( mix( .0, .01, specularity ), mix( .4, 1.0, specularity ), fresnel );\n\n    light += ambient;\n\tlight += subsurface;\n\n    vec3 result = light*albedo;\n\tresult = mix( result, reflection, fresnel );\n\tresult += specular1;\n    result += specular2;\n\n    \n    \n\treturn result;\n}\n\n\nfloat Trace( vec3 pos, vec3 ray, float traceStart, float traceEnd )\n{\n    float t0=0.,t1=1000.;\n    float t2=0.,t3=1000.;\n  \n    float t = max(traceStart, min(t2,t0));\n    traceEnd = min(traceEnd, max(t3,t1));\n    float h;\n    for( int i=0; i < g_traceLimit; i++) {\n        h = map( pos+t*ray );\n        if (h < g_traceSize || t > traceEnd)\n            return t>traceEnd?1000.:t;\n        t = t+h;\n    }\n    \n\treturn 1000.0;\n}\n\n\n\nvec3 Normal( vec3 pos, vec3 ray, float t) {\n\n\tfloat pitch = .2 * t \/ iResolution.x;\n    \n\/\/#ifdef FAST\n\/\/\t\/\/ don't sample smaller than the interpolation errors in Noise()\n\tpitch = max( pitch, .005 );\n\/\/#endif\n\t\n\tvec2 d = vec2(-1,1) * pitch;\n\n\tvec3 p0 = pos+d.xxx; \/\/ tetrahedral offsets\n\tvec3 p1 = pos+d.xyy;\n\tvec3 p2 = pos+d.yxy;\n\tvec3 p3 = pos+d.yyx;\n\t\n\tfloat f0 = map(p0);\n\tfloat f1 = map(p1);\n\tfloat f2 = map(p2);\n\tfloat f3 = map(p3);\n\t\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3);\n\t\/\/return normalize(grad);\n\t\/\/ prevent normals pointing away from camera (caused by precision errors)\n\treturn normalize(grad - max(.0,dot (grad,ray ))*ray);\n}\n\n\n\/\/ Camera\nvec3 Ray( float zoom, in vec2 fragCoord) {\n    mat2 rot = matRot(.2*cos(.2*g_time)*cos(.71*g_time)); \n\treturn vec3( (fragCoord.xy-iResolution.xy*.5)*rot, iResolution.x*zoom );\n}\n\nvec3 Rotate( inout vec3 v, vec2 a ) {\n\tvec4 cs = vec4( cos(a.x), sin(a.x), cos(a.y), sin(a.y) );\n\t\n\tv.yz = v.yz*cs.x+v.zy*cs.y*vec2(-1,1);\n\tv.xz = v.xz*cs.z+v.zx*cs.w*vec2(1,-1);\n\t\n\tvec3 p;\n\tp.xz = vec2( -cs.w, -cs.z )*cs.x;\n\tp.y = cs.y;\n\t\n\treturn p;\n}\n\n\n\/\/ Camera Effects\n\nvoid BarrelDistortion( inout vec3 ray, float degree ){\n\t\/\/ would love to get some disperson on this, but that means more rays\n\tray.z \/= degree;\n\tray.z = ( ray.z*ray.z - dot(ray.xy,ray.xy) ); \/\/ fisheye\n\tray.z = degree*sqrt(ray.z);\n}\n\n\n\n\n\/\/ -------------------------------------------\n\nconst float\n    a_eyeClose = .55, \n    a_eyeOpen = -.3;\n\n\n\/\/const float \n  \/\/  t_apear = 5.,\n \/\/   t_noze = t_apear+8., \n \/\/   t_openEye = t_noze + 1.,\n \/\/   t_g_headRot = t_openEye + 4.5,\n  \/\/  t_rotDown = t_g_headRot + 3.5,\n  \/\/  t_outNoze = t_rotDown + 3.,\n  \/\/  t_night = t_outNoze + 4.,\n  \/\/  t_colorfull = t_night + 5.,\n  \/\/  t_disapear = t_colorfull + 2.,\n  \/\/  t_closeEye = t_disapear + 3.;\n\n\nmat3 lookat(in vec3 ro, in vec3 up){\n    vec3 fw=normalize(ro),\n    \t rt=normalize(cross(fw,up));\n    return mat3(rt, cross(rt,fw),fw);\n}\n\nvec3 RD(in vec3 ro, in vec3 cp, in vec2 fCoord) {\n    return lookat(cp-ro, vec3(0.,1.,0.))*normalize(vec3(((2.*fCoord-iResolution.xy)\/iResolution.y)*ma, 12.0));\n} \n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float yy = fragCoord.y\/iResolution.y;\n\tif(yy<.11 || yy >.89) discard;\n\n\tg_time = 1.2*iGlobalTime;\/\/ - .25*smoothstep(2.,4.,iGlobalTime);\n    \n    float st = 1.2; \/\/ speed coeff\n    float time = g_time-19.;\n    \n\/\/ constantes\n    ma = matRot(-.5);\n    mb = matRot(-.15);\n    mc = matRot(-.6);\n\n    rotTime = matRot(5.*g_time); \n    \n\/\/ Eye blink\n    float a_Paupieres = mix(a_eyeOpen,a_eyeClose, hash(floor((time-2.)*10.))>.94?2.*abs(fract(20.*(time-2.))-.5):0.);    \n\n    g_eyeRot = matRot(a_Paupieres);\n\n\/\/ rotation de la tete \n    float a_headRot = 0.1, a_headRotH = -.1;\n\n    g_headRotH = matRot(a_headRotH); \n\n    mat2 g_headRotH2 = matRot(-a_headRotH); \n\n\n\n    g_lightPos = vec3(0,0,40);\n\n\/\/ intensitee et couleur du point\n    float lightAppear = 0.; \n\tvec3 lightCol2 = vec3(1.,0.,0.);\n    \n\t\/\/ Ambiant color\n\tg_envBrightness = vec3(.6,.65,.9);\n\t\n\n\tvec3 lightDir1 = normalize(vec3(.5,1.5,1.5));\n\tvec3 lightCol1 = vec3(1.1,1.,.9)*.7*g_envBrightness;\n\n\tfloat lightRange2 = .4; \n\tfloat traceStart = 0.;\n\tfloat traceEnd = 200.0;\n\n    vec3 col, colorSum = vec3(0.);\n\n#if (ANTIALIASING == 1)\t\n\tint i=0;\n#else\n\tfor (int i=0;i<ANTIALIASING;i++) {\n#endif\n\t\tcol = vec3(0);\n\n        \/\/ Camera    \n\n#if (ANTIALIASING == 1)\t        \n        float randPix = 0.;\n#else \n        float randPix = hash(g_time); \/\/ Use frame rate to improve antialiasing ... not sure of result\n#endif        \n\t\tvec2 subPix = .4*vec2(cos(randPix+6.28*float(i)\/float(ANTIALIASING)),\n                              sin(randPix+6.28*float(i)\/float(ANTIALIASING)));\n\t\t\n\n        \n        vec3 ray = Ray(1.8,fragCoord.xy+subPix);\t\t\n\t\tBarrelDistortion(ray, 2.15 );\n\t\tray = normalize(ray);\n\t\tvec3 localRay = ray;\n        \n        \n\t\tvec2 mouse = vec2(-.1-.1*cos(.4*g_time),0.);\n\n\t\tif ( iMouse.z > 0.0 )\n\t\t\tmouse = .5-iMouse.yx\/iResolution.yx;\n\t\tvec3 pos; \/\/ = vec3(0,-.2,-2.) + 37.*Rotate(ray, vec2(-.1,1.+time*.1)+vec2(-1.0,-3.3)*mouse );        \n\n        g_deltaPast = hash3(vec2(g_time));\n        vec2 q = ((2.*(fragCoord.xy+subPix)-iResolution.xy)\/iResolution.y);\n\n        float time2 = \/*mod(*\/g_time;\/\/,52.);\n        if (time2 < 5.5) {\n        \tpos = vec3(10., 1., 450.-200.*(time2));\n            q *= matRot(mix(-.5, .5, smoothstep(1.8, 2.2, time2))); \n            ray = lookat(-pos, vec3(0.,1.,0.))*normalize(vec3(q, 12.0));\n        } else if (time2 < 24.) {\n        \/\/\tpos = mix(vec3(6., 0., 5.), vec3(6., 0., 5.-200.*(time2-17.)), smoothstep(16.,16.2,time2));\n        \tpos = vec3(6., -.15, 3.5);\n            float a = mix(0., 2.2, \/*8.5,*\/ smoothstep(14., 19., time2));\n            float k = mix(1., 5., smoothstep(17., 20., time2));\n            k = mix(k, 55., smoothstep(23.5, 24., time2));\n            pos *= k;\n            pos.xz *= matRot(a);\n            ray = lookat(vec3(0.0,0.05,.7)-pos, vec3(0.,1.,0.))*normalize(vec3(q, 6.0));\n            pos -= .1*g_deltaPast;\n\n        } else {\n\t\t\tg_time += 9.;\n            \n            ray = Ray(1.8,fragCoord.xy+subPix);\t\t\n            BarrelDistortion(ray, 2.15 );\n            ray = normalize(ray);\n            localRay = ray;\n\n\t\t\tmouse = vec2(-.1-.1*cos(.4*g_time),0.);\n\t\t\tpos = vec3(0,-.2,-2.) + 37.*Rotate(ray, vec2(-.1,1.+time*.1)+vec2(-1.0,-3.3)*mouse );        \n            pos -= .2*g_deltaPast;\n        }\n        \n\t\tvec3 skyColor = Sky( ray );\n        \n\n\t\tfloat t = Trace(pos, ray, traceStart, traceEnd );\n        if ( t < 900.0 )\n\t\t{           \n\t\t\tvec3 p = pos + ray*t;\n\t\t\t\n\t\t\t\/\/ Shadows\n\t\t\tvec3 lightDir2 = g_lightPos-p;\n\t\t\tfloat lightIntensity2 = length(lightDir2);\n\t\t\tlightDir2 \/= lightIntensity2;\n\t\t\tlightIntensity2 = lightAppear*lightRange2\/(.1+lightIntensity2*lightIntensity2);\n\t\t\t\n\t\t\tfloat s1 = 0.0;\n\t\t\ts1 = Trace(p, lightDir1, .05, 4.0 );\n\t\t\tfloat s2 = 0.0;\n\t\t\ts2 = Trace(p, lightDir2, .05, 4.0 );\n\t\t\t\n\t\t\tvec3 n = Normal(p, ray, t);\n\t\t\tcol = Shade(p, ray, n, lightDir1, lightDir2,\n\t\t\t\t\t\tlightCol1, lightCol2*lightIntensity2,\n\t\t\t\t\t\t(s1<20.0)?0.0:1.0, (s2<20.0)?0.0:1.0, t );\n\t\t\t\n\t\t\t\/\/ fog\n\t\t\tfloat f = 25.0;\n\t\t\tcol = mix(skyColor, col, exp2(-t*vec3(.4,.6,1.0)\/f) );\n\t\t}\n\t\telse\n\t\t{\n            t = 200.;\n            col = skyColor; \n\t\t}\n        \n        \n         vec4 cloud = raymarch(pos+vec3(0.,3.,g_time*200.), ray, skyColor, t);\n         col = col*(1.-cloud.a) + cloud.xyz; \/\/col*(1.-cloud.a) + cloud.rgb*cloud.a;\n        \n        \t\t\n\n\t\/\/ Post traitments -----------------------------------------------------    \n\t\t\/\/ Vignetting:\n\t\tcol *= smoothstep(.15, .0, dot(localRay.xy,localRay.xy) );\n\n\t\t\t\n\t\tcolorSum += col;\n        \n#if (ANTIALIASING > 1)\t\n\t}\n    \n    col = colorSum\/float(ANTIALIASING);\n#else\n\tcol = colorSum;\n#endif\n    \n\n    \/\/ Compress bright colours, (because bloom vanishes in vignette)\n    vec3 c = (col-1.0);\n    c = sqrt(c*c+.05); \/\/ soft abs\n    col = mix(col,1.0-c,.48); \/\/ .5 = never saturate, .0 = linear\n\t\n\t\/\/ compress bright colours\n\tfloat l = max(col.x,max(col.y,col.z));\/\/dot(col,normalize(vec3(2,4,1)));\n\tl = max(l,.01); \/\/ prevent div by zero, darker colours will have no curve\n\tfloat l2 = SmoothMax(l,1.0,.01);\n\tcol *= l2\/l;\n    \n    \t\t\/\/ grain\n\t\tvec2 grainuv = fragCoord.xy + floor(g_time*60.0)*vec2(37,41);\n\t\tvec2 filmNoise = 1.5*texture2D( iChannel1, .5*grainuv\/iChannelResolution[0].xy ).rb;\n\t\tcol *= mix( vec3(1), mix(vec3(1,.5,0),vec3(0,.5,1),filmNoise.x), .1*filmNoise.y );\n    \/*\n   float gray = dot(col, vec3(0.299, 0.587, 0.114));\n\t\n    const vec3 SEPIA = vec3(1.25, 1.0, 0.85); \n    col = gray*gray*gray*SEPIA;\n    *\/\n \/\/   col = mix(col, vec3(1), snowFlake(3.*(fragCoord\/iResolution.y)+vec2(-5.1,-.52)));\n\tfragColor =  vec4(pow(col,vec3(1.\/1.6)),1);\n}\n","name":"","description":"","type":"image"}]}}