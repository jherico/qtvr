{"Shader":{"ver":"0.1","info":{"id":"4l2SDc","date":"1447001244","viewed":342,"name":"Moonwalkin2","username":"summer","description":"walking on the moon...","likes":1,"published":3,"flags":0,"tags":["raytracing","grid","ridgedfbm"],"hasliked":0},"renderpass":[{"inputs":[{"id":17,"src":"\/presets\/tex12.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define RES 4\n#define GAIN 0.8\n#define LAC 1.3\n#define HEIGHT 0.3\n#define PREC 0.003\n#define EPS 0.03\n#define SIZE 4.\nconst vec2 add = vec2(1., 0.);\nfloat Noise(vec2 xy){\n\treturn texture2D(iChannel0, xy).x*2.-1.;   \n}\n\nfloat ridge(float n){\n\treturn 2.*pow(1.-abs(n), 3.0)-1.;   \n}\n\n\nfloat stars(vec2 uv){\n\tif(Noise(uv*0.7)>0.9)\n\t\treturn 1.0;\n\treturn 0.0;\n}\n\nfloat ridged(vec2 pos){\n\tfloat r = 0.0, f = 1.0, a = 1.0, p = 1.0;\n\tfor(int i=0; i<10; i++){\n        if(i>=RES)\n            break;\n        float n = a*ridge(Noise(f*pos));\n        r += (p\/2.+.5)*n;\n\t\tf *= LAC;\n\t\ta *= GAIN;\n        p = n;\n\t}\n\treturn r\/1.5;\n}\n\nfloat holes(vec2 pos){\n        vec2 tile = floor(pos\/SIZE);    \n    vec2 offset = abs(vec2(fract(Noise(tile))*SIZE, fract(Noise(tile*11.123))*SIZE));\n    offset = vec2(.5, .5)*SIZE+Noise(tile)*2.;\n       vec2 uv = fract(abs(pos)\/SIZE)*SIZE-offset;\n     if(length(uv)<1.)\n        return pow(length(uv*0.2), 1.3);\n    return 20.;\n}\nfloat grid(vec2 pos){\n    vec2 tile = floor(pos\/SIZE);    \n    vec2 offset = abs(vec2(fract(Noise(tile))*SIZE, fract(Noise(tile*11.123))*SIZE));\n    offset = vec2(.5, .5)*SIZE+Noise(tile)*2.;\n    vec2 uv = fract(abs(pos)\/SIZE)*SIZE-offset;\n    float size = Noise(tile*4.234);\n    return min(1.\/(pow(length(uv), 6.)+0.1), 0.6);\n}\n\nfloat map(vec2 pos){\n\n    return min(max(ridged(pos\/350.)*HEIGHT, grid(pos)\/1.4-.3),holes(pos));\n    \n}\n\n\nbool trace(vec3 ro, vec3 rd, out vec3 hit){\n    vec3 last = ro;\n    hit = ro;\n    for(int i=0; i<1000; i++){\n        float dist = length(ro-hit);\n        if(dist>30.0)\n            return false;\n        float h = map(hit.xy);\n        hit = last+rd*max(0.01, (hit.z-h)*0.1);       \n        if(h>hit.z){\n            \/\/hit = bs(last,hit);\n           \n            return true;\n        }\n        last = hit;\n    }\n    return false;\n}\n\nvoid camera(vec2 uv, out vec3 cp, out vec3 cd){\n\tcp = iGlobalTime * vec3(0., 1., 0.)+vec3(0., 0., 1.4);\n    cd = vec3(mix(-1., 1., uv.x)*iResolution.x\/iResolution.y,\n              1.,\n              mix(-1., .5, uv.y)\n        );\n}\n\nvec3 normal(vec2 pos){\n     float dfx = map(pos+add.xy*EPS)-map(pos-add.xy*EPS);\n     float dfy = map(pos+add.yx*EPS)-map(pos-add.yx*EPS);\n     return normalize(cross(vec3(add.xy*EPS, dfx), vec3(add.yx*EPS, dfy)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cp;\n    vec3 cd;\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    camera(uv, cp, cd);\n    vec3 hit;\n    float t;\n    if(trace(cp, cd, hit))\n        \/\/t = length(hit-cp)\/15.;\n        t = dot(normal(hit.xy), normalize(vec3(1.0, 0.0, 0.1)));\n    else\n        t = stars(uv);\n    \/\/t = ridged(uv\/10.)\/2.+0.5;\n\tfragColor = vec4(t, t, t, 0.0);\n}","name":"","description":"","type":"image"}]}}