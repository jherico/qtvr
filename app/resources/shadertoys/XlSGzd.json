{"Shader":{"ver":"0.1","info":{"id":"XlSGzD","date":"1427149661","viewed":655,"name":"Acid Kaleidoscope","username":"mpcomplete","description":"Playing with transitions between transformations.<br\/><br\/>Mixing ideas from<br\/>- https:\/\/www.shadertoy.com\/view\/XlXGW2 and<br\/>- https:\/\/www.shadertoy.com\/view\/XlfGDf","likes":3,"published":3,"flags":0,"tags":["transformations"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/#define DEBUG 1\n\nfloat time = iGlobalTime*.3;\n\n\/\/ 2D rotation matrix.\nmat2 rotate(float angle)\n{\n    return mat2(\n        vec2( cos(angle), sin(angle)),\n        vec2(-sin(angle), cos(angle)));\n}\n\n\/\/ Transform a point on square to a circle.\nvec2 mapSquare(in vec2 p)\n{\n    vec2 ap = abs(p);\n    float r = max(ap.x, ap.y);\n    float angle = atan(p.y, p.x);\n\n    return r*vec2(cos(angle), sin(angle));\n}\n\n\/\/ Make a pattern of squares in a repeating grid.\nvec2 dupSquares(in vec2 p)\n{\n    vec2 ap = abs(sin(p*3.));\n    float r = max(ap.x, ap.y);\n    float angle = atan(p.y, p.x);\n\n    return r*vec2(cos(angle), sin(angle));\n}\n\n\/\/ Duplicate pattern in dupSquaresConcentric squares.\nvec2 dupSquaresConcentric(in vec2 p)\n{\n    vec2 ap = abs(p);\n    float r = max(ap.x, ap.y);\n    float angle = atan(p.y, p.x);\n\n    return sin(3.*r)*vec2(cos(angle), sin(angle));\n}\n\n\/\/ Duplicate pattern in a repeating grid.\nvec2 dupGrid(in vec2 p)\n{\n    return abs(sin(p*4.));\n}\n\nfloat numPhases = 4.;\nvec2 getTransform(in vec2 p, float t)\n{\n    int which = int(mod(t, numPhases));\n\n    if (which == 0) {\n        p = rotate(time*.3)*p*.7;\n        p = dupSquares(p);\n    } else if (which == 1) {\n        p = dupSquares(p);\n        p = rotate(time*.2)*p;\n        p = dupSquares(p);\n    } else if (which == 2) {\n        p = dupSquares(p);\n        p = rotate(time*.3)*p;\n        p = dupSquaresConcentric(p);\n    } else {\n        p = dupSquaresConcentric(p*1.5);\n    }\n    return p;\n}\n\nvec2 applyTransform(in vec2 p)\n{\n    float t = time*.35;\n#ifdef DEBUG\n    if (iMouse.z > .001) t = iMouse.x\/iResolution.x * numPhases;\n#endif\n    float pct = smoothstep(0., 1., mod(t, 1.));\n    return mix(getTransform(p, t), getTransform(p, t+1.), pct);\n}\n\nvec4 gradient(float f)\n{\n    vec4 c = vec4(0);\n\tf = mod(f, 1.5);\n    for (int i = 0; i < 3; ++i)\n        c[i] = pow(.5 + .5 * sin(2.0 * (f +  .2*float(i))), 10.0);\n    return c;\n}\n\nfloat offset(float th)\n{\n    return .2*sin(25.*th)*sin(time);\n}\n\nvec4 tunnel(float th, float radius)\n{\n\treturn gradient(offset(th) + 2.*log(radius) - time);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy \/ iResolution.xy;\n    p.x *= iResolution.x\/iResolution.y;\n\n    p = applyTransform(p);\n\n\tfragColor = tunnel(atan(p.y, p.x), 2.0 * length(p));\n}","name":"","description":"","type":"image"}]}}