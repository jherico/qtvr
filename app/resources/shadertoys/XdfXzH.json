{"Shader":{"ver":"0.1","info":{"id":"XdfXzH","date":"1396446421","viewed":867,"name":"hardware smoothing (dFdx)","username":"FabriceNeyret2","description":"cheap smoothing using hardware derivative (limited, but basically for free).<br\/>Space to toggle ON\/OFF","likes":0,"published":3,"flags":0,"tags":["dfdx"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define SMOOTH .5 \/\/ 0., 1., or sub-relaxation\nvec2 FragCoord;\n\n\/\/ --- noise functions from https:\/\/www.shadertoy.com\/view\/XslGRr\n\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\/\/  End of Created by inigo quilez\n\nbool keyToggle(int ascii) \n{\treturn (texture2D(iChannel2,vec2((.5+float(ascii))\/256.,0.75)).x > 0.); }\n\n\n\/\/ --- the smoothing function using the neighboor pixels value\n\nfloat smooth(float v) \n{\n\tfloat vx = -dFdx(v)*(2.*mod(FragCoord.x-.5,2.)-1.),\n\t\t  vy = -dFdy(v)*(2.*mod(FragCoord.y-.5,2.)-1.);\n\n\treturn v + SMOOTH*(vx+vy)\/3.;\n}\n\nvec4 smooth(vec4 v) \n{\n\tvec4  vx = -dFdx(v)*(2.*mod(FragCoord.x-.5,2.)-1.),\n\t\t  vy = -dFdy(v)*(2.*mod(FragCoord.y-.5,2.)-1.);\n\n\treturn v + SMOOTH*(vx+vy)\/3.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy;\n    FragCoord=fragCoord;\n    \n#define IMAGE 2 \/\/ test case\n\n#if IMAGE == 1\n\tfloat v = mod(uv.x+uv.y,2.);\n#elif IMAGE == 11\n\tfloat v = (uv.x-uv.y < 0.) ? 1. : 0.;\n#elif IMAGE == 2\n\tfloat v = noise(vec3(4.*uv,0.));\n#elif IMAGE == 3\n\tvec4 v = texture2D(iChannel0, 2.*uv\/iResolution.xy,0.);\n#endif\n\t\n#define TEST 0 \/\/ smoothing (0) vs debug visualization (>0) \n\t\n#if TEST == 0\n\tif (keyToggle(32)) {\n\t\tv = smooth(v);\n\t\tif (length(uv\/iResolution.y-vec2(.1,.1))<.05) { fragColor = vec4(1.,0.,0.,0.); return; }\n\t}\n\telse\n\t\tif (abs(.05-length(uv\/iResolution.y-vec2(.1,.1)))<.003) { fragColor = vec4(1.,0.,0.,0.); return; }\n\t\n\t\/\/fragColor = vec4(v\/2.); \/\/ to check values > 1.\n\tfragColor = vec4(v);\n\n#elif TEST == 1\n\tfragColor = vec4(.5*(dFdx(v)+1.),\n\t\t\t\t\t\t.5*(dFdy(v)+1.),\n\t\t\t\t\t\t0.,1.); \n#elif TEST == 2\n\tfragColor = vec4(mod(fragCoord.x-.5,2.), \n\t\t\t\t\t\tmod(fragCoord.y-.5,2.), \n\t\t\t\t\t\t0.,1.); \n#elif TEST == 3\n\tfragColor = vec4(.5*((2.*mod(fragCoord.x,2.)-1.)+1.), \n\t\t\t\t\t\t.5*((2.*mod(fragCoord.y,2.)-1.)+1.),\n\t\t\t\t\t\t0.,1.); \n#elif TEST == 4\n\tfragColor = vec4(.5*(dFdx(v)*(2.*mod(fragCoord.x,2.)-1.)+1.), \n\t\t\t\t\t\t.5*(dFdy(v)*(2.*mod(fragCoord.y,2.)-1.)+1.),\n\t\t\t\t\t\t0.,1.); \n#endif\n\t\n}","name":"","description":"","type":"image"}]}}