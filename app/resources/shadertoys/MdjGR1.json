{"Shader":{"ver":"0.1","info":{"id":"MdjGR1","date":"1383957409","viewed":15479,"name":"Filtering procedurals","username":"iq","description":"One way to decouple material pattern\/texturing\/shading from lighting and visibility. The (procedural) texture is adaptively filtered\/supersampled based on ray differentials (max 100 samples) at a rate independent of the lighting and visibility\/tracing.","likes":61,"published":3,"flags":0,"tags":["procedural","3d","filter","filtering","differentials"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ A test on using ray differentials (only primary rays for now) to choose texture filtering\n\/\/ footprint, and adaptively supersample\/filter the procedural texture\/patter (up to a rate\n\/\/ of 10x10).\n\n\/\/ This solves texture aliasing without resorting to full-screen 10x10 supersampling, which would\n\/\/ involve doing raytracing and lighting 10x10 times (not realtime at all).\n \n\/\/ The tecnique should be used to filter every texture independently. The ratio of the supersampling\n\/\/ could be inveresely proportional to the screen\/lighing supersampling rate such that the cost\n\/\/ of texturing would be constant no matter the final image quality settings.\n\n\n\/\/===============================================================================================\n\/\/===============================================================================================\n\nconst int MaxSamples = 10;  \/\/ 10*10\n\n\/\/===============================================================================================\n\/\/===============================================================================================\n\/\/ noise implementation\n\/\/===============================================================================================\n\/\/===============================================================================================\n\nvec3 hash3( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*13.5453123);\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash3( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash3( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash3( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash3( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash3( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash3( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash3( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash3( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\n\/\/===============================================================================================\n\/\/===============================================================================================\n\/\/ sphere implementation\n\/\/===============================================================================================\n\/\/===============================================================================================\n\nfloat softShadowSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = sph.xyz - ro;\n    float b = dot( oc, rd );\n\t\n    float res = 1.0;\n    if( b>0.0 )\n    {\n        float h = dot(oc,oc) - b*b - sph.w*sph.w;\n        res = smoothstep( 0.0, 1.0, 2.0*h\/b );\n    }\n    return res;\n}\n\nfloat occSphere( in vec4 sph, in vec3 pos, in vec3 nor )\n{\n    vec3 di = sph.xyz - pos;\n    float l = length(di);\n    return 1.0 - dot(nor,di\/l)*sph.w*sph.w\/(l*l); \n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    float t = -1.0;\n\tvec3  ce = ro - sph.xyz;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\tt = -b - sqrt(h);\n\t}\n\t\n\treturn t;\n}\n\n\/\/===============================================================================================\n\/\/===============================================================================================\n\/\/ scene\n\/\/===============================================================================================\n\/\/===============================================================================================\n\n\n\/\/ spheres\nconst vec4 sc0 = vec4( 0.0,1.0, 0.0, 1.0 );\nconst vec4 sc1 = vec4( 0.0,1.0,14.0, 4.0 );\nconst vec4 sc2 = vec4(-11.0,1.0, 12.0, 4.0 );\nconst vec4 sc3 = vec4( 13.0,1.0,-10.0, 4.0 );\n\nfloat intersect( vec3 ro, vec3 rd, out vec3 pos, out vec3 nor, out float occ, out float matid )\n{\n    \/\/ raytrace\n\tfloat tmin = 10000.0;\n\tnor = vec3(0.0);\n\tocc = 1.0;\n\tpos = vec3(0.0);\n\t\n\t\/\/ raytrace-plane\n\tfloat h = (0.0-ro.y)\/rd.y;\n\tif( h>0.0 ) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.0,1.0,0.0); \n\t\tpos = ro + h*rd;\n\t\tmatid = 0.0;\n\t\tocc = occSphere( sc0, pos, nor ) * \n\t\t\t  occSphere( sc1, pos, nor ) *\n\t\t\t  occSphere( sc2, pos, nor ) *\n\t\t\t  occSphere( sc3, pos, nor );\n\t}\n\n\t\/\/ raytrace-sphere\n\th = iSphere( ro, rd, sc0 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + h*rd;\n\t\tnor = normalize(pos-sc0.xyz); \n\t\tmatid = 1.0;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\th = iSphere( ro, rd, sc1 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + tmin*rd;\n\t\tnor = normalize(ro+h*rd-sc1.xyz); \n\t\tmatid = 1.0;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\th = iSphere( ro, rd, sc2 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + tmin*rd;\n\t\tnor = normalize(ro+h*rd-sc2.xyz); \n\t\tmatid = 1.0;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\th = iSphere( ro, rd, sc3 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + tmin*rd;\n\t\tnor = normalize(ro+h*rd-sc3.xyz); \n\t\tmatid = 1.0;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\treturn tmin;\t\n}\n\nvec3 texCoords( in vec3 p )\n{\n\treturn 64.0*p;\n}\n\nvec3 mytexture( vec3 p, vec3 n, float matid )\n{\n\tp += 0.1;\n\tvec3 ip  = floor(p\/20.0);\n\tvec3 fp  = fract(0.5+p\/20.0);\n\n\tfloat id = fract(sin(dot(ip,vec3(127.1,311.7, 74.7)))*58.5453123);\n\tid = mix( id, 0.3, matid );\n\t\n\tfloat f = mod( ip.x + mod(ip.y + mod(ip.z, 2.0), 2.0), 2.0 );\n\t\n\tfloat g = 0.5 + 1.0*noise( p * mix( vec3(0.2+0.8*f,1.0,1.0-0.8*f), vec3(1.0), matid) );\n\t\n\tg *= mix( smoothstep( 0.03, 0.04, abs(fp.x-0.5)\/0.5 )*\n\t          smoothstep( 0.03, 0.04, abs(fp.z-0.5)\/0.5 ),\n\t\t\t  1.0,\n\t\t\t  matid );\n\t\n\tvec3 col = 0.5 + 0.5*sin( 1.0 + 2.0*id + vec3(0.0,1.0,2.0) );\n\t\n\treturn col * g;\n}\n\nvoid calcCamera( out vec3 ro, out vec3 ta )\n{\n\tfloat an = 0.1*iGlobalTime;\n\tro = vec3( 5.5*cos(an), 1.0, 5.5*sin(an) );\n    ta = vec3( 0.0, 1.0, 0.0 );\n\n}\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in float occ, in vec3 rd )\n{\n    float sh = min( min( min( softShadowSphere( pos, vec3(0.57703), sc0 ),\n\t\t\t\t              softShadowSphere( pos, vec3(0.57703), sc1 )),\n\t\t\t\t              softShadowSphere( pos, vec3(0.57703), sc2 )),\n                              softShadowSphere( pos, vec3(0.57703), sc3 ));\n\tfloat dif = clamp(dot(nor,vec3(0.57703)),0.0,1.0);\n\tfloat bac = clamp(dot(nor,vec3(-0.707,0.0,-0.707)),0.0,1.0);\n    vec3 lin  = dif*vec3(1.50,1.40,1.30)*sh;\n\t     lin += occ*vec3(0.15,0.20,0.30);\n\t     lin += bac*vec3(0.20,0.20,0.20);\n\t     lin += sh*0.8*pow(clamp(dot(reflect(rd,nor),vec3(0.57703)),0.0,1.0),12.0);\n\n    return lin;\n}\n\/\/===============================================================================================\n\/\/===============================================================================================\n\/\/ render\n\/\/===============================================================================================\n\/\/===============================================================================================\n\nvoid calcRayForPixel( vec2 pix, out vec3 resRo, out vec3 resRd )\n{\n\tvec2 p = (-iResolution.xy + 2.0*pix) \/ iResolution.y;\n\t\n     \/\/ camera movement\t\n\tvec3 ro, ta;\n\tcalcCamera( ro, ta );\n    \/\/ camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t\/\/ create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\t\n\tresRo = ro;\n\tresRd = rd;\n}\n\n\/\/ sample a procedural texture with filtering\nvec3 sampleTextureWithFilter( in vec3 uvw, in vec3 ddx_uvw, in vec3 ddy_uvw, in vec3 nor, in float mid )\n{\n    int sx = 1 + int( clamp( 4.0*length(ddx_uvw-uvw), 0.0, float(MaxSamples-1) ) );\n    int sy = 1 + int( clamp( 4.0*length(ddy_uvw-uvw), 0.0, float(MaxSamples-1) ) );\n\n\tvec3 no = vec3(0.0);\n\n\t#if 1\n    for( int j=0; j<MaxSamples; j++ )\n    for( int i=0; i<MaxSamples; i++ )\n    {\n        if( j<sy && i<sx )\n        {\n            vec2 st = vec2( float(i), float(j) ) \/ vec2( float(sx),float(sy) );\n            no += mytexture( uvw + st.x*(ddx_uvw-uvw) + st.y*(ddy_uvw-uvw), nor, mid );\n        }\n    }\n    #else\n    for( int j=0; j<sy; j++ )\n    for( int i=0; i<sx; i++ )\n    {\n        vec2 st = vec2( float(i), float(j) )\/vec2(float(sx),float(sy));\n        no += mytexture( uvw + st.x * (ddx_uvw-uvw) + st.y*(ddy_uvw-uvw), nor, mid );\n    }\n    #endif\t\t\n\n\treturn no \/ float(sx*sy);\n}\n\nvec3 sampleTexture( in vec3 uvw, in vec3 nor, in float mid )\n{\n    return mytexture( uvw, nor, mid );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2  p  = (-iResolution.xy + 2.0*fragCoord.xy) \/ iResolution.y;\n    float th = (-iResolution.x + 2.0*iMouse.x) \/ iResolution.y;\n\t\n    if( iMouse.z<0.01) th = 0.5\/ iResolution.y;\n\t\n\tvec3 ro, rd, ddx_ro, ddx_rd, ddy_ro, ddy_rd;\n\tcalcRayForPixel( fragCoord.xy + vec2(0.0,0.0), ro, rd );\n\tcalcRayForPixel( fragCoord.xy + vec2(1.0,0.0), ddx_ro, ddx_rd );\n\tcalcRayForPixel( fragCoord.xy + vec2(0.0,1.0), ddy_ro, ddy_rd );\n\t\t\n    \/\/ trace\n\tvec3 pos, nor;\n\tfloat occ, mid;\n    float t = intersect( ro, rd, pos, nor, occ, mid );\n\n\tvec3 col = vec3(0.9);\n\tif( t<100.0 )\n\t{\n#if 1\n\t\t\/\/ -----------------------------------------------------------------------\n        \/\/ compute ray differentials by intersecting the tangent plane to the  \n        \/\/ surface.\t\t\n\t\t\/\/ -----------------------------------------------------------------------\n\n\t\t\/\/ computer ray differentials\n\t\tvec3 ddx_pos = ddx_ro - ddx_rd*dot(ddx_ro-pos,nor)\/dot(ddx_rd,nor);\n\t\tvec3 ddy_pos = ddy_ro - ddy_rd*dot(ddy_ro-pos,nor)\/dot(ddy_rd,nor);\n\n\t\t\/\/ calc texture sampling footprint\t\t\n\t\tvec3     uvw = texCoords(     pos );\n\t\tvec3 ddx_uvw = texCoords( ddx_pos );\n\t\tvec3 ddy_uvw = texCoords( ddy_pos );\n#else\n\t\t\/\/ -----------------------------------------------------------------------\n        \/\/ Because we are in the GPU, we do have access to differentials directly\n        \/\/ This wouldn't be the case in a regular raytrace.\n\t\t\/\/ It wouldn't work as well in shaders doing interleaved calculations in\n\t\t\/\/ pixels (such as some of the 3D\/stereo shaders here in Shadertoy)\n\t\t\/\/ -----------------------------------------------------------------------\n\t\tvec3 uvw = texCoords( pos );\n\n\t\t\/\/ calc texture sampling footprint\t\t\n\t\tvec3 ddx_uvw = uvw + dFdx( uvw ); \n        vec3 ddy_uvw = uvw + dFdy( uvw ); \n#endif\n\t\t\/\/ shading\t\t\n\t\tvec3 mate = vec3(0.0);\n\t\t\n\t\tif( p.x>th ) \n            mate = sampleTexture( uvw, nor, mid );\n        else\n            mate = sampleTextureWithFilter( uvw, ddx_uvw, ddy_uvw, nor, mid );\n\n        \/\/ lighting\t\n\t\tvec3 lin = doLighting( pos, nor, occ, rd );\n\n        \/\/ combine lighting with material\t\t\n\t\tcol = mate * lin;\n\t\t\n        \/\/ fog\t\t\n        col = mix( col, vec3(0.9), 1.0-exp( -0.0002*t*t ) );\n\t}\n\t\n    \/\/ gamma correction\t\n\tcol = pow( col, vec3(0.4545) );\n\n\tcol *= smoothstep( 0.006, 0.008, abs(p.x-th) );\n\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}