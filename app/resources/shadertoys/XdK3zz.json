{"Shader":{"ver":"0.1","info":{"id":"XdK3zz","date":"1453156402","viewed":478,"name":"Minesweeper Game","username":"demofox","description":"A minesweeper game.  Click to reveal a square, F + click to toggle a flag.  Space to start a new game if you win or lose. Green = you won, red = you lost.","likes":20,"published":3,"flags":48,"tags":["2d","game","minesweeper"],"hasliked":0},"renderpass":[{"inputs":[{"id":47,"src":"\/presets\/tex19.png","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ the size in X and Y of our gameplay grid\nconst float c_gridSize = 16.0;\nconst float c_maxGridCell = c_gridSize - 1.0;\n\n\/\/ graphics values\n#define CELL_SHADE_MARGIN 0.1\n#define CELL_SHADE_DARK   0.4\n#define CELL_SHADE_MED    0.8\n#define CELL_SHADE_LIGHT  1.0\n#define CELL_SHADE_REVEAL 0.6\n#define CELL_SHADE_MARGIN_REVEALED 0.025\n\n\/\/ variables\nconst vec2 txState = vec2(2.0, c_gridSize);  \/\/ x = state. y = mouse button down last frame. zw unused\n\n\/\/============================================================\n\/\/ save\/load code from IQ's shader: https:\/\/www.shadertoy.com\/view\/MddGzf\n\nvec4 loadValue( in vec2 re )\n{\n    return texture2D( iChannel0, (0.5+re) \/ iChannelResolution[0].xy, -100.0 );\n}\n\n\/\/============================================================\nfloat SDFCircle( in vec2 coords, in vec3 circle )\n{\n    coords -= circle.xy;\n    float v = coords.x * coords.x + coords.y * coords.y;\n    vec2  g = vec2(circle.z * coords.x, circle.z * coords.y);\n    return abs(v)\/length(g); \n}\n\n\/\/============================================================\nvoid PixelToCell (in vec2 fragCoord, out vec2 uv, out vec2 cell, out vec2 cellFract)\n{\n    float aspectRatio = iResolution.x \/ iResolution.y;\n    uv = ((fragCoord.xy \/ iResolution.xy)  - vec2(0.25,0.05)) * 1.1;\n    uv.x *= aspectRatio;\n    cell = floor(uv * c_gridSize);\n    cellFract = fract(uv * c_gridSize);\n}\n\n\/\/============================================================\nvec3 BackgroundPixel (in vec2 uv)\n{\n    float distortX = sin(iGlobalTime * 0.6 + uv.x*5.124) * 0.03 + iGlobalTime*0.06;\n    float distortY = sin(iGlobalTime * 0.7 + uv.y*3.165) * 0.05 + iGlobalTime*0.04;\n    \n    vec2 offsetG = vec2(sin(iGlobalTime*1.534), cos(iGlobalTime*1.453)) * 10.0 \/ iChannelResolution[1].xy;\n    vec2 offsetB = vec2(sin(iGlobalTime*1.756), cos(iGlobalTime*1.381)) * 10.0 \/ iChannelResolution[1].xy;\n        \n   \tvec3 ret;    \n    ret.r = texture2D( iChannel1, uv + vec2(distortX, distortY) ).r;\n    ret.g = texture2D( iChannel1, uv + vec2(distortX, distortY) + offsetG ).r;\n    ret.b = texture2D( iChannel1, uv + vec2(distortX, distortY) + offsetB ).b;        \n    return ret;\n}\n\n\/\/============================================================\nvec3 HiddenTileColor (in vec2 cell, in vec2 cellFract, in vec2 mouseCell)\n{\n    float addMedium = clamp((1.0 - step(cellFract.x, CELL_SHADE_MARGIN)) * (1.0 - step(cellFract.y, CELL_SHADE_MARGIN)), 0.0, 1.0);\n    float addLight = clamp(step(1.0 - cellFract.x, CELL_SHADE_MARGIN) + step(1.0 - cellFract.y, CELL_SHADE_MARGIN), 0.0, 1.0);\n    addLight *= addMedium;\n   \n   \tfloat unClickedColor =\n        CELL_SHADE_DARK +\n        (CELL_SHADE_MED - CELL_SHADE_DARK) * addMedium +\n        (CELL_SHADE_LIGHT - CELL_SHADE_MED) * addLight;\n    \n    vec3 ret = vec3(unClickedColor);   \n    \n    if (cell == mouseCell)\n        ret.z = 0.0;\n    \n    return ret;\n}\n\n\/\/============================================================\nfloat OutsideCircle (in vec2 point, in vec3 circle)\n{\n    return length(point-circle.xy) > circle.z ? 1.0 : 0.0;\n}\n\n\/\/============================================================\nvec3 CountTileColor (in vec2 cellFract, float count)\n{\n    float color = CELL_SHADE_REVEAL;\n    \n    \/\/ if this is an odd number, put a dot in the center\n    if (mod(count,2.0) == 1.0)\n        color *= smoothstep(0.7,1.5,SDFCircle(cellFract, vec3(0.5,0.5,0.1)));\n        \/\/color *= OutsideCircle(cellFract, vec3(0.5,0.5,0.1));\n    \n    \/\/ if greater than or equal to two, put a dot in the lower left and upper right corner\n    if (count >= 2.0)\n    {\n        color *= smoothstep(0.7,1.5,SDFCircle(cellFract, vec3(0.25,0.25,0.1)));\n        color *= smoothstep(0.7,1.5,SDFCircle(cellFract, vec3(0.75,0.75,0.1)));\n    }\n    \n    \/\/ if greater than or equal to four, put a dot in the upper left and lower right corner\n    if (count >= 4.0)\n    {\n        color *= smoothstep(0.7,1.5,SDFCircle(cellFract, vec3(0.25,0.75,0.1)));\n        color *= smoothstep(0.7,1.5,SDFCircle(cellFract, vec3(0.75,0.25,0.1)));   \n    }\n    \n    \/\/ if greater than or equal to 6, put a dot on the left and right\n    if (count >= 6.0)\n    {\n        color *= smoothstep(0.7,1.5,SDFCircle(cellFract, vec3(0.25,0.5,0.1)));\n        color *= smoothstep(0.7,1.5,SDFCircle(cellFract, vec3(0.75,0.5,0.1)));          \n    }\n    \n    \/\/ if greater than or equal to 8, put a dot on the top and bottom\n   \tif (count >= 8.0)\n    {\n        color *= smoothstep(0.7,1.5,SDFCircle(cellFract, vec3(0.5,0.25,0.1)));\n        color *= smoothstep(0.7,1.5,SDFCircle(cellFract, vec3(0.5,0.75,0.1)));           \n    }\n    \n    if ((cellFract.x < CELL_SHADE_MARGIN_REVEALED) || (cellFract.y < CELL_SHADE_MARGIN_REVEALED) ||\n        ((1.0 - cellFract.x) < CELL_SHADE_MARGIN_REVEALED) || ((1.0 - cellFract.y) < CELL_SHADE_MARGIN_REVEALED))\n        color = CELL_SHADE_DARK;\n    \n    return vec3(color);\n}\n\n\/\/============================================================\nvec3 FlagColor (in vec2 cell, in vec2 cellFract, in vec2 mouseCell)\n{\n    vec3 pixel = HiddenTileColor(cell, cellFract, mouseCell);\n    \n    pixel.xz *= smoothstep(1.0,1.5,SDFCircle(cellFract, vec3(0.5,0.5,0.2)));\n    \n    return pixel;\n}\n\n\/\/============================================================\nvec3 BombColor (in vec2 cellFract)\n{\n    float shade = 0.0;\n    \n    shade += (1.0 - smoothstep(1.0,1.5,SDFCircle(cellFract, vec3(0.5,0.5,0.15))));\n    shade += (1.0 - smoothstep(1.0,1.5,SDFCircle(cellFract, vec3(0.3,0.3,0.1))));\n    shade += (1.0 - smoothstep(1.0,1.5,SDFCircle(cellFract, vec3(0.3,0.7,0.1))));\n    shade += (1.0 - smoothstep(1.0,1.5,SDFCircle(cellFract, vec3(0.7,0.3,0.1))));\n    shade += (1.0 - smoothstep(1.0,1.5,SDFCircle(cellFract, vec3(0.7,0.7,0.1))));\n    \n    return vec3(clamp(shade,0.0,1.0));\n}\n\n\/\/============================================================\nvec3 TileColor (in vec2 cell, in vec2 cellFract, vec4 cellData, vec2 mouseCell, bool gameOver)\n{\n    \/\/ on game over, we show all bombs\n    if (gameOver)\n    {\n        \/\/ if it's a bomb, show the bomb always\n        if (cellData.z == 1.0)\n            return BombColor(cellFract);\n        \/\/ else if it's unrevealed, show the unrevealed tile\n        else if (cellData.x == 0.0)\n\t\t\treturn HiddenTileColor(cell, cellFract, mouseCell);\n        \/\/ else show the number of bomb neighbors there are\n        else\n            return CountTileColor(cellFract, floor(cellData.y * 8.0));\n    }\n    \/\/ else we are playing normal so show everything\n    else\n    {\n        \/\/ if it's unrevealed\n        if (cellData.x == 0.0)\n        {\n            \/\/ if it's flagged, draw a flag\n            if (cellData.w == 1.0)\n                return FlagColor(cell, cellFract, mouseCell);\n            \/\/ else show a regular unrevealed tile\n            else\n                return HiddenTileColor(cell, cellFract, mouseCell);        \n        }\n        \/\/ else if it's revealed\n        else\n        {\n            \/\/ if it's a bomb, draw a bomb\n            if (cellData.z == 1.0)\n                return BombColor(cellFract);\n            \/\/ else draw how many neighbors are bombs\n            else\n                return CountTileColor(cellFract, floor(cellData.y * 8.0));\n        }\n    }\n}\n\n\/\/============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ load the game state variable\n    vec4 state = loadValue(txState);\n    \n    \/\/ calculate the cell data for this specific pixel\n    \/\/ draw the background if we are outside of the grid\n    vec2 uv, cell, cellFract;\n    PixelToCell(fragCoord, uv, cell, cellFract);\n    if (cell.x < 0.0 || cell.y < 0.0 || cell.x > c_maxGridCell || cell.y > c_maxGridCell)\n    {\n        fragColor = vec4(BackgroundPixel(uv), 1.0);\n        return;\n    }\n    \n    \/\/ calculate where the mouse is\n    vec2 mouseUv, mouseCell, mouseCellFract;\n    PixelToCell(iMouse.xy, mouseUv, mouseCell, mouseCellFract);\n    mouseCell *= iMouse.z > 0.0 ? 1.0 : -1.0;\n\t    \n    \/\/ get the data for the current cell\n    vec4 cellData = texture2D( iChannel0, (cell+0.5) \/ iChannelResolution[0].xy, -100.0 );\n    \n    \/\/ draw grid of cells\n    bool gameOver = state.x > 0.2;\n    vec3 pixelColor = TileColor(cell, cellFract, cellData, mouseCell, gameOver);\n    \n    \/\/ if we won, make everything green\n    if (state.x > 0.3)\n         pixelColor.xz = vec2(0.0);\n    \/\/ else if we lost, make everything red\n    else if (state.x > 0.2)\n        pixelColor.yz = vec2(0.0);\n\n    \n    \/\/ DEBUG: Visualize all game state\n    \/\/pixelColor = texture2D(iChannel0, uv).rbg;\n\n    \/\/ DEBUG: Visualize cell fractional offsets\n    \/\/pixelColor = vec3(cellFract, 0.0);\n    \n    \/\/ DEBUG: Visualize grid cells\n    \/\/pixelColor = vec3(cell \/ c_gridSize, 0.0);\n    \n    \/\/ DEBUG: visualize grid cell data    \n    \/\/pixelColor = cellData.rgb;\n    \n    fragColor = vec4(pixelColor, 1.0);\n}","name":"","description":"","type":"image"},{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ the size in X and Y of our gameplay grid\nconst float c_gridSize = 16.0;\nconst float c_maxGridCell = c_gridSize - 1.0;\nconst float c_numBombs = 32.0;  \/\/ on average, this many bombs will show up. could be more or less though.\nconst int c_gridChecksPerFrame = 16;\n\n\/\/ The grid representing the board\n\/\/ x = revealed (1.0) or not (0.0)\n\/\/ y = how many bombs are near it 0 to 8, normalized to 0..1\n\/\/ z = is a bomb (1.0) or not a bomb (0.0)\n\/\/ w = is a flag (1.0) or not a flag (0.0)\nconst vec4 txCells = vec4(0.0, 0.0, c_gridSize - 1.0, c_gridSize - 1.0);\n\n\/\/ other variables\nconst vec2 txState = vec2(2.0, c_gridSize);\n\/\/ x = state.\n\/\/ y = mouse button down last frame.\n\/\/ z,w = last cell checked for victory\n\n\/\/ keys\nconst float KEY_SPACE = 32.5\/256.0;\nconst float KEY_F = 70.5\/256.0;\n\n\/\/============================================================\n\n\/\/ save\/load code from IQ's shader: https:\/\/www.shadertoy.com\/view\/MddGzf\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nfloat isInside( vec2 p, vec4 c ) { vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y); }\n\nvec4 loadValue( in vec2 re )\n{\n    return texture2D( iChannel0, (0.5+re) \/ iChannelResolution[0].xy, -100.0 );\n}\n\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\nvoid storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\n\/\/============================================================\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\/\/============================================================\nvoid PixelToCell (in vec2 fragCoord, out vec2 uv, out vec2 cell, out vec2 cellFract)\n{\n    float aspectRatio = iResolution.x \/ iResolution.y;\n    uv = ((fragCoord.xy \/ iResolution.xy)  - vec2(0.25,0.05)) * 1.1;\n    uv.x *= aspectRatio;\n    cell = floor(uv * c_gridSize);\n    cellFract = fract(uv * c_gridSize);\n}\n\n\/\/============================================================\nvec4 GetCellData (in vec2 cell)\n{\n    if (cell.x >= 0.0 && cell.y >= 0.0 && cell.x <= c_maxGridCell && cell.y <= c_maxGridCell)\n        return texture2D( iChannel0, (cell + 0.5) \/ iChannelResolution[0].xy, -100.0 );\n    else\n        return vec4(0.0);\n}\n\n\/\/============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    if (fragCoord.x > c_gridSize || fragCoord.y > c_gridSize + 1.0)\n        discard;\n    \n    \/\/----- Load State -----\n    vec2 cell     = floor(fragCoord);  \n    \n    vec4 state    = loadValue(txState);\n    vec4 cellData = GetCellData(cell);\/\/loadValue(fragCoord.xy-0.5);\n    \n    \/\/ calculate the cell to check, from state.zw\n    vec2 cellCheck = floor(state.zw * c_maxGridCell);\n    \n    \/\/ get the neighboring cell data\n    vec4 cellDataUL = GetCellData(cell + vec2(-1.0,  1.0));\n    vec4 cellDataU  = GetCellData(cell + vec2( 0.0,  1.0));\n    vec4 cellDataUR = GetCellData(cell + vec2( 1.0,  1.0));\n    vec4 cellDataR  = GetCellData(cell + vec2( 1.0,  0.0));\n    vec4 cellDataDR = GetCellData(cell + vec2( 1.0, -1.0));\n    vec4 cellDataD  = GetCellData(cell + vec2( 0.0, -1.0));\n    vec4 cellDataDL = GetCellData(cell + vec2(-1.0, -1.0));\n    vec4 cellDataL  = GetCellData(cell + vec2(-1.0,  0.0));     \n    \n    \/\/ calculate where the mouse is\n    vec2 mouseUv, mouseCell, mouseCellFract;\n    PixelToCell(iMouse.xy, mouseUv, mouseCell, mouseCellFract);   \n    \n    \/\/ reset game state on first frame\n    if (iFrame == 0)\n        state = vec4(0.0);\n    \n    \/\/ state .0 -> reset game state\n    if (state.x < 0.1)\n    {\n        state.x = 0.1;\n        state.y = 0.0;\n        state.zw = vec2(0.0);\n        \n        \/\/ initialize all grid cells to unrevealed, zero neighbor bombs, not a bomb\n        cellData = vec4(0.0);\n        \n        \/\/ random up some bombs!\n        if (rand(cell+iGlobalTime) < c_numBombs \/ (c_gridSize*c_gridSize))\n            cellData.z = 1.0;\n    }\n   \t\/\/ state .1 -> set neighbor counts on grid\n    else if (state.x < 0.2)\n    {\n        state.x = 0.2;\n        float neighborBombs = \n            (cellDataUL.z > 0.0 ? 1.0 : 0.0) +\n            (cellDataU.z  > 0.0 ? 1.0 : 0.0) +\n            (cellDataUR.z > 0.0 ? 1.0 : 0.0) +\n            (cellDataR.z  > 0.0 ? 1.0 : 0.0) +\n            (cellDataDR.z > 0.0 ? 1.0 : 0.0) +\n            (cellDataD.z  > 0.0 ? 1.0 : 0.0) +\n            (cellDataDL.z > 0.0 ? 1.0 : 0.0) +\n            (cellDataL.z  > 0.0 ? 1.0 : 0.0);\n        \n        cellData.y = neighborBombs \/ 8.0;\n        \n        \/\/ DEBUG: visualize the numbers by uncommenting this\n\t\t\/\/cellData.y = clamp(cell.x \/ 8.0, 0.0, 1.0);\n    }\n   \t\/\/ state .2 -> we are playing!\n    else if (state.x < 0.3)\n    {\n        \/\/ if the mouse is down, remember that it is\n        if (iMouse.z > 0.0)\n        {\n            state.y = 1.0;     \n        }\n        \/\/ if it isn't down, it might have been last frame\n        else\n        {\n            \/\/ if the mouse was down last frame, we need to see about revealing a cell\n            \/\/ also remember that the mouse is not down now\n            if (state.y == 1.0)\n            {\n                \/\/ get the data for the cell under the mouse\n                vec4 mouseCellData = GetCellData(mouseCell); \n                                    \n                \/\/ if the user is pressing shift, they want to flag this cell\n                if (texture2D( iChannel1, vec2(KEY_F,0.25) ).x == 1.0)\n                {\n                    \/\/ toggle the cell as flagged\n                    if (cell == mouseCell)\n                        cellData.w = 1.0 - cellData.w;\n                }\n                \/\/ else if they want to reveal it and it isn't flagged (protect user)\n                else if (mouseCellData.w < 1.0)\n                {\n                    \/\/ reveal the cell\n                    if (cell == mouseCell)\n                        cellData.x = 1.0;\n\n                    \/\/ if they clicked on a bomb, die\n                    if (mouseCellData.z == 1.0)\n                        state.x = 0.3;                 \n                }                \n                \n                state.y = 0.0;\n            }\n        }\n        \n        \/\/ if the current cell we are processing is unrevealed\n        \/\/ and there are neighbors which have zero bomb neighbors but are revealed, reveal this\n        \/\/ cell too.\n        if (cellData.x == 0.0)\n        {\n            \/\/ if any of the neighbors are revealed zeros, then reveal this cell\n            if ((cellDataUL.x == 1.0 && cellDataUL.y == 0.0) ||\n                (cellDataU.x  == 1.0 && cellDataU.y  == 0.0) ||\n                (cellDataUR.x == 1.0 && cellDataUR.y == 0.0) ||\n                (cellDataR.x  == 1.0 && cellDataR.y  == 0.0) ||\n                (cellDataDR.x == 1.0 && cellDataDR.y == 0.0) ||\n                (cellDataD.x  == 1.0 && cellDataD.y  == 0.0) ||\n                (cellDataDL.x == 1.0 && cellDataDL.y == 0.0) ||\n                (cellDataL.x  == 1.0 && cellDataL.y  == 0.0))\n            {\n                cellData.x = 1.0;\n            }\n        }\n        \n        \/\/ check for victory by scanning cells to find any unrevealed cells that aren't bombs.\n        for (int i = 0; i < c_gridChecksPerFrame; ++i)\n        {\n            if (cellCheck.x == c_maxGridCell)\n            {\n                cellCheck.x = 0.0;\n                if (cellCheck.y == c_maxGridCell)\n                {\n                    \/\/ Victory!\n                    cellCheck.y = 0.0;\n                    state.x = 0.4;\n                    break;\n                }\n                else\n                {\n                    cellCheck.y = cellCheck.y + 1.0;\n                }\n            }\n            else\n            {\n                cellCheck.x = cellCheck.x + 1.0;\n            }\n\n            \/\/ if the cell we are checking is unrevealed, and not a bomb, start our scan over, they haven't won yet.\n            vec4 cellCheckData = GetCellData(cellCheck);\n            if (cellCheckData.x == 0.0 && cellCheckData.z == 0.0)\n            {\n                cellCheck = vec2(0.0);\n                break;\n            }\n        }\n        \n    }\n   \t\/\/ state .3 -> we lost\n\t\/\/ state .4 -> we won\n    else\n    {\n        \/\/ reset when user presses space\n        if (texture2D( iChannel1, vec2(KEY_SPACE,0.25) ).x == 1.0)\n        \tstate.x = 0.0; \n    }\n            \n\t\/\/ convert cellCheck back into state.zw\n    state.zw = cellCheck \/ c_maxGridCell;\n    \n    \/\/----- Save State -----\n    fragColor = vec4(0.0);\n    storeValue(txState, state   , fragColor, fragCoord);\n    storeValue(txCells, cellData, fragColor, fragCoord);\n}\n","name":"","description":"","type":"buffer"}]}}