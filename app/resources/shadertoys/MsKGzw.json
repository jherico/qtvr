{"Shader":{"ver":"0.1","info":{"id":"MsKGzw","date":"1453821436","viewed":237,"name":"Polyhedras with control","username":"knighty","description":"just regular polyhedra with controls from <a href=\"https:\/\/www.shadertoy.com\/view\/MdKGRw\"  class=\"regular\" target=\"_blank\">here<\/a>.<br\/>Sliders are left to right: U, V, W, Type.","likes":19,"published":3,"flags":32,"tags":["polyhedra"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ --- sliders and mouse widgets -------------------------------------------\n\nvec2 R = iResolution.xy;\n#define UI(x) texture2D(iChannel0,(vec2(x,0)+.5)\/R)\n#define Swidth  .004\n#define Sradius .02\n#define Bradius .04\n#define Mradius .02\n\nvec4 affMouse(vec2 uv)  { \/\/ display mouse states ( color )\n    vec4 mouse = UI(33);                       \/\/ current mouse pos\n    float k = length(mouse.xy\/R.y-uv)\/Mradius,\n          s = sign(mouse.z);\n\tif (k<1.) \n\t    if (k>.8) return vec4(1e-10);\n\t\t   else   return vec4(s,1.-s,0,1); \n\t\n    k = length( UI(34).xy\/R.y-uv)\/Mradius;     \/\/ prev mouse pos \n\tif (k<1.) \n\t    if (k>.8) return vec4(1e-10);\n\t\t   else   return vec4(0,0,1,1); \n            \n    k = length(abs(mouse.zw)\/R.y-uv)\/Mradius;  \/\/ drag start  mouse pos \n\tif (k<1.) \n\t    if (k>.8) return vec4(1e-10);\n\t\t   else   return vec4(0,.4,s,1); \n\t\n\treturn vec4(0);\n}\n\nfloat aff_sliders(vec2 U) { \/\/ display sliders ( grey level or 0.)\n    for (float i=0.; i<16.; i++) {\n        if (i>=UI(0).x) break;\n        vec4 S = UI(i+1.);\n        float l = abs(S.z);\n        if (S.z>0. && abs(U.y-S.y)<Swidth && abs(U.x-S.x-l\/2.)<l\/2. ) return 1.;\n        if (S.z<0. && abs(U.x-S.x)<Swidth && abs(U.y-S.y-l\/2.)<l\/2. ) return 1.;\n        if (S.z>0. && length(U-S.xy-vec2(S.a*l,0))<Sradius ) return 1.;\n        if (S.z<0. && length(U-S.xy-vec2(0,S.a*l))<Sradius ) return 1.;\n    }\n    return 0.;       \n}\n\nfloat aff_buttons(vec2 U) { \/\/ display buttons ( grey level or 0.)\n    for (float i=0.; i<16.; i++) {\n        if (i>=UI(0).y) break;\n        vec4 S = UI(i+17.);\n        float l = length(U-S.xy);\n        if (l < Bradius) \n            if (S.a>0.) return 1.; \n            else return .3+smoothstep(.7,1.,l\/Bradius);\n    }\n    return 0.;\n}        \n\n\/\/------------------------------------------------------------------------------------\n#define PI\t3.14159265359\n#define PI2\t( PI * 2.0 )\n\nbool Fdisp = true;\nbool Sdisp = true;\nbool Vdisp = true;\n\nint Type=3;\nfloat U=0.,V=0.,W=1.;\nfloat SRadius=0.03, VRadius=0.07;\n\nvec3 nc,p,pab,pbc,pca;\nvoid init() {\/\/setup folding planes and vertex\n\tfloat t=iGlobalTime;\n    Type=int(fract(UI(4).a)*3.)+3;\n    U=UI(1).a;\/\/0.5*sin(t*1.5)+0.5;\n    V=UI(2).a;\/\/0.5*sin(t*0.8)+0.5;\n    W=UI(3).a;\/\/0.5*sin(t*0.3)+0.5;\n    Fdisp = UI(17).a < 0.;\n    Sdisp = UI(18).a < 0.;\n    Vdisp = UI(19).a < 0.;\n    float cospin=cos(PI\/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n\tnc=vec3(-0.5,-cospin,scospin);\/\/3rd folding plane. The two others are xz and yz planes\n\tpab=vec3(0.,0.,1.);\n\tpbc=vec3(scospin,0.,0.5);\/\/No normalization in order to have 'barycentric' coordinates work evenly\n\tpca=vec3(0.,scospin,cospin);\n\tp=normalize((U*pab+V*pbc+W*pca));\/\/U,V and W are the 'barycentric' coordinates (coted barycentric word because I'm not sure if they are really barycentric... have to check)\n\tpbc=normalize(pbc);\tpca=normalize(pca);\/\/for slightly better DE. In reality it's not necesary to apply normalization :) \n}\n\nvec3 fold(vec3 pos) {\n\tfor(int i=0;i<5 \/*Type*\/;i++){\n\t\tpos.xy=abs(pos.xy);\/\/fold about xz and yz planes\n\t\tpos-=2.*min(0.,dot(pos,nc))*nc;\/\/fold about nc plane\n\t}\n\treturn pos;\n}\n\nfloat D2Planes(vec3 pos) {\/\/distance to the 3 faces\n\tpos-=p;\n    float d0=dot(pos,pab);\n\tfloat d1=dot(pos,pbc);\n\tfloat d2=dot(pos,pca);\n\treturn max(max(d0,d1),d2);\n}\n\nfloat length2(vec3 p){ return dot(p,p);}\n\nfloat D2Segments(vec3 pos) {\n\tpos-=p;\n\tfloat dla=length2(pos-min(0.,pos.x)*vec3(1.,0.,0.));\n\tfloat dlb=length2(pos-min(0.,pos.y)*vec3(0.,1.,0.));\n\tfloat dlc=length2(pos-min(0.,dot(pos,nc))*nc);\n\treturn sqrt(min(min(dla,dlb),dlc))-SRadius;\n}\n\nfloat D2Vertices(vec3 pos) {\n\treturn length(pos-p)-VRadius;\n}\n\nfloat Polyhedron(vec3 pos) {\n\tpos=fold(pos);\n\tfloat d=10000.;\n\tif(Fdisp) d=min(d,D2Planes(pos));\n\tif(Sdisp) d=min(d,D2Segments(pos));\n\tif(Vdisp)  d=min(d,D2Vertices(pos));\n\treturn d;\n}\n\nvec3 getColor(vec3 pos){\/\/Not optimized.\n#define Face0Color vec3(.8,0.3,0.);\n#define Face1Color vec3(0.15,0.7,0.1);\n#define Face2Color vec3(0.05,0.6,1.);\n#define SegmentsColor vec3(0.2,0.2,0.8);\n#define VerticesColor vec3(1.,.2,.15);\n\tpos=fold(pos);\n\tfloat d0=1000.0,d1=1000.0,d2=1000.,df=1000.,dv=1000.,ds=1000.;\n\tif(Fdisp){\n\t\td0=dot(pos-p,pab);\n\t\td1=dot(pos-p,pbc);\n\t\td2=dot(pos-p,pca);\n\t\tdf=max(max(d0,d1),d2);\n\t}\n\tif(Sdisp) ds=D2Segments(pos);\n\tif(Vdisp) dv=D2Vertices(pos);\n\tfloat d=min(df,min(ds,dv));\n\tvec3 col=Face0Color;\n\tif(d==df){\n\t\tif(d==d1) col=Face1Color;\n\t\tif(d==d2) col=Face2Color;\n\t}else{\n\t\tif(d==ds) col=SegmentsColor;\n\t\tif(d==dv) col=VerticesColor;\n\t}\n\treturn col;\n}\n\/\/-------------------------------------------------\n\/\/From https:\/\/www.shadertoy.com\/view\/XtXGRS#\nvec2 rotate(in vec2 p, in float t)\n{\n\treturn p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nfloat map(in vec3 p)\n{\n    \/\/return length(p)-1.;\n\treturn mix(length(p)-1.,Polyhedron(p),UI(5).a);\/\/just for fun\n}\n\nvec3 calcNormal(in vec3 p)\n{\n\tconst vec2 e = vec2(0.0001, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy) - map(p - e.xyy),\n\t\tmap(p + e.yxy) - map(p - e.yxy),\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 5.0;\n\tconst float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for(int i = 0; i < 128; i++)\n    {\n        if(h < precis*t || t > maxd) break;\n\t    h = map(ro + rd * t);\n        t += h;\n    }\n    if(t < maxd) res = t;\n    return res;\n}\n\nvec3 transform(in vec3 p)\n{\n    vec4 mouse = UI(35);\/\/R.y;\n    \/\/mouse.xy = clamp(mouse.xy, vec2(-180.,-90.), vec2(180.,90.));\n    \n    p.zx = rotate(p.zx, iGlobalTime * 0. - (mouse.x)*PI\/360.);\n    p.yz = rotate(p.yz, iGlobalTime * 0. + (mouse.y)*PI\/360.);\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy\/R.y;\n    \/\/vec4 mouse = UI(33)\/R.y;\n    \n\t\/\/ display sliders and buttons \n\t{ float s = aff_sliders(uv); if (s>0.) { fragColor = s*vec4(1,.2,0,1); return;}}\n    { float s = aff_buttons(uv); if (s>0.) { fragColor = s*vec4(0,.2,1,1); return;}}\n    \n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) \/ iResolution.y;\n\tvec3 col = vec3(0.3 + p.y * 0.1);\n   \tvec3 rd = normalize(vec3(p, -1.8));\n\tvec3 ro = vec3(0.0, 0.0, 2.5);\n    vec3 li = normalize(vec3(0.5, 0.8, 3.0));\n    ro = transform(ro);\n\trd = transform(rd);\n\tli = transform(li);\n    init();\n    float t = march(ro, rd);\n    if(t > -0.001)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 n = calcNormal(pos);\n\t\tfloat dif = clamp(dot(n, li), 0.0, 1.0);\n        col = getColor(pos) * dif + .5*pow(dif, 200.);\n        col = pow(col, vec3(0.45));\n\t}\n   \tfragColor = vec4(col, 1.0);\n}","name":"","description":"","type":"image"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/By FabriceNeyret2: https:\/\/www.shadertoy.com\/view\/MdKGRw\n\/\/With some modifications\n\n\/\/ only line 0, pixels 0 to 33 of bufA are used\n\/\/ if you need the full buffer but the .a components, you might adapt this util to use only .a \n\n#define FAKE_MOUSE 1 \/\/ fake mouse motion if no user input\n#define Sradius .02  \/\/ influence radius for sliders\n#define Bradius .04  \/\/ influence radius for buttons\n\n#define HORIZ   1.\n#define VERTIC -1.\n\n\nvec2 R = iResolution.xy;\n#define UI(x) texture2D(iChannel0,(vec2(x,0)+.5)\/R)\n\n#define add_slider(x,y,d,l,v0) { nbS++; if (U==vec2(nbS,0.))    O = vec4(x,y,(l)*(d),v0); }\n#define add_button(x,y,v0)     { nbB++; if (U==vec2(nbB+16,0.)) O = vec4(x,y,0,v0);       }\n\nbool insideSlider(vec2 U, vec4 S){\n        float l = abs(S.z);\n        if (S.z>0. && abs(U.y-S.y)<Sradius && abs(U.x-S.x-l\/2.)<l\/2. ) return true;\n        if (S.z<0. && abs(U.x-S.x)<Sradius && abs(U.y-S.y-l\/2.)<l\/2. ) return true;\n        if (S.z>0. && length(U-S.xy-vec2(S.a*l,0))<Sradius ) return true;\n        if (S.z<0. && length(U-S.xy-vec2(0,S.a*l))<Sradius ) return true;\n    return false;       \n}\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    O = texture2D(iChannel0,U\/R);\n    U -= .5;\n    \n    if (iFrame==0) {\n        int nbS = 0, nbB = 0;\n        \n        add_slider (.05,.05,VERTIC,.5,.0); \/\/ --- define your sliders here ---\n        add_slider (.10,.05,VERTIC,.5,.99); \/\/ read value [0,1] in UI(i).a  , i=1..16\n        add_slider (.15,.05,VERTIC,.5,.0);\n        add_slider (.20,.05,VERTIC,.5,.99);\n        add_slider (.25,.05,VERTIC,.5,.99);\n        \n        add_button ( .05,.95, -1.);          \/\/ --- define your buttons here ---\n        add_button ( .15,.95, -1.);          \/\/ read value {-1,1} in UI(i+16).a , i=1..16\n        add_button ( .25,.95, -1.);          \n        \/*add_button ( 1.,.1, -1.);          *\/\n        \n        if (U==vec2(0,0)) O = vec4(nbS, nbB, 0., 0.);\n        if (U==vec2(35,0)) O = vec4(0.);\n        return;\n    }\n    \n    if (U==vec2(33,0)) {  \/\/ previous mouse state (for BufA) our mouse state (other shaders)\n        vec4 m = iMouse;\n#if FAKE_MOUSE\n        if (length(m.xy)==0. && m.z<=0.) { \/\/ fake mouse motion if no user input\n\t        float t = iGlobalTime;         \/\/ you can reset this state by putting the mouse back in the corner\n\t        m.xy = (.5+.4*vec2(cos(t),sin(t)))*R;\n\t    }   \n#endif\n        O = m;\n        return; \n    }              \n    \n    if (U==vec2(34,0)) { O = UI(33); return; } \/\/ previous mouse state (for other shaders)\n    \n    if (U==vec2(35,0)){\n        if(iMouse.z\/iResolution.y > 0.3) O.xy = O.zw + iMouse.xy - iMouse.zw;\n        else O = O.xyxy;\n        return;\n    }\n    \n    if (iMouse.z>0. && U.y==0.) {          \/\/ --- let mouse trigers the right slider or button\n       \tvec4 M = iMouse\/iResolution.y;\n        if (U.x <= UI(0).x) {\n\t        vec4 S = UI(U.x);\n            if(insideSlider(M.zw, S)){\n    \t    \tfloat l = abs(S.z);\n\t        \tif (S.z>0. ) O.a = clamp((M.x-S.x)\/l,0.,1.);\n    \t    \tif (S.z<0. ) O.a = clamp((M.y-S.y)\/l,0.,1.);\n            }\n    \t}\n        else if (UI(33).z<0. &&  U.x>16. && U.x<=16.+UI(0).y ) {\n\t        vec4 S = UI(U.x);\n            if (length(M.xy-S.xy)<Bradius) O.a *= -1.;\n        }\n    }\n        \n}","name":"","description":"","type":"buffer"}]}}