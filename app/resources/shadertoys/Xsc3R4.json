{"Shader":{"ver":"0.1","info":{"id":"Xsc3R4","date":"1448283909","viewed":707,"name":"Cheap Cloud Flythrough","username":"Shane","description":"This is an attempt to give the impression of a cloud flythrough, whilst maintaining a reasonably acceptable framerate.","likes":44,"published":3,"flags":0,"tags":["noise","cloud","volumetric","sinusoidal","flythrough"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/*\n\n\tCheap Cloud Flythrough \n\t----------------------\n\t\n\t\"Cheap\" should probably refer to the quality of the physics in this shader, which is\n\tvirtually non existent, but it actually refers to the fake cloud algorithm... if you could \n\tcall it that. :)\n\t\n\tThis is merely an attempt to give the impression of a cloud flythrough, whilst maintaining\t\n\ta reasonably acceptable framerate. The key to that is keeping the distance field as simple \n\tas possible.\n\n\tDue to the amount of cost cutting, it's far from  perfect. However, there's still plenty \n\tof room for improvement.\n\n    I've used density based accumulation, which in one way or another, uses concepts from many \n\tvolumetric examples, but particularly from the following:\n\t\n\tCloudy Spikeball - Duke\n    https:\/\/www.shadertoy.com\/view\/MljXDw\n    \/\/ Port from a demo by Las - Worth watching.\n    \/\/ http:\/\/www.pouet.net\/topic.php?which=7920&page=29&x=14&y=9\n    \n    Other shaders worth looking at:\n\n\tClouds - IQ: One of my favorite shaders, and everyone elses, it seems.\n\thttps:\/\/www.shadertoy.com\/view\/XslGRr\n\t\t\n\tSample Pinning - huwb: Fast, and pretty.\n\thttps:\/\/www.shadertoy.com\/view\/XdfXzn\n\t\n\tFakeVolumetricClouds - Kuvkar: Fast, using parallax layers. Really cool.\n\thttps:\/\/www.shadertoy.com\/view\/XlsXzN\n\n    Emission clouds - Duke: Nice, and straight forward.\n    https:\/\/www.shadertoy.com\/view\/ltBXDm\n\n\n*\/\n\n\/\/ Hash function. This particular one probably doesn't disperse things quite \n\/\/ as nicely as some of the others around, but it's compact, and seems to work.\n\/\/\nvec3 hash33(vec3 p){ \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n\n\/\/ IQ's texture lookup noise... in obfuscated form. There's less writing, so\n\/\/ that makes it faster. That's how optimization works, right? :) Seriously,\n\/\/ though, refer to IQ's original for the proper function.\n\/\/ \n\/\/ By the way, you could replace this with the non-textured version, and the\n\/\/ shader should run at almost the same efficiency.\nfloat pn( in vec3 p ){\n    \n    vec3 i = floor(p); p -= i; p *= p*(3. - 2.*p);\n\tp.xy = texture2D(iChannel0, (p.xy + i.xy + vec2(37, 17)*i.z + .5)\/256., -100.).yx;\n\treturn mix(p.x, p.y, p.z);\n}\n\n\n\n\/\/ Basic low quality noise consisting of three layers of rotated, mutated \n\/\/ trigonometric functions. Needs work, but sufficient for this example.\nfloat trigNoise3D(in vec3 p){\n\n    \n    float res = 0., sum = 0.;\n    \n    \/\/ IQ's cheap, texture-lookup noise function. Very efficient, but still \n    \/\/ a little too processor intensive for multiple layer usage in a largish \n    \/\/ \"for loop\" setup. Therefore, just one layer is being used here.\n    float n = pn(p*8. + iGlobalTime*2.);\n\n\n    \/\/ Two sinusoidal layers. I'm pretty sure you could get rid of one of \n    \/\/ the swizzles (I have a feeling the GPU doesn't like them as much), \n    \/\/ which I'll try to do later.\n    \n    vec3 t = sin(p.yzx*3.14159265 + cos(p.zxy*3.14159265+1.57\/2.))*0.5 + 0.5;\n    p = p*1.5 + (t - 1.5); \/\/  + iGlobalTime*0.1\n    res += (dot(t, vec3(0.333)));\n\n    t = sin(p.yzx*3.14159265 + cos(p.zxy*3.14159265+1.57\/2.))*0.5 + 0.5;\n    res += (dot(t, vec3(0.333)))*0.7071;    \n\t \n\treturn ((res\/1.7071))*0.85 + n*0.15;\n}\n\n\/\/ Distance function.\nfloat map(vec3 p) {\n\n    return trigNoise3D(p*0.5);\n    \n    \/\/ Three layers of noise, for comparison.\n    \/\/p += iGlobalTime;\n    \/\/return pn(p*.75)*0.57 + pn(p*1.875)*0.28 + pn(p*4.6875)*0.15;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\n    \/\/ Unit direction ray vector: Note the absence of a divide term. I came across\n    \/\/ this via a comment Shadertoy user \"coyote\" made. I'm pretty easy to please,\n    \/\/ but I thought it was pretty cool.\n    vec3 rd = normalize(vec3(fragCoord.xy - iResolution.xy*.5, iResolution.y*0.75)); \n\n    \/\/ Ray origin. Moving along the Z-axis.\n    vec3 ro = vec3(0., 0. , iGlobalTime*4.);\n\n    \/\/ Cheap camera rotation.\n    \/\/\n    \/\/ 2D rotation matrix. Note the absence of a cos variable. It's there, but in disguise.\n    \/\/ This one came courtesy of Shadertoy user, \"Fabrice Neyret.\"\n    vec2 a = sin(vec2(1.5707963, 0) + iGlobalTime*0.1875); \n    mat2 rM = mat2(a, -a.y, a.x);\n    rd.xy = rd.xy*rM; \/\/ Apparently, \"rd.xy *= rM\" doesn't work on some setups. Crazy.\n    rd.xz = rd.xz*rM;\n\n    \/\/ Placing a light in front of the viewer and up a little, then rotating it in sync\n    \/\/ with the camera. I guess a light beam from a flying vehicle would do this.\n    vec3 lp = vec3( 0., 1., 4. );\n    lp.xy = lp.xy*rM;\n    lp.xz = lp.xz*rM;\n    lp += ro;\n\n    \/\/ The ray is effectively marching through discontinuous slices of noise, so at certain\n    \/\/ angles, you can see the seperation. A bit of randomization can mask that, to a degree.\n    \/\/ At the end of the day, it's not a perfect process. Note, the ray is deliberately left \n    \/\/ unnormalized... if that's a word.\n    \/\/\n    \/\/ Randomizing the direction.\n    rd = (rd + (hash33(rd.zyx)*0.006-0.003)); \n    \/\/ Randomizing the length also. \n    rd *= (1. + fract(sin(dot(vec3(7, 157, 113), rd.zyx))*43758.5453)*0.06-0.03);      \n\n    \/\/ Local density, total density, and weighting factor.\n    float ld=0., td=0., w=0.;\n\n    \/\/ Closest surface distance, and total ray distance travelled.\n    float d=1., t=0.;\n\n    \/\/ Distance threshold. Higher numbers give thicker clouds, but fill up the screen too much.    \n    const float h = .5;\n\n\n    \/\/ Initializeing the scene color to black, and declaring the surface position vector.\n    vec3 col = vec3(0), sp;\n\n\n\n    \/\/ Particle surface normal.\n    \/\/\n    \/\/ Here's my hacky reasoning. I'd imagine you're going to hit the particle front on, so the normal\n    \/\/ would just be the opposite of the unit direction ray. However particles are particles, so there'd\n    \/\/ be some randomness attached... Yeah, I'm not buying it either. :)\n    vec3 sn = normalize(hash33(rd.yxz)*.03-rd);\n\n    \/\/ Raymarching loop.\n    for (int i=0; i<64; i++) {\n\n        \/\/ Loop break conditions. Seems to work, but let me\n        \/\/ know if I've overlooked something.\n        if((td>1.) || d<0.001*t || t>80.)break;\n\n\n        sp = ro + rd*t; \/\/ Current ray position.\n        d = map(sp); \/\/ Closest distance to the surface... particle.\n\n        \/\/ If we get within a certain distance, \"h,\" of the surface, accumulate some surface values.\n        \/\/ The \"step\" function is a branchless way to do an if statement, in case you're wondering.\n        \/\/\n        \/\/ Values further away have less influence on the total. When you accumulate layers, you'll\n        \/\/ usually need some kind of weighting algorithm based on some identifying factor - in this\n        \/\/ case, it's distance. This is one of many ways to do it. In fact, you'll see variations on \n        \/\/ the following lines all over the place.\n        \/\/\n        ld = (h - d) * step(d, h); \n        w = (1. - td) * ld;   \n\n        \/\/ Use the weighting factor to accumulate density. How you do this is up to you. \n        td += w*w*8. + 1.\/60.; \/\/w*w*5. + 1.\/50.;\n        \/\/td += w*.4 + 1.\/45.; \/\/ Looks cleaner, but a little washed out.\n\n\n        \/\/ Point light calculations.\n        vec3 ld = lp-sp; \/\/ Direction vector from the surface to the light position.\n        float lDist = max(length(ld), 0.001); \/\/ Distance from the surface to the light.\n        ld\/=lDist; \/\/ Normalizing the directional light vector.\n\n        \/\/ Using the light distance to perform some falloff.\n        float atten = 1.\/(1. + lDist*0.125 + lDist*lDist*0.05);\n\n        \/\/ Ok, these don't entirely correlate with tracing through transparent particles,\n        \/\/ but they add a little anglular based highlighting in order to fake proper lighting...\n        \/\/ if that makes any sense. I wouldn't be surprised if the specular term isn't needed,\n        \/\/ or could be taken outside the loop.\n        float diff = max(dot( sn, ld ), 0.);\n        float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0. ), 4.);\n\n\n        \/\/ Accumulating the color. Note that I'm only adding a scalar value, in this case,\n        \/\/ but you can add color combinations.\n        col += w*(1.+diff*.5+spec*.5)*atten;\n\n        \/\/ Try this instead, to see what it looks like without the fake contrasting. Obviously,\n        \/\/ much faster.\n        \/\/col += w*atten*1.25;\n\n\n        \/\/ Enforce minimum stepsize. This is probably the most important part of the procedure.\n        \/\/ It reminds me a little of of the soft shadows routine.\n        t +=  max(d * 0.5, 0.02); \/\/\n        \/\/ t += 0.2; \/\/ t += d*0.5;\/\/ These also work, but don't seem as efficient.\n\n    }\n\n    col = min(col, 1.);\n\n    \/\/ trigNoise3D(rd*1.)\n    col = mix(vec3(min(col.x*1.5, 1.),  pow(col.x, 2.5), pow(col.x, 12.)), col, dot(cos(rd*6. +sin(rd.yzx*6.)), vec3(.333))*.25+.75);\n    col = mix(col.zyx, col, dot(cos(rd*9. +sin(rd.yzx*9.)), vec3(.333))*.15+.85);\/\/xzy\n\n    \/\/col = mix(col.zyx, col, dot(rd, vec3(.5))+.5);\n\n    fragColor = vec4(col, 1.0);\n}","name":"","description":"","type":"image"}]}}