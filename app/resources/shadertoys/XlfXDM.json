{"Shader":{"ver":"0.1","info":{"id":"XlfXDM","date":"1437051863","viewed":1200,"name":"Ray Marching Experiment 29","username":"aiekick","description":"based on pattern from 104 shader https:\/\/www.shadertoy.com\/view\/ltlSW4  displaced on ball<br\/>you can comment line 4 il you want unlimited dispalce from 0 to 1.<br\/>Mouse Axis X => Grow Up\/Down \/\/ Mouse Axis Y => Density from 0 to 100.","likes":29,"published":3,"flags":0,"tags":["ray","experiment","marching","29"],"hasliked":0},"renderpass":[{"inputs":[{"id":27,"src":"\/presets\/cube05_0.png","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Stephane Cuillerdier - Aiekick\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define limited_displace\n\nfloat dstepf = 0.0;\n    \nconst vec2 RMPrec = vec2(0.2, 0.05); \nconst vec3 DPrec = vec3(1e-3, 12., 1e-8); \n\nvec2 Params; \/\/ x => ratio, y => Density\n\nvec4 map(vec3 p)\n{\n\t\/\/ pattern based on 104 shader https:\/\/www.shadertoy.com\/view\/ltlSW4 \n    vec4 col = vec4(p,1);\n    vec2 i = col.xz*Params.y;\n    i=i\/col.y+iGlobalTime;\n    i-=col.xy=ceil(i+=i.x*=.577);\n    col.xy+=step(1.,col.z=mod(col.x+col.y,3.))-step(2.,col.z)*step(i,i.yx);\n    col.z=0.;\n    col=.5+.5*sin(col);\n    \n    dstepf += 0.015;\n\n    float disp;\n    \n    #ifdef limited_displace\n    \tdisp = dot(col.rgb,vec3(Params.x));\n    #else\n    \tdisp = dot(col,vec4(Params.x));\n    #endif               \n                         \n    float dist = length(p) -4. + smoothstep(0., 1., disp);\n    \n    return vec4(dist, col.rgb);\n}\n\nvec3 nor( vec3 pos, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n    map(pos+e.xyy).x - map(pos-e.xyy).x,\n    map(pos+e.yxy).x - map(pos-e.yxy).x,\n    map(pos+e.yyx).x - map(pos-e.yyx).x );\n    return normalize(n);\n}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cu, vec3 cv)\n{\n\tvec3 rov = normalize(cv-ro);\n    vec3 u =  normalize(cross(cu, rov));\n    vec3 v =  normalize(cross(rov, u));\n    vec3 rd = normalize(rov + u*uv.x + v*uv.y);\n    return rd;\n}\n\nvoid mainImage( out vec4 f, in vec2 g )\n{\n    vec2 si = iResolution.xy;\n   \tfloat t = iGlobalTime;\n    Params.x = sin(t*.5)*.5+.5;\n    Params.y = 10.;\n    if (iMouse.z>0.) Params = iMouse.xy \/ si * vec2(1., 100.);\n    f = vec4(0.);\n    float ca = t*.2; \/\/ angle z\n    float ce = 4.7; \/\/ elevation\n    float cd = 0.5; \/\/ distance to origin axis\n    vec3 cu=vec3(0,1,0);\/\/Change camere up vector here\n    vec3 cv=vec3(0,0,0); \/\/Change camere view here\n    float refl_i = .6; \/\/ reflexion intensity\n    float refr_a = 1.2; \/\/ refraction angle\n    float refr_i = .8; \/\/ refraction intensity\n    float bii = 0.6; \/\/ bright init intensity\n    vec2 uv = (g+g-si)\/min(si.x, si.y);\n    vec3 ro = vec3(sin(ca)*cd, ce+1., cos(ca)*cd); \/\/\n    vec3 rd = cam(uv, ro, cu, cv);\n    float b = bii;\n    vec3 d = vec3(0.);\n    vec3 p = ro+rd*d.x;\n    float s = DPrec.y;\n    float rmd = sign(map(p).x);\n    for(int i=0;i<1000;i++)\n    {      \n\t\tif(s<DPrec.x||s>DPrec.y) break;\n        s = map(p).x*(s>DPrec.x?RMPrec.x:RMPrec.y);\n        if (sign(s) != rmd) break;\n        d.y = d.x;\n        d.x += s;\n        p = ro+rd*d.x;\n   \t}\n\n    float countIter = 0.;\n    if (sign(s) == rmd)\n    {\n    \tp = ro+rd*d.x;\n        rmd = map(p).x;\n        for (int i = 0; i < 20; i++)\n        {\n        \tcountIter += 10.;\n            d.z = (d.x + d.y)*.5;\n            p = ro+rd*d.z;\n            s = map(p).x*RMPrec.y;\n            d.x += abs(s);\n            if (abs(s) < DPrec.z)break;\n            (d.x*rmd < 0. )? (d.x = d.z ): (d.y = d.z);\n       \t}\n        d.x = (d.x+d.y) * .5;\n   \t}\n\n    f += pow(b,15.);\n    \n    if (d.x<DPrec.y)\n    {\n    \tfloat nPrec = 10.\/countIter;\n        vec3 n = nor(p, nPrec);\n        vec3 ray = reflect(rd, n);\n        f += textureCube(iChannel0, ray) * refl_i; \n        ray = refract(rd, n, refr_a);\n        f += textureCube(iChannel0, rd) * refr_i; \n        f.rgb = mix( f.rgb, map(p).yzw,0.5);                \n   \t}\n    else\n    {\n    \tf = textureCube(iChannel0, rd);\n    }\n\n    f *= dstepf;\n}\n\n","name":"","description":"","type":"image"}]}}