{"Shader":{"ver":"0.1","info":{"id":"MsKGRW","date":"1453528405","viewed":115,"name":"Branchless RGB to HSL ","username":"poljere","description":"Comparison between branchless RGB to HSL implementation vs branched RGB to HSL conversion. This branchless version just intends to remove branches by keeping parity with the results obtained from the branched version.","likes":2,"published":3,"flags":0,"tags":["2d","rgb","branchless","hsl","colorspace","rgb2hsl","hsl2rgb"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Pol Jeremias - poljere\/2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nvec3 rgb2hsl( in vec3 c )\n{\n    const float epsilon = 0.00000001;\n    float cmin = min( c.r, min( c.g, c.b ) );\n    float cmax = max( c.r, max( c.g, c.b ) );\n\tfloat cd   = cmax - cmin;\n    vec3 hsl = vec3(0.0);\n    hsl.z = (cmax + cmin) \/ 2.0;\n    hsl.y = mix(cd \/ (cmax + cmin + epsilon), cd \/ (epsilon + 2.0 - (cmax + cmin)), step(0.5, hsl.z));\n    \n    \/\/ Special handling for the case of 2 components being equal and max at the same time,\n    \/\/ this can probably be improved but it is a nice proof of concept\n    vec3 a = vec3(1.0 - step(epsilon, abs(cmax - c)));\n    a = mix(vec3(a.x, 0.0, a.z), a, step(0.5, 2.0 - a.x - a.y));\n    a = mix(vec3(a.x, a.y, 0.0), a, step(0.5, 2.0 - a.x - a.z));\n    a = mix(vec3(a.x, a.y, 0.0), a, step(0.5, 2.0 - a.y - a.z));\n    \n    hsl.x = dot( vec3(0.0, 2.0, 4.0) + ((c.gbr - c.brg) \/ (epsilon + cd)), a );\n    hsl.x = (hsl.x + (1.0 - step(0.0, hsl.x) ) * 6.0 ) \/ 6.0;\n    return hsl;\n}\n\nvec3 rgb2hsl_branches( in vec3 c )\n{\n    const float epsilon = 0.00000001;\n    vec3 hsl = vec3(0.0);\n\tfloat cmin = min( c.r, min( c.g, c.b ) );\n\tfloat cmax = max( c.r, max( c.g, c.b ) );\n\thsl.z = ( cmax + cmin ) \/ 2.0;\n\tif ( cmax > cmin ) \n    {\n\t\tfloat cdelta = cmax - cmin;\n        \n        hsl.y = hsl.z < 0.5 ? cdelta \/ ( epsilon + cmax + cmin) : cdelta \/ ( epsilon + 2.0 - ( cmax + cmin ) );\n        \n\t\tif ( c.r == cmax ) \n        {\n\t\t\thsl.x = ( c.g - c.b ) \/ (epsilon + cmax - cmin);\n\t\t} \n        else if ( c.g == cmax ) \n        {\n\t\t\thsl.x = 2.0 + ( c.b - c.r ) \/ (epsilon + cmax - cmin);\n\t\t} \n        else \n        {\n\t\t\thsl.x = 4.0 + ( c.r - c.g ) \/ (epsilon + cmax - cmin);\n\t\t}\n\n\t    if ( hsl.x < 0.0)\n        {\n\t\t\thsl.x += 6.0;\n\t\t}\n\t\thsl.x = hsl.x \/ 6.0;\n\t}\n    \n\treturn hsl;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\n    \/\/ Generate RGB color\n    vec3 rgb = vec3(0.2 * (0.5+0.5*sin(iGlobalTime + uv.y)), 0.4, 0.4 * (0.5+0.5*sin(iGlobalTime + uv.x)));\n    \n    \/\/ RBG to HSL\n    vec3 hsl = rgb2hsl(rgb);\n    vec3 hsl_branches = rgb2hsl_branches(rgb);\n\n    \/\/fragColor.xyz = abs(hsl - hsl_branches);\n    fragColor.xyz = mix(hsl, hsl_branches, step(0.5, uv.x)) * step(0.001, abs(uv.x - 0.5));\n}","name":"","description":"","type":"image"}]}}