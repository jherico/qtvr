{"Shader":{"ver":"0.1","info":{"id":"4dXGDX","date":"1380146008","viewed":1115,"name":"Julia - Generic","username":"iq","description":"A generic Julia set renderer, using distance to the set (Douady_Hubbard potential). In this case I'm using a rational function of order 6: f(z) = (z-(1+i)\/10)(z-i)(z-1)^4 \/ (z+1)(z-(1+i)) + c","likes":3,"published":3,"flags":0,"tags":["2d","fractal","distance","generic"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/------------------------------------------------------------\n\/\/ complex number operations\nvec2 cadd( vec2 a, float s ) { return vec2( a.x+s, a.y ); }\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) \/ d; }\nvec2 csqr( vec2 a ) { return vec2(a.x*a.x-a.y*a.y, 2.0*a.x*a.y ); }\nvec2 csqrt( vec2 z ) { float m = length(z); return sqrt( 0.5*vec2(m+z.x, m-z.x) ) * vec2( 1.0, sign(z.y) ); }\nvec2 conj( vec2 z ) { return vec2(z.x,-z.y); }\nvec2 cpow( vec2 z, float n ) { float r = length( z ); float a = atan( z.y, z.x ); return pow( r, n )*vec2( cos(a*n), sin(a*n) ); }\n\/\/------------------------------------------------------------\n\n\nvec2 f( vec2 z, vec2 c )\n{\n\t\/\/return csqr(z) + c;   \/\/ tradicional z -> z^2 + c Julia set\n\n\treturn c + cdiv( cmul( z-vec2(0.0,1.0), cmul( cpow(z-1.0,4.0), (z-vec2(-0.1)) ) ), \n\t\t\t\t\t cmul( z-vec2(1.0,1.0), z+1.0));\n}\n\nvec2 df( vec2 z, vec2 c )\n{\n\tvec2 e = vec2(0.001,0.0);\n    return cdiv( f(z,c) - f(z+e,c), e );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n\tp.y *= iResolution.y\/iResolution.x;\n\tp = 2.5*(p+vec2(0.25,0.37));\n\t\n\tfloat time = iGlobalTime;\n\tvec2 c = vec2( 0.1-0.08, 0.55-0.3 ) + \n\t\t     0.30*vec2( sin(0.31*(time-10.0)), cos(0.37*(time-10.0)) ) - \n\t\t     0.01*vec2( sin(2.17*(time-10.0)), cos(2.31*(time-10.0)) );\n\t\n\n\t\/\/ iterate\t\t\n\tvec2 dz = vec2( 1.0, 0.0 );\n\tvec2 z = p;\n\tfloat g = 1e10;\n\tfor( int i=0; i<100; i++ )\n\t{\n\t\tif( dot(z,z)>10000.0 ) continue;\n\n        \/\/ chain rule for derivative\t\t\n\t\tdz = cmul( dz, df( z, c ) );\n\n        \/\/ function\t\t\n\t\tz = f( z, c );\n\t\t\n\t\tg = min( g, dot(z-1.0,z-1.0) );\n\t}\n\n    \/\/ distance estimator\n\tfloat h = 0.5*log(dot(z,z))*sqrt( dot(z,z)\/dot(dz,dz) );\n\t\n\th = clamp( h*100.0, 0.0, 1.0 );\n\t\n\t\n\tvec3 col = 0.6 + 0.4*cos( log(log(1.0+g))*0.5 + 4.5 + vec3(0.0,0.5,1.0) );\n\tcol *= h;\n\tfragColor = vec4( col, 1.0 );\n\n}\n","name":"","description":"","type":"image"}]}}