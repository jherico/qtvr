{"Shader":{"ver":"0.1","info":{"id":"lsyGzw","date":"1453692820","viewed":120,"name":"Companion Cubed Ultra","username":"unconed","description":"Experiment with folds and inversions.","likes":2,"published":3,"flags":0,"tags":["hybridfractal"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"vec4 fold1(vec4 z) {\n    vec3 p = z.xyz;\n    p = p - 2.0 * clamp(p, -1.0, 1.0);\n    return vec4(p, z.w);\n}\n\nvec4 fold2(vec4 z) {\n    vec3 p = z.xyz;\n    p = p - 2.0 * clamp(p, -1.0, 1.0);\n    return vec4(p * 2.0, 2.0 * z.w);\n}\n\nvec4 invertRadius(vec4 z, float radius2, float limit) {\n  float r2 = dot(z.xyz, z.xyz);\n  float f = clamp(radius2 \/ r2, 1., limit);\n  return z * f;\n}\n\nvec4 affine(vec4 z, float factor, vec3 offset) {\n  z.xyz *= factor;\n  z.xyz += offset;\n  z.w *= abs(factor);\n  return z;\n}\n\nvec4 mandel(vec4 z, vec3 offset) {\n  float x = z.x;\n  float y = z.y;\n\n  z.w = 2. * length(z.xy) * z.w + 1.;\n\n  z.x = x*x - y*y + offset.x;\n  z.y = 2.*x*y + offset.y;\n\n  return z;\n}\n\nvec4 invert(vec4 z, float factor) {\n  float r2 = dot(z.xyz, z.xyz);\n  float f = factor \/ r2;\n  return z * f;\n}\n\nvec4 rotateXY(vec4 z, float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  mat2 m = mat2(c, s, -s, c);\n  return vec4(m * z.xy, z.zw);\n}\n\nvec4 rotateXZ(vec4 z, float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  mat2 m = mat2(c, s, -s, c);\n  vec2 r = m * z.xz;\n  return vec4(r.x, z.y, r.y, z.w);\n}\n\nvec4 shiftXY(vec4 z, float angle, float radius) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return vec4(vec2(c, s) * radius + z.xy, z.zw);\n}\n\nfloat surface = 0.0;\nfloat sdf(vec3 p) {\n    \/\/vec3 pmod = mod(p + 2.0, 4.0) - 2.0;\n    vec4 z = vec4(p, 1.0);\n    \n    float t = iGlobalTime * .5;\n\n    vec3 vo1 = vec3(sin(t * .1), cos(t * .0961), sin(t * .017)) * .1;\n    vec3 vo2 = vec3(cos(t * .07), sin(t * .0533), sin(t * .138)) * .1;\n    vec3 vo3 = vec3(sin(t * .031), sin(t * .0449), cos(t * .201)) * .1;\n    \n    z = invertRadius(z, 10.0*10.0, 1.3);\n    z.xyz += vo1;\n    z = fold1(z);\n    z.xyz += vo2;\n    z = invertRadius(z, 10.0*10.0, 1.3);\n    z = rotateXZ(z, t * .102);\n    z = rotateXY(z, t * .123);\n    z = fold1(z);\n    z.xyz += vo1;\n    z = invertRadius(z, 10.0*10.0, 1.3);\n    z = fold1(z);\n    z = rotateXY(z, t * .123);\n    z = fold2(z);\n    z.xyz += vo3;\n    z = rotateXY(z, t);\n    z = rotateXZ(z, t * .202);\n    z = invertRadius(z, 1.0*1.0, 3.0);\n    z = rotateXY(z, t * .123);\n    z = fold1(z);\n    z = invertRadius(z, 1.0*1.0, 3.0);\n    z = rotateXY(z, t * .123);\n    z = fold2(z);\n    z.xyz += vo3;\n    z = rotateXY(z, t);\n    z = rotateXZ(z, t * .202);\n    z = invertRadius(z, 1.0*1.0, 3.0);\n    z = rotateXY(z, t * .123);\n    z = fold1(z);\n    z = invertRadius(z, 1.0*1.0, 3.0);\n    z = rotateXY(z, t * .123);\n    z = fold2(z);\n    z.xyz += vo3;\n    z = rotateXY(z, t);\n    z = rotateXZ(z, t * .202);\n    z = invertRadius(z, 1.0*1.0, 3.0);\n    z = rotateXY(z, t * .123);\n    z = fold1(z);\n    z = invertRadius(z, 1.0*1.0, 3.0);\n    z = rotateXY(z, t * .123);\n    z = fold2(z);\n    z.xyz += vo3;\n    z = rotateXY(z, t);\n    z = rotateXZ(z, t * .202);\n    z = invertRadius(z, 1.0*1.0, 3.0);\n    z = rotateXY(z, t * .123);\n    z = fold1(z);\n    z = invertRadius(z, 1.0*1.0, 3.0);\n\n\n\n    vec3 po = vec3(0.0, 0.0, 0.0);\n\n    float d1 = (length(z.xyz - po) - .9) \/ z.w;\n    \n    vec3 box = abs(z.xyz);\n    float d2 = (max(box.x - 1.0, max(box.y - 1.0, box.z - .5))) \/ z.w;\n\t\n    float d3 = min(d1, d2);\n    if (d2 == d3) {\n      surface = 1.0;\n    }\n    else {\n      surface = 0.0;\n    }\n    return d3;\n}\n\nvec3 normal(vec3 p) {\n\tvec2 e = vec2(.0001, 0.0);\n    return normalize(vec3(\n        sdf(p + e.xyy) - sdf(p - e.xyy),\n        sdf(p + e.yxy) - sdf(p - e.yxy),\n        sdf(p + e.yyx) - sdf(p - e.yyx)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec2 xy = (uv * 2.0 - 1.0) * vec2(iResolution.x \/ iResolution.y, 1.0);\n\n    vec3 color = vec3(.8, .9, 1.0) * (1.5 - uv.y);\n\n    vec3 light = vec3(.577);\n    float angle = 1.0-iMouse.x * .005;   \n    float c = cos(angle);\n    float s = sin(angle);\n    mat3 camera = mat3(\n        c,  0.0, -s,\n         0.0,  1.0, 0.0,\n        s,  0.0, c\/\/,\n\t);\n    float fov = .5;\n\n    vec3 rd = camera * normalize(vec3(xy * fov,-1.0));\n    vec3 ro = vec3(s,0.0,c)*32.0;\n    \n    float tmax = 100.0;\n    float dmin = .001;\n    float t = 0.0;\n    float d = sdf(ro);\n    if (d < 0.0) rd = -rd;\n    for (int i = 0; i < 96; ++i) {\n        vec3 p = ro + rd * t;\n        d = sdf(p);\n        t += d;\n        if (t > tmax || abs(d) < dmin) break;\n    }\n\n    vec3 p = ro + rd * t;\n    vec3 n = normal(p);\n    if (t < tmax && d < dmin) {\n      vec3 albedo = mix(vec3(1.0, 0.02, 0.02), vec3(1.0), surface);\n  \t  float diffuse = clamp(dot(n, light), 0.0, 1.0);\n      \n      float ao = 0.0;\n      float am = 0.0;\n      float step = .05;\n      vec3 pa = p;\n      for (int i = 0; i < 8; ++i) {\n          pa += n * step;\n          am += step;\n          ao += max(0.0, sdf(pa) \/ am);\n          step += .05;\n      }\n      \n      t = .1;\n      float shadow = 1.0;\n      if (diffuse > 0.0) {\n        for (int i = 0; i < 32; ++i) {\n          vec3 pb = p + light * t;\n          d = sdf(pb);\n          t += d;\n          if (d < 0.0) break;\n        }\n        \n        shadow = clamp(d, 0.0, 1.0);\n        diffuse *= shadow;\n      }\n        \n      ao = ao \/ 8.0;\n      float ambient = 0.04;\n\n      vec3 sun = vec3(1.0, .9, .8);\n      vec3 sky = vec3(.3, .5, 1.0);\n      color = 2.0 * vec3(mix(sun * diffuse, sky, ambient) * ao * ao * albedo * 5.0);\n      color = color\/(1.0+color);\n    }\n    \n\tfragColor = vec4(sqrt(color),1.0);\n}","name":"","description":"","type":"image"}]}}