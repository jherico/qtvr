{"Shader":{"ver":"0.1","info":{"id":"lsBSDm","date":"1412646115","viewed":5458,"name":"Inverse Bilinear","username":"iq","description":"Inverse bilinear interpolation: given a point p and a quad compute the bilinear coordinates of p in the quad. More info <a href=\"http:\/\/www.iquilezles.org\/www\/articles\/ibilinear\/ibilinear.htm\"  class=\"regular\" target=\"_blank\">in this article<\/a>.","likes":13,"published":3,"flags":0,"tags":["2d","interpolation","bilinear"],"hasliked":0},"renderpass":[{"inputs":[{"id":2,"src":"\/presets\/tex01.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Inverse bilienar interpolation: given four points defining a quadrilateral, compute the\n\/\/ uv coordinates of any point in the plane that would give result to that point as a \n\/\/ bilinear interpolation of the four points.\n\/\/\n\/\/ The problem resolves through a quadratic equation. More information in this article:\n\/\/\n\/\/ http:\/\/www.iquilezles.org\/www\/articles\/ibilinear\/ibilinear.htm\n\n\nfloat cross( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n\/\/ given a point p and a quad defined by four points {a,b,c,d}, return the bilinear\n\/\/ coordinates of p in the quad. Returns (-1,-1) if the point is outside of the quad.\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross( g, f );\n    float k1 = cross( e, f ) + cross( h, g );\n    float k0 = cross( h, e );\n    \n    float w = k1*k1 - 4.0*k0*k2;\n    \n    if( w<0.0 ) return vec2(-1.0);\n\n    w = sqrt( w );\n    \n    float v1 = (-k1 - w)\/(2.0*k2);\n    float v2 = (-k1 + w)\/(2.0*k2);\n    float u1 = (h.x - f.x*v1)\/(e.x + g.x*v1);\n    float u2 = (h.x - f.x*v2)\/(e.x + g.x*v2);\n    bool  b1 = v1>0.0 && v1<1.0 && u1>0.0 && u1<1.0;\n    bool  b2 = v2>0.0 && v2<1.0 && u2>0.0 && u2<1.0;\n    \n    vec2 res = vec2(-1.0);\n\n    if(  b1 && !b2 ) res = vec2( u1, v1 );\n    if( !b1 &&  b2 ) res = vec2( u2, v2 );\n    \n    return res;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nvec3  hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy)\/iResolution.y;\n    \n    \/\/ background\n    vec3 col = vec3( 0.35 + 0.1*p.y );\n\n    \/\/ move points\n    vec2 a = cos( 1.11*iGlobalTime + vec2(0.1,4.0) );\n    vec2 b = cos( 1.13*iGlobalTime + vec2(1.0,3.0) );\n    vec2 c = cos( 1.17*iGlobalTime + vec2(2.0,2.0) );\n    vec2 d = cos( 1.15*iGlobalTime + vec2(3.0,1.0) );\n\n    \/\/ area of the quad\n    vec2 uv = invBilinear( p, a, b, c, d );\n    if( uv.x>-0.5 )\n    {\n        col = texture2D( iChannel0, uv ).xyz;\n    }\n    \n    \/\/ quad borders\n    float h = 2.0\/iResolution.y;\n    col = mix( col, vec3(1.0,0.7,0.2), 1.0-smoothstep(h,2.0*h,sdSegment(p,a,b)));\n    col = mix( col, vec3(1.0,0.7,0.2), 1.0-smoothstep(h,2.0*h,sdSegment(p,b,c)));\n    col = mix( col, vec3(1.0,0.7,0.2), 1.0-smoothstep(h,2.0*h,sdSegment(p,c,d)));\n    col = mix( col, vec3(1.0,0.7,0.2), 1.0-smoothstep(h,2.0*h,sdSegment(p,d,a)));\n \n    col += (1.0\/255.0)*hash3(p.x+13.0*p.y);\n\n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}