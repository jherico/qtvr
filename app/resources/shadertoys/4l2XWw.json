{"Shader":{"ver":"0.1","info":{"id":"4l2XWw","date":"1448919713","viewed":259,"name":"phyllotaxis 2D","username":"shaderology","description":"infinite zoom into 2d pattern of romanesco broccoli. ","likes":7,"published":3,"flags":0,"tags":["2d","fibonacci","phyllotaxis","logpolar","romanesco","broccoli"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define PI 3.14159265359\n#define PI2 6.28318530718\n#define SPIRALS 7.\n#define LEV 5\n\/\/#define CELLROTATION\n\nvec2 rotate2D(vec2 p, float t)\n{\n    mat2 m = mat2( cos(t), sin(t), -sin(t), cos(t) );\n    return m * p;\n}\n\nvec4 phyllotaxis( vec2 uv, float offset )\n{\n\n    \/\/ initiate\n    float i_s = 1.;\n    float r_s = 1.;\n    float t_s = 0.;\n    float occ = 1.;\n    float dsp = 0.5;\n    vec3 n = vec3(0., 0., 1.);\n\n    for( int i=1; i<LEV; i++ )\n    {\n      float zoom = i == 1 ? offset : 0.;\n        \n      \/\/ Log-Polar coordinates from UVs generated in previous iteration\n      float r = length(uv);\n      float lr = log(r);\n      float theta = atan( uv.x, uv.y);\n        \n      \/\/ Logarithmic spiral coordinates\n      vec2 spiral = vec2( theta - lr, theta + lr - zoom)\/PI;\n      \n      \/\/ Phyllotaxis florets - main pattern\n      \/\/ Log-polar fractions back to cartesian cells\n      uv = fract( spiral * SPIRALS ) -  0.5;\n\n      \/\/ Align new theta's using parent theta. Not very accurate as there is some distortion.\n      \/\/ Also had to offset with a mysterious constant of 0.36 (golden fraction?)\n      #ifdef CELLROTATION\n        \/\/ Experimental part. Flatten the spiral coordinates to cells\n        \/\/ and use uniform value of an entire cell to offset theta\n        float cellr = floor(spiral.x * SPIRALS) - floor(spiral.y * SPIRALS);\n        float cellt = floor(spiral.x * SPIRALS ) + floor(spiral.y * SPIRALS );\n        vec2 uvcell = vec2( cellr, cellt \/ (SPIRALS \/ 1.55) );\n        \/\/uv = rotate2D( uv, -(theta+0.72)  ); \/\/ + 2x golden fraction?\n        uv = rotate2D( uv,  -(uvcell.y) );\n        t_s = theta;\n      #else\n        \/\/ cheap offset with golden(?) constant.\n        \/\/ thetas are aligned but slightly distorted\n        t_s = theta + t_s + 0.36;\n      #endif\n      \n      \/\/ smooth cone tips\n      float taper = smoothstep(0.0, 0.2, r) * (1. - smoothstep(0.5, 0.8, r));\n        \n      \/\/ build and layer the normals and multiply with floret radius\n      n += mix( vec3(0., 0., 1.0), vec3( sin(t_s), cos(t_s), 0. ),  pow(taper, 0.5)) * r_s;        \n  \n      \/\/ comp occlusion.\n      occ *= 1.-pow(r, 2.);\n        \n      \/\/ displacement is not used in this demo\n      \/\/ dsp += (1.-r) * i_s * r_s;\n      \n      \/\/ store iteration multiplier for displacements\n      i_s = 1. \/ float(i);\n        \n      \/\/ combine and store floret radius. next iteration we use it to\n      \/\/ multiply displacements and normals\n      r_s *= sqrt(r);\n    }    \n    \n   return vec4( normalize(n), occ ); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    uv.y *= iResolution.y \/ iResolution.x;\n\n\tvec2 m = iMouse.xy \/ iResolution.xy -.5;\n\tm.x*= iResolution.x\/ iResolution.y;\n\tm *= 20.0;\n\t\n    \/\/ VARIABLES\n    float t = fract(iGlobalTime * .05) * PI;\n    vec3 sp = vec3(uv - 0.4, 0.);\n    vec3 lp = iMouse.z < .5 ? vec3(sin(t*5.)*10.,cos(t*8.)*10., -1.5) : vec3(m, -2.);\n    vec3 ld = normalize(lp - sp);\n    vec3 ro = vec3(0, 0, -0.5);\n    vec3 rd = normalize(ro-sp);\n\n    \/\/ THE PATTERN\n    vec4 brocc = phyllotaxis(sp.xy, t);\n    vec3 n = vec3( brocc.xy, -brocc.z);\n    float occ = brocc.w;\n    \n    \/\/ COLORS\n    vec3 base = vec3(0.38, 0.52, 0.26);\n    vec3 diff = vec3(0.6, 0.6, 0.5);\n    vec3 spec = diff;\n    vec3 back = vec3(0.1, 0.01, 1.5);\n    vec3 ambi = vec3(0.25, 0.44, 0.23);\n    \n    \/\/ SHADE\n\tdiff *= max(dot(n, ld), 0.);\n    back *= max(dot(n, vec3(0.4, -0.4, 0.2)), 0.);\n    spec *= pow(max(dot( reflect(-ld, n), rd), 0.), 7.); \n    ambi *= occ;\n\n    \/\/ COMP\n    vec3 col = base * ambi;\n    col += base * diff;\n    col += spec * 0.2;\n    col += base * back;\n\n    \/\/ POST\n    col *= pow(20.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y),0.5) +  0.1;\n    col = sqrt(col);\n    \n\tfragColor = vec4( col, 1.);\n}","name":"","description":"","type":"image"}]}}