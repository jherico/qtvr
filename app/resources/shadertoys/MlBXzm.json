{"Shader":{"ver":"0.1","info":{"id":"MlBXzm","date":"1442440664","viewed":929,"name":"sphere stuff","username":"tly","description":"idea from http:\/\/www.josleys.com\/article_show.php?id=83, linked by BeyondTheStatic <img src=\"\/img\/emoticonHappy.png\"\/>","likes":4,"published":3,"flags":0,"tags":["sphere","reflections"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"struct Ray{\n\tvec3 p,v;\n};\n\t\nstruct Sphere{\n\tvec3 o;\n\tfloat r;\n};\n\t\nstruct Hit{\n\tvec3 p;\n\tvec3 n;\n\tfloat l;\n};\n\nvec3 color(int index){\n\tif(index == 0) return vec3(0,0,1);\n    if(index == 1) return vec3(0,1,1);\n    if(index == 2) return vec3(1,0,0);\n    if(index == 3) return vec3(1,1,0);\n    if(index == 4) return vec3(0,1,0);\n    if(index == 5) return vec3(1,0,1);\n    else return vec3(0);\n}\nconst float infinity = 100000000000.0;\n\t\nHit hit(Ray ray,Sphere sphere){\n\tvec3 o = sphere.o - ray.p;\n\t\n\tfloat p = dot(ray.v,o);\n\tfloat q = dot(o,o) - sphere.r * sphere.r;\n\t\n\tvec2 d = p + vec2(1,-1) * sqrt(p*p - q);\n\tvec3 p0 = ray.p + ray.v * min(d.x,d.y);\n\treturn Hit(\n        p0, \/\/hitpoint\n        (p0 - sphere.o)\/sphere.r, \/\/avoiding \"normalize\"\n        (d.x > 0.0 && d.y > 0.0) ? min(d.x,d.y) : infinity \/\/throw away if hitpoints are behind the rayposition\n\t);\t\n}\n\nvec3 rotateY(in vec3 v, in float a) {\n\treturn vec3(cos(a)*v.x + sin(a)*v.z, v.y,-sin(a)*v.x + cos(a)*v.z);\n}\n\nvec3 rotateX(in vec3 v, in float a) {\n\treturn vec3(v.x,cos(a)*v.y + sin(a)*v.z,-sin(a)*v.y + cos(a)*v.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = (fragCoord.xy - iResolution.xy*0.5 )\/iResolution.y;\n\t\n\tRay ray = Ray(vec3(0),normalize(vec3(uv.x,uv.y,0.75)));\n\tray.v = rotateY(ray.v,-0.1 * iGlobalTime);\n    ray.v = rotateX(ray.v,-0.13 * iGlobalTime);\n\t\n\tfloat r = mix(0.6,sqrt(3.0) * 0.5,min(1.0,1.5 * pow(sin(iGlobalTime) * 0.5 + 0.5,0.3)));\n\tSphere spheres[6];\n    spheres[0] = Sphere(vec3(0,0,+1),r);\n\tspheres[1] = Sphere(vec3(0,0,-1),r);\n\tspheres[2] = Sphere(vec3(0,+1,0),r);\n\tspheres[3] = Sphere(vec3(0,-1,0),r);\n\tspheres[4] = Sphere(vec3(+1,0,0),r);\n\tspheres[5] = Sphere(vec3(-1,0,0),r);\n\t\n    float factor = 0.7;\n    float lightStrength = 1.0;\n    fragColor = vec4(0,0,0,1);\n\t\n\tconst int REFLECTIONS = 9;\n\tfor(int i = 0; i < REFLECTIONS; i++){\n        Hit h = Hit(vec3(0),vec3(0),infinity);\n        int found = -1;\n\t\tfor(int j = 0; j < 6; j++){\n\t\t\tHit x = hit(ray,spheres[j]);\n            if(x.l < h.l){\n                h = x;\n                found = j;\n           \t}\n\t\t}\n\t\tif(found != -1){\n\t\t\tray.p = h.p;\n\t\t\tray.v = reflect(ray.v,h.n);\n            \n            vec3 lightVec = -normalize(h.p);\n            float diffuse = dot(h.n,lightVec);\n            float specular = pow(abs(dot(reflect(-lightVec,h.n),lightVec)),20.0);\n\t\t\tfragColor.xyz += lightStrength * (diffuse * color(found) + specular);\n        }\n        lightStrength *= factor;\n\t}\n\tfragColor.xyz *= 1.3 * (1.0 - factor);\n}","name":"","description":"","type":"image"}]}}