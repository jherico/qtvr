{"Shader":{"ver":"0.1","info":{"id":"4tX3DH","date":"1421362607","viewed":716,"name":"Harmonic Pendula","username":"dcm","description":"An array of pendula at various lengths such that their periods sync up in various harmonies.  ","likes":1,"published":3,"flags":0,"tags":["raycasting","pendulum"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Original link: https:\/\/www.shadertoy.com\/view\/Xds3zN\n\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ A list of usefull distance function to simple primitives, and an example on how to \n\/\/ do some interesting boolean operations, repetition and displacement.\n\/\/\n\/\/ More info here: http:\/\/www.iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\n\n\/\/ Modified by AranHase to implement Gooch shading from:\n\/\/ http:\/\/www.cs.northwestern.edu\/~ago820\/SIG98\/abstract.html\n\/\/ Very simple technique to auto shade technical illustrations\n\n\/\/ modified by dcm to check out an array of pendula\n\nconst int num = 40;\nconst float pi = 3.14159;\nconst float tau = 2.0*3.14159;\nint sticks = 0;\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0\/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0\/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n  return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n\/\/----------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n\/\/----------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = opU( vec2( sdPlane(     pos), 10.0 ),\n\t                vec2( sdSphere(    pos-vec3( 0.0,-.25, 0.0), 0.15 ), 46.9 ) );\n    \n    float numsq = float(num*num);\n    for(int i = 0; i < num; i+=1)\n    {\n        float j = float(i)+1.0;\n        float theta = pi*cos(j*iGlobalTime\/10.0);\n        float r = 3.75-3.75*(j*j\/numsq);\n            \n        float c = 24.0;\n        \/\/float c = 1.0;\n        res = opU( res,\n              vec2( sdSphere( pos-vec3( j\/2.0, \n                                       4.0 - r*cos(theta), \n                                       r*sin(theta)), \n                             0.25 ), c ) );\n        \/*\n        if (sticks == 1)\n        {\n        res = opU( res, \n                  vec2( sdCapsule(pos,\n                  \tvec3(float(j)\/2.0, 4.0, 0.0),\n                  \tvec3(float(j)\/2.0, 4.0 - r*cos(theta), \n                                       r*sin(theta)), 0.01\n                  ), 1.0));\n        }\n\t\t*\/\n    }\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = float(num);\n    \n#if 0\n    float tp1 = (0.0-ro.y)\/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)\/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<500; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h\/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)\/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 fragCoord )\n{ \n    \/\/ y = -m(x-0.5)^2 + 1.0\n    float xx = fragCoord.y\/iResolution.y-0.5;\n    xx = -5.000*xx*xx + 1.0;\n    vec3 col = vec3(0.5*xx);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m >= 0.0 )\n    {\n        vec3 view_direction = -rd;\n        \n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        \/\/ Light above is easier for the brain to process\n        vec3 lig = normalize( vec3(100, 100, 100)-pos );\n        \n        \n        float b = 0.4;\n        float y = 0.4;\n        float alpha = 0.2;\n        float beta = 0.6;\n        \n        vec3 kblue = vec3(0, 0, b);\n        vec3 kyellow = vec3(y, y, 0);\n        \n        \/\/ Ambient light\n        vec3 ka = vec3(0.1);\n        \n        \/\/ Diffuse light intensity\n        vec3 kd = vec3(m\/55.0, (m-55.0)\/55.0, 0.00);\n        \n        \/\/ These values are better explained in the original paper\n        \/\/ I kept the same names\n        vec3 kcool = kblue + alpha*kd;\n        vec3 kwarm = kyellow + beta*kd;\n        \n        \n        vec3 I = ((1.0+dot(lig,nor))*0.5)*kcool + ((1.0-(1.0+dot(lig,nor))*0.5))*kwarm;\n        float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        col = I + 0.90*spe*vec3(1.00,1.00,1.00) + ka;\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\n\tvec2 q = fragCoord.xy\/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x\/iResolution.y;\n    vec2 mo = iMouse.xy\/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iGlobalTime;\n\n\t\/\/ camera\t\n\tvec3 ro = vec3( -4.0+3.2*cos( + 6.0*mo.x), 0.1 + 2.0*mo.y, 0.0 + 3.2*sin( 6.0*mo.x) );\n\tvec3 ta = vec3( 1.0, 3.0, 0.5 );\n\t\n\t\/\/ camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n\t\n    vec3 col = render( ro, rd, fragCoord);\n\n\t\/\/col = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}