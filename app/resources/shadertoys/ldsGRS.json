{"Shader":{"ver":"0.1","info":{"id":"ldsGRS","date":"1373678886","viewed":2115,"name":"Metro Tunnel","username":"fb39ca4","description":"Inspired by the tunnels in Metro 2033. Click and drag to move the light along the tunnel.<br\/>This scene makes heavy use of repeating geometry, as you can see in the train tracks and wall braces. I even  plan to extend this to repeating lights in the future.","likes":16,"published":3,"flags":0,"tags":["raymarching","shadow","metro","2033"],"hasliked":0},"renderpass":[{"inputs":[{"id":3,"src":"\/presets\/tex02.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":6,"src":"\/presets\/tex05.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":7,"src":"\/presets\/tex06.jpg","ctype":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/Thank you iquilez for some of the primitive distance functions!\n\n\nconst float PI = 3.14159265358979323846264;\n\nconst float GAMMA_CORRECTION_FACTOR = 2.6;\n\nconst int MAX_PRIMARY_RAY_STEPS = 64;\nconst int MAX_SECONDARY_RAY_STEPS = 12;\n\n\/\/General math functions\t\nfloat square(float x) {\n\treturn x * x;\n}\n\nfloat round(float x) {\n\treturn floor(x + 0.5);\n}\n\nfloat isNegative(float x) {\n\t\/\/returns 0.0 if positive, 1.0 if negative\n\t\/\/return (-abs(x) \/ x + 1.0) \/ 2.0;\n\treturn 1.0 - step(0.0, x);\n}\n\nvec2 rectToPolar(vec2 v) {\n\t\/\/result = vec2(length(v), atan(v.y \/ v.x));\n\treturn vec2(length(v), atan(v.y \/ v.x) + isNegative(v.x) * PI);\n}\n\nvec2 polarToRect(vec2 v) {\n\treturn v.x * vec2(cos(v.y), sin(v.y));\n}\n\nfloat polarDist(vec2 v1, vec2 v2) { \n\t\/\/Formula ripped from \n\t\/\/http:\/\/math.ucsd.edu\/~wgarner\/math4c\/derivations\/distance\/distancepolar.htm\n\treturn sqrt(v1.x * v1.x + v2.x * v2.x - 2.0 * v1.x * v2.x * cos(v1.y - v2.y));\n}\n\nvec2 rot2D(vec2 v, float angle) {\n\tfloat sinA = sin(angle);\n\tfloat cosA = cos(angle);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\n}\n\nfloat wireFunc(float x, float period) {\n\t\/\/adjusts the position of the wires\n\treturn cos(min(mod(x, period), PI) + floor(x \/ period) * PI);\n}\n\nfloat expFog(float d, float density) {\n\treturn 1.0 \/ pow(d * density, 2.71828);\n}\n\n\/\/better texture filtering - Thanks iquilez! - https:\/\/www.shadertoy.com\/view\/XsfGDn\nvec3 betterTextureSample64(sampler2D texture, vec2 uv) {\t\n\tfloat textureResolution = 64.0;\n\tuv = uv*textureResolution + 0.5;\n\tvec2 iuv = floor( uv );\n\tvec2 fuv = fract( uv );\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv); \/\/ fuv*fuv*fuv*(fuv*(fuv*6.0-15.0)+10.0);;\n\tuv = (uv - 0.5)\/textureResolution;\n\treturn texture2D(texture, uv).rgb;\n}\n\nvec3 betterTextureSample256(sampler2D texture, vec2 uv) {\t\n\tfloat textureResolution = 256.0;\n\tuv = uv*textureResolution + 0.5;\n\tvec2 iuv = floor( uv );\n\tvec2 fuv = fract( uv );\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv); \/\/ fuv*fuv*fuv*(fuv*(fuv*6.0-15.0)+10.0);;\n\tuv = (uv - 0.5)\/textureResolution;\n\treturn texture2D(texture, uv).rgb;\n}\n\n\/\/CSG operations\nfloat join(float a, float b) { return min(a, b); }\nfloat carve(float a, float b) { return max(a, -b); }\nfloat intersect(float a, float b) { return max(a, b); }\n\n\/\/Distance field primitives\nfloat sdPlane(vec3 p, vec4 n) {\n\treturn dot(p, n.xyz) + n.w;\n}\n\nfloat sdInfCyl(vec2 p, float r) {\n\treturn length(p.xy) - r;\n}\n\nfloat sdInfCylPolar(vec2 p, vec3 d) {\n\t\/\/d.xy = polar coords of center of cylinder\n\t\/\/d.z = radius of cylinder\n\treturn polarDist(p, d.xy) - d.z;\n}\n\nfloat sd2Planes(vec3 p, vec4 n) {\n\tfloat plane1 = dot(p, n.xyz);\n\tfloat plane2 = dot(p, -n.xyz) - n.w;\n\treturn max(plane1, plane2);\n}\n\nfloat sdWedge(vec2 p, float d) { \n\t\/\/p is a polar coordinate!\t\n\treturn p.x * sin(abs(p.y) - d);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  \tvec3 d = abs(p) - b;\n  \treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdInfBox(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat distanceField(vec3 p) {\n\tfloat result;\n\tvec2 polarXY = rectToPolar(vec2(abs(p.x), p.y));\n\t\n\t\/\/float heightOffset = 0.05 * texture2D(iChannel0, 0.06 * p.xz).r + 0.03 * square(p.x);\n\tfloat heightOffset = -0.02 * betterTextureSample256(iChannel0, 0.09 * p.xz).r + 0.06 * betterTextureSample256(iChannel0, 0.015 * p.xz).g + 0.03 * square(p.x);\n\tfloat ground = sdPlane(vec3(p.x, p.y - heightOffset, p.z), vec4(0.0, 1.0, 0.0, 2.1))  \/ 1.05;\n\tfloat tunnel = -sdInfCyl(p.xy, 4.0);\n\t\n\tfloat ringSupport = sd2Planes(vec3(p.xy, mod(p.z, 0.5) - 0.25), vec4(0.0, 0.0, -1.0, 0.05));\n\tringSupport = carve(ringSupport, sdInfCyl(p.xy, 3.85));\n\t\n\tfloat linearSupport = sdWedge(vec2(polarXY.x, mod(polarXY.y, PI \/ 10.0) - PI \/ 20.0), 0.015);\n\tlinearSupport = carve(linearSupport, sdInfCyl(p.xy, 3.90));\n\t\n\tfloat railroadTie = sdBox(vec3(p.xy, mod(p.z, 0.5) - 0.25) - vec3(0.0, -2.1, 0.0), vec3(1.3, 0.1, 0.10));\n\t\n\tfloat rail = sdInfBox(vec2(abs(p.x), p.y) - vec2(0.812, -1.9), vec2(0.05, 0.1));\n\t\n\tfloat wireOffset = 0.1 * wireFunc(p.z + 4.0 * step(p.x, 0.0), 2.0 * PI);\n\tfloat wirePos = 0.0;\n\twirePos = wireOffset + round((polarXY.y - wireOffset) \/ 0.05) * 0.05;\n\twirePos = clamp(wirePos, 0.2 + wireOffset - 0.05, 0.2 + wireOffset + 0.05);\n\t\n\tfloat wire = sdInfCylPolar(vec2(polarXY.x, polarXY.y), vec3(3.75, wirePos, 0.05));\n\twire \/= 1.05;\n\t\n\tresult = join(tunnel, ground);\n\tresult = join(result, ringSupport);\n\tresult = join(result, linearSupport);\n\tresult = join(result, railroadTie);\n\tresult = join(result, rail);\n\tresult = join(result, wire);\n\treturn result;\n}\n\nint getMaterial(vec3 p) {\n\tvec2 polarXY = rectToPolar(vec2(abs(p.x), p.y));\n\t\n\tfloat heightOffset = -0.01 * betterTextureSample256(iChannel0, 0.06 * p.xz).r + 0.06 * betterTextureSample256(iChannel0, 0.015 * p.xz).g + 0.03 * square(p.x);\n\tfloat ground = sdPlane(vec3(p.x, p.y - heightOffset, p.z), vec4(0.0, 1.0, 0.0, 2.1));\n\t\n\tfloat tunnel = -sdInfCyl(p.xy, 4.0);\n\tfloat ringSupport = sd2Planes(vec3(p.xy, mod(p.z, 0.5) - 0.25), vec4(0.0, 0.0, -1.0, 0.05));\n\tringSupport = carve(ringSupport, sdInfCyl(p.xy, 3.85));\n\tfloat linearSupport = sdWedge(vec2(polarXY.x, mod(polarXY.y, PI \/ 10.0) - PI \/ 20.0), 0.015);\n\tlinearSupport = carve(linearSupport, sdInfCyl(p.xy, 3.90));\n\tfloat wall = min(min(ringSupport, linearSupport), tunnel);\n\t\n\tfloat railroadTie = sdBox(vec3(p.xy, mod(p.z, 0.5) - 0.25) - vec3(0.0, -2.1, 0.0), vec3(1.3, 0.1, 0.10));\n\t\n\tfloat rail = sdInfBox(vec2(abs(p.x), p.y) - vec2(0.812, -1.9), vec2(0.05, 0.1));\n\t\n\tfloat wireOffset = 0.1 * wireFunc(p.z + 4.0 * step(p.x, 0.0), 2.0 * PI);\n\tfloat wirePos = 0.0;\n\twirePos = wireOffset + round((polarXY.y - wireOffset) \/ 0.05) * 0.05;\n\twirePos = clamp(wirePos, 0.2 + wireOffset - 0.05, 0.2 + wireOffset + 0.05);\n\t\n\tfloat wire = sdInfCylPolar(vec2(polarXY.x, polarXY.y), vec3(3.75, wirePos, 0.05));\n\n\tif (ground < min(min(wall, railroadTie), min(rail, wire))) return 1;\n\telse if (wall < min(railroadTie, min(rail, wire))) return 2;\n\telse if (railroadTie < min(rail, wire)) return 3;\n\telse if (rail < wire) return 4;\n\telse return 5;\n}\n\n\/\/rendering functions\nvec3 castRay(vec3 pos, vec3 dir, float treshold) {\n\tfor (int i = 0; i < MAX_PRIMARY_RAY_STEPS; i++) {\n\t\t\tfloat dist = distanceField(pos);\n\t\t\tif (abs(dist) < treshold) break;\n\t\t\tpos += dist * dir;\n\t}\n\treturn pos;\n}\n\nvec3 getNormal(vec3 pos, float derivDist) {\n\tvec3 surfaceNormal;\n\tsurfaceNormal.x = distanceField(vec3(pos.x + derivDist, pos.y, pos.z)) \n\t\t\t\t\t- distanceField(vec3(pos.x - derivDist, pos.y, pos.z));\n\tsurfaceNormal.y = distanceField(vec3(pos.x, pos.y + derivDist, pos.z)) \n\t\t\t\t\t- distanceField(vec3(pos.x, pos.y - derivDist, pos.z));\n\tsurfaceNormal.z = distanceField(vec3(pos.x, pos.y, pos.z + derivDist)) \n\t\t\t\t\t- distanceField(vec3(pos.x, pos.y, pos.z - derivDist));\n\treturn normalize(0.5 * surfaceNormal \/ derivDist);\n}\n\nfloat castShadowRay(vec3 pos, vec3 lightPos, float treshold) {\n\tvec3 dir = normalize(pos - lightPos);\n\tfloat maxDist = length(lightPos - pos);\n\tvec3 rayPos = lightPos;\n\tfloat distAccum = 0.0;\n\tfor (int i = 0; i < MAX_SECONDARY_RAY_STEPS; i++) {\n\t\tfloat dist = distanceField(rayPos);\n\t\trayPos += dist * dir;\n\t\tdistAccum += dist;\n\t}\n\tif (distAccum > maxDist - treshold) return 1.0;\n\telse return 0.0;\n}\n\nfloat lightPointDiffuseShadow(vec3 pos, vec3 lightPos, vec3 normal) {\n\tvec3 lightDir = normalize(lightPos - pos);\n\tfloat lightDist = length(lightPos - pos);\n\tfloat color = square(dot(normal, lightDir)) \/ square(lightDist);\n\tif (color > 0.00) color *= castShadowRay(pos, lightPos, 0.05);\n\treturn max(0.0, color);\n}\nfloat lightPointDiffuseSpecularShadow(vec3 pos, vec3 lightPos, vec3 cameraPos, vec3 normal) {\n\tvec3 lightDir = normalize(lightPos - pos);\n\tfloat lightDist = length(lightPos - pos);\n\tfloat color = dot(normal, lightDir) \/ square(lightDist);\n\tif (color > 0.01) {\n\t\tvec3 cameraDir = normalize(cameraPos - pos);\n\t\tcolor += dot(cameraDir, lightDir);\n\t\tcolor *= castShadowRay(pos, lightPos, 0.001);\n\t}\n\treturn max(0.0, color);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 mousePos = (iMouse \/ iResolution.xyxy) * 2.0 - 1.0;\n\tvec2 screenPos = (fragCoord.xy \/ iResolution.xy) * 2.0 - 1.0;\n\tvec3 cameraPos = vec3(0.0, 0.0, iGlobalTime * 2.0);\n\t\/\/vec3 cameraPos = vec3(0.0);\n\t\n\tfloat cameraRotAngle = -0.7 * mousePos.x;\n\tvec3 cameraDir = vec3(0.0, 0.0, 1.5);\n\tcameraDir.xz = rot2D(cameraDir.xz, cameraRotAngle);\n\tvec3 planeU = vec3(1.0, 0.0, 0.0);\n\tplaneU.xz = rot2D(planeU.xz, cameraRotAngle);\n\tvec3 planeV = vec3(0.0, iResolution.y \/ iResolution.x * 1.0, 0.0);\n\tvec3 rayDir = normalize(cameraDir + screenPos.x * planeU + screenPos.y * planeV);\n\t\n\tvec3 rayPos = castRay(cameraPos, rayDir, 0.01);\n\tvec2 polarXY = rectToPolar(vec2(abs(rayPos.x), rayPos.y));\n\tvec3 surfaceNormal = getNormal(rayPos, 0.0008);\n\t\n\tint material = getMaterial(rayPos);\n\tvec3 materialDiffuse = vec3(1.0);\n\tif (material == 1) materialDiffuse = (texture2D(iChannel3, rayPos.zx).rgb \/ 2.0 + 0.5) * vec3(1.0, 0.75, 0.6) * 0.5;\n\tif (material == 2) materialDiffuse = vec3(1.0, 0.7, 0.6) * texture2D(iChannel1, vec2(polarXY.y * 2.0 \/ PI, rayPos.z + polarXY.x)).rgb;\/\/vec3(0.0, 1.0, 0.0);\n\tif (material == 3) materialDiffuse = vec3(0.3, 0.5, 1.0) * texture2D(iChannel2, vec2(rayPos.x, rayPos.y + rayPos.z)).rgb;\n\tif (material == 4) materialDiffuse = vec3(0.6, 0.6, 0.6);\n\tif (material == 5) materialDiffuse = vec3(0.4, 0.4, 0.4);\n\t\n\tvec3 color = materialDiffuse * 0.4;\n\t\n\tvec3 light1Pos = vec3(0.0, 1.1, 7.5 * mousePos.y + 12.0 + cameraPos.z);\n\t\/\/lightPos = vec3(0.0, 0.0, sin(iGlobalTime) * 4.0 + 6.0);\n\t\t\n\t\/\/float isLit = castShadowRay(rayPos, lightPos, 0.02, 0.001);\n\tcolor += materialDiffuse * 18.0 * lightPointDiffuseShadow(rayPos, light1Pos, surfaceNormal);\n\t\n\tvec3 light2Pos = vec3(0.0, 1.1, 0.0);\/\/vec3(0.0, 1.1, 15.0 * mousePos.w + 16.0 \/*+ iGlobalTime * 2.0*\/);\n\tlight2Pos.z = round(rayPos.z \/ 16.0) * 16.0;\n\t\n\tcolor += materialDiffuse * 18.0 * lightPointDiffuseShadow(rayPos, light2Pos, surfaceNormal);\n\t\n\tcolor = pow(color, vec3(GAMMA_CORRECTION_FACTOR));\n\t\n\tfragColor = vec4(color, 1.0);\n\t\/\/fragColor = vec4(isLit * pow(10.0 * vec3(dot(surfaceNormal, lightRayDir)) \/ square(lightDistTotal), vec3(2.2)), 1.0);\n}","name":"","description":"","type":"image"}]}}