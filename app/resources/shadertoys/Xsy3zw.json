{"Shader":{"ver":"0.1","info":{"id":"Xsy3zw","date":"1453628442","viewed":163,"name":"othello \/ reversi - human\/comput","username":"FabriceNeyret2","description":"Human\/Computer, Human\/Human, Computer\/Computer ( flag #Human in BufA)    .  You are white.<br\/>NB: I don't pretend the computer plays well ! :-)","likes":8,"published":3,"flags":32,"tags":["game","othello","reversi"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define DEBUG 0\n#define SHOW  1  \/\/ 0 1 2   1: enlight allowed places  2: show places score\n\nvec2 R = iResolution.xy;\n#define text(U)  texture2D(iChannel0, (U+.5)\/R)\n#define draw_pawn(D,v) O += smoothstep(.4,.35,length(D)) * (2.*(v)-3.)\n\nvoid mainImage( out vec4 O, vec2 U )\n{       \n    O-=O;\n#if DEBUG\n    O = text(.1*U-.5)\/2.;               \/\/  display states for debug\n    if (length(O.rg)>=1.) return; \n#endif\n    \n    U = (U+U-R)\/R.y;\n    draw_pawn(4.*U-vec2(-5.5,0), text(vec2(.5,9.5)).x); \/\/ show current player\n    if (abs(U.x-1.3)<.1 && U.y>=0. && U.y<text(vec2(0,11)).x\/64.) O--; \/\/ #black pawns\n    if (abs(U.x-1.5)<.1 && U.y>=0. && U.y<text(vec2(0,11)).y\/64.) O++; \/\/ #white pawns\n    if (abs(U.x)>1.) { O+=.5; return; }                 \/\/ out of board    \n    \n    vec2 P = floor(4.+4.*U);                            \/\/ current cell\n    U = fract(U*4.+.05);                                \/\/ cell coordinates\n\n    if (P == text(vec2(0,8)).xy) \n         O.r++;                                         \/\/ mark play position\n    else O.g=.5;                                        \/\/ default cell color\n    if (SHOW>=1 && text(P+16.).x>0.) O.g+=.2;           \/\/ enlight allowed places\n    if (SHOW==2 && abs(U.x-.5)<.1 && U.y<text(P+16.).x\/16.) O.r++; \/\/ show place sclore\n    \n    float v = text(P).x;                                \/\/ pawn value\n    if (v>0.) draw_pawn(U-.55, v);                      \/\/ draw pawn\n    if (min(U.x,U.y)<.07) O-=O;                         \/\/ lines between cells\n}","name":"","description":"","type":"image"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define SPEED 60.\n#define HUMAN 1       \/\/ 0 1 2\n#define AUTO  1       \/\/ 1. Set 0 with HUMAN=0 let you trigger each next move\n#define INIT_BOARD 0  \/\/ 0: classical  1: random\n\nfloat ME = 2.;        \/\/ current color played. 1: black 2: white\n    \nvec2 R = iResolution.xy;\n#define cell(P,d) texture2D(iChannel0, ( P + 8.*(d) +.5) \/ R)\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U -= .5;                              \/\/ integer pixel position\n    \n    if (iFrame==0) {                      \/\/ --- init ------------------------------\n        O-=O;\n        if (U==vec2(0,9)) O.x=ME;         \/\/ curr player state\n        \n        if (max(U.x,U.y)<8.) {            \/\/ board data\n            float t=fract(iDate.w);\n#if INIT_BOARD                            \/\/ start with a random board\n            O.x = floor(3.*fract(1e4*sin(dot(U+t,vec2(71.17,13.13))))); \/\/ 0,1,2\n#else                                     \/\/ classical start board\n            if (min(U.x,U.y)>=3. && max(U.x,U.y)<=4.) O.x = 1.+mod(U.x+U.y,2.);\n#endif\n            O.a = fract(1e4*sin(dot(U+t,vec2(7.17,91.13))));  \/\/ to help choice :-)\n        }\n        return;\n    }\n\n    if (U==vec2(0,10)) { O=iMouse; return; }       \/\/ prev mouse state\n   \n    \n    O = cell(U, 0.);                               \/\/ for persistancy of all states\n    ME = cell(vec2(0,9),0.).x;                     \/\/ current player\n    bool human = HUMAN==2 || (HUMAN==1 && ME==2.); \/\/ is it human\n\n    \n    if (U==vec2(0,8)) {                   \/\/ --- make playing decision ---------------- \n        vec2 pM;\n        if (human) {                      \/\/ human player\n            pM = floor(4.+4.*(iMouse.xy*2.-R)\/R.y);  \/\/ user interactive choice\n            if ( cell(pM,2.).x==0.) pM = vec2(-1);   \/\/ location not allowed\n        } else {                          \/\/ computer player\n            float M=0.; pM=vec2(-1);      \/\/ --- find the place of maximum score ----\n            for (int j=0; j<8; j++)       \/\/ <><><> should time-serialize these loops as well\n                for (int i=0; i<8; i++) { \n                    vec2 p = vec2(i,j);\n                    float v = cell(p, 2.).x;                     \/\/ #pawn taken if play here\n                    if (v>0.) {                      \/\/ <><><> here, enrich strategy by modifying weight \n                        v += cell(p, 0.).a;                      \/\/ rand to prevent cases of equality\n                        if ( i==0||i==7  ||  j==0||j==7 ) v+=8.; \/\/ border bonus\n                        if ((i==0||i==7) && (j==0||j==7)) v+=8.; \/\/ corner bonus\n                        if (v>M) {  M = v; pM=p; }               \/\/ best for now\n        }       }   }\n        O.xy = pM;                        \/\/ store play decision coordinates \n        return;\n    }\n\n    if (U==vec2(0,11)) {                  \/\/ --- pawn count (for display) ---------------- \n           O.xy = vec2(0);\n           for (int j=0; j<8; j++)        \/\/ <><><> should time-serialize these loops as well\n                for (int i=0; i<8; i++) { \n                    vec2 p = vec2(i,j);\n                    float v = cell(p, 0.).x; \n                    if (v==1.) O.x++; else if (v==2.) O.y++;\n    }           }\n    \n    vec2 d = floor(U\/8.)-2.;  \n    \/\/ --- memory page = d+2. (3rd cell() parameter).\n\t\/\/ page 0:     .x: board\n    \/\/ page 2+dir: .y: number of taken pawn in direction dir.  .x: pawn index in line\n    \/\/ page 2:     ;x: total number of taken pawn (for each play position)\n    \/\/ (0,8):  best location to play\n    \/\/ (0,9):  current player\n    \/\/ (0,10): prev mouse state\n    \/\/ (0,11): pawns count \n    \/\/ (shown with DEBUG=1 in Image shader)\n    \n\n    if (  (AUTO!=0 && mod(float(iFrame),60.)==0.)                 \/\/ auto  play every 60 frames\n        ||(AUTO==0 && iMouse.z<0. &&cell(vec2(0,10),0.).z>=0.)) { \/\/ user triggers play\n                                                 \/\/ --- excute playing decision --------------------\n        vec2 p0 = cell(vec2(0,8),0.).xy;         \/\/ chosen play location\n        if (d==vec2(-2) ) {                      \/\/ we are in board page                             \n           if (p0==vec2(-1)) return;             \/\/ can't play\n           for (int j=-1; j<2; j++)              \/\/ check what's taken in each direction\n                for (int i=-1; i<2; i++) {\n                    vec2 d = vec2(i,j);\n                    float l = cell(p0, d+2.).y;       \/\/ #pawns in dir(i,j)\n                    if (l>0.) {                       \/\/ line of food\n                        vec2 dp = d*l, p1 = p0+dp;    \/\/ twin eater location\n                        if (length(clamp( dot(U-p0,dp)\/dot(dp,dp), 0.,1.) *dp - (U-p0)) < .1) \n                            O.x = ME;                 \/\/ eaten line of pawns\n        }       }   }\n        else if (!( human && p0==vec2(-1)))           \/\/ if legal move, switch player\n          { O-=O; if (U==vec2(0,9)) O.x=3.-ME; };     \/\/ reset all states\n        return;\n    }\n    \n    if (max(abs(d.x),abs(d.y))>1.) return;            \/\/ not in a compute page\n    U = mod(U,8.);                                    \/\/ cell index in page\n    \n                                \/\/ --- evaluate board potential --------------------------\n    \n    if (d==vec2(0)) {           \/\/ --- combine directional scores --------\n        O.x = 0.;\n        for (int j=-1; j<2; j++)\n            for (int i=-1; i<2; i++)\n                if (i!=0 || j!=0) O.x += cell(U,vec2(i,j)+2.).y; \/\/ adds the 8 maps\n        O.y = 2.*float(U==cell(vec2(0,8),0.).xy);     \/\/ draw location of max (for debug)\n        return;\n    }\n    \n    O.z =.5+2.*mod(d.x+d.y+2.,2.);                    \/\/ checkboard for debug     \n    \n                               \/\/ --- find all playable position and their score ---------\n                               \/\/ (time-serialized loops)\n    vec2 P = U+d;                                     \/\/ neighbor cell in direction d\n    if (min(P.x,P.y)<0. || max(P.x,P.y)>7.) return;   \/\/ is out of board\n    \n    float v = cell(U, 0.).x;                   \/\/ cell content in board page \n    if (v==3.-ME)                              \/\/ current cell is target color\n        if ( cell(P,0.).x == ME ) O.x = 1.;    \/\/ neighbor in direction p is me: mark cur cell \"eatable in dir d\".\n        else { float c = cell(P, d+2.).x;      \/\/ recursion to neighbor mark\n               if (c>0.) O.x = c+1.;           \/\/ food index in the line\n             }\n    else if (v == 0.)                          \/\/ current cell is free\n        O.y = cell(P, d+2.).x;                 \/\/ store #N pawn takable in direction d \n}","name":"","description":"","type":"buffer"}]}}