{"Shader":{"ver":"0.1","info":{"id":"4slGRf","date":"1375932572","viewed":1773,"name":"Moon Surface","username":"4rknova","description":"Navigating on the surface of the moon.","likes":32,"published":3,"flags":0,"tags":["raymarching","terrain","moon"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ by Nikos Papadopoulos, 4rknova \/ 2013\n\/\/ Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n#define EPS\t\t.001\n#define PI\t\t3.14159265359\n#define RADIAN\t180. \/ PI\n#define SPEED\tiGlobalTime * 1.2\n\nfloat hash(vec2 p)\n{\n    return fract(sin(dot(p,vec2(127.1,311.7))) * 43758.5453123);\n}\n\nfloat noise(vec2 p)\n{\n    vec2 i = floor(p), f = fract(p); \n\tf *= f*(3.-2.*f);\n    \n    vec2 c = vec2(0,1);\n    \n    return mix(mix(hash(i + c.xx), \n                   hash(i + c.yx), f.x),\n               mix(hash(i + c.xy), \n                   hash(i + c.yy), f.x), f.y);\n}\n\nfloat fbm(in vec2 p)\n{\n\treturn\t.5000 * noise(p)\n\t\t   +.2500 * noise(p * 2.)\n\t\t   +.1250 * noise(p * 4.)\n\t\t   +.0625 * noise(p * 8.);\n}\n\nfloat dst(vec3 p)\n{\n\treturn dot(vec3(p.x, p.y + .45 * fbm(p.zx), p.z), vec3(0.,1.,0.));\t\n}\n\nvec3 nrm(vec3 p, float d)\n{\n\treturn normalize(\n\t\t\tvec3(dst(vec3(p.x + EPS, p.y, p.z)),\n    \t\t\t dst(vec3(p.x, p.y + EPS, p.z)),\n    \t\t\t dst(vec3(p.x, p.y, p.z + EPS))) - d);\n}\n\nbool rmarch(vec3 ro, vec3 rd, out vec3 p, out vec3 n)\n{\n\tp = ro;\n\tvec3 pos = p;\n\tfloat d = 1.;\n\n\tfor (int i = 0; i < 64; i++) {\n\t\td = dst(pos);\n\n\t\tif (d < EPS) {\n\t\t\tp = pos;\n\t\t\tbreak;\n\t\t}\n\t\tpos += d * rd;\n\t}\n\t\n\tn = nrm(p, d);\n\treturn d < EPS;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\tvec2 uvn = (2. * uv - 1.)\n\t\t\t * vec2(iResolution.x \/ iResolution.y, 1.);\n\t\n\tif (abs(EPS + uvn.y) >= .7 || mod(floor(fragCoord.y),2.) > 0.) { \n\t\tfragColor = vec4(vec3(0.),1.);\n\t\treturn;\n\t}\n\n\tvec3 cu = vec3(0.,1.,0.);\n\tvec3 cp = vec3(0., 1.1 + fbm(vec2(iGlobalTime)) * .2, SPEED);\n\tvec3 ct = vec3(1.5 * sin(iGlobalTime), \n\t\t\t\t   -8. + cos(iGlobalTime) + fbm(cp.xz) * 5., 15. + SPEED);\n\t\t\n\tvec3 ro = cp,\n\t\t rd = normalize(vec3(uvn, 1. \/ tan(30. * RADIAN)));\n\t\n\tvec3 cd = ct - cp,\n\t\t rz = normalize(cd),\n\t\t rx = normalize(cross(rz, cu)),\n\t\t ry = normalize(cross(rx, rz));\n\n\trd = normalize(mat3(rx, ry, rz) * rd);\n\n\tvec3 sp, sn;\n\tvec3 col = (rmarch(ro, rd, sp, sn) ?\n\t\t  vec3(.6) * dot(sn, normalize(vec3(cp.x, cp.y + .5, cp.z) - sp))\n\t\t: vec3(0.));\n\t\n\tcol += hash(hash(uv) * uv * iGlobalTime) * .15;\n\tcol *= 1.9 * smoothstep(length(uv * .5 - .25), .8, .4);\n\tcol *= smoothstep(EPS, 3.5, iGlobalTime);\n\tfragColor = vec4(col, 1.);\n}","name":"","description":"","type":"image"}]}}