{"Shader":{"ver":"0.1","info":{"id":"4tSSRh","date":"1441505713","viewed":807,"name":"Metaeaux - Marball blobs","username":"metaeaux","description":"Learning to do textures, shadows and deformations","likes":1,"published":3,"flags":0,"tags":["raymarchingbasics"],"hasliked":0},"renderpass":[{"inputs":[{"id":8,"src":"\/presets\/tex07.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":9,"src":"\/presets\/tex08.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":10,"src":"\/presets\/tex09.jpg","ctype":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"float dancingSphere(vec3 p, float rad) {\n    float undulate = 5. * sin(iGlobalTime * 0.2);\n    float radius = rad + 0.1 * (sin(p.x * undulate ) + sin(p.y * undulate +  2.*iGlobalTime));\n    return length(p) - radius;\n}\n\nvec4 sphereColor( in vec3 pos, in vec3 nor, in sampler2D iChannel)\n{\n\tvec2 uv = vec2( atan( nor.x, nor.z ), acos(nor.y) );\n    vec3 col = (texture2D( iChannel, uv ).xyz);\n    float ao = clamp( 0.75 + 0.25*nor.y, 0.0, 1.0 );\n    return vec4( col, ao );\n}\n\nvec4 floorColor( in vec3 pos, in vec3 nor )\n{\n    vec3 col = texture2D( iChannel1, 0.5*pos.xz ).xyz;\n\t\n    \/\/ fake ao\n    float f = smoothstep( 0.1, 1.75, length(pos.xz) );\n\n\treturn vec4(col, 0.5*f+0.5*f*f);\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  float undulate = 5. * cos(iGlobalTime * 0.2);\n  float radius = r + 0.1 * (sin(p.x * undulate ) + sin(p.y * undulate +  2.*iGlobalTime));\n  return length(max(abs(p)-b,0.0))-r*radius;\n}\n\nfloat plane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\n\/\/ subtraction\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\n\/\/ union\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn d1.x < d2.x ? d1 : d2;\n}\n\n\/\/ intersection\nvec2 opI( vec2 d1, vec2 d2 )\n{\n    return d1.x > d2.x ? d1 : d2;\n}\n\nvec2 map(vec3 p) {\n    \n    vec2 d = opU(vec2(dancingSphere(p - vec3(1.5, 0., 0.), 1.), 1.), vec2(p.y + 2., 2.));\n    \n    d = opU(d, vec2(udRoundBox(p - vec3(-1.5, 0., 0.), vec3(.0, 0., 0.), 1.), 3.));\n    \n    return d;\n}\n\nvec3 normal(vec3 pos) {\n    vec3 e = vec3(0.00001, 0., 0.);\n    vec3 nor = normalize( vec3(map(pos+e.xyy).x - map(pos-e.xyy).x,\n                               map(pos+e.yxy).x - map(pos-e.yxy).x,\n                               map(pos+e.yyx).x - map(pos-e.yyx).x));\n    return nor;\n}\n\nfloat shadow( in vec3 ro, in vec3 rd, in float maxt)\n{\n\tfloat res = 1.0;\n    float dt = 0.04;\n    float t = .02;\n    for( int i=0; i < 20; i++ )\n    {       \n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, maxt*h\/t );\n        t += h;\n    }\n    return res;\n}\n\nvec3 raymarch(in vec3 ro, in vec3 rd, in float tmax)\n{\n\tvec2 h = vec2(0.);\n    float t = 0.;\n    \n    for(int i = 0; i < 64; i++)\n    {\n     \th = map(ro + t * rd);\n        t += h.x;\n        if( h.x < 0.001) break;\n        if(t > tmax) return vec3(t, h.x, -1.);\n    }\n    \n    return vec3(t, h);\n    \n}\n\nvec4 selectColour(in float index, in vec3 pos, in vec3 nor) {\n    vec4 ambient = 1.5 * vec4(0.1, 0.15, 0.2, 1.);\n    vec4 planeColour = vec4(1.);\n    vec4 blobColour = vec4(0.6, 0.8, 1., 1.);\n    \n    if (index == 1.) return sphereColor(pos, nor, iChannel3); \/\/blobColour;\n    else if(index == 2.) return planeColour;\n    else if(index == 3.) return sphereColor(pos, nor, iChannel2);\n    else return ambient; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float grid = 4.;\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec2 p = uv * grid - grid\/2.;\n    \n    p.x *= iResolution.x\/iResolution.y;\n    \n    vec3 eye = vec3(0., 0., 0.);\n    vec3 up = normalize(vec3(0., 1., 0.5));\n    vec3 right = vec3(1., 0., 0.);\n    vec3 forward = normalize(vec3(0., 2., -4.));\n    float focalLength = 2.;\n\n    vec3 ro = forward*focalLength + right * p.x + up * p.y;\n    vec3 rd = normalize(cross(right, up));    \n    vec4 col = vec4(0.);\n    vec3 lig = vec3(0.9*cos(iGlobalTime), 0.9, 0.9*sin(iGlobalTime));\n    vec4 ambient = 1.5 * vec4(0.1, 0.15, 0.2, 1.);\n    vec3 planeColour = vec3(1.);\n    vec3 blobColour = vec3(0.6, 0.8, 1.);\n    float tmax = 20.0;\n    \n    \/\/ lets raymarch!\n    vec3 march = raymarch(ro, rd, tmax);\n    vec2 h = march.yz;\n    float t = march.x;\n    \n    \/\/ did we intersect the primitive?\n    if(t < tmax) {\n    \tvec3 pos = ro + t * rd;\n        vec3 e = vec3(0.0001, 0., 0.);\n        vec3 nor = normal(pos);\n        \n        col = selectColour(h.y, pos, nor);\n        \n        float lambert = clamp(dot(normalize(nor), normalize(lig)), 0., 1.);\n        float phong = pow(lambert,128.);\n        \n        \/\/ lambert shading and ambient colour\n        col = clamp(col*lambert + ambient * (1.0 - lambert) + phong, 0., 1.);  \n        \n        \/\/ shadow and ambient colour\n        float sh = shadow( pos, lig, 1.0);\n\t\tcol *= sh  + ambient * (1.0 - sh);\n        \n    }\n    \n    \n\tfragColor = col;\n}","name":"","description":"","type":"image"}]}}