{"Shader":{"ver":"0.1","info":{"id":"4stGWX","date":"1453452987","viewed":188,"name":"Gaussian AA Test","username":"tsone","description":"Testing anti-aliasing with coverage estimated with Gaussian. Uses one edge for the estimate. Click to show the render without anti-aliasing. Based on eiffie's shader: https:\/\/www.shadertoy.com\/view\/ldSGRz","likes":5,"published":3,"flags":0,"tags":["antialias","gaussian"],"hasliked":0},"renderpass":[{"inputs":[{"id":17,"src":"\/presets\/tex12.png","ctype":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\n#define SQRT2    1.414213562373095\n#define SQRT3    1.732050807568877\n\n#define MARCH_ITERATIONS 90\n#define MARCH_THRESHOLD .00001\n\n\/\/#define FISHEYE_AMOUNT .0\n#define FISHEYE_AMOUNT (-.3-.3*sin(.3*iGlobalTime))\n\n#define MAX_DEPTH 270.\n\n\nfloat sqr(float x) { return x*x; }\n\n\nmat3 rot_mat;\nfloat pxg, pxn;\n\n\nmat3 rot_z(in float a) {\n\tfloat ca = cos(a);\n\tfloat sa = sin(a);\n\treturn mat3(\n\t\tca,sa,0.0,\n\t\t-sa,ca,0.0,\n\t\t0.0,0.0,1.0\n\t);\n}\n\nmat3 rot_y(in float a) {\n\tfloat ca = cos(a);\n\tfloat sa = sin(a);\n\treturn mat3(\n\t\tca,0.0,sa,\n\t\t0.0,1.0,0.0,\n\t\t-sa,0.0,ca\n\t);\n}\n\nmat3 rot_x(in float a) {\n\tfloat ca = cos(a);\n\tfloat sa = sin(a);\n\treturn mat3(\n\t\t1.0,0.0,0.0,\n\t\t0.0,ca,sa,\n\t\t0.0,-sa,ca\n\t);\n}\n\nfloat BoxRounded(in vec3 p, in vec3 s, float r)\n{\n    p = max(abs(p) - s, 0.);\n\treturn length(p) - r;\n}\n\nfloat Map(in vec3 p)\n{\n    p = mod(p + 6., 12.) - 6.;\n    p = abs(p);\n\tfloat d0 = BoxRounded(p, vec3(2.7), .1);\n\tfloat d1 = BoxRounded(p+vec3(-2.8), vec3(1.7), .1);\n    return max(d0, -d1);\n}\n\nvec3 CameraRayDir(in vec2 fragCoord)\n{\n\tvec2 uv = (2.*fragCoord - iResolution.xy) \/ length(iResolution.xy);\n\treturn normalize(vec3(SQRT2 * uv, 1. + FISHEYE_AMOUNT * dot(uv, uv)));\n}\n\nvoid Camera(out vec3 P, out vec3 D, in vec2 fragCoord)\n{\n    D = CameraRayDir(fragCoord);\n    \n    \/\/ Calc 'px' as delta of D (=ray direction) to neighboring farthest pixel.\n    vec3 D2 = CameraRayDir(fragCoord + sign(D.xy));\n    float px = length(D2 - D);\n    \/\/ 'px' for normal calculation. SQRT3 scale distance to cover a sphere around px cube.\n    pxn = SQRT3 * px;\n    \/\/ 'px' for Gaussian coverage. SQRT2 is from 1\/2 scaler in the exponent in\n    \/\/ Gaussian distribution. It is transformed into our scaler. Divisor 3 sets\n    \/\/ the distribution to cover 99% of the value inside px distance.\n    \/\/ See: https:\/\/en.wikipedia.org\/wiki\/Gaussian_filter\n    pxg = SQRT2 * px \/ 3.;\n    \n    \/\/ Position and rotate camera.\n    P = rot_mat * vec3(0.0,-.5,-10.);\n\tD = rot_mat * D;\n}\n\nvec3 Normal(in vec3 p, float t)\n{\n    vec2 v = vec2(t * pxn, 0.);\n\tfloat d1 = Map(p-v.xyy), d2 = Map(p+v.xyy);\n\tfloat d3 = Map(p-v.yxy), d4 = Map(p+v.yxy);\n\tfloat d5 = Map(p-v.yyx), d6 = Map(p+v.yyx);\n\treturn normalize(vec3(-d1+d2,-d3+d4,-d5+d6));\n}\n\nstruct MarchResult\n{\n    vec2 edge;\n    float t;\n    float d;\n};\n    \nvec3 Shade(in vec3 P, in vec3 D, float t, in vec3 L)\n{\n    P += t * D;\n\tvec3 N = Normal(P, t);\n    float NdotL = max(dot(N, L), 0.);\n    return vec3(NdotL);\n}\n\nvec3 SampleGauss(in vec3 srccolor, in vec3 dstcolor, float t, float d)\n{\n    return mix(srccolor, dstcolor, exp(-sqr(d) \/ sqr(t * pxg)));\n}\n\nvec3 Color(in vec3 P, in vec3 D, in vec3 L, in MarchResult r, bool disable_aa) {\n    vec3 color = vec3(sqr(.5*D.y + .5));\n    if (disable_aa && r.d <= MARCH_THRESHOLD) {\n    \tcolor = Shade(P, D, r.t, L);\n    } else {\n        color = SampleGauss(color, Shade(P, D, r.t, L), r.t, r.d);\n\t    color = SampleGauss(color, Shade(P, D, r.edge.y, L), r.edge.y, r.edge.x);\n    }\n    return color;\n}\n\nMarchResult March(in vec3 ro, in vec3 rd, float rnd)\n{\n    float t = Map(ro) * (1. - .25*rnd);\n    float d = t;\n    float od = MAX_DEPTH;\n    vec2 edge = vec2(MAX_DEPTH);\n\tfor (int j = 0; j < MARCH_ITERATIONS; ++j) {\n\t\td = Map(ro + t*rd);\n        if (d > od && edge.x > od) {\n            edge = vec2(od, t-od);\n        }\n        t += d;\n        od = d;\n\t\tif (d < MARCH_THRESHOLD || t > MAX_DEPTH) {\n\t\t\tbreak;\n\t\t}\n\t}\n    \n    return MarchResult(edge, t, d);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec3 P, D;\n\tint i;\n    \n    float rnd = texture2D(iChannel0, fragCoord \/ iChannelResolution[0].xy).r;\n\n    float time = .1 * iGlobalTime;\n    rot_mat = rot_y(time)*rot_x(.75);\/\/rot_x(t)*rot_y(t)*rot_z(t);\n    \n\tCamera(P, D, fragCoord);\n\tMarchResult r = March(P, D, rnd);\n    vec3 L = rot_mat * normalize(vec3(-.15,.3,-1.));\n    \n    vec3 final = Color(P, D, L, r, iMouse.z > 0.);\n    \/\/ Reduce banding by adding noise.\n    final += rnd \/ 512.0;\n    \/\/ Gamma encode.\n    final = pow(final, vec3(1.\/2.2));\n\tfragColor = vec4(final, 1.);\n}","name":"","description":"","type":"image"}]}}