{
	"Shader": 
	[
		{
			"ver": "0.1",
			"info": 
			{
				"id": "MsBGRh",
				"date": "1383425375",
				"viewed": 1301,
				"name": "DE DoF",
				"username": "eiffie",
				"description": "This is distance estimated DoF. Now SoC. Why? Well the idea came from knighty and IQ that what I was doing with AA could be used to create DoF so I had to try. It works! With knighty's improvements it is quite fast too! Fast enough for shadows now!",
				"likes": 14,
				"published": 3,
				"tags": 
				[
					"dof",
					"fakedof",
					"soc"
				],

				"hasliked": 0
			},

			"renderpass": 
			[
				{
					"inputs": 
					[
						
					],

					"outputs": 
					[
						
					],

					"code": "\/\/ DE DOF by eiffie\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ This is an example of calculating DOF based on distance estimates. The idea of\n\/\/ gathering samples any time you are within the circle of confusion came from IQ.\n\/\/ The implementation is as simple as I could make it. The surface is treated like\n\/\/ a cloud density so the DOF can \"see around\" the edges of objects by stepping thru them.\n\/\/ Here are some open issues when using high apertures:\n\/\/ Surfaces become misshaped since lighting based on an average normal is not the same\n\/\/ as averaged lighting across many normals.\n\/\/ Color blending is rudimentary (fast though!)\n\n\/\/V2 added some of knighty's improvements (it really speeds up the march to add the CoC to DE!)\n\nconst float aperture=0.05,focalDistance=1.5,shadowCone=0.5;\/\/play with these to test the DOF\n\n#define time iGlobalTime\n#define size iResolution\n\n\n#define TAO 6.283\nvec2 Rotate(in vec2 v, float angle) {return v*mat2(cos(angle),sin(angle),-sin(angle),cos(angle));}\nvec2 Kaleido(in vec2 v,float power){return Rotate(v,floor(.5+atan(v.x,-v.y)*power\/TAO)*TAO\/power);}\nfloat HTorus(in vec3 z, float radius1, float radius2){return max(-z.y-0.055,length(vec2(length(z.xy)-radius1,z.z))-radius2-z.x*0.035);}\n\nvec3 mcol;\nfloat dB;\nfloat DE(in vec3 z0){\n\tvec4 z=vec4(z0,1.0);\n\tfloat d=max(abs(z.y+1.0)-1.0,length(z.xz)-0.13);\n\tfor(int i=0;i<4;i++){\n\t\tz.xz=Kaleido(z.xz,3.0);\n\t\tz.z+=1.0;\n\t\td=min(d,HTorus(z.zyx,1.0,0.1)\/z.w);\n\t\tz.z+=1.0;\n\t\tz*=vec4(2.0,-2.0,2.0,2.0);\n\t}\n\tz.z-=0.8;\n\tdB=(length(z.xyz)-1.0)\/z.w;\n\treturn min(d,min(dB,z0.y+1.0));\n}\nfloat CE(in vec3 z0){\/\/same but also colors\n\tfloat d=DE(z0);\n\tif(abs(d-z0.y-1.0)<0.001)mcol+=vec3(0.0,0.3,0.15);\n\telse if(abs(d-dB)<0.001)mcol+=vec3(1.0,1.0-abs(sin(z0.x*100.0)),0.0);\n\telse mcol+=vec3(0.0,abs(sin(z0.z*40.0)),1.0);\n\treturn d+abs(sin(z0.y*100.0))*0.005;\/\/just giving the surface some procedural texture\n}\nfloat rand(vec2 co){\/\/ implementation found at: lumina.sourceforge.net\/Tutorials\/Noise.html\n\treturn fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat pixelSize;\nfloat CircleOfConfusion(float t){\/\/calculates the radius of the circle of confusion at length t\n\treturn aperture*abs(t-focalDistance)+pixelSize*(1.0+t);\n}\nfloat linstep(float a, float b, float t){float v=(t-a)\/(b-a);return clamp(v,0.,1.);}\/\/from knighty\n\nfloat FuzzyShadow(vec3 ro, vec3 rd, float coneGrad, float rCoC){\n\tfloat t=0.0,d=1.0,s=1.0;\n\tro+=rd*0.01;\n\tfor(int i=0;i<8;i++){\n\t\tif(s<0.1)break;\n\t\tfloat r=rCoC+t*coneGrad;\/\/radius of cone\n\t\td=DE(ro+rd*t)+r*0.5;\n\t\ts*=linstep(-r,r,d);\n\t\tt+=abs(d)*(0.8+0.2*rand(gl_FragCoord.xy*vec2(i)));\n\t}\n\treturn clamp(s,0.0,1.0);\n}\n\nmat3 lookat(vec3 fw,vec3 up){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,normalize(up)));return mat3(rt,cross(rt,fw),fw);\n}\n\nvoid main() {\n\tpixelSize=2.5\/size.y;\n\tvec3 ro=vec3(cos(time),sin(time*0.3)*0.3,sin(time))*2.4;\/\/camera setup\n\tvec3 L=normalize(ro+vec3(0.5,2.5,-0.5));\n\tvec3 rd=lookat(-ro*vec3(1.0,2.0,1.0)-vec3(1.0,0.0,0.0),vec3(0.0,1.0,0.0))*normalize(vec3((2.0*gl_FragCoord.xy-size.xy)\/size.y,1.0));\n\tvec4 col=vec4(0.0);\/\/color accumulator\n\tfloat t=0.0;\/\/distance traveled\n\tfor(int i=1;i<48;i++){\/\/march loop\n\t\tif(col.w>0.9 || t>10.0)continue;\/\/bail if we hit a surface or go out of bounds\n\t\tfloat rCoC=CircleOfConfusion(t);\/\/calc the radius of CoC\n\t\tfloat d=DE(ro)+0.25*rCoC;\n\t\tif(d<rCoC){\/\/if we are inside add its contribution\n\t\t\tvec3 p=ro-rd*abs(d-rCoC);\/\/back up to border of CoC\n\t\t\tmcol=vec3(0.0);\/\/clear the color trap, collecting color samples with normal deltas\n\t\t\tvec2 v=vec2(rCoC*0.5,0.0);\/\/use normal deltas based on CoC radius\n\t\t\tvec3 N=normalize(vec3(-CE(p-v.xyy)+CE(p+v.xyy),-CE(p-v.yxy)+CE(p+v.yxy),-CE(p-v.yyx)+CE(p+v.yyx)));\n\t\t\t\/\/if(N!=N)N=-rd; \/\/this is sometimes needed to fake a surface normal\n\t\t\t\/\/if(dot(N,rd)<=0.0){\/\/it doesn't seem to matter if we take samples around the corners!\n\t\t\t\tvec3 scol=mcol*0.1666*max(0.1,0.25+dot(N,L)*0.75);\n\t\t\t\tscol+=pow(max(0.0,dot(reflect(rd,N),L)),8.0)*vec3(1.0,0.9,0.8);\/\/todo: adjust this for bokeh highlights????\n\t\t\t\tscol*=FuzzyShadow(p,L,shadowCone,rCoC);\/\/I wouldn't have believed this would compile but only 8 shadows steps!!!\n\t\t\t\tfloat alpha=(1.0-col.w)*linstep(-rCoC,rCoC,-d);\/\/calculate the mix like cloud density\n\t\t\t\tcol+=vec4(scol*alpha,alpha);\/\/blend in the new color\n\t\t\t\/\/}\n\t\t}\n\t\td=abs(d)*(0.8+0.2*rand(gl_FragCoord.xy*vec2(i)));\/\/add in noise to reduce banding and create fuzz\n\t\tro+=d*rd;\/\/march\n\t\tt+=d;\n\t}\/\/mix in background color\n\tvec3 scol=vec3(0.0);\/\/mix(vec3(0.0,0.275,0.15)*max(0.1,0.25+dot(vec3(0.0,1.0,0.0),L)*0.75),vec3(0.4,0.5,0.6),smoothstep(0.0,0.1,rd.y));\n\tcol.rgb+=scol*(1.0-clamp(col.w,0.0,1.0));\n\tgl_FragColor = vec4(clamp(2.0*col.rgb,0.0,1.0),1.0);\n}\n",
					"name": "",
					"description": "",
					"type": "image"
				}
			]
		}
	]
}