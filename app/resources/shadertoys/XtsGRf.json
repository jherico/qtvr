{"Shader":{"ver":"0.1","info":{"id":"XtsGRf","date":"1423876664","viewed":792,"name":"Volumetric Cube","username":"Flyguy","description":"Testing a mix of ray marching and volume ray casting.","likes":2,"published":3,"flags":0,"tags":["raymarching","volume","cube"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define RotateX(v,a) v.yz *= mat2(cos(a),sin(a),-sin(a),cos(a))\n#define RotateY(v,a) v.xz *= mat2(cos(a),sin(a),-sin(a),cos(a))\n#define RotateZ(v,a) v.xy *= mat2(cos(a),sin(a),-sin(a),cos(a))\n\n#define MIN_MARCH_DIST 0.001\n#define MAX_MARCH_STEPS 48\n#define MAX_VOLUME_STEPS 290\n#define VOLUME_STEP_SIZE 0.01\n\nvec4 Volume(vec3 pos)\n{\n    RotateY(pos,iGlobalTime);\n    RotateZ(pos,-0.5);\n    \n    float vol = dot(normalize(pos),vec3(1,0,0));\n    \n    vec3 col = mix(vec3(1.0,0.2,0.2),vec3(0.2,0.2,1.0),step(0.0,vol));\n    \n    vol = smoothstep(0.6,0.9,abs(vol));\n    \n\treturn vec4(col, max(0.0,vol)*0.01);  \n}\n\nvec3 MarchVolume(vec3 orig, vec3 dir)\n{\n    \/\/Ray march to find the cube surface.\n    float t = 0.0;\n    vec3 pos = orig;\n    for(int i = 0;i < MAX_MARCH_STEPS;i++)\n    {\n        pos = orig + dir * t;\n        float dist = 100.0;\n        \n        dist = min(dist, 8.0-length(pos));\n        dist = min(dist, max(max(abs(pos.x),abs(pos.y)),abs(pos.z))-1.0);\/\/length(pos)-1.0);\n        \n        t += dist;\n        \n        if(dist < MIN_MARCH_DIST){break;}\n    }\n    \n    \/\/Step though the volume and add up the opacity.\n    vec4 col = vec4(0.0);\n    for(int i = 0;i < MAX_VOLUME_STEPS;i++)\n    {\n    \tt += VOLUME_STEP_SIZE;\n        \n    \tpos = orig + dir * t;\n        \n        \/\/Stop if the sample becomes completely opaque or leaves the volume.\n        if(max(max(abs(pos.x),abs(pos.y)),abs(pos.z))-1.0 > 0.0) {break;}\n        \n        vec4 vol = Volume(pos);\n        vol.rgb *= vol.w;\n        \n        col += vol;\n    }\n    \n    return col.rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy \/ iResolution.y;\n\tvec2 uv = fragCoord.xy \/ iResolution.y;\n    \n    vec3 dir = normalize(vec3(uv-res\/2.0,1.0));\n    vec3 orig = vec3(0,0,-3.5);\n\n        \n    RotateX(dir,radians(iMouse.y));\n    RotateX(orig,radians(iMouse.y));\n    RotateY(dir,radians(-iMouse.x));\n    RotateY(orig,radians(-iMouse.x));\n\n    \n    vec3 color = MarchVolume(orig,dir);\n    \n\tfragColor = vec4(color, 1.0);\n}","name":"","description":"","type":"image"}]}}