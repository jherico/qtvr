{"Shader":{"ver":"0.1","info":{"id":"Md3GWf","date":"1452470850","viewed":128,"name":"Blue Noise Stippling","username":"joeedh","description":"Attempt at a procedurally generated blue noise mask.  Note that I apply a sharpening filter to the input data.","likes":8,"published":3,"flags":0,"tags":["dither","halftone","diffusion","bluenoise","stippling","ordered"],"hasliked":0},"renderpass":[{"inputs":[{"id":11,"src":"\/presets\/vid00.ogv","ctype":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/checkerboard noise\nvec2 stepnoise(vec2 p, float size) {\n    p += 10.0;\n    float x = floor(p.x\/size)*size;\n    float y = floor(p.y\/size)*size;\n    \n    x = fract(x*0.1) + 1.0 + x*0.0002;\n    y = fract(y*0.1) + 1.0 + y*0.0003;\n    \n    float a = fract(1.0 \/ (0.000001*x*y + 0.00001));\n    a = fract(1.0 \/ (0.000001234*a + 0.00001));\n    \n    float b = fract(1.0 \/ (0.000002*(x*y+x) + 0.00001));\n    b = fract(1.0 \/ (0.0000235*b + 0.00001));\n    \n    return vec2(a, b);\n    \n}\nfloat tent(float f) {\n    return 1.0 - abs(fract(f)-0.5)*2.0;\n}\n\n#define SEED1 (1.705)\n#define SEED2 (1.379)\n#define DMUL 8.12235325\n\nfloat poly(float a, float b, float c, float ta, float tb, float tc) {\n    return (a*ta + b*tb + c*tc) \/ (ta+tb+tc);\n}\nfloat mask(vec2 p) {\n    vec2 r = stepnoise(p, 5.5)-0.5;\n    p[0] += r[0]*DMUL;\n    p[1] += r[1]*DMUL;\n    \n    float f = fract(p[0]*SEED1 + p[1]\/(SEED1+0.15555))*1.03;\n    return poly(pow(f, 150.0), f*f, f, 1.0, 0.0, 1.3);\n}\n\nfloat s(float x, float y, vec2 uv) {\n    vec4 clr = texture2D(iChannel0, vec2(x, y)\/iResolution.xy + uv);\n    float f = clr[0]*0.3 + clr[1]*0.6 + clr[1]*0.1;\n    \n    return f;\n}\n\nmat3 normalize(mat3 mat) {\n    float sum = mat[0][0]+mat[0][1]+mat[0][2]\n              + mat[1][0]+mat[1][1]+mat[1][2]\n              + mat[2][0]+mat[2][1]+mat[2][2];\n    return mat \/ sum;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy;\n    vec2 uv2 = fragCoord.xy \/ iResolution.x;\n    \n    vec2 r = stepnoise(uv, 6.0);\n    \n    vec4 clr = texture2D(iChannel0, fragCoord.xy \/ iResolution.xy);\n    float slide = tent(-0.0*iGlobalTime+uv2[0]*0.5);\n    \n    float f = clr[0]*0.3 + clr[1]*0.6 + clr[1]*0.1;\n    \n    \/\/sharpen input.  this is necassary for stochastic\n    \/\/ordered dither methods.\n    vec2 uv3 = fragCoord.xy \/ iResolution.xy;\n    float d = 0.5;\n    mat3 mat = mat3(\n        vec3(d, d,   d),\n        vec3(d, 2.0, d),\n        vec3(d, d,   d)\n    );\n    \n    float f1 = s(0.0, 0.0, uv3);\n    \n    mat = normalize(mat)*1.0;\n    f = s(-1.0, -1.0, uv3)*mat[0][0] + s(-1.0, 0.0, uv3)*mat[0][1] + s(-1.0, 1.0, uv3)*mat[0][2]\n      + s( 0.0, -1.0, uv3)*mat[1][0] + s( 0.0, 0.0, uv3)*mat[1][1] + s( 0.0, 1.0, uv3)*mat[1][2]\n      + s( 1.0, -1.0, uv3)*mat[2][0] + s( 1.0, 0.0, uv3)*mat[2][1] + s( 1.0, 1.0, uv3)*mat[2][2];\n    \n    f = (f-s(0.0, 0.0, uv3));\n    f *= 40.0;\n    f = f1 - f;\n    \n    float c = mask(uv);\n    \n    if (uv2[1] < 0.05) {\n        c = float(slide >= c);\n    } else {\n\t    c = float(f >= c);\n    }\n    \n\tfragColor = vec4(c, c, c, 1.0);\n}","name":"","description":"","type":"image"}]}}