{"Shader":{"ver":"0.1","info":{"id":"MdfGWn","date":"1367026689","viewed":6112,"name":"Ellipse - Distance Estimation","username":"iq","description":"If a circle is deformed into an ellipse distances are nor preserved, and hence its thickness is not constant (left). A (first order) distance estimation can be done by diving the implicit by the modulo of its gradient, producing constant thickness (right)","likes":19,"published":3,"flags":0,"tags":["2d"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ An example on how to compute a distance estimation for an ellipse (which provides\n\/\/ constant thickness to its boundary). This is achieved by dividing the implicit \n\/\/ description by the modulo of its gradient. The same process can be applied to any\n\/\/ shape defined by an implicity formula (ellipses, metaballs, fractals, mandelbulbs).\n\/\/\n\/\/ top    left : f(x,y)\n\/\/ top    right: f(x,y) divided by analytical gradient\n\/\/ bottom left : f(x,y) divided by numerical GPU gradient\n\/\/ bottom right: f(x,y) divided by numerical gradient\n\/\/\n\/\/ More info here:\n\/\/\n\/\/ http:\/\/www.iquilezles.org\/www\/articles\/distance\/distance.htm\n\nfloat a = 1.0;\nfloat b = 3.0;\nfloat r = 0.9 + 0.1*sin(3.1415927*iGlobalTime);\n\nfloat e = 2.0\/iResolution.y;\n\n\/\/ f(x,y) (top left)\nfloat ellipse1(vec2 p)\n{\n    float f = abs(length( p*vec2(a,b) )-r);\n    return f;\n}\n\n\/\/ f(x,y) divided by analytical gradient (top right)\nfloat ellipse2(vec2 p)\n{\n    float f = length( p*vec2(a,b) );\n    return abs(f-r)*f\/(length(p*vec2(a*a,b*b)));\n}\n\n\/\/ f(x,y) divided by numerical GPU gradient (bottom left)\nfloat ellipse3(vec2 p)\n{\n    float f = ellipse1(p);\n    float g = length( vec2(dFdx(f),dFdy(f))\/e );\n\treturn f\/g;\n}\n\n\/\/ f(x,y) divided by numerical gradient (bottom right)\nfloat ellipse4(vec2 p)\n{\n    float f = ellipse1(p);\n    float g = length( vec2(ellipse1(p+vec2(e,0.0))-ellipse1(p-vec2(e,0.0)),\n                           ellipse1(p+vec2(0.0,e))-ellipse1(p-vec2(0.0,e))) )\/(2.0*e);\n    return f\/ g;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord.xy-iResolution.xy) \/ iResolution.y;\n    \n\tfloat f1 = ellipse1(uv);\n\tfloat f2 = ellipse2(uv);\n\tfloat f3 = ellipse3(uv);\n\tfloat f4 = ellipse4(uv);\n\t\n\tvec3 col = vec3(0.3);\n\n    \/\/ ellipse     \n    float f = mix( mix(f1,f2,step(0.0,uv.x)), \n                   mix(f3,f4,step(0.0,uv.x)), \n                   step(uv.y,0.0) );\n    \n\tcol = mix( col, vec3(1.0,0.6,0.2), 1.0-smoothstep( 0.1, 0.11, f ) );\n    \n    \/\/ lines    \n\tcol *= smoothstep( e, 2.0*e, abs(uv.x) );\n\tcol *= smoothstep( e, 2.0*e, abs(uv.y) );\n\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}