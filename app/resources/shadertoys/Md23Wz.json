{"Shader":{"ver":"0.1","info":{"id":"Md23Wz","date":"1386531457","viewed":2372,"name":"Mars Jetpack","username":"Dave_Hoskins","description":"Uses sphere tracing to accumulate normals across the landscape. Materials are calculated after the tracing loop, so only the normal can be used as reference. Sphere diameter to create depth of field is distance squared.  http:\/\/youtu.be\/2eSb8zB4dBo","likes":51,"published":3,"flags":64,"tags":["3d","raymarch","spheretracing","mars","marsjetpack","soundcloud"],"hasliked":0},"renderpass":[{"inputs":[{"id":17,"src":"\/presets\/tex12.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":171,"src":"https:\/\/soundcloud.com\/etokaminiature\/zzzzra-vertige-version-excessive","ctype":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Mars Jetpack. By David Hoskins, December 2013.\n\/\/ https:\/\/www.shadertoy.com\/view\/Md23Wz\n\n\/\/ YouTube:-\n\/\/ http:\/\/youtu.be\/2eSb8zB4dBo\n\n\/\/ Uses sphere tracing to accumulate direction normals across the landscape.\n\/\/ Materials are calculated after the tracing loop,\n\/\/ so only the normal can be used as reference.\n\/\/ Sphere diameter to create depth of field is distance squared.\n\n\/\/ For red\/cyan 3D. Red on the left.\n\/\/ #define STEREO\n\n\/\/ Uncomment this for a faster landscape that uses a texture for the fractal:-\n#define FASTER_LANDSCAPE\n\nvec3 sunLight  = normalize( vec3(  0.35, 0.1,  0.3 ) );\nconst vec3 sunColour = vec3(1.0, .75, .5);\nvec2 coord;\n\n\n\/\/--------------------------------------------------------------------------\n\/\/ Noise functions...\nfloat Hash( float n )\n{\n    return fract(sin(n)*33753.545383);\n}\nfloat Linstep(float a, float b, float t)\n{\n\treturn clamp((t-a)\/(b-a),0.,1.);\n\n}\n\n#ifdef FASTER_LANDSCAPE\n\/\/--------------------------------------------------------------------------\n\n#define STEP (1.0\/256.0)\nvec3 NoiseD( in vec2 p )\n{\n    vec2 f = fract(p);\n    p = floor(p);\n    vec2 u = f*f*(1.5-f)*2.0;\n    vec4 n;\n\tn.x = texture2D( iChannel0, (p+vec2(0.5,0.5))*STEP, -100.0 ).x;\n\tn.y = texture2D( iChannel0, (p+vec2(1.5,0.5))*STEP, -100.0 ).x;\n\tn.z = texture2D( iChannel0, (p+vec2(0.5,1.5))*STEP, -100.0 ).x;\n\tn.w = texture2D( iChannel0, (p+vec2(1.5,1.5))*STEP, -100.0 ).x;\n\n    \/\/ Normally you can make a texture out of these 4 so\n    \/\/ you don't have to do any of it again...\n    n.yzw = vec3(n.x-n.y-n.z+n.w, n.y-n.x, n.z-n.x);\n    vec2 d = 6.0*f*(f-1.0)*(n.zw+n.y*u.yx);\n    \n\treturn vec3(n.x + n.z * u.x + n.w * u.y + n.y * u.x * u.y, d.x, d.y);\n}\n#else\n\n\n\n\/\/--------------------------------------------------------------------------\nvec3 NoiseD( in vec2 x )\n{\n\tx+=4.2;\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\t\/\/vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    float n = p.x + p.y*57.0;\n\n    float a = Hash(n+  0.0);\n    float b = Hash(n+  1.0);\n    float c = Hash(n+ 57.0);\n    float d = Hash(n+ 58.0);\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(f-1.0)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n#endif\n\/\/--------------------------------------------------------------------------\n#define START_HEIGHT 400.0\n#define WARP  .15\n#define SCALE  .002\n#define HEIGHT 40.0\n#define LACUNARITY 1.83\nconst mat2 rotate2D = mat2(1.732, 1.543, -1.543, 1.782);\nfloat Terrain( in vec2 p)\n{\n\tp *= SCALE;\n\tfloat sum = 0.0;\n\tfloat freq = 1.;\n\tfloat amp = 3.5;\n\tvec2 dsum = vec2(0,0);\n\tfor(int i=0; i < 5; i++)\n\t{\n\t\tvec3 n = NoiseD(p + (WARP * dsum * freq));\n\t\tsum += amp * (1.0 - abs(n.x-.5)*2.0);\n\t\tdsum += amp * n.yz * -n.x;\n\t\tfreq *= LACUNARITY;\n\t\tamp = amp*.5 * min(sum*.5, .9);\n\t\tp = rotate2D * p;\n\t}\n\treturn sum * HEIGHT;\n\t\n}\n\n\/\/--------------------------------------------------------------------------\nfloat Terrain2( in vec2 p, in float sphereR)\n{\n\tp *= SCALE;\n\tfloat sum = 0.0;\n\tfloat freq = 1.0;\n\tfloat amp = 3.5;\n\tvec2 dsum = vec2(0,0);\n\tfor(int i=0; i < 8; i++)\n\t{\n\t\tvec3 n = NoiseD(p + (WARP * dsum * freq));\n\t\tsum += amp * (1.0 - abs(n.x-.5)*2.0);\n\t\tdsum += amp * n.yz * -n.x;\n\t\tfreq *= LACUNARITY;\n\t\tamp = amp * .5 * min(sum*.5, .9);\n\t\tp = rotate2D * p;\n\t}\n\treturn sum * HEIGHT;\n}\n\n\/\/--------------------------------------------------------------------------\nfloat Terrain3( in vec2 p)\n{\n\tp *= SCALE;\n\t float sum = 0.0;\n\t float freq = 1.0;\n\tfloat amp = 3.5;\n\t vec2 dsum = vec2(0,0);\n\n\t for(int i=0; i < 3; i++)\n\t {\n\t\tvec3 n = NoiseD(p + (WARP * dsum * freq));\n\t\tsum += amp * (1.0 - abs(n.x-.5)*2.0);\n\t\tdsum += amp * n.yz * -n.x;\n\t\tfreq *= LACUNARITY;\n\t\tamp = amp*.5 * min(sum*.5, .9);\n\t\tp = rotate2D * p;\n\t}\n\treturn sum * HEIGHT+20.0;\n\n}\n\n\n\/\/--------------------------------------------------------------------------\nfloat Map(in vec3 p)\n{\n\tfloat h = Terrain(p.xz);\n    return p.y - h;\n}\n\n\/\/--------------------------------------------------------------------------\n\/\/ Grab all sky information for a given ray from camera\nvec3 GetSky(in vec3 rd)\n{\n\tfloat sunAmount = max( dot( rd, sunLight), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(vec3(.015,0.0,.01), vec3(.42, .2, .1), v);\n\t\/\/sky *= smoothstep(-0.3, .0, rd.y);\n\tsky = sky + sunColour * sunAmount * sunAmount * .25;\n\tsky = sky + sunColour * min(pow(sunAmount, 800.0)*1.5, .3);\n\treturn clamp(sky, 0.0, 1.0);\n}\n\n\/\/--------------------------------------------------------------------------\nfloat SphereRadius(float t)\n{\n\tt = abs(t-250.0);\n\tt *= 0.01;\n\treturn clamp(t*t, 50.0\/iResolution.y, 80.0);\n}\n\n\/\/--------------------------------------------------------------------------\n\/\/ Calculate sun light...\nvec3 DoLighting(in vec3 mat, in vec3 normal, in vec3 eyeDir)\n{\n\tfloat h = dot(sunLight,normal);\n\tmat = mat * sunColour*(max(h, 0.0));\n\tmat += vec3(0.04, .02,.02) * max(normal.y, 0.0);\n\treturn mat;\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 GetNormal(vec3 p, float sphereR)\n{\n\tvec2 j = vec2(sphereR, 0.0);\n\tvec3 nor  \t= vec3(0.0,\t\tTerrain2(p.xz, sphereR), 0.0);\n\tvec3 v2\t\t= nor-vec3(j.x,\tTerrain2(p.xz+j, sphereR), 0.0);\n\tvec3 v3\t\t= nor-vec3(0.0,\tTerrain2(p.xz-j.yx, sphereR), -j.x);\n\tnor = cross(v2, v3);\n\treturn normalize(nor);\n}\n\n\/\/--------------------------------------------------------------------------\nvec4 Scene(in vec3 rO, in vec3 rD)\n{\n    \/\/float t = 0.0;\n\tfloat t = 20.0 * texture2D(iChannel0, coord.xy \/ iChannelResolution[0].xy).y;\n\tfloat alpha;\n\tvec4 normal = vec4(0.0);\n\tvec3 p = vec3(0.0);\n\tfloat oldT = 0.0;\n\tfor( int j=0; j < 105; j++ )\n\t{\n\t\tif (normal.w >= .8 || t > 1400.0) break;\n\t\tp = rO + t*rD;\n\t\tfloat sphereR = SphereRadius(t);\n\t\tfloat h = Map(p);\n\t\tif( h < sphereR)\n\t\t{\n\t\t\t\/\/ Accumulate the normals...\n\t\t\t\/\/vec3 nor = GetNormal(rO + BinarySubdivision(rO, rD, t, oldT, sphereR) * rD, sphereR);\n\t\t\tvec3 nor = GetNormal(p, sphereR);\n\t\t\talpha = (1.0 - normal.w) * ((sphereR-h) \/ sphereR);\n\t\t\tnormal += vec4(nor * alpha, alpha);\n\t\t}\n\t\toldT = t;\n\t\tt +=  h*.5 + t * .003;\n\t}\n\tnormal.xyz = normalize(normal.xyz);\n\t\/\/ Scale the alpha up to 1.0...\n\tnormal.w = clamp(normal.w * (1.0 \/ .8), 0.0, 1.0);\n\t\/\/ Fog...   :)\n\tnormal.w \/= 1.0+(smoothstep(300.0, 1400.0, t) * 2.0);\n\treturn normal;\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 CameraPath( float t )\n{\n    vec2 p = vec2(400.0 * sin(3.54*t), 400.0 * cos(2.0*t) );\n\treturn vec3(p.x+440.0,  0.0, p.y+10.0);\n} \n\nfloat Hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 33758.5453)-.5;\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 PostEffects(vec3 rgb, vec2 xy)\n{\n\t\/\/ Gamma first...\n\trgb = pow(rgb, vec3(0.45));\n\n\t\/\/ Then...\n\t#define CONTRAST 1.2\n\t#define SATURATION 1.3\n\t#define BRIGHTNESS 1.4\n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\n\t\/\/ Noise...\n\t\/\/ rgb = clamp(rgb+Hash(xy*iGlobalTime)*.1, 0.0, 1.0);\n\t\/\/ Vignette...\n\trgb *= .4+0.5*pow(40.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.2 );\t\n\n\treturn rgb;\n}\n\n\/\/--------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat m = (iMouse.x\/iResolution.x)*300.0;\n\tfloat gTime = (iGlobalTime*8.0+m+2321.0)*.006;\n    vec2 xy = fragCoord.xy \/ iResolution.xy;\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x\/iResolution.y,1.0);\n    coord = fragCoord \/ iChannelResolution[0].xy;\n\tvec3 camTar;\n\t\n\tfloat hTime = mod(gTime+1.95, 2.0);\n\t\n\t#ifdef STEREO\n\tfloat isRed = mod(fragCoord.x + mod(fragCoord.y,2.0),2.0);\n\t#endif\n\n\tvec3 cameraPos = CameraPath(gTime + 0.0);\n\n\t\/\/float height = 300.-hTime*24.0;\n\tfloat height = (smoothstep(.3, 0.0, hTime) + smoothstep(1.7, 2.0, hTime)) * 400.0;\n\tcamTar\t = CameraPath(gTime + .3);\n\tcameraPos.y += height;\n\t\n\tfloat t = Terrain3(CameraPath(gTime + .009).xz)+20.0;\n\tif (cameraPos.y < t) cameraPos.y = t;\n\tcamTar.y = cameraPos.y-clamp(height-40.0, 0.0, 100.0);\n\n\tfloat roll = .4*sin(gTime+.5);\n\tvec3 cw = normalize(camTar-cameraPos);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = cross(cw,cp);\n\tvec3 cv = cross(cu,cw);\n\tvec3 dir = normalize(uv.x*cu + uv.y*cv + 1.1*cw);\n\tmat3 camMat = mat3(cu, cv, cw);\n\n\t#ifdef STEREO\n\tcameraPos += 1.5*cu*isRed; \/\/ move camera to the right - the rd vector is still good\n\t#endif\n\n\tvec3 col;\n\tfloat distance;\n\tvec4 normal;\n\tnormal = Scene(cameraPos, dir);\n\t\n\tcol = mix(vec3(.4, 0.5, 0.5), vec3(.7, .35, .1),smoothstep(0.8, 1.1, (normal.y)));\n\tcol = mix(col, vec3(0.17, 0.05, 0.0), clamp(normal.z+.2, 0.0, 1.0));\n\tcol = mix(col, vec3(.8, .8,.5), clamp((normal.x-.6)*1.3, 0.0, 1.0));\n\n\tif (normal.w > 0.0) col = DoLighting(col, normal.xyz, dir);\n\n\tcol = mix(GetSky(dir), col, normal.w);\n\n\t\/\/ bri is the brightness of sun at the centre of the camera direction.\n\t\/\/ Yeah, the lens flares is not exactly subtle, but it was good fun making it.\n\tfloat bri = dot(cw, sunLight)*.7;\n\tif (bri > 0.0)\n\t{\n\t\tvec2 sunPos = vec2( dot( sunLight, cu ), dot( sunLight, cv ) );\n\t\tvec2 uvT = uv-sunPos;\n\t\tuvT = uvT*(length(uvT));\n\t\tbri = pow(bri, 6.0)*.8;\n\n\t\t\/\/ glare = the red shifted blob...\n\t\tfloat glare1 = max(dot(normalize(vec3(dir.x, dir.y+.3, dir.z)),sunLight),0.0)*1.4;\n\t\t\/\/ glare2 is the yellow ring...\n\t\tfloat glare2 = max(1.0-length(uvT+sunPos*.5)*4.0, 0.0);\n\t\tuvT = mix (uvT, uv, -2.3);\n\t\t\/\/ glare3 is a purple splodge...\n\t\tfloat glare3 = max(1.0-length(uvT+sunPos*5.0)*1.2, 0.0);\n\n\t\tcol += bri * vec3(1.0, .0, .0)  * pow(glare1, 12.5)*.05;\n\t\tcol += bri * vec3(1.0, .5, 0.5) * pow(glare2, 2.0)*2.5;\n\t\tcol += bri * sunColour * pow(glare3, 2.0)*3.0;\n\t}\n\tcol = PostEffects(col, xy);\t\n\t\n\t#ifdef STEREO\t\n\tcol *= vec3( isRed, 1.0-isRed, 1.0-isRed );\t\n\t#endif\n\t\n\tfragColor=vec4(col,1.0);\n}\n\n\/\/--------------------------------------------------------------------------","name":"","description":"","type":"image"}]}}