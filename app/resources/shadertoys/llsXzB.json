{"Shader":{"ver":"0.1","info":{"id":"llsXzB","date":"1437753164","viewed":891,"name":"Oren Nayar Light Model","username":"aiekick","description":"I tried to do the Oren Nayar Light Model explained here :<br\/> <a href=\"\/\/https:\/\/en.wikipedia.org\/wiki\/Oren%E2%80%93Nayar_reflectance_model\"  class=\"regular\" target=\"_blank\">Oren Nayar Light Model<\/a><br\/>I dont know if i have well writed the model, because the light change while the cam move..","likes":4,"published":3,"flags":0,"tags":["light","model","oren","nayar"],"hasliked":0},"renderpass":[{"inputs":[{"id":22,"src":"\/presets\/cube00_0.jpg","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"const vec2 RMPrec = vec2(0.5, 0.01); \/\/ ray marching tolerance precision \/\/ low, high\nconst vec2 DPrec = vec2(0.0001, 100.); \/\/ ray marching distance precision \/\/ low, high\n\n#define mPi 3.14159\n#define m2Pi 6.28318\n\nvec2 s,g,m;\n\n\/\/ metric\nfloat lenABC(vec3 p, vec3 ABC){return pow(pow(p.x*p.x, ABC.x) + pow(p.y*p.y, ABC.y) + pow(p.z*p.z, ABC.z), .5);}\n\nvec4 map(vec3 p)\n{\n\tvec4 col = vec4(0.);\n\t\n    float r = sin(iGlobalTime*.5)*.25+.75;\n    \n    vec3 objParams = vec3(r);\n\tcol.x = lenABC(p,objParams)-2.;\n\t\n\treturn col;\n}\n\nvec3 cam(vec2 uv, in vec3 ro, in vec3 up, in vec3 org)\n{\n\tvec3 rov = normalize(org-ro.xyz);\n    vec3 u =  normalize(cross(up, rov));\n    vec3 v =  normalize(cross(rov, u));\n    return normalize(rov + u*uv.x + v*uv.y);\n}\n\n\/\/https:\/\/en.wikipedia.org\/wiki\/Oren%E2%80%93Nayar_reflectance_model\nvec3 OrenNayarLightModel(vec3 rd, vec3 ld, vec3 n)\n{\n\tvec3 col = vec3(0.);\n\n\tfloat RDdotN = dot(-rd, n);\n\tfloat NdotLD = dot(n, ld);\n    \n    float aRDN = acos(RDdotN);\n\tfloat aNLD = acos(NdotLD);\n    \n\tfloat mu = 0.3; \/\/ roughness\n\tif (iMouse.z>0.) mu = iMouse.y\/iResolution.y;\n    \n\tfloat A = 1.-.5*mu*mu\/(mu*mu+0.57);\n\tfloat B = .45*mu*mu\/(mu*mu+0.09);\n\t\n\tfloat alpha = max(aRDN, aNLD);\n\tfloat beta = min(aRDN, aNLD);\n\t\n\tfloat albedo = 1.1;\n\t\n\tfloat e0 = 3.1;\n\tcol = vec3(albedo \/ mPi) * cos(aNLD) * (A + ( B * max(0.,cos(aRDN - aNLD)) * sin(alpha) * tan(beta)))*e0;\n\t\n\treturn col;\n}\n\n\/\/ thanks to kuvkar\nvec3 OrenNayarLightModel2(vec3 rd, vec3 ld, vec3 n)\n{\n    vec3 col = vec3(0.);\n\n    float NdotL = dot(n, ld);\n    float NdotV = dot(-rd, n);\n\n    float angleVN = acos(NdotV);\n    float angleLN = acos(NdotL);\n\n    float mu = .3; \/\/ roughness\n\tif (iMouse.z>0.) mu = iMouse.y\/iResolution.y;\n    \n    float A = 1.-.5*mu*mu\/(mu*mu+0.57);\n    float B = .45*mu*mu\/(mu*mu+0.09);\n\n    float alpha = max(angleVN, angleLN);\n    float beta = min(angleVN, angleLN);\n    float gamma = dot(-rd -(n * NdotV), ld - (n * NdotL));\n    float albedo = 1.1;\n    float e0 = 3.1;\n    float L1 = max(0.0, NdotL) * (A + B * max(0.0, gamma) * sin(alpha) * tan(beta));\n    col = vec3(1.0) * L1;\n\n    return col;\n}\nvec4 scn(vec2 uv, float t)\n{\t\n\tvec3 ro = vec3(sin(t), -sin(3.55), cos(t))*5.5;\n\tvec3 up = vec3(0,1,0);\n\tvec3 org = vec3(0);\n\t\n\tvec3 rd = cam(uv, ro, up, org);\n\t\n\tvec4 col = vec4(0.);\n\n\tfloat s = DPrec.x;\n\tfloat d = 0.;\n\tvec3 p = ro+rd*d;\n    \n\tfor(int i=0;i<200;i++)\n\t{\n\t\tif(s<DPrec.x||s>DPrec.y) break;\n\t\ts = map(p).x;\n\t\td += s*(s>DPrec.x?RMPrec.x:RMPrec.y);\n\t\tp = ro+rd*d;\n\t}\t\n    \n\tfloat lightIntensity = sin(iGlobalTime*0.5)*.5;\n\n\tif (s<DPrec.x)\n\t{\n\t\tvec2 e = vec2(0.01, 0.);\n\t\tvec3 n;\n\t\tn.x = map(p+e.xyy).x - map(p-e.xyy).x; \n\t\tn.y = map(p+e.yxy).x - map(p-e.yxy).x; \n\t\tn.z = map(p+e.yyx).x - map(p-e.yyx).x;  \n\t\tn = normalize(n); \n\t\t\n\t\tcol.rgb = g.x<m.x?\n            OrenNayarLightModel(rd, reflect(rd,n), n):\n        \tOrenNayarLightModel2(rd, reflect(rd,n), n);\n   \t\n\t}\n\telse\n\t{\n\t\tcol = textureCube(iChannel0, rd);\t\n\t}\n\t\n\treturn col;\n}\n\nvoid mainImage(out vec4 f, in vec2 gg)\n{\n\ts = iResolution.xy;\n    g = gg;\n    m = s\/2.;\n    if ( iMouse.z >0.) m=iMouse.xy;\n\tvec2 uv = (g+g-s)\/s.y;\n\t\n\tfloat t = iGlobalTime;\n\t\n\tf = scn(uv, t*.5);\n    \n    f = mix( f, vec4(0.), 1.-smoothstep( 1., 2., abs(m.x-g.x) ) );    \n}\n","name":"","description":"","type":"image"}]}}