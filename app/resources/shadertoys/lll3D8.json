{"Shader":{"ver":"0.1","info":{"id":"lll3D8","date":"1421811083","viewed":780,"name":"Grand Harmonic Matrix","username":"bergi","description":"Visualization of all integer divisors in 3D space.<br\/>(And, tatatataa, my first non-kali-set shader ;-)","likes":1,"published":3,"flags":0,"tags":["reflection","ray","mathematics","antialiasing","marching","divisors"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/*\tGrand Harmonic Matrix\n\n  \t(c) 2015, stefan berke\n\n\tlicense: aGPL3\n\n\tThe Grand Harmonic Matrix - as Jan Ten called it -\n\tis the visualization of all integer divisors in space. \n\n\tOne can argue that it is a most trivial thing. \n\tEach sphere simply represents a quotient of the term x\/y\/z (or any permutation). \n\tBut!\n\tThere are some fundamental yet unsolved problems in mathematics that relate to\n\tthese divisors. Most famous is the distribution of prime numbers. \n\tWe know the statistics, but we don't know the real numbers, unless a computer\n\tfound them for us. In fact, you can do the same with any number of divisors. \n\tPrimes have two, the most common number is four. Square numbers always have an odd\n\tnumber of divisors, etc.. They all have in common that they are quite randomly \n\tdistributed. \n\tFor me it's like a marvel. We learned to count, add and multiply, which is, \n\tagain, quite trivial. But somehow the result is above what scientists can know for\n\tsure, even after thousands of years of mathematics.\n\tFrom looking at the Grand Harmonic Matrix we can at least see immediately\n\twhy a prime is prime - in fact we don't understand why it is so hard to find the \n\tnext largest prime, because it looks so trivial. \n\tIt's much better though to only look at the 2d version for this. \n\tSee for example iq's \"Multiples\" https:\/\/www.shadertoy.com\/view\/4slXzr\n\n\tThis is the long overdue matrix-in-a-shader. \n\tYou need to play a bit with the\tcamera yourself to investigate stuff. \n\tThe default scenes show\n\t1) the origin (where the matrix is most crowded in all directions)\n\t2) a plane at faculty 7 (5040) which has A LOT of divisors\n\t3) a flight along one axis until forever ;)\n\n\tSome further reading.\n\n\thttp:\/\/www.cymatrix.org \n\t\tJan and my experimental site with .. experiments\n\thttp:\/\/divisorplot.com\n\t\tJeffrey Ventrella's excellent investigation into the 2d matrix\n\thttp:\/\/vimeo.com\/57713992\n\t\tA video where the quotients are used as notes for a synthesizer\n\t\t(one of my favorite algorithms for computational music)\n\thttp:\/\/www.fddb.org\/shows\/loco-dyna-morphics\n\t\tA more advanced composition (from about 7 to 20 min).\n\n*\/\nconst float PI = \t\t\t\t\t3.14159265;\n\nconst float SPHERE_RAD = \t\t\t0.25;\t\t\t\/\/ must be < 0.5\nconst float PRECISION = \t \t\t0.76;\t\t\t\/\/ larger radius needs smaller precission\nconst float SURFACE = \t\t\t\t0.0001;\n\nfloat time =\t\t\t\t\t\tiGlobalTime;\n\n#define COLORS\t\t\t\t\t\t1\n#define AA\t\t\t\t\t\t\t1\t\t\t\t\/\/ oversampling for anti-aliasing\n\t\t\t\t\t\t\t\t\t\t\t\t\t\/\/ totally not fast!\n\n\/* Dertermines if the components in p are divisable in any order.\n   Returns 0 or the resulting quotient. *\/\nfloat is_harmonic(in vec3 p)\n{\n    p = floor(p);\n\n    if (p.x == 0. || p.y == 0. || p.z == 0.) return 0.;\n\n    \/\/ for negative numbers, the d == floor(d) does not work\n    p = abs(p);\n    \/\/ (would need extra work here to return the correct sign)\n    \n    \/\/ there might be a more efficient way, but i never came up\n    \/\/ with one... modulo is not sufficient\n    float\n    d = p.x \/ p.y \/ p.z; if (d == floor(d)) return d;\n    d = p.x \/ p.z \/ p.y; if (d == floor(d)) return d;\n    d = p.y \/ p.x \/ p.z; if (d == floor(d)) return d;\n    d = p.y \/ p.z \/ p.x; if (d == floor(d)) return d;\n    d = p.z \/ p.x \/ p.y; if (d == floor(d)) return d;\n\td = p.z \/ p.y \/ p.x; if (d == floor(d)) return d;\n\n    return 0.;\n}\n\n\n\/\/ ---------------- raymarching -------------------\n\n\/\/ returns distance in x, quotient in y\nvec2 scene_dist(in vec3 p)\n{\n    float h = is_harmonic(p + .5);\n\n    vec3 pm = mod(p + .5, 1.) - .5;\n    \n    \/\/ no \"real distance field\"\n    \/\/ the trick is to place spheres at every grid cell\n    \/\/ but making the unwanted spheres a radius of 0.0\n    return vec2( length(pm) - SPHERE_RAD * min(1., h) + 0.001, h);\n}\n\n\/\/ for normals\n\/\/ simply puts a sphere at every grid cell\n\/\/ to avoid the quotient calculation\nfloat scene_dist_any(in vec3 p)\n{\n    vec3 pm = mod(p + .5, 1.) - .5;\n    \n    return length(pm) - SPHERE_RAD;\n}\n\n\/\/ orthonormal by nimitz \n\/\/ https:\/\/www.shadertoy.com\/view\/4sSSW3\nvec3 scene_normal(in vec3 p)\n{\n    vec3 e = vec3(-1., 1., .0) * 0.001;\n    return normalize(\n          e.xxx * scene_dist_any(p+e.xxx)\n        + e.xyy * scene_dist_any(p+e.xyy)\n        + e.yxy * scene_dist_any(p+e.yxy)\n        + e.yyx * scene_dist_any(p+e.yyx) );\n}\n\n\/\/ intensity of color as function of distance\nfloat intensity(float d) { return smoothstep(15., 0., d); }\n\n\/\/ ray has the format as in trace() below\nvec3 scene_color(in vec3 ray, in vec3 norm)\n{\n#if COLORS == 1\n    \/\/ base color from divisior\n    float a = ray.y * PI * 2. \/ 12.;\n    vec3 col = .6 + .4 * vec3(sin(a), sin(a*1.5), sin(a*2.));\n#else\n    vec3 col = vec3(.9, 1., .8);\n#endif\n    col *= .2;\n    \n    float dull = max(0., dot(vec3(.707), norm));\n    col += .3 * dull + .1 * pow(dull, 9.);\n    return col * intensity(ray.z);\n}\n\n\/\/ returns surface distance in x, \n\/\/ quotient in y, way travelled in z\nvec3 trace(in vec3 pos, in vec3 dir)\n{\n    float t = 0.;\n    vec2 d = scene_dist(pos);\n    for (int i=0; i<70; ++i)\n    {\n        if (d.x <= SURFACE)\n            continue;\n        \n        vec3 p = pos + t * dir;\n        \n        d = scene_dist(p);\n        \n        t += d.x * PRECISION;\n    }\n    \n    return vec3(d.x, d.y, t);\n}\n\n\/\/ ---------------------- path --------------------\n\nvec2 rotate(in vec2 v, float r)\n{\n\tfloat s = sin(r), c = cos(r);\n    \treturn vec2(v.x * c - v.y * s, v.x * s + v.y * c);\n}\n\nvoid path(out vec3 pos, out vec3 dir, in float ti, in vec2 uv)\n{\n    float seq = mod(ti \/ 10., 3.);\n    \/\/ fly-through\n    if (seq < 1.)\n    {\n    \tpos = vec3(.2*sin(ti), 3.+3.*sin(ti\/3.), -ti * 10.);\n    \tdir = normalize(vec3(uv, -1.1));\n        dir.yz = rotate(dir.yz, -0.3*sin(ti\/3.-1.));\n    }\n    \/\/ faculty plane\n    else if (seq < 2.)\n    {\n        pos = vec3(10.*sin(ti\/10.), 5040.5, 10.*cos(ti\/10.));\n        dir = normalize(vec3(uv, -1.5));\n        dir.xy = rotate(dir.xy, -0.5*sin(ti\/5.+2.));\n        dir.xz = rotate(dir.xz, -ti\/10. + 1. + sin(ti\/5.));\n    }\n    \/\/ origin\n    else if (seq < 3.)\n    {\n        pos = vec3(10.*sin(ti\/10.), 3.5 + 2. * sin(ti\/5.), 10.*cos(ti\/10.));\n        dir = normalize(vec3(uv, -1.5));\n        dir.yz = rotate(dir.yz, -0.5*sin(ti\/5.));\n        dir.xz = rotate(dir.xz, -ti\/10.);\n    }\n}\n\n\n\/\/ ------------------- full render step -----------------\n\nvec3 render(in vec2 uv)\n{\n    vec3 col = vec3(0.), pos, dir;\n    \n    path(pos, dir, time, uv);\n    \n    vec3 ray = trace(pos, dir);\n   \n    if (ray.x <= SURFACE)\n    {\n        vec3 p = pos + dir * ray.z;\n        vec3 n = scene_normal(p);\n        col += scene_color(ray, n);\n        float it = intensity(ray.z);\n        \n        \/\/ reflection steps\n        if (it > 0.)\n        for (int i = 0; i<2; ++i)\n        {\n            dir = reflect(dir, n);;\n            pos = p + .04 * dir;\n            ray = trace(pos, dir);\n\n            if (ray.x <= SURFACE)\n            {\n                p = pos + dir * ray.z;\n                n = scene_normal(p);\n                col += scene_color(ray, n) * it \/ (2. + float(i));\n            }\n            else continue;\n        }\n    }\n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy * 2. - 1.;\n    float aspect = iResolution.x \/ iResolution.y;\n    uv.x *= aspect;\n\n#if AA < 2\t\n    vec3 col = render(uv);\n#else\n\tvec3 col = vec3(0.);\n    for (int j=0; j<AA; ++j)\n    for (int i=0; i<AA; ++i)\n    {\n        vec2 pix = vec2(float(i), float(j)) \/ float(AA)\n            \t\t\/ (iResolution.xy);\n        col += render(uv + pix);\n    }\n    col \/= float(AA*AA);\n#endif\n    \n    fragColor = vec4(pow(col, vec3(1.\/2.2)),1.0);\n}","name":"","description":"","type":"image"}]}}