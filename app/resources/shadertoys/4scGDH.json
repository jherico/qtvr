{"Shader":{"ver":"0.1","info":{"id":"4scGDH","date":"1449472661","viewed":456,"name":"Neon Plasma Storm","username":"Nickenstein79","description":"My first effort with Shadertoy. Inspired by mu6k's Noise Plasma (https:\/\/www.shadertoy.com\/view\/XsS3Rd). I decided to turn this into a bit of tutorial for others who are new to Shaders. Updated with toggle-able CRT filter effects. Share and modify! <img src=\"\/img\/emoticonHappy.png\"\/>","likes":23,"published":3,"flags":0,"tags":["swirl","tutorial","plasma","contrast","crt","psychedelic","vignette","trig","vortex","firstshader","hash","rotozoom","distorsion","neon","tut"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":45,"src":"\/presets\/tex17.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":368,"src":"https:\/\/soundcloud.com\/binster\/clockwork","ctype":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Neon Plasma Storm (Unoptomised, so it can be a learning aid to others)\n\/\/ by Nickenstein79, Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ Inspired by mu6k's Noise plasma, which can found at: https:\/\/www.shadertoy.com\/view\/XsS3Rd\n\n\/\/ This is my first attempt with Shadertoy.\n\/\/ I've heavily commented it and left it completely unoptimised as a learning aid to other newbs.\n\/\/ There are plenty of tweekable paramaters so folks can see and learn how it all works. :)\n\/\/ (A fully optomised version will be added later. But that one will be an impenitrable wall of trig to new comers.)\n\n\/\/ Updated on 09\/12\/2015 to include a some additional toggle-able CRT-filter effects.\n\n\/\/ Awesome tune: Clockwork, by Binster\/.mepegasus - https:\/\/soundcloud.com\/binster\n\n#define NUM_LAYERS \t\t\t\t\t(7)\n#define LAYER_SEPERATION_FACTOR\t\t(0.041)\n#define ZOOM_FACTOR_PERIOD \t\t\t(40.0)  \t\/\/ The time taken for a full zoom-out\/zoom-in phase\n#define ZOOM_FACTOR_MIN \t\t\t(0.5)\n#define ZOOM_FACTOR_MAX \t\t\t(2.8)\n#define SCROLL_SPEED_AT_MIN_ZOOM\t(4.0)\n#define SCROLL_SPEED_AT_MAX_ZOOM\t(12.000001)\n#define ROTATION_MATRIX_MAX_SKEW\t(0.4)\t\t\/\/ The maximum skewing\/warping of the rotation matrix\n#define ROTATION_MATRIX_SKEW_PERIOD (7.4)\t\t\/\/ The time taken to fully skew and un-skew the rotation matrix\n\n\/\/#define CRT_FILTER_ON\t\t\t\t\t\t\t\/\/ Toggle this line to dissable\/enable the CRT Filter\n\/\/#define CRT_VIGNETTE_ON\t\t\t\t\t\t\/\/ Toggle this line to dissable\/enable the CRT-edge vignette\n\/\/#define CRT_EXTRA_NOISE_ON\t\t\t\t\t\/\/ Toggle this line to dissable\/enable the CRT-Extra Noise\n\n#define TWO_PI\t\t\t\t\t\t(6.283185307179586476925286766559)\n#define LAYER_STEP_SIZE \t\t\t(1.0\/float(NUM_LAYERS))\n\n\/\/ Returns a psuedo-random float value (in the range 0.0 to 1.0) generated from a 2D vector\n\/\/ works by combining the input seed value with prime numbers.\n\/\/ Using primes causes sequential inputs (such as pixel coordinates) to still generate non-sequential outputs.\nfloat Hash_From2D(vec2 Vec)\n{\n    float f = Vec.x + Vec.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\n \n\/\/ Returns a sin wave driven value that oscilates between Min and Max over the given time period\nfloat OscilateSinScalar(float Min, float Max, float Period)\n{\n\treturn (Max-Min) * (sin(iGlobalTime*TWO_PI\/Period)*0.5+0.5) + Min;\n}\n\n\/\/ Returns the interpolant (fraction) of CurrentValue between Min and Max in the range (0.0 to 1.0)\nfloat GetInterpolant(float Min, float Max, float CurrentValue)\n{\n    return (CurrentValue-Min) \/ (Max-Min);\n}\n\n\/\/ returns a skewed Z rotation matrix (The skewing changes over time)\nmat2 ZRotate_Skewed(float Angle)\n{\n    \/\/ Get a value to skew the rotion matrix with, which bounces between 0.0 and ROTATION_MATRIX_MAX_SKEW, over a given time period.\n    float Skew = 1.0 - OscilateSinScalar(0.0, ROTATION_MATRIX_MAX_SKEW, ROTATION_MATRIX_SKEW_PERIOD);\n    \n    \/\/ As the input angle is based on an incrimental timer multiplied by magic numbers and getting the cosine of these values,\n    \/\/ this generates an animated angle which drifts chaotically and \n    \/\/ unpredictably over time (Like a double-pendulum's motion. Actually, a triple-pendulum as we combine three cos() values).\n    \/\/ twiddle with the multiply values being passed to cos() until you like the motion of the simulation.\n\tAngle = cos(Angle*0.1)*cos(Angle*0.7)*cos(Angle*0.73)*2.0;    \n    \n    \/\/ build and return the skewed Z-rotation matrix\n    return mat2(sin(Angle * Skew),cos(Angle),-cos(Angle * Skew),sin(Angle));\n}\n\n\/\/ sample the input textures which create our desired material surface effect\nvec4 SampleMaterial(vec2 uv)\n{\n   float t = iGlobalTime * 0.5;\n   \n   \/\/ sample texture 0, just the red channel to get an initial grey-scale value in range 0.0 to 1.0\n   float Sample0 = texture2D(iChannel0, uv * 0.1 ).b;\n    \n   \/\/ Modify Sample0 by subtracting circlular patterns that grow across the texture over time\n   \/\/ fiddle with the numbers to get differening circular patterns\n   Sample0 -= 0.5 + sin(t + sin(uv.x) + sin(uv.y)) * 0.7; \n   \n   \/\/ adjust brightness\n   Sample0 *= 1.6;\n   \n   \/\/ ensure no negative values with abs(), this also causes a double\n   \/\/ concentric-circle pattern as sin() returns -1 to +1 values.\n   Sample0 = abs(Sample0);\n \n   \/\/ invert these fat bright negative-circles to get thin bright circles and curves\n   Sample0 = 1.0\/(Sample0*10.0+1.0);\n    \n   \/\/ make a greyscale colour from Sample0, then multiply it by a full-colour sample from eleswhere on texture 0\n   vec4 Colour = vec4(Sample0) * texture2D(iChannel0, uv * 0.05);\n    \n   \/\/ multiple this colour by a scrolling sample from texture 1 (random coloured noise texture)\n   \/\/ Adjust the multiplyer to expand or shrink the range of the coloured noise texture in use\n   return Colour * texture2D(iChannel1,(uv + (iGlobalTime*1.3)) * 0.001735);\n}\n\n\/\/ Generate fast downward cycling fat scanlines\nfloat scanline(vec2 uv, float TexHeight) \n{\n\treturn sin(iResolution.y * uv.y * 0.7 - iGlobalTime * 10.0);\n}\n\n\/\/ Generate slow upward cycling thin scanlines\nfloat slowscan(vec2 uv, float TexHeight) \n{\n\treturn sin(iResolution.y * uv.y * 0.02 + iGlobalTime * 6.0);\n}\n\n\/\/ warp uv coordinates to emulate a curved crt screen\nvec2 crt_bend_uv_coords(vec2 coord, float bend)\n{\n\t\/\/ put in symmetrical coords\n\t\/\/coord = (coord - 0.5) * 2.0;\n\t\/\/coord *= 0.5;\t\n\t\n\t\/\/ deform coords\n\tcoord.x *= 1.0 + pow((abs(coord.y) \/ bend), 2.0);\n\tcoord.y *= 1.0 + pow((abs(coord.x) \/ bend), 2.0);\n\n\t\/\/ transform back to 0.0 - 1.0 space\n\tcoord  = (coord \/ 1.0) + 0.5;\n\n\treturn coord;\n}\n\n\/\/ wibble the screen, crt magnetic interferance distortion effect\nvec2 scandistort(vec2 uv) \n{\n\tfloat scan1 = clamp(cos(uv.y * 2.0 + iGlobalTime), 0.0, 1.0);\n\tfloat scan2 = clamp(cos(uv.y * 2.0 + iGlobalTime + 4.0) * 10.0, 0.0, 1.0);\n\tfloat amount = scan1 * scan2 * uv.x; \n\tuv.x -= 0.05 * mix( texture2D(iChannel1, vec2(uv.x, amount)).x * amount, amount, 0.9 );\n    \n\treturn uv;\n}\n\n\/\/ CRT edge vignette\nvec3 CRT_Vignette(vec3 Colour, vec2 uv)\n{\n    uv.x \/= iResolution.x \/ iResolution.y;\n\tfloat Vignette = clamp(pow(cos(uv.x * 3.1415), 1.3) * pow(cos(uv.y * 3.1415), 1.3) * 50.0, 0.0, 1.0);\n    Colour *= Vignette;\n    \n    return Colour;    \n}\n\n\/\/ Cathode ray tube filter, to look like an old cathode ray-tube monitor with scanlines, and V-Hold, etc...\nvec3 CRT_Filter(vec3 Colour, vec2 uv)\n{\n#ifdef CRT_EXTRA_NOISE_ON    \n    Colour.r += Hash_From2D(uv * iGlobalTime * 911.911 * 4.0) * 0.19;\n    Colour.g += Hash_From2D(uv * iGlobalTime * 563.577 * 4.0) * 0.19;\n    Colour.b += Hash_From2D(uv * iGlobalTime * 487.859 * 4.0) * 0.19;\n#endif    \n    \n    vec2 sd_uv = uv;\n\tvec2 crt_uv = crt_bend_uv_coords(sd_uv, 2.0);    \n    vec3 scanline_Colour;\n\tvec3 slowscan_Colour;\n\tscanline_Colour.x = scanline(crt_uv, iResolution.y);\n    slowscan_Colour.x = slowscan(crt_uv, iResolution.y);\n    scanline_Colour.y = scanline_Colour.z = scanline_Colour.x;\n\tslowscan_Colour.y = slowscan_Colour.z = slowscan_Colour.x;\n\tColour = mix(Colour, mix(scanline_Colour, slowscan_Colour, 0.5), 0.04);\n    \n    \/\/ apply the CRT-vignette filter\n#ifdef CRT_VIGNETTE_ON\n    Colour = CRT_Vignette(Colour, uv);\n#endif     \n    \n    return Colour;\n}\n\n\/\/ Perform some post processing effects on the output colour\nvec3 PostProcessColour(vec3 Colour, vec2 uv)\n{\n    \/\/ Vignette (Darken the pixels nearer the corners of the screen)\n    Colour -= vec3(length(uv*0.1));\n    \n    \/\/ Add some random noise to the colour with the Hashing function\n\tColour += Hash_From2D(uv*iGlobalTime*0.01)*0.02;\n    \n    \/\/ apply the CRT-screen filter\n#ifdef CRT_FILTER_ON\n    Colour = CRT_Filter(Colour, uv);\n#endif \n    \n    \/\/ Approximate the brightness of the colour by using it as a 3d spacial vector and getting its length in colour space\n    float Brightness = length(Colour);\n    \n    \/\/ inrease the colour contrast, by dimming the darker colours and brightening the lighter ones, \n    \/\/ via linear interpolation of the colour and its approximated brightness value\n\tColour = mix(Colour, vec3(Brightness), Brightness - 0.5);\n    \n    return Colour;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ get a UV chord for each texel in the range -1.0 to 1.0 (so we can scale\/rotate everything from the center of the screen)\n\tvec2 uv = fragCoord.xy \/ iResolution.xy - 0.5;\n    \n    \/\/ modify the X component of the uv, by the screen's aspect ratio to avoid stretching of the input textures in width\n\tuv.x *= iResolution.x \/ iResolution.y;\n    \n    \/\/ start with black\n\tvec3 Colour = vec3(0.0, 0.0, 0.0);\n    \n    \/\/ Determine a scale value that oscilates between MIN_ZOOM and MAX_ZOOM over the desired time period\n    float ScaleValue = OscilateSinScalar(ZOOM_FACTOR_MIN, ZOOM_FACTOR_MAX, ZOOM_FACTOR_PERIOD);\n    \n    \/\/ Determine a speed to scroll through the texture space.\n    \/\/ This works by generating a speed value between MIN_SCROLL and MAX_SCROLL\n    \/\/ which is guided by the current zoom value, such that when the texture\n    \/\/ is fully zoomed out, the scroll speed is at the desired maximum, and when\n    \/\/ the texture is fully zoomed in, the scroll speed is at the desired minimum.\n    float ScrollInterpolant = GetInterpolant(ZOOM_FACTOR_MIN, ZOOM_FACTOR_MAX, ScaleValue);\n    \/\/ mix performs a linear interpolation between two inputs\n    float ScrollValue = mix(SCROLL_SPEED_AT_MIN_ZOOM, SCROLL_SPEED_AT_MAX_ZOOM, ScrollInterpolant); \n    \n\t\/\/ Sum the colour contribution of each layer   \n\tfor (float i = 0.0; i < 1.0; i += LAYER_STEP_SIZE)\n\t{\n        \/\/ clone the uv, so the original is preserved for each itteration of the loop\n\t\tvec2 uv2 = uv;\n       \n        \/\/ Rotate with a Z-Rotation matrix that skewes over time \n        \/\/ (Giving a slighlty different input angle for each layer, as i-squared is combined in)\n        uv2 *= ZRotate_Skewed(iGlobalTime * i*i * 12.0 * LAYER_SEPERATION_FACTOR);\n        \n        \/\/ Scale (Again, giving a slighlty different scale for each layer, as i-squared is combined in)\n\t\tuv2 *= ScaleValue * (i*i+1.0); \n\n        \/\/ Scroll the sampling position over time\n\t\tuv2.xy += ScrollValue + iGlobalTime*0.125;        \n        \n        \/\/ sample the material, building up each layer's colour contribution\n\t\tColour += SampleMaterial(uv2).xyz*LAYER_STEP_SIZE*3.5;\n\t}\n\t\n    \/\/ Perform some post processing on the accumulated colour layers\n    Colour = PostProcessColour(Colour, uv);\n    \n    \/\/ set the generated colour as the final output pixel colour\n\tfragColor = vec4(Colour, 1.0);\n}","name":"","description":"","type":"image"}]}}