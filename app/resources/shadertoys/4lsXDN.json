{"Shader":{"ver":"0.1","info":{"id":"4lsXDN","date":"1436942360","viewed":964,"name":"Ellipse - Distance II","username":"iq","description":"Another way to compute the distance to an ellipse (see <a href=\"https:\/\/www.shadertoy.com\/view\/4sS3zz\" class=\"regular\" target=\"_blank\">https:\/\/www.shadertoy.com\/view\/4sS3zz<\/a>)","likes":2,"published":3,"flags":0,"tags":["2d","distance","ellipse"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Computing the distance to an ellipse using David Eberly's method instead of mine\n\/\/\n\/\/ David's: http:\/\/www.geometrictools.com\/Documentation\/DistancePointEllipseEllipsoid.pdf\n\/\/\n\/\/ Mine: http:\/\/iquilezles.org\/www\/articles\/ellipsedist\/ellipsedist.htm and https:\/\/www.shadertoy.com\/view\/4sS3zz\n\nfloat rlength( vec2 v )\n{\n    \/\/return length(v);\n    \n    v = abs( v );\n    if( v.x > v.y ) return v.x * sqrt( 1.0 + (v.y\/v.x)*(v.y\/v.x) );\n    else            return v.y * sqrt( 1.0 + (v.x\/v.y)*(v.x\/v.y) );\n}\n\nfloat GetRoot( float r0, float z0, float z1, float g )\n{\n    float n0 = r0*z0;\n    float s0 = z1 - 1.0;\n    float s1 = (g<0.0) ? 0.0 : rlength( vec2(n0, z1) ) - 1.0;\n    float s = 0.0;\n    for( int i=0; i<64; i++ )\n    {\n        s = 0.5*(s0+s1);\n        \/\/if( s==s0 || s==s1 ) break;\n        vec2 ratio = vec2( n0 \/ (s + r0), z1 \/ (s + 1.0 ) );\n        g = dot(ratio,ratio) - 1.0;\n        \/\/if( g>0.0 ) { s0=s; } else  if( g<0.0 ) { s1=s; } else break;\n        if( g>0.0 ) s0=s; else s1=s;\n    }\n    return s;\n}\n\nfloat sdEllipse( vec2 p, vec2 e )\n{\n    p = abs( p );\n    \n    float dis = 0.0;\n\n    \/\/if( p.y>0.0 )\n    \/\/{\n        \/\/if( p.x>0.0 )\n        \/\/{\n            vec2 z = p \/ e;\n            float g = dot(z,z) - 1.0;\n            \/\/if( g !=0.0 )\n            {\n                float r0 = (e.x\/e.y)*(e.x\/e.y);\n                float sbar = GetRoot( r0, z.x, z.y, g );\n                vec2 r = p * vec2( r0\/(sbar+r0), 1.0\/(sbar+1.0) );\n                dis = length( p - r ) * sign( p.y - r.y );\n            }\/*\n            else\n            {\n                dis = 0.0;\n            }\n        }\n        else\n        {\n            vec2 r = vec2( 0.0, e.y );\n            dis = abs(p.y-e.y);\n        }\n    }\n    else\n    {\n        float numer0 = e.x*p.x;\n        float denom0 = e.x*e.x - e.y*e.y;\n        if( numer0 < denom0 )\n        {\n            float xde0 = numer0 \/ denom0;\n            vec2 r = e * vec2( xde0, sqrt( 1.0 - xde0*xde0 ) );\n            dis = length( p - r );\n        }\n        else\n        {\n            vec2 r = vec2( e.x, 0.0 );\n            dis = abs(p.x - e.x);\n        }\n    }\n*\/\n    return dis ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = -1.0 + 2.0 * fragCoord.xy\/iResolution.xy;\n\tuv.x *= iResolution.x\/iResolution.y;\n\t\n    vec2 m = iMouse.xy\/iResolution.xy;\n\tm.x *= iResolution.x\/iResolution.y;\n\t\n\tfloat d = sdEllipse( uv, vec2(0.3,0.3)*m + vec2(1.0,0.5)  );\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n\n\tfragColor = vec4( col, 1.0 );;\n}","name":"","description":"","type":"image"}]}}