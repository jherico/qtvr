{"Shader":{"ver":"0.1","info":{"id":"4sdGWN","date":"1449714422","viewed":890,"name":"Hemispherical SDF AO","username":"XT95","description":"Mixing the \"classical SDF AO\" with random hemisphere directions instead of the normal.<br\/>Good result, but that need more iterations and that have some self occlusion problems..<br\/><br\/>Use the mouse to compare<br\/><br\/>Any idea <img src=\"\/img\/emoticonHappy.png\"\/> ?<br\/>","likes":16,"published":3,"flags":0,"tags":["distancefield","ao","ambientocclusion","hemispherical"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by anatole duprat - XT95\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/More details here http:\/\/www.aduprat.com\/portfolio\/?page=articles\/hemisphericalSDFAO\n\nconst float PI = 3.14159265359;\n\nvec3 raymarche( in vec3 ro, in vec3 rd, in vec2 nfplane );\nvec3 normal( in vec3 p );\nfloat box( in vec3 p, in vec3 data );\nfloat map( in vec3 p );\n\nmat3 lookat( in vec3 fw, in vec3 up );\nmat3 rotate( in vec3 v, in float angle);\n\n\nfloat hash( float n )\/\/->0:1\n{\n    return fract(sin(n)*3538.5453);\n}\nvec3 randomSphereDir(vec2 rnd)\n{\n\tfloat s = rnd.x*PI*2.;\n\tfloat t = rnd.y*2.-1.;\n\treturn vec3(sin(s), cos(s), t) \/ sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n\tvec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );\n\treturn v * sign(dot(v, dir));\n}\n\nfloat ambientOcclusion( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tconst int nbIte = 32;\n    const float nbIteInv = 1.\/float(nbIte);\n    const float rad = 1.-1.*nbIteInv; \/\/Hemispherical factor (self occlusion correction)\n    \n\tfloat ao = 0.0;\n    \n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash(float(i))*maxDist;\n        vec3 rd = normalize(n+randomHemisphereDir(n, l )*rad)*l; \/\/ mix direction with the normal\n        \t\t\t\t\t\t\t\t\t\t\t\t\t    \/\/ for self occlusion problems!\n        \n        ao += (l - map( p + rd )) \/ pow(1.+l, falloff);\n    }\n\t\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n\nfloat classicAmbientOcclusion( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash(float(i))*maxDist;\n        vec3 rd = n*l;\n        \n        ao += (l - map( p + rd )) \/ pow(1.+l, falloff);\n    }\n\t\n    return clamp( 1.-ao\/float(nbIte), 0., 1.);\n}\n\n\n\/\/Shading\nvec3 shade( in vec3 p, in vec3 n, in vec3 org, in vec3 dir, vec2 v )\n{\t\t\n    vec3 col = vec3(1.);\n\t\n    float a = ambientOcclusion(p,n, 5., .9);\n    float b = classicAmbientOcclusion(p,n, 5., .9);\n    \n    if( iMouse.z > .5 ) \n    {\n        if( v.x-iMouse.x\/iResolution.x >0. )\n\t\t\tcol *= a;\n        else\n            col *= b;\n    }\n    else\n    {\n        if( v.x > 0.5 )\n\t\t\tcol *= a;\n        else\n            col *= b;\n    }\n        \n\treturn col;\n}\n\n\/\/Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\/\/screen coords\n\tvec2 q = fragCoord.xy\/iResolution.xy;\n\tvec2 v = -1.0+2.0*q;\n\tv.x *= iResolution.x\/iResolution.y;\n\t\n\t\/\/camera ray\n\tfloat ctime = (iGlobalTime)*.25;\n\tvec3 ro = vec3( cos(ctime)*5.,10.+cos(ctime*.5)*3.,-13.+sin(ctime) );\n\tvec3 rd = normalize( vec3(v.x, v.y, 1.5) );\n\trd = lookat( -ro + vec3(0., 5., 0.), vec3(0., 1., 0.) ) * rd;\n\t\n\t\/\/classic raymarching by distance field\n\tvec3 p = raymarche(ro, rd, vec2(1., 30.) );\n\tvec3 n = normal(p.xyz);\n\tvec3 col = shade(p, n, ro, rd, q);\n\t\n\t\/\/Gamma correction\n    col = pow(col, vec3(1.\/2.2));\n    \n    if( iMouse.z > .5 ) \n    {\n    \tif( abs(q.x-iMouse.x\/iResolution.x) < 1.\/iResolution.x )\n        \tcol = vec3(0.);\n    }\n    else if( abs(q.x-.5) < 1.\/iResolution.x)\n        col = vec3(0.);\n        \n\tfragColor = vec4( col, 1. );\n}\n\n\n\n\n    \nfloat map( in vec3 p )\n{\n\tfloat d = -box(p-vec3(0.,10.,0.),vec3(10.));\n\td = min(d, box(rotate(vec3(0.,1.,0.), 1.)*(p-vec3(4.,5.,6.)), vec3(3.,5.,3.)) );\n\td = min(d, box(rotate(vec3(0.,1.,0.),-1.)*(p-vec3(-4.,2.,0.)), vec3(2.)) );\n\td = max(d, -p.z-9.);\n\t\n\treturn d;\n}\n\n\nvec3 raymarche( in vec3 ro, in vec3 rd, in vec2 nfplane )\n{\n\tvec3 p = ro+rd*nfplane.x;\n\tfloat t = 0.;\n\tfor(int i=0; i<64; i++)\n\t{\n        float d = map(p);\n        t += d;\n        p += rd*d;\n\t\tif( d < 0.001 || t > nfplane.y )\n            break;\n            \n\t}\n\t\n\treturn p;\n}\nvec3 normal( in vec3 p )\n{\n\tvec3 eps = vec3(0.001, 0.0, 0.0);\n\treturn normalize( vec3(\n\t\tmap(p+eps.xyy)-map(p-eps.xyy),\n\t\tmap(p+eps.yxy)-map(p-eps.yxy),\n\t\tmap(p+eps.yyx)-map(p-eps.yyx)\n\t) );\n}\n\nfloat box( in vec3 p, in vec3 data )\n{\n    return max(max(abs(p.x)-data.x,abs(p.y)-data.y),abs(p.z)-data.z);\n}\n\n\nmat3 lookat( in vec3 fw, in vec3 up )\n{\n\tfw = normalize(fw);\n\tvec3 rt = normalize( cross(fw, normalize(up)) );\n\treturn mat3( rt, cross(rt, fw), fw );\n}\n\nmat3 rotate( in vec3 v, in float angle)\n{\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\t\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\n\n","name":"","description":"","type":"image"}]}}