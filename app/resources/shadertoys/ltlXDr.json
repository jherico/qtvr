{"Shader":{"ver":"0.1","info":{"id":"ltlXDr","date":"1436054093","viewed":943,"name":"Backscatter","username":"yupferris","description":"This was my sandbox while making the 40kb intro Backscatter by Logicoma (http:\/\/www.pouet.net\/prod.php?which=65966), which started as an exemusic entry that was too big and ended with winning the intro compo at Solskogen 2015.","likes":5,"published":3,"flags":0,"tags":["procedural","raymarching","fractal","demo","backscatter","logicoma","40k","64k","ferris","hoffman"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Thanks to iq for the noise routine, the vignette, and some repetition stuff.\n\/\/ Also thanks to mu6k for some repetion\/mirroring tricks used in ALLTHECUBES and\n\/\/ Daedelus for finding a funny bottleneck in the code structure on some GPU's :D\n\n\/\/#define BAWLS\n\/\/#define TUNNEL\n#define ALLTHECUBES\n\/\/#define SLICES\n\/\/#define TWISTERS\n\/\/#define OUTDOORZ\n\nstruct Material\n{\n    vec3 additiveColor;\n    vec3 diffuseColor;\n    vec3 specularColor;\n    float specularExponent;\n    float backgroundAmount;\n};\n   \nMaterial mixMaterials(Material a, Material b, float x)\n{\n    return Material(\n        mix(a.additiveColor, b.additiveColor, x),\n        mix(a.diffuseColor, b.diffuseColor, x),\n        mix(a.specularColor, b.specularColor, x),\n        mix(a.specularExponent, b.specularExponent, x),\n        mix(a.backgroundAmount, b.backgroundAmount, x));\n}\n\nstruct SceneResult\n{\n    float d;\n    Material material;\n};\n\nvec3 rotateX(vec3 x, float an)\n{\n    float c = cos(an);\n    float s = sin(an);\n    return vec3(x.x, x.y * c - x.z * s, x.z * c + x.y * s);\n}\n\nvec3 rotateY(vec3 x, float an)\n{\n    float c = cos(an);\n    float s = sin(an);\n    return vec3(x.x * c - x.z * s, x.y, x.z * c + x.x * s);\n}\n\nvec3 rotateZ(vec3 x, float an)\n{\n    float c = cos(an);\n    float s = sin(an);\n    return vec3(x.x * c - x.y * s, x.y * c + x.x * s, x.z);\n}\n\n\/\/ Noise by iq\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat fbm(vec3 x)\n{\n    float ret = noise(x);\n    ret += noise(x * 2.0) \/ 2.0;\n    ret += noise(x * 4.0) \/ 4.0;\n    ret += noise(x * 8.0) \/ 8.0;\n    ret += noise(x * 16.0) \/ 16.0;\n    return ret;\n}\n\nfloat fbm2(vec3 x)\n{\n    float ret = noise(x);\n    \/\/ret += noise(x * 2.0) \/ 2.0;\n    ret += noise(x * 4.0) \/ 4.0;\n    \/\/ret += noise(x * 8.0) \/ 8.0;\n    ret += noise(x * 16.0) \/ 16.0;\n    return ret;\n}\n\nfloat fbm3(vec3 x)\n{\n    float ret = noise(x); x = rotateY(x, .833);\n    \/\/ret += noise(x * 2.0) \/ 2.0;\n    ret += noise(x * 4.0) \/ 4.0;\n    \/\/ret += noise(x * 8.0) \/ 8.0;\n    \/\/ret += noise(x * 16.0) \/ 16.0;\n    return ret;\n}\n\n#define saturate(x) (clamp(x, 0.0, 1.0))\n\nvec3 nightSky(vec3 eyeDir)\n{\n    float starsBrightness = pow(noise(eyeDir * 200.0), 86.0) * 2.2;\n    vec3 stars = vec3(saturate(starsBrightness));\n    \n    float horizonBrightness = pow(1.0 - abs(eyeDir.y) + .01, 22.0) * .3;\n    vec3 horizon = vec3(0.8, 0.9, 1.0) * horizonBrightness;\n    \n    vec3 moonPos = normalize(vec3(1, 2, 2));\n    float moonBrightness = saturate(pow(max(dot(eyeDir, moonPos), 0.0) + .01, 3000.0));\n    vec3 moonColor = mix(vec3(0.9), vec3(.8, .6, .5), fbm(eyeDir * 24.0));\n    vec3 moon = moonColor * moonBrightness;\n    \n    vec3 clearSky = stars + horizon + moon;\n    \n    return clearSky;\n}\n\nfloat sphere(vec3 p, vec3 pos, float radius)\n{\n    return length(p - pos) - radius;\n}\n\nfloat cube(vec3 p, vec3 pos, vec3 size)\n{\n    vec3 d = abs(p - pos) - size;\n    return max(max(d.x, d.y), d.z);\n}\n\nfloat bawlsNoise(vec3 p)\n{\n    vec3 normalNoisePos = p * 5.0;\/\/ + vec3(0.0, iGlobalTime, 0.0);\n    return\n        saturate(pow((fbm(normalNoisePos) - .6) * 4.0, 2.0))\n        + pow(fbm(normalNoisePos * 3.0 + 40.0), 6.0) * .08\n        ;\n}\n\n#ifdef BAWLS\nfloat ballsTime = iGlobalTime * .3;\nvec3 ball1Pos = vec3(cos(ballsTime * .44), cos(ballsTime * .99), sin(ballsTime * 1.3)) * 1.4;\nvec3 ball2Pos = vec3(cos(ballsTime * 1.3), sin(ballsTime * .78), cos(ballsTime)) * 1.2;\nvec3 ball3Pos = vec3(sin(ballsTime * .77), sin(ballsTime * .12), sin(ballsTime * 2.0)) * 1.2;\nfloat ball1Rad = sin(ballsTime + 1.0) * .4 + .6;\nfloat ball2Rad = cos(ballsTime * 1.6 + 2.0) * .4 + .6;\nfloat ball3Rad = sin(ballsTime * .84 + 3.0) * .4 + .6;\n\nfloat metaballs(vec3 p)\n{\n    float ball1 = sphere(p, ball1Pos, ball1Rad);\n    float ball2 = sphere(p, ball2Pos, ball2Rad);\n    float ball3 = sphere(p, ball3Pos, ball3Rad);\n    \n    float srf =\n        1.0 \/ (ball1 + ball1Rad) +\n        1.0 \/ (ball2 + ball2Rad) +\n        1.0 \/ (ball3 + ball3Rad);\n    \n    return 1.0 \/ srf - .4;\n}\n\nSceneResult f(vec3 p)\n{\n    float diag = (p.x + p.y + p.z) * 2.0 + iGlobalTime * 1.2;\n    float materialMix = saturate(pow(abs(sin(diag) * 1.1), 120.0));\n    \n    Material smoothMaterial = Material(\n        vec3(0.0),\n        vec3(.08),\n        vec3(2.0),\n        36.0,\n        0.52);\n    \n    Material fuzzyMaterial = Material(\n        vec3(0.0),\n        mix(vec3(1.0, .2, .1), vec3(.9, .1, .1), saturate(pow(fbm(p * 7.0) * 1.1 - .1, 8.0))),\n        vec3(.3),\n        6.0,\n        0.4);\n    \n    Material material = mixMaterials(smoothMaterial, fuzzyMaterial, materialMix);\n    float d =\n        metaballs(p)\n        - (fbm3(p * 12.0 + iGlobalTime * .4) - .1) * materialMix * .01\n        ;\n    \n    return SceneResult(d, material);\n}\n\nSceneResult tf(vec3 p)\n{\n    SceneResult bawlsResult = f(p);\n    \n    float normalNoise = bawlsNoise(p);\n    \n    return SceneResult(bawlsResult.d + normalNoise * .001, bawlsResult.material);\n}\n#endif\n\n#ifdef TUNNEL\nvec2 tunnelUv(vec3 p)\n{\n    vec3 tunnelP = p * .1;\n    return vec2(atan(tunnelP.y, tunnelP.x) * 2.0, tunnelP.z + iGlobalTime * .125);\n}\n\nSceneResult tunnel(vec3 p)\n{\n    Material material = Material(\n        vec3(0.0),\n        vec3(.8, .9, 1.0) * .32,\n        vec3(.2),\n        36.0,\n        0.2);\n    \n    vec2 uv = tunnelUv(p);\n    float d = 6.0 - length(p.xy + vec2(sin(p.z * .4 + iGlobalTime * .21), cos(p.z * .4 + iGlobalTime * .34)) * .7) + fbm3(vec3(uv, iGlobalTime * .1)) * 4.0;\n    \n    float cutoutSize = 1.2;\n    float cutout = -(min(abs(p.x) - cutoutSize, abs(p.y) - cutoutSize));\n    \n    return SceneResult(max(d, cutout), material);\n}\n\nSceneResult f(vec3 p)\n{\n    return tunnel(p);\n}\n\nSceneResult tf(vec3 p)\n{\n    SceneResult original = f(p);\n    \n    vec2 uv = tunnelUv(p);\n    return SceneResult(\n        original.d + fbm(vec3(uv * 2.1, iGlobalTime * .1) * 3.4) * .4,\n        original.material);\n}\n#endif\n\n#ifdef ALLTHECUBES\n\/\/ rep stolen from iq\nfloat repCubes( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return cube(q, vec3(0.0), vec3(0.34));\n}\n\nSceneResult f(vec3 p)\n{\n    Material material = Material(\n        vec3(0.0),\n        vec3(.8),\n        vec3(.02),\n        36.0,\n        0.6);\n    float t = iGlobalTime * .4;\n    vec3 q = rotateY(rotateZ(rotateX(p, t * .22), t * .34), t * .44 + sin(p.y * .05 + t * .2));\n    float e = .95;\n    for (int i = 0; i < 4; i++)\n    {\n        q = rotateX(rotateZ(abs(q - e * float(i)), 40.0 + t * .12), t * .116);\n        e = e * .5 + e * e * .3;\n    }\n    float d = max(repCubes(q, vec3(.8)), cube(q, vec3(0.0), vec3(6.0, 6.0, 6.0)));\n    \n    return SceneResult(d, material);\n}\n\nSceneResult tf(vec3 p)\n{\n    float diag = (p.x + p.y + p.z) * 2.2;\n    float materialMix = saturate(pow((sin(diag) * .5 + .5) * 1.2, 40.0));\n    \n    Material material = Material(\n        vec3(0.0),\n        vec3(.08),\/\/vec3(1.0, .2, .1),\n        vec3(1.01),\n        6.0,\n        0.0);\n    \n    SceneResult original = f(p);\n    return SceneResult(original.d + (fbm(p * 3.0) + 1.4) * materialMix * .03, mixMaterials(original.material, material, materialMix));\n}\n#endif\n\n#ifdef SLICES\nSceneResult f(vec3 p)\n{\n    Material material = Material(\n        vec3(0.0),\n        vec3(.88),\n        vec3(2.0),\n        36.0,\n        0.52);\n    \n    float slashesAmt = .5;\n    \n    \/\/float slashes = abs(fract((p.x + p.y + p.z) * 8.0) \/ 16.0 - 1.0 \/ 32.0) - Slashes \/ 32.0;\n      float slashes = abs(fract((p.x + p.y + p.z) \/ 2.0) - 1.0 \/ 2.0) - slashesAmt \/ 2.0;\n    float d = max(cube(p, vec3(0.0), vec3(4.0)), slashes);\n    \n    return SceneResult(d, material);\n}\n\nSceneResult tf(vec3 p)\n{\n    SceneResult original = f(p);\n    return SceneResult(original.d + bawlsNoise(p) * .001, original.material);\n}\n#endif\n\n#ifdef TWISTERS\nSceneResult f(vec3 p)\n{\n    Material material = Material(\n        vec3(0.0),\n        vec3(.08),\n        vec3(2.0),\n        36.0,\n        0.82);\n    \n    vec3 q = rotateY(p, sin(p.y * .03 + iGlobalTime * .73) * 6.2);\n    float d = 1000.0;\n    for (int i = 0; i < 3; i++)\n    {\n        float an = float(i) \/ 3.0 * 2.0 * 3.141592;\n        d = min(d, length(q.xz + vec2(cos(an), sin(an)) * 2.2) - 1.0);\n    }\n    \n    float cutoutPos = sin(iGlobalTime * 1.7) * 3.0;\n    float cutoutSize = sin(iGlobalTime * 2.1) + 1.5;\n    float cutout = -(abs(p.y - cutoutPos) - cutoutSize);\n    d = max(d, cutout);\n    \n    return SceneResult(d, material);\n}\n\nSceneResult tf(vec3 p)\n{\n    SceneResult original = f(p);\n    return SceneResult(original.d + bawlsNoise(p) * .003, original.material);\n}\n#endif\n\n#ifdef OUTDOORZ\n\/\/ rep stolen from iq\nfloat repCylinders( vec3 p, vec2 c )\n{\n    vec2 derp = mod(p.xz, c);\n    vec2 q = derp-0.5*c;\n    return length(q) - .34;\n}\n\nSceneResult f(vec3 p)\n{\n    float diag = p.x + p.y + p.z;\n    \n    Material material = Material(\n        vec3(0.0),\n        vec3(.08) * vec3(1., .9, .8),\n        vec3(2.0),\n        36.0,\n        0.42);\n    \n    float s = sphere(p, vec3(0.0), 5.0) + noise(p * .4 + iGlobalTime);\n    float cylinders = repCylinders(p + noise(p * .1 + iGlobalTime) * .8, vec2(10.0));\n    float ground = p.y + 12.0 + (sin(p.x * .4) + cos(p.z * .4)) * .4;\n    \n    return SceneResult(min(min(s, cylinders), ground), material);\n}\n\nSceneResult tf(vec3 p)\n{\n    float diag = (p.x + p.y + p.z) * 2.2;\n    float materialMix = saturate(pow((sin(diag) * .5 + .5) * 1.2, 40.0));\n    \n    Material material = Material(\n        vec3(0.0),\n        vec3(.08),\/\/vec3(1.0, .2, .1),\n        vec3(1.01),\n        6.0,\n        0.0);\n    \n    SceneResult original = f(p);\n    return SceneResult(original.d + (fbm(p * 3.0) + 1.4) * materialMix * .03, mixMaterials(original.material, material, materialMix));\n}\n#endif\n\nvec3 lightContribution(\n    vec3 eyePos,\n    vec3 eyeDir,\n    vec3 normal,\n    vec3 lightPos,\n    vec3 lightColor,\n    Material material,\n    float occlusionTerm)\n{\n    vec3 l = normalize(lightPos - eyePos);\n    vec3 diffuse = max(material.diffuseColor * (max(dot(normal, l), 0.0)) - occlusionTerm, vec3(0.0));\n    vec3 refVec = reflect(l, normal);\n    vec3 specular = material.specularColor * pow(max(dot(refVec, eyeDir), 0.0), material.specularExponent);\n    return (diffuse + specular) * lightColor;\n}\n\n#if defined TUNNEL || defined OUTDOORZ\nvec3 light1Pos = vec3(sin(iGlobalTime * 1.1), cos(iGlobalTime), 20.0);\/\/ * vec3(2.0, 2.0, 1.0);\nvec3 light2Pos = vec3(cos(iGlobalTime * .84), cos(iGlobalTime * .45), 20.0);\/\/ * vec3(2.0, 2.0, 1.0);\n#else\nfloat lightTime = iGlobalTime * .2;\nvec3 light1Pos = vec3(sin(lightTime * 1.1), cos(lightTime) * .3 + .4, sin(lightTime * .76)) * 20.0;\nvec3 light2Pos = vec3(cos(lightTime * .84), cos(lightTime * .45) * .3 + .4, sin(lightTime * 1.2)) * 20.0;\n#endif\nvec3 light1Color = vec3(0.7, .85, 1.0);\nvec3 light2Color = vec3(1.0, .85, .7);\n\nvec3 outdoorBackground(vec3 eyePos, vec3 eyeDir)\n{\n    vec3 sky =\n        vec3(0.08)\n        + pow(max(dot(eyeDir, normalize(light1Pos - eyePos)), 0.0), 27.0) * light1Color * .4\n        + pow(max(dot(eyeDir, normalize(light2Pos - eyePos)), 0.0), 27.0) * light2Color * .4\n        + mix(vec3(.8, .9, 1.0), vec3(1.0, .9, .8), pow(1.0 - abs(eyeDir.y), 2.1)) * .8\n        ;\n    \n    float cloudsMix =\n        saturate(pow(fbm(vec3(eyeDir.xz * 7.0, iGlobalTime * .1)) - .2, 6.0))\n        * pow(max(eyeDir.y, 0.0), 1.4) * .8;\n    \n    vec3 clouds = mix(vec3(.8), vec3(1.0), fbm(eyeDir * 24.0));\n    \n    return mix(sky, clouds, cloudsMix);\n}\n\nvec3 getColor(float x)\n{\n    return\n        mix(\n            vec3(.2, .8, 1.0),\n            mix(\n                vec3(.7, .2, 1.0),\n                mix(\n                    vec3(1.0, .6, .2),\n                    vec3(1.0),\n                    step(.6, x)),\n                step(.4, x)),\n            step(.2, x));\n}\n\nvec3 neonTunnelBackground(vec3 eyePos, vec3 eyeDir)\n{\n    float t = iGlobalTime * .2;\n    float an = atan(eyeDir.x, eyeDir.z) \/ (2.0 * 3.141592) * 26.0;\n    float f = (1.0 - pow(abs(fract(an) * 2.0 - 1.0), 23.0)) * (1.0 - pow(abs(eyeDir.y), 3.0));\n    f *= saturate(pow(fbm(vec3(floor(an), t * 1.4, 0.0)) - .2, 12.0) * 3.0 + .1);\n    f *= (1.0 - pow(saturate(fbm(eyeDir * 33.0) - .8), 3.0)) * .6 + .4;\n    float c = saturate(pow(fbm(vec3(floor(an), 0.0, t * .13)) - .1, 12.0) * 3.0 + .1);\n    return getColor(c) * f * .7 * 2.0;\n}\n\nvec3 background(vec3 eyePos, vec3 eyeDir)\n{\n    return\n#if defined TUNNEL || defined OUTDOORZ\n        outdoorBackground(eyePos, eyeDir);\n#else\n        neonTunnelBackground(eyePos, eyeDir);\n#endif\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 pixelPos = (fragCoord - iResolution.xy \/ 2.0) \/ iResolution.y;\n    \n    vec3 eyeDir = normalize(vec3(pixelPos, 1));\n    \n    vec2 normMouse = vec2(0.0);\/\/iMouse.xy \/ iResolution.xy - .5;\n    float camRotX = sin(iGlobalTime * .1) + normMouse.y * 3.141592;\n    float camRotY = iGlobalTime * .5 + normMouse.x * 2.0 * 3.141592;\n    float camRotZ = sin(iGlobalTime * .083) * .4;\n    \n    eyeDir = rotateZ(eyeDir, camRotZ);\n    eyeDir = rotateX(eyeDir, camRotX);\n    eyeDir = rotateY(eyeDir, camRotY);\n    \n    vec3 eyePos =\n#ifdef BAWLS\n        vec3(0.0, 0.0, -4.0);\n#elif defined TUNNEL\n        vec3(0.0, -7.0, -4.0);\n#else\n        vec3(0.0, -0.0, -14.0);\n#endif\n    eyePos = rotateX(eyePos, camRotX);\n    eyePos = rotateY(eyePos, camRotY);\n    \n    vec3 color = background(eyePos, eyeDir);\n    \n    const float maxDisTravelled = 40.0;\n    float disTravelled = 0.0;\n    const int maxIterations = 160;\n    for (int i = 0; i < maxIterations; i++)\n    {\n        float d = f(eyePos).d;\n        if (d <= 0.0)\n            break;\n        \n        d = max(d, .025);\n        eyePos += eyeDir * d;\n        disTravelled += d;\n        if (disTravelled >= maxDisTravelled)\n            break;\n    }\n    \n    if (disTravelled < maxDisTravelled)\n    {\n        SceneResult td = tf(eyePos);\n        vec3 normal = normalize(\n            vec3(\n                tf(eyePos + vec3(.003, 0, 0)).d - td.d,\n                tf(eyePos + vec3(0, .003, 0)).d - td.d,\n                tf(eyePos + vec3(0, 0, .003)).d - td.d));\n\n        float occlusionTerm = 0.0;\n        for (float i = 1.0; i < 4.0; i += 1.0)\n            occlusionTerm += max(-f(eyePos + normal * i * .1).d, 0.0) \/ pow(2.0, i);\n        occlusionTerm *= 2.0;\n\n        vec3 surfaceColor =\n            td.material.additiveColor\n            + lightContribution(eyePos, eyeDir, normal, light1Pos, light1Color, td.material, occlusionTerm)\n            + lightContribution(eyePos, eyeDir, normal, light2Pos, light2Color, td.material, occlusionTerm)\n            + background(eyePos, reflect(eyeDir, normal)) * td.material.backgroundAmount;\n\n        \/\/vec3 iterationGlow = vec3(.9, 1.0, 1.1) * pow(float(i) \/ float(maxIterations), 2.0);\n\n        color =\n            mix(\n                color,\n                surfaceColor,\n                1.0 - pow(disTravelled \/ maxDisTravelled, 2.0))\n            \/\/+ iterationGlow\n            ;\n    }\n    \n    vec2 q = fragCoord.xy \/ iResolution.xy;\n    color = pow(color * vec3(1.0, .99, 1.06), vec3(1.2));\n    \n    \/\/color = pow(color, vec3(3.0));\n    \n    \/\/ Vignette (stolen from iq)\n    color *= 0.4 + 0.6*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n    \n    \/\/ Cheap \"bloom emulation\" to better match the actual intro :)\n    color += pow(max(color - .2, 0.0), vec3(1.4)) * .5;\n    \n    fragColor = vec4(color, 1);\n}","name":"","description":"","type":"image"}]}}