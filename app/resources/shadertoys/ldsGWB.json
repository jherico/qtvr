{"Shader":{"ver":"0.1","info":{"id":"ldsGWB","date":"1378824091","viewed":17443,"name":"Shiny Toy","username":"eiffie","description":"Who is more drunk, the driver, pilot, camera operator, road surveyor or coder? Up the \"Rays\" value for a better quality.","likes":95,"published":3,"flags":0,"tags":["pathmarching"],"hasliked":0},"renderpass":[{"inputs":[{"id":16,"src":"\/presets\/tex11.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Shiny Toy Car by eiffie\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ V2 Sedan Version: simplified car, added quadcop, bushs and the speed, lighting fix. \n\nconst int Rays=2, RaySteps=48, maxBounces=6;\/\/up the Rays value for less fuzz\nconst float fov = 4.5,blurAmount = 0.005,maxDepth=11.0,HitDistance=0.001;\nconst vec3 sunColor=vec3(1.0,0.9,0.8),sunDir=vec3(0.35,0.5,-0.35),skyColor=vec3(0.13,0.14,0.15);\nconst vec2 ve=vec2(0.0001,0.0);\nint obj=0;\nfloat tim;\nmat2 rmx;\n#define tex iChannel0\n#define time iGlobalTime*0.5\n#define size iResolution\n\nstruct material {vec3 color;float difExp,spec,specExp;};\n\nfloat smin(float a,float b,float k){return -log(exp(-k*a)+exp(-k*b))\/k;}\/\/from iq\n#define TAO 6.283\nvoid Rotate(inout vec2 v, float angle) {v*=mat2(cos(angle),sin(angle),-sin(angle),cos(angle));}\nvoid Kaleido(inout vec2 v,float power){Rotate(v,floor(0.5+atan(v.x,-v.y)*power\/TAO)*TAO\/power);}\n\nfloat DE(in vec3 p0){\/\/carcar\n\tp0.z+=tim;\n\tvec3 p=p0+vec3(0.0,1.24,0.0);\n\tfloat r=length(p.yz);\n\tfloat d= length(max(vec3(abs(p.x)-0.35,r-1.92,-p.y+1.4),0.0))-0.05;\n\td=max(d,p.z-1.0);\n\tp=p0+vec3(0.0,-0.22,0.39);\n\tp.xz=abs(p.xz)-vec2(0.5300,0.9600);p.x=abs(p.x);\n\tr=length(p.yz);\n\td=smin(d,length(max(vec3(p.x-0.08,r-0.25,-p.y-0.08),0.0))-0.04,8.0);\n\td=max(d,-max(p.x-0.165,r-0.24));\n\tfloat d2=length(vec2(max(p.x-0.13,0.0),r-0.2))-0.02;\n\tfloat d3=length(vec2(max(p.x-0.11,0.0),r-0.18))-0.02;\n\tif(p0.z<0.0)p.yz=p.yz*rmx;\n\telse p.yz=rmx*p.yz;\n\tKaleido(p.yz,9.0);\n\td3=min(d3,length(max(abs(p.xyz)-vec3(0.07,0.0,0.17),0.0))-0.01);\n\td=min(min(p0.y,d),min(d2,d3));\n\tif(obj<0){\n\t\tif(d==d2)obj=1;\n\t\telse if(d==d3)obj=2;\n\t\telse if(d==p0.y)obj=3;\n\t\telse obj=0;\n\t}\n\treturn d;\n}\n\nmaterial getMaterial( in vec3 p0, inout vec3 nor )\n{\/\/return material properties\n\tvec3 dif=vec3(0.0);\n\tif(obj==0){\/\/body\n\t\tif(abs(p0.y-0.6)>0.1 || abs(p0.x)>0.43 || p0.z+tim<-0.9900)dif=vec3(0.9,0.9,0.4);\n\t\treturn material(dif,pow(2.0,10.0),1.0,pow(2.0,14.0));\n\t}else if(obj==1){\/\/tire\n\t\treturn material(dif,4.0,0.75,32.0);\n\t}else if(obj==2){\/\/rim\n\t\treturn material(vec3(0.8),pow(2.0,16.0),1.0,2048.0);\n\t}else {\/\/ground\n\t\tp0.x+=(sin(p0.z*0.1)+sin(p0.z*0.13))*0.5;\n\t\tif(abs(abs(p0.x-1.0)-2.5)<0.05 || (abs(p0.x-1.0)<0.05 && fract(p0.z*0.25)<0.25))dif=vec3(1.0);\n\t\telse if(abs(p0.x-1.0)<3.25-texture2D(tex,p0.xz*0.5).r*0.2)dif=vec3(0.25);\n\t\telse dif=vec3(0.6,0.5,0.3);\n\t\tvec3 col=min(10.0,abs(p0.x))*0.01*texture2D(tex,p0.xz*0.05).rgb;\n\t\tnor=normalize(nor+col);\n\t\tdif+=col;\n\t\treturn material(dif,3.0,0.5,1024.0);\n\t}\n}\n\nfloat DEQCop(vec2 z){\n\tvec2 p=abs(z)-vec2(2.0);\n\tp*=rmx;\n\tfloat d=max(abs(p.x)-1.5,abs(p.y)-0.1);\n\tp=abs(z*mat2(0.707,-0.707,0.707,0.707));\n\td=min(d,length(p)-1.0);\n\td=min(d,max(p.x-3.0,p.y-0.1));\n\td=min(d,max(p.x-0.1,p.y-3.0));\n\treturn step(0.0,d)*0.75+0.25;\n}\n\nvec3 getBackground( in vec3 ro, vec3 rd, vec3 qcop  ){\n\tvec2 pt=vec2(rd.x+rd.z*0.6,rd.y*2.0);\n\tif(rd.y<texture2D(tex,pt).r*0.02)return vec3(0.05,0.1,0.025)+max(0.0,rd.y)*vec3(8.0,4.0,0.0);\n\tvec3 clouds=texture2D(tex,pt*0.1).rgb*0.05+texture2D(tex,pt*0.3).rgb*0.025;\n\tfloat t=1.0;\n\tif(ro!=qcop){\n\t\tt=(qcop.y-ro.y)\/rd.y;\n\t\tif(t>0.0){\n\t\t\tpt=ro.xz+rd.xz*t-qcop.xz;\n\t\t\tt=DEQCop(pt);\n\t\t}else t=1.0;\n\t}\n\n\treturn t*(clouds+skyColor+rd*0.05+sunColor*(pow(max(0.0,dot(rd,sunDir)),2.0)*0.5+pow(max(0.0,dot(rd,sunDir)),80.0)));\n}\n\nfloat BBox(vec3 p, vec3 rd, vec3 bs)\n{\n\tvec3 t0=(-bs-p)\/rd,t1=(bs-p)\/rd;\n\tvec3 n=min(t0,t1),f=max(t0,t1);\n\tfloat tmin=max(n.x,max(n.y,n.z)),tmax=min(f.x,min(f.y,f.z));\n\tif(tmin<=tmax) return tmin;\n\treturn maxDepth;\n}\n\n\/\/the code below can be left as is so if you don't understand it that makes two of us :)\n\n\/\/random seed and generator\nvec2 randv2;\nvec2 rand2(){\/\/ implementation derived from one found at: lumina.sourceforge.net\/Tutorials\/Noise.html\n\trandv2+=vec2(1.0,1.0);\n\treturn vec2(fract(sin(dot(randv2.xy ,vec2(12.9898,78.233))) * 43758.5453),\n\t\tfract(cos(dot(randv2.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n \nvec3 powDir(vec3 nor, vec3  dir, float power) \/\/modified from syntopia's code\n{\/\/creates a biased random sample without penetrating the surface (approx Schlick's)\n\tfloat ddn=max(0.01,abs(dot(dir,nor)));\n\tvec2 r=rand2()*vec2(TAO,1.0);\n\tvec3 nr=(ddn<0.99)?nor:((abs(nor.x)<0.5)?vec3(1.0,0.0,0.0):vec3(0.0,1.0,0.0));\n\tvec3 sdir=normalize(cross(dir,nr));\n\tr.y=pow(r.y,1.0\/power);\n\tvec3 ro= normalize(sqrt(1.0-r.y*r.y)*(cos(r.x)*sdir + sin(r.x)*cross(dir,sdir)*ddn) + r.y*dir);\n\treturn (dot(ro,nor)<0.0)?reflect(ro,nor):ro;\n}\n\nvec3 scene(vec3 ro, vec3 rd) \n{\/\/ find color of scene\n\tvec3 fcol=vec3(1.333),qcop=ro;\n\tfloat d,t=min(ro.y\/-rd.y,BBox(ro-vec3(0.0,0.22,-tim-0.33),rd,vec3(0.8,0.51,1.75)));\/\/bounding\n\tint iHitCount=0;\n\tfor(int i=0; i<RaySteps; i++ ){\/\/ march loop\n\t\tif(t>=maxDepth)continue;\n\t\tt+=d=DE(ro+t*rd);\/\/march\n\t\tif(abs(d)<HitDistance*t){\/\/hit\n\t\t\tobj=-1;\/\/turn on material mapping\n\t\t\tt+=d=DE(ro+t*rd);\/\/move closer while coloring\n\t\t\tro+=rd*t;\/\/ advance ray position to hit point\n        \t\tvec3 nor = normalize(vec3(-DE(ro-ve.xyy)+DE(ro+ve.xyy),\n\t\t\t\t-DE(ro-ve.yxy)+DE(ro+ve.yxy),\n\t\t\t\t-DE(ro-ve.yyx)+DE(ro+ve.yyx)));\/\/ get the surface normal\n\t\t\tmaterial m=getMaterial( ro, nor );\/\/and material\n\t\t\tvec3 refl=reflect(rd,nor);\/\/setting up for a new ray direction and defaulting to a reflection\n\t\t\trd=powDir(nor,refl,m.difExp);\/\/redirect the ray\n\t\t\tm.color+=mix(vec3(-0.2,0.0,0.2),vec3(0.2,0.0,-0.2),0.25+0.75*dot(rd,nor));\n\t\t\t\/\/the next line calcs the amount of energy left in the ray based on how it bounced (diffuse vs specular) \n\t\t\tfcol*=mix(m.color,vec3(1.0),min(pow(max(0.0,dot(rd,refl)),m.specExp)*m.spec,1.0));\n\t\t\tt=max(d*5.0,HitDistance);\/\/hopefully pushs thru the surface\n\t\t\tif(iHitCount++>maxBounces || dot(fcol,fcol)<0.01)t=maxDepth;\n\t\t}\n\t}\n\tif(rd.y<0.0){\/\/one more ground hit for good luck\n\t\tobj=3;\n\t\tt=ro.y\/-rd.y;\/\/calc the intersection\n\t\tro+=rd*t;\/\/ advance ray position to hit point\n        \tvec3 nor = vec3(0.0,1.0,0.0);\n\t\tmaterial m=getMaterial( ro, nor );\n\t\tvec3 refl=reflect(rd,nor);\/\/setting up for a new ray direction and defaulting to a reflection\n\t\trd=powDir(nor,refl,m.difExp);\/\/redirect the ray\n\t\tm.color+=mix(vec3(-0.2,0.0,0.2),vec3(0.2,0.0,-0.2),0.25+0.75*dot(rd,nor));\n\t\tfcol*=mix(m.color,vec3(1.0),min(pow(max(0.0,dot(rd,refl)),m.specExp)*m.spec,1.0));\t\n\t}\n\treturn fcol*getBackground(ro,rd,qcop);\/\/light the scene\n}\t\n\nmat3 lookat(vec3 fw,vec3 up){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,normalize(up)));return mat3(rt,cross(rt,fw),fw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\trandv2=fract(cos((fragCoord.xy+fragCoord.yx*vec2(1000.0,1000.0))+vec2(time)*10.0)*10000.0);\n\tvec3 clr=vec3(0.0);\n\tfor(int iRay=0;iRay<Rays;iRay++){\n\t\tfloat tim3=time+0.02*float(iRay)\/float(Rays);\n\t\ttim=tim3*tim3;\/\/14.4;\n\t\tfloat tim2=tim3*0.15;\n\t\tfloat ct=cos(tim*1.25),st=sin(tim*1.25);\n\t\tvec3 ro=vec3(cos(tim2)*vec2(sin(tim2*6.4),cos(tim2*6.4)),sin(tim2))*(6.0+3.0*sin(tim2*3.0));\n\t\tro.y=ro.y*0.2+2.5;\n\t\tfloat focusDistance=max(length(ro)-0.1,0.01);\n\t\tmat3 rotCam=lookat(-ro+texture2D(tex,vec2(tim2,tim2*1.3)).rgb*0.125+vec3(cos(tim2*0.75),sin(tim2*0.4),sin(tim2*0.6))*0.5,vec3(0.0,1.0+cos(tim2*25.0)*0.125,0.125*sin(tim2*25.0)));\n\t\tro.z-=tim;\n\t\trmx=mat2(ct,st,-st,ct);\n\t\tvec2 pxl=(-size.xy+2.0*(fragCoord.xy+rand2()))\/size.y;\n\t\tvec3 er = normalize( vec3( pxl.xy, fov ) );\n\t\tvec3 go = blurAmount*focusDistance*vec3( -1.0 + 2.0*rand2(), 0.0 );\n       \tvec3 gd = normalize( er*focusDistance - go );gd.z=0.0;\n\t\tclr+=scene(ro+rotCam*go,normalize(rotCam*(er+gd)));\n\t}\n\tclr\/=vec3(Rays);\n\tfragColor = vec4(sqrt(clr)*1.4-0.25,1.0);\n}","name":"","description":"","type":"image"},{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/sorry, couldn't help myself\n\/*float sawtooth(float time){return fract(time)-0.5;}\n\nvec2 mainSound(float time)\n{\n    return vec2( sawtooth(time*time) );\n}*\/\n\/\/v2 with LOTS of gears\nfloat saw(float time){return clamp(fract(time)*2.0-1.0,-0.5,0.5);}\nvec2 mainSound(float time)\n{\n    float t=pow(time+1.0,0.75);\n    t=mod(t,2.0)+1.0+floor(t*0.25+0.5);\n    t=pow(t,4.0);\n    return vec2( saw(t),saw(t+sin(time)) )*0.2;\n}\n","name":"","description":"","type":"sound"}]}}