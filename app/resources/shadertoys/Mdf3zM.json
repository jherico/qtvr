{"Shader":{"ver":"0.1","info":{"id":"Mdf3zM","date":"1365959156","viewed":6042,"name":"Escher's prentententoonstelling","username":"reinder","description":"I found this article: http:\/\/www.ams.org\/notices\/200304\/fea-escher.pdf describing the transformation used by Escher in the droste-picture: de prentententoonstelling (the picture gallery). The source is a mess atm - I will clean up later.","likes":59,"published":3,"flags":0,"tags":["distancefields","droste","escher","domaintransformation"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Escher's prentententoonstelling. Reinder Nijhoff 2013\n\/\/ @reindernijhoff\n\/\/\n\/\/ https:\/\/www.shadertoy.com\/view\/Mdf3zM\n\/\/\n\/\/ Study of the transformation of Escher in 'the prentententoonstelling'\n\/\/\n\/\/ http:\/\/www.ams.org\/notices\/200304\/fea-escher.pdf\n\/\/ h(w) = w\u03b1 = w^((2\u03c0i+log scale)\/(2\u03c0i))\n\/\/\n\/\/ distancefield functions by inigo quilez.\n\/\/\n\n\/\/#define SHADOW\n#define WOBBLE\n\nfloat t = mod(iGlobalTime, 48.);\n\nfloat st = 0., zt = 0.;\n\nfloat deformationScale, zoom;\n\nvec2 escherDeformation( in vec2 uv ) {\n\t\n\/\/ http:\/\/www.ams.org\/notices\/200304\/fea-escher.pdf\n\/\/ h(w) = w\u03b1 = w^((2\u03c0i+log scale)\/(2\u03c0i))\n\t\n\tfloat lnr = log(length(uv));\n\tfloat th = atan( uv.y, uv.x )+(0.4\/256.)*deformationScale;\n\tfloat sn = -log(deformationScale)*(1.\/(2.*3.1415926));\n\tfloat l = exp( lnr - th*sn ); \n\t\n\tvec2 ret = vec2( l );\n\t\n\tret.x *= cos( sn*lnr+th );\n\tret.y *= sin( sn*lnr+th );\n\t\t\n\treturn ret;\n}\n\n#define drostescale 256.\n\nvec2 drosteTransformation( in vec2 uv ) {\n\tfor( int i=0; i<2; i++ ) {\n\t\tif(any(greaterThan(abs(uv),vec2(1.)))) {\n\t\t\tuv *= (1.\/drostescale);\n\t\t}\t\t\n\t\tif(all(lessThan(abs(uv),vec2(1.\/drostescale)))) {\n\t\t\tuv *= drostescale;\n\t\t}\n\t}\n\treturn uv;\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat sdPlane( vec3 p ) {\n\treturn p.y+14.+0.05*cos(p.x+iGlobalTime*2.);\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat udBox( vec3 p, vec3 b) {\n  return length(max(abs(p)-b,0.0));\n}\nfloat sdTriPrism( vec3 p, vec2 h ) {\n    vec3 q = abs(p);\n    return max(q.x-h.y,max(q.z*0.4+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdCylinderXY( vec3 p, vec2 h ) {\n  return max( length(p.xy)-h.x, abs(p.z)-h.y );\n}\nfloat sdCylinderYZ( vec3 p, vec2 h ) {\n  return max( length(p.yz)-h.x, abs(p.x)-h.y );\n}\nfloat sdCylinderXZ( vec3 p, vec2 h ) {\n  return max( length(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n\n\/\/----------------------------------------------------------------------\n\nfloat opS( float d1, float d2 ) {\n    return max(-d2,d1);\n}\nfloat opU( float d1, float d2 ) {\n    return min(d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 ) {\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat opI( float d1, float d2 ) {\n    return max(d1,d2);\n}\n\n\/\/----------------------------------------------------------------------\n\n\nfloat objPrentenTentoonstelling( in vec3 pos ) {\n\tvec3 tpos;\/\/ = pos;\n\ttpos.x = min( abs(pos.x), abs(pos.z) );\n\ttpos.y = pos.y;\n\ttpos.z = max( abs(pos.x), abs(pos.z) );\n\t\n\tfloat res = opU(opU(opU(opU(opU(\n\t\t\topS(opS(opS( \/\/ main building\n\t\t\t\topS(\n\t\t\t\t\tudBox( tpos, vec3( 5.5, 24.0, 5.5 ) ),\n\t\t\t\t\tsdBox( vec3(tpos.x, tpos.y-24.0, tpos.z), vec3( 5.25, 0.5, 5.25) ) \n\t\t\t\t),\n\t\t\t\tsdBox( vec3( mod(tpos.x+1.75, 3.5)-1.75, tpos.y-21.5, tpos.z-5.), vec3( 1.,1.,4.) )\n\t\t\t),\n\t\t\t\tsdBox( vec3( mod(tpos.x+1.75, 3.5)-1.75, tpos.y-15.5, tpos.z-5.), vec3( 1.,2.,4.) )\n\t\t\t),\n\t\t\t\tsdCylinderXY( vec3( mod(tpos.x+1.75, 3.5)-1.75, tpos.y-17.5, tpos.z-5.), vec2( 1.,4.) )\n\t\t\t),\n\t\t\topI( \/\/ main building windows\n\t\t\t\tudBox( tpos, vec3( 5.5, 23., 5.5 ) ),\n\t\t\t\topU(\n\t\t\t\t\tudBox(  vec3( mod(tpos.x+1.75, 3.5)-1.75, tpos.y, tpos.z-5.2), vec3( 0.05, 24., 0.05 ) ),\n\t\t\t\t\tudBox(  vec3( tpos.x, mod(tpos.y+0.425, 1.75)-0.875, tpos.z-5.2), vec3( 10.0, 0.05, 0.05 ) )\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t\topS( \/\/ gallery\n\t\t\topU(opU(opU(\t\t\n\t\t\t\topS(opS( \n\t\t\t\t\t\tudBox( tpos, vec3( 8.375, 8.75, 8.375 ) ),\n\t\t\t\t\t\tsdCylinderXY( vec3( mod(tpos.x, 2.75)-1.375, tpos.y-6.5, tpos.z-8.75), vec2( 1.25,2.75) )\n\t\t\t\t\t),\n\t\t\t\t\tsdBox( vec3(  mod(tpos.x, 2.75)-1.375, tpos.y-4.5, tpos.z-8.75), vec3( 1.25,2.0,2.75) )\t\t\t\n\t\t\t\t),\n\t\t\t\tudBox(  vec3( mod(tpos.x-8.375\/18., 8.375\/9.)-8.375\/18., tpos.y, tpos.z-8.3), vec3( 0.025, 8.5, 0.025 ) )\n\t\t\t),\n\t\t\t\tudBox(  vec3( tpos.x, tpos.y-4.3, tpos.z-8.3), vec3( 8.5, 0.025, 0.025 ) ) \n\t\t\t),\n\t\t\t\tudBox(  vec3( tpos.x, tpos.y-6.3, tpos.z-8.3), vec3( 8.5, 0.025, 0.025 ) ) \n\t\t\t),\n\t\t\topU(opU(opU(\n\t\t\t\tsdCylinderYZ( vec3( pos.x-8.75, pos.y-6.5, mod(pos.z, 13.75)-6.875), vec2( 1.25,20.) ),\n\t\t\t\tsdBox( vec3(  pos.x-8.75, pos.y-2.5, mod(pos.z,  13.75)-6.875), vec3( 20.,4.0,1.25) )\t\t\t\n\t\t\t),\n\t\t\t\tsdCylinderXY( vec3( mod(pos.x,13.75)-6.875, pos.y-6.5, pos.z-8.75), vec2( 1.25,20.) )\n\t\t\t),\n\t\t\t\tsdBox( vec3(  mod(pos.x, 13.75)-6.875, pos.y-2.5, pos.z-8.75), vec3( 1.25,4.0,20.) )\t\n\t\t\t)\n\t\t) ),\n\t\t\tsdTriPrism( vec3(tpos.x, tpos.y-9.3, tpos.z-5.2), vec2(2.0, 10. ) ) \/\/ roof\n\t\t),\n\t\t\tsdTriPrism( vec3(tpos.x, tpos.y-2.8, tpos.z-5.2), vec2(0.75, 8. ) )\n\t\t),\n\t\tudBox( tpos, vec3( 6.5, 2.5, 6.5 ) )\n\t);\n\t\n\treturn res;\n}\n\nfloat objB1( in vec3 pos ) {\n\tfloat res =\n\t\topU(opS(\t\t\t\n\t\t\topS(\n\t\t\t\tudBox( pos, vec3( 20., 30.0, 10. ) ),\t\t\t\t\n\t\t\t\tsdBox( pos+vec3(0., -30., 0.), vec3( 19.75, 1., 9.75 ) )\n\t\t\t),\n\t\t\tsdBox( vec3( mod(pos.x+1.75, 3.5)-1.75, mod(pos.y+3.5, 7.)-2., pos.z-10.), vec3( 1.,1.,4.) )\n\t\t),\n\t\t\topI( \/\/ main building windows\n\t\t\t\tudBox( pos, vec3( 18., 30.0, 10. ) ),\n\t\t\t\topU(\n\t\t\t\t\tudBox(  vec3( mod(pos.x+1.75, 3.5)-1.75, pos.y, pos.z-9.8), vec3( 0.05, 30., 0.05 ) ),\n\t\t\t\t\tudBox(  vec3( pos.x, mod(pos.y+0.425, 1.75)-0.875, pos.z-9.8), vec3( 50.0, 0.05, 0.05 ) )\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\treturn res;\t\n}\n\nfloat objB2( in vec3 pos ) {\n\tvec3 tpos;\/\/ = pos;\n\ttpos.x = min( abs(pos.x), abs(pos.z) );\n\ttpos.y = pos.y;\n\ttpos.z = max( abs(pos.x), abs(pos.z) );\n\t\n\tfloat res = opU(\n\t\t\topS(opS( \/\/ main building\n\t\t\t\topS(\n\t\t\t\t\tudBox( tpos, vec3( 8.75, 31.0, 8.75 ) ),\n\t\t\t\t\tsdBox( vec3(tpos.x, tpos.y-31.0, tpos.z), vec3( 8.5, 1.0, 8.5) ) \n\t\t\t\t\n\t\t\t),\n\t\t\t\tsdBox( vec3( mod(tpos.x+1.75, 3.5)-1.75, mod(tpos.y+4.5, 9.)-2.5, tpos.z-5.), vec3( 1.,2.,4.) )\n\t\t\t),\n\t\t\t\tsdCylinderXY( vec3( mod(tpos.x+1.75, 3.5)-1.75, mod(tpos.y+4.5, 9.)-4.5, tpos.z-5.), vec2( 1.,4.) )\n\t\t\t),\n\t\t\topI( \/\/ main building windows\n\t\t\t\tudBox( tpos, vec3( 8.75, 31.0, 8.75 ) ),\n\t\t\t\topU(\n\t\t\t\t\tudBox(  vec3( mod(tpos.x+1.75, 3.5)-1.75, tpos.y, tpos.z-8.45), vec3( 0.05, 31., 0.05 ) ),\n\t\t\t\t\tudBox(  vec3( tpos.x, mod(tpos.y+0.425, 1.75)-0.875, tpos.z-8.45), vec3( 10.0, 0.05, 0.05 ) )\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\treturn res;\t\n}\n\nvec2 map( in vec3 pos ) {\n    vec2 res = opU( vec2( sdPlane( pos), 3.0 ),\n\t                vec2( udBox( pos+vec3(0.0, 9.0, 85.0), vec3( 200., 10.0, 100. ) ), 1. ) );\n\n\tres = opU( res, vec2( udBox( pos+vec3(0.0, 20.0, 75.0), vec3( 200., 10.0, 100. ) ), 1. ) );\n \tres = opU( res, vec2( udBox( pos+vec3(0.0, 6.5, -15.0), vec3( 200., 10.0, 0.25 ) ), 1. ) );\n\n\tres = opU( res, vec2( udBox( pos+vec3( 220.0, 14.0, 0.0), vec3( 100., 10.0, 200. ) ), 1. ) );\n\t\t\n\tres = opU( res, vec2( udBox( (pos+vec3(3.20, -4.95, -5.55)), vec3( 0.55, 0.9, 0.01 ) ), 2. ) );\n\tres = opU( res, vec2( sdCylinderXZ( vec3(mod(pos.x+8., 16.)-8., pos.y+10., pos.z-24.), vec2( 0.4, 1.5)), 1.) );\n\n\tif( pos.z > 20. ) {\n\t\treturn res;\n\t}\n\t\n\tres = opU( res, vec2( objPrentenTentoonstelling( vec3(mod(pos.x+40.,80.)-40., pos.y, mod(pos.z+40.,80.)-40.) ), 1. ) );\n\t\n\tpos += vec3(3.25, -4.60, -5.55);\n\tres = opU( res, vec2( opI(\n\t\tudBox( vec3(mod(pos.x+0.8, 1.6)-0.8, pos.y, pos.z), vec3( 0.7, 0.9, 0.1 ) ),\n\t\tudBox( pos-vec3(3.25, -4.60, -5.55), vec3( 5.5, 5.5, 8.5 ) )\n\t\t), 4. ) );\n\tpos -= vec3(3.25, -4.60, -5.55);\n\t\n\tpos += vec3( 15.5, 8., 10.);\n\tres = opU( res, vec2( objB1( vec3(mod(pos.x+27.,54.)-27., pos.y, mod(pos.z+50.,100.)-50.) ), 1. ) );\n\tpos += vec3( 20.5, -8., 5.);\n\tres = opU( res, vec2( objB2( vec3(mod(pos.x+23.,46.)-23., pos.y, mod(pos.z+35.,70.)-35.) ), 1. ) );\n\tpos += vec3( 20., -10., 10.);\n\tres = opU( res, vec2( objB1( vec3(mod(pos.x+77.,144.)-77., pos.y, mod(pos.z+66.,132.)-66.) ), 1. ) );\n\t\t\n\treturn res;\n}\n\n\n\/\/ fast castfunctions to detect if droste picture is hit by ray\n\nfloat fastObjPrentenTentoonstelling( in vec3 pos ) {\n\treturn opU(\tudBox(  vec3( pos.x, pos.y-6.3, pos.z-8.3), vec3( 8.5, 0.025, 0.025 ) ),\n\t\t\t\tudBox(  vec3( mod(pos.x-8.375\/18., 8.375\/9.)-8.375\/18., pos.y, pos.z-8.3), vec3( 0.025, 8.5, 0.025 ) )\n\t);\n}\nvec2 fastMap( in vec3 pos ) {\n    return opU( vec2( fastObjPrentenTentoonstelling( pos), 1.0 ),\n\t            vec2( udBox( (pos+vec3(3.30, -4.55, -5.55)), vec3( 0.55, 0.7, 0.01 ) ), 2. ) );\n}\n\nvec2 fastCastRay( in vec3 ro, in vec3 rd, in float maxd )\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float t = 0.0;\n    float m = -1.0;\n    for( int i=0; i<60; i++ )\n    {\n\t\tif( abs(h)<precis || t>maxd ) break;  {\n\t\t\tt += h;\n\t\t\tvec2 res = fastMap( ro+rd*t );\n\t\t\th = res.x;\n\t\t\tm = res.y;\n\t\t}\n    }\n\n    if( t>maxd ) m=-1.0;\n    return vec2( t, m );\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, in float maxd )\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float t = 0.0;\n    float m = -1.0;\n    for( int i=0; i<60; i++ )\n    {\n\t\tif( abs(h)<precis || t>maxd ) break;  {\n\t\t\tt += h;\n\t\t\tvec2 res = map( ro+rd*t );\n\t\t\th = res.x;\n\t\t\tm = res.y;\n\t\t}\n    }\n\n    if( t>maxd ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )\n{\n\tfloat res = 1.0;\n    float t = 0.1;\n    for( int i=0; i<15; i++ )\n    {\n\t\tif( t<maxt )\n\t\t{\n        float h = map( ro + rd*t ).x;\t\t\t\n\t\tres = min( res, k*h\/t );\n        t += 0.005+h;\n\t\t} \n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvoid getRoAndRd( in vec2 uv, out vec3 ro, out vec3 rd ) {\n#ifdef WOBBLE\n\tro = vec3( 20.2+(1.0+cos((t+42.)\/48.*2.*3.1415926))*cos(iGlobalTime), 36.0, 47.0  );\n#else\n\tro = vec3( 20.2, 36.0, 47.0  );\n#endif\t\n\tvec3 ta = vec3( -3.1, 4.8,  5.5 );\n\t\n\t\/\/ camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\trd = normalize( uv.x*cu + uv.y*cv + cw*zoom);\n}\n\nbool hitDrostePicture( vec2 uv ) {\n\tvec3 ro, rd;\n\tgetRoAndRd( uv, ro, rd );\t\n\t\n\tvec2 res = fastCastRay(ro,rd,200.0);\n\treturn (res.y == 2. );\n}\n\nvec4 trace( vec2 uv ) {\n\tvec3 ro, rd;\n\tgetRoAndRd( uv, ro, rd );\n\t\n    vec3 col = vec3(0.);\n\t\t\n    vec2 res = castRay(ro,rd,400.0);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n\n\t\tcol = vec3(0.7);\n\t\tif( m == 3. ) col = vec3(0.6,0.71,1.0);\n\t\tif( m == 4. ) col = vec3( 1. );\n\t\t\n\t\tif( m == 1. && all(lessThan(abs(pos), vec3( 5.65, 10., 5.65 ) ) ) ) {\n\t\t\tcol = vec3( 0.6 ); \/\/ inside gallery\n\t\t}\n\t\t\n\t\tvec3 lig = normalize( vec3(-0.4, 0.4, 0.8) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n\n\t\tfloat sh = 1.0;\n#ifdef SHADOW\t\t\n\t\tif( dif>0.05 ) { sh = softshadow( pos, lig, 0.1, 30.0, 5.0 ); dif *= (0.8+0.2*sh); }\n#endif\t\t\n\t\tvec3 brdf = vec3(0.0);\n\t\tbrdf += 0.80*amb*vec3(0.6,0.71,0.85);\n        brdf += 1.30*dif*vec3(1.00,0.90,0.70);\n\n\t\tcol = col*brdf;\n\t\t\n\t} else {\n\t\tcol = 1.2*vec3(0.6,0.71,0.85) - rd.y*0.2*vec3(1.0,0.5,1.0);\n\t}\n\n\treturn vec4( clamp(col,0.0,1.0), m );\n}\n\nvoid init() {\n\tt = mod( t+11., 48. );\n\n\tif( t < 8. ) st = t;\n\telse if( t < 24. ) st = 8.;\n\telse if( t < 32. ) st = 32.-t;\n\t\t\n\tt = mod( t+12., 48. );\n\t\t\n\tif( t < 8. ) zt = t;\n\telse if( t < 24. ) zt = 8.;\n\telse if( t < 32. ) zt = 32.-t;\n\t\t\n\tdeformationScale = clamp(pow(2.0,st), 1., 256.);\n\tzoom = 2.8*clamp(pow(2.0,zt), 1.0, 256. );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\t\n\tuv = 2.*uv - vec2(1.);\n    uv.x *= iResolution.x\/ iResolution.y;\n\t\t\n\tinit();\n\t\n\tvec3 col = vec3(0.);\n\n\tbool band = abs(uv.x)>1.?true:false;\n\t\n\t\/\/ the  gallerymodel is a factor 1.\/0.7 too high to match Eschers painting, so I cheat :(\n\tuv.x *= 0.7;\n\tuv = escherDeformation(uv);\t\n\tuv = drosteTransformation(uv);\n\t\n\tif( hitDrostePicture(uv) ) uv*=256.;\n\tif( hitDrostePicture(uv) ) uv*=256.;\n\t\n\t\n\tvec4 tr = trace( uv );\n\tcol = tr.xyz;\n\t\n\tif( band ) {\n\t\tcol = mix( col, vec3(0.), st\/8. );\t\n\t}\t\t\n\t\n\tfragColor = vec4( col,1.0);\n}","name":"","description":"","type":"image"}]}}