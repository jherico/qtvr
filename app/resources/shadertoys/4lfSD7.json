{"Shader":{"ver":"0.1","info":{"id":"4lfSD7","date":"1436984048","viewed":1059,"name":"The Red Planet","username":"adam27","description":"My vision of Mars.","likes":6,"published":3,"flags":0,"tags":["3d","terrain","planet","mars","warsztat"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\nconst mat2 mat = mat2(1.8, 1.1, -1.1, 1.8);\n\nfloat rand(vec2 v)\n{\n\tfloat x = fract(sin(dot(v, vec2(1872.8497, -2574.9248))) * 72123.19);\n\treturn x;\n}\n\nfloat noise(in vec2 p) \n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix(mix(rand(i + vec2(0.0,0.0)), rand(i + vec2(1.0,0.0)), u.x),\n\t\t\t\t\t\tmix(rand(i + vec2(0.0,1.0)), rand(i + vec2(1.0,1.0)), u.x), u.y);\n}\n\nfloat map(vec2 xz)\n{\n\txz += noise(xz);\n\tvec2 a = 1.0 - abs(sin(xz));\n\tvec2 b = abs(cos(xz));\n\treturn pow(dot(a, b) * length(cos(xz)), 0.5) + pow(sin(xz.x), 1.0) + pow(cos(xz.y), 1.0);\n}\n\nfloat terrain(vec3 p)\n{\n\tvec2 xz = p.xz \/ 5.0;\n\txz.x *= 0.7;\n\tfloat amp = 1.5;\n\tfloat h = 0.0;\n\tfloat freq = 0.1;\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tfloat h1 = map(xz * freq);\n\t\tfloat h2 = map(xz * freq);\n\t\th += (h1 + h2) * amp;\n\t\tfreq *= 2.1;\n\t\tamp *= 0.21;\n\t\txz *= mat;\n\t}\n\treturn p.y - h;\n}\n\n\nfloat castRay(inout vec3 p, vec3 dir)\n{\t\n\tfloat t = 0.1;    \n\tfloat d = 0.1;\n\tfor (int i = 0; i < 200; i++)\n\t{\n\t\tfloat h = terrain(p + dir*t);\n\t\tif (h < 0.0)\n\t\t\tbreak;\n\t\t\n\t\td *= 1.05;\n        t += d;\n        if (i == 199)\n            return 20000.0;\n\t}\n    \n\tfloat t2 = t;\n\tfloat h2 = terrain(p + dir*t2);\n\tif (h2 > 0.0)\n\t\treturn t2;\n\tfloat t1 = t - d*10.0;\n\tfloat h1 = terrain(p + dir*t1);\n\tfor (int i = 0; i < 8; i++)\n\t{\n\t\tt = mix(t1, t2, h1\/(h1-h2));\n\t\tfloat h = terrain(p + dir*t);\n\t\tif (h < 0.0)\n\t\t{\n            t2 = t; \n            h2 = h;\n        }\n\t\telse\n\t\t{\n            t1 = t; \n            h1 = h;\n        }\n\t}\t\n\tp = p + dir*t;\n\treturn t;\n}\n\nvec3 getNormal(vec3 p, float d)\n{\n    vec3 n;\n    n.y = terrain(p);    \n    n.x = terrain(p + vec3(d, 0.0, 0.0)) - n.y;\n    n.z = terrain(p + vec3(0.0, 0.0, d)) - n.y;\n    n.y = d;\n    return normalize(n);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 angle = vec2(iGlobalTime \/ 4.0, radians(5.0));\n    vec3 center = vec3(-iGlobalTime * 10.0, 0.0, -iGlobalTime * 10.0);\n    float zoom = 1.0;\n    \n    vec3 p = vec3(cos(angle.x)*cos(angle.y), sin(angle.y), sin(angle.x)*cos(angle.y));\n\tvec2 uv = (fragCoord.xy\/* + vec2(int(iGlobalTime*30.0))*\/) \/ iResolution.yy - vec2(iResolution.x \/ iResolution.y \/ 2.0, 0.5);\n    \n    vec3 tx = vec3(-sin(angle.x), 0.0, cos(angle.x));\n    vec3 ty = vec3(-cos(angle.x)*sin(angle.y), cos(angle.y), -sin(angle.x)*sin(angle.y));\n    \n    vec3 p2 = p * 1.5;\n    p = p * zoom + center;\n    p.y -= terrain(vec3(p.x, 0.0, p.z)) - 3.0;\n    \n    vec3 dir = tx * uv.x + ty * uv.y - p2;\n    \n    vec3 color = vec3(0.0);\n    vec3 light = normalize(vec3(0.6, 0.8, 0.3));\n    \n    \n\tfloat dist = castRay(p, dir);\n\t\n    if (dist > 10000.0)\n        color = vec3(0.8, 0.4, 0.2) * 1.0 - dot(vec3(0.0, 1.0, 0.0), dir);\n    else    \n   \t\tcolor = vec3(0.8, 0.45, 0.2) * pow(max(dot(getNormal(p, dist*0.001), light), 0.0), 2.0) + noise(p.xz * 4.0) \/ 25.0;\n\t\n    \n    fragColor = vec4(color, 1.0);\n}","name":"","description":"","type":"image"}]}}