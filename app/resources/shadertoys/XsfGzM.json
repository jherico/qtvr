{"Shader":{"ver":"0.1","info":{"id":"XsfGzM","date":"1365016363","viewed":1639,"name":"Nyan","username":"reinder","description":"Nyan exploring. The shader shows the procedural textures of my shader 'Abandond base on Mars': https:\/\/www.shadertoy.com\/view\/4sfGR7.","likes":21,"published":3,"flags":0,"tags":["procedural","textures"],"hasliked":0},"renderpass":[{"inputs":[{"id":2,"src":"\/presets\/tex01.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":14,"src":"\/presets\/tex14.png","ctype":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Nyan. Created by Reinder Nijhoff 2013\n\/\/ @reindernijhoff\n\/\/\n\/\/ https:\/\/www.shadertoy.com\/view\/XsfGzM\n\/\/\n\n\/\/ seconds needed to walk through room\n#define WALKINGSPEED 3.\n\n#define DIRT\n#define NYANSPEED 16.\n\n#define NUMBERLIGHTS 4\n\n#define EXPOSURE 1.9\n#define AMBIANT 3.\n#define DYNAMICLIGHTSTRENGTH 2.\n#define PI 3.1415926\n\n#define INTERVALBACKGROUND 16.\n#define INTERVALFLOOR 16.\n#define INTERVALFOREGROUND 16.\n#define INTERVALSPECULARCOLOR 1.\n#define INTERVALDIRT 10.\n\n\nfloat dirtFactor;\nfloat time = iGlobalTime + 259.;\n\n\/\/\n\/\/ math functions\n\/\/\n\nconst mat2 mr = mat2 (0.84147,  0.54030,\n\t\t\t\t\t  0.54030, -0.84147 );\nfloat hash( float n ) {\n\treturn fract(sin(n)*43758.5453);\n}\nvec2 hash2( float n ) {\n    return fract(sin(vec2(n,n+1.0))*vec2(2.1459123,3.3490423));\n}\n\nvec3 hash3( float n ) {\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(3.5453123,4.1459123,1.3490423));\n}\nfloat noise(in float x) {\n\tfloat p = floor(x);\n\tfloat f = fract(x);\n\t\t\n\tf = f*f*(3.0-2.0*f);\t\n\treturn mix( hash(p+  0.0), hash(p+  1.0),f);\n}\nfloat noise(in vec2 x) {\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\t\t\n\tf = f*f*(3.0-2.0*f);\t\n\tfloat n = p.x + p.y*57.0;\n\t\n\tfloat res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n\t\t\t\t\tmix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n\treturn res;\n}\nfloat fbm( vec2 p ) {\n\tfloat f;\n\tf  =      0.5000*noise( p ); p = mr*p*2.02;\n\tf +=      0.2500*noise( p ); p = mr*p*2.33;\n\tf +=      0.1250*noise( p ); p = mr*p*2.01;\n\tf +=      0.0625*noise( p ); p = mr*p*2.01;\n\treturn f\/(0.9175);\n}\n\n\/\/\n\/\/ material functions\n\/\/\n\nfloat matfhf, matflf;\nfloat matnoisehf;\nvec3 math3;\n\nvoid materialInit(in float seed, const vec2 coord) {\n\tmatfhf = fbm( coord * 171. );\n\tmatflf = fbm( coord );\n\tmatnoisehf = noise( coord * 193. );\n\tmath3  = hash3( seed * 11. );\n}\n\nvec3 materialBaseColor( float t ) {\n\tt = mod( t, 3490423. );\n\treturn texture2D( iChannel0, vec2( t )*vec2(0.14591255443,0.34934560423) ).xyz;\n}\n\nvoid materialDirt( const vec2 coord, out vec3 color, out vec2 normal ) {\n\tcolor = vec3( 0.7, 0.5, 0.4 ) * (0.25+0.75*matfhf);\n\tnormal = vec2( matnoisehf*2. -1. );\n}\n\nvec2 materialGrooves( float seed, bool iswall ) {\n\tvec2 math2 = hash2( seed );\n\tif( iswall ) return clamp( floor(math2*6.) \/ 8. - 0.25, vec2(0.), vec2(1.));\n\treturn clamp( floor( math2*4.) \/ 8., vec2(0.), vec2(1.));\n}\n\nfloat grooveHeight( float l, const float w, float p ) {\n\tif( l == 0. ) return 1.;\n\treturn (smoothstep( 0.,  w*0.5, mod(p, l) )) * (1.-smoothstep( l-w*0.5, l, mod(p, l) ));\n}\n\nfloat materialHeightMap( const vec2 grooves, const vec2 coord ) {\n\treturn min( grooveHeight( grooves.x, 0.01, coord.x ), grooveHeight( grooves.y, 0.01, coord.y ));\n}\n\nfloat materialDirtAmount( const vec2 grooves, const vec2 coord ) {\n\tvec2 f = mix( vec2(0.01), grooves*2., dirtFactor );\n\treturn 1. - 0.5*min( grooveHeight( grooves.x, f.x, coord.x ), grooveHeight( grooves.y, f.y, coord.y ));\n}\n\n\/\/ calculate color\n\nvoid getMaterial( float seed, const vec2 coord, const vec2 grooves,  bool isfloor, bool iswall, \n\t\t\t  \t  out vec3 color, out vec2 normal, out float spec ) {\n\n\tfloat height = materialHeightMap( grooves, coord );\t\n\tnormal.x = (height-materialHeightMap( grooves, coord-vec2(0.002,0.) )) * 500.;\n\tnormal.y = (height-materialHeightMap( grooves, coord-vec2(0.,0.002) )) * 500.;\n\tnormal += 0.1*fract( math3.y * 1.64325 ) * (2. * vec2( matfhf, matnoisehf ) - vec2(1.));\n\t\n\tspec = (height + 4.*matfhf )*0.1*fract( math3.x * 1.13 )*matflf;\n\t\n\tvec3 color1 = materialBaseColor( seed ); \t\n\tvec3 color2 = materialBaseColor( seed*2.6345 ); \t\n\n\t\/\/ checkboard ?\n\tbool checkx = grooves.x > 0. && mod( coord.x, grooves.x*2. ) < grooves.x;\n\tbool checky = grooves.y > 0. && mod( coord.y, grooves.y*2. ) < grooves.y;\n\t\n\tif( fract( math3.z * 4.435 ) < 0.5 && ((checkx && checky) || (!checkx && !checky)) ) {\n\t\tcolor = mix( color2, color1, matflf*fract(math3.y*45.234) );\n\t} else {\t\t\n\t\tcolor = mix( color1, color2, matflf*fract(math3.y*45.234) );\n\t}\n\t\n\tcolor *= (0.8+0.2*height+0.2*fract( math3.x*3.76 )*matfhf);\n\t\t\n#ifdef DIRT\t\n\tif( dirtFactor > 0.1 ) { \/\/ dirt\n\t\tvec2 dirtNormal; vec3 dirtColor;\t\t\n\t\tmaterialDirt( coord, dirtColor, dirtNormal );\n\t\t\n\t\tfloat dirtAmount = materialDirtAmount( grooves, coord );\t\n\n\t\tif( iswall ) {\n\t\t\tdirtAmount += clamp( dirtFactor - coord.y, -dirtAmount, 1.);\n\t\t} else\tif( !isfloor ) {\n\t\t\tdirtAmount *= 0.5; \/\/ less dirt on ceiling\n\t\t}\n\t\n\t\tdirtFactor = clamp( 10. * (0.5* (dirtAmount * matflf + matfhf ) - (1.-dirtFactor)), 0., 1.);\n\t\n\t\tif( dirtFactor > 0.1 ) {\n\t\t\tcolor = mix( color, dirtColor, dirtFactor );\n\t\t\tspec *= 1. - dirtFactor;\n\t\t\tnormal = mix( normal, dirtNormal, dirtFactor );\n\t\t}\n\t}\n#endif\n}\n\nvoid getWallMaterial( float seed, vec2 coord,  \n\t\t\t\t\t  out vec3 color, out vec2 normal, out float spec ) {\n\tcoord *= 0.1;\n\tmaterialInit( seed, coord );\n\t\n\tfloat s = mod( floor( math3.y*13.4361 ), 8. ) * 0.125;\n\t\n\tfloat wseed = seed;\n\tif( coord.y > s ) wseed += 1.;\t\n\n\tvec2 grooves = materialGrooves( wseed, true );\n\n\tgetMaterial( seed, coord, vec2(grooves.x, max( grooves.y, s )), false, true, color, normal, spec );\n}\n\nvoid getFloorMaterial( float seed, vec2 coord, bool isfloor,  \n\t\t\t\t\t   out vec3 color, out vec2 normal, out float spec ) {\t\n\tcoord *= 0.1;\n\tmaterialInit( seed, coord );\n\tvec2 grooves = materialGrooves( seed, false );\n\n\tgetMaterial( seed, coord, grooves, isfloor, false, color, normal, spec );\n}\n\n\nvec3 getColor(vec2 coord) {\n\tfloat z, spec, offset;\n\tvec3 color, position, normal, retcolor;\n\tvec2 ntangent;\n\t\n\toffset = time * NYANSPEED;\n\t\n\tcoord.y += 0.4;\n\t\n\tif( coord.y >  0. ) { \/\/ wall at z = -8.\n\t\tz = 8.; vec2 dxy = vec2( z );\n\t\tposition = vec3( coord*dxy, z );\n\t\tfloat material = floor( (position.x+offset) \/ INTERVALBACKGROUND );\t\n\t\tgetWallMaterial( material, position.xy+offset*vec2(1., 0.), color, ntangent, spec );\n\t\tnormal = normalize( vec3( -ntangent.x, -ntangent.y, -1. ) );\n\t} else if( coord.y < -0.125 ) { \/\/ wall at z = -4;\n\t\tz = 4.; vec2 dxy = vec2( z );\n\t\tposition = vec3( (coord+vec2(0.,0.125))*dxy, z );\n\t\tfloat material = floor( (position.x+offset) \/ INTERVALFOREGROUND );\n\t\tgetFloorMaterial( material, position.xy+offset*vec2(1., 0.), false, color, ntangent, spec );\n\t\tnormal = normalize( vec3( -ntangent.x, -ntangent.y, -1. ) );\n\t} else { \/\/ floor\n\t\tz = -1.\/(coord.y-0.125); vec2 dxy = vec2( z );\n\t\tposition = vec3( coord*dxy, z );\n\t\tfloat material = floor( (position.x+offset) \/ INTERVALFLOOR );\n\t\tgetFloorMaterial( material, position.xz+offset*vec2(1., 0.), true, color, ntangent, spec );\n\t\tnormal = normalize( vec3( -ntangent.x, 1., -ntangent.y ) );\n\t}\n\t\n\t\/\/ nyan cat! at z=-7;\n\tz = 7.; vec2 dxy = vec2( z );\n\tvec2 nyanpos = coord*dxy+vec2( 6.5, 1.2 );\n\tbool nyanhit = false;\n\t\n\tif( nyanpos.x >= 0. && nyanpos.x < 5. && nyanpos.y >= 0. && nyanpos.y < 5. ) {\n\t\tvec2 nyancoord = nyanpos\/5.;\n\t\t\n\t\tfloat ofx = floor( mod( time*NYANSPEED, 6.0 ) );\n\t\tfloat ww = 40.0\/256.0;\n\t\t\t\t\n\t\tnyancoord.y = 1.0-nyancoord.y;\n\t\tnyancoord.x = clamp( nyancoord.x*ww + ofx*ww, 0.0, 1.0 );\n\t\tvec4 nyan = texture2D( iChannel1, nyancoord );\n\t\tif( nyan.w > 0. ) {\n\t\t\tcolor = nyan.xyz;\n\t\t\tnormal = vec3( 0., 0., -1. );\n\t\t\tposition =  vec3( nyanpos, z );\n\t\t\tspec = 0.5;\n\t\t\tnyanhit = true;\n\t\t}\n\t}\n\t\t\n\tvec3 diffcolor = vec3(0.6);\n\tretcolor = diffcolor*color*AMBIANT * dot( normalize( -vec3( 0.8, -0.8, 1.0 ) ), normal );\n\t\n\t\/\/ dynamic lights\n\n\tfloat specfactor = time\/INTERVALSPECULARCOLOR;\n\tvec3 speccolor = normalize( mix( hash3( floor( specfactor ) ), hash3( floor( specfactor+1. ) ), fract( specfactor ) ) );\n\t\n\tfloat totalwidth = 40.;\n\tvec3 rd = normalize( vec3( coord, 0.1 ) );\n\t\n\tfor( int i=0; i<NUMBERLIGHTS; i++) {\n\t\tfloat lx = mod( float(i)*totalwidth\/float(NUMBERLIGHTS)-offset, totalwidth)-totalwidth\/2.;\n\t\tvec3 loffset = vec3( 1.5*sin(time*2.+float(i)), 4.4*cos(time*1.3+float(i)), 3.*sin(time*0.9+float(i)) );\n\n\t\tvec3 lpos = vec3( lx, 5., 4.5 ) + loffset;\n\t\tvec3 lvec = lpos - position;\n\t\t\n\t\tfloat llig = dot( lvec, lvec);\n\t\tfloat im = inversesqrt( llig );\n\t\tlvec = im * lvec;\n\t\t\n\t\t\/\/ diffuse\n\t\tfloat diff = DYNAMICLIGHTSTRENGTH * clamp( dot( lvec, normal ), 0., 1.);\t\n\t\t\/\/ specular\t\t\n\t\tfloat specu = clamp( dot( reflect(rd,normal), lvec ), 0.0, 1.0 );\n\t\tspecu = 40. * DYNAMICLIGHTSTRENGTH * spec * (pow(specu,16.0) + 0.5*pow(specu,4.0));\n\t\t\n\t\tretcolor += speccolor * color * (diff+specu) \/ llig;\n\t}\n\n\tif( !nyanhit ) {\n\t\tfloat ao = length(position- vec3( -3.5, 1.3, 6.));\n\t\tretcolor *= clamp( ao*0.4, 0., 1.);\n\t}\n\t\n\treturn retcolor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 q = fragCoord.xy\/iResolution.xy;\n\tvec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x\/iResolution.y;\n\t\n\tdirtFactor = 0.4+0.2*sin(time\/INTERVALDIRT+1.6);\n\t\n\tvec3 color = getColor( p );\n\tcolor = pow( 0.7*color, vec3(EXPOSURE) );\t\n    \/\/ vigneting\n    color *= 0.25+0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15 );\n\t\n\tfragColor = vec4( color, 1.0);\n}","name":"","description":"","type":"image"}]}}