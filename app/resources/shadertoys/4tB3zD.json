{"Shader":{"ver":"0.1","info":{"id":"4tB3zD","date":"1427154367","viewed":1062,"name":"Raymarching Attempt 2","username":"Craxic","description":"A much much faster version of my first ray marcher. I've noticed that using continuous functions rather than if statements yields much much better results (way more than I expected). Neat!","likes":24,"published":3,"flags":0,"tags":["raymarching"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Copyright (C) 2015 Matthew Ready\n\/\/ Licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Australia license.\n\/\/ http:\/\/creativecommons.org\/licenses\/by-nc-sa\/3.0\/au\n\n#define INNER_RADIUS 0.75\n#define OUTER_RADIUS 0.9\n#define SHEET_THICKNESS 0.012\n#define NOISINESS 10.0\n\n#define INNER_COLOR vec4(0.0, 30.0, 30.0, 1.0)\n#define OUTER_COLOR vec4(20.0, 20.0, 30.0, 1.0)\n\n#define NUM_STEPS 20\n#define TIME_SCALE 5.0\n\nfloat trapezium(float x)\n{\n    \/\/            __________\n    \/\/ 1.0 -     \/          \\\n    \/\/          \/            \\                .\n    \/\/ 0.5 -   \/              \\              .  --> Repeating\n    \/\/        \/                \\            . \n    \/\/ 0.0 - \/                  \\__________\/\n    \/\/\n    \/\/       |    |    |    |    |    |    |\n    \/\/      0.0  1\/6  2\/6  3\/6  4\/6  5\/6  6\/6\n    \/\/\n\treturn min(1.0, max(0.0, 1.0 - abs(-mod(x, 1.0) * 3.0 + 1.0)) * 2.0);\n}\n\nvec3 colFromHue(float hue)\n{\n    \/\/ https:\/\/en.wikipedia.org\/wiki\/Hue#\/media\/File:HSV-RGB-comparison.svg\n\treturn vec3(trapezium(hue - 1.0\/3.0), trapezium(hue), trapezium(hue + 1.0\/3.0));\n}\n\n\/\/ Cheap noise functions. I just messed around with sin functions until\n\/\/ I got something I liked. The important thing was to make sure the periods\n\/\/ of the sin functions weren't constant and varied over space.\nfloat cnoise3(float pos)\n{\n\treturn (cos(pos \/ 2.0) * 0.2 + 1.0);\n}\n\nfloat cnoise2(float pos)\n{\n\treturn (sin(pos * cnoise3(pos) \/ 2.0) * 0.2 + 1.0);\n}\n\nfloat cnoise(vec4 pos)\n{\n    \/\/ These values are all very carefully chosen using \n    \/\/ lots of very complex mathematics. In other news, \n    \/\/ bashing my head on my keyboard is now complex \n    \/\/ mathematics\n    float x = pos.x * cnoise2(pos.y) + pos.w * 0.87123 + 82.52;\n    float y = pos.y * cnoise2(pos.z) + pos.w * 0.78725 + 12.76;\n    float z = pos.z * cnoise2(pos.x) + pos.w * 0.68201 + 42.03;\n    return (sin(x) + sin(y) + sin(z)) \/ 3.0;\n}\n\nvec4 merge_colours(vec4 apply_this, vec4 on_top_of_this)\n{\n    \/\/ Very basic colour merging\n    return on_top_of_this * (1.0 - apply_this.a) + apply_this * apply_this.a;\n}\n\nvec4 getdensity(vec3 pos)\n{\n    \/\/ This function get's the \"density\" of fog at a position in space (pos)\n    \n    \/\/ First, let's make a variable we can reuse for scaled time.\n    float time = iGlobalTime * TIME_SCALE;\n    \n    \/\/ The next thing to do is decide where to sample the noise functions.\n    \/\/ We want the radius of the bubble to be constant along any ray from \n    \/\/ the center of the bubble. So, to ensure that we always sample the same\n    \/\/ position in the noise function for any ray, we normalize the position\n    \/\/ vector (since the origin of the bubble is at 0)\n    vec3 samplePos = normalize(pos);\n    \n    \/\/ The inner colour of the buble is just a random colour sampled from the cheap noise function.\n    vec4 inner_color = vec4(colFromHue(cnoise(vec4(samplePos \/ 5.0, time \/ 15.0))) * 25.0, 1.0);\n    \/\/ The outer colour of the buble is a big whiter than the inside. This helps make the bubble\n    \/\/ look more natural.\n    vec4 outer_color = merge_colours(vec4(25.0,25.0,25.0,0.5), inner_color);\n    \n    \/\/ Now we're going to sample the noise function to get the radius of the bubble along this ray\n    float sample = (cnoise(vec4(samplePos * NOISINESS, time)) + 1.0) \/ 2.0;\n    \/\/ Clamp the noise in case using a different noise function (perlin for example)\n    sample = clamp(sample, 0.0, 1.0);\n    \/\/ Calculate the inner and outer most radius boundaries\n    float innerIncBorder = INNER_RADIUS + SHEET_THICKNESS;\n    float outerIncBorder = OUTER_RADIUS - SHEET_THICKNESS;\n    \/\/ Calculate the radius of the bubble by linearly interpolating \n    \/\/ the noise sample between inner and outer boundaries.\n    float radius = innerIncBorder + (outerIncBorder - innerIncBorder) * sample;\n    \n    \/\/ Calculate the distance between the volume sample position and the center of the bubble\n    float dist = distance(pos, vec3(0.0, 0.0, 0.0));\n    \/\/ Calculate the density of the fog. We use a very \"strongly peaking\" function here. \n    \/\/ It's almost 0 everywhere except at radius, where it peaks to 1 and then falls to 0 very quickly.\n    \/\/ Take a look at it in wolframalpha. \n    float density = exp(-pow(dist - radius, 2.0) * 05000.0);\n    \n    \/\/ Calculate final color here. Lerp the inner and outer colours depending on the radius and scale by density\n    return (inner_color + (outer_color - inner_color) * (radius - innerIncBorder) \/ (outerIncBorder - innerIncBorder)) * density;\n}\n\nvec4 raymarch(vec3 start, vec3 end)\n{\n    \/\/ This is the ray marching function. Here, we sample NUM_STEPS points along the vector\n    \/\/ between start and end. Then, we integrate the resultant densities linearly.\n    vec4 retn = vec4(0.0, 0.0, 0.0, 0.0);\n\tvec3 delta = end - start;\n    float stepDistance = length(delta) \/ float(NUM_STEPS);\n    \n    vec4 densityPrevious = getdensity(start);\n    for (int i = 1; i < NUM_STEPS; i++) \n    {\n        vec3 samplePos = start + delta * float(i) \/ float(NUM_STEPS);\n        vec4 density = getdensity(samplePos);\n        \/\/ Integrate the density using linear interpolation\n        \/\/ The colours will be the average of the two weighted by their alpha\n        vec4 densityIntegrated = (density + densityPrevious) \/ 2.0;\n        \/\/ Optimised out to return. densityIntegrated *= stepDistance\n        retn += densityIntegrated;\n        \n        densityPrevious = density;\n    }\n    \n    return retn * stepDistance;\n}\n\nvec4 raymarch_ball(vec2 coord)\n{\n\t\/\/ Now we're going to intersect a ray from the \n    \/\/ coord along the Z axis onto two spheres, one \n    \/\/ inside the other (same origin). getdensity \n    \/\/ is only > 0 between these volumes.\n    float d = distance(coord, vec2(0.0, 0.0));\n    if (d > OUTER_RADIUS) {\n        \/\/ No intersection on the spheres.\n\t\treturn vec4(0.0, 0.0, 0.0, 0.0);\n    }\n    float dOuterNormalized = d \/ OUTER_RADIUS;\n    float outerStartZ = -sqrt(1.0 - dOuterNormalized*dOuterNormalized) * OUTER_RADIUS; \/\/ sqrt(1-x*x) = function of a circle :)\n    float outerEndZ = -outerStartZ;\n    if (d > INNER_RADIUS) {\n        \/\/ The ray only intersects the larger sphere, \n        \/\/ so we need to cast from the front to the back\n        \n        \/\/ We do it twice so that the number of samples in this branch\n        \/\/ is identical to the number of samples \n        \/\/ inside the blob. Otherwise we see artifacts with \n        \/\/ a lower number of samples.\n        vec4 frontPart = raymarch(vec3(coord, outerStartZ), vec3(coord, 0));\n        vec4 backPart = raymarch(vec3(coord, 0), vec3(coord, outerEndZ));\n        return frontPart + backPart;\n    }\n    \n    float dInnerNormalized = d \/ INNER_RADIUS;\n    float innerStartZ = -sqrt(1.0 - dInnerNormalized*dInnerNormalized) * INNER_RADIUS; \/\/ sqrt(1-x*x) = function of a circle :)\n    float innerEndZ = -innerStartZ;\n    \/\/ The ray intersects both spheres.\n    vec4 frontPart = raymarch(vec3(coord, outerStartZ), vec3(coord, innerStartZ));\n    vec4 backPart = raymarch(vec3(coord, innerEndZ), vec3(coord, outerEndZ));\n    vec4 final = frontPart + backPart;\n    return final;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy \/ min(iResolution.x, iResolution.y)) * 2.0 - vec2(iResolution.x \/ iResolution.y, 1.0);\n    fragColor = merge_colours(raymarch_ball(uv), vec4(0.0, 0.0, 0.0, 1.0));\n}","name":"","description":"","type":"image"}]}}