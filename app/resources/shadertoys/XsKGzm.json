{"Shader":{"ver":"0.1","info":{"id":"XsKGzm","date":"1453864935","viewed":112,"name":"Alien Tunnel Timewarp","username":"cacheflowe","description":"Experimenting with more complex shapes, but still not very complex at all, and I have no idea what I'm doing.","likes":4,"published":3,"flags":0,"tags":["lattice"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define ITERATIONS 512\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )\/k;\n}\n\nfloat smin( float a, float b )\n{\n    return smin(a, b, 12. + 4. * sin(iGlobalTime\/2.));\n}\n\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r ) {\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n\nfloat opBlend( vec3 p ) {\n    vec3 boxSize = vec3(0.02 + 0.1 * sin(p.z\/10.), 0.03 + 0.2 * sin(p.z\/20.), 0.25);\n    float d1 = udRoundBox( p, boxSize, 0.1);\n    vec3 cylinderSize = vec3(0.01 + 0.005 * sin(p.z\/10.), 0.01 + 0.02 * sin(p.z\/20.), 0.01);\n    float d2 = sdCylinder(p, cylinderSize);\n    \/\/return smin( d1, d2 );\n    return smin( d1, d2, 12. + 4. * sin(iGlobalTime\/2.) );\n}\n\nfloat opRep( vec3 p, vec3 spacing ) {\n    vec3 q = mod(p, spacing) - 0.5 * spacing;\n    return opBlend(q);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ 1 : retrieve the fragment's coordinates\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    uv -= vec2(0.5, 0.5);\n\n\t\/\/ 2 : camera position and ray direction\n\tvec3 pos = vec3( 0, iGlobalTime\/2., iGlobalTime );\n\tvec3 dir = vec3( uv.x, uv.y, 1.0 + 0.9 * sin(iGlobalTime\/1.) );\n \n\t\/\/ 3 : ray march loop\n    \/\/ ip will store where the ray hits the surface\n\tvec3 ip;\n \n\t\/\/ variable step size\n\tfloat t = 0.0;\n\tfloat findThresh = 0.0001;\n\tint found = 0;\n    int last_i = 0;\n    \n\tfor(int i = 0; i < ITERATIONS; i++) {\n\t\tlast_i = i;\n        \n        \/\/update position along path\n        ip = pos + dir * t;\n \n        \/\/gets the shortest distance to the scene\n        \/\/break the loop if the distance was too small\n        \/\/this means that we are close enough to the surface\n \t\tfloat temp;\n\n\t\t\/\/ make a repeating SDF shape\n        vec3 spacings = vec3(0.7 + 0.4 * sin(iGlobalTime\/4.), 0.5, 0.5);\n\t\ttemp = opRep( ip, spacings );\n\t\tif( temp < findThresh ) {\n\t\t\tfloat r = 0.5 + 0.2 * sin(ip.z\/2. + iGlobalTime\/2. + ip.y\/4.);\n\t\t\tfloat g = 0.3 + 0.2 * sin(ip.z\/4. + iGlobalTime\/2. - ip.y\/2.);\n\t\t\tfloat b = 0.6 + 0.3 * sin(ip.z\/3. + iGlobalTime\/2. + ip.y\/1.);\n\t\t\tip = vec3(r, g, b);\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t\/\/increment the step along the ray path\n\t\tt += temp;\n\t}\n\t\n\t\/\/ make background black if no shape was hit\n\tif(found == 0) {\n\t\tip = vec3(0,0,0);\n\t}\n \n\t\/\/ 4 : apply color to this fragment\n    \/\/ subtract from color as distance increases\n\tfragColor = vec4(ip - (float(last_i)\/0.5) \/ float(ITERATIONS), 1.0 );\n}","name":"","description":"","type":"image"}]}}