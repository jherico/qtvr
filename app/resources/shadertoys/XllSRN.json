{"Shader":{"ver":"0.1","info":{"id":"XllSRN","date":"1435472596","viewed":701,"name":"A Sphere on the Floor","username":"codywatts","description":"A raycaster which casts multiple rays per fragment in order to achieve basic antialiasing. Click and drag the mouse to move the camera.","likes":3,"published":3,"flags":0,"tags":["raycasting","antialiasing"],"hasliked":0},"renderpass":[{"inputs":[{"id":6,"src":"\/presets\/tex05.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define X_AXIS vec3(1, 0, 0)\n#define Y_AXIS vec3(0, 1, 0)\n#define Z_AXIS vec3(0, 0, 1)\n\nstruct Material\n{\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat shininess;\n};\n\nstruct Sphere\n{\n\tvec3 center;\n\tfloat radius;\n\tMaterial material;\n};\n    \nstruct Plane\n{\n\tvec3 point;\n\tvec3 normal;\n\tMaterial material;\n};\n\nstruct Ray\n{\n\tvec3 origin;\n\tvec3 direction;\n};\n\nstruct Intersection\n{\n\tbool hit;\n\tvec3 position;\n\tvec3 normal;\n\tMaterial material;\n};\n\nstruct Camera\n{\n\tvec3 position;\n\tvec3 forward;\n\tvec3 up;\n\tvec3 right;\n};\n\nstruct Spotlight\n{\n\tvec3 position;\n\tvec3 direction;\n\tfloat angle;\n};\n\nIntersection raySphereIntersection(in Ray ray, in Sphere sphere)\n{\n\tIntersection i;\n\ti.hit = false;\n\t\n\tvec3 centerToOrigin = ray.origin - sphere.center;\n\tfloat dotProduct = dot(ray.direction, centerToOrigin);\n\tfloat squareRootTerm = pow(dotProduct, 2.0) - pow(length(centerToOrigin), 2.0) + pow(sphere.radius, 2.0);\n\tif (squareRootTerm < 0.0)\n\t{\n\t\treturn i;\n\t}\n\t\n\tfloat distanceToHit = (-dotProduct) - sqrt(squareRootTerm);\n\tif (distanceToHit < 0.0)\n\t{\n\t\treturn i;\n\t}\n\ti.position = ray.origin + (ray.direction * distanceToHit);\n\ti.normal = normalize(i.position - sphere.center);\n\ti.material = sphere.material;\n\ti.hit = true;\n\treturn i;\n}\n\nIntersection rayPlaneIntersection(in Ray ray, in Plane plane)\n{\n\tIntersection i;\n\ti.hit = false;\n\t\n\tfloat dotProduct = dot(ray.direction, plane.normal);\n\tif (dotProduct == 0.0)\n\t{\n\t\treturn i;\n\t}\n\t\n\tfloat distanceToHit = dot(plane.point - ray.origin, plane.normal)\/dotProduct;\n\tif (distanceToHit < 0.0)\n\t{\n\t\treturn i;\n\t}\n\ti.position = ray.origin + (ray.direction * distanceToHit);\n\ti.normal = plane.normal;\n\ti.material = plane.material;\n\ti.hit = true;\n\treturn i;\n}\n\nvec3 blinnPhong(in vec3 lightPosition, in vec3 cameraPosition, in vec3 objectPosition, in vec3 objectNormal, in Material material)\n{\n\tvec3 fromObjectToLight = normalize(lightPosition - objectPosition);\n\tfloat lambertian = dot(fromObjectToLight, objectNormal);\n\tfloat specularIntensity = 0.0;\n    \n    if (lambertian > 0.0) \/\/ = diffuseIntensity > 0.0\n    {\n        vec3 fromObjectToCamera = normalize(cameraPosition - objectPosition);\n        vec3 halfwayVector = normalize(fromObjectToLight + fromObjectToCamera);\n        float specTmp = max(dot(objectNormal, halfwayVector), 0.0);\n        specularIntensity = pow(specTmp, material.shininess);\n    }\n    \n    return lambertian * material.diffuseColor + specularIntensity * material.specularColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\/\/ Declare constants\n    const int RaysPerFragment = 5;\n\tconst vec3 BallColorOne = vec3(1, 0, 0);\n\tconst vec3 BallColorTwo = vec3(1, 1, 1);\n\tconst int BallSegmentCount = 3;\n\tconst float BallSegmentTransitionFactor = 0.05;\n\tconst float DistanceFromBall = 50.0;\n\tconst float PlaneTextureSize = 12.0;\n\tconst float SpotlightSoftness = 0.2;\n\t\t\n\t\/\/ Define our sphere\n\tSphere s;\n\ts.center = vec3(0, 0, 0);\n\ts.radius = 12.0;\n\ts.material.specularColor = vec3(0, 0, 0);\n\ts.material.shininess = 100.0;\n\t\n\t\/\/ Define our plane\n\tPlane p;\n\tp.point = s.center - vec3(0, s.radius, 0);\n\tp.normal = Y_AXIS;\n\tp.material.specularColor = vec3(1, 1, 1);\n\tp.material.shininess = 1000.0;\n\t\n\t\/\/ Define our spotlight\n\tSpotlight spotlight;\n\tspotlight.position = vec3(10.0, 20.0, 10.0);\n\tspotlight.direction = normalize(s.center - spotlight.position);\n\tspotlight.angle = PI \/ 5.0;\n\t\n\t\/\/ Define our camera\n\tCamera camera;\n\tfloat cameraRotationValue = (iMouse.xy == vec2(0) ? 0.8 * -iGlobalTime : (iMouse.x \/ iResolution.x) * TWO_PI);\n\tcamera.position = s.center + vec3(cos(cameraRotationValue) * DistanceFromBall, DistanceFromBall * (1.0 - (iMouse.y \/ iResolution.y)), sin(cameraRotationValue) * DistanceFromBall);\n\t\n\tvec3 targetPosition = s.center;\n\tcamera.forward = normalize(targetPosition - camera.position);\n\tcamera.right = cross(Y_AXIS, camera.forward);\n\tcamera.up = cross(camera.forward, camera.right);\n\t\n\t\/\/ To antialias our image, we cast multiple rays per fragment and \"average\" the result.\n\tvec3 accumulatedColor = vec3(0, 0, 0);\n\tfloat accumulatedSignificance = 0.0;\n\t\n\tfor (int i = 0; i < RaysPerFragment; ++i)\n\t{\n\t\tfloat t = float(i) \/ float(RaysPerFragment);\n\t\t\n\t\tfloat significance = (1.0 - t);\n\t\t\n\t\tvec2 fragCoordOffset = vec2(cos(t * TWO_PI) * t, sin(t * TWO_PI) * t);\n\t\tvec2 uv = 2.0 * (fragCoord + fragCoordOffset) \/ iResolution.xy - 1.0;\n\t\tuv.x *= iResolution.x \/ iResolution.y;\n\t\t\n\t\tRay r;\n\t\tr.origin = camera.position;\n\t\tr.direction = normalize(camera.forward + camera.right * uv.x + camera.up * uv.y);\n\t\t\n\t\tfloat percentLit = 1.0;\n\t\t\n\t\tIntersection intersection = raySphereIntersection(r, s);\n\t\t\/\/ If our ray hit the sphere...\n\t\tif (intersection.hit == true)\n\t\t{\n\t\t\tvec2 flattenedNormal = normalize(vec2(intersection.normal.x, intersection.normal.z));  \n\t\t\tfloat polarCoordinate = atan(flattenedNormal.y, flattenedNormal.x);\n\t\t\tpolarCoordinate += PI; \/\/ polarCoordinate is now between (0, 2*PI)\n\t\t\tpolarCoordinate = pow(sin(float(BallSegmentCount) * polarCoordinate), 2.0); \/\/ polarCoordinate is now between (0, 1)\n\t\t\t\n\t\t\tfloat smoothFactor = smoothstep(0.5 - BallSegmentTransitionFactor, 0.5 + BallSegmentTransitionFactor, polarCoordinate);\n\t\t\tintersection.material.diffuseColor = BallColorOne * smoothFactor + BallColorTwo * (1.0 - smoothFactor);\n\t\t}\n\t\t\/\/ If the ray didn't hit the sphere, test to see if it hits the plane.\n\t\telse\n\t\t{\n\t\t\tintersection = rayPlaneIntersection(r, p);\n\t\t\t\n\t\t\tif (intersection.hit == true)\n\t\t\t{\n\t\t\t\tvec3 fromPointToIntersection = intersection.position - p.point;\n\t\t\t\tvec2 textureCoordinates = vec2(dot(fromPointToIntersection, X_AXIS), dot(fromPointToIntersection, Z_AXIS)) * (1.0 \/ PlaneTextureSize);\n\t\t\t\t\n\t\t\t\tintersection.material.diffuseColor = texture2D(iChannel0, textureCoordinates).xyz;\n\t\t\t\t\n\t\t\t\t\/\/ We cast a ray from the intersection point back to the light to test whether this position lies in shadow.\n\t\t\t\tRay shadowRay;\n\t\t\t\tshadowRay.origin = intersection.position;\n\t\t\t\tshadowRay.direction = normalize(spotlight.position - intersection.position);\n\t\t\t\t\n\t\t\t\tIntersection shadowIntersection = raySphereIntersection(shadowRay, s);\n\t\t\t\tif (shadowIntersection.hit == true)\n\t\t\t\t{\n\t\t\t\t\tpercentLit = 0.0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvec3 objectColor = vec3(0, 0, 0);\n\t\t\n\t\t\/\/ If the ray hit the sphere or the plane...\n\t\tif (intersection.hit == true)\n\t\t{\n\t\t\tif (percentLit > 0.0)\n\t\t\t{\n\t\t\t\tvec3 fromLightToObject = normalize(intersection.position - spotlight.position);\n\t\t\t\tfloat angleFromLightToObject = acos(dot(fromLightToObject, spotlight.direction));\n\t\t\t\t\n\t\t\t\t\/\/ Smoothstep softens the edges of the spotlight\n\t\t\t\tpercentLit = smoothstep(-SpotlightSoftness, SpotlightSoftness, spotlight.angle - angleFromLightToObject);\n\t\t\t\t\n\t\t\t\tobjectColor = blinnPhong(spotlight.position, camera.position, intersection.position, intersection.normal, intersection.material);\n\t\t\t}\n\t\t\t\n\t\t\tobjectColor = max(objectColor * percentLit, intersection.material.diffuseColor * 0.0025);\n\t\t\tobjectColor *= clamp((60000.0 \/ pow(distance(s.center, intersection.position), 2.0)), 0.0, 1.0);\n\t\t}\n\t\t\n\t\taccumulatedColor += objectColor * significance;\n\t\taccumulatedSignificance += significance;\n\t}\n\t\n\taccumulatedColor \/= accumulatedSignificance;\n\taccumulatedColor = pow(accumulatedColor, vec3(1.0\/2.2)); \/\/ Gamma correction\n\tfragColor = vec4(accumulatedColor, 1.0);\n}","name":"","description":"","type":"image"}]}}