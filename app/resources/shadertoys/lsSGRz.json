{"Shader":{"ver":"0.1","info":{"id":"lsSGRz","date":"1382556152","viewed":1706,"name":"Portal","username":"HLorenzi","description":"A one-way raymarched portal! The camera will travel between both worlds. It will look back rapidly in order to show the one-way-ness of the portal. It also features a nice glow effect I tried to create. (Some code from iq) Got kinda broken recently...","likes":23,"published":3,"flags":0,"tags":["3d","raymarch","glow","portal"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Comment to turn off for faster rendering!\n\/\/#define SHADOWS 1\n#define GLOW 1\n#define SPECULAR 1\n\n\/\/ Increase for bigger glow effect (which also gets a little bugged...)!\n#define GLOW_AMOUNT 4.0\n\n\/\/ Reduce for accuracy-performance trade-off!\n#define RAYMARCH_ITERATIONS 40\n#define SHADOW_ITERATIONS 60\n\n\/\/ Increase for accuracy-performance trade-off!\n#define SHADOW_STEP 2.0\n\n\n\n\nvoid fUnionMat(inout float curDist, inout float curMat, float dist, in float mat)\n{\n\tif (dist < curDist) {\n\t\tcurMat = mat;\n\t\tcurDist = dist;\n\t}\n}\n\nfloat fSubtraction(float a, float b)\n{\n\treturn max(-a,b);\n}\n\nfloat fIntersection(float d1, float d2)\n{\n    return max(d1,d2);\n}\n\nfloat fUnion(float d1, float d2)\n{\n    return min(d1,d2);\n}\n\nfloat pSphere(vec3 p, float s)\n{\n\treturn length(p)-s;\n}\n\nfloat pRoundBox(vec3 p, vec3 b, float r)\n{\n \treturn length(max(abs(p)-b,0.0))-r;\n}\n\nfloat pTorus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat distf(int world, vec3 p, inout float m)\n{\n\tfloat d = 0.0;\n\tm = 0.0;\n\t\n\tif (world == 0) {\n\t\td = 16.0 + p.z;\n\t\tm = 1.0;\n\t\t\n\t\tfUnionMat(d, m, pSphere(vec3(24,22,4) + p, 12.0), 4.0);\n\t\tfUnionMat(d, m, pRoundBox(vec3(6,-35,4) + p, vec3(4,4,11), 1.0), 4.0);\n\t\tfUnionMat(d, m, pRoundBox(vec3(19,-15,0) + p, vec3(4,4,15), 1.0), 4.0);\n\t\tfUnionMat(d, m, pRoundBox(vec3(-12,20,12) + p, vec3(7,7,7), 1.0), 4.0);\n\t} else {\n\t\td = 16.0 + p.z;\n\t\tm = 2.0;\n\t\t\n\t\tfUnionMat(d, m, pRoundBox(vec3(15,35,6) + p, vec3(4,12,9), 1.0), 5.0);\n\t\tfUnionMat(d, m, pRoundBox(vec3(-10,35,10) + p, vec3(15,3,5), 1.0), 5.0);\n\t\tfUnionMat(d, m, pRoundBox(vec3(15,-35,6) + p, vec3(12,6,15), 1.0), 5.0);\n\t}\n\t\n\tfloat portal = pTorus(p, vec2(12,1));\n\t\n\tfUnionMat(d, m, portal, 3.0);\n\t\n\treturn d;\n}\n\nfloat distf2(int world, vec3 p, inout float m)\n{\n\tfloat d = 0.0;\n\tm = 0.0;\n\t\n\tif (world == 0) {\n\t\td = 16.0 + p.z;\n\t\tm = 1.0;\n\t\t\n\t\tfUnionMat(d, m, pSphere(vec3(24,22,4) + p, 12.0), 4.0);\n\t\tfUnionMat(d, m, pRoundBox(vec3(6,-35,4) + p, vec3(4,4,11), 1.0), 4.0);\n\t\tfUnionMat(d, m, pRoundBox(vec3(19,-15,0) + p, vec3(4,4,15), 1.0), 4.0);\n\t\tfUnionMat(d, m, pRoundBox(vec3(-12,20,12) + p, vec3(7,7,7), 1.0), 4.0);\n\t} else {\n\t\td = 16.0 + p.z;\n\t\tm = 2.0;\n\t\t\n\t\tfUnionMat(d, m, pRoundBox(vec3(15,35,6) + p, vec3(4,12,9), 1.0), 5.0);\n\t\tfUnionMat(d, m, pRoundBox(vec3(-10,35,10) + p, vec3(15,3,5), 1.0), 5.0);\n\t\tfUnionMat(d, m, pRoundBox(vec3(15,-35,6) + p, vec3(12,6,15), 1.0), 5.0);\n\t}\n\t\n\treturn d;\n}\n\n\nvec3 normalFunction(int world, vec3 p)\n{\n\tconst float eps = 0.01;\n\tfloat m;\n    vec3 n = vec3( (distf(world,vec3(p.x-eps,p.y,p.z),m) - distf(world,vec3(p.x+eps,p.y,p.z),m)),\n                   (distf(world,vec3(p.x,p.y-eps,p.z),m) - distf(world,vec3(p.x,p.y+eps,p.z),m)),\n                   (distf(world,vec3(p.x,p.y,p.z-eps),m) - distf(world,vec3(p.x,p.y,p.z+eps),m))\n\t\t\t\t );\n    return normalize( n );\n}\n\nvec4 raymarch(float world, vec3 from, vec3 increment)\n{\n\tconst float maxDist = 200.0;\n\tconst float minDist = 0.1;\n\tconst int maxIter = RAYMARCH_ITERATIONS;\n\t\n\tfloat dist = 0.0;\n\t\n\tfloat material = 0.0;\n\t\n\tfloat glow = 1000.0;\n\t\n\tfor(int i = 0; i < maxIter; i++) {\n\t\tvec3 pos = (from + increment * dist);\n\t\tfloat distEval = distf(int(world), pos, material);\n\t\t\n\t\tif (distEval < minDist) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t#ifdef GLOW\n\t\tif (material == 3.0) {\n\t\t\tglow = min(glow, distEval);\n\t\t}\n\t\t#endif\n\t\t\n\t\t\n\t\tif (length(pos.xz) < 12.0 && \n\t\t\tpos.y > 0.0 &&\n\t\t\t(from + increment * (dist + distEval)).y <= 0.0) {\n\t\t\tif (world == 0.0) {\n\t\t\t\tworld = 1.0;\n\t\t\t} else {\n\t\t\t\tworld = 0.0;\n\t\t\t}\n\t\t}\n\t\tdist += distEval;\n\t}\n\t\n\t\n\tif (dist >= maxDist) {\n\t\tmaterial = 0.0;\n\t}\n\t\n\treturn vec4(dist, material, world, glow);\n}\n\nfloat shadow(float world, vec3 from, vec3 increment)\n{\n\tconst float minDist = 1.0;\n\t\n\tfloat res = 1.0;\n\tfloat t = 1.0;\n\tfor(int i = 0; i < SHADOW_ITERATIONS; i++) {\n\t\tfloat m;\n        float h = distf2(int(world), from + increment * t,m);\n        if(h < minDist)\n            return 0.0;\n\t\t\n\t\tres = min(res, 4.0 * h \/ t);\n        t += SHADOW_STEP;\n    }\n    return res;\n}\n\nvec4 getPixel(float world, vec3 from, vec3 to, vec3 increment)\n{\n\tvec4 c = raymarch(world, from, increment);\n\t\n\tvec3 hitPos = from + increment * c.x;\n\tvec3 normal = normalFunction(int(c.z),hitPos);\n\tvec3 lightPos = -normalize(hitPos + vec3(0,0,-4));\n\t\n\tfloat diffuse = max(0.0, dot(normal, -lightPos)) * 0.5 + 0.5;\n\tfloat shade = \n\t\t#ifdef SHADOWS\n\t\t\tshadow(c.z, hitPos, lightPos) * 0.5 + 0.5;\n\t\t#else\n\t\t\t1.0;\n\t\t#endif\n\tfloat specular = 0.0;\t\n\t\t#ifdef SPECULAR\n\t\tif (dot(normal, -lightPos) < 0.0) {\n\t\t\tspecular = 0.0;\n\t\t} else {\n\t\t\tspecular = pow(max(0.0, dot(reflect(-lightPos, normal), normalize(from - hitPos))), 5.0);\n\t\t}\n\t\t#endif\n\t\n\t\n\tvec4 m = vec4(0,0,0,1);\n\t\n\tif (c.y == 1.0) {\n\t\tm = mix(vec4(1,0.1,0.2,1), vec4(1,0.3,0.6,1), sin(hitPos.x) * sin(hitPos.y)) *\n\t\t\tclamp((100.0 - length(hitPos.xy)) \/ 100.0, 0.0, 1.0);\n\t} else if (c.y == 2.0) {\n\t\tm = mix(vec4(0.1,0.2,1,1), vec4(0.5,0.5,1,1), sin(hitPos.x)) *\n\t\t\tclamp((100.0 - length(hitPos.xy)) \/ 100.0, 0.0, 1.0);\n\t} else if (c.y == 3.0) {\n\t\tm = vec4(1,1,1,1);\t\n\t} else if (c.y == 4.0) {\n\t\tm = (fract(hitPos.x \/ 3.0) < 0.5 ? vec4(1,0.1,0.2,1) : vec4(1,0.3,0.6,1));\n\t} else if (c.y == 5.0) {\n\t\tm = (fract(hitPos.x \/ 3.0) < 0.5 ? vec4(0.1,0.4,1,1) : vec4(0.4,0.6,1,1));\n\t}\n\t\n\t\n\treturn mix(vec4(1,1,1,1), (m * diffuse + vec4(1,1,1,1) * specular) * shade, clamp(c.w \/ GLOW_AMOUNT, 0.0, 1.0));\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n\t\/\/ Camera\n\t\n\tvec2 q = fragCoord.xy\/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= -iResolution.x\/iResolution.y;\n    vec2 mo = iMouse.xy\/iResolution.xy;\n\n\t\/\/ camera\t\n\tfloat dist = 50.0;\n\t\n\tvec3 ta = vec3(cos(iGlobalTime \/ 2.0) * 8.0,\n\t\t\t\t\tsin(iGlobalTime \/ 2.0 + 2.0) * 12.0,\n\t\t\t\t   4.0);\n\tvec3 ro = vec3(50.0 + cos(iGlobalTime \/ 2.0) * dist,sin(iGlobalTime \/ 2.0) * dist * 1.5,\n\t\t\t\t   4.0);\n\t\n\t\/\/ camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 0.0, 1.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\t\n\tfloat world;\n\tif (cos(-iGlobalTime \/ 4.0) > 0.0) {\n\t\tworld = 0.0;\n\t} else {\n\t\tworld = 1.0;\n\t}\n\t\n\tfragColor = getPixel(world, ro, ta, rd);\n}","name":"","description":"","type":"image"}]}}