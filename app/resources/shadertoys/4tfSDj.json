{"Shader":{"ver":"0.1","info":{"id":"4tfSDj","date":"1439935663","viewed":890,"name":"Thumpn' Speakers","username":"squid","description":"Speakers move with the actual amplitude values from the sound shader, for better or worse.","likes":9,"published":3,"flags":8,"tags":["3d"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ many thanks to iq and srtuss as well as all the other small things I copied from other people\n\n\n\/\/\treally fake GI based on picking up the color with AO, \n\/\/\t\tmakes the LEDs look like lights and not color changing shapes\n#define SILLY_GI\n\n\/\/\tget a better frame rate\n#define SHADOW_STEPS 40\n\n#define ZOOM 30.\n#define CAM_HEIGHT .5\n#define TARG_Y 4.\n\n\/\/-- sound synth --\n\n\/\/!! this is the real frame rate drain \t!!\n\/\/ change this value first if your frame rate is really bad\n\/\/ (the value is also in the sound shader, but I can't really tell that they are different)\n#define NSPC 64\n\/\/!!\t\t\t\t\t\t\t\t\t!!\n\n#define pi2 6.283185307179586476925286766559\n\n\/\/ cheap and unrealistic distortion\nfloat dist(float s, float d)\n{\n\treturn clamp(s * d, -1.0, 1.0);\n}\nvec2 dist(vec2 s, float d)\n{\n\treturn clamp(s * d, -1.0, 1.0);\n}\n\n\/\/ quantize\nfloat quan(float s, float c)\n{\n\treturn floor(s \/ c) * c;\n}\n\n\/\/ a resonant lowpass filter's frequency response\nfloat filter(float h, float cut, float res)\n{\n\tcut -= 20.0;\n\tfloat df = max(h - cut, 0.0), df2 = abs(h - cut);\n\treturn exp(-0.005 * df * df) * 0.5 + exp(df2 * df2 * -0.1) * 2.2;\n}\n\n\/\/ randomize\nfloat nse(float x)\n{\n\treturn fract(sin(x * 110.082) * 19871.8972);\n\t\/\/return fract(sin(x * 110.082) * 13485.8372);\n}\nfloat nse_slide(float x)\n{\n\tfloat fl = floor(x);\n\treturn mix(nse(fl), nse(fl + 1.0), smoothstep(0.0, 1.0, fract(x)));\n}\n\n\/\/ note number to frequency\nfloat ntof(float n)\n{\n\treturn 440.0 * pow(2.0, (n - 69.0) \/ 12.0);\n}\n\n\/\/ tb303 core\nvec3 synth(float tseq, float t)\n{\n\tvec2 v = vec2(0.0);\n\t\n\tfloat tnote = fract(tseq);\n\tfloat dr = 0.26;\n\tfloat amp = smoothstep(0.05, 0.0, abs(tnote - dr - 0.05) - dr) * exp(tnote * -1.0);\n\tfloat seqn = nse(floor(tseq));\n\t\/\/float seqn = nse_slide(tseq);\n\tfloat n = \/*20.0 + floor(seqn * 38.0);*\/10.0 + floor(seqn * 60.0);\n\tfloat f = ntof(n)+dist(sin((tseq-t)*.1),20.);\n\t\n    float sqr = smoothstep(0.0, 0.01, abs(mod(t * 9.0, 64.0) - 20.0) - 20.0);\n    \n\tfloat base = f;\/\/50.0 + sin(sin(t * 0.1) * t) * 20.0;\n\tfloat flt = exp(tnote * -1.5) * 50.0 + pow(cos(t * 1.0) * 0.5 + 0.5, 4.0) * 80.0 - 0.0;\n\tfor(int i = 0; i < NSPC; i ++)\n\t{\n\t\tfloat h = float(i + 1);\n\t\tfloat inten = 1.0 \/ h;\n\t\t\/\/inten *= sin((pow(h, sin(t) * 0.5 + 0.5) + t * 0.5) * pi2) * 0.9 + 0.1;\n\t\t\n\t\tinten = mix(inten, inten * mod(h, 2.0), sqr);\n\t\t\n\t\tinten *= exp(-1.0 * max(2.0 - h, 0.0));\/\/ + exp(abs(h - flt) * -2.0) * 8.0;\n\t\t\n\t\tinten *= filter(h, flt, 4.0);\n\t\tinten += dist(inten, 8.5)*.5;\n\t\t\n\t\tv.x += inten * sin((pi2 + 0.01) * (t * base * h));\n\t\tv.y += inten * sin(pi2 * (t * base * h));\n\t}\n\t\n\t\n\tfloat o = v.x * amp;\/\/exp(max(tnote - 0.3, 0.0) * -5.0);\n\t\n\t\/\/o = dist(o, 2.5);\n\t\n\treturn vec3(dist(v * amp, 2.0)*1.2, f);\n}\n\n\/\/ heavy 909-ish bassdrum\nfloat kick(float tb, float time)\n{\n\ttb = fract(tb \/ 4.0) * 0.5;\n\tfloat aa = 5.0;\n\ttb = sqrt(tb * aa) \/ aa;\n\t\n\tfloat amp = exp(max(tb - 0.15, 0.0) * -10.0);\n\tfloat v = sin(tb * 100.0 * pi2) * amp;\n\tv = dist(v, 4.0) * amp;\n\tv += nse(quan(tb, 0.001)) * nse(quan(tb, 0.00001)) * exp(tb * -20.0) * 2.5;\n\treturn v;\n}\n\n\/\/ bad 909-ish open hihat\nfloat hat(float tb)\n{\n\ttb = fract(tb \/ 4.0) * 0.5;\n\tfloat aa = 4.0;\n\ttb = sqrt(tb * aa) \/ aa;\n\treturn nse(sin(tb * 4000.0) * 0.0001) * smoothstep(0.0, 0.01, tb - 0.25) * exp(tb * -5.0);\n}\n\n\n\n\/\/ oldschool explosion sound fx\nfloat expl(float tb)\n{\n\t\/\/tb = fract(tb \/ 4.0) * 0.5;\n\tfloat aa = 20.0;\n\ttb = sqrt(tb * aa) \/ aa;\n\t\n\tfloat amp = exp(max(tb - 0.15, 0.0) * -10.0);\n\tfloat v = nse(quan(mod(tb, 0.1), 0.0001));\n\tv = dist(v, 4.0) * amp;\n\treturn v;\n}\n\nvec3 synth1_echo(float tb, float time)\n{\n    vec3 v;\n    v = synth(tb, time) * 0.5;\/\/ + synth2(time) * 0.5;\n\tfloat ec = 0.6, fb = 0.6, et = 2.0 \/ 9.0, tm = 2.0 \/ 9.0;\n\tv += synth(tb, time - et) * ec * vec3(1.0, 0.5, 1.); ec *= fb; et += tm;\n\tv += synth(tb, time - et).yxz * ec * vec3(0.5, 1.0, 1.); ec *= fb; et += tm;\n\tv += synth(tb, time - et) * ec * vec3(1.0, 0.5, 1.); ec *= fb; et += tm;\n\tv += synth(tb, time - et).yxz * ec * vec3(0.5, 1.0, 1.); ec *= fb; et += tm;\n\t\n    return v;\n}\n#define _hfqo if(!highfreqonly)\n\nvec2 mainSound(float time, bool highfreqonly)\n{\n\tvec2 mx = vec2(0.0);\n\t\n\tfloat tb = mod(time * 9.0, 16.0);\n\t\n\tvec3 s1 = synth1_echo(tb, time) * 0.8;\n    if(!highfreqonly && s1.z < 600.) {\n    \tmx = s1.xy;\n    } else if(s1.z > 600.) {\n    \tmx = s1.xy;\n    }\n    \n    mx += expl(mod(time * 9.0, 64.0) \/ 4.5) * 0.4;\n    \n    if(highfreqonly) { mx += vec2(hat(tb) ) + quan(hat(tb), .01)*.4; }\n\t\n\t\/\/mx += dist(fract(tb \/ 16.0) * sin(ntof(77.0 - 36.0) * pi2 * time), 8.0) * 0.2;\n\t\/\/mx += expl(tb) * 0.5;\n\t\n\tfloat k = kick(tb, time) * 0.6;\/\/ - kick(tb, time - 0.004) * 0.5 - kick(tb, time - 0.008) * 0.25);\n\t\n\t_hfqo mx += vec2(k);\n\t\n\t\n\t\n\tmx = dist(mx, 1.2);\n\t\n\treturn mx*.8;\n}\n\/*vec2 mainSound(float time, bool highfreqonly)\n{\n\tvec2 mx = vec2(0.0);\n\t\n\tfloat tb = mod(time * 9.0, 16.0);\n\t\n\t\n\tvec3 s1 = synth1_echo(tb, time) * 0.8 * smoothstep(0.0, 0.01, abs(mod(time * 9.0, 256.0) + 8.0 - 128.0) - 8.0);\n    if(!highfreqonly && s1.z < 600.) {\n    \tmx = s1.xy;\n    } else if(s1.z > 600.) {\n    \tmx = s1.xy;\n    }\n    float hi = 1.0;\n    float ki = smoothstep(0.01, 0.0, abs(mod(time * 9.0, 256.0) - 64.0 - 128.0) - 64.0);\n    float s2i = 1.0 - smoothstep(0.01, 0.0, abs(mod(time * 9.0, 256.0) - 64.0 - 128.0) - 64.0);\n    hi = ki;\n    \n    mx += expl(mod(time * 9.0, 64.0) \/ 4.5) * 0.4 * s2i;\n    \n\tmx += vec2(hat(tb) * 1.5) * hi;\n\t\n\t\/\/mx += dist(fract(tb \/ 16.0) * sin(ntof(77.0 - 36.0) * pi2 * time), 8.0) * 0.2;\n\t\/\/mx += expl(tb) * 0.5;\n\t\n\tmx += vec2(synth2_echo(time, tb)) * 0.2 * s2i;\n\t\n\t\n\tmx = mix(mx, mx * (1.0 - fract(tb \/ 4.0) * 0.5), ki);\n\tfloat sc = sin(pi2 * tb) * 0.4 + 0.6;\n\tfloat k = kick(tb, time) * 0.8 * sc * ki;\/\/ - kick(tb, time - 0.004) * 0.5 - kick(tb, time - 0.008) * 0.25);\n\t\n\t_hfqo mx += vec2(k, k);\n\t\n\t\n\t\n\tmx = dist(mx, 1.00);\n\t\n\treturn vec2(mx.x*cos(time), mx.x*sin(time));\n}*\/\n\/\/-----------------\n\n\/\/------hashes w\/o sine\n#define MOD2 vec2(443.8975,397.2973)\n#define MOD3 vec3(443.8975,397.2973, 491.1871)\n#define MOD4 vec4(443.8975,397.2973, 491.1871, 470.7827)\n\n\/\/----------------------------------------------------------------------------------------\n\/\/\/  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3.zxy, p3.yxz+19.19);\n    return fract(vec3(p3.x * p3.y, p3.x*p3.z, p3.y*p3.z));\n}\n\n\n\/\/------\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat torus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat cylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec3 getClosest( vec2 b0, vec2 b1, vec2 b2 ) \n{\n\t\n  float a =     det(b0,b2);\n  float b = 2.0*det(b1,b0);\n  float d = 2.0*det(b2,b1);\n  float f = b*d - a*a;\n  vec2  d21 = b2-b1;\n  vec2  d10 = b1-b0;\n  vec2  d20 = b2-b0;\n  vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n  vec2  pp = -f*gf\/dot(gf,gf);\n  vec2  d0p = b0-pp;\n  float ap = det(d0p,d20);\n  float bp = 2.0*det(d10,d0p);\n  float t = clamp( (ap+bp)\/(2.0*a+b+d), 0.0 ,1.0 );\n  return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\n\nvec2 _bezier( vec3 a, vec3 b, vec3 c, vec3 p )\n{\n\tvec3 w = normalize( cross( c-b, a-b ) );\n\tvec3 u = normalize( c-b );\n\tvec3 v = normalize( cross( w, u ) );\n\n\tvec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n\tvec2 b2 = vec2( 0.0 );\n\tvec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n\tvec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n\tvec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy );\n\n\treturn vec2( sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z), cp.z );\n}\nfloat bezier1(vec3 p, vec3 a, vec3 b, vec3 c, float r) {\n    vec2 h = _bezier(a, b, c, p);\n\t\t\n\treturn h.x-r;\n}\n\n\nvec4 u( vec4 d1, vec4 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\nvec4 s( vec4 d1, vec4 d2 )\n{\n    return -d2.x > d1.x ? d2*vec4(-1.,1.,1.,1.) : d1;\n    \/\/return max(-d2,d1); max(a,b) = a > b ? a : b\n}\nmat3 rotateX(float r)\n{\n    vec2 cs = vec2(cos(r), sin(r));\n    return mat3(1., 0., 0., 0., cs.x, cs.y, 0., -cs.y, cs.x);\n}\n\nmat3 rotateY(float r)\n{\n    vec2 cs = vec2(cos(r), sin(r));\n    return mat3(cs.x, 0, cs.y, 0, 1, 0, -cs.y, 0, cs.x);\n}\n\nmat3 rotateZ(float r)\n{\n    vec2 cs = vec2(cos(r), sin(r));\n    return mat3(cs.x, cs.y, 0., -cs.y, cs.x, 0., 0., 0., 1.);\n}\n\n\nvec2 Fal = vec2(0.), Fhi = vec2(0.);\n\n\n\nvec4 speaker(vec3 p, float lFal, float lFhi) {\n    \n    vec2 c1 = p.zy-vec2(0., 4.);\n\tfloat S1 = log(max(length(c1),0.4)*0.1);\n    float disp = S1*lFal*step(length(c1),3.6)*.2;\n    \n    vec2 c2 = p.zy-vec2(0., 9.75);\n\tfloat S2 = log(max(length(c2),0.4)*0.1);\n    disp += S2*lFhi*step(length(c2),2.0)*.2;\n    disp = clamp(disp, -3., 0.);\n        \n    vec4 r = \tvec4( box(p-vec3(0., 6., 0.), vec3(3.+disp, 6., 4. )), 3., length(c1), length(c2) );\n    r = u(r,\tvec4( box(p-vec3(-2., 6., 0.), vec3(1., 6., 4.)), 3., 1000., 1000. ));\n    r = u(r,\tvec4( torus((p-vec3(3., 4., 0.)).yxz, vec2(3.5, .1)), 2., 0., 0. ));\n    r = u(r,\tvec4( torus((p-vec3(3., 9.75, 0.)).yxz, vec2(1.9, .1)), 2., 0., 0. ));\n    \/\/r = u(r,\tvec4( length(p-vec3(2., 4., 0.))-.3, 2., 0., 0. ));\n    return r;\n}\n\nvec4 synthbox1(vec3 p) {\t\n    vec4 r = vec4(box(p-vec3(0., 2., 0.), vec3(3., 2., 4.2)), 2., 0., 0.);\n    if(abs(p.z)<4. && p.y > 1. && p.y < 3.) { \/\/makes everything more stable\n   \t\tvec3 q = p;\n    \tq.y = mod(q.y, 1.)-.5;\n    \tq.z = mod(q.z, 1.)-.5;\n    \tr = u(r, vec4(length(q-vec3(3., 0., 0.))-.3, 6., floor(p.z)-3. , floor(p.y)-2.));\n    }\n    return r;\n}\n\nvec4 knob(vec3 p) {\n\tvec4 r = vec4(cylinder(p.zxy, vec2(.3, .25)), 2., 0., 0.);\n    r = u(r, vec4(box(p-vec3(0., .4, 0.), vec3(.23, .09, .05)), 2., 0., 0.) );\n\treturn r;\n}\n\nvec4 synthbox2(vec3 p) {\n    vec4 r = vec4(box(p-vec3(0., 2., 0.), vec3(3., 4., 4.)), 2., 0., 0.);\n    if(abs(p.z)<4.2) {\n    \tr = u(r, vec4(length(p-vec3(3., -1.3, 3.5))-.2, 600., 0., 0.)); \n        vec3 kq = p;\n        kq.z = mod(clamp(kq.z, -3., 3.), 1.5)-.75;\n    \tr = u(r, knob( (kq-vec3(3., 0., 0.))*rotateX( floor(p.z\/1.5 + 1.)*1.3+.2 ) ));\n\t\tvec3 sq = p-vec3(3., 0., 1.);\n        sq.y = mod(clamp(sq.y, 1.5, 5.), .7)-.35;\n        r = s(r, vec4(box(sq, vec3(.5, .2, 2.)), 9., 0., 0.));\n        if(p.y > 1. && p.y < 5. ) {\n        \tvec3 cq = (p-vec3(3., 0., -2.5));\n        \tcq.y = mod(cq.y, 1.)-.5;\n\t\t\tr = u(r, vec4(cylinder(cq.zxy, vec2(.25, .2)), 7., floor(p.y), 0.));\n        }\n    } \n    return r;\n}\n\nvec4 synthstack(vec3 p) {\n\tvec4 r = synthbox1(p*rotateY(-.04));\n    r = u(r, synthbox2((p-vec3(0., 6., 0.))*rotateY(.04)));\n    r = u(r, vec4(\n        bezier1(p, \n                vec3(-3., 1., 0.), \n                vec3(-6., -1.8, 0.), \n\t\t\t\tvec3(-3., 6., 0.), .2), \n        \t8., 0., 0.));\n    return r;\n}\n\nvec4 map(vec3 p) {\n\tvec4 r = vec4(p.y, 1., 0., 0.);\n    \n    r = u(r, speaker((p-vec3(0., 0., 12.))*rotateY(-.3), Fal.x, Fhi.x ));\n    r = u(r, speaker((p-vec3(0., 0., -12.))*rotateY(.3), Fal.y, Fhi.y ));\n    \n    r = u(r, synthstack(p));\n    \n    r = u(r, vec4(bezier1(vec3(p.x, p.y, abs(p.z)), \n                          vec3(-3., .5, 2.),\n                          vec3(-7., .0, 5.), \n                          vec3(-3.3, .5, 9.), .2), 8., 0., 0.));\n    \n    return r;\n}\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\nvec3 matcol(vec3 id, vec3 p) {\n    if (id.x == 1.) {\n        vec2 t = floor(p.xz*.1);\n        float xp = exp(-length(p.xz)*.03);\n        float mx = pow(noise(vec3(t,iGlobalTime*2.)), 40.)*2.;\n        return ( clamp(hash32(t+5.),vec3(0.1), vec3(1.))+mx ) * xp;\/\/vec3(0.8, 0.8, 0.8);\n    }\n    else if\t(id.x == 2.) return vec3(0.1,  0.1, 0.1);\n    else if (id.x == 3.) {\n        if(id.y < 3.6 || id.z < 2.0) return vec3(0.2, 0.2, 0.22)+noise(p*vec3(5.,5.,30.))*.05;\n    \treturn vec3(0.5, 0.45, 0.4)+noise(p)*.15;\n    } else if(id.x == 6.) {\n        float idy = abs(id.y);\n        float vol = step(abs(id.z) > 0. ? Fal.x*1.2 : Fal.y*1.2 , idy)+.05;\n        return clamp(mix(vec3(0.9, .0, 0.), vec3(.2, .8, 0.), floor(idy*.5-.4))*vol,0.,.9)\n            #ifdef SILLY_GI\n            * 2.\n            #endif\n            ; \n    } else if(id.x == 7.) {\n        float idy = abs(id.y);\n        float b = clamp(1.-mod(iGlobalTime*2.5-idy, 4.), .05, .8) \n            #ifdef SILLY_GI\n            * 4.\n            #endif\n            ;\n        return vec3(1., .85, 0.2)*b;\n    } else if(id.x == 8.) {\n        return vec3(0.05, 0., 1.); \n    } else if(id.x == 9.) {\n        return vec3(0.3);\n    }\n    return vec3(3., .0, 0.);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<SHADOW_STEPS; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h\/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0., 1.0 );\n\n}\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)\/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\nvec3 calcLGI( in vec3 pos, in vec3 nor )\n{\n\tvec3 occ = vec3(0.0);\n    float sca = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n        float hr = 0.01 + 0.2*float(i)\/4.0;\n        vec3 aopos =  nor * hr + pos;\n        vec4 v = map(aopos);\n        occ += -(v.x-hr)*sca*matcol(v.yzw, aopos);\n        sca *= 0.9;\n    }\n    return occ;\/\/clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 shade(vec3 p, vec3 n, vec4 rs) {\n\t\/\/return matcol(rs.yzw, p);\n    vec3 mc = matcol(rs.yzw, p);\n    vec3 ao = mc*.1*calcAO(p,n);\n    #ifdef SILLY_GI\n    vec3 gi = .1*calcLGI(p,n);\n    #endif\n    vec3 L1 = normalize(vec3(0.6, .7, .5));\n    float S1 = max(0., dot(n, L1)) * softshadow(p, L1, 0.1, 100.);\n    \n    vec3 L2 = normalize(vec3(0.1, .7, -.5));\n    float S2 = max(0., dot(n, L2)) * softshadow(p, L2, 0.1, 100.);\n    \n    return (S1*vec3(1., .9, .8) + S2*vec3(.8, .8, 1.))*.5*mc + ao \n        #ifdef SILLY_GI\n        + gi\n        #endif\n        ;\n}\n\nvec4 rm( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 800.0;\n    \n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    vec3 m = vec3(-1.0);\n    for( int i=0; i<200; i++ )\n    {\n\t    vec4 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x*.5;\n\t    m = res.yzw;\n    }\n\n    if( t>tmax ) m=vec3(-1.0);\n    return vec4( t, m );\n}\n\nvec3 normal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.0001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iGlobalTime;\n    Fal = (1.-mainSound(t,false))*2.-.5;\n    Fhi = (1.-mainSound(t,true))*2.-.5;\n    \n\tvec2 uv = fragCoord.xy \/ iResolution.y * 2. - vec2(1.75, 1.);\n    vec2 mouse = (iMouse.xy \/ iResolution.xy);\n    float T = -mouse.x*6. + 0.5;\n    vec3 ro = vec3(cos(T), CAM_HEIGHT + 2.*mouse.y, sin(T))*ZOOM;\n    vec3 ww = normalize(vec3(0., TARG_Y, 0.) - ro);\n    vec3 uu = normalize(cross(ww, vec3(0., 1., 0.)));\n    vec3 vv = cross(ww, uu);\n    vec3 rd = normalize(ww*2.5 + uu*uv.x + vv*-uv.y);\n    \n    vec4 rs = rm(ro,rd);\n    if(rs.y > -1.) {\n        vec3 pos = ro+rd*rs.x;\n        vec3 nor = normal(pos);\n        vec3 col = shade(pos,nor,rs);\n        vec2 px = (fragCoord.xy \/ iResolution.xy);\n        float vignette = px.x * px.y * ( 1.0 - px.x ) * ( 1.0 - px.y );\n    \tvignette = clamp( pow( 8.0 * vignette, 0.3 ), 0.0, 1.0 );\n        col *= vignette;\n    \tfragColor = vec4(pow(col,vec3(1.\/2.2)),1.);\n    } else {\n    \tfragColor = vec4(0.);\n    }\n}","name":"","description":"","type":"image"},{"inputs":[],"outputs":[{"channel":"0"}],"code":"\n\/\/remix(?) of srtuss's acid jam\n\n#define NSPC 256\n\n#define pi2 6.283185307179586476925286766559\n\n\/\/ cheap and unrealistic distortion\nfloat dist(float s, float d)\n{\n\treturn clamp(s * d, -1.0, 1.0);\n}\nvec2 dist(vec2 s, float d)\n{\n\treturn clamp(s * d, -1.0, 1.0);\n}\n\n\/\/ quantize\nfloat quan(float s, float c)\n{\n\treturn floor(s \/ c) * c;\n}\n\n\/\/ a resonant lowpass filter's frequency response\nfloat filter(float h, float cut, float res)\n{\n\tcut -= 20.0;\n\tfloat df = max(h - cut, 0.0), df2 = abs(h - cut);\n\treturn exp(-0.005 * df * df) * 0.5 + exp(df2 * df2 * -0.1) * 2.2;\n}\n\n\/\/ randomize\nfloat nse(float x)\n{\n\treturn fract(sin(x * 110.082) * 19871.8972);\n\t\/\/return fract(sin(x * 110.082) * 13485.8372);\n}\nfloat nse_slide(float x)\n{\n\tfloat fl = floor(x);\n\treturn mix(nse(fl), nse(fl + 1.0), smoothstep(0.0, 1.0, fract(x)));\n}\n\n\/\/ note number to frequency\nfloat ntof(float n)\n{\n\treturn 440.0 * pow(2.0, (n - 69.0) \/ 12.0);\n}\n\n\/\/ tb303 core\nvec2 synth(float tseq, float t)\n{\n\tvec2 v = vec2(0.0);\n\t\n\tfloat tnote = fract(tseq);\n\tfloat dr = 0.26;\n\tfloat amp = smoothstep(0.05, 0.0, abs(tnote - dr - 0.05) - dr) * exp(tnote * -1.0);\n\tfloat seqn = nse(floor(tseq));\n\t\/\/float seqn = nse_slide(tseq);\n\tfloat n = \/*20.0 + floor(seqn * 38.0);*\/10.0 + floor(seqn * 60.0);\n\tfloat f = ntof(n)+dist(sin((tseq-t)*.1),20.);\n\t\n    float sqr = smoothstep(0.0, 0.01, abs(mod(t * 9.0, 64.0) - 20.0) - 20.0);\n    \n\tfloat base = f;\/\/50.0 + sin(sin(t * 0.1) * t) * 20.0;\n\tfloat flt = exp(tnote * -1.5) * 50.0 + pow(cos(t * 1.0) * 0.5 + 0.5, 4.0) * 80.0 - 0.0;\n\tfor(int i = 0; i < NSPC; i ++)\n\t{\n\t\tfloat h = float(i + 1);\n\t\tfloat inten = 1.0 \/ h;\n\t\t\/\/inten *= sin((pow(h, sin(t) * 0.5 + 0.5) + t * 0.5) * pi2) * 0.9 + 0.1;\n\t\t\n\t\tinten = mix(inten, inten * mod(h, 2.0), sqr);\n\t\t\n\t\tinten *= exp(-1.0 * max(2.0 - h, 0.0));\/\/ + exp(abs(h - flt) * -2.0) * 8.0;\n\t\t\n\t\tinten *= filter(h, flt, 4.0);\n\t\tinten += dist(inten, 8.5)*.5;\n\t\t\n\t\tv.x += inten * sin((pi2 + 0.01) * (t * base * h));\n\t\tv.y += inten * sin(pi2 * (t * base * h));\n\t}\n\t\n\t\n\tfloat o = v.x * amp;\/\/exp(max(tnote - 0.3, 0.0) * -5.0);\n\t\n\t\/\/o = dist(o, 2.5);\n\t\n\treturn vec2(dist(v * amp, 2.0)*1.2);\n}\n\n\/\/ heavy 909-ish bassdrum\nfloat kick(float tb, float time)\n{\n\ttb = fract(tb \/ 4.0) * 0.5;\n\tfloat aa = 5.0;\n\ttb = sqrt(tb * aa) \/ aa;\n\t\n\tfloat amp = exp(max(tb - 0.15, 0.0) * -10.0);\n\tfloat v = sin(tb * 100.0 * pi2) * amp;\n\tv = dist(v, 4.0) * amp;\n\tv += nse(quan(tb, 0.001)) * nse(quan(tb, 0.00001)) * exp(tb * -20.0) * 2.5;\n\treturn v;\n}\n\n\/\/ bad 909-ish open hihat\nfloat hat(float tb)\n{\n\ttb = fract(tb \/ 4.0) * 0.5;\n\tfloat aa = 4.0;\n\ttb = sqrt(tb * aa) \/ aa;\n\treturn nse(sin(tb * 4000.0) * 0.0001) * smoothstep(0.0, 0.01, tb - 0.25) * exp(tb * -5.0);\n}\n\n\n\n\/\/ oldschool explosion sound fx\nfloat expl(float tb)\n{\n\t\/\/tb = fract(tb \/ 4.0) * 0.5;\n\tfloat aa = 20.0;\n\ttb = sqrt(tb * aa) \/ aa;\n\t\n\tfloat amp = exp(max(tb - 0.15, 0.0) * -10.0);\n\tfloat v = nse(quan(mod(tb, 0.1), 0.0001));\n\tv = dist(v, 4.0) * amp;\n\treturn v;\n}\n\nvec2 synth1_echo(float tb, float time)\n{\n    vec2 v;\n    v = synth(tb, time) * 0.5;\/\/ + synth2(time) * 0.5;\n\tfloat ec = 0.6, fb = 0.6, et = 2.0 \/ 9.0, tm = 2.0 \/ 9.0;\n\tv += synth(tb, time - et) * ec * vec2(1.0, 0.5); ec *= fb; et += tm;\n\tv += synth(tb, time - et).yx * ec * vec2(0.5, 1.0); ec *= fb; et += tm;\n\tv += synth(tb, time - et) * ec * vec2(1.0, 0.5); ec *= fb; et += tm;\n\tv += dist(synth(tb, time - et).yx * ec * vec2(0.5, 1.0), 1.5); ec *= fb; et += tm;\n\t\n    return v;\n}\n\nvec2 mainSound(float time)\n{\n\tvec2 mx = vec2(0.0);\n\t\n\tfloat tb = mod(time * 9.0, 16.0);\n\t\n\t\n\tmx = synth1_echo(tb, time) * 0.8;\n\n    \n    mx += expl(mod(time * 9.0, 64.0) \/ 4.5) * 0.4;\n    \n\tmx += vec2(hat(tb)) + quan(hat(tb), .01)*.4;\n\t\n\t\/\/mx += dist(fract(tb \/ 16.0) * sin(ntof(77.0 - 36.0) * pi2 * time), 8.0) * 0.2;\n\t\/\/mx += expl(tb) * 0.5;\n\t\n\tfloat k = kick(tb, time) * 0.6;\/\/ - kick(tb, time - 0.004) * 0.5 - kick(tb, time - 0.008) * 0.25);\n\t\n\tmx += vec2(k);\n\t\n\t\n\t\n\tmx = dist(mx, 1.2);\n\t\n\treturn mx;\n}","name":"","description":"","type":"sound"}]}}