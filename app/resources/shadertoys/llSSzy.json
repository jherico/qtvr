{"Shader":{"ver":"0.1","info":{"id":"llSSzy","date":"1444585473","viewed":614,"name":"Vorotiles","username":"GrosPoulet","description":"Yet another Voronoi shader...","likes":11,"published":3,"flags":0,"tags":["voronoi","tiles"],"hasliked":0},"renderpass":[{"inputs":[{"id":28,"src":"\/presets\/tex15.png","ctype":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Inspired by: https:\/\/www.shadertoy.com\/view\/4lsXR7, https:\/\/www.shadertoy.com\/view\/MdSGRc, https:\/\/www.shadertoy.com\/view\/4dl3D4\n\n\/\/ Increase this value to generate smaller tiles\n#define DENSITY 100.0\n\/\/ Width of margin around picture\n#define MARGIN 0.0\n\/\/ Animation time in seconds\n#define ANIMATE_DURATION 5.0\n\n#define pi 3.1415926535897932384626433832795\n#define hfpi 1.5707963267948966192313216916398\n#define PI pi\n#define HFPI hfpi\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ methods\nfloat AnimateDensity()\n{\n    float i = floor(iGlobalTime \/ ANIMATE_DURATION);\n    float r = (iGlobalTime - ANIMATE_DURATION * i) \/ ANIMATE_DURATION;\n    float sinr = pow(sin(HFPI * r), 2.0);\n    float k = ( mod(i, 2.0) == 0.0 ? sinr : 1.0 - sinr );\n \treturn max(k*DENSITY, 5.0);\n}\n\nvec2 hash( vec2 p )\n{\n    p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn fract(sin(p)*43758.5453);\n}\n\n\/\/ From: https:\/\/www.shadertoy.com\/view\/ldl3W8#\nvec3 voronoi( vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    \/\/----------------------------------\n    \/\/ first pass: regular voronoi\n    \/\/----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n\t\tfor( int i=-1; i<=1; i++ )\n\t\t{\n\t\t\tvec2 g = vec2(float(i),float(j));\n\t\t\tvec2 o = hash( n + g );\n\t\t\to = 0.5 + 0.5*sin( iGlobalTime + 6.2831*o );\n\t\t\tvec2 r = g + o - f;\n\t\t\t\n\t\t\t\/\/Euclidian distance\n\t\t\tfloat d = dot(r,r);\n\n\t\t\tif( d<md )\n\t\t\t{\n\t\t\t\tmd = d;\n\t\t\t\tmr = r;\n\t\t\t\tmg = g;\n\t\t\t}\n\t\t}\n\n    \/\/----------------------------------\n    \/\/ second pass: distance to borders\n    \/\/----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n\t\tfor( int i=-2; i<=2; i++ )\n\t\t{\n\t\t\tvec2 g = mg + vec2(float(i),float(j));\n\t\t\tvec2 o = hash( n + g );\n\t\t\to = 0.5 + 0.5*sin( iGlobalTime + 6.2831*o );\n\t\t\tvec2 r = g + o - f;\n\n\t\t\tif( length(mr-r) >= 0.0001 )\n\t\t\t{\n\t\t\t\t\/\/ distance to line\t\t\n\t\t\t\tfloat d = dot( 0.5*(mr+r), normalize(r-mr) );\n\n\t\t\t\tmd = min( md, d );\n\t\t\t}\n\t\t}\n\n    return vec3( md, mr );\n}\n\nvec3 VoronoiColor(float density, vec2 uv, out float distance2border, out vec2 featurePt, out bool noTiles)\n{\n\tfloat XYRatio = iResolution.x \/ iResolution.y;\n\tvec2 p = uv;\n\tp.x *= XYRatio;\n\t\n    vec3 v = voronoi( density*p );\n    distance2border = v.x;\n    featurePt = v.yz;\n\tfeaturePt.x \/= (density * XYRatio);\n\tfeaturePt.y \/= density;\n    \n    \/\/tile color = color at feature-point location\n    vec2 uvCenter = uv;\n    uvCenter.x += featurePt.x;\n    uvCenter.y += featurePt.y;\n  \t\n\tvec3 color = vec3(0.0);\n\n\t\/\/compute margin where no tiles are allowed\n\tif (abs(uvCenter.x)*XYRatio < MARGIN\/density || abs(uvCenter.y) < MARGIN\/density || abs(1.0 - uvCenter.x)*XYRatio < MARGIN\/density || abs(1.0 - uvCenter.y) < MARGIN\/density)\n\t{\n\t\tcolor = texture2D(iChannel0, uv).rgb;\n\t\tnoTiles = true;\n\t}\n    else\n\t{\n\t\tcolor = texture2D(iChannel0, uvCenter).rgb;\n\t\tnoTiles = false;\n\t}\n        \n    return color;\n}\n\nvec3 Vorotiles(vec2 posSample)\n{\n    vec2 uv = posSample.xy;\n\t\n\tvec2 p = posSample.xy;\n\tp.x *= iResolution.x \/ iResolution.y;\n    \n    vec3 color = vec3(0.0,0.0,0.0);\n    float distance2border = 0.0;\n\tvec2 featurePt = vec2(0.0,0.0);\n    float density = AnimateDensity();\n\tbool noTiles = false;\n    color = VoronoiColor(density, uv, distance2border, featurePt, noTiles);\n    color += vec3(0.1);\n\n    \/\/ Make tiles'borders cleaner\n    if (noTiles == false)\n\t\tcolor = mix( vec3(0.0,0.0,0.0), color, smoothstep( 0.0, 0.1, distance2border ) );\n        \n    \/\/ Set the final fragment color.\n\treturn color;\n}\n\n\n\/\/ Sample a procedural texture (anti-aliasing)\n\/\/ Stolen from IQ: https:\/\/www.shadertoy.com\/view\/MdjGR1\nvec3 VorotilesAA( vec2 uv )\n{\n\t#define SAMPLING_STRENGTH 10000000000.0\n\t#define NB_SAMPLES 3 \/\/0: no anti-aliasing\n\t\n\tif (NB_SAMPLES == 0)\n\t{\n\t\treturn Vorotiles( uv );\n\t}\n\telse\n\t{\n\t\t\/\/ calc texture sampling footprint\t\t\n\t\tvec2 ddx = dFdx( uv ); \n\t\tvec2 ddy = dFdy( uv ); \n\t\n\t\tint sx = 1 + int( clamp( SAMPLING_STRENGTH*length(ddx), 0.0, float(NB_SAMPLES-1) ) );\n\t\tint sy = 1 + int( clamp( SAMPLING_STRENGTH*length(ddy), 0.0, float(NB_SAMPLES-1) ) );\n\n\t\tvec3 no = vec3(0.0);\n\n\t\tfor( int j=0; j<NB_SAMPLES; j++ )\n\t\tfor( int i=0; i<NB_SAMPLES; i++ )\n\t\t{\n\t\t\tif( j<sy && i<sx )\n\t\t\t{\n\t\t\t\tvec2 st = vec2( float(i), float(j) ) \/ vec2( float(sx),float(sy) );\n\t\t\t\tno += Vorotiles( uv + st.x*ddx + st.y*ddy );\n\t\t\t}\n\t\t}\n\n\t\treturn no \/ float(sx*sy);\n\t}\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;   \n    \n    \/\/pan\n  \tuv -= iMouse.xy \/ iResolution.xy;\n\t\t\n\tvec3 col = VorotilesAA( uv );\n\t\n    \/\/ Set the final fragment color.\n\tfragColor = vec4(col,1.0);\n}","name":"","description":"","type":"image"}]}}