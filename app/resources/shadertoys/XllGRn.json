{"Shader":{"ver":"0.1","info":{"id":"XllGRn","date":"1418289768","viewed":307,"name":"Visible clock","username":"dr2","description":"The mechanics of timekeeping; when the clock is open time speeds up to show all the gears rotating (there is an optional second hand - see the source).<br\/>","likes":4,"published":3,"flags":0,"tags":["raymarching","gears","time"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ \"Visible Clock\" by dr2 - 2014\n\/\/ License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n\/\/#define SHOW_SEC   \/\/ uncomment to show second hand (may crash some browsers)\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, cHashA3.xy)) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float s = 0.;\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return s;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nint idObj;\nvec3 qHit, ltDir;\nfloat tCur, todCur, tCyc, tSeq, aVelFac, axDist, wlGap, fadeCase, openMech;\nbool visCase;\nconst float ntM1 = 36., ntM2 = 12., ntM3 = 48., ntM4 = 12.;\n#ifdef SHOW_SEC\nconst float ntS1 = 32., ntS2 = 16., ntS3 = 36., ntS4 = 12.,\n   ntS5 = 60., ntS6 = 12., ntS7 = 32., ntS8 = 16.;\n#endif\nconst float rtFacB = (7.\/32.), ttWid = 0.35;\nconst int idBody = 10, idGearS = 11, idGearB = 12, idHandH = 13,\n   idHandM = 14, idHandS = 15, idAxH = 16, idAxM = 17, idAxS = 18,\n   idAxF = 19, idAxB = 20, idCase = 21, idDial = 22, idRing = 23, idFoot = 24;\nconst float dstFar = 100.;\nconst float pi = 3.14159;\n\nfloat GearDf (vec3 p, float rtFac, float nth, float aRot, float tWid, float wlThk,\n   float dHit, int idGear)\n{\n  float nsp = 8.;\n  float rad = rtFac * nth;\n  float d, a;\n  vec3 q = p;\n  vec2 s = vec2 (abs (length (q.xz) - (rad - 1.5 * tWid)) - 2. * tWid,\n     abs (q.y) - wlThk);\n  d = min (max (s.x, s.y), 0.) + length (max (s, 0.));\n  d = min (d, max (length (q.xz) - 5. * wlThk, abs (q.y) - wlThk));\n  q.zx = Rot2D (q.zx, aRot);\n  vec3 qq = q;\n  float g = atan (q.z, - q.x);\n  a = 2. * pi \/ nth;\n  q.xz = Rot2D (q.xz, a * floor (g \/ a + 0.5));\n  d = max (d, - (rad - 1.5 * tWid - tWid + clamp (2. * abs (q.z) - abs (q.x) - tWid,\n     q.x, q.x + 2. * tWid)));\n  q = qq;\n  a = 2. * pi \/ nsp;\n  q.xz = Rot2D (q.xz, a * floor (g \/ a + 0.5));\n  q.x += 0.5 * rad - 0.5 * tWid;\n  d = min (d, PrBoxDf (q, vec3 (0.5 * rad - 2. * tWid, wlThk, 0.03 * rad)));\n  if (d < dHit) { dHit = d;  idObj = idGear;  qHit = q; }\n  return dHit;\n}\n\nfloat GearTrainDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d, angRot, rtFac;\n  float wlThk = 0.15;\n  angRot = - todCur * aVelFac;\n  rtFac = rtFacB;\n  p.y -= 4. * wlGap;\n  q = p;  q.x -= axDist;\n  dHit = GearDf (q, rtFac, ntM1, angRot, ttWid, wlThk, dHit, idGearB);\n  angRot *= - ntM1 \/ ntM2;\n  q = p;  q.x += axDist;\n  dHit = GearDf (q, rtFac, ntM2, angRot + pi \/ ntM2, ttWid, wlThk, dHit, idGearS);\n  wlThk *= 0.9;\n  rtFac = (4.\/5.) * rtFacB;\n  p.y += 2. * wlGap;\n  q = p;  q.x += axDist;\n  dHit = GearDf (q, rtFac, ntM3, angRot, ttWid, wlThk, dHit, idGearB);\n  angRot *= - ntM3 \/ ntM4;\n  q = p;  q.x -= axDist;\n  dHit = GearDf (q, rtFac, ntM4, angRot + pi \/ ntM4, ttWid, wlThk, dHit, idGearS);\n#ifdef SHOW_SEC\n  wlThk *= 0.9;\n  rtFac = rtFacB;\n  p.y += 2. * wlGap;\n  q = p;  q.x -= axDist;\n  dHit = GearDf (q, rtFac, ntS1, angRot, ttWid, wlThk, dHit, idGearB);\n  angRot *= - ntS1 \/ ntS2;\n  q = p;  q.x += axDist;\n  dHit = GearDf (q, rtFac, ntS2, angRot + pi \/ ntS2, ttWid, wlThk, dHit, idGearS);\n  rtFac = rtFacB;\n  p.y += 2. * wlGap;\n  q = p;  q.x += axDist;\n  dHit = GearDf (q, rtFac, ntS3, angRot, ttWid, wlThk, dHit, idGearB);\n  angRot *= - ntS3 \/ ntS4;\n  q = p;  q.x -= axDist;\n  dHit = GearDf (q, rtFac, ntS4, angRot + pi \/ ntS4, ttWid, wlThk, dHit, idGearS);\n  wlThk *= 0.9;\n  rtFac = (2.\/3.) * rtFacB;\n  p.y += 2. * wlGap;\n  q = p;  q.x -= axDist;\n  dHit = GearDf (q, rtFac, ntS5, angRot, ttWid, wlThk, dHit, idGearB);\n  q = p;  q.x += axDist;\n  angRot *= - ntS5 \/ ntS6;\n  dHit = GearDf (q, rtFac, ntS6, angRot + pi \/ ntS6, 0.65 * ttWid, wlThk, dHit, idGearS);\n  wlThk *= 0.9;\n  rtFac = rtFacB;\n  p.y += 2. * wlGap;\n  q = p;  q.x += axDist;\n  dHit = GearDf (q, rtFac, ntS7, angRot, ttWid, wlThk, dHit, idGearB);\n  angRot *= - ntS7 \/ ntS8;\n  q = p;  q.x -= axDist;\n  dHit = GearDf (q, rtFac, ntS8, angRot + pi \/ ntS8, ttWid, wlThk, dHit, idGearS);\n#endif\n  return 0.5 * dHit;\n}\n\nfloat AxleDf (vec3 p, float rad, float len, float dHit, int idAx)\n{\n  vec3 q = p.xzy;\n  float d;\n  d = PrCylDf (q, rad, len);\n  if (d < dHit) { dHit = d;  idObj = idAx;  qHit = q; }  \n  return dHit;\n}\n\nfloat FrameDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d;\n  float axRad = 0.3;\n  p.y -= 4. * wlGap;\n  q = p;  q.xy -= vec2 (axDist, 0.5 * wlGap);\n  dHit = AxleDf (q, 1.5 * axRad, 1.4 * wlGap, dHit, idAxH);\n  p.y += wlGap;\n  q = p;  q.x += axDist;\n  dHit = AxleDf (q, axRad, 1.8 * wlGap, dHit, idAxB);\n  p.y += wlGap;\n  q = p;  q.x += axDist;\n  dHit = AxleDf (q, axRad, 0.6 * wlGap, dHit, idAxB);\n  p.y += 2. * wlGap;\n  q = p;  q.xy -= vec2 (axDist, 3. * wlGap);\n  dHit = AxleDf (q, axRad, 4. * wlGap, dHit, idAxM);\n#ifdef SHOW_SEC\n  p.y += wlGap;\n  q = p;  q.x += axDist;\n  dHit = AxleDf (q, axRad, 1.8 * wlGap, dHit, idAxB);\n  p.y += wlGap;\n  q = p;  q.x -= axDist;\n  dHit = AxleDf (q, axRad, 0.8 * wlGap, dHit, idAxB);\n  p.y += wlGap;\n  q = p;  q.x -= axDist;\n  dHit = AxleDf (q, axRad, 1.8 * wlGap, dHit, idAxB);\n  p.y += wlGap;\n  q = p;  q.x -= axDist;\n  dHit = AxleDf (q, axRad, 0.8 * wlGap, dHit, idAxB);\n  p.y += wlGap;\n  q = p;  q.x += axDist;\n  dHit = AxleDf (q, axRad, 1.8 * wlGap, dHit, idAxB);\n#else\n  p.y += 5. * wlGap;\n#endif\n  p.y += wlGap;\n  q = p;  q.xy -= vec2 (axDist, 6.4 * wlGap);\n  dHit = AxleDf (q, 0.5 * axRad, 7.2 * wlGap, dHit, idAxS);\n  q = p;  q.xy -= vec2 (- axDist, 5. * wlGap);\n  dHit = AxleDf (q, 0.5 * axRad, 6.1 * wlGap, dHit, idAxF);\n  p.y -= 5. * wlGap;\n  q = p;  q.y = abs (q.y) - 5.5 * wlGap;\n  d = PrBoxDf (q, vec3 (axDist - 1.8 * axRad, 0.3 * axRad, 0.7 * axRad));\n  q.x = abs (q.x) - axDist;\n  d = min (d, PrCylDf (q.xzy, 2. * axRad, 0.3 * axRad));\n  if (d < dHit) { dHit = d;  idObj = idAxB;  qHit = q; }\n  return dHit;\n}\n\nfloat HandsDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d, angRot, angRotS, angRotM, angRotH;\n  p.x -= axDist;\n  angRot = todCur * aVelFac;\n  angRotH = angRot - 0.5 * pi;\n  q = p;\n  q.xz = q.xz * cos (angRotH) * vec2 (1., 1.) + q.zx * sin (angRotH) * vec2 (-1., 1.);\n  q.xy -= vec2 (-2., 5.7 * wlGap);\n  d = PrCylDf (q.zyx, 0.5 * ttWid, 2.);\n  if (d < dHit) { dHit = d;  idObj = idHandH;  qHit = q; }\n  angRot *= (ntM1 \/ ntM2) * (ntM3 \/ ntM4);\n  angRotM = angRot - 0.5 * pi;\n  q = p;\n  q.xz = q.xz * cos (angRotM) * vec2 (1., 1.) + q.zx * sin (angRotM) * vec2 (-1., 1.);\n  q.xy -= vec2 (-2.5, 6.5 * wlGap);\n  d = PrCylDf (q.zyx, 0.5 * ttWid, 2.5);\n  if (d < dHit) { dHit = d;  idObj = idHandM;  qHit = q; }\n#ifdef SHOW_SEC\n  angRot *= (ntS1 \/ ntS2) * (ntS3 \/ ntS4) * (ntS5 \/ ntS6) * (ntS7 \/ ntS8);\n  angRotS = angRot - 0.5 * pi;\n  q = p;\n  q.xz = q.xz * cos (angRotS) * vec2 (1., 1.) + q.zx * sin (angRotS) * vec2 (-1., 1.);\n  q.xy -= vec2 (-2.7, 7.3 * wlGap);\n  d = PrCylDf (q.zyx, 0.3 * ttWid, 3.2);\n  if (d < dHit) { dHit = d;  idObj = idHandS;  qHit = q; }\n#endif\n  return dHit;\n}\n\nfloat CaseDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d;\n  p.y -= -0.8;\n  q = p;\n  d = PrBoxDf (q, vec3 (13.5, 4.4, 8.5));\n  if (d < dHit) { dHit = d;  idObj = idCase;  qHit = q; }\n  q.xy -= vec2 (axDist, 4.3);\n  d = max (PrCylDf (q.xzy, 7.4, 0.4), - PrCylDf (q.xzy, 7., 0.41));\n  if (d < dHit) { dHit = d;  idObj = idRing;  qHit = q; }\n  d = PrCylDf (q.xzy, 7., 0.1);\n  if (d < dHit) { dHit = d;  idObj = idDial;  qHit = q; }\n  q = p;  q.xy = abs (q.xy) - vec2 (10., 2.4);  q.z -= 8.7;\n  d = PrCylDf (q, 1., 0.5);\n  if (d < dHit) { dHit = d;  idObj = idFoot;  qHit = q; }\n  return dHit;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dHit = dstFar;\n  if (visCase) dHit = CaseDf (p, dHit);\n  else dHit = GearTrainDf (p, dHit);\n  dHit = FrameDf (p, dHit);\n  dHit = HandsDf (p, dHit);\n  return dHit;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  const float dTol = 0.001;\n  float d;\n  float dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < dTol || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao = 0.;\n  for (int i = 0; i < 8; i ++) {\n    float d = 0.1 + float (i) \/ 8.;\n    ao += max (0., d - 3. * ObjDf (ro + rd * d));\n  }\n  return clamp (1. - 0.1 * ao, 0., 1.);\n}\n\nvec3 WoodCol (vec3 p, vec3 n)\n{\n  p *= 5.;\n  float f = dot (vec3 (Fbm2 (p.yz * vec2 (1., 0.1)),\n     Fbm2 (p.zx * vec2 (1., 0.1)), Fbm2 (p.yx * vec2 (1., 0.1))), abs (n));\n  return mix (vec3 (0.4, 0.2, 0.1), vec3 (0.3, 0.1, 0.), f);\n}\n\nvec4 ObjCol (vec3 n)\n{\n  vec4 col4;\n  if (idObj == idCase) {\n    if (n.y < 0.99 || length (qHit.xz - vec2 (-8., -3.)) > 3.)\n       col4 = vec4 (WoodCol (qHit, n), 1.);\n    else col4 = vec4 (0.1, 0.07, 0., 0.1) *\n       (0.5 + 0.5 * Noisefv2 (50. * qHit.xz));\n  } else if (idObj == idDial) {\n    col4 = vec4 (0.7, 1., 1., 1.);\n    float a = 6. * (atan (qHit.z, - qHit.x) \/ pi + 1.);\n    if (abs (mod (a + 0.5, 1.) - 0.5) < 0.05 &&\n       abs (length (qHit.xz) - 5.9) < 0.9) col4 *= 0.1;\n  } else if (idObj == idRing) col4 = vec4 (0.2, 0.7, 1., 1.);\n  else if (idObj == idGearB) col4 = vec4 (1., 1., 0.5, 1.);\n  else if (idObj == idGearS) col4 = vec4 (0.8, 0.8, 0.2, 1.);\n  else if (idObj == idAxB) col4 = vec4 (0.6, 0.6, 0.3, 1.);\n  else if (idObj == idAxF) col4 = vec4 (0.4, 0.4, 0.3, 1.);\n  else if (idObj == idHandH || idObj == idAxH) col4 = vec4 (1., 0.3, 0.2, 1.);\n  else if (idObj == idHandM || idObj == idAxM) col4 = vec4 (0.3, 0.2, 1., 1.);\n#ifdef SHOW_SEC\n  else if (idObj == idHandS || idObj == idAxS) col4 = vec4 (0.3, 1., 0.2, 1.);\n#endif\n  else if (idObj == idFoot) col4 = vec4 (0.3, 0.2, 0.1, 0.1);\n  else col4 = vec4 (0.);\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 objCol;\n  vec3 vn, roo;\n  int idObjT;\n  float dstHit, dif, ao;\n  vec3 colC = vec3 (0., 0., 0.04), colNC = vec3 (0., 0., 0.04);\n  roo = ro;\n  visCase = true;\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  idObjT = idObj;\n  if (idObj < 0) dstHit = dstFar;\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    objCol = ObjCol (vn);\n    dif = max (dot (vn, ltDir), 0.);\n    ao = ObjAO (ro, vn);\n    colC = objCol.xyz * (0.2 * ao * (1. +\n       max (dot (vn, - normalize (vec3 (ltDir.x, 0., ltDir.z))), 0.)) +\n       max (0., dif) * (dif + ao * objCol.w *\n       pow (max (0., dot (ltDir, reflect (rd, vn))), 64.)));\n  }\n  ro = roo;\n  visCase = false;\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  idObjT = idObj;\n  if (idObj < 0) dstHit = dstFar;\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    objCol = ObjCol (vn);\n    dif = max (dot (vn, ltDir), 0.);\n    ao = ObjAO (ro, vn);\n    colNC = objCol.xyz * (0.2 * ao * (1. +\n       max (dot (vn, - normalize (vec3 (ltDir.x, 0., ltDir.z))), 0.)) +\n       max (0., dif) * (dif + ao * objCol.w *\n       pow (max (0., dot (ltDir, reflect (rd, vn))), 64.)));\n  }\n  return sqrt (clamp (mix (colC, colNC, fadeCase), 0., 1.));\n}\n\nvoid SetConfig ()\n{\n  tCyc = 30.;\n  tSeq = mod (tCur, tCyc);\n  fadeCase = SmoothBump (5., 25., 2., tSeq);\n  openMech = SmoothBump (10., 20., 1., tSeq);\n#ifdef SHOW_SEC\n  aVelFac = (2. * pi \/ (12. * 3600.)) * (1. + 99. * step (0.2, openMech));\n#else\n  aVelFac = (2. * pi \/ (12. * 3600.)) * (1. + 1999. * step (0.2, openMech));\n#endif\n  wlGap = 0.7 * (1. + 1.3 * openMech);\n  axDist = 4.83;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy \/ iResolution.xy - 1.;\n  uv.x *= iResolution.x \/ iResolution.y;\n  tCur = iGlobalTime;\n  todCur = iDate.w;\n  float dist = 60.;\n  float zmFac = 5.;\n  float az = pi;\n  float el = 0.5 * pi;\n  SetConfig ();\n  float dir = (1. - 2. * floor (mod (tCur \/ (3. * tCyc), 2.)));\n  az += dir * 2. * pi * tSeq \/ tCyc;\n  el -= 0.04 * pi * openMech;\n  vec2 ca = cos (vec2 (el, az));\n  vec2 sa = sin (vec2 (el, az));\n  mat3 vuMat = mat3 (1., 0., 0., 0., 1., 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n     mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n  vec3 rd = vuMat * normalize (vec3 (uv, zmFac));\n  vec3 ro = - vuMat * vec3 (0., 0., dist);\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  vec3 col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n","name":"","description":"","type":"image"}]}}