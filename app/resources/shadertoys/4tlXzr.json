{"Shader":{"ver":"0.1","info":{"id":"4tlXzr","date":"1436219155","viewed":424,"name":"Moon Surface II","username":"4rknova","description":"Navigating on the surface of the moon.<br\/>Remake of <a href=\"https:\/\/www.shadertoy.com\/view\/4slGRf\"  class=\"regular\" target=\"_blank\">\"Moon Surface\"<\/a>","likes":9,"published":3,"flags":0,"tags":["raymarching","terrain","moon"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ by Nikos Papadopoulos, 4rknova \/ 2015\n\/\/ Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n#define EPS\t\t.001\n#define PI\t\t3.14159265359\n#define RADIAN\t180. \/ PI\n#define SPEED\t25.\n\nfloat hash(vec2 p)\n{\n    return fract(sin(dot(p,vec2(127.1,311.7))) * 43758.5453123);\n}\n\nfloat noise(vec2 p)\n{\n    vec2 i = floor(p), f = fract(p); \n\tf *= f*(3.-2.*f);\n    \n    vec2 c = vec2(0,1);\n    \n    return mix(mix(hash(i + c.xx), \n                   hash(i + c.yx), f.x),\n               mix(hash(i + c.xy), \n                   hash(i + c.yy), f.x), f.y);\n}\n\nfloat fbm(in vec2 p)\n{\n\treturn\t.5000 * noise(p)\n\t\t   +.2500 * noise(p * 2.)\n\t\t   +.1250 * noise(p * 4.)\n\t\t   +.0625 * noise(p * 8.);\n}\n\nfloat dst(vec3 p)\n{\n\treturn dot(vec3(p.x, p.y\n                    + 0.45 * fbm(p.zx) \n                    + 2.55 * noise(.1 * p.xz) \n                    + 0.83 * noise(.4 * p.xz)\n                    + 3.33 * noise(.001 * p.xz)\n                    + 3.59 * noise(.0005 * (p.xz + 132.453)) \n                    , p.z),  vec3(0.,1.,0.));\t\n}\n\nvec3 nrm(vec3 p, float d)\n{\n\treturn normalize(\n\t\t\tvec3(dst(vec3(p.x + EPS, p.y, p.z)),\n    \t\t\t dst(vec3(p.x, p.y + EPS, p.z)),\n    \t\t\t dst(vec3(p.x, p.y, p.z + EPS))) - d);\n}\n\nbool rmarch(vec3 ro, vec3 rd, out vec3 p, out vec3 n)\n{\n\tp = ro;\n\tvec3 pos = p;\n\tfloat d = 1.;\n\n\tfor (int i = 0; i < 64; i++) {\n\t\td = dst(pos);\n\n\t\tif (d < EPS) {\n\t\t\tp = pos;\n\t\t\tbreak;\n\t\t}\n\t\tpos += d * rd;\n\t}\n\t\n\tn = nrm(p, d);\n\treturn d < EPS;\n}\n\nvec4 render(vec2 uv)\n{\n    float t = iGlobalTime;\n    \n    vec2 uvn = (uv) * vec2(iResolution.x \/ iResolution.y, 1.);\n\t\n    float vel = SPEED * t;\n    \n\tvec3 cu = vec3(2. * noise(vec2(.3 * t)) - 1.,1., 1. * fbm(vec2(.8 * t)));\n\tvec3 cp = vec3(0, 3.1 + noise(vec2(t)) * 3.1, vel);\n\tvec3 ct = vec3(1.5 * sin(t), \n\t\t\t\t   -2. + cos(t) + fbm(cp.xz) * .4, 13. + vel);\n\t\t\n\tvec3 ro = cp,\n\t\t rd = normalize(vec3(uvn, 1. \/ tan(60. * RADIAN)));\n\t\n\tvec3 cd = ct - cp,\n\t\t rz = normalize(cd),\n\t\t rx = normalize(cross(rz, cu)),\n\t\t ry = normalize(cross(rx, rz));\n\n\trd = normalize(mat3(rx, ry, rz) * rd);\n    \n\n\tvec3 sp, sn;\n\tvec3 col = (rmarch(ro, rd, sp, sn) ?\n\t\t  vec3(.6) * dot(sn, normalize(vec3(cp.x, cp.y + .5, cp.z) - sp))\n\t\t: vec3(0.));\n\t\n\treturn vec4(col, length(ro-sp));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy \/ iResolution.xy * 2. - 1.;\n        \n    if (abs(EPS + uv.y) >= .7 || mod(floor(fragCoord.y),2.) > 0.) { \n\t\tfragColor = vec4(0,0,0,1);\n        return;\n\t}\n\t\n    vec4 res = render(uv);\n    \n    vec3 col = res.xyz;\n    \n    col *= 1.75 * smoothstep(length(uv) * .35, .75, .4);\n    col += hash(hash(uv) * uv * iGlobalTime) * .15;\n\tcol *= smoothstep(EPS, 3.5, iGlobalTime);\n\n    fragColor = vec4(col, 1);\n}","name":"","description":"","type":"image"}]}}