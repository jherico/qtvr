{"Shader":{"ver":"0.1","info":{"id":"XtB3zz","date":"1426728505","viewed":787,"name":"Tectonics","username":"leon","description":"Evolving planet with rising and falling buildings.<br\/>","likes":3,"published":3,"flags":0,"tags":["planet","tectonics"],"hasliked":0},"renderpass":[{"inputs":[{"id":8,"src":"\/presets\/tex07.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":15,"src":"\/presets\/tex10.png","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ <3 Shadertoy\n\n#define PI 3.141592653589\n\n\/\/ Raymarching\nconst float rayEpsilon = 0.0001;\nconst float rayMin = 0.1;\nconst float rayMax = 100.0;\nconst int rayCount = 64;\n\n\/\/ Camera\nvec3 eye = vec3(0.01, 0.01, -1.125);\nvec3 front = vec3(0.01, 0.01, 0.4);\nvec3 right = vec3(1.0, 0.0, 0.0);\nvec3 up = vec3(0.0, 1.0, 0.0);\n\n\/\/ Animation\nvec2 uvScale = vec2(1);\nfloat terrainHeight = 0.09;\nfloat sphereRadius = 0.96;\nfloat translationSpeed = 0.1;\nfloat rotationSpeed = 0.25;\nfloat orbitSpeed = 0.2;\n\n\/\/ Heights\nfloat deepWater = .1;\nfloat water = .4;\nfloat ground = .5;\nfloat grass = .6;\nfloat moutain = .9;\nfloat buildingTreshold = 0.6;\nfloat buildingMargin = 0.04;\nfloat buildingHeight = 0.06;\nvec3 buildingSize = vec3(0.01, 0.01, 0.1);\n\n\/\/ Colors\nvec3 skyColor = vec3(0.05, 0, 0);\nvec3 shadowColor = vec3(0.1, 0, 0);\nvec3 waterColor = vec3(0.6, 0.7, .9);\nvec3 groundColor = vec3(.7, .7, .6);\nvec3 grassColor = vec3(.6, .65, .1);\nvec3 mountainColor = vec3(.8);\nvec3 cloudColor = vec3(.99);\nvec3 buildingColor = vec3(.7);\n\nvec3 rotateY(vec3 v, float t)\n{\n    float cost = cos(t); float sint = sin(t);\n    return vec3(v.x * cost + v.z * sint, v.y, -v.x * sint + v.z * cost);\n}\nvec3 rotateX(vec3 v, float t)\n{\n    float cost = cos(t); float sint = sin(t);\n    return vec3(v.x, v.y * cost - v.z * sint, v.y * sint + v.z * cost);\n}\n\nfloat box( vec3 p, vec3 b ) { return length(max(abs(p)-b,0.0)); }\n\nfloat sphere( vec3 p, float s ) { return length(p)-s; }\nvec3 repeat( vec3 p, float c ) { return mod(p, c)-.5*c; }\nfloat inter( float d1, float d2 ) { return max(d1, d2); }\nfloat sub( float d1, float d2 ) { return max(-d1, d2); }\nfloat add( float d1, float d2 ) { return min(d1, d2); }\n\nfloat posterize( float p, float details ) { return floor(p * details) \/ details; }\nfloat reflectance(vec3 a, vec3 b) { return dot(normalize(a), normalize(b)); }\nvec2 kaelidoGrid(vec2 p) { return vec2(step(mod(p, 2.0), vec2(1.0))); }\n\nfloat grid(vec2 uv, float thickness, float cellSize) { return min(1., step(mod(uv.x, cellSize), thickness) + step(mod(uv.y, cellSize), thickness)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \/\/ Ray from UV\n\tvec2 uv = fragCoord.xy * 2.0 \/ iResolution.xy - 1.0;\n    uv.x *= iResolution.x \/ iResolution.y;\n    vec3 ray = normalize(front + right * uv.x + up * uv.y);\n    \n    \/\/ Color    \n    vec3 color = skyColor;\n    \n    \/\/ Animation\n    float translationTime = iGlobalTime * translationSpeed;\n    float rotationTime = iGlobalTime * rotationSpeed;\n    float orbitTime = iGlobalTime * orbitSpeed;\n    \n    \/\/ Raymarching\n    float t = 0.0;\n    for (int r = 0; r < rayCount; ++r)\n    {\n        \/\/ Ray Position\n        vec3 p = eye + ray * t;\n        vec3 originP = p;\n        float d;\n        \n        \/\/ Transformations\n       \tp = rotateX(p, PI \/ 2.0);\n        \n        \/\/ Sphere UV\n        vec3 n = normalize(p);\n        float angleXZ = atan(n.z, n.x) \/ PI;\n        float angleXY = atan(n.y, n.x) \/ PI;\n       \tfloat refl = reflectance(p, eye) \/ PI;\n        \n        vec2 sphereP = vec2(angleXY, refl);\n        vec2 sP1 = sphereP * uvScale - rotationSpeed * vec2(cos(translationTime), sin(translationTime));\n        vec2 sP2 = sphereP * uvScale + rotationSpeed * vec2(cos(translationTime + .5), sin(translationTime + .5));\n\n        vec2 uv1 = mod(mix(sP1, 1.0 - sP1, kaelidoGrid(sP1)), 1.0);\n        vec2 uv2 = mod(mix(sP2, 1.0 - sP2, kaelidoGrid(sP2)), 1.0);\n        \n        \/\/ Texture\n        vec3 texture1 = texture2D(iChannel0, uv1).rgb;\n        vec3 texture2 = 1.0 - texture2D(iChannel0, uv2).rgb;\n        vec3 texture3 = texture2D(iChannel1, sphereP).rgb;\n        \n        \/\/ Height from luminance\n        float luminance1 = (texture1.r + texture1.g + texture1.b) \/ 3.0;\n        float luminance2 = (texture2.r + texture2.g + texture2.b) \/ 3.0;\n        float luminance3 = (texture3.r + texture3.g + texture3.b) \/ 3.0;\n        float l = (luminance1 + luminance2) \/ 2.0;\n        \n        \/\/ Displacement\n        p += normalize(p) * -terrainHeight * l;\n        float planet = sphere(p, sphereRadius);\n        \n        p = repeat(originP, buildingMargin);\n        float building = box(p, buildingSize);\n        float canBuild = smoothstep(ground, grass, l);\n        building = inter(building, sphere(originP, sphereRadius + canBuild * (buildingHeight + 0.02*posterize(luminance3, 16.0))));\n        \n        d = add(planet, building);\n        \n        \/\/ Distance min or max reached\n        if (d < rayEpsilon || t > rayMax)\n        {\n            \/\/ planet\n            color = mix(skyColor, waterColor, smoothstep(deepWater, water, l));\n            color = mix(color, groundColor, smoothstep(water, ground, l));\n            color = mix(color, grassColor, smoothstep(ground, grass, l));\n            color = mix(color, mountainColor, smoothstep(grass, moutain, l));\n            \n            \/\/ building\n            color = mix(color, buildingColor, step(building, d));\n        \t\t\n            \/\/ Shadow from ray count\n            color = mix(color, shadowColor, float(r) \/ float(rayCount));\n            \n            \/\/ Sky color from distance\n            color = mix(color, skyColor, smoothstep(rayMin, rayMax, t));\n                            \n            break;\n        }\n        \n        \/\/ Distance field step\n        t += d;\n    }\n    \n    \/\/ Hop\n\tfragColor = vec4(color, 1);\n}","name":"","description":"","type":"image"}]}}