{"Shader":{"ver":"0.1","info":{"id":"XsjSzc","date":"1414459923","viewed":1113,"name":"Oscilomushroom","username":"iq","description":"Made after this: . No actual implicit procedural modeling used!","likes":10,"published":3,"flags":0,"tags":["2d","osciloscope"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ This shader is doing the \"right thing\" --> generating two time signals and then lighting the electron\n\/\/ beam as it gets moved by then. No actual implicit procedural modeling used!\n\nfloat length2( in vec2 v ) { return dot(v,v); }\n\nfloat ssdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2  pa = p - a;\n\tvec2  ba = b - a;\n    float bam = dot(ba,ba);\n    if( bam>0.1 ) return 10.0;\n\tfloat h = clamp( dot(pa,ba)\/bam, 0.0, 1.0 );\n\t\n\treturn length2( pa - ba*h );\n}\n\nconst float freq = 100.0;\n\nfloat saw( float x ) { return -1.0 + 2.0*fract(x); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy) \/ iResolution.y;\n    p *= 1.25;\n    \n    float f = 1.5;\n    float ox = 0.0;\n    float oy = 0.0;\n    for( int i=0; i<1024; i++ )\n    {\n        float h = float(i)\/1024.0;\n    \n        float t = iGlobalTime + 10.0*h\/freq;\n    \n        \/\/----------------        \n        float x = 0.6*cos( 5.0*freq*6.2831*t ) * \n                      sin( 1.0*freq*6.2831*t\/12.0) *\n                 (0.1+0.9*step(fract(t*freq\/12.0),0.25)) - \n                  0.2*sin(t*6.2831*freq\/12.0 + t*2.0) * \n                 (1.0-fract(t*freq\/12.0));\n        float y = 0.1*sin( 5.0*freq*6.2831*t ) - \n                  1.0*saw( 1.0*freq*t\/12.0 );\n        \/\/----------------        \n        \n        \n        if( i>0 ) \n        {\n            float dis = ssdSegment( p, vec2(x,y), vec2(ox,oy) );\n            f += exp( -5000.0*dis )*1.00 + \n                 exp( - 100.0*dis )*0.04;\n        }\n        ox = x;\n        oy = y;\n    }    \n    \n    float h = clamp( f*0.05, 0.0, 1.0 );\n    vec3 col = vec3( h*h, h, h*h*h )*3.0;\n   \n    vec2 q = fragCoord.xy\/iResolution.xy;\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\n    float grid = 1.0;\n    grid *= 1.0-smoothstep( 0.98, 0.99, 2.0*abs(fract( q.x*10.0 )-0.5) );\n    grid *= 1.0-smoothstep( 0.96, 0.98, 2.0*abs(fract( q.y*6.0 )-0.5) );\n    grid *= 1.0-smoothstep( 0.90, 0.92, 2.0*abs(fract( q.x*50.0 )-0.5) )*\n                smoothstep( 0.84, 0.85, 2.0*abs(fract( q.y* 6.0 )-0.5) );\n    grid *= 1.0-smoothstep( 0.91, 0.92, 2.0*abs(fract( q.y*30.0 )-0.5) )*\n                smoothstep( 0.85, 0.86, 2.0*abs(fract( q.x*10.0 )-0.5) );\n    col *= 0.5 + 0.5*grid;\n  \n    col += 0.06*smoothstep(0.2,0.7,q.y);\n    \n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"},{"inputs":[],"outputs":[{"channel":"0"}],"code":"const float freq = 500.0;\n\nfloat saw( float x ) { return -1.0 + 2.0*fract(x); }\n\nvec2 mainSound(float time)\n{\n    float t = time;\n    \n    float x = 0.5*cos( 5.0*freq*6.2831*t ) * \n                  sin( 1.0*freq*6.2831*t\/12.0) *\n                 (0.1+0.9*step(fract(t*freq\/12.0),0.25)) - \n              0.2*sin(t*6.2831*freq\/12.0 + t*2.0) * \n                 (1.0-fract(t*freq\/12.0));\n    float y = 0.1*sin( 5.0*freq*6.2831*t ) - \n              1.0*saw( 1.0*freq*t\/12.0 );\n    \n    return 0.15*vec2( x, y );\n}","name":"","description":"","type":"sound"}]}}