{"Shader":{"ver":"0.1","info":{"id":"llfSRN","date":"1434820958","viewed":682,"name":"1D Linear Uniform B-Spline II","username":"demofox","description":"1D Linear B-Spline.  Use the mouse to control the yellow control point.<br\/>There are 8 control points P0-P7 and implicitly 10 knots: [0-9].  Only time 1.0 through 8.0 are valid due to how bsplines work.<br\/>Signed distance used for rendering curve.","likes":1,"published":3,"flags":0,"tags":["2d","bspline"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/*\n\nMore info on b-splines and other curves here:\nhttp:\/\/www.ibiblio.org\/e-notes\/Splines\/Intro.htm\n\n*\/\n\n#define P0  0.25\n#define P1  (sin(iGlobalTime*1.5) * 0.5)\n#define P2  0.21\n#define P3  -0.1\n#define P4  0.2\n#define P5  (iMouse.z <= 0.0 ? 0.25 : iMouse.y \/ iResolution.y - 0.5)\n#define P6  -0.25\n#define P7  0.0\n\n#define EDGE   0.005\n#define SMOOTH 0.0025\n\nfloat N_i_1 (in float t, in float i)\n{\n    \/\/ return 1 if i < t < i+1, else return 0\n    return step(i, t) * step(t,i+1.0);\n}\n\nfloat N_i_2 (in float t, in float i)\n{\n    return\n        N_i_1(t, i)       * (t - i) +\n        N_i_1(t, i + 1.0) * (i + 2.0 - t);\n}\n\nfloat SplineValue(in float t)\n{\n    return\n        P0 * N_i_2(t, 0.0) +\n        P1 * N_i_2(t, 1.0) +\n        P2 * N_i_2(t, 2.0) +\n        P3 * N_i_2(t, 3.0) +\n        P4 * N_i_2(t, 4.0) +\n        P5 * N_i_2(t, 5.0) +\n        P6 * N_i_2(t, 6.0) +\n        P7 * N_i_2(t, 7.0);       \n}\n\n\/\/ F(x,y) = F(x) - y\nfloat F ( in vec2 coords )\n{\n    \/\/ time in this curve goes from 0.0 to 9.0 but values\n    \/\/ are only valid between 1.0 and 8.0\n    float T = coords.x*7.0 + 1.0;    \n    return SplineValue(T) - coords.y;\n}\n\n\/\/ signed distance function for F(x,y)\nfloat SDF( in vec2 coords )\n{\n    float v = F(coords);\n    float slope = dFdx(v) \/ dFdx(coords.x);\n    return abs(v)\/length(vec2(slope, -1.0));\n}\n\n\/\/ signed distance function for Circle, for control points\nfloat SDFCircle( in vec2 coords, in vec2 offset )\n{\n    coords -= offset;\n    float v = coords.x * coords.x + coords.y * coords.y - EDGE*EDGE;\n    vec2  g = vec2(2.0 * coords.x, 2.0 * coords.y);\n    return v\/length(g); \n}\n\n\/\/-----------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    float aspectRatio = iResolution.x \/ iResolution.y;\n    vec2 percent = ((fragCoord.xy \/ iResolution.xy) - vec2(0.25,0.5));\n    percent.x *= aspectRatio;\n\n    vec3 color = vec3(1.0,1.0,1.0);\n    float dist = SDFCircle(percent, vec2(0.0 \/ 7.0,P0));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(0.0,0.0,1.0),vec3(1.0,1.0,1.0),dist);\n    }\n    \n    dist = SDFCircle(percent, vec2(1.0 \/ 7.0,P1));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(0.0,1.0,0.0),vec3(1.0,1.0,1.0),dist);\n    }    \n    \n    dist = SDFCircle(percent, vec2(2.0 \/ 7.0,P2));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(0.0,0.0,1.0),vec3(1.0,1.0,1.0),dist);\n    }    \n    \n    dist = SDFCircle(percent, vec2(3.0 \/ 7.0,P3));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(0.0,0.0,1.0),vec3(1.0,1.0,1.0),dist);\n    }     \n    \n    dist = SDFCircle(percent, vec2(4.0 \/ 7.0,P4));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(0.0,0.0,1.0),vec3(1.0,1.0,1.0),dist);\n    }   \n    \n    dist = SDFCircle(percent, vec2(5.0 \/ 7.0,P5));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(1.0,1.0,0.0),vec3(1.0,1.0,1.0),dist);\n    }      \n    \n    dist = SDFCircle(percent, vec2(6.0 \/ 7.0,P6));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(0.0,0.0,1.0),vec3(1.0,1.0,1.0),dist);\n    }        \n    \n    dist = SDFCircle(percent, vec2(7.0 \/ 7.0,P7));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(0.0,0.0,1.0),vec3(1.0,1.0,1.0),dist);\n    }       \n    \n    if (percent.x >= 0.0 && percent.x <= 1.0)\n    {\n    \tdist = SDF(percent);\n    \tif (dist < EDGE + SMOOTH)\n    \t{\n        \tdist = smoothstep(EDGE - SMOOTH,EDGE + SMOOTH,dist);\n        \tcolor *= vec3(dist);\n    \t}\n    }\n    \n\tfragColor = vec4(color,1.0);\n}\n","name":"","description":"","type":"image"}]}}