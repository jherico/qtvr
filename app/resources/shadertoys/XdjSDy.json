{"Shader":{"ver":"0.1","info":{"id":"XdjSDy","date":"1415594551","viewed":1345,"name":"Triangle - occlusion","username":"iq","description":"Analytical ambient occlusion of a triangle. Left side of screen, stochastically sampled occlusion. Right side of the screen, analytical solution (no rays casted). Move the mouse to compare.","likes":14,"published":3,"flags":0,"tags":["3d","triangle","occlusion","analytic"],"hasliked":0},"renderpass":[{"inputs":[{"id":2,"src":"\/presets\/tex01.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\/\/ Analytical ambient occlusion of a triangle. Left side of screen, stochastically \n\/\/ sampled occlusion. Right side of the screen, analytical solution (no rays casted).\n\/\/\n\/\/ If the polygons was intersecting the ground plane, we'd need to perform clipping\n\/\/ and use the resulting triangles for the analytic formula instead.\n    \n\n\/\/=====================================================\n\n\/\/ Triangle intersection. Returns { t, u, v }\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 a = v0 - v1;\n    vec3 b = v2 - v0;\n    vec3 p = v0 - ro;\n    vec3 n = cross( b, a );\n    vec3 q = cross( p, rd );\n\n    float idet = 1.0\/dot( rd, n );\n\n    float u = dot( q, b )*idet;\n    float v = dot( q, a )*idet;\n    float t = dot( n, p )*idet;\n\n    if( u<0.0 || u>1.0 || v<0.0 || (u+v)>1.0 ) return vec3( -1.0 );\n\n    return vec3( t, u, v );\n}\n\n\/\/ Triangle occlusion (if fully visible)\nfloat triOcclusion( in vec3 pos, in vec3 nor, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 a = normalize( v0 - pos );\n    vec3 b = normalize( v1 - pos );\n    vec3 c = normalize( v2 - pos );\n    \n    return (dot( nor, normalize( cross(a,b)) ) * acos( dot(a,b) ) +\n            dot( nor, normalize( cross(b,c)) ) * acos( dot(b,c) ) +\n            dot( nor, normalize( cross(c,a)) ) * acos( dot(c,a) ) ) \/ 6.2831;\n}\n\n\/\/=====================================================\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\nfloat iPlane( in vec3 ro, in vec3 rd )\n{\n    return (-1.0 - ro.y)\/rd.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy) \/ iResolution.y;\n    float s = (2.0*iMouse.x-iResolution.x) \/ iResolution.y;\n    if( iMouse.z<0.001 ) s=0.0;\n\n\tvec3 ro = vec3(0.0, 0.0, 4.0 );\n\tvec3 rd = normalize( vec3(p,-2.0) );\n\t\n    \/\/ triangle animation\n    vec3 v1 = cos( iGlobalTime + vec3(2.0,1.0,1.0) + 0.0 )*vec3(1.5,1.0,1.0);\n\tvec3 v2 = cos( iGlobalTime + vec3(5.0,2.0,3.0) + 2.0 )*vec3(1.5,1.0,1.0);\n\tvec3 v3 = cos( iGlobalTime + vec3(1.0,3.0,5.0) + 4.0 )*vec3(1.5,1.0,1.0);\n\n    vec4 rrr = texture2D( iChannel0, (fragCoord.xy)\/iChannelResolution[0].xy, -99.0  ).xzyw;\n\n\n    vec3 col = vec3(0.0);\n\n    float tmin = 1e10;\n    \n    float t1 = iPlane( ro, rd );\n    if( t1>0.0 )\n    {\n        tmin = t1;\n        vec3 pos = ro + tmin*rd;\n        vec3 nor = vec3(0.0,1.0,0.0);\n        float occ = 0.0;\n        \n        if( p.x > s )\n        {\n            occ = triOcclusion( pos, nor, v1, v2, v3 );\n        }\n        else\n        {\n   \t\t    vec3  ru  = normalize( cross( nor, vec3(0.0,1.0,1.0) ) );\n\t\t    vec3  rv  = normalize( cross( ru, nor ) );\n\n            occ = 0.0;\n            for( int i=0; i<256; i++ )\n            {\n                vec2  aa = hash2( rrr.x + float(i)*203.1 );\n                float ra = sqrt(aa.y);\n                float rx = ra*cos(6.2831*aa.x); \n                float ry = ra*sin(6.2831*aa.x);\n                float rz = sqrt( 1.0-aa.y );\n                vec3  dir = vec3( rx*ru + ry*rv + rz*nor );\n                vec3 res = triIntersect( pos+nor*0.001, dir, v1, v2, v3 );\n                occ += step(0.0,res.x);\n            }\n            occ \/= 256.0;\n        }\n\n        col = vec3(1.0);\n        col *= 1.0 - occ;\n    }\n\n    vec3 res = triIntersect( ro, rd, v1, v2, v3 );\n    float t2 = res.x;\n    if( t2>0.0 && t2<tmin )\n    {\n        tmin = t2;\n        float t = t2;\n        vec3 pos = ro + t*rd;\n        vec3 nor = normalize( cross( v2-v1, v3-v1 ) );\n\t\tcol = vec3(1.0,0.8,0.5);\n        col *= 1.5*texture2D( iChannel1, res.yz ).xyz;\n        col *= 0.6 + 0.4*nor.y;\n\t}\n\n\tcol *= exp( -0.05*tmin );\n\n    float e = 2.0\/iResolution.y;\n    col *= smoothstep( 0.0, 2.0*e, abs(p.x-s) );\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}