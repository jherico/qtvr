{"Shader":{"ver":"0.1","info":{"id":"XlBGzm","date":"1427513484","viewed":1054,"name":"Midnight Snow","username":"RavenWorks","description":"<strong>I hate winter, except when it does this.<\/strong> Music is based on George Winston's arrangement of Carol Of The Bells.<br\/>Got curious about raytracing a bounding box to skip raymarches; works pretty well, at the cost of crashing WebGL if too many objects\u2026","likes":8,"published":3,"flags":9,"tags":["raymarch","landscape","snow","winter","realism"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\n\nconst float PI =3.141592;\nconst float PI2=6.2831853;\n\n\n\n\nfloat smooth( float a, float b, float k ){\n    float h = clamp(0.5+0.5*(b-a)\/k,0.0,1.0);\n    return mix(b,a,h) - k*h*(1.0-h);\n}\n\nvoid hardAdd(inout int curMaterial, inout float curD, int newMaterial, float newD){\n    if (newD < curD) {\n        curD = newD;\n        curMaterial = newMaterial;\n    }\n}\nvoid hardSubtract(inout float curD, float newD) {\n    curD = max( -newD, curD );\n}\nvoid smoothAdd(inout float curD, float newD, float blendPower){\/\/blend colors too?\n    curD = smooth( newD, curD, blendPower );\n}\nvoid smoothSubtract(inout float curD, float newD, float blendPower){\n    curD = -smooth( newD , -curD , blendPower );\n}\n\n\nfloat obj_ball(vec3 p, vec3 center, float radius){\n    return length(p-center)-radius;\n}\nfloat obj_cylinder(vec3 p, vec3 center, vec2 size, float roundness){\n    vec3 tp = p-center;\n    vec2 d = abs(vec2(length(tp.yz),tp.x)) - size;\n    return min(max(d.x,d.y)+roundness,0.0) + length(max(d,0.0))-roundness;\n}\nfloat obj_planeY(vec3 p, float planeY){\n    return p.y-planeY;\n}\nfloat obj_roundline( vec3 p, vec3 a, vec3 b, float r ){\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nfloat obj_box(vec3 p, vec3 center, vec3 size, float roundness){\n    vec3 d = abs(p-center) - (size-roundness);\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - roundness;\n}\n\nfloat middleMod(float val,float modDist){\n    return mod(val+modDist*0.5,modDist)-modDist*0.5;\n}\n\n\n\nfloat det2d(vec2 vecA, vec2 vecB){\n    return vecA.x*vecB.y - vecA.y*vecB.x;\n}\n\n\n\nbool testAABB(vec3 rayPt, vec3 rayDir, vec3 boxMid, vec3 boxSizeHalf, out float dist){\n    \n    \/\/ thank you http:\/\/gamedev.stackexchange.com\/a\/18459\n    \n    vec3 lbGap = (boxMid-boxSizeHalf-rayPt)\/rayDir;\n    vec3 rtGap = (boxMid+boxSizeHalf-rayPt)\/rayDir;\n    \n    float tmin = max(max(min(lbGap.x,rtGap.x),min(lbGap.y,rtGap.y)),min(lbGap.z,rtGap.z));\n    float tmax = min(min(max(lbGap.x,rtGap.x),max(lbGap.y,rtGap.y)),max(lbGap.z,rtGap.z));\n    if (tmax < 0.0) return false;\n    if (tmin > tmax) return false;\n\t\n\tdist = tmin;\n\t\n    return true;\n    \n}\n\nvec2 rotVec(vec2 v, vec2 r){\n    return vec2(\n    \tv.x*r.x - v.y*r.y,\n        v.x*r.y + v.y*r.x\n    );\n}\n\n\nvoid moveToBranchSpace(inout vec3 rayPt, inout vec3 rayDir, vec3 rotOrigin, float pitch, float yaw) {\n    \n    rayPt -= rotOrigin;\n    \n    vec2 yawVec = vec2(cos(yaw),sin(yaw));\n    rayPt.xz = rotVec(rayPt.xz,yawVec);\n    rayDir.xz = rotVec(rayDir.xz,yawVec);\n    \n    vec2 pitchVec = vec2(cos(pitch),sin(pitch));\n    rayPt.xy = rotVec(rayPt.xy,pitchVec);\n    rayDir.xy = rotVec(rayDir.xy,pitchVec);\n    \n}\n\nvec3 moveFromBranchSpace(vec3 rayPt, vec3 rotOrigin, float pitch, float yaw){\n    \n    vec3 resultPt = rayPt;\n    \n    vec2 yawVec = vec2(cos(-yaw),sin(-yaw));\n    resultPt.xz = rotVec(resultPt.xz,yawVec);\n    \n    vec2 pitchVec = vec2(cos(-pitch),sin(-pitch));\n    resultPt.xy = rotVec(resultPt.xy,pitchVec);\n    \n    resultPt += rotOrigin;\n    \n    return resultPt;\n    \n}\n\n\nconst vec3 e=vec3(0.00007,0,0);\nconst float maxd=256.0; \/\/Max depth\nfloat nearestD = maxd;\nvec3 color = vec3(0.0,0.0,1.0);\n\nconst float branchStart=0.1;\nfloat branchEnd=0.0;\n\nfloat branchDistance(vec3 p, inout int material){\n    \n    \n    float distance = 9999.9;\n    material = 0;\n    \n    const float snowR = 0.2;\n    vec3 cylMiddle = vec3((branchStart+branchEnd)*0.5,0.0,0.0);\n    vec2 cylSize = vec2(0.0,(branchEnd-branchStart)*0.5-snowR);\n    \n    const float leavesR = 0.2;\n    \n    const float branchLeavesBelow = -0.2;\n    const vec3 subBranchOff = vec3(0.0,branchLeavesBelow,0.0);\n    \n    hardAdd(material,distance,1, obj_cylinder(p, cylMiddle, cylSize, snowR) );\n    \n    const float subBranchGap = 0.5;\/\/total space before wrap\n    const float subBranchStride = subBranchGap-snowR*2.0;\/\/branch size allowing for rounded ends\n    \n    const vec3 subBranchStart = vec3(snowR,0.0,0.0);\n    const vec3 subBranchLength = vec3(subBranchStride,-0.8,0.8);\n    \n    if ( (p.x < branchEnd) && (p.x > branchStart) ) {\n        \n        float branchX = (floor((branchEnd-p.x)\/subBranchGap)*subBranchGap);\/\/step\n    \tvec3 modP = vec3(mod(branchEnd-p.x,subBranchGap),p.y,abs(p.z));\n        \n        float unit = (branchX\/(branchEnd-branchStart));\n        float subBranchAmt = sin(unit*PI);\n        \n        vec3 subBranchSnowEnd = subBranchStart+subBranchLength*subBranchAmt;\n        vec3 subBranchLeafEnd = subBranchStart+subBranchLength*(subBranchAmt + 0.2);\n        \n        smoothAdd(distance, obj_roundline(modP,subBranchSnowEnd,subBranchStart,snowR), 0.2);\n        hardAdd(material,distance,2, obj_roundline(modP,subBranchLeafEnd+subBranchOff,subBranchStart+subBranchOff,leavesR) );\n        \n    }\n    \n    hardAdd(material,distance,2, obj_cylinder(p, cylMiddle+vec3(0.0,branchLeavesBelow,0.0), cylSize, leavesR) );\n    \n    return distance;\n    \n    \n}\n\nvoid raytraceBranch(vec3 rayPt, vec3 rayDir, vec3 treeOrigin, float theBranchEnd, float pitch, float yaw){\n    \n    \n    branchEnd = theBranchEnd;\/\/is it a terrible idea to use globals to avoid passing arguments over and over? (or a great idea?)\n    \n    \n    moveToBranchSpace(rayPt, rayDir, treeOrigin, pitch, yaw);\n    \n    float testDist = -1.0;\n    if (!testAABB(rayPt, rayDir,\n                  vec3((branchStart+branchEnd)*0.5,-0.05,0.0),\/\/hardcoded y offset\n                  vec3((branchEnd-branchStart)*0.5,0.8,2.0),\/\/hardcoded size\n                  testDist)) return;\n    \n    \n    \n    vec3 p = rayPt + rayDir*testDist;\n\n    float f=testDist;\n    float d=0.01;\n    float curMaxD = testDist + branchEnd*2.0;\/\/slightly overkill but close enough\n    int mat, dummyMat;\n    for(int i=0;i<16;i++){\n        if (f >= curMaxD) {\n\t\t\tf = maxd;\n\t\t\tbreak;\n\t\t}\n\t\tif (abs(d) < .01) break;\n        f+=d;\n        p=rayPt + rayDir*f;\n        d = branchDistance(p,mat);\n    }\n    \n    \n    \n    \n    \n    if (f < nearestD) {\n\n        nearestD = f;\n\n        \/\/ this normal calculation actually ignores the branch's tilt,\n        \/\/ but whatever, it's close enough for lighting this vague\n        vec3 n = normalize(vec3(d-branchDistance(p-e.xyy,dummyMat),\n                                d-branchDistance(p-e.yxy,dummyMat),\n                                d-branchDistance(p-e.yyx,dummyMat)));\n        \n\n        if (mat == 1) {\n            \n            float diffuse=max(dot(n,vec3(0.0,1.0,0.0)),0.0);\n            diffuse = pow(diffuse,0.5);\n            color = mix(vec3(0.90,0.55,0.00),vec3(0.95,0.85,0.70),diffuse);\n            \n        } else {\n            \n            float diffuse=max(dot(n,vec3(0.0,1.0,0.0)),0.0);\n            color = vec3(0.1,0.2,0.2) * diffuse;\n\n        }\n\n    }\n    \n    #ifdef DRAW_CLIP_RAYTRACES\n    color = mix(color,vec3(1.0,0.0,0.0),0.1);\n    #endif\n    \n}\n\n\nvoid raytraceBranchShelf(vec3 rayPt, vec3 rayDir, vec3 shelfOrigin, float shelfRad, float shelfPitch, float shelfYawOff){\n    \n    float shelfHeight = sin(shelfPitch)*shelfRad;\n    float shelfWidth = cos(shelfPitch)*shelfRad;\n    \n    float dummyDist;\n    if (!testAABB(rayPt, rayDir,\n                  shelfOrigin-vec3(0.0,shelfHeight,0.0),\n                  vec3(shelfWidth,abs(shelfHeight)+2.0,shelfWidth),\/\/hardcoded box height padding\n                  dummyDist)) return;\n    \n    \n    const int branchesAround = 8;\n    for(int i=0; i<8; i++){\n    \traytraceBranch(rayPt,rayDir,shelfOrigin,shelfRad,shelfPitch,shelfYawOff + PI*float(i)\/float(branchesAround)*2.0);\n    }\n    \n    #ifdef DRAW_CLIP_RAYTRACES\n    color = mix(color,vec3(0.0,0.0,1.0),0.1);\n    #endif\n}\n\n\nfloat timeToWindWaveAmt(float time){\n    \n    float wave = sin( time + sin(time*0.8) + sin(time*0.2)*sin(time*2.1) );\n    return wave*0.5 + 0.5;\n    \n}\n\n\nvoid raytraceTree(vec3 rayPt, vec3 rayDir, vec3 treeOrigin, float yOff, float heightOff, float widthOff){\n    \n    treeOrigin.y += 6.0+yOff;\n    \n\tvec2 aboveRayPt = rayPt.xz;\n    vec2 aboveRayDir = normalize(rayDir.xz);\n    vec2 aboveTreeOrigin = treeOrigin.xz;\n    vec2 aboveTreeGap = aboveTreeOrigin-aboveRayPt;\n    \n    \/\/ test between cylinder ends\n    \n    float distToTree = length(aboveTreeGap);\n    float stepLength = length(rayDir.xz);\n    float stepsToTree = distToTree\/stepLength;\n    float yAtTree = rayPt.y + rayDir.y*stepsToTree;\n    float coneBtmY = treeOrigin.y-12.0;\n    float coneTopY = treeOrigin.y+20.0;\/\/hook these up to the same property as actually determines the branches? :|\n    if (yAtTree < coneBtmY) return;\n    if (yAtTree > coneTopY) return;\n    float coneFracY = (yAtTree - coneBtmY) \/ (coneTopY - coneBtmY);\n    \n    \n    \/\/ test within cylinder radius\n    const float coneTopRad = 2.0;\n    const float coneBtmRad = 14.0;\n    float treeHitzoneRadius = coneTopRad + (coneBtmRad-coneTopRad)*(1.0-coneFracY);\n    float distToPointOnRayClosestToCenterOfTree = dot(aboveTreeGap,aboveRayDir)\/length(aboveRayDir);\n    if (distToPointOnRayClosestToCenterOfTree <= 0.0) return;\/\/should consider radius of cylinder too, but won't matter for this scene\n    vec2 pointOnRayClosestToCenterOfTree = aboveRayPt+aboveRayDir*distToPointOnRayClosestToCenterOfTree;\n    float closestDistToTreeCenter = length(pointOnRayClosestToCenterOfTree-aboveTreeOrigin);\n    if (closestDistToTreeCenter > treeHitzoneRadius) return;\n    \n    \n    const float numShelves=11.0;\n    for(float i=0.0; i<numShelves; i++){\n        float branchFrac = i\/numShelves;\n        \n        float windWaveOff = treeOrigin.x*-0.007;\n        float windWaveAmt = timeToWindWaveAmt(iGlobalTime*1.5 + windWaveOff);\n        windWaveAmt = 1.0 - pow( 1.0-windWaveAmt , 2.0 );\n        const float windWaveMin = 0.2;\n        windWaveAmt = windWaveAmt*(1.0-windWaveMin) + windWaveMin;\n        \n        float subWave = sin(iGlobalTime*3.0 + treeOrigin.x*-0.01 + branchFrac*1.2);\n        subWave = subWave*0.5+0.5;\n        subWave = 1.0-pow(1.0-subWave,2.0);\n        \n        float windWave = subWave*windWaveAmt*-0.04;\n        \n    \traytraceBranchShelf(rayPt, rayDir,\n                            treeOrigin+vec3(0.0,1.0+(pow(1.0-branchFrac,0.6))*(13.0+heightOff),0.0),\/\/height\n                            branchStart+0.5+(9.0+widthOff)*branchFrac,\/\/length\n                            0.05+0.6*branchFrac + windWave,\/\/pitch\n                            3.0*branchFrac\/\/yaw offset\n                           );\n    }\n    \n    \n    float trunkRadius = -(yAtTree-(treeOrigin.y+8.0))*0.1;\n    if (yAtTree < treeOrigin.y+10.0) {\n        if (closestDistToTreeCenter < trunkRadius) {\n            \/\/ this is utterly fudged, but it's close enough for such a tiny detail\n            float trunkFracFudged = (1.0-pow((closestDistToTreeCenter\/trunkRadius),3.0))*trunkRadius;\n            float trunkDist = distToPointOnRayClosestToCenterOfTree - trunkFracFudged;\n            if (trunkDist < nearestD) {\n                nearestD = trunkDist;\n            \tcolor = vec3(0.15,0.10,0.00)*(trunkFracFudged+0.2);\n            } else {\n                #ifdef DRAW_CLIP_RAYTRACES\n                color -= vec3(0.0,0.5,0.0);\n                #endif\n            }\n        }\n    }\n    \n    \n    \n    \n    \n    \n    #ifdef DRAW_CLIP_RAYTRACES\n    color = mix(color,vec3(0.0,1.0,0.0),0.1);\n    #endif\n}\n\nvoid raytraceTreeline(vec3 rayPt, vec3 rayDir, float treelineZ, float treeGapX, float offX, float groundY){\n    \n    float rayGapStepsZ = (treelineZ-rayPt.z)\/rayDir.z;\n    float rayX = rayPt.x + rayDir.x*rayGapStepsZ;\n    float treeX = floor((rayX-offX)\/treeGapX)*treeGapX + treeGapX*0.5 + offX;\n    \n    if (abs(treeX) > 240.0) return;\n    \n    raytraceTree(rayPt,rayDir,vec3(treeX,groundY,treelineZ),\n    \tsin(treeX+treelineZ)*1.5,\/\/yOff\n        sin(treeX*0.7+treelineZ)*4.0,\/\/heightOff\n        sin(treeX*0.85+treelineZ)*1.0\/\/widthOff\n    );\n    \n    #ifdef DRAW_CLIP_RAYTRACES\n    \/\/color.r += sin(treeX*0.1)*0.01+0.5;\n    #endif\n    \n}\n\nvoid raytraceHillTreeline(vec3 rayPt, vec3 rayDir, float treelineX, float treeGapZ, float offZ, float offY, float slopeY){\n    \n    if (rayDir.x < 0.0) treelineX *= -1.0;\n    \n    float groundY = 0.0;\n    \n    float rayGapStepsX = (treelineX-rayPt.x)\/rayDir.x;\n    float rayZ = rayPt.z + rayDir.z*rayGapStepsX;\n    float treeZ = floor((rayZ-offZ)\/treeGapZ)*treeGapZ + treeGapZ*0.5 + offZ;\n    \n    if (treeZ > 40.0) return;\n    if (treeZ < -70.0) return;\n    \n    const float hillNearZ = 0.0;\n    if (treeZ > hillNearZ) groundY = (treeZ-hillNearZ)*slopeY;\n    \n    groundY += offY;\n    \n    raytraceTree(rayPt,rayDir,vec3(treelineX,groundY,treeZ),\n    \tsin(treeZ+treelineX)*1.5,\/\/yOff\n        sin(treeZ*0.7+treelineX)*4.0,\/\/heightOff\n        sin(treeZ*0.85+treelineX)*1.0\/\/widthOff\n    );\n    \n    \/\/#ifdef DRAW_CLIP_RAYTRACES\n    \/\/color.g += sin(treeZ*0.2)*0.1+0.5;\n    \/\/#endif\n    \n}\n\n\n\nconst float roadZ = 54.0;\nconst float roadGroundY = -14.0;\nconst float roadW = 240.0;\n\nfloat groundDistance(vec3 p, inout int material){\n    \n    float distance = 9999.9;\n    material = 0;\n    \n    \n    \n    hardAdd(material,distance,1,\n    \tobj_box(p, vec3(0.0,-50.0,-23.0),\n\t\tvec3(70.0,50.0,55.0),\n\t\t40.0) );\n    \n    smoothAdd(distance,\n\t\tobj_box(p, vec3(0.0,-12.0,-75.0),\n        vec3(58.0,32.0,36.0),\n        30.0), 30.0 );\n    \n    smoothAdd(distance,\n        obj_box(p, vec3(0.0,roadGroundY-20.0,64.0),\n        vec3(roadW,20.0,100.0),\n        20.0), 15.0 );\n    \n    distance += sin( p.x*0.4 + sin(p.x*0.2) + sin(p.z*0.5)*0.75 )*0.2;\n    distance += sin( p.z*0.4 + sin(p.z*0.2) + sin(p.x*0.5)*0.75 )*0.2;\n    \n    smoothSubtract(distance,\n\t\tobj_box(p, vec3(0.0,roadGroundY+4.9,roadZ),\n        vec3(roadW,6.0,12.0),\n        4.0), 1.0 );\n    \n    hardAdd(material,distance,3,\n    \tobj_box(p, vec3(0.0,roadGroundY-3.1,roadZ),\n        vec3(roadW,2.1,12.0),\n        0.0) );\n    \n    \n    \n    \n    \n    return distance;\n    \n}\n\nfloat flakeDistance(vec3 p){\n    \n    const float snowflakeMaxDist = 20.0;\n    if ( (abs(p.x) > snowflakeMaxDist) || (abs(p.y) > snowflakeMaxDist) || (abs(p.z) > snowflakeMaxDist) ) return 9999.9;\n    \n    float snowPush = 1.25*iGlobalTime;\n    \n    p.x += snowPush*-10.0;\n    p.y += snowPush*1.5;\n    p.z += snowPush*-0.25;\n    \n    const float modDist = 4.0;\n    \n    float stepX = floor(p.x\/modDist);\n    float stepY = floor(p.y\/modDist);\n    float stepZ = floor(p.z\/modDist);\n    \n    vec3 flakeP = vec3(\n        mod(p.x,modDist),\n        mod(p.y,modDist),\n        mod(p.z,modDist)\n    );\n    \n    vec3 flakePos = vec3(modDist*0.5);\n    \n    flakePos.x += sin(snowPush+stepY*1.0)*(2.0\/5.0)*modDist;\n    flakePos.y += sin(snowPush+stepZ*1.3)*(2.0\/5.0)*modDist;\n    flakePos.z += sin(snowPush+stepX*1.7)*(2.0\/5.0)*modDist;\n\t\n    \n    return obj_ball(flakeP, flakePos, 0.08);\n    \n}\n\n\nvoid tiretrack(vec3 p, inout float clearAmt, float period, float origOffX, float offY, float amt, float width) {\n    \n    float offX = origOffX;\n    \n    float testY = p.z - roadZ;\n    if (testY < 0.0) {\n        testY *= -1.0;\n        offX += 8.0;\n    }\n    if (testY > 5.0) {\n        testY -= 5.0;\n        offX += 8.0;\n    }\n    \n    float waveY = sin(p.x*period+offX)*amt+offY;\n    float offDist = abs(testY-waveY)\/width;\n    if (offDist<1.0) clearAmt += 1.0-pow(offDist,2.0);\n    \n}\n\n\n\n\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ) {\n    \n    \n    \n    vec3 scrCoord = fragRayOri;\n    vec3 curCameraRayUnit = fragRayDir;\n    \n    \n    \n    scrCoord.y += 1.7;\/\/ standing person\n    \n    \n    \/\/ bleh.. but, I accidentally set the scene up backwards! 9_9\n    curCameraRayUnit *= vec3(-1.0,1.0,-1.0);\n    scrCoord *= vec3(-1.0,1.0,-1.0);\n    \/\/\n    \n    \n    \n    vec3 p = scrCoord;\n\n    float f=0.0;\n    float d=0.01;\n    int mat, dummyMat;\n    for(int i=0;i<64;i++){\n        if ((abs(d) < .001) || (f > maxd)) break;\n        f+=d;\n        p=scrCoord + curCameraRayUnit*f;\n        d = groundDistance(p,mat);\n    }\n    \n    if (f < nearestD) {\n\n        nearestD = f;\n        \n        vec3 n = normalize(vec3(d-groundDistance(p-e.xyy,dummyMat),\n                                d-groundDistance(p-e.yxy,dummyMat),\n                                d-groundDistance(p-e.yyx,dummyMat)));\n\n\n        if (mat == 1) {\n            \n            float diffuse=max(dot(n,vec3(0.0,1.0,0.0))*0.5+0.5,0.0);\n            const float minVal = -1.0;\n            diffuse = max(0.0, minVal + diffuse*(1.0-minVal) );\n            diffuse = pow(diffuse,2.0);\n            color = mix(vec3(0.25,0.0,0.10),vec3(0.95,0.85,0.60),diffuse);\n            \n        }\n        if (mat == 3) {\n            if ( abs(p.z-roadZ) < 0.8 ) {\n                color = vec3(0.47,0.42,0.20);\n            } else {\n            \tcolor = vec3(0.20,0.15,0.15);\n            }\n            float clearAmt = 0.5;\n            \n            const float trackW = 0.8;\n            tiretrack(p,clearAmt,\n                      0.13,\/\/period\n                      6.0,\/\/offX\n                      1.5,\/\/offY\n                      0.5,\/\/amp\n                      trackW\n                     );\n            tiretrack(p,clearAmt,\n                      0.06,\/\/period\n                      0.0,\/\/offX\n                      2.5,\/\/offY\n                      0.5,\/\/amp\n                      trackW\n                     );\n            tiretrack(p,clearAmt,\n                      0.22,\/\/period\n                      19.0,\/\/offX\n                      3.5,\/\/offY\n                      0.5,\/\/amp\n                      trackW\n                     );\n            clearAmt \/= 3.0;\n            clearAmt = 1.0-pow(1.0-clearAmt,1.5);\n            color = mix(color,vec3(0.95,0.85,0.60),0.5-0.4*clearAmt);\n        }\n\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n    raytraceHillTreeline(scrCoord,curCameraRayUnit, 75.0, 19.0,  4.0,  -6.0, -0.4);\n    raytraceHillTreeline(scrCoord,curCameraRayUnit,100.0, 12.0,  0.0, -10.0, -0.25);\n    \n    raytraceTreeline(scrCoord,curCameraRayUnit,roadZ+25.0, 17.0, 12.0,roadGroundY-1.0);\n    raytraceTreeline(scrCoord,curCameraRayUnit,roadZ+40.0, 14.0,  2.0,roadGroundY-1.0);\n    raytraceTreeline(scrCoord,curCameraRayUnit,roadZ+55.0, 11.0,  3.0,roadGroundY-1.0);\n    \n    \n    \n    float litAmt = max(0.0,dot(vec3(0.0,1.0,0.0),curCameraRayUnit))*0.5+0.5;\n    litAmt = 1.0-pow(1.0-litAmt,1.5);\n    vec3 skyCol = mix(vec3(0.45,0.10,0.25),vec3(0.90,0.80,0.50),litAmt);\n    \n    float distFrac = nearestD\/maxd;\n    color = mix(color,skyCol,distFrac);\n    \n    \n    \n    \n    \n    \n    \n    \n    f=0.0;\n    d=0.01;\n    const vec3 flakeE=vec3(0.007,0,0);\n    for(int i=0;i<128;i++){\n        if ((abs(d) < .001) || (f > maxd)) break;\n        f+=d*0.125;\n        p=scrCoord + curCameraRayUnit*f;\n        d = flakeDistance(p);\n    }\n    \n    if (f < nearestD && abs(d)<0.001) {\n\n        nearestD = f;\n        \n        vec3 n = normalize(vec3(d-flakeDistance(p-flakeE.xyy),\n                                d-flakeDistance(p-flakeE.yxy),\n                                d-flakeDistance(p-flakeE.yyx)));\n\n\n        float edgeFade = pow(max(0.0,dot(n,-curCameraRayUnit)),3.0)*0.7;\n        float distFade = max(0.0,1.0-(nearestD\/20.0));\n        color = mix(color,vec3(1.0,0.9,0.6),edgeFade*distFade);\n\n    }\n    \n    \n    \n    \n    \n    \n    \n    fragColor = vec4(color,1.0);\n    \n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    \n    float camLookX, camLookY;\n    \n    vec2 mouseFrac = iMouse.xy\/iResolution.xy;\n    mouseFrac -= 0.5;\n    mouseFrac *= 2.0;\n    \n    if (iMouse.z != 0.0) {\n        \n        camLookX = -mouseFrac.x * PI;\n        camLookX += PI;\n        \n    \tcamLookY = mouseFrac.y;\n        camLookY *= PI*0.35;\n        \n    } else {\n        camLookX = PI*0.75;\n        camLookY = PI*-0.05;\n    }\n    \n    \n    \n    \n    float vertFov = 50.0;\n    float horizFov = 2.0*atan(tan((vertFov\/180.0*PI)\/2.0)*(iResolution.x\/iResolution.y))*180.0\/PI;\n    vec4 fovAngsMono = vec4(horizFov\/2.0, horizFov\/2.0, vertFov\/2.0, vertFov\/2.0);\n    \n    \n    \n    vec2 fragFrac = fragCoord.xy\/iResolution.xy;\n\n    vec2 eyeRes = iResolution.xy;\n    vec4 fovAngs = fovAngsMono;\n\n\n    \/\/vec3 cameraRight,cameraUp,cameraFwd;\n    \/\/quatToAxes(headOrientation,cameraRight,cameraUp,cameraFwd);\n    vec3 cameraRight = vec3(cos(camLookX),0.0,sin(camLookX));\n    vec3 cameraFwd = vec3(cos(camLookX+PI*0.5)*cos(camLookY),sin(camLookY),sin(camLookX+PI*0.5)*cos(camLookY));\n    vec3 cameraUp = -cross(cameraRight,cameraFwd);\n    cameraFwd *= -1.0;\n    \n    \n    \n    \/\/ position\n\n    vec3 cameraPos = vec3(0.0);\n    \n    \n    \n    float fovL = -fovAngs.x\/180.0*PI;\n    float fovR =  fovAngs.y\/180.0*PI;\n    float fovU = -fovAngs.z\/180.0*PI;\n    float fovD =  fovAngs.w\/180.0*PI;\n\n    float fovMiddleX = (fovR + fovL) * 0.5;\n    float fovMiddleY = (fovU + fovD) * 0.5;\n    float fovHalfX = (fovR - fovL) * 0.5;\n    float fovHalfY = (fovD - fovU) * 0.5;\n\n\n\n    float scrWorldHalfX = sin(fovHalfX)\/sin(PI*0.5 - fovHalfX);\n    float scrWorldHalfY = sin(fovHalfY)\/sin(PI*0.5 - fovHalfY);\n\n\n    \/\/ determine screen plane size from FOV values, then interpolate to find current pixel's world coord\n\n    vec2 vPos = fragFrac;\/\/0 to 1\n    vPos.x -= (-fovL\/(fovHalfX*2.0));\n    vPos.y -= (-fovU\/(fovHalfY*2.0));\n\n    vec3 screenPlaneCenter = cameraPos+cameraFwd;\n    vec3 scrCoord = screenPlaneCenter + vPos.x*cameraRight*scrWorldHalfX*2.0 + vPos.y*cameraUp*scrWorldHalfY*2.0;\n    vec3 curCameraRayUnit = normalize(scrCoord-cameraPos);\n    \n    \n    \n    \/\/ scene is accidentally backwards, ugh\n    curCameraRayUnit *= vec3(-1.0,1.0,-1.0);\n    scrCoord *= vec3(-1.0,1.0,-1.0);\n    \/\/\n    \n    mainVR(fragColor,fragCoord,scrCoord,curCameraRayUnit);\n    \n    \n    \n}","name":"","description":"","type":"image"},{"inputs":[],"outputs":[{"channel":"0"}],"code":"const int rest = 999;\n\nint imod(int x, int modulo){\n    return int(mod(float(x),float(modulo)));\/\/ewwwww\n}\n\nfloat noteFreq(int note){\n    float oct = 1.0;\n    if (note >= 12) {\n        note -= 12;\n        oct = 2.0;\n    }\n    if (note < 0) {\n        note += 12;\n        oct = 0.5;\n    }\n    if (note ==  0) return oct*391.995;\n    if (note ==  1) return oct*415.305;\n    if (note ==  2) return oct*440.000;\n    if (note ==  3) return oct*466.164;\n    if (note ==  4) return oct*493.883;\n    if (note ==  5) return oct*523.251;\n    if (note ==  6) return oct*554.365;\n    if (note ==  7) return oct*587.330;\n    if (note ==  8) return oct*622.254;\n    if (note ==  9) return oct*659.255;\n    if (note == 10) return oct*698.456;\n    if (note == 11) return oct*739.989;\n    return 0.0;\n}\nint melodyNote(int beat){\n    if (beat < 0) return rest;\n    int melodyBeat = imod(beat,6);\n    if (melodyBeat == 0) return 3;\n    if (melodyBeat == 1) return 7;\n    if (melodyBeat == 2) return 2;\n    if (melodyBeat == 3) return 3;\n    if (melodyBeat == 4) return 0;\n    if (melodyBeat == 5) return 7;\n    return rest;\n}\nfloat melodyVol(int beat){\n    if (beat < 0) return 0.0;\n    int melodyBeat = imod(beat,6);\n    if (melodyBeat == 0) return 1.0;\n    if (melodyBeat == 1) return 0.07;\n    if (melodyBeat == 2) return 0.4;\n    if (melodyBeat == 3) return 0.3;\n    if (melodyBeat == 4) return 0.5;\n    if (melodyBeat == 5) return 0.07;\n    return 0.0;\n}\n\n\/*\nint harmonyNote(int bar){\n    if (bar == 0) return 12;\n    if (bar == 1) return 10;\n    if (bar == 2) return 8;\n    if (bar == 3) return 7;\n    if (bar == 4) return 8;\n    if (bar == 5) return 7;\n    if (bar == 6) return 5;\n    if (bar == 7) return 0;\n    return rest;\n}\n*\/\n\nint harmonyNoteA(int bar){\n    if (bar > 7) bar = 7;\n    if (bar == 0) return 12;\n    if (bar == 1) return 10;\n    if (bar == 2) return 8;\n    if (bar == 3) return 7;\n    if (bar == 4) return 8;\n    if (bar == 5) return 7;\n    if (bar == 6) return 5;\n    if (bar == 7) return 3;\n    return rest;\n}\nint harmonyNoteB(int bar){\n    if (bar > 7) bar = 7;\n    if (bar == 0) return 7;\n    if (bar == 1) return 5;\n    if (bar == 2) return 3;\n    if (bar == 3) return 3;\n    if (bar == 4) return 3;\n    if (bar == 5) return 3;\n    if (bar == 6) return 0;\n    if (bar == 7) return 0;\n    return rest;\n}\nint harmonyNoteC(int bar){\n    if (bar > 6) {\n        bar = 6+imod(bar,2);\n    }\n    if (bar == 0) return 3;\n    if (bar == 1) return 2;\n    if (bar == 2) return 0;\n    if (bar == 3) return 0;\n    if (bar == 4) return 0;\n    if (bar == 5) return -2;\n    if (bar == 6) return -4;\n    if (bar == 7) return -5;\n    return rest;\n}\n\nconst float beatLength = 0.36;\nconst float ringLength = 3.0;\n\nfloat beatFrac;\nfloat attack(float power){\n\treturn 1.0-pow(1.0-beatFrac,power);\n}\nfloat release(float power){\n\treturn 1.0-pow(beatFrac,power);\n}\n\nvec2 strikeNote(int note, float vol, float time, bool isMelody){\n    \n    if (note == rest) return vec2(0.0);\n    if (time < 0.0) return vec2(0.0);\n    \n    beatFrac = time\/(beatLength*(isMelody?ringLength:7.0));\n    float baseFreq = 6.2831*noteFreq(note)*time;\n    \n    vec2 mix = vec2(0.0);\n    \n    if (isMelody) {\n        mix += vec2( sin(baseFreq* 1.0)*attack(100.0)*release(0.25)*vol*0.10 );\n        mix += vec2( sin(baseFreq* 4.0)*attack(200.0)*release(0.125)*vol*0.25 );\n        mix += vec2( sin(baseFreq*10.0)*attack(200.0)*release(0.125)*vol*0.025 );\n        mix += vec2( sin(baseFreq*16.0)*attack(400.0)*release(0.125)*vol*0.02 );\n        mix *= 0.4;\n    } else {\n        baseFreq *= 0.125;\n        mix += vec2( sin(baseFreq* 2.0)*attack(400.0)*release(3.0)*vol*0.004 );\n        mix += vec2( sin(baseFreq* 3.0)*attack(1600.0)*release(2.0)*vol*0.002 );\n        mix += vec2( sin(baseFreq* 4.0)*attack(3200.0)*release(0.5)*vol*0.125 );\n        mix += vec2( sin(baseFreq* 8.0)*attack(400.0)*release(0.25)*vol*0.005 );\n    }\n    \n    \n    return mix;\n    \n}\n\nvec2 mainSound(float time){\n    \n    float songtime = time - 1.0;\n    \n    if (songtime < 0.0) return vec2(0.0);\n    \n    \n    int beat = int(songtime\/beatLength);\n    float beatTime = mod(songtime,beatLength);\n    \n    vec2 mix = vec2(0.0);\n    for(float i=0.0; i<ringLength; i++){\n        mix += strikeNote(melodyNote(beat-int(i)),melodyVol(beat-int(i)),beatTime+beatLength*i,true);\n    }\n    \n    \n    int bar = int(songtime\/(beatLength*6.0))-4;\n    if (bar >= 0) {\n        \n        float barTime = mod(songtime,(beatLength*6.0));\n\n        mix += strikeNote(harmonyNoteA(bar),0.8,barTime,false);\n        mix += strikeNote(harmonyNoteB(bar),0.3,barTime-0.02,false);\n        mix += strikeNote(harmonyNoteC(bar),0.3,barTime-0.04,false);\n        \n        if (barTime < 1.0) {\n            beatFrac = barTime*1.0;\n            float tom = sin(barTime*pow((1.0-barTime),1.5)*500.0);\n        \tmix += (tom*attack(5000.0)*release(0.02))*0.5;\n        }\n\n    }\n        \n    const float fadeStart = beatLength*6.0*14.0;\n    const float fadeEnd = beatLength*6.0*16.0;\n    float fadeout = max(0.0,min(1.0,1.0-((songtime-fadeStart)\/(fadeEnd-fadeStart))));\n    fadeout = pow(fadeout,1.5);\n    \n    return mix*fadeout*4.0;\n    \n}","name":"","description":"","type":"sound"}]}}