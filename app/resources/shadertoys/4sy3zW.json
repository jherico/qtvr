{"Shader":{"ver":"0.1","info":{"id":"4sy3zW","date":"1453379447","viewed":88,"name":"Everyday021 - Relax","username":"Makio64","description":"everyday021 - Relax","likes":3,"published":3,"flags":0,"tags":["everyday"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Everyday021 - Relax\n\/\/ By David Ronai \/ @Makio64\n\n\/\/------------------------------------------------------------------ VISUAL QUALITY\n#define POSTPROCESS\n#define RAYMARCHING_STEP 40\n#define RAYMARCHING_JUMP 1.\n\/\/------------------------------------------------------------------ DEBUG\n\/\/#define RENDER_DEPTH\n\/\/#define RENDER_NORMAL\n\/\/#define RENDER_AO\n\nconst float SPEED = 10.;\nconst float PI = 3.14159265359;\n\n\/\/------------------------------------------------------------------  SIGNED PRIMITIVES\n\/\/http:\/\/mercury.sexy\/hg_sdf\/\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nvec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5)\/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r\/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\nfloat fHexagonCircumcircle(vec3 p, vec2 h) {\n\tvec3 q = abs(p);\n\treturn max(q.y - h.y, max(q.x*sqrt(3.)*0.5 + q.z*0.5, q.z) - h.x);\n}\nfloat pyramid( vec3 p, float h) {\n\tvec3 q=abs(p);\n\treturn max(-p.y, (q.x*1.5+q.y+q.z*1.5-h)\/3.0 );\n}\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI\/repetitions;\n\tfloat a = atan(p.y, p.x) + angle\/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a\/angle);\n\ta = mod(a,angle) - angle\/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\tif (abs(c) >= (repetitions\/2.)) c = abs(c);\n\treturn c;\n}\n\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)\/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n\n\n\/\/------------------------------------------------------------------ MAP\nfloat map( in vec3 pos ) {\n\tvec3 q = pos;\n    \/\/pR(q.xy,iGlobalTime+sin(pos.z));\n    pModPolar(q.xy,18.);\n    pMod1(q.z,0.0000001);\n    float idx2 = pMod1(pos.z,10.);\n    idx2 = abs(sin(idx2))*3.;\n    q.y += 10.;\n\tfloat d = pyramid(q,20.);\n    q.y -= 1.8;\n\tfloat d2 = pyramid(q,15.);\n    d = max(-d2,d);\n\tfloat b = fBox(pos, vec3(50.,50.,2.));\n    d = max(-b,d);    \n    return d;\n}\n\n\/\/------------------------------------------------------------------ RAYMARCHING\n#ifdef RENDER_DEPTH\nfloat castRay( in vec3 ro, in vec3 rd, inout float depth )\n#else\nfloat castRay( in vec3 ro, in vec3 rd )\n#endif\n{\n\tfloat t = 0.0;\n\tfloat res;\n\tfor( int i=0; i<RAYMARCHING_STEP; i++ )\n\t{\n\t\tvec3 pos = ro+rd*t;\n\t\tres = map( pos );\n\t\tif( res < 0.01 || t > 150. ) break;\n\t\tt += res*RAYMARCHING_JUMP;\n\t\t#ifdef RENDER_DEPTH\n\t\tdepth += 1.\/float(RAYMARCHING_STEP);\n\t\t#endif\n\t}\n\treturn t;\n}\n\nvec3 calcNormal(vec3 p) {\n\tfloat eps = 0.0001;\n\tconst vec3 v1 = vec3( 1.0,-1.0,-1.0);\n\tconst vec3 v2 = vec3(-1.0,-1.0, 1.0);\n\tconst vec3 v3 = vec3(-1.0, 1.0,-1.0);\n\tconst vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\treturn normalize( v1 * map( p + v1*eps ) +\n\t\t\t\t\t  v2 * map( p + v2*eps ) +\n\t\t\t\t\t  v3 * map( p + v3*eps ) +\n\t\t\t\t\t  v4 * map( p + v4*eps ) );\n}\n\nfloat hash( float n ){\n\treturn fract(sin(n)*3538.5453);\n}\n\nfloat calcAO( in vec3 p, in vec3 n, float maxDist, float falloff ){\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = n*l;\n\t\tao += (l - map( p + rd )) \/ pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao\/float(nbIte), 0., 1.);\n}\n\n\/\/ calculate local thickness\n\/\/ base on AO but : inverse the normale & inverse the color\nfloat thickness( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = -n*l;\n\t\tao += (l + map( p + rd )) \/ pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao\/float(nbIte), 0., 1.);\n}\n\n\/\/------------------------------------------------------------------ POSTEFFECTS\n\n#ifdef POSTPROCESS\nvec3 postEffects( in vec3 col, in vec2 uv, in float time )\n{\n\t\/\/ vigneting\n\tcol *= 0.4+0.6*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.5 );\n\treturn col;\n}\n#endif\n\nvec3 addLight(in vec3 lpos, inout vec3 col, in vec3 pos, in vec3 nor, in vec3 rd, in float thi){\n\tvec3 ldir = normalize(lpos-pos);\n\tfloat latt = pow( length(lpos-pos)*.03, .5 );\n    float trans =  pow( clamp( max(0.,dot(-rd, -ldir+nor)), 0., 1.), 1.) + 1.;\n\t\/\/col = vec3(.2,.1,.1) * (max(dot(nor,ldir),0.) ) \/ latt;\n\tcol += vec3(.3,.3,.1) * (trans\/latt)*thi;\n    return col;\n   \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv )\n{\n\tvec3 col = vec3(.0,.0,1.2);\n\n\t#ifdef RENDER_DEPTH\n\tfloat depth = 0.;\n\tfloat t = castRay(ro,rd,depth);\n\t#else\n\tfloat t = castRay(ro,rd);\n\t#endif\n\n\t#ifdef RENDER_DEPTH\n\treturn vec3(depth\/10.,depth\/5.,depth);\n\t#endif\n\n\tvec3 pos = ro + t * rd;\n\tvec3 nor = calcNormal(pos);\n\n\t#ifdef RENDER_NORMAL\n\treturn nor;\n\t#endif\n\n\tfloat ao = calcAO(pos,nor,10.,1.2);\n\t#ifdef RENDER_AO\n\treturn vec3(ao);\n\t#endif\n\n    float thi = thickness(pos, nor, 4., 2.5);\n\n    vec3 lpos1 = vec3(0.,27.5,-iGlobalTime*SPEED);\n\tvec3 ldir1 = normalize(lpos1-pos);\n\tfloat latt1 = pow( length(lpos1-pos)*.03, 1. );\n    float trans1 =  pow( clamp( max(0.,dot(-rd, -ldir1+nor)), 0., 1.), 1.) + 1.;\n\tvec3 diff1 = vec3(.3,.2,.1) * (max(dot(nor,ldir1),0.) ) \/ latt1;\n\tcol =  diff1;\n\tcol += vec3(.8,.6,.9) * (trans1\/latt1)*thi;\n    \n    vec3 lpos = vec3(80.,0.,-iGlobalTime*SPEED);\n    vec3 ldir = normalize(lpos-pos);\n\tfloat latt = pow( length(lpos-pos)*.03, .1 );\n    float trans =  pow( clamp( max(0.,dot(-rd, -ldir+nor)), 0., 1.), 1.) + 1.;\n\tcol += vec3(.2,.1,.1) * (max(dot(nor,ldir),0.) ) \/ latt;\n\tcol += vec3(.1,.1,.1) * (trans\/latt)*thi;\n\n    float d = distance(pos.xyz,vec3(0.));\n\tcol = max(vec3(.05),col);\n\tcol *= ao;\n    \n\tcol = mix( col, vec3(1.), 1.0-exp((0.000015+abs(sin(iGlobalTime)*0.00015))*t*t));\n\n\treturn col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\treturn mat3( cu, cv, cw );\n}\n\nvec3 orbit(float phi, float theta, float radius)\n{\n\treturn vec3(\n\t\tradius * sin( phi ) * cos( theta ),\n\t\tradius * cos( phi ),\n\t\tradius * sin( phi ) * sin( theta )\n\t);\n}\n\n\/\/------------------------------------------------------------------ MAIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec2 p = -1. + 2. * uv;\n    p.x *= iResolution.x \/ iResolution.y;\n    \n    \/\/Camera\n\tfloat radius = 10.;\n    float angle = iGlobalTime;\n\tvec3 ro = vec3(0.,0.2,-SPEED*iGlobalTime+radius);\n\tvec3 ta  = vec3(0.,0., -SPEED*iGlobalTime);\n\tmat3 ca = setCamera( ro, ta, 0. );\n\tvec3 rd = ca * normalize( vec3(p.xy,1.5) );\n\n\t\/\/ Raymarching\n\tvec3 color = render( ro, rd, uv );\n\t#ifdef POSTPROCESS\n\tcolor = postEffects( color, uv, iGlobalTime );\n\t#endif\n\tfragColor = vec4(color,1.0);\n}","name":"","description":"","type":"image"}]}}