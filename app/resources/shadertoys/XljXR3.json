{"Shader":{"ver":"0.1","info":{"id":"XljXR3","date":"1445431109","viewed":445,"name":"Gotham City","username":"dr2","description":"A city without traffic problems, a short day\/night cycle, and a skydeck (mousing encouraged).","likes":13,"published":3,"flags":0,"tags":["raymarching","cityscape"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ \"Gotham City\" by dr2 - 2015\n\/\/ License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n\/\/ Architectural motifs and idea of dda-based raymarching from\n\/\/ Octavio Good's \"Skyline\"; with thanks.\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, cHashA3.xy)) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + cHashA4.xy) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat IFbm1 (float p)\n{\n  float s, a;\n  s = 0.;\n  a = 1.;\n  for (int j = 0; j < 4; j ++) {\n    s += floor (10. * a * Noiseff (p));\n    a *= 0.6;\n    p *= 4.;\n  }\n  return 0.1 * s;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat PrOBoxDf (vec3 p, vec3 b)\n{\n  return length (max (abs (p) - b, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z \/ h, -1., 1.))) - r;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h = clamp (0.5 + 0.5 * (b - a) \/ r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p = abs (fract (c.xxx + vec3 (1., 2.\/3., 1.\/3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nmat3 vuMat;\nvec3 vuPos, qHit, sunDir;\nvec2 iqBlk, cTimeV;\nfloat dstFar, tCur, scnCount, flyDir, fDayLt, qcCar, cDir;\nint idObj, flyMode;\nconst float flrHt = 0.05;\nconst int idBldgF = 1, idBldgC = 2, idRoad = 3, idSWalk = 4, idCarWhl = 5,\n   idCarBdy = 6, idTrLight = 7, idTwr = 8, idTwrTop = 9;\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 dyCol, ntCol, rds;\n  vec2 p;\n  float cloudFac, a, s, sd;\n  if (rd.y > 0.) {\n    ro.xz += 2. * tCur;\n    p = 0.005 * (rd.xz * (100. - ro.y) \/ rd.y + ro.xz);\n    a = 0.8;\n    s = 0.;\n    for (int j = 0; j < 4; j ++) {\n      s += a * Noisefv2 (p);\n      a *= 0.5;\n      p *= 2.;\n    }\n    cloudFac = clamp (2. * s * sqrt (rd.y) - 0.1, 0., 1.);\n  } else cloudFac = 0.;\n  sd = max (dot (rd, sunDir), 0.);\n  dyCol = vec3 (0.05, 0.15, 0.3) + 0.25 * pow (1. - max (rd.y, 0.), 8.) +\n     (0.35 * pow (sd, 6.) + 0.65 * min (pow (sd, 256.), 0.3));\n  dyCol = mix (dyCol, vec3 (1.), cloudFac);\n  ntCol = vec3 (0.02, 0.02, 0.04);\n  rds = rd + vec3 (1.);\n  for (int j = 0; j < 10; j ++)\n     rds = 11. * abs (rds) \/ dot (rds, rds) - 3.;\n  ntCol += vec3 (0.7, 0.6, 0.6) * max (1. - 8. * fDayLt, 0.) *\n     min (1., 1.5e-6 * pow (min (16., length (rds)), 5.));\n  return mix (ntCol, dyCol, fDayLt);\n}\n\nfloat BldgDf (vec3 p, float dMin)\n{\n  vec3 q, qq;\n  vec2 ip;\n  float d, bWid, bWidU, bHt, bHtU, bShape, tWid, hiMid, twHt;\n  bool bTall;\n  ip = floor (p.xz);\n  hiMid = dot (ip, ip);\n  bTall = (hiMid == 0.);\n  hiMid = 0.75 * clamp (4. \/ max (sqrt (hiMid), 1.), 0., 1.);\n  d = p.y;\n  if (d < dMin) { dMin = d;  idObj = idRoad;  qHit = p;  iqBlk = ip; }\n  q = p;\n  q.xz = fract (q.xz) - vec2 (0.5);\n  bWid = floor ((0.2 + Hashfv2 (11. * ip) * 0.1) \/ flrHt + 0.5) * flrHt;\n  bWidU = floor (bWid * (0.5 + 0.3 * Hashfv2 (12. * ip)) \/ flrHt + 0.5) * flrHt;\n  bHt = (0.5 * Hashfv2 (13. * ip) + 0.05) * hiMid *\n     (1.5 + (bWid - 0.15) \/ flrHt) + 0.1;\n  bHtU = 0.25 * bHt + 0.75 * max (0., Hashfv2 (15. * ip) - 0.5) * hiMid + 0.05;\n  bHt = (floor (bHt \/ flrHt) + 0.2) * flrHt;\n  bHtU = floor (bHtU \/ flrHt) * flrHt;\n  if (bHtU > 0.) bHtU += 0.2 * flrHt;\n  if (bTall) {\n    bHt = max (bHt, 40.2 * flrHt);\n    bHtU = max (bHtU, 20.2 * flrHt);\n  }\n  tWid = ((bHtU > 0.) ? bWidU : bWid) - 0.0125;\n  bShape = Hashfv2 (17. * ip);\n  q.y -= 0.0015;\n  d = PrOBoxDf (q, vec3 (0.35, 0.0015, 0.35));\n  if (d < dMin) { dMin = d;  idObj = idSWalk;  qHit = p; }\n  q.y -= 0.0015;\n  qq = q;\n  qq.xz = abs (qq.xz) - vec2 (0.345);\n  qq.y -= 0.02;\n  d = PrCylDf (qq.xzy, 0.002, 0.02);\n  if (d < dMin) { dMin = d;  idObj = idTrLight;  qHit = qq; }\n  qq = q;\n  qq.y -= bHt - 0.2 * flrHt - 0.001;\n  if (bShape > 0.25) {\n    d = PrOBoxDf (qq, vec3 (bWid, bHt, bWid));\n    if (d < dMin) { dMin = d;  idObj = idBldgF;  qHit = qq;  iqBlk = ip; }\n  } else {\n    d = PrCylDf (qq.xzy, bWid, bHt);\n    if (d < dMin) { dMin = d;  idObj = idBldgC;  qHit = qq;  iqBlk = ip; }\n  }\n  qq.y -= bHt + bHtU - 0.2 * flrHt - 0.001;\n  if (bHtU > 0.) {\n    if (bShape > 0.5) {\n      d = max (PrOBoxDf (qq, vec3 (bWidU, bHtU, bWidU)),\n         - PrOBoxDf (qq - vec3 (0., bHtU, 0.),\n\t vec3 (tWid, 0.1 * flrHt, tWid)));\n      if (d < dMin) { dMin = d;  idObj = idBldgF;  qHit = qq;  iqBlk = ip; }\n    } else {\n      d = max (PrCylDf (qq.xzy, bWidU, bHtU),\n\t - PrCylDf ((qq - vec3 (0., bHtU, 0.)).xzy, tWid, 0.1 * flrHt));\n      if (d < dMin) { dMin = d;  idObj = idBldgC;  qHit = qq;  iqBlk = ip; }\n    }\n  }\n  if (flyMode > 0) {\n    qq.y -= bHtU - 0.2 * flrHt - 0.001;\n    if (bShape < 0.1) {\n      d = PrCapsDf (qq.xzy, 0.4 * bWidU, 1.25 * flrHt);\n      if (d < dMin) { dMin = d;  idObj = idBldgC;  qHit = qq;  iqBlk = ip; }\n    } else if (bShape > 0.7) {\n      d = PrOBoxDf (qq, vec3 (0.25 * bWidU, 1.25 * flrHt, 0.25 * bWidU));\n      if (d < dMin) { dMin = d;  idObj = idBldgF;  qHit = qq;  iqBlk = ip; }\n    }\n    if (bHt + bHtU > 30. * flrHt) {\n      twHt = 0.1 * (bHt + bHtU);\n      qq.y -= twHt;\n      d = PrCapsDf (qq.xzy, 0.3 * flrHt, twHt);\n      if (d < dMin) {\n\tdMin = d;  qHit = qq;  iqBlk = ip;\n\tidObj = (qq.y > 0.9 * twHt) ? idTwrTop : idTwr;  \n      }\n    }\n    if (bTall) {\n      qq = q;\n      qq.y -= 2. * (bHt + bHtU) + 0.2 * flrHt;\n      d = PrCylDf (qq.xzy, 0.3, 1.2 * flrHt);\n      if (d < dMin) { dMin = d;  idObj = idBldgC;  qHit = qq;  iqBlk = ip; }\n    }\n  }\n  return dMin;\n}\n\nfloat CarDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, bf, vDir, cCar;\n  if (cDir == 0. && abs (fract (p.z) - 0.5) > 0.35 ||\n     cDir == 1. && abs (fract (p.x) - 0.5) < 0.35) {\n    p.xz = vec2 (- p.z, p.x);\n    vDir = 0.;\n  } else {\n    vDir = 1.;\n  }\n  q = p;\n  q.y -= -0.003;\n  q.z += 3. * floor (q.x);\n  q.x = fract (q.x) - 0.5;\n  q.z *= sign (q.x);\n  q.z -= cTimeV.x + ((cDir == vDir) ? vDir + cTimeV.y : 1.);\n  cCar = floor (20. * q.z);\n  q.z = fract (q.z) - 0.5;\n  q.x = abs (q.x) - 0.395 - 0.06 * step (0.7, Hashff (11. * cCar)) -\n     0.03 * Hashff (13. * cCar);\n  bf = PrOBoxDf (q + vec3 (0., 0., -0.1), vec3 (0.015, 0.05, 0.2));\n  q.z = mod (q.z, 0.05) - 0.025;\n  d = SmoothMin (PrOBoxDf (q + vec3 (0., -0.008, 0.), vec3 (0.007, 0.002, 0.015)),\n     PrOBoxDf (q + vec3 (0., -0.015, 0.003), vec3 (0.0035, 0.0003, 0.005)), 0.02);\n  d = max (d, bf);\n  if (d < dMin) { dMin = d;  idObj = idCarBdy;  qHit = q;  qcCar = cCar; }\n  q.xz = abs (q.xz) - vec2 (0.0085, 0.01);\n  q.y -= 0.006;\n  d = max (PrCylDf (q.yzx, 0.003, 0.0012), bf);\n  if (d < dMin) { dMin = d;  idObj = idCarWhl;  qHit = q; }\n  return 0.8 * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin;\n  dMin = dstFar;\n  dMin = BldgDf (p, dMin);\n  dMin = CarDf (p, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 srd, dda, h;\n  float dHit, d;\n  srd = - sign (rd.xz);\n  dda = - srd \/ (rd.xz + 0.0001);\n  dHit = 0.;\n  for (int j = 0; j < 220; j ++) {\n    p = ro + dHit * rd;\n    h = fract (dda * fract (srd * p.xz));\n    d = ObjDf (p);\n    dHit += min (d, 0.2 + max (0., min (h.x, h.y)));\n    if (d < 0.0002 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = 0.0001 * vec3 (1., -1., 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 20; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, 30. * h \/ d);\n    d += 0.3 + 0.02 * d;\n    if (h < 0.001) break;\n  }\n  return max (sh, 0.);\n}\n\nvec4 ObjCol (vec3 ro, vec3 rd, vec3 vn)\n{\n  vec3 col;\n  vec2 g;\n  float wFac, f, ff, spec;\n  wFac = 1.;\n  col = vec3 (0.);\n  spec = 0.;\n  if (idObj == idBldgF || idObj == idBldgC) {\n    col = HsvToRgb (vec3 (0.7 * Hashfv2 (19. * iqBlk), 0.2,\n       0.4 + 0.2 * Hashfv2 (21. * iqBlk)));\n    if (abs (vn.y) < 0.05) {\n      f = mod (qHit.y \/ flrHt - 0.2, 1.) - 0.5;\n      wFac = 1. - 0.5 * sign (f) * step (abs (abs (f) - 0.24), 0.02) -\n         0.801 * step (abs (f), 0.22);\n      if (wFac < 0.2) {\n        f = (idObj == idBldgF) ? 1.5 * dot (qHit.xz, normalize (vn.zx)) :\n           length (qHit.xz) * (atan (qHit.z, qHit.x) + 0.5 * pi);\n  \twFac = min (0.2 + 0.8 * floor (fract (f \/ flrHt + 0.25) *\n\t   (1. + Hashfv2 (51. * iqBlk))), 1.);\n      }\n      col *= wFac;\n      spec = 0.3;\n    } else if (vn.y > 0.95) {\n      g = step (0.05, fract (qHit.xz * 70.));\n      col *= mix (0.7, 1., g.x * g.y);\n    }\n    if (wFac > 0.5)\n       col *= (0.8 + 0.2 * Noisefv2 (512. * vec2 (qHit.x + qHit.z, qHit.y)));\n  } else if (idObj == idTwr) {\n    col = vec3 (0.3);\n    spec = 0.3;\n  } else if (idObj == idTwrTop) {\n     col = vec3 (1., 0., 0.);\n     spec = -1.;\n  } else if (idObj == idSWalk) {\n    g = step (0.05, fract (qHit.xz * 35.));\n    col = vec3 (0.2) * mix (0.7, 1., g.x * g.y);\n  } else if (idObj == idTrLight) {\n    f = 2. * (atan (qHit.z, qHit.x) \/ pi + 1.) + 0.5;\n    ff = floor (f);\n    if (abs (qHit.y - 0.014) < 0.004 && abs (f - ff) > 0.3) {\n      col = mix (vec3 (0., 1., 0.), vec3 (1., 0., 0.),\n         (mod (ff, 2.) == 0.) ? cDir : 1. - cDir);\n      spec = -2.;\n    } else {\n      col = vec3 (0.4, 0.2, 0.1);\n      spec = 0.5;\n    }\n  } else if (idObj == idCarBdy) {\n    col = HsvToRgb (vec3 (Hashff (qcCar * 37.), 0.9,\n       0.4 + 0.6 * vec3 (Hashff (qcCar * 47.))));\n    f = abs (qHit.z + 0.003);\n    wFac = max (max (step (0.001, f - 0.005) * step (0.001, abs (qHit.x) - 0.0055),\n       step (f, 0.001)), step (0.0015, abs (qHit.y - 0.0145)));\n    col *= wFac;\n    spec = 1.;\n    if (abs (qHit.z) > 0.015) {\n      g = vec2 (qHit.x, 3. * (qHit.y - 0.008));\n      if (qHit.z > 0. && dot (g, g) < 3.6e-5) col *= 0.3;\n      g = vec2 (abs (qHit.x) - 0.005, qHit.y - 0.008);\n      f = dot (g, g);\n      if (qHit.z > 0. && f < 2.2e-6) {\n\tcol = vec3 (1., 1., 0.3);\n\tspec = -2.;\n      } else if (qHit.z < 0. && f < 1.1e-6) {\n\tcol = vec3 (1., 0., 0.);\n\tspec = -2.;\n      }\n    }\n  } else if (idObj == idCarWhl) {\n    if (length (qHit.yz) < 0.0015) {\n      col = vec3 (0.7);\n      spec = 0.8;\n    } else {\n      col = vec3 (0.03);\n    } \n  } else if (idObj == idRoad) {\n    g = abs (fract (qHit.xz) - 0.5);\n    if (g.x < g.y) g = g.yx;\n    col = mix (vec3 (0.05), vec3 (0.08), step (g.x, 0.355));\n    f = (step (abs (g.x - 0.495), 0.0015) + step (abs (g.x - 0.365), 0.0015)) *\n       step (g.y, 0.29);\n    col = mix (col, vec3 (1., 0.8, 0.3), f);\n    f = step (abs (g.x - 0.44), 0.0015) * step (g.y, 0.29) *\n       step (fract (g.y * 18. + 0.25), 0.7) +\n       step (0.6, fract (g.x * 30. + 0.25)) * step (0.36, g.x) *\n       step (abs (g.y - 0.32), 0.02);\n    col = mix (col, vec3 (0.8), f);\n  }\n  if (wFac < 0.5) {\n    rd = reflect (rd, vn);\n    g = Rot2D (rd.xz, 5.1 * atan (20. + iqBlk.y, 20. +  iqBlk.x));\n    col = 0.8 * (0.2 + 0.8 * (step (1., ro.y + 5. * rd.y -\n       0.2 * floor (5. * IFbm1 (0.3 * atan (g.y, g.x) + pi) + 0.05)))) *\n       SkyCol (ro, rd);\n    spec = -1.;\n  }\n  return vec4 (col, spec);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, sCol, vn;\n  float dstHit, sh, f, s, fHaze, spec;\n  int idObjT;\n  sCol = SkyCol (ro, rd);\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  if (dstHit == dstFar) idObj = -1;\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    col4 = ObjCol (ro, rd, vn);\n    col = col4.rgb;\n    spec = col4.a;\n    if (spec >= 0.) {\n      if (idObj == idRoad) vn = VaryNf (500. * qHit, vn, 2.);\n      else if (idObj == idBldgF || idObj == idBldgC)\n         vn = VaryNf (500. * qHit, vn, 0.5);\n      sh = mix (1., 0.2 + 0.8 * ObjSShadow (ro, sunDir), fDayLt);\n      col = col * (0.1 + 0.1 * max (vn.y, 0.) * sh +\n         0.8 * fDayLt * sh * max (dot (vn, sunDir), 0.)) +\n\t fDayLt * sh * spec * pow (max (0., dot (sunDir, reflect (rd, vn))), 64.);\n    }\n    if (spec == -1.) {\n      if (idObj == idBldgF || idObj == idBldgC) {\n        s = Hashfv2 (37. * iqBlk);\n        f = step (fDayLt, 0.2 + 0.3 * Hashfv2 (47. * iqBlk));\n        col = mix (0.2 * col, vec3 (0.8 + 0.2 * s, 0.75 - 0.4 * s, 0.), f);\n      } else if (idObj == idCarBdy) col = mix (vec3 (0.1, 0.05, 0.), col, fDayLt);\n      else if (idObj == idTwrTop) col *= 1. - 0.8 * fDayLt;\n    }\n    if (spec >= 0.) col *= 0.1 + 0.9 * fDayLt;\n    fHaze = (flyMode > 0) ? clamp (8. * (dstHit \/ dstFar - 0.8), 0., 1.) :\n       clamp (4. * (dstHit \/ dstFar - 0.2), 0., 1.);\n    col = mix (col, sCol, fHaze * fHaze);\n  } else col = sCol;\n  return pow (clamp (col, 0., 1.), vec3 (0.4));\n}\n\nvec3 TrackPath (float t)\n{\n  vec3 p;\n  float ti[5], tLin, tCyc, pLen;\n  tLin = 1.;\n  tCyc = 4. * tLin;\n  ti[0] = 0.;\n  ti[1] = ti[0] + tLin;\n  ti[2] = ti[1] + tLin;\n  ti[3] = ti[2] + tLin;\n  ti[4] = ti[3] + tLin;\n  pLen = 4.;\n  p = vec3 (0.);\n  p.y = 0.3 + 2.5 * SmoothBump (0.3, 0.8, 0.07, mod (0.11 * t, 1.));\n  t = mod (t + scnCount * tLin, tCyc);\n  if (t < ti[1]) {\n    p.x = pLen;\n    p.z = - pLen + 2. * pLen * (t - ti[0]) \/ (ti[1] - ti[0]);\n  } else if (t < ti[2]) {\n    p.x =   pLen - 2. * pLen * (t - ti[1]) \/ (ti[2] - ti[1]);\n    p.z = pLen;\n  } else if (t < ti[3]) {\n    p.x = - pLen;\n    p.z =   pLen - 2. * pLen * (t - ti[2]) \/ (ti[3] - ti[2]);\n  } else if (t < ti[4]) {\n    p.x = - pLen + 2. * pLen * (t - ti[3]) \/ (ti[4] - ti[3]);\n    p.z = - pLen;\n  }\n  p.x *= flyDir;\n  p.x += (scnCount - 3.) * pLen;\n  return p;\n}\n\nvoid VuPM (float t)\n{\n  vec3 fpF, fpB, vel;\n  float a, ca, sa, dt;\n  dt = 0.05;\n  fpF = TrackPath (t + dt);\n  fpB = TrackPath (t - dt);\n  vuPos = 0.5 * (fpF + fpB);\n  vuPos.y = fpB.y;\n  vel = (fpF - fpB) \/ (2. * dt);\n  a = atan (vel.z, vel.x) - 0.5 * pi;\n  ca = cos (a);  sa = sin (a);\n  vuMat = mat3 (ca, 0., - sa, 0., 1., 0., sa, 0., ca);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac, tScene, cTime, cTimeI, t, tRep, sunAz, sunEl, asp;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy \/ canvas - 1.;\n  uv.x *= canvas.x \/ canvas.y;\n  tCur = iGlobalTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy \/ canvas - 0.5;\n  mPtr.x -= 0.08;\n  tRep = 40.;\n  scnCount = floor (tCur \/ (3. * tRep));\n  tScene = tCur - 3. * tRep * scnCount;\n  scnCount = mod (scnCount, 10.);\n  if (tScene < tRep) flyMode = 0;\n  else if (tScene < 2. * tRep) flyMode = 1;\n  else flyMode = 2;\n  flyDir = sign (mod (tCur, 6. * tRep) - 3. * tRep);\n  t = mod (0.013 * tCur + 0.2, 1.);\n  fDayLt = SmoothBump (0.2, 0.8, 0.05, t);\n  sunAz = 0.8 * pi * (2. * t - 1.);\n  sunEl = 0.97 * (1. - 0.7 * sin (abs (0.5 * sunAz)));\n  sunDir = vec3 (0., 0., - 1.);\n  sunDir.xz = Rot2D (sunDir.xz, sunAz);\n  sunDir.yz = Rot2D (sunDir.yz, sunEl);\n  cTime = 0.15 * tScene;\n  cTimeI = floor (cTime);\n  cDir = mod (cTimeI, 2.);\n  cTimeV = vec2 (floor (0.5 * cTimeI), cTime - cTimeI);\n  if (flyMode == 0) dstFar = 50.;\n  else dstFar = 70.;\n  if (flyMode == 0) {\n    az = 0.;\n    el = -0.05;\n    zmFac = 4.8;\n    if (mPtr.z > 0.) {\n      az -= 2. * pi * mPtr.x;\n      el = clamp (el - mPtr.y, -1.4, 0.3);\n    }\n  } else if (flyMode == 1) {\n    az = 0.;\n    el = 0.;\n    zmFac = 2.2;\n    if (mPtr.z > 0.) zmFac = clamp (zmFac + 3. * mPtr.y, 0.7, 4.);\n  } else if (flyMode == 2) {\n    az = 0.033 * tCur * flyDir;\n    t = SmoothBump (0.3, 0.8, 0.2, mod (0.025 * tCur, 1.));\n    el = 0.1 + 0.8 * t;\n    zmFac = 3.6 + 11. * t;\n  }\n  if (flyMode == 0) {\n    ro = vec3 (-0.03, 0.1, scnCount + cTimeV.x + ((cDir == 1.) ? cTimeV.y : 0.));\n  } else if (flyMode == 1) {\n    VuPM (0.1 * tCur);\n    ro = vuPos;\n  } else if (flyMode == 2) {\n    ori = vec2 (el, az);\n    ca = cos (ori);  sa = sin (ori);\n    vuMat = mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n       mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n    ro = vec3 (0., 1., -25.) * vuMat;\n    if (mPtr.z > 0.) {\n      az -= 0.5 * pi * mPtr.x;\n      el = clamp (el - 2. * mPtr.y, -0.1, 1.5);\n    }\n  }\n  if (flyMode == 0 || flyMode == 2) {\n    ori = vec2 (el, az);\n    ca = cos (ori);  sa = sin (ori);\n    vuMat = mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n       mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n  }\n  rd = normalize (vec3 (uv, zmFac)) * vuMat;\n  col = ShowScene (ro, rd);\n  asp = canvas.y \/ canvas.x;\n  t = step (50. * abs (mod (tCur \/ tRep + 0.5, 1.) - 0.5),\n     max (abs (uv.x * asp), abs (uv.y)) \/ max (asp, 1.));\n  col = mix (col, vec3 (0.1, 0.1, 0.2), t);\n  fragColor = vec4 (col, 1.);\n}\n","name":"","description":"","type":"image"}]}}