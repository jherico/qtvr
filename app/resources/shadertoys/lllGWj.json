{"Shader":{"ver":"0.1","info":{"id":"lllGWj","date":"1425412359","viewed":831,"name":"Alien magma","username":"mpcomplete","description":"Testing noise, fbm,and color rotation.","likes":5,"published":3,"flags":0,"tags":["noise","fbm","hsv"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"float time = iGlobalTime * 0.15;\n\n\/\/ http:\/\/lolengine.net\/blog\/2013\/07\/27\/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\/\/ hq texture noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\n\tvec2 rg1 = texture2D( iChannel0, (uv+ vec2(0.5,0.5))\/256.0, -100.0 ).yx;\n\tvec2 rg2 = texture2D( iChannel0, (uv+ vec2(1.5,0.5))\/256.0, -100.0 ).yx;\n\tvec2 rg3 = texture2D( iChannel0, (uv+ vec2(0.5,1.5))\/256.0, -100.0 ).yx;\n\tvec2 rg4 = texture2D( iChannel0, (uv+ vec2(1.5,1.5))\/256.0, -100.0 ).yx;\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\n\t\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\/\/x3\nvec3 noise3( in vec3 x)\n{\n\treturn vec3( noise(x+vec3(123.456,.567,.37)),\n\t\t\t\tnoise(x+vec3(.11,47.43,19.17)),\n\t\t\t\tnoise(x) );\n}\n\n\/\/ https:\/\/code.google.com\/p\/fractalt}erraingeneration\/wiki\/Fractional_Brownian_Motion\nvec3 fbm(in vec2 p)\n{\n    const float gain = 0.5;\n    const float lacunarity = 2.;\n\n    vec3 total = vec3(0);\n\tfloat amplitude = gain;\n\n\tfor (int i = 1; i < 7; i++) {\n\t\ttotal += noise3(vec3(p, time)) * amplitude;\n\t\tamplitude *= gain;\n\t\tp *= lacunarity;\n\t}\n\treturn total;\n}\n\nmat3 rotation(float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat3(oc * a.x * a.x + c,        oc * a.x * a.y - a.z * s,  oc * a.z * a.x + a.y * s,\n                oc * a.x * a.y + a.z * s,  oc * a.y * a.y + c,        oc * a.y * a.z - a.x * s,\n                oc * a.z * a.x - a.y * s,  oc * a.y * a.z + a.x * s,  oc * a.z * a.z + c);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy \/ iResolution.xy;\n\tp.x *= iResolution.x\/iResolution.y;\n\n    p.x = p.x*(1. + .2*sin(time*2.));\n    p.y = p.y*(1. + .2*sin(time*2.));\n    p += vec2(6.5, 6.5);\n\n    vec3 color = fbm(3.5*p);\n\n#if 0\n    color = mod(time + color*1.5, 1.);\n    color = hsv2rgb(vec3(color.x, .8, .8));\n#else\n    color = time*vec3(0.9, 0.7, 0.25) + color;\n\n    float c1 = color.x*3.;\n    float c2 = color.y*9.;\n    vec3 col1 = 0.5 + 0.5*sin(c1 + vec3(0.0,0.5,1.0));\n\tvec3 col2 = 0.5 + 0.5*sin(c2 + vec3(0.5,1.0,0.0));\n\tcolor = 2.0*pow(col1*col2,vec3(0.8));\n\n    vec3 axis = fbm(p*2.75);\n    color = rotation(.9*length(axis)*sin(8.*time), axis)*color;\n#endif\n\n    fragColor.xyz = color;\n}","name":"","description":"","type":"image"}]}}