{"Shader":{"ver":"0.1","info":{"id":"ltj3Ww","date":"1429631513","viewed":729,"name":"LRSK - Lame Raymarch Scene Kit","username":"citruslee","description":"I got fed up with the awkward math where positive direction from camera was a negative number, also juggling with operators and ugly one liners with millions of unite operators. So this framework is the result.","likes":1,"published":3,"flags":0,"tags":["basic3dframeworkformyownprojects"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/************************************************************************************************\n\n\tBy citrus, Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n    I got fed up with the awkward math where positive direction \n    from camera was a negative number, also juggling with operators \n    and ugly one liners with millions of unite operators. So this \n    framework is the result.\n\n\tAddendum: This is just an experiment to achieve some kind of easier scene construction\n\t\t\t  and I DO NOT TAKE RESPONSIBILITY for this shader. Use it freely tho, but it is\n\t\t\t  slow as hell and a very lame framework yet. Will update it over time. \n\n\t\t\t  Any help or insight is well appreciated!\n\n\t\t\t  \n     21\/04\/2015:\n     - published\n\n     22\/04\/2015:\n     - Camera on mouse move from on musk's shader \n\t   https:\/\/www.shadertoy.com\/view\/lds3RX - Spheres\/Plane\n\t \n\t - Basic scenegraph structures\n\n\t 23\/04\/2015:\n     - Based on iq's insight, I moved the shading from the \n\t   raymarch into the main function, now it should perform better\n\n\n************************************************************************************************\/\n\n\/\/The for loop loop count (heh)\n#define EVALCNT 40.0\n\/\/The constant when we hit the surface\n#define AEPSILON 0.01\n\/\/shiny!\n#define CORNFLOWERBLUE vec4(0.392157, 0.584314, 0.929412, 1.0);\n\n\/\/object type constants\n\/\/TODO: Write constants also for the shading types\n#define OBJ_SPHERE 1\n#define OBJ_BOX 2\n#define OBJ_CONE 3\n\n\/\/TODO!!!!!!!!!!!!!!: Object params should be added to this!!!\n\/\/TODO2: Rotations!\n\/\/TODO3: Scaling!\n\/\/TODO4: Operators! (Bend, displace)\n\/\/MAYBE-TODO: Texture ID-s\nstruct Object\n{\n    vec3 pos;\t\t\/\/the object position in 3D\n\tint type;\t\t\/\/the object type (e.g.: box, cone, blah, blah)\n    int material;\t\/\/the material used to render this object\n};\n\n\/\/this is just an unverified theory and a preparation for implementation\nstruct Leaf\n{\n\n    int command; \t\/\/union, substract, intersect, none...\n    Object object;\t\/\/the primitive to draw to\n};\n    \nstruct Trunk\n{\n    int isRootLeaf; \/\/0 if not and 1 if yes\n    int childCount;\t\/\/if 0, then it is a single object in the scenegraph\n    Leaf parent[10];\t\/\/the parent leaf in the hierarchy...on the first depth level should give the root\n    Leaf sibling[10];\t\/\/\"pointer\" to the next leaf on the same depth\n    Leaf child[10];\t\t\/\/child leaves are the sub-branches\n};\n    \nstruct Scenegraph\n{\n \tint objectCount;\n    int lightCount;\n    \n    Trunk root;\n};\n\n\/\/Yeah, I ripped these functions from iq...sorry but thanks :)\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)),0.0) + length(max(d, 0.0));\n}\n\nfloat sdCone(in vec3 p, in vec3 c)\n{\n    vec2 q = vec2(length(p.xz), p.y );\n#if 0\n\treturn max(max(dot(q, c.xy), p.y), -p.y - c.z );\n#else\n    float d1 = -p.y - c.z;\n    float d2 = max(dot(q, c.xy), p.y);\n    return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);\n#endif    \n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n\/\/This function is called on every object, getting the object type and rendering it to it's position.\n\/\/TODO: Fix the hardcoded stuff like object parameters\nfloat traceObject(vec3 pos, Object obj)\n{\n    if(obj.type == OBJ_SPHERE)\n\t{\n        return sdSphere(pos - obj.pos, 1.0);\n    }\n    else if(obj.type == OBJ_BOX)\n\t{\n        return sdBox(pos - obj.pos, vec3(1.0));\n    }\n    else if(obj.type == OBJ_CONE)\n\t{\n        return sdCone(pos - obj.pos, vec3(1.8, 1.6, 1.0)) * 0.5;\t\/\/without the multiplication\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\/\/the object looks pretty bugged\n    }\n    else\n    {\n     \treturn 0.0;   \n    }\n}\n\n#define OBJCNT 3\n\n\/\/Here is the whole scene setup via the Object struct\n\/\/Every object is then rendered by a for loop, but you must specify the max OBJCNT above\nvec2 scene(vec3 pos)\n{\n    Object object[OBJCNT];\n    object[0].pos = vec3(0.0, 0.0, 1.0);\n    object[0].type = OBJ_SPHERE;\n    object[0].material = 2;\n    \n    object[1].pos = vec3(-1.0, 1.0, 2.0);\n    object[1].type = OBJ_BOX;\n    object[1].material = 2;\n    \n    object[2].pos = vec3(2.0, 1.0, 2.0);\n    object[2].type = OBJ_CONE;\n    object[2].material = 2;\n    \n    vec2 result = vec2(0.0);\n    for(int i = 0; i < OBJCNT; i++)\n    {\n        if(i == 0)\n        {\n            result = vec2(traceObject(pos, object[i]), object[i].material);   \n        }\n    \telse\n    \t{\n\t\t\tresult = opU(vec2(traceObject(pos, object[i]), object[i].material), result);\n    \t}\n    }\n \treturn result;   \n}\n\nvec3 sceneNormal(vec3 pos)\n{\n\tfloat distancePoint = scene(pos).x;\n    float aepsilon = 0.01;\n    float x = scene(pos + vec3(AEPSILON, 0.0, 0.0)).x;\n    float y = scene(pos + vec3(0.0, AEPSILON, 0.0)).x;\n    float z = scene(pos + vec3(0.0, 0.0, AEPSILON)).x;\n\treturn normalize(vec3(x - distancePoint, y - distancePoint, z -distancePoint));\n}\n\n\/\/ brdf\nvec3 brdf(vec3 normal, vec3 lightDist, vec3 viewDir, float roughness, vec3 diffuseReflectance, vec3 specularReflectance, vec3 lightIntensity) \n{\n\tvec3 halfvec = normalize(lightDist + viewDir );\n\t\n\tfloat dotNH = max(dot(normal, halfvec), 0.0);\n\tfloat dotNV = max(dot(normal, viewDir), 0.0);\n\tfloat dotNL = max(dot(normal, lightDist), 0.0);\n\tfloat dotH   = max(dot(halfvec, viewDir), 0.0);\n\t\n\tfloat g = 2.0 * dotNH \/ dotH;\n\tfloat G = min(min(dotNV, dotNL) * g, 1.0);\n\n\tfloat squareNH   = dotNH * dotNH;\n\tfloat squaredNHM = squareNH * (roughness * roughness);\n\tfloat D = exp((squareNH - 1.0) \/ squaredNHM) \/ (squareNH * squaredNHM);\n\t\n\tvec3 fresnelSpecular = specularReflectance + (1.0  - specularReflectance) * pow(1.0 - dotH  , 5.0);\n\tvec3 fresnelDiffuse = specularReflectance + (1.0  - specularReflectance) * pow(1.0 - dotNL, 5.0);\n\t\n\tvec3 brdfSpecular = fresnelSpecular * D * G \/ ( dotNV * dotNL * 4.0 );\n\tvec3 brdfDiffuse = diffuseReflectance * (1.0 - fresnelDiffuse);\n\treturn (brdfSpecular + brdfDiffuse) * lightIntensity * dotNL;\t\n}\n\n\/\/a lame, I think phong lightning, will be modified\nvec4 phong(vec3 pos)\n{\n\tvec3 normals = sceneNormal(pos);\n        \n    vec3 dirToLight = vec3(-1.0, 1.0, 0.0);\n\tvec4 lightIntensity = vec4(1.0, 1.0, 1.0, 1.0);\n    vec3 normCamSpace = normalize(normals);\n    \n    float cosAngIncidence = dot(normCamSpace, dirToLight);\n    cosAngIncidence = clamp(cosAngIncidence, 0.0, 1.0);\n    \n    return lightIntensity * cosAngIncidence;\n}\n\n\/\/Remarks: vec.x component will be used for normals\n\/\/\t\t   vec.y component is the material in use with the object\n\/\/\n\/\/\t\t\tI think, maybe vec.z could be used for texture selection\nvec4 shade(vec2 shadinginfo, vec3 pos, vec3 eye)\n{\n\tif(shadinginfo.y == 0.0)\n    {\n     \treturn phong(pos);\t\/\/flat shade   \n    }\n    else if(shadinginfo.y == 1.0)\n    {\n     \treturn phong(pos);\t\/\/non-flat shade   \n    }\n    else if(shadinginfo.y == 2.0)\n    {\n     \treturn phong(pos);\t\/\/non-non-flat shade   \n    }\n    else\n    {\n     \treturn CORNFLOWERBLUE;   \/\/whatever\n    }\n}\n\nvec2 raymarch(inout vec3 pos, inout vec3 dir)\n{\n    vec2 result;\t\/\/the scene is contained in this variable\n    \n    for(float i = 0.0; i < EVALCNT; i++)\n    {\n        result = scene(pos);\n        pos += dir * result.x;\n        if(result.x < AEPSILON)\n        {\n            return result;\n        }\n    }\n \treturn vec2(99999.0, 99999.0);   \/\/here should be some sky color computations, but now, I cannot do such\n    \t\t\t\t\t\t \/\/thing with my n00b ass...nonetheless, cornflower blue rulz\n}\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0,+1.0);\n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy - 0.5;\n\tuv.x *= iResolution.x \/ iResolution.y; \/\/fix aspect ratio\n\tvec3 mouse = vec3(iMouse.xy \/ iResolution.xy - 0.5, iMouse.z - .5);\n\t\n\tfloat t = iGlobalTime * .5 * 0.0 + 30.0;\n\tmouse += vec3(sin(t) * .05, sin(t) * .01, .0);\n\t\n\tfloat offs0 = 5.0;\n\tfloat offs1 = 1.0;\n\t\n\t\/\/setup the camera\n\tvec3 p = vec3(0, 0.0, -1.0);\n\tp = rotate_x(p, mouse.y * 9.0 + offs0);\n\tp = rotate_y(p, mouse.x * 9.0 + offs1);\n\tp *= (abs(p.y * 2.0 + 1.0) + 1.0);\n\tvec3 d = vec3(uv, 1.0);\n\td.z -= length(d) * .6; \/\/lens distort\n\td = normalize(d);\n\td = rotate_x(d, mouse.y * 9.0 + offs0);\n\td = rotate_y(d, mouse.x*9.0 + offs1);\n   \tvec2 result = raymarch(p, d);\n    \n    if(result.y == 99999.0)\n    {\n        fragColor = CORNFLOWERBLUE;\n    }\n    else\n    {\n\t\tfragColor = shade(result, p, d);\n    }\n}","name":"","description":"","type":"image"}]}}