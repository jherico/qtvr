{"Shader":{"ver":"0.1","info":{"id":"Mll3W2","date":"1425690278","viewed":768,"name":"@party 2015 invite","username":"jimbo00000","description":"<a href=\"http:\/\/atparty-demoscene.net\/\" class=\"regular\" target=\"_blank\">http:\/\/atparty-demoscene.net\/<\/a> Come and check out the North American Demoscene in Boston on June 19-22, 2015 at MIT's Stata center. Featuring Brian Peiris of <a href=\"https:\/\/github.com\/brianpeiris\/RiftSketch\"  class=\"regular\" target=\"_blank\">RiftSketch<\/a> fame!","likes":0,"published":3,"flags":0,"tags":["demoscene","party","atparty","invite","boston"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Come attend @party 2015 June 19-22 in Boston at MIT!\n\/\/ Start the party manually by uncommenting below if you don't want to wait.\n\/\/#define PARTY_ON\n\n\/\/ @party will take place June 19-22 2015 6PM\nvec4 atPartyDate = vec4(2015., (6.-1.), 19., 18.*60.*60.);\n\nfloat t = 3.*iGlobalTime;\nfloat party = 0.;\n\n\/\/ math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI \/ 180.0;\nmat3 rotationX(float t) {\n    float ct=cos(t), st=sin(t);\n    return mat3(1., 0.,  0.,  0., ct, -st,  0., st,  ct);}\nmat3 rotationY(float t) {\n    float ct=cos(t), st=sin(t);\n    return mat3(ct, 0., st,  0., 1., 0.,  -st, 0., ct);}\nmat3 rotationZ(float t) {\n    float ct=cos(t), st=sin(t);\n    return mat3(ct, -st, 0.,  st, ct, 0.,  0., 0., 1.);}\nmat3 rotationXY(vec2 angle) {\n\tvec2 c = cos(angle);\n\tvec2 s = sin(angle);\n\treturn mat3(\n\t\tc.y    ,  0.0, -s.y,\n\t\ts.y*s.x,  c.x,  c.y*s.x,\n\t\ts.y*c.x, -s.x,  c.y*c.x);\n}\n\nmat3 getMouseRotMtx()\n{\n    float f= .05;\n    vec2 a = .5*vec2(.3,.2);\n    vec2 o = vec2(.2,-.2);\n    return rotationXY(-o+a*vec2(sin(f*t), cos(f*t)));\n    \n\t\/\/ Use shadertoy mouse uniform\n    vec4 m = iMouse;\n    vec2 mm = m.xy - abs(m.zw);\n    vec2 rv = 0.01*mm;\n\tmat3 rotmtx = rotationY(rv.x) * rotationX(-rv.y);\n    return rotmtx;\n}\n\n\n\/\/ libiq\n\n\/\/ exponential smooth min (k = 32);\nfloat smine( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )\/k;\n}\n\n\/\/ polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)\/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/ DISTANCE FUNCTIONS\n\/\/\n\/\/ Primitives from http:\/\/www.iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\n\/\/\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\nfloat sdPlane( vec3 p, vec4 n )\n{\n    \/\/ n must be normalized\n    return dot(p,n.xyz) + n.w;\n}\n\n\/\/\n\/\/ Composites\n\/\/\nfloat rollprism(vec3 pos)\n{\n    return max(\n        udRoundBox(pos, vec3(2.,1.4,5.), 3.5),\n        -sdPlane(pos, vec4(normalize(vec3(-1.,0.,0.)),3.))\n        );\n}\n\nfloat rollprism2(vec3 pos)\n{\n    return max(\n        udRoundBox(pos, vec3(2.,2.,5.), 7.5),\n        -udRoundBox(pos, vec3(2.,2.,15.), 5.5)\n        );\n}\n\nfloat atsign(vec3 pos)\n{\n    float d = min(\n        rollprism(pos-vec3(1.,0.,0.)),\n        rollprism2(pos)\n        );\n    d = smin(d,\n             sdBox(pos-vec3(4.2,-3.5,0.), vec3(3.5,1.4,5.))\n            ,1.);    \n    d = max(d, -sdBox(pos-vec3(6.,-8.4,0.), vec3(6.,3.5,12.))); \/\/ chop horiz\n    \n    \/\/ chop off front and back\n    float w = 0.;\/\/1.+sin(t);\n    d = max(d, -sdPlane(pos                 , vec4(vec3(0.,0.,-1.),0.)));\n    d = max(d, -sdPlane(pos-vec3(0.,0.,-1.5-w), vec4(vec3(0.,0.,1.),0.)));\n    return d;\n}\n\nfloat attail(vec3 pos)\n{\n    float s = -0.+0.5*pow((1.+0.1*pos.x),1.7);\n    return sdBox(pos, vec3(5.,0.8+s,.6+s));\n}\n\nfloat at(vec3 pos)\n{\n    \/\/ dance\n    float p = 0.02*party;\n    pos = rotationY(p*pos.y*sin(3.*t)) * pos;\n    pos = rotationX(p*pos.y*sin(5.*t)) * pos;\n    \n    return min(\n        atsign(pos),\n        attail(\n            rotationY(-.03*(pos.x+7.)) *\n            (pos-vec3(3.,-8.5,.0)))\n        );\n}\n\nfloat DE_atlogo( vec3 pos )\n{\n\tmat3 rotmtx = getMouseRotMtx();\n\tpos = rotmtx * pos;\n\tfloat d2 = 9999.;\n\treturn min(d2, at(pos));\n}\n\n\n\/\/\n\/\/ lighting and shading\n\/\/\nvec3 shading( vec3 v, vec3 n, vec3 eye ) {\n\tfloat shininess = 16.0;\n\tvec3 ev = normalize( v - eye );\n\tvec3 ref_ev = reflect( ev, n );\t\n\tvec3 final = vec3( 0.0 );\n\t\/\/ disco light\n\t{\n\t\tvec3 light_pos   = vec3( 1.0, 10.0, 30.0 );\n        float p = party;\n\t\tvec3 light_color = vec3(p*sin(3.*t), p*sin(3.3*t), p*sin(4.*t));\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = 0.;\/\/max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * ( diffuse + specular ); \n\t}\n\t\n\t\/\/ white light\n\t{\n\t\tvec3 light_pos   = vec3( 10.0, 20.0, -10.0 );\n\t\t\/\/vec3 light_pos   = vec3( -20.0, -20.0, -20.0 );\n\t\tvec3 light_color = vec3( 1.);\/\/0.3, 0.7, 1.0 );\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n        shininess = 8.;\n\t\tfloat diffuse  = 0.;\/\/max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * ( diffuse + specular ); \n\t}\n\n\treturn final;\n}\n\n\/\/ get gradient in the world\nvec3 gradient( vec3 pos ) {\n\tconst float grad_step = 0.31;\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tDE_atlogo( pos + dx ) - DE_atlogo( pos - dx ),\n\t\t\tDE_atlogo( pos + dy ) - DE_atlogo( pos - dy ),\n\t\t\tDE_atlogo( pos + dz ) - DE_atlogo( pos - dz )\t\n\t\t)\n\t);\n}\n\n\/\/ ray marching\nfloat ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\tconst int max_iterations = 255;\n\tconst float stop_threshold = 0.001;\n\tfloat depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n\t\tfloat dist = DE_atlogo( origin + dir * depth );\n\t\tif ( dist < stop_threshold ) {\n\t\t\treturn depth;\n\t\t}\n\t\tdepth += dist;\n\t\tif ( depth >= end) {\n\t\t\treturn end;\n\t\t}\n\t}\n\treturn end;\n}\n\n\/\/ get ray direction from pixel position\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n\nvec3 getSceneColor_atlogo( in vec3 ro, in vec3 rd )\n{\n\tconst float clip_far = 100.0;\n\tfloat depth = ray_marching( ro, rd, -10.0, clip_far );\n\tif ( depth >= clip_far ) {\n        return vec3(1.);\n\t}\n\tvec3 pos = ro + rd * depth;\n\tvec3 n = gradient( pos );\n\treturn shading( pos, n, ro );\n}\n\n\n\n\/\/\n\/\/ The cube\n\/\/\nmat3 getCubeMtx()\n{\n    return rotationY(.8+party*pow(abs(sin(PI*2.*iGlobalTime)),5.)) * rotationX(.3);\n}\n\nfloat DE_cube( vec3 pos )\n{\n\tpos = getCubeMtx() * pos;\n\treturn udRoundBox(pos, vec3(1.5), .15);\n}\n\nvec3 shade_cube(vec3 v, vec3 n, vec3 ntx, vec3 eye) {\n\tvec3 ev = normalize(v - eye);\n\tvec3 final = vec3(0.);\n    vec3 light_pos = vec3(-10.,20.,40.);\n    vec3 vl = normalize(light_pos - v);\n    float diffuse = max(0.0, dot( vl, n ));\n    final += 1.3 * diffuse; \n\t\/\/ transform normals with the cube to find flat faces\/edges\n\tfloat px = abs(dot(ntx,vec3(1.,0.,0.)));\n\tfloat py = abs(dot(ntx,vec3(0.,1.,0.)));\n\tfloat pz = abs(dot(ntx,vec3(0.,0.,1.)));\n    float p = max(px,max(py,pz));\n    final *= smoothstep(0.9,1.,length(p));\n    return final;\n}\n\nvec3 grad_cube(vec3 pos) {\n\tconst float gs = 0.02;\n\tconst vec3 dx = vec3(gs, 0., 0.);\n\tconst vec3 dy = vec3(0., gs, 0.);\n\tconst vec3 dz = vec3(0., 0., gs);\n\treturn normalize( vec3(\n\t\t\tDE_cube(pos + dx) - DE_cube(pos - dx),\n\t\t\tDE_cube(pos + dy) - DE_cube(pos - dy),\n\t\t\tDE_cube(pos + dz) - DE_cube(pos - dz)\t\n\t\t));\n}\n\nfloat raymarch_cube(vec3 origin, vec3 dir, float start, float end) {\n\tconst int max_iterations = 64;\n\tconst float stop_threshold = 0.01;\n\tfloat depth = start;\n\tfor (int i=0; i<max_iterations; i++) {\n\t\tfloat dist = DE_cube(origin + dir*depth);\n\t\tif (dist < stop_threshold) return depth;\n\t\tdepth += dist;\n\t\tif (depth >= end) return end;\n\t}\n\treturn end;\n}\n\nvec3 getCubeColor(in vec3 ro, in vec3 rd) {\n\tconst float clip_far = 100.0;\n\tfloat depth = raymarch_cube(ro, rd, 0., clip_far);\n\tif ( depth >= clip_far )\n\t\treturn getSceneColor_atlogo(ro,rd);\n    vec3 pos = ro + rd * depth;\n\tvec3 ne = grad_cube(pos);\n    vec3 ntx = getCubeMtx() * ne;\n\treturn shade_cube(pos, ne, ntx, ro);\n}\n\n\n\/\/ ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n\/\/ Creative Commons CC0 1.0 Universal (CC-0) \n\/\/ https:\/\/www.shadertoy.com\/view\/4sBSWW\n\nfloat DigitBin(const in int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue(const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n    vec2 vStringCharCoords = (gl_FragCoord.xy - vPixelCoords) \/ vFontSize;\n    if ((vStringCharCoords.y < 0.0) || (vStringCharCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) \/ log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCharCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n\t\t\t\tif(fDigitIndex < 0.0) fDigitIndex += 1.0;\n\t\t\t\tfloat fDigitValue = (abs(fValue \/ (pow(10.0, fDigitIndex))));\n                float kFix = 0.0001;\n                fCharBin = DigitBin(int(floor(mod(kFix+fDigitValue, 10.0))));\n\t\t\t}\t\t\n\t\t}\n\t}\n    return floor(mod((fCharBin \/ pow(2.0, floor(fract(vStringCharCoords.x) * 4.0) + (floor(vStringCharCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n\/\/ ---- 8< -------- 8< -------- 8< -------- 8< ----\n\n\/\/ NOT general, only works until June\nvec4 getCountdown(vec4 then, vec4 now)\n{\n    int md[6];md[1]=31;md[2]=28;md[3]=31;md[4]=30;md[5]=31;\n    int totalDays = int(then.z);\n    if (int(then.y) == int(now.y))\n    {\n        totalDays -= int(now.z);\n    }\n    else\n    {\n        for (int i=1; i<6; ++i)\n        {\n            if (i >= int(now.y+1.)) totalDays += md[i];\n        }\n        totalDays -= int(now.z);\n    }\n    if (now.w > then.w) totalDays -=1;\n    \n    float secs = now.w;\n    float ds = then.w - now.w;\n    float hours = mod(ds \/ (60.0 * 60.0), 24.0);\n    float minutes = mod(ds \/ 60.0, 60.0);\n    float seconds = mod(ds, 60.0);\n    return vec4(float(totalDays), float(hours), minutes, seconds);\n}\n\nvec3 getTextColor(vec3 bgcol)\n{    \n    vec4 cd = getCountdown(atPartyDate, iDate);\n\tvec2 vFontSize = vec2(2.*8.0, 2.*15.0); \/\/ Multiples of 4x5 work best\n    vec2 loc = vec2(-10., 10.);\n    vec3 c = vec3(0.);\n\tvec3 fc = bgcol;\n    fc = mix(fc, c, PrintValue(loc+vec2(0.,0.), vFontSize, cd.x, 4.0, 0.0));\n    fc = mix(fc, c, PrintValue(loc+vec2(50.,0.), vFontSize, cd.y, 4.0, 0.0));\n    fc = mix(fc, c, PrintValue(loc+vec2(100.,0.), vFontSize, cd.z, 4.0, 0.0));\n    fc = mix(fc, c, PrintValue(loc+vec2(150.,0.), vFontSize, cd.w, 4.0, 0.0));\n    return fc;\n}\n\nvec3 getSceneColor(in vec3 ro, in vec3 rd)\n{\n    vec3 bgcol = getCubeColor(ro,rd);\n\treturn getTextColor(bgcol);\n}\n\n\n#ifndef RIFTRAY\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 testDate = iDate;\n    vec4 cd = getCountdown(atPartyDate, testDate);\n    float daysleft = cd.x;\n    party = 1.-clamp(daysleft\/14.,0.,1.);\n    \n#ifdef PARTY_ON\n\tparty = 1.;\n#endif\n\n\t\/\/ default ray dir\/origin\n\tvec3 dir = ray_dir( 45.0, iResolution.xy, fragCoord.xy );\n\tvec3 eye = vec3( 0.0, 0.0, 30.0 );\t\n\tfragColor = vec4( getSceneColor( eye, dir ), 1.0 );\n}\n#endif\n","name":"","description":"","type":"image"},{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ This code ripped entirely from https:\/\/www.shadertoy.com\/view\/MdfXW2\n\/\/ Start the party manually by uncommenting below if you don't want to wait.\n\/\/#define PARTY_ON\n\n\/\/ @party will take place June 19-22 2015 6PM\nvec4 atPartyDate = vec4(2015., (6.-1.), 19., 18.*60.*60.);\n\n#define PI 3.14159265358979323846\n#define TAU PI*2.\n\n#define C  32.703\n#define CS 34.648\n#define D  36.708\n#define DS 38.891\n#define E  41.203\n#define F  43.654\n#define FS 46.249\n#define G  48.999\n#define GS 51.913\n#define A  55.0\n#define AS 58.270\n#define B  61.735\n\n#define BPM 120.\n\nfloat noise( float x ){\n    return fract(sin(1371.1*x)*43758.5453);\n}\n\n\/\/3 input arpeggiator, with smoothing\nfloat arp(float a, float b, float c, float t, float smooth)\n{\t\n\tfloat ra = mix(0., a, smoothstep(0.333-smooth, .333+smooth, sin(t*TAU)));\n\tfloat rb = mix(0., b, smoothstep(0.333-smooth, .333+smooth, sin(t*TAU-.333*TAU)));\n\tfloat rc = mix(0., c, smoothstep(0.333-smooth, .333+smooth, sin(t*TAU-.666*TAU)));\n\treturn ra+rb+rc;\n}\n \n\/* Input:\n\tgate = how long the note is on [-1...1]\n\tsmooth = symmetric attack\/release smoothing (a real ADSR would be better)\n    ofst = time offset, [-1...1] 1 is one period\n*\/\nfloat seq(float t, float gate, float smooth, float ofst)\n{\n\treturn smoothstep( gate-smooth, gate+smooth,\n                      cos( (t*PI*BPM\/120.) - ofst*TAU - PI*0.5 + gate ) );\n}\n\n\/\/same idea but with an AR envelope\nfloat seqAR(float t, float gate, float atk, float rel, float ofst)\n{\n    float p = ((t*PI*BPM\/120.)-ofst*TAU-PI*0.5+gate );\n    float tp = fract(p\/PI*.5);\n    \n    \/\/The envelopes have to be scaled based on the gate length\n    gate = clamp(gate,-1.,1.);\n    float scl = (1.-abs(gate));\n    atk *= scl;\n    rel *= scl;\n    \n    \/\/Attack envelope\n\tif (tp > 0.5)\n\t\treturn smoothstep( gate-atk, gate+atk, cos(p));\n    \/\/Release envelope\n\telse\n\t\treturn smoothstep( gate-rel, gate+rel, cos(p));\n}\n\n\/\/-------------------------------------------------------------------\n\/\/---------------------------Instruments-----------------------------\n\/\/-------------------------------------------------------------------\n\n\/\/Basic waveforms with note and octave input\nfloat sn(float t, float note, float octave)\n{\n\treturn sin(t*note*exp2(octave)*PI);\n}\n\nfloat saw(float t, float note, float octave)\n{\n\treturn fract(t*note*exp2(octave-1.))-0.5;\n}\n\nfloat tri(float t, float note, float octave)\n{\n\treturn (abs(fract(t*note*exp2(octave-1.))-0.5)*2.-0.5)*2.;\n}\n\nfloat sqr(float t, float note, float octave)\n{\n\treturn step(fract(t*note*exp2(octave-1.)), 0.5)-0.5;\n}\n\n\/\/-------------------------------------------------------------------\n\/\/----------------------------Mixing---------------------------------\n\/\/-------------------------------------------------------------------\n\n\/\/Simple mixing function with balance control  (balance range 0..1)\nvec2 mixb(float x, float bal)\n{\n\tbal = clamp(bal,0.,1.);\n\treturn vec2(x * bal, x*(1.-bal));\n}\n\n\nfloat bassline(float t)\n{\n\tfloat v = 0.;\t\n    float tw = -.01;\n    v += sqr(t,C,2.)\n        * seq(t*8., -0.0, 0., 0.05) \/\/ eigth notes\n        * seq(t*.25, .75, 0., tw); \/\/ 1 measure(1st\/4)\n    v += sqr(t,DS,2.)\n        * seq(t*8., -0.0, 0., 0.05)\n        * seq(t*.25, .75, 0., .25+tw); \/\/ 1 measure(2nd\/4)\n    v += sqr(t,AS,1.)\n        * seq(t*8., -0.0, 0., 0.05)\n        * seq(t*.25, .75, 0., .5+tw); \/\/ 1 measure(3nd\/4)\n    v += sqr(t,F,2.)\n        * seq(t*8., -0.0, 0., 0.05)\n        * seq(t*.25, .75, 0., .75+tw); \/\/ 1 measure(4th\/4)\n    return v;\n}\n\n\/\/ NOT general, only works until June\nvec4 getCountdown(vec4 then, vec4 now)\n{\n    int md[6];md[1]=31;md[2]=28;md[3]=31;md[4]=30;md[5]=31;\n    int totalDays = int(then.z);\n    if (int(then.y) == int(now.y))\n    {\n        totalDays -= int(now.z);\n    }\n    else\n    {\n        for (int i=1; i<6; ++i)\n        {\n            if (i >= int(now.y+1.)) totalDays += md[i];\n        }\n        totalDays -= int(now.z);\n    }\n    if (now.w > then.w) totalDays -=1;\n    \n    float secs = now.w;\n    float ds = then.w - now.w;\n    float hours = mod(ds \/ (60.0 * 60.0), 24.0);\n    float minutes = mod(ds \/ 60.0, 60.0);\n    float seconds = mod(ds, 60.0);\n    return vec4(float(totalDays), float(hours), minutes, seconds);\n}\n\nvec2 mainSound(float time)\n{\n\tfloat t = time;\n    float party = 0.;\n    vec4 testDate = iDate;\n    vec4 cd = getCountdown(atPartyDate, testDate);\n    float daysleft = cd.x;\n    party = 1.-clamp(daysleft\/14.,0.,1.);\n    \n#ifdef PARTY_ON\n    party = 1.;\n#endif\n    \/\/the AR envelope version of the sequencer can be used for basic \"drums\"\n    \n    \/\/kick: low frequency sin with sharp attack and slow release\n    \/\/in this care i'm also modulating the frequency for extra oomph\n    float frq = seqAR(t*4.,.9,1.,1.,0.)*0.05;\n    float v1 = sn(t+frq,A,1.)*seqAR(t*4.,.9,.005,1.,0.);\n    \n    \/\/ snare on offbeats\n    v1 += noise(t)*seqAR(1.+t*2., .94, .0001, 0.1, -.02)*0.5;\n\tfloat v2 = bassline(t);\n    \n    \/\/some notes for the arp\n    float nA = sqr(t,A,4.);\n    float nAS = sqr(t,AS,4.);\n    float nB = sqr(t,B,4.);\n    float nC = sqr(t,C,4.);\n    float nD = sqr(t,D,4.);\n    float nDS = sqr(t,DS,4.);\n    float nE = sqr(t,E,4.);\n    float nF = sqr(t,F,4.);\n    float nFs = sqr(t,FS,4.);\n    float nG = sqr(t,G,4.);\n    float nA2 = sqr(t,A,5.);\n    float nAS2 = sqr(t,AS,5.);\n    float nB2 = sqr(t,B,4.);\n    float nC2 = sqr(t,C,5.);\n    float nD2 = sqr(t,D,5.);\n    \n    float arpspeed = t*8.;\/\/16.;\n    float x = t*.125*.25*PI;\n    float cyc = sign(sin(x)) -sign(cos(2.*x));\n    arpspeed = t*mix(4., 8., .5+.5*cyc);\n    float arpgate = 0.5;\n    float ACE = arp(nC,nE,nC2, arpspeed, arpgate);\n    float ABE = arp(nDS,nG,nC2, arpspeed, arpgate);\n    float arp7 = arp(nG,nF,nAS, arpspeed, arpgate);\n    float asus = arp(nA,nDS,nAS, arpspeed, arpgate);\n    float ares = arp(nAS,nD,nD2, arpspeed, arpgate);\n    \n    \/\/some patterns with those arps\n    float t12 = t\/2.;\n    const float gat = 0.7;\n    const float sm = 0.05;\n    float pat1 = 0.;\n    pat1 += ACE*seq(t*.25, gat, sm, 0.\/4.);\n    pat1 += ABE*seq(t*.25, gat, sm, 1.\/4.);\n    pat1 += arp7*seq(t*.25, gat, sm, 2.\/4.);\n    pat1 += asus*seq(t*.5, gat, sm, 4.\/8.)*seq(t*.25, gat, sm, 3.\/4.);\n    pat1 += ares*seq(t*.5, gat, sm, 6.\/8.)*seq(t*.25, gat, sm, 3.\/4.);\n    float v3 = pat1;\n    \n\t\/\/Mixing\n\tvec2 v = vec2(0.);\n    if (party > .1)\n    \tv += mixb(v1*1.5,0.5);\n    if (party > .5)\n\t\tv += mixb(v2*0.25,0.4);\n    if (party > .8)\n\t\tv += mixb(v3*0.25,0.3);\n\treturn v;\n}\n","name":"","description":"","type":"sound"}]}}