{"Shader":{"ver":"0.1","info":{"id":"MlSXRG","date":"1444506272","viewed":566,"name":"Jungle Fractal II","username":"gtoledo3","description":"A progression of my earlier \"Altered Julia Jungle\" post. It seemed different enough in style to merit a separate post.","likes":5,"published":3,"flags":0,"tags":["julia","jungle"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"float depthCull=.1;\nfloat time=iGlobalTime;\nfloat zoom=2.;\nfloat bailout=12.;\nfloat X=-.7;\nfloat Y=.3;\nvec2 offset=vec2(0.,.4);\nconst int iterations=16;\n\/\/jungle fractal II, by George Toledo, 2015.\n\n\/\/ Cellular noise (\"Worley noise\") in 2D in GLSL.\n\/\/ Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n\/\/ This code is released under the conditions of the MIT license.\n\/\/ See LICENSE file for details, located in ZIP file here:\n\/\/ http:\/\/webstaff.itn.liu.se\/~stegu\/GLSL-cellular\/\n\n\/\/ Permutation polynomial: (34x^2 + x) mod 289\nvec3 permute(vec3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\n\/\/ Cellular noise, returning F1 and F2 in a vec2.\n\/\/ Standard 3x3 search window for good F1 and F2 values\nvec2 cellular(vec2 P) {\n#define K 0.142857142857 \/\/ 1\/7\n#define Ko 0.428571428571 \/\/ 3\/7\n#define jitter 1.0 \/\/ Less gives more regular pattern\n\tvec2 Pi = mod(floor(P), 289.0);\n \tvec2 Pf = fract(P);\n\tvec3 oi = vec3(-1.0, 0.0, 1.0);\n\tvec3 of = vec3(-0.5, 0.5, 1.5);\n\tvec3 px = permute(Pi.x + oi);\n\tvec3 p = permute(px.x + Pi.y + oi); \/\/ p11, p12, p13\n\tvec3 ox = fract(p*K) - Ko;\n\tvec3 oy = mod(floor(p*K),7.0)*K - Ko;\n\tvec3 dx = Pf.x + 0.5 + jitter*ox;\n\tvec3 dy = Pf.y - of + jitter*oy;\n\tvec3 d1 = dx * dx + dy * dy; \/\/ d11, d12 and d13, squared\n\tp = permute(px.y + Pi.y + oi); \/\/ p21, p22, p23\n\tox = fract(p*K) - Ko;\n\toy = mod(floor(p*K),7.0)*K - Ko;\n\tdx = Pf.x - 0.5 + jitter*ox;\n\tdy = Pf.y - of + jitter*oy;\n\tvec3 d2 = dx * dx + dy * dy; \/\/ d21, d22 and d23, squared\n\tp = permute(px.z + Pi.y + oi); \/\/ p31, p32, p33\n\tox = fract(p*K) - Ko;\n\toy = mod(floor(p*K),7.0)*K - Ko;\n\tdx = Pf.x - 1.5 + jitter*ox;\n\tdy = Pf.y - of + jitter*oy;\n\tvec3 d3 = dx * dx + dy * dy; \/\/ d31, d32 and d33, squared\n\t\/\/ Sort out the two smallest distances (F1, F2)\n\tvec3 d1a = min(d1, d2);\n\td2 = max(d1, d2); \/\/ Swap to keep candidates for F2\n\td2 = min(d2, d3); \/\/ neither F1 nor F2 are now in d3\n\td1 = min(d1a, d2); \/\/ F1 is now in d1\n\td2 = max(d1a, d2); \/\/ Swap to keep candidates for F2\n\td1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; \/\/ Swap if smaller\n\td1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; \/\/ F1 is in d1.x\n\td1.yz = min(d1.yz, d2.yz); \/\/ F2 is now not in d2.yz\n\td1.y = min(d1.y, d1.z); \/\/ nor in  d1.z\n\td1.y = min(d1.y, d2.x); \/\/ F2 is in d1.y, we're done.\n\treturn sqrt(d1.xy);\n}\n\nvec2 cmult(vec2 a, vec2 b)\n{\n\tvec2 p;\n\tp[0]=a[0]*b[0]-a[1]*b[1];\n\tp[1]=a[0]*b[1]+a[1]*b[0];\n\treturn p;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 offset=vec2(offset.x+sin(time*.1)*.1,offset.y+cos(time*.1)*.1);\n\tvec2 position = (gl_FragCoord.xy\/iResolution.x) - offset;\n\t\n\tposition = position * (zoom+sin(time*.1)*.2);\n\tvec2 mouse=vec2(X+sin(time)*.01,Y+cos(time)*.02);\n\tvec2 c, c0, d;\n\tfloat v;\n\t\n\tc = vec2(position);\n\tc0 = mouse;\n\tc +=sin(time+cellular(c )*.1)*.01;\n\tvec2 f = position.xy;\n\tfor(int i=0; i<iterations; i++) {\n\t\td = cmult(c, c);\n\t\tc = d + c0;\n\t\tv = sqrt((c.x*c.x)) + (c.y*c.y) \/ sin(length(c.x )*4.);\n\n\t\tif (v > bailout) break;\n\t}\n\tfloat l=sin(( c.y*2.)*.23);\n\tc +=cellular( c*23.);\n\t\/\/l +=sin(c.y *1.2)*.5;\n\t\/\/l +=sin(c.y *.2)*.1;\n\tc.x+=sin(c.y*2.);\n\tc.y+=sin(c.x*20.)*.1;\n\tc.x+=sin(c.y*3.);\n\tc.y+=sin(c.x*5.);\n\t\n\tfloat rand = mod(fract(sin(dot(2.5*gl_FragCoord.xy\/iResolution.xy, vec2(12.9898,100.233))) * 43758.5453), .7);\n\tfragColor=vec4(0.);\n\tif(v>depthCull*100.){\n\n\tfragColor = vec4(vec3(sin(c.x*l*10.)*.6,length(-1.5-sin(-c*.6))*.17,sin(c.y*l)*.5)*(smoothstep(d.x,.1,.7)),.3);}\n\t\n\telse if(v<depthCull*100. && v>depthCull*.1 ){\n\tc.x=c.x+time*1.1;\n\tv +=sin(c.x*1.1)*.1;\n\tv +=sin(c.y*2.3)*.1;\n\tv +=sin(c.x*3.5)*.1;\n\tv +=sin(c.y*4.)*.1;\n\tv +=sin(c.y*6.)*.1;\n\tv +=sin(c.x*5.)*.1;\n\tv +=sin(c.x*10.)*.1;\n\tv +=sin(c.x*128.)*.01;\n\tv +=cellular( c ).x;\n\n\tv=max(0.,v);\n\tv=exp(v)-1.4;\n\tfragColor = vec4(rand+vec3(pow(v+.46,-.75)),1.)*vec4(.1,.17,.2,1.);\n\t}\n\t\/\/fragColor=vec4(vec3(0.),1.);\n}\n","name":"","description":"","type":"image"}]}}