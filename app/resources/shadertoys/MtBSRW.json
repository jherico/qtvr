{"Shader":{"ver":"0.1","info":{"id":"MtBSRW","date":"1454173428","viewed":71,"name":"Evolving Isles","username":"capitanNeptune","description":"First attemp in shader","likes":7,"published":3,"flags":0,"tags":["procedural","2d","noise","terrain","map","simplex","height","isles"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ All noise and fbm from iq\n\n#define time iGlobalTime*0.05\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,128.852))) * 43758.5453)*2.0-1.0;\n}\n\nfloat simplex3D(vec3 p)\n{\n\t\n\tfloat f3 = 1.0\/3.0;\n\tfloat s = (p.x+p.y+p.z)*f3;\n\tint i = int(floor(p.x+s));\n\tint j = int(floor(p.y+s));\n\tint k = int(floor(p.z+s));\n\t\n\tfloat g3 = 1.0\/6.0;\n\tfloat t = float((i+j+k))*g3;\n\tfloat x0 = float(i)-t;\n\tfloat y0 = float(j)-t;\n\tfloat z0 = float(k)-t;\n\tx0 = p.x-x0;\n\ty0 = p.y-y0;\n\tz0 = p.z-z0;\n\t\n\tint i1,j1,k1;\n\tint i2,j2,k2;\n\t\n\tif(x0>=y0)\n\t{\n\t\tif\t\t(y0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } \/\/ X Y Z order\n\t\telse if\t(x0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } \/\/ X Z Y order\n\t\telse \t\t\t{ i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; } \/\/ Z X Z order\n\t}\n\telse \n\t{ \n\t\tif\t\t(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } \/\/ Z Y X order\n\t\telse if\t(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } \/\/ Y Z X order\n\t\telse \t\t\t{ i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } \/\/ Y X Z order\n\t}\n\t\n\tfloat x1 = x0 - float(i1) + g3; \n\tfloat y1 = y0 - float(j1) + g3;\n\tfloat z1 = z0 - float(k1) + g3;\n\tfloat x2 = x0 - float(i2) + 2.0*g3; \n\tfloat y2 = y0 - float(j2) + 2.0*g3;\n\tfloat z2 = z0 - float(k2) + 2.0*g3;\n\tfloat x3 = x0 - 1.0 + 3.0*g3; \n\tfloat y3 = y0 - 1.0 + 3.0*g3;\n\tfloat z3 = z0 - 1.0 + 3.0*g3;\t\n\t\t\t\t \n\tvec3 ijk0 = vec3(i,j,k);\n\tvec3 ijk1 = vec3(i+i1,j+j1,k+k1);\t\n\tvec3 ijk2 = vec3(i+i2,j+j2,k+k2);\n\tvec3 ijk3 = vec3(i+1,j+1,k+1);\t\n            \n\tvec3 gr0 = normalize(vec3(noise3D(ijk0),noise3D(ijk0*2.01),noise3D(ijk0*2.02)));\n\tvec3 gr1 = normalize(vec3(noise3D(ijk1),noise3D(ijk1*2.01),noise3D(ijk1*2.02)));\n\tvec3 gr2 = normalize(vec3(noise3D(ijk2),noise3D(ijk2*2.01),noise3D(ijk2*2.02)));\n\tvec3 gr3 = normalize(vec3(noise3D(ijk3),noise3D(ijk3*2.01),noise3D(ijk3*2.02)));\n\t\n\tfloat n0 = 0.0;\n\tfloat n1 = 0.0;\n\tfloat n2 = 0.0;\n\tfloat n3 = 0.0;\n\n\tfloat t0 = 0.5 - x0*x0 - y0*y0 - z0*z0;\n\tif(t0>=0.0)\n\t{\n\t\tt0*=t0;\n\t\tn0 = t0 * t0 * dot(gr0, vec3(x0, y0, z0));\n\t}\n\tfloat t1 = 0.5 - x1*x1 - y1*y1 - z1*z1;\n\tif(t1>=0.0)\n\t{\n\t\tt1*=t1;\n\t\tn1 = t1 * t1 * dot(gr1, vec3(x1, y1, z1));\n\t}\n\tfloat t2 = 0.5 - x2*x2 - y2*y2 - z2*z2;\n\tif(t2>=0.0)\n\t{\n\t\tt2 *= t2;\n\t\tn2 = t2 * t2 * dot(gr2, vec3(x2, y2, z2));\n\t}\n\tfloat t3 = 0.5 - x3*x3 - y3*y3 - z3*z3;\n\tif(t3>=0.0)\n\t{\n\t\tt3 *= t3;\n\t\tn3 = t3 * t3 * dot(gr3, vec3(x3, y3, z3));\n\t}\n\treturn 96.0*(n0+n1+n2+n3);\n\t\n}\n\nfloat fbm(vec3 p)\n{\n\tfloat f;\n    f  = 0.50000*(simplex3D( p )); p = p*2.01;\n    f += 0.25000*(simplex3D( p )); p = p*2.02;\n    f += 0.12500*(simplex3D( p )); p = p*2.03;\n    f += 0.06250*(simplex3D( p )); p = p*2.04;\n    f += 0.03125*(simplex3D( p )); p = p*2.05;\n    f += 0.015625*(simplex3D( p ));\n\treturn f;\n}\n\n\/\/absolute value\nfloat ridgedMultifractal(vec3 p)\n{\n\tfloat f;\n    f  = 0.50000*abs(simplex3D( p )); p = p*2.01;\n    f += 0.25000*abs(simplex3D( p )); p = p*2.02;\n    f += 0.12500*abs(simplex3D( p )); p = p*2.03;\n    f += 0.06250*abs(simplex3D( p )); p = p*2.04;\n    f += 0.03125*abs(simplex3D( p ));\n\treturn f;\n}\n\nfloat inverseRidgedMultifractal(vec3 p)\n{\n\tfloat f;\n    f  = 0.50000*abs(simplex3D( p )); p = p*2.01;\n    f += 0.25000*abs(simplex3D( p )); p = p*2.02;\n    f += 0.12500*abs(simplex3D( p )); p = p*2.03;\n    f += 0.06250*abs(simplex3D( p )); p = p*2.04;\n    f += 0.03125*abs(simplex3D( p ));\n\treturn 1.0-f;\n}\n\nfloat terrain( vec3 p )\n{\n    float terrain = 0.0;\n    \n    terrain += 0.95*fbm( p * vec3(1.0, 0.2, 0.2))*0.5+0.5; p = p*2.01;\n    terrain += 0.05*inverseRidgedMultifractal( p );\n    \n    return terrain;\n}\n\nvec3 interpolateColors( float n , vec2 limits, vec3 startColor, vec3 endColor )\n{\n    float a = ((n-limits.x)\/(limits.y-limits.x));\n    float invn = 1.0 - a;\n    return vec3(endColor.r * a + startColor.r * invn, \n                endColor.g * a + startColor.g * invn,\n                endColor.b * a + startColor.b * invn);\n}\n\nvec3 colorize( float n )\n{    \n    if(n <= .60)\t\t\/\/ static water\n    {\n        return interpolateColors(n, vec2(.0,.60), vec3(.06,.12,.24), vec3(.15,.23,.34));\n    }\n    else if(n <= .68)\t\/\/ underwater sand\n    {\n        return interpolateColors(n, vec2(.60,.68), vec3(.15,.23,.34), vec3(.23,.34,.43));\n    }\n    else if(n <= .71)\t\/\/ underwater coral rgb(30%, 56%, 55%)\n    {\n        return interpolateColors(n, vec2(.68,.71), vec3(.23,.34,.43), vec3(.30,.56,.55));\n    }\n    else if(n <= .712)\t\/\/ beach rgb(70%, 56%, 42%)\n    {\n        return interpolateColors(n, vec2(.71,.712), vec3(.30,.56,.55), vec3(.87,.68,.39));\n    }\n    else if(n <= .725)\t\/\/ beach2 rgb(87%, 68%, 39%)\n    {\n        return interpolateColors(n, vec2(.712,.725), vec3(.87,.68,.39), vec3(.27,.30,.15));\n    }\n    else if(n <= .80)\t\/\/ grass\n    {\n        return interpolateColors(n, vec2(.725,.80), vec3(.27,.30,.15), vec3(.20,.25,.08));\n    }\n    else if(n <= .85)\t\/\/ brown1\n    {\n        return interpolateColors(n, vec2(.80,.85), vec3(.20,.25,.08), vec3(.25,.25,.15));\n    }\n    else if(n <= .90)\t\/\/ brown2\n    {\n        return interpolateColors(n, vec2(.85,.90), vec3(.25,.25,.15), vec3(.76,.68,.60));\n    }\n    else if(n <= .95)\t\/\/ snow\n    {\n        return interpolateColors(n, vec2(.90,.95), vec3(.76,.68,.60), vec3(.85,.89,.85));\n    }\n    \n    return vec3(n,n,n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy*1.0-0.5;\n    uv.x*=(iResolution.x\/iResolution.y);\n    float mx = iMouse.x>0.0?iMouse.x\/iResolution.x:0.5;\n    float my = iMouse.y>0.0?iMouse.y\/iResolution.y:0.5;\n\tuv*=my*10.0;\n    \n    float n = 0.0;\n    if(uv.x < (fragCoord.x \/ iResolution.x*1.0-0.5)*2.0)\n    {\n    \tn = terrain(vec3(time, vec2(uv)));\n    }\n    else\n    {\n    \tn = terrain(vec3(time, vec2(uv)));\n    }\n    \n    float b = terrain(vec3(time, vec2(uv) - vec2(-.005, .005)));\n    vec3 light = vec3(0.0,0.0,0.0);\n    vec3 shadow = vec3(0.0,0.0,0.0);\n    vec2 water_wind_direction = vec2(-time*0.5, time*0.2);\n    \n    \/\/light\n    if(b > n && n > 0.60)\n    {\n    \t\/\/shadow = interpolateColors(b, vec2(.6,1.0), vec3(.0), vec3(.15));\n        \/\/under the water\n        if( n < 0.71)\n        {\n            float toadd = (b-n)*10.0;\n            light = vec3(toadd);\n            light = interpolateColors(n, vec2(0.60, 0.71), vec3(0.0), vec3(light));\n        }\n        else\n        {\n            float toadd = (b-n)*20.0;\n       \t\tlight = vec3(toadd);\n        }\n    }\n    \/\/water  light\n    else if(n < 0.71)\n    {\n        float b = inverseRidgedMultifractal(vec3((time+50.0)*0.5, water_wind_direction + uv - vec2(-.005, .005)));\n        float v = inverseRidgedMultifractal(vec3((time+50.0)*0.5, water_wind_direction + uv));\n        float toadd = (b-v)*0.5;\n       \tlight += vec3(toadd);\n    }\n    \/\/shadows\n    b = terrain(vec3(time, vec2(uv)-vec2(.01, -.01)));\n    \n    if(b > n && n > 0.71)\n    {\n        float toadd = (b-n)*10.0;\n       \tshadow = vec3(toadd);\n    }\n    \n    if(uv.x < (fragCoord.x \/ iResolution.x*1.0-0.5)*2.0)\n    {\n    \tfragColor = vec4(colorize(n) + light - shadow, 1.0);\n        \/\/fragColor = vec4(n, n, n, 1.0);\n    }\n    else\n    {\n        fragColor = vec4(colorize(n) + light - shadow, 1.0);\n    \t\/\/fragColor = vec4(n, n, n, 1.0);\n    }\n}","name":"","description":"","type":"image"}]}}