{"Shader":{"ver":"0.1","info":{"id":"Xtf3RB","date":"1422786984","viewed":252,"name":"Ico-Disco","username":"dr2","description":"This is the answer to nimitz's next question; the dodecahedron (see MtsGW7) is left as an exercise.","likes":0,"published":3,"flags":0,"tags":["raymarching","icosahedron","symmetry"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ \"Ico-Disco\" by dr2 - 2015\n\/\/ License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nint idObj;\nmat3 rMat[20];\nvec3 ltDir;\nfloat tCur, eLen, chLen, chRad;\nconst float C_ab = -0.364863828, C_ia = 0.55357435, C_d = 0.288675135,\n   C_r = 0.80901699;\nconst float pi = 3.14159;\nconst float dstFar = 20.;\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z \/ h, -1., 1.))) - r;\n}\n\nfloat IcosDf (vec3 p)\n{\n  p.z -= C_r * eLen;\n  p.yz = Rot2D (p.yz, C_ab);\n  p.y += C_d * eLen;\n  p.xy = Rot2D (p.xy, floor (0.5 + atan (p.x, p.y) * (1.5 \/ pi)) * (pi \/ 1.5));\n  p.y -= C_d * chLen;  \n  return PrCapsDf (p.yzx, chRad, 0.5 * chLen);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float d, dHit;\n  dHit = dstFar;\n  d = dHit;\n  q = p * rMat[0] ;  d = min (d, IcosDf (q));\n  q = p * rMat[1] ;  d = min (d, IcosDf (q));\n  q = p * rMat[2] ;  d = min (d, IcosDf (q));\n  q = p * rMat[3] ;  d = min (d, IcosDf (q));\n  q = p * rMat[4] ;  d = min (d, IcosDf (q));\n  q = p * rMat[5] ;  d = min (d, IcosDf (q));\n  q = p * rMat[6] ;  d = min (d, IcosDf (q));\n  q = p * rMat[7] ;  d = min (d, IcosDf (q));\n  q = p * rMat[8] ;  d = min (d, IcosDf (q));\n  q = p * rMat[9] ;  d = min (d, IcosDf (q));\n  q = p * rMat[10];  d = min (d, IcosDf (q));\n  q = p * rMat[11];  d = min (d, IcosDf (q));\n  q = p * rMat[12];  d = min (d, IcosDf (q));\n  q = p * rMat[13];  d = min (d, IcosDf (q));\n  q = p * rMat[14];  d = min (d, IcosDf (q));\n  q = p * rMat[15];  d = min (d, IcosDf (q));\n  q = p * rMat[16];  d = min (d, IcosDf (q));\n  q = p * rMat[17];  d = min (d, IcosDf (q));\n  q = p * rMat[18];  d = min (d, IcosDf (q));\n  q = p * rMat[19];  d = min (d, IcosDf (q));\n  if (d < dHit) { dHit = d;  idObj = 1; }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nmat3 RotToRMat (vec3 v, float a)\n{\n  mat3 m;\n  float c, s, a1, a2;\n  c = cos (a);\n  s = sin (a);\n  m[0][0] = (1. - c) * v.x * v.x + c;\n  m[1][1] = (1. - c) * v.y * v.y + c;\n  m[2][2] = (1. - c) * v.z * v.z + c;\n  a1 = (1. - c) * v.x * v.y;\n  a2 = -s * v.z;\n  m[0][1] = a1 + a2;\n  m[1][0] = a1 - a2;\n  a1 = (1. - c) * v.z * v.x;\n  a2 = -s * v.y;\n  m[2][0] = a1 + a2;\n  m[0][2] = a1 - a2;\n  a1 = (1. - c) * v.y * v.z;\n  a2 = -s * v.x;\n  m[1][2] = a1 + a2;\n  m[2][1] = a1 - a2;\n  return m;\n}\n\nvoid BuildRMats ()\n{\n  mat3 axMat[3];\n  axMat[0] = RotToRMat (vec3 (1., 0., 0.), pi);\n  axMat[1] = RotToRMat (vec3 (0., cos (C_ia), sin (C_ia)), 0.4 * pi);\n  axMat[2] = RotToRMat (vec3 (0., 1., 0.), pi);\n  for (int i = 0; i < 3; i ++) {\n    for (int j = 0; j < 3; j ++) rMat[0][i][j] = 0.;\n    rMat[0][i][i] = 1.;\n  }\n  rMat[1]  = axMat[0];\n  rMat[2]  = axMat[1];\n  rMat[3]  = rMat[2] * axMat[1];\n  rMat[4]  = rMat[3] * axMat[1];\n  rMat[5]  = rMat[4] * axMat[1];\n  rMat[6]  = rMat[1] * axMat[1];\n  rMat[7]  = rMat[6] * axMat[1];\n  rMat[8]  = rMat[7] * axMat[1];\n  rMat[9]  = rMat[8] * axMat[1];\n  rMat[10] = axMat[2];\n  rMat[11] = rMat[1] * axMat[2];\n  rMat[12] = rMat[2] * axMat[2];\n  rMat[13] = rMat[3] * axMat[2];\n  rMat[14] = rMat[4] * axMat[2];\n  rMat[15] = rMat[5] * axMat[2];\n  rMat[16] = rMat[6] * axMat[2];\n  rMat[17] = rMat[7] * axMat[2];\n  rMat[18] = rMat[8] * axMat[2];\n  rMat[19] = rMat[9] * axMat[2];\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p = abs (fract (c.xxx + vec3 (1., 2.\/3., 1.\/3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstHit;\n  eLen = 1. + 0.3 * (1. + cos (tCur));\n  chLen = 0.85;\n  chRad = 0.03;\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  if (idObj < 0) dstHit = dstFar;\n  if (dstHit >= dstFar) col = vec3 (0.05);\n  else {\n    ro += rd * dstHit;\n    vn = ObjNf (ro);\n    col = HsvToRgb (vec3 (mod (0.5 * tCur, 1.), 1., 1.)) *\n       (0.3 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       0.5 * pow (max (0., dot (ltDir, reflect (rd, vn))), 128.);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy \/ iResolution.xy - 1.;\n  uv.x *= iResolution.x \/ iResolution.y;\n  tCur = iGlobalTime;\n  mat3 vuMat;\n  vec3 ro, rd;\n  vec2 vEl, vAz;\n  float az, el;\n  el = 0.05 * tCur;\n  az = 0.11 * tCur;\n  vEl = vec2 (cos (el), sin (el));\n  vAz = vec2 (cos (az), sin (az));\n  vuMat = mat3 (1., 0., 0., 0., vEl.x, - vEl.y, 0., vEl.y, vEl.x) *\n     mat3 (vAz.x, 0., vAz.y, 0., 1., 0., - vAz.y, 0., vAz.x);\n  rd = normalize (vec3 (uv, 5.5)) * vuMat;\n  ro = - vec3 (0., 0., 8.) * vuMat;\n  ltDir = normalize (vec3 (1., 1., -1.)) * vuMat;\n  BuildRMats ();\n  vec3 col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n","name":"","description":"","type":"image"}]}}