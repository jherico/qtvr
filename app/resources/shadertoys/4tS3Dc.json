{"Shader":{"ver":"0.1","info":{"id":"4tS3Dc","date":"1432923998","viewed":689,"name":"Ray Marching Experiment 26","username":"aiekick","description":"Another variation of <a href=\"https:\/\/www.shadertoy.com\/view\/llB3zc\" class=\"regular\" target=\"_blank\">https:\/\/www.shadertoy.com\/view\/llB3zc<\/a> but on torus<br\/>use mouse xy to change pattern","likes":4,"published":3,"flags":0,"tags":["ray","experiment","marching","26"],"hasliked":0},"renderpass":[{"inputs":[{"id":26,"src":"\/presets\/cube04_0.png","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Stephane Cuillerdier - Aiekick\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define uScreenSize iResolution \n#define uTime iGlobalTime \n#define uMouse iMouse \n#define uCubeMap iChannel0\n\nvec2 m;\n\nvec3 dstepf = vec3(0.0);\nvec3 colFact = vec3(0.0006, 0.0004, 0.17); \n\nconst vec2 RMPrec = vec2(0.3, 0.05); \/\/ ray marching tolerance precision \/\/ vec2(low, high)\nconst vec2 DPrec = vec2(0.001, 50.); \/\/ ray marching distance precision\n    \nfloat sphereRadius = 6.; \/\/ radius of sphere before tex displace\n\nfloat dota(vec3 a, vec3 b)\n{\n\tdstepf.y += colFact.y; \n    return dot(a,b);\n}\n\nvec3 nora(vec3 a)\n{\n    dstepf.z += colFact.z;\n    return normalize(a);\n}\n\n#define mPi 3.14159\n#define m2Pi 6.28318\nvec2 uvMap(vec3 p)\n{\n    p = normalize(p);\n    vec2 tex2DToSphere3D;\n    tex2DToSphere3D.x = 0.5 + atan(p.z, p.x) \/ m2Pi;\n    tex2DToSphere3D.y = 0.5 - asin(p.y) \/ mPi;\n    return tex2DToSphere3D;\n}\n\nvec2 getTemp(vec3 p)\n{\n\tp*=2.;\n    \n    vec2 p2 = uvMap(p);\n    \n    vec2 coef = vec2(30.,100.*(sin(uTime*.1)*.5+.5));\n    if ( uMouse.z>0.) coef *= iMouse.xy\/iResolution.xy; \n    \n    float r = fract(p2.x*coef.x+cos(p2.y*coef.y));\n\treturn vec2(dota(p,p)*(100.)*r,r);\n}\n\nvec3 getHotColor(float Temp)\n{\n\tvec3 col = vec3(255.);\n\tcol.x = 56100000. * pow(Temp,(-3. \/ 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. \/ 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)\/255.;\n\tif (Temp < 1000.) col *= Temp\/1000.;\n   \treturn col;\n}\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec4 map(vec3 p)\n{   \n    dstepf.x += colFact.x;\n   \n    vec2 r = getTemp(p);\n    vec3 col = getHotColor(r.x);\n            \n    float disp = dota(col,vec3(-dstepf.xyx));\n    float sp = length(p) -sphereRadius - disp;\n        \n    sp = sdTorus(p, vec2( sphereRadius, sphereRadius\/2.)) - disp;\n    return vec4(sp, col);\n}\n\nvec3 nor( in vec3 p, float prec)\n{\n\tvec2 e = vec2( prec, 0.);\n\tvec3 n = vec3(\n    \tmap(p+e.xyy).x - map(p-e.xyy).x,\n        map(p+e.yxy).x - map(p-e.yxy).x,\n        map(p+e.yyx).x - map(p-e.yyx).x );\n\treturn normalize(n);\n}\n\n\/\/\/\/\/\/\/\/MAIN\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = uTime*0.5;\n    float cam_a = t; \/\/ angle z\n    \n    float cam_e = 5.; \/\/ elevation\n    float cam_d = 10.; \/\/ distance to origin axis\n   \t\n    vec3 camUp=vec3(0,1,0);\/\/Change camere up vector here\n  \tvec3 camView=vec3(0,-5.,0); \/\/Change camere view here\n  \tfloat li = 0.55; \/\/ light intensity\n    float refl_i = .6; \/\/ reflexion intensity\n    float bii = 0.35; \/\/ bright init intensity\n    \n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/if ( uMouse.z>0.) cam_e = uMouse.x\/uScreenSize.x * 10.; \/\/ mouse x axis \n    \/\/if ( uMouse.z>0.) cam_d = uMouse.y\/uScreenSize.y * 50.; \/\/ mouse y axis \n   \t\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \n    \/\/ col variations\n    colFact.y =  colFact.y * (sin(uTime*2.)*.5+.5) + colFact.y;\n    colFact.x =  colFact.y* (sin(uTime)*.5+.5) + colFact.x\/3.;\n    colFact.z =  0.5* (sin(uTime*0.5)*.5+.5) + 0.1;\n        \n\tvec2 uv = fragCoord.xy \/ uScreenSize.xy * 2. -1.;\n    uv.x*=uScreenSize.x\/uScreenSize.y;\n    \n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(-sin(cam_a)*cam_d, cam_e+1., cos(cam_a)*cam_d); \/\/\n  \tvec3 rov = nora(camView-ro);\n    vec3 u = nora(cross(camUp,rov));\n  \tvec3 v = cross(rov,u);\n  \tvec3 rd = nora(rov + uv.x*u + uv.y*v);\n    \n    float b = bii;\n    \n    float d = 0.;\n    vec3 p = ro+rd*d;\n    float s = DPrec.x;\n    \n    vec3 ray, cubeRay;\n    \n    for(int i=0;i<500;i++)\n    {      \n    \tif(s<DPrec.x||s>DPrec.y) break;\n        s = map(p).x*(s>DPrec.x?RMPrec.x:RMPrec.y);\n        d += s;\n        p = ro+rd*d;\n    }\n\n    if (d<DPrec.y)\n    {\n    \tvec3 n = nor(p, 0.001);\n\n        ray = reflect(rd, n);\n        cubeRay = textureCube(uCubeMap, ray).rgb  * refl_i ;\n\n        col = cubeRay+pow(li,15.);\n        \n        col = mix(col, map(p).yzw, 0.5);\n            \n        col += dstepf;\n \t}\n    else \n    {\n    \tcol = textureCube(uCubeMap, rd).rgb;\n    }\n        \n    fragColor.rgb = col;\n}\n","name":"","description":"","type":"image"}]}}