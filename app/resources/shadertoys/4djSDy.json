{"Shader":{"ver":"0.1","info":{"id":"4djSDy","date":"1415594977","viewed":4924,"name":"Sphere - occlusion","username":"iq","description":"Analytical ambient occlusion of a sphere. Left side, stochastically sampled occlusion. Right, analytical solution, no rays casted. More info in <a href=\"http:\/\/iquilezles.org\/www\/articles\/sphereao\/sphereao.htm\"  class=\"regular\" target=\"_blank\">this article<\/a>. Move the mouse to compare.","likes":17,"published":3,"flags":0,"tags":["3d","triangle","occlusion","analytic"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\/\/ Analytical ambient occlusion of a sphere. Left side of screen, stochastically \n\/\/ sampled occlusion. Right side of the screen, analytical solution (no rays casted).\n\/\/\n\/\/ When the sphere is fully visible to the normal, the solution is easy. More info here:\n\/\/ http:\/\/iquilezles.org\/www\/articles\/sphereao\/sphereao.htm\n\/\/\n\/\/ When the sphere is only partially visible and see clipping, it gets more complicated:\n\/\/ http:\/\/www.frostbite.com\/wp-content\/uploads\/2014\/11\/course_notes_moving_frostbite_to_pbr.pdf\n\n\/\/ Sphere intersection\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\n\/\/ Sphere occlusion\nfloat sphOcclusion( in vec3 pos, in vec3 nor, in vec4 sph )\n{\n    vec3  di = sph.xyz - pos;\n    float l  = length(di);\n    float nl = dot(nor,di\/l);\n    float h  = l\/sph.w;\n    float h2 = h*h;\n    float k2 = 1.0 - h2*nl*nl;\n\n    \/\/ above\/below horizon: Quilez - http:\/\/iquilezles.org\/www\/articles\/sphereao\/sphereao.htm\n    float res = max(0.0,nl)\/h2;\n    \/\/ intersecting horizon: Lagarde\/de Rousiers - http:\/\/www.frostbite.com\/wp-content\/uploads\/2014\/11\/course_notes_moving_frostbite_to_pbr.pdf\n    if( k2 > 0.0 ) \n    {\n        #if 1\n            res = nl*acos(-nl*sqrt( (h2-1.0)\/(1.0-nl*nl) )) - sqrt(k2*(h2-1.0));\n            res = res\/h2 + atan( sqrt(k2\/(h2-1.0)));\n            res \/= 3.141593;\n        #else\n            \/\/ cheap approximation: Quilez\n            res = pow( clamp(0.5*(nl*h+1.0)\/h2,0.0,1.0), 1.5 );\n        #endif\n    }\n\n    return res;\n}\n\n\/\/=====================================================\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\nfloat iPlane( in vec3 ro, in vec3 rd )\n{\n    return (-1.0 - ro.y)\/rd.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy) \/ iResolution.y;\n    float s = (2.0*iMouse.x-iResolution.x) \/ iResolution.y;\n    if( iMouse.z<0.001 ) s=0.0;\n    \n\tvec3 ro = vec3(0.0, 0.0, 4.0 );\n\tvec3 rd = normalize( vec3(p,-2.0) );\n\t\n    \/\/ sphere animation\n    vec4 sph = vec4( cos( iGlobalTime + vec3(2.0,1.0,1.0) + 0.0 )*vec3(1.5,1.2,1.0), 1.0 );\n\n    vec4 rrr = texture2D( iChannel0, (fragCoord.xy)\/iChannelResolution[0].xy, -99.0  ).xzyw;\n\n\n    vec3 col = vec3(0.0);\n\n    float tmin = 1e10;\n    \n    float t1 = iPlane( ro, rd );\n    if( t1>0.0 )\n    {\n        tmin = t1;\n        vec3 pos = ro + tmin*rd;\n        vec3 nor = vec3(0.0,1.0,0.0);\n        float occ = 0.0;\n        \n        if( p.x > s )\n        {\n            occ = sphOcclusion( pos, nor, sph );\n        }\n        else\n        {\n   \t\t    vec3  ru  = normalize( cross( nor, vec3(0.0,1.0,1.0) ) );\n\t\t    vec3  rv  = normalize( cross( ru, nor ) );\n\n            occ = 0.0;\n            for( int i=0; i<256; i++ )\n            {\n                vec2  aa = hash2( rrr.x + float(i)*203.1 );\n                float ra = sqrt(aa.y);\n                float rx = ra*cos(6.2831*aa.x); \n                float ry = ra*sin(6.2831*aa.x);\n                float rz = sqrt( 1.0-aa.y );\n                vec3  dir = vec3( rx*ru + ry*rv + rz*nor );\n                float res = sphIntersect( pos, dir, sph );\n                occ += step(0.0,res);\n            }\n            occ \/= 256.0;\n        }\n\n        col = vec3(1.0);\n        col *= 1.0 - occ;\n    }\n\n    float t2 = sphIntersect( ro, rd, sph );\n    if( t2>0.0 && t2<tmin )\n    {\n        tmin = t2;\n        float t = t2;\n        vec3 pos = ro + t*rd;\n        vec3 nor = normalize( pos - sph.xyz );\n\t\tcol = vec3(1.2);\n        col *= 0.6+0.4*nor.y;\n\t}\n\n\tcol *= exp( -0.05*tmin );\n\n    float e = 2.0\/iResolution.y;\n    col *= smoothstep( 0.0, 2.0*e, abs(p.x-s) );\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}