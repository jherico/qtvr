{"Shader":{"ver":"0.1","info":{"id":"4dc3zr","date":"1447633262","viewed":619,"name":"Nixie Tube Digits","username":"Flyguy","description":"Some nixie tube like digits made of lines, arcs and circles.<br\/>The digits were designed in AutoCAD and converted to GLSL code using C# and netDxf.","likes":24,"published":3,"flags":0,"tags":["text","distance","font","digit","nixie"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define SHOW_GRID\n\nfloat pi = atan(1.0)*4.0;\nfloat tau = atan(1.0)*8.0;\n\nfloat scale = 1.0 \/ 6.0;\n\nvec2 digitSize = vec2(1.0,1.5) * scale;\nvec2 digitSpacing = vec2(1.1,1.6) * scale;\n\n\/\/Distance to a line segment,\nfloat dfLine(vec2 start, vec2 end, vec2 uv)\n{\n\tstart *= scale;\n\tend *= scale;\n    \n\tvec2 line = end - start;\n\tfloat frac = dot(uv - start,line) \/ dot(line,line);\n\treturn distance(start + line * clamp(frac, 0.0, 1.0), uv);\n}\n\n\/\/Distance to the edge of a circle.\nfloat dfCircle(vec2 origin, float radius, vec2 uv)\n{\n\torigin *= scale;\n\tradius *= scale;\n    \n\treturn abs(length(uv - origin) - radius);\n}\n\n\/\/Distance to an arc.\nfloat dfArc(vec2 origin, float start, float sweep, float radius, vec2 uv)\n{\n\torigin *= scale;\n\tradius *= scale;\n    \n\tuv -= origin;\n\tuv *= mat2(cos(start), sin(start),-sin(start), cos(start));\n\t\n\tfloat offs = (sweep \/ 2.0 - pi);\n\tfloat ang = mod(atan(uv.y, uv.x) - offs, tau) + offs;\n\tang = clamp(ang, min(0.0, sweep), max(0.0, sweep));\n\t\n\treturn distance(radius * vec2(cos(ang), sin(ang)), uv);\n}\n\n\/\/Distance to the digit \"d\" (0-9).\nfloat dfDigit(vec2 origin, float d, vec2 uv)\n{\n\tuv -= origin;\n\td = floor(d);\n\tfloat dist = 1e6;\n\t\n\tif(d == 0.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(1.000,1.000), vec2(1.000,0.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.000,1.000), vec2(0.000,0.500), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,1.000),0.000, 3.142, 0.500, uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,0.500),3.142, 3.142, 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 1.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.500,1.500), vec2(0.500,0.000), uv));\n\t\treturn dist;\n\t}\n\tif(d == 2.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(1.000,0.000), vec2(0.000,0.000), uv));\n\t\tdist = min(dist, dfLine(vec2(0.388,0.561), vec2(0.806,0.719), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,1.000),0.000, 3.142, 0.500, uv));\n\t\tdist = min(dist, dfArc(vec2(0.700,1.000),5.074, 1.209, 0.300, uv));\n\t\tdist = min(dist, dfArc(vec2(0.600,0.000),1.932, 1.209, 0.600, uv));\n\t\treturn dist;\n\t}\n\tif(d == 3.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.000,1.500), vec2(1.000,1.500), uv));\n\t\tdist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.500,1.000), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,0.500),3.142, 4.712, 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 4.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.700,1.500), vec2(0.000,0.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.000,0.500), vec2(1.000,0.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.700,1.200), vec2(0.700,0.000), uv));\n\t\treturn dist;\n\t}\n\tif(d == 5.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.300,1.500), uv));\n\t\tdist = min(dist, dfLine(vec2(0.300,1.500), vec2(0.200,0.900), uv));\n\t\tdist = min(dist, dfArc(vec2(0.500,0.500),3.142, 5.356, 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 6.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.067,0.750), vec2(0.500,1.500), uv));\n\t\tdist = min(dist, dfCircle(vec2(0.500,0.500), 0.500, uv));\n\t\treturn dist;\n\t}\n\tif(d == 7.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.000,1.500), vec2(1.000,1.500), uv));\n\t\tdist = min(dist, dfLine(vec2(1.000,1.500), vec2(0.500,0.000), uv));\n\t\treturn dist;\n\t}\n\tif(d == 8.0)\n\t{\n\t\tdist = min(dist, dfCircle(vec2(0.500,0.400), 0.400, uv));\n\t\tdist = min(dist, dfCircle(vec2(0.500,1.150), 0.350, uv));\n\t\treturn dist;\n\t}\n\tif(d == 9.0)\n\t{\n\t\tdist = min(dist, dfLine(vec2(0.933,0.750), vec2(0.500,0.000), uv));\n\t\tdist = min(dist, dfCircle(vec2(0.500,1.000), 0.500, uv));\n\t\treturn dist;\n\t}\n\n\treturn dist;\n}\n\n\/\/Distance to a number\nfloat dfNumber(vec2 origin, float num, vec2 uv)\n{\n\tuv -= origin;\n\tfloat dist = 1e6;\n\tfloat offs = 0.0;\n\t\n\tfor(float i = 5.0;i > -3.0;i--)\n\t{\t\n\t\tfloat d = mod(num \/ pow(10.0,i),10.0);\n\t\t\n\t\tvec2 pos = digitSpacing * vec2(offs,0.0);\n\n\t\tif(i == 0.0)\n\t\t{\n\t\t\tdist = min(dist, dfCircle(vec2(offs+0.9,0.1)*1.1, 0.04,uv));\n\t\t}\n\t\t\n\t\tif(num > pow(10.0,i) || i == 0.0)\n\t\t{\n\t\t\tdist = min(dist, dfDigit(pos, d, uv));\n\t\t\toffs++;\n\t\t}\t\n\t}\n\treturn dist;\t\n}\n\n\/\/Length of a number in digits\nfloat numberLength(float n)\n{\n\treturn floor(max(log(n) \/ log(10.0), 0.0) + 1.0) + 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 aspect = iResolution.xy \/ iResolution.y;\n\tvec2 uv = fragCoord.xy \/ iResolution.y - aspect\/2.0;\n\t\n\tfloat n = iGlobalTime;\n\t\n\tfloat nsize = numberLength(n);\n\t\n\tvec2 pos = -digitSpacing * vec2(nsize,1.0)\/2.0;\n\n\tfloat dist = 1e6;\n\tdist = min(dist, dfNumber(pos, n, uv));\n\t\n\tvec3 color = vec3(0);\n\t\n\tfloat shade = 0.0;\n\t\n\tshade = 0.004 \/ (dist);\n\t\n\tcolor += vec3(1,0.2,0) * shade;\n    \n    #ifdef SHOW_GRID\n    float grid = 0.5-max(abs(mod(uv.x*64.0,1.0)-0.5), abs(mod(uv.y*64.0,1.0)-0.5));\n    \n    color *= 0.25+vec3(smoothstep(0.0,64.0 \/ iResolution.y,grid))*0.75;\n    #endif\n\t\n\tfragColor = vec4( color , 1.0 );\n}","name":"","description":"","type":"image"}]}}