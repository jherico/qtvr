{"Shader":{"ver":"0.1","info":{"id":"MlXXDM","date":"1439205467","viewed":855,"name":"[SIG15] Winning Solitaire 2","username":"eigenaar","description":"A classic and forever satisfying video game moment. Controls : hold A while running to better see the cards. If you can, increase the number of cards (see \"#define OBJECT\") and add the missing patterns (see \"#define COMPILE_PATTERNS\").","likes":1,"published":3,"flags":16,"tags":["sig15"],"hasliked":0},"renderpass":[{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/======================================================================\n\/\/ Hold A to better see a sample of the cards.\n\/\/ On my windows 8 laptop, compilation fails using Chrome\n\/\/ but works fine with Firefox. Reducing the number of cards\n\/\/ (by commenting the \"#define OBJECT\"s below) might help.\n\n\/\/ Some symbol patterns on the cards crash at compilation on some browsers,\n\/\/ so I took them out. You can try adding them back by uncommenting the\n\/\/ line \"#define COMPILE_PATTERNS\".\n\n\/\/ I left the number of cards at 1 by default so it loads faster, but\n\/\/ increase it to at least 6 to get nice results. Crank it up\n\/\/ to 20 if you can :).\n\n\/\/ A piecewise parabolic prism bounding volume is used to find a\n\/\/ good approximation of intersections, and the neighboring cards in the stack\n\/\/ are then searched for a precise intersection. All designs were\n\/\/ manually constructed with implicit functions. Cards numbers and suits\n\/\/ are selected automatically.\n\n\/\/ By Olivier Mercier\n\/\/======================================================================\n\n\n\n\/\/ parameters, can be modified\n#define CAMERA_SPEED 0.22\n#define NB_BOUNCES 10\n#define BUMP_HEIGHT_FACTOR 0.5\n#define CARD_SPEED 1.0\n#define SEED 12834.77346652\n#define CARD_DENSITY 8.0\n#define NB_MARCH_LAYERS 3 \/\/ affects the number of cards searched for intersections.\n#define CARD_BORDER_SIZE 0.025\n#define CARD_BORDER_TINT1 0.3\n#define CARD_BORDER_TINT2 0.2\n#define SHOOT_TOWARDS_CAMERA_RANGE 0.95 \/\/ range (in radian) for the randomness of the card direction angle\n#define SHOOT_TOWARDS_CAMERA_OFFSET 4.0 \/\/ to shoot ahead of the camera\n\n\/\/#define COMPILE_PATTERNS\n\n\/\/ e.g. if you want 5 card stacks, leave OBJECT1 to OBJECT5 uncommented, and comment OBJECT6 to OBJECT20.\n#define OBJECT1\n\/\/#define OBJECT2\n\/\/#define OBJECT3\n\/\/#define OBJECT4\n\/\/#define OBJECT5\n\/\/#define OBJECT6\n\/\/#define OBJECT7\n\/\/#define OBJECT8\n\/\/#define OBJECT9\n\/\/#define OBJECT10\n\/\/#define OBJECT11\n\/\/#define OBJECT12\n\/\/#define OBJECT13\n\/\/#define OBJECT14\n\/\/#define OBJECT15\n\/\/#define OBJECT16\n\/\/#define OBJECT17\n\/\/#define OBJECT18\n\/\/#define OBJECT19\n\/\/#define OBJECT20\n\n\n\/\/ constants. DO NOT MODIFY.\n#define MATERIAL_UVW 1\n#define MATERIAL_NORMAL 2\n#define MATERIAL_CARD_SIDE_XM 3\n#define MATERIAL_CARD_SIDE_XP 4\n#define MATERIAL_CARD_SIDE_YM 5\n#define MATERIAL_CARD_SIDE_YP 6\n#define MATERIAL_CARD_FACE 7\n#define MATERIAL_CARD_BACK 8\n#define MATERIAL_FLOOR 9\n#define INFINITY 99999.0\n#define EPSILON 0.0001\n#define PI 3.14159265359\n#define CARD_HEIGHT 1.4\n#define CARD_WIDTH 1.0\n#define CARD_SPEED_ADJUSTED CARD_SPEED\/(34.0\/5.0)\n\nfloat multiMin3(float a1, float a2, float a3) {return min(a1,min(a2,a3));}\nfloat multiMin4(float a1, float a2, float a3,float a4) {return min(a1,min(a2,min(a3,a4)));}\nfloat multiMin5(float a1, float a2, float a3,float a4,float a5) {return min(a1,min(a2,min(a3,min(a4,a5))));}\nfloat multiMin6(float a1, float a2, float a3,float a4,float a5,float a6) {return min(a1,min(a2,min(a3,min(a4,min(a5,a6)))));}\nfloat multiMax3(float a1, float a2, float a3) {return max(a1,max(a2,a3));}\nfloat multiMax4(float a1, float a2, float a3,float a4) {return max(a1,max(a2,max(a3,a4)));}\nfloat multiMax5(float a1, float a2, float a3,float a4,float a5) {return max(a1,max(a2,max(a3,max(a4,a5))));}\nvec3 minVec3(vec3 a, vec3 b){ return vec3(min(a.x,b.x), min(a.y,b.y), min(a.z,b.z)); }\nvec3 multiMin3Vec3(vec3 a1,vec3 a2,vec3 a3){ return minVec3(a1, minVec3(a2,a3)); }\nvec3 multiMin4Vec3(vec3 a1,vec3 a2,vec3 a3,vec3 a4){ return minVec3(a1, minVec3(a2,minVec3(a3,a4))); }\nvec3 multiMin5Vec3(vec3 a1,vec3 a2,vec3 a3,vec3 a4,vec3 a5){ return minVec3(a1, minVec3(a2,minVec3(a3,minVec3(a4,a5)))); }\nvec3 multiMin6Vec3(vec3 a1,vec3 a2,vec3 a3,vec3 a4,vec3 a5,vec3 a6){ return minVec3(a1, minVec3(a2,minVec3(a3,minVec3(a4,minVec3(a5,a6))))); }\nvec3 multiMin7Vec3(vec3 a1,vec3 a2,vec3 a3,vec3 a4,vec3 a5,vec3 a6,vec3 a7){ return minVec3(a1, minVec3(a2,minVec3(a3,minVec3(a4,minVec3(a5,minVec3(a6,a7)))))); }\nvec3 multiMin9Vec3(vec3 a1,vec3 a2,vec3 a3,vec3 a4,vec3 a5,vec3 a6,vec3 a7,vec3 a8,vec3 a9){ return minVec3(a1, minVec3(a2,minVec3(a3,minVec3(a4,minVec3(a5,minVec3(a6,minVec3(a7,minVec3(a8,a9)))))))); }\n\nstruct Intersection {\n    float dist;\n    vec3 normal;\n    vec3 uvw;\n    int material;\n    int info1;\n    int info2;\n};\n    \nfloat sqr(float x) {return x*x;}\n\nvec3 camPosFun(float time) {\n    return 18.0*vec3(2.0*cos(time*CAMERA_SPEED), 0.25, sin(time*CAMERA_SPEED));\n}\n\nIntersection rectangle(vec3 ori, vec3 dir, vec3 center, vec3 normal, vec2 size) {\n    \n    Intersection res;\n    vec3 up = vec3(1.0,0.0,0.0);\n    vec3 right = cross(normal, up);\n    \n    float dist = dot(normal, center-ori) \/ dot(normal, dir);\n        vec3 pos = ori + dist*dir;\n        vec3 uvw = vec3(vec2(dot(pos-center, right), dot(pos-center,up)), 0.0);\n        if(abs(uvw.x) <= size.x && abs(uvw.y) <= size.y) {\n            res.dist = dist;\n            res.normal = dot(normal, dir) >= 0.0 ? normal : -normal;\n            res.uvw = uvw;\n            res.material = MATERIAL_FLOOR;\n        } else {\n            res.dist = -1.0;\n        }\n    \n    return res;\n}\n\n\/\/ piecewise parabolic funcction representing bounces.\nfloat bounce(float x, float bounceHeight, float bounceStepSize)\n{    \n    float maxHeight = bounceHeight;\n    float MHOverBounceStepSiseSqrDiv = maxHeight\/(bounceStepSize*bounceStepSize\/4.0);\n    float sqrtCoeff = (1.0+sqrt(BUMP_HEIGHT_FACTOR))*sqrt(maxHeight\/MHOverBounceStepSiseSqrDiv);\n    float sqrtFact = sqrt(BUMP_HEIGHT_FACTOR);\n        \n    float res = 0.0;\n    float center = 0.0;\n    float height = maxHeight;\n    float fact = 1.0;\n    float temp;\n    for(int i=0; i<=NB_BOUNCES; i++) {\n        temp = -MHOverBounceStepSiseSqrDiv*sqr(x-center) + height;\n        if(temp >= 0.0) {res = temp; return res;}\n        height *= BUMP_HEIGHT_FACTOR;\n        fact *= sqrtFact;\n        center = sqrtCoeff*(1.0-fact)\/(1.0-sqrtFact); \n    }\n    \n    return res;\n}\n\nfloat bounceFloor(float x, float bounceHeight, float bounceStepSize) {\n    return bounce( floor(EPSILON+x*CARD_DENSITY)\/CARD_DENSITY,bounceHeight, bounceStepSize );\n}\n\n\n\/\/ returns a different value for each time cycle\nfloat cycleRandom(float time, float frequency, float phase, float seed) {\n    return sin(54.1235+SEED*seed + SEED*floor(time*frequency*CARD_SPEED_ADJUSTED - phase));\n}\n\n\n\/\/ falling card stack starting at center and extruding in the given direction\nIntersection fallingCard(float time, vec3 ori, vec3 dir, float frequency, float phase) {\n\n    vec3 center= vec3(\n                     0.0 + 8.0*cycleRandom(time, frequency, phase, 31.512*frequency),\n                     0.0,\n                     0.0 + 8.0*cycleRandom(time, frequency, phase, 51.512*frequency)\n                 );\n    float bounceHeight = 8.0 + 4.0*cycleRandom(time, frequency, phase, 3.997*frequency);\n    float bounceStepSize = 8.0 + 4.0*cycleRandom(time, frequency, phase, 15.371*frequency);\n    float camAngle = CAMERA_SPEED*(SHOOT_TOWARDS_CAMERA_OFFSET+floor(time*frequency*CARD_SPEED_ADJUSTED - phase)\/(frequency*CARD_SPEED_ADJUSTED));\n    float theta = camAngle + SHOOT_TOWARDS_CAMERA_RANGE*cycleRandom(time, frequency, phase, 12.662*frequency);\n    vec3 z = vec3(cos(theta), 0.0, sin(theta));\n    vec3 y = vec3(0.0,1.0,0.0);\n    \n    float speed = CARD_SPEED*frequency*bounceStepSize;\n    float bssAdjusted = 34.0*bounceStepSize\/5.0;\n    \n    float zBegin = max(mod(speed*(time-phase\/speed*bssAdjusted),bssAdjusted)-12.0*bounceStepSize\/5.0,0.0);\n    float zEnd = min(mod(speed*(time-phase\/speed*bssAdjusted),bssAdjusted),14.0*bounceStepSize\/5.0);\n   \n    int cardId = int(max(min(7.0 + 6.5*cycleRandom(time, frequency, phase, 39.612*frequency),13.0),1.0));\n    int cardSuit = int(max(min(3.0 + 2.0*cycleRandom(time, frequency, phase, 634.775*frequency),4.0),1.0));\n    \n    Intersection res;\n    res.info1 = cardId;\n    res.info2 = cardSuit;\n    \n    if(zEnd < zBegin) {res.dist = -1.0; return res;}\n    \n    \n    \/\/ transform to local axis-aligned coordinates\n    vec3 x = cross(y,z);\n    vec3 locOri = vec3( dot(ori-center,x), dot(ori-center,y), dot(ori-center,z) );\n    vec3 locDir = vec3( dot(dir,x), dot(dir,y), dot(dir,z) );\n    \n    \n    \/\/=============================================\n    \/\/ rough intersection with bounding volume\n    float tx = INFINITY;\n    float ty = INFINITY;\n    float tz = INFINITY;\n    vec3 interX, interY, interZ;\n    \n    \n    if(abs(locDir.x) > EPSILON\/10.0) {\n        tx = (sign(locOri.x)*CARD_WIDTH - locOri.x)\/locDir.x;\n        interX = locOri + tx*locDir;\n        if (tx < 0.0) {tx = INFINITY;}\n        else if(!( abs(interX.y - bounce(interX.z,bounceHeight,bounceStepSize))<=CARD_HEIGHT && zBegin<=interX.z && interX.z<=zEnd)) {tx = INFINITY;}\n    }\n    \n    \n    if(abs(locDir.z) > EPSILON\/10.0) {\n        tz = min( (zEnd - locOri.z)\/locDir.z, (zBegin - locOri.z)\/locDir.z );\n        interZ = locOri + tz*locDir;\n        if (tz < 0.0) {tz = INFINITY;}\n        if(!( abs(interZ.x)<=CARD_WIDTH && abs(interZ.y-bounce(interZ.z,bounceHeight,bounceStepSize))<=CARD_HEIGHT )) {tz = INFINITY;}\n    }\n    \n    \n    if(abs(locDir.y) > EPSILON\/1000.0) {\n        float a = -bounceHeight\/(bounceStepSize*bounceStepSize\/4.0);\n        float c = 0.0;\n        float h = bounceHeight;\n        ty = INFINITY;\n        float tyBump;\n        \n        float bssSqrDiv4 = (bounceStepSize*bounceStepSize\/4.0);\n        \n        float bounceSize = sqrt(h\/bounceHeight*bssSqrDiv4);\n        \n        float tempA2 = 4.0*a*sqr(locDir.z);\n        float tempB3 = tempA2\/2.0;\n        for(int i=0; i<=NB_BOUNCES; i++) {\n            if(abs(locDir.z)<=EPSILON) {\n                tyBump = min( (h + CARD_HEIGHT - locOri.y + a*(c-locOri.z)*(c-locOri.z))\/locDir.y ,\n                              (h - CARD_HEIGHT - locOri.y + a*(c-locOri.z)*(c-locOri.z))\/locDir.y );\n                \n            } else {\n                float tempA1 = sqr(locDir.y) + 4.0*a*locDir.y*locDir.z*(c-locOri.z);\n                float delta1 = tempA1 + tempA2*(locOri.y-(h+CARD_HEIGHT));\n                float delta2 = tempA1 + tempA2*(locOri.y-(h-CARD_HEIGHT));\n                \n                float temp1 = INFINITY;\n                float temp2 = INFINITY;\n                float tempB1 = locDir.y + 2.0*a*locDir.z*(c-locOri.z);\n                if(delta1 >= 0.0) {            \n                    float tempB2 = sqrt(delta1);\n                    float t1 = (tempB1 + tempB2)\/tempB3;\n                    if(t1 < 0.0) {t1 = INFINITY;}\n                    else {\n                        vec3 interBump = locOri + t1*locDir;\n                        if( !(abs(interBump.x)<=CARD_WIDTH && abs(interBump.z - c) <= bounceSize && interBump.z >= zBegin && interBump.z <= zEnd) ) {t1 = INFINITY;}\n                    }\n                    float t2 = (tempB1 - tempB2)\/tempB3;\n                    if(t2 < 0.0) {t2 = INFINITY;}\n                    else {\n                        vec3 interBump = locOri + t2*locDir;\n                        if( !(abs(interBump.x)<=CARD_WIDTH && abs(interBump.z - c) <= bounceSize && interBump.z >= zBegin && interBump.z <= zEnd) ) {t2 = INFINITY;}\n                    }\n                                        \n                    temp1 = min( t1, t2 );\n                }\n                if(delta2 >= 0.0) {\n                    float tempB2 = sqrt(delta2);\n                    float t1 = (tempB1 + tempB2)\/tempB3;\n                    if(t1 < 0.0) {t1 = INFINITY;}\n                    else {\n                        vec3 interBump = locOri + t1*locDir;\n                        if( !(abs(interBump.x)<=CARD_WIDTH && abs(interBump.z - c) <= bounceSize && interBump.z >= zBegin && interBump.z <= zEnd) ) {t1 = INFINITY;}\n                    }\n                    float t2 = (tempB1 - tempB2)\/tempB3;\n                    if(t2 < 0.0) {t2 = INFINITY;}\n                    else {\n                        vec3 interBump = locOri + t2*locDir;\n                        if( !(abs(interBump.x)<=CARD_WIDTH && abs(interBump.z - c) <= bounceSize && interBump.z >= zBegin && interBump.z <= zEnd) ) {t2 = INFINITY;}\n                    }\n                                        \n                    temp2 = min( t1, t2 );\n                }\n                \n                tyBump = min( temp1, temp2 );\n                \n            }\n            \n            vec3 interBump = locOri + tyBump*locDir;\n            if( abs(interBump.x)<=CARD_WIDTH && abs(interBump.z - c) <= bounceSize ) {\n                ty = min(ty, tyBump);\n            }\n            \n            h *= BUMP_HEIGHT_FACTOR;\n            c += bounceSize;\n            bounceSize = sqrt(h\/bounceHeight*bssSqrDiv4);\n            c += bounceSize;\n            \n        }\n        \n        interY = locOri + ty*locDir;\n        if(!( abs(interY.x)<=CARD_WIDTH && zBegin<=interY.z && interY.z<=zEnd)) {ty = INFINITY;}\n    }\n                \n    float minT = multiMin3(tx,ty,tz);\n    if(minT > INFINITY\/2.0) {res.dist = -1.0; return res;}\n    vec3 interBounding = locOri + minT*locDir;\n    \n   \n    \n    \/\/=============================================\n    \/\/ if intersects with bounding volume, refine intersections by looking at the neighboring card slices.\n        \n    float tCard = INFINITY;\n    int material = -1;\n    \n    \n    \/\/ refine intersection in x\n    if( tx < INFINITY\/2.0 ) {\n        if( abs(interX.y-bounceFloor(interX.z-0.5*(-1.0+sign(locDir.z))\/CARD_DENSITY,bounceHeight,bounceStepSize))<=CARD_HEIGHT ) {\n            tCard = min(tCard, tx);\n            material = MATERIAL_CARD_SIDE_XM;\n        }\n    }\n    \n    \n    \/\/ refine intersection in z\n    if( tz < INFINITY\/2.0 ) {\n        if( abs(interZ.y-bounceFloor(interZ.z,bounceHeight,bounceStepSize))<=CARD_HEIGHT ) {\n            tCard = min(tCard, tz);\n            if(locDir.z<=0.0) {material = MATERIAL_CARD_FACE;}\n            else              {material = MATERIAL_CARD_BACK;}\n        }\n    }\n    \n\n    \n    \n    \/\/ refine intersection in y by looking at neighboring cards.\n    int zFloored = int(floor(EPSILON+interBounding.z*CARD_DENSITY));\n    for(int i=-NB_MARCH_LAYERS; i<=NB_MARCH_LAYERS; i++) {\n        \n        int iSlice = zFloored + int(sign(-locDir.z))*i;\n        \n        float prevZ = (float(iSlice-int(sign(locDir.z)))\/CARD_DENSITY);\n        float thisZ = (float(iSlice  )\/CARD_DENSITY);\n        \n        if(thisZ < zBegin || thisZ > zEnd) {continue;}\n        float prevY, thisY;\n        \n        prevY = bounce(prevZ,bounceHeight,bounceStepSize) + CARD_HEIGHT;\n        thisY = bounce(thisZ,bounceHeight,bounceStepSize) + CARD_HEIGHT;\n         \n        float maxPrevThisY = max(prevY,thisY);\n        float minPrevThisY = min(prevY,thisY);\n        float maxPrevThisZ = max(prevZ,thisZ);\n        float minPrevThisZ = min(prevZ,thisZ);\n        \n        \/\/ top of card\n        if(abs(locDir.y) > EPSILON) {\n            ty = ( minPrevThisY - locOri.y )\/locDir.y;\n            interY = locOri + ty*locDir;\n            if( ty >= 0.0 && minPrevThisZ<=interY.z && interY.z<=maxPrevThisZ && abs(interY.x)<=CARD_WIDTH ) {\n                if(ty < tCard) {\n                    tCard = ty;\n                    material = MATERIAL_CARD_SIDE_YM;\n                }\n            }\n        }\n        \n        \/\/ vertical wall\n        if(abs(locDir.z) > EPSILON) {\n            tz = ( thisZ - locOri.z )\/locDir.z;\n            interZ = locOri + tz*locDir;\n            if( tz >= 0.0 && minPrevThisY<=interZ.y && interZ.y<=maxPrevThisY && abs(interZ.x)<=CARD_WIDTH ) {\n                if(tz < tCard) {\n                    tCard = tz;\n                    if(locDir.z<=0.0) {material = MATERIAL_CARD_FACE;}\n                    else              {material = MATERIAL_CARD_BACK;}\n                }\n            }\n        }\n        \n        prevY = bounce(prevZ,bounceHeight,bounceStepSize) - CARD_HEIGHT;\n        thisY = bounce(thisZ,bounceHeight,bounceStepSize) - CARD_HEIGHT;\n        maxPrevThisY = max(prevY,thisY);\n        minPrevThisY = min(prevY,thisY);\n        \n        \/\/ top of card\n        if(abs(locDir.y) > EPSILON) {\n            ty = ( maxPrevThisY - locOri.y )\/locDir.y;\n            interY = locOri + ty*locDir;\n            if( ty >= 0.0 && minPrevThisZ<=interY.z && interY.z<=maxPrevThisZ && abs(interY.x)<=CARD_WIDTH ) {\n                if(ty < tCard) {\n                    tCard = ty;\n                    material = MATERIAL_CARD_SIDE_YM;\n                }\n                \n            }\n        }\n        \n        \/\/ vertical wall\n        if(abs(locDir.z) > EPSILON) {\n            tz = ( thisZ - locOri.z )\/locDir.z;\n            interZ = locOri + tz*locDir;\n            if( tz >= 0.0 && minPrevThisY<=interZ.y && interZ.y<=maxPrevThisY && abs(interZ.x)<=CARD_WIDTH ) {\n                if(tz < tCard) {\n                    tCard = tz;\n                    if(locDir.z<0.0) {material = MATERIAL_CARD_FACE;}\n                    else              {material = MATERIAL_CARD_BACK;}\n                }\n            }\n        }\n    }\n    \n    if(tCard > INFINITY\/2.0) {res.dist = -1.0;}\n    else{\n        vec3 interCard = locOri + tCard*locDir;\n        res.dist = tCard;\n        res.material = material;\n        \n        if(material == MATERIAL_CARD_SIDE_XM) {\n            if(locDir.x >= 0.0) {\n                res.material = MATERIAL_CARD_SIDE_XP;\n                res.normal = x;\n                res.uvw = vec3(interCard.x, interCard.y, interCard.z);\n            } else {\n                res.material = MATERIAL_CARD_SIDE_XM;\n                res.normal = -x;\n                res.uvw = vec3(interCard.x, interCard.y, interCard.z);\n            }\n        } else if(material == MATERIAL_CARD_SIDE_YM) {\n            if(locDir.y >= 0.0) {\n                res.material = MATERIAL_CARD_SIDE_YM;\n                res.normal = y;\n                res.uvw = vec3(interCard.x, interCard.y, interCard.z);\n            } else {\n                res.material = MATERIAL_CARD_SIDE_YP;\n                res.normal = -y;\n                res.uvw = vec3(interCard.x, interCard.y, interCard.z);\n            }\n        } else if(material==MATERIAL_CARD_FACE) {\n            res.normal = z;\n            res.uvw = vec3(interCard.x, interCard.y-bounceFloor(interCard.z,bounceHeight,bounceStepSize), interCard.z);\n        } else if(material == MATERIAL_CARD_BACK) {\n            res.normal = -z;\n            res.uvw = vec3(interCard.x, interCard.y-bounceFloor(interCard.z,bounceHeight,bounceStepSize), interCard.z);\n        }\n    }    \n    \n    return res;\n}\n\n\/\/ 1 to 13 is number+JQK\nvec3 cardSymbol(vec2 uv, int id, vec2 center, float size, int suitColor) {\n    vec3 color = vec3(1.0);\n    \n    float x = (uv.x - center.x)\/size;\n    float y = (uv.y - center.y)\/size;\n        \n    float phi = -1.0;\n    if(id==1) {\n        phi = multiMin4(1.4-2.8*x-y,1.4+2.8*x-y,2.8+2.0*y,-max(multiMin3(0.075-0.67*x-0.178571*y,0.075+0.67*x-0.178571*y,0.0892857+0.357143*y),multiMin4(-0.401786-0.535714*y,-1.15*x-0.410714*y,1.15*x-0.410714*y,2.57857+1.35714*y)));\n    } else if(id==2) {\n        float t1 = 0.937994*(1.4+y);\n        float t2 = 0.75*(1.0+x);\n        float t3 = sqr(-0.75+(t2));\n        float t4 = sqr(-1.87638+(t1));\n          phi = multiMax3(multiMin3(1.0-1.77778*(t3)-1.77778*(t4),-1.0+16.0*(t3)+16.0*(t4),-min(1.87638-(t1),-0.951057*(-0.75+(t2))-0.309017*(-1.87638+(t1)))),multiMin4(1.0-1.33333*(-0.75+(t2)),1.0+1.33333*(-0.75+(t2)),1.0-4.0*(-0.25+(t1)),1.0+4.0*(-0.25+(t1))),multiMin4(-0.5+(t1),-0.951057*(-1.19721+(t2))-0.309017*(-0.5+(t1)),1.0-0.697681*(-1.19721+(t2))*(-1.19721+(t2))-0.697681*(-0.5+(t1))*(-0.5+(t1)),-1.0+2.05716*(-1.19721+(t2))*(-1.19721+(t2))+2.05716*(-0.5+(t1))*(-0.5+(t1))));\n    } else if(id==3) {\n        float t1 = sqr(x);\n          phi = max(multiMin3(0.489796-(t1)+(-1.74927-1.49938*y)*y,1.77778+5.44444*(t1)+y*(9.52381+8.16327*y),-min(0.-1.4*x,1.+1.71429*y)),multiMin3(0.489796-(t1)+(1.74927-1.49938*y)*y,1.77778+5.44444*(t1)+y*(-9.52381+8.16327*y),-min(0.-1.4*x,1.-1.71429*y)));\n    } else if(id==4) {\n           phi = min(multiMax3(multiMin4(3.16667-4.16667*x,-1.16667+4.16667*x,-0.333333-1.66667*y,2.33333+1.66667*y),multiMin4(2.77778-2.77778*x,-0.777778+2.77778*x,-0.833333-4.16667*y,2.83333+4.16667*y),multiMin5(2.47-3.25*x,0.990349+0.990349*x,2.18512+2.25965*x-1.61404*y,1.59035-1.13596*y,1.87+2.75*y)),-multiMin3(0.49-1.75*x,0.66+1.75*x-1.25*y,0.25+1.25*y));\n    } else if(id==5) {\n        float t1 = sqr(-0.7+0.714286*(1.4+y));\n        float t2 = 2.85714*(-0.35+0.7*(1.0+x));\n        float t3 = 2.0*(-1.5+0.714286*(1.4+y));\n        float t4 = 1.42857*(-0.7+0.7*(1.0+x));\n        float t5 = 5.0*(-0.2+0.7*(1.0+x));\n        float t6 = 5.0*(-1.8+0.714286*(1.4+y));\n        float t7 = 5.0*(-1.2+0.714286*(1.4+y));\n        phi = multiMax4(multiMin3(1.0-2.04082*sqr(-0.7+0.7*(1.0+x))-2.04082*(t1),-1.0+11.1111*sqr(-0.7+0.7*(1.0+x))+11.1111*(t1),-min(-1.0*(-0.7+0.7*(1.0+x)),-0.7+0.714286*(1.4+y))),multiMin4(1.0-(t4),1.0+(t4),1.0-(t6),1.0+(t6)),multiMin4(1.0-(t2),1.0+(t2),1.0-(t7),1.0+(t7)),multiMin4(1.0-(t5),1.0+(t5),1.0-(t3),1.0+(t3)));\n    } else if(id==6) {\n        float t1 = sqr(x);\n        phi = max(min(-0.280411-(t1)+(-3.44566-2.31812*y)*y,5.97113+5.44444*(t1)+y*(18.7597+12.6209*y)),multiMin4(0.240625+0.34658*x-0.156326*y,0.165609-0.118292*y,0.0713646+0.0303719*x+0.0960231*y,-0.0346321-0.376951*x+0.178595*y));\n    } else if(id==7) {\n        phi = max(multiMin4(1.-x,1.+x,5.6-4.0*y,-3.6+4.0*y),multiMin4(1.20252-0.364399*x-0.931243*y,-0.103283+0.931243*x-0.364399*y,0.603283-0.931243*x+0.364399*y,1.4+y));\n    } else if(id==8) {\n        float t1 = sqr(x);\n        phi = max(min(0.489796-(t1)+(-1.74927-1.49938*y)*y,1.77778+5.44444*(t1)+y*(9.52381+8.16327*y)),min(0.489796-(t1)+(1.74927-1.49938*y)*y,1.77778+5.44444*(t1)+y*(-9.52381+8.16327*y)));\n    } else if(id==9) {\n        float t1 = sqr(x);\n        phi = max(min(-0.280411-(t1)+(3.44566-2.31812*y)*y,5.97113+5.44444*(t1)+y*(-18.7597+12.6209*y)),multiMin4(-0.0346321+0.376951*x-0.178595*y,0.0713646-0.0303719*x-0.0960231*y,0.165609+0.118292*y,0.240625-0.34658*x+0.156326*y));\n    } else if(id==10) {\n        phi = max(min(0.816327+(1.22449-2.04082*x)*x-0.510204*sqr(y),x*(-6.66667+11.1111*x)+2.77778*y*y),multiMin4(-3.-5.0*x,5.+5.0*x,1.-0.714286*y,1.+0.714286*y));\n    } else if(id==11) {\n        phi = multiMax3(multiMin3(-0.55-1.39286*y,0.825255+(-0.326531-1.30612*x)*x+(-0.781706-0.989822*y)*y,-0.0486111+x*(1.77778+7.11111*x)+y*(4.25595+5.38903*y)),multiMin4(3.-4.0*x,-1.+4.0*x,1.56-1.11429*y,0.44+1.11429*y),multiMin4(1.3913-1.3913*x,0.608696+1.3913*x,4.875-3.48214*y,-2.875+3.48214*y));\n    } else if(id==12) {\n        phi = max(min(0.998283+(-0.0862742-1.08456*x)*x+(0.00145184-0.511241*y)*y,-0.995231+x*(0.23965+3.01266*x)+y*(-0.00403288+1.42011*y)),multiMin4(-0.0868019-1.1716*x-1.12614*y,-0.193198+0.460248*x-0.44239*y,0.829594-0.460248*x+0.44239*y,0.723198+1.1716*x+1.12614*y));\n    } else if(id==13) {\n        phi = multiMax3(multiMin4(-2.24012-4.24012*x,4.24012+4.24012*x,1.-0.714286*y,1.+0.714286*y),multiMin4(1.06003+1.06003*x-0.928571*y,0.820061-0.585758*y,0.+0.585758*y,-0.23997-1.06003*x+0.928571*y),multiMin4(-0.23997-1.06003*x-0.928571*y,0.-0.585758*y,0.820061+0.585758*y,1.06003+1.06003*x+0.928571*y));\n    }\n    \n    if(phi>=0.0) {\n        color.r = suitColor==1?1.0:0.0;\n        color.g = 0.0;\n        color.b = 0.0;\n    }\n    \n    return color;\n}\n\n\n\/\/ 1=diamond, 2=heart, 3=spade, 4=club\nvec3 cardSuit(vec2 uv, int id, vec2 center, float size) {\n    vec3 color = vec3(1.0);\n    \n    float x = (uv.x - center.x)\/size;\n    float y = (uv.y - center.y)\/size;\n    \n    float phi = -1.0;\n    if(id==1) {\n        phi = multiMin4(1.4-1.4*x-y,1.4+1.4*x-y,1.4-1.4*x+y,1.4+1.4*x+y);\n    } else if(id==2) {\n           phi = multiMax3(0.202435+(-2.41421-2.91421*x)*x+(1.21619-1.24268*y)*y,0.202435+(2.41421-2.91421*x)*x+(1.21619-1.24268*y)*y,multiMin3(-0.114277-0.788252*y,1.11428-1.20711*x+0.788252*y,1.11428+1.20711*x+0.788252*y));\n    } else if(id==3) {\n        float t1 = (0.064261+0.298355*y)*y;\n        float t2 = (-0.742857-1.72449*y)*y;\n        phi = multiMax4(0.42+(2.41421-2.91421*x)*x+(t2),0.42+(-2.41421-2.91421*x)*x+(t2),multiMin3(1.3-1.20711*x-0.928571*y,1.3+1.20711*x-0.928571*y,-0.3+0.928571*y),multiMin6(1.8-1.20711*x,1.8+1.20711*x,0.3-0.928571*y,1.3+0.928571*y,0.124567+(-1.50366+0.504189*x)*x+(t1),0.124567+(1.50366+0.504189*x)*x+(t1)));\n    } else if(id==4) {\n        phi = multiMax4(-1.22851-3.48205*x*x+(5.31619-3.17049*y)*y,0.249948+(-3.23205-3.48205*x)*x+(-0.0255681-3.17049*y)*y,0.249948+(3.23205-3.48205*x)*x+(-0.0255681-3.17049*y)*y,multiMin6(1.8-x,1.8+x,0.264102-0.954213*y,1.3359+0.954213*y,0.127498+(-1.24567+0.346021*x)*x+(0.0897412+0.31506*y)*y,0.127498+(1.24567+0.346021*x)*x+(0.0897412+0.31506*y)*y));\n    }\n    \n    if(phi>=0.0) {\n        color.r = id<3?1.0:0.0;\n        color.g = 0.0;\n        color.b = 0.0;\n    }\n    \n    return color;\n}\n\n\/\/ faces for jack, queen and king.\nvec3 cardHead(vec2 uv, int id, vec2 center, float size) {\n    vec3 color = vec3(1.0);\n    \n    float x = (uv.x - center.x)\/size;\n    float y = (uv.y - center.y)\/size;\n    \n    if(id==11) {\n        \/\/ face\n        if( 1.0-2.04082*x*x-2.77778*y*y >= 0.0) {\n            color = vec3(1.0, 215.0\/255.0, 140.0\/255.0);\n        }\n        \/\/ eyes\n        if( max(1.0-816.327*(-0.2+x)*(-0.2+x)-816.327*(-0.1+y)*(-0.1+y),1.0-816.327*(0.2+x)*(0.2+x)-816.327*(-0.1+y)*(-0.1+y)) >= 0.0 ) {\n            color = vec3(0.0);\n        }\n        \/\/ hair\n        if( multiMax5(min(1.0-44.4444*sqr(0.2+x)-44.4444*sqr(0.15+-0.37+y),-1.0+25.0*sqr(0.2+x)+25.0*sqr(0.25-0.37+y)),min(1.0-44.4444*sqr(-0.2+x)-44.4444*sqr(0.15-0.25+y),-1.0+25.0*sqr(-0.2+x)+25.0*sqr(0.25-0.25+y)),min(1.0-25.0*sqr(0.2+0.29552*(-0.2+x)-0.955336*(0.35+y))-25.0*sqr(-0.955336*(-0.2+x)-0.29552*(0.35+y)),-1.0+20.6612*sqr(0.25+0.29552*(-0.2+x)-0.955336*(0.35+y))+20.6612*sqr(-0.955336*(-0.2+x)-0.29552*(0.35+y))),min(1.0-25.0*sqr(0.2-0.29552*(0.2+x)-0.955336*(0.35+y))-25.0*sqr(-0.955336*(0.2+x)+0.29552*(0.35+y)),-1.0+20.6612*sqr(0.25-0.29552*(0.2+x)-0.955336*(0.35+y))+20.6612*sqr(-0.955336*(0.2+x)+0.29552*(0.35+y))),multiMin4(0.2-x,0.2+x,-0.5-y,0.8+y-abs(-0.1+mod(-0.1+x,0.2)))) >= 0.0 ) {\n            color = vec3(163.0\/255.0, 107.0\/255.0, 2.0\/255.0);\n        }\n        \/\/ crown\n        if( multiMin4(0.5-x,0.5+x,-0.4+y,0.7-y+abs(-0.1+mod(-0.1+x,0.2))) >= 0.0 ) {\n            color = vec3(1.0,234.0\/255.0,0.0);\n        }\n        \n    } else if(id==12) {\n           \/\/ face\n        if( 1.0-2.04082*x*x-2.77778*y*y >= 0.0) {\n            color = vec3(1.0, 215.0\/255.0, 140.0\/255.0);\n        }\n        \/\/ eyes\n        if( max(1.0-816.327*(-0.2+x)*(-0.2+x)-816.327*(-0.1+y)*(-0.1+y),1.0-816.327*(0.2+x)*(0.2+x)-816.327*(-0.1+y)*(-0.1+y)) >= 0.0 ) {\n            color = vec3(0.0);\n        }\n        \/\/ hair\n        if( multiMax4(min(-1.0+1.5625*sqr(0.62161*(-0.6+x)-0.783327*(-0.35+y))+1.5625*sqr(0.9+0.783327*(-0.6+x)+0.62161*(-0.35+y)),1.0-1.77778*sqr(0.62161*(-0.6+x)-0.783327*(-0.35+y))-1.77778*sqr(0.75+0.783327*(-0.6+x)+0.62161*(-0.35+y)-0.05*(1.0+cos(10.0*PI*(0.62161*(-0.6+x)-0.783327*(-0.35+y)))))),min(-1.0+1.5625*sqr(0.9-0.783327*(0.6+x)+0.62161*(-0.35+y))+1.5625*sqr(0.62161*(0.6+x)+0.783327*(-0.35+y)),1.0-1.77778*sqr(0.62161*(0.6+x)+0.783327*(-0.35+y))-1.77778*sqr(0.75-0.783327*(0.6+x)+0.62161*(-0.35+y)-0.05*(1.0+cos(10.0*PI*(0.62161*(0.6+x)+0.783327*(-0.35+y)))))),min(1.0-16.0*sqr(0.955336*(-0.25+x)-0.29552*(-0.3+y))-16.0*sqr(0.25+0.29552*(-0.25+x)+0.955336*(-0.3+y)),-1.0+sqr(0.955336*(-0.25+x)-0.29552*(-0.3+y))+ sqr(1.05+0.29552*(-0.25+x)+0.955336*(-0.3+y))),min(1.0-16.0*sqr(0.955336*(0.25+x)+0.29552*(-0.3+y))-16.0*sqr(0.25-0.29552*(0.25+x)+0.955336*(-0.3+y)),-1.0+sqr(0.955336*(0.25+x)+0.29552*(-0.3+y))+sqr(1.05-0.29552*(0.25+x)+0.955336*(-0.3+y)))) >= 0.0 ) {\n            color = vec3(163.0\/255.0, 107.0\/255.0, 2.0\/255.0);\n        }\n        \/\/ lips\n        if( multiMax3(min(1.0-8.16327*x*x-8.16327*sqr(-0.07-y),-1.0+2.77778*x*x+2.77778*sqr(0.23-y)),min(1.0-59.1716*sqr(0.995004*(-0.12+x)+0.0998334*(0.24+y))-59.1716*sqr(0.13-0.0998334*(-0.12+x)+0.995004*(0.24+y)),-1.0+25.0*sqr(0.995004*(-0.12+x)+0.0998334*(0.24+y))+25.0*sqr(0.24-0.0998334*(-0.12+x)+0.995004*(0.24+y))),min(1.0-59.1716*sqr(0.995004*(0.12+x)-0.0998334*(0.24+y))-59.1716*sqr(0.13+0.0998334*(0.12+x)+0.995004*(0.24+y)),-1.0+25.0*sqr(0.995004*(0.12+x)-0.0998334*(0.24+y))+25.0*sqr(0.24+0.0998334*(0.12+x)+0.995004*(0.24+y)))) >= 0.0 ) {\n            color = vec3(1.0, 61.0\/255.0, 61.0\/255.0);\n        }\n        \/\/ crown\n        if( multiMin4(0.5-x, 0.5+x, -0.45+y, 0.75-y+abs(-0.1+mod(-0.1+x,0.2))) >= 0.0 ) {\n            color = vec3(1.0,234.0\/255.0,0.0);\n        }\n    } else if(id==13) {\n        \/\/ face\n        if( 1.0-2.04082*x*x-2.77778*y*y >= 0.0) {\n            color = vec3(1.0, 215.0\/255.0, 140.0\/255.0);\n        }\n        \/\/ eyes\n        if( max(1.0-816.327*(-0.2+x)*(-0.2+x)-816.327*(-0.1+y)*(-0.1+y),1.0-816.327*(0.2+x)*(0.2+x)-816.327*(-0.1+y)*(-0.1+y)) >= 0.0 ) {\n            color = vec3(0.0);\n        }\n        \/\/ hair\n        if( multiMax5(min(1.0-44.4444*sqr(0.877583*(-0.15+x)+0.479426*(-0.3+y))-44.4444*sqr(0.15-0.479426*(-0.15+x)+0.877583*(-0.3+y)),-1.0+sqr(0.877583*(-0.15+x)+0.479426*(-0.3+y))+sqr(1.1-0.479426*(-0.15+x)+0.877583*(-0.3+y))),min(1.0-44.4444*sqr(0.877583*(0.15+x)-0.479426*(-0.3+y))-44.4444*sqr(0.15+0.479426*(0.15+x)+0.877583*(-0.3+y)),-1.0+sqr(0.877583*(0.15+x)-0.479426*(-0.3+y))+sqr(1.1+0.479426*(0.15+x)+0.877583*(-0.3+y))),min(-1.0+ x*x+sqr(0.53-y),1.0-2.04082*x*x-2.04082*sqr(0.03-y-0.05*(1.0+cos(10.0*PI*x)))),min(1.0-25.0*sqr(0.2+0.29552*(-0.24+x)-0.955336*(0.35+y))-25.0*sqr(-0.955336*(-0.24+x)-0.29552*(0.35+y)),-1.0+11.1111*sqr(0.4+0.29552*(-0.24+x)-0.955336*(0.35+y))+11.1111*sqr(-0.955336*(-0.24+x)-0.29552*(0.35+y))),min(1.0-25.0*sqr(0.2-0.29552*(0.24+x)-0.955336*(0.35+y))-25.0*sqr(-0.955336*(0.24+x)+0.29552*(0.35+y)),-1.0+11.1111*sqr(0.4-0.29552*(0.24+x)-0.955336*(0.35+y))+11.1111*sqr(-0.955336*(0.24+x)+0.29552*(0.35+y)))) >= 0.0 ) {\n            color = vec3(166.0\/255.0, 166.0\/255.0, 166.0\/255.0);\n        }\n        \/\/ crown\n        if( multiMin4(0.5 -x,0.5 +x,-0.4+y,0.7 -y+abs(-0.1+mod(-0.1+x,0.2))) >= 0.0 ) {\n            color = vec3(1.0,234.0\/255.0,0.0);\n        }\n    }\n    \n    return color;\n}\n\n\n#ifdef COMPILE_PATTERNS\n\n\/\/ check if point is inside box, return position inside box mappd to [1.0, 1.4], return vec2(infinity) if outside.\nvec2 isInsideBox(vec2 uv, vec2 center, float size) {\n    vec2 newUV = (uv - center)\/size;\n    if(abs(newUV.x) <= CARD_WIDTH && abs(newUV.y) <= CARD_HEIGHT) {return newUV;}\n    else {return vec2(INFINITY);}\n}\n\n\n\/\/ patterns in center of number cards\nvec3 cardPattern(vec2 uv, int number, int suit, int suitColor) {\n    vec3 color = vec3(1.0);\n    vec2 newUV = vec2(INFINITY);\n    \n    \/\/return color;\n    \n    \/*\n    if(number==1) {\n        color = min(color, cardSuit(uv, suit, vec2(0.0,0.0), 0.5));\n    } else if(number==2) {\n        color = min(color, cardSuit(uv, suit, vec2(0.0,-0.5), 0.25));\n        color = min(color, cardSuit(uv, suit, vec2(0.0,0.5), 0.25));\n    } else if(number==3) {\n        color = min(color, cardSuit(uv, suit, vec2(0.0,-0.7), 0.2));\n        color = min(color, cardSuit(uv, suit, vec2(0.0,0.0), 0.2));\n        color = min(color, cardSuit(uv, suit, vec2(0.0,0.7), 0.2));\n    } else if(number==4) {\n        color = min(color, cardSuit(uv, suit, vec2(-0.25,-0.5), 0.2));\n        color = min(color, cardSuit(uv, suit, vec2(-0.25, 0.5), 0.2));\n        color = min(color, cardSuit(uv, suit, vec2( 0.25,-0.5), 0.2));\n        color = min(color, cardSuit(uv, suit, vec2( 0.25, 0.5), 0.2));\n    } else if(number==5) {\n        color = min(color, cardSuit(uv, suit, vec2(-0.3,-0.55), 0.2));\n        color = min(color, cardSuit(uv, suit, vec2(-0.3, 0.55), 0.2));\n        color = min(color, cardSuit(uv, suit, vec2( 0.0,0.0), 0.2));\n        color = min(color, cardSuit(uv, suit, vec2( 0.3, -0.55), 0.2));\n        color = min(color, cardSuit(uv, suit, vec2( 0.3, 0.55), 0.2));\n    } else if(number==6) {\n        color = min(color, cardSuit(uv, suit, vec2(-0.3,-0.65), 0.18));\n        color = min(color, cardSuit(uv, suit, vec2(-0.3, 0.0), 0.18));\n        color = min(color, cardSuit(uv, suit, vec2(-0.3, 0.65), 0.18));\n        color = min(color, cardSuit(uv, suit, vec2(0.3, -0.65), 0.18));\n        color = min(color, cardSuit(uv, suit, vec2(0.3, 0.0), 0.18));\n        color = min(color, cardSuit(uv, suit, vec2(0.3, 0.65), 0.18));\n    } else if(number==7) {\n        color = min(color, cardSuit(uv, suit, vec2(-0.3,-0.7), 0.15));\n        color = min(color, cardSuit(uv, suit, vec2(-0.3, 0.0), 0.15));\n        color = min(color, cardSuit(uv, suit, vec2(-0.3, 0.7), 0.15));\n        color = min(color, cardSuit(uv, suit, vec2(0.3, -0.7), 0.15));\n        color = min(color, cardSuit(uv, suit, vec2(0.3, 0.0), 0.15));\n        color = min(color, cardSuit(uv, suit, vec2(0.3, 0.7), 0.15));\n        color = min(color, cardSuit(uv, suit, vec2(0.0, 0.35), 0.15));\n    } else if(number==8) {\n        color = min(color, cardSuit(uv, suit, vec2(-0.3,-0.7), 0.15));\n        color = min(color, cardSuit(uv, suit, vec2(-0.3, 0.0), 0.15));\n        color = min(color, cardSuit(uv, suit, vec2(-0.3, 0.7), 0.15));\n        color = min(color, cardSuit(uv, suit, vec2(0.3, -0.7), 0.15));\n        color = min(color, cardSuit(uv, suit, vec2(0.3, 0.0), 0.15));\n        color = min(color, cardSuit(uv, suit, vec2(0.3, 0.7), 0.15));\n        color = min(color, cardSuit(uv, suit, vec2(0.0, 0.35), 0.15));\n        color = min(color, cardSuit(uv, suit, vec2(0.0, -0.35), 0.15));\n    } else if(number==9) {\n        color = min(color, cardSuit(uv, suit, vec2(-0.3,-0.7), 0.12));\n        color = min(color, cardSuit(uv, suit, vec2(-0.3,-0.23), 0.12));\n        color = min(color, cardSuit(uv, suit, vec2(-0.3, 0.23), 0.12));\n        color = min(color, cardSuit(uv, suit, vec2(-0.3, 0.7), 0.12));\n        color = min(color, cardSuit(uv, suit, vec2( 0.3,-0.7), 0.12));\n        color = min(color, cardSuit(uv, suit, vec2( 0.3,-0.23), 0.12));\n        color = min(color, cardSuit(uv, suit, vec2( 0.3, 0.23), 0.12));\n        color = min(color, cardSuit(uv, suit, vec2( 0.3, 0.7), 0.12));\n        color = min(color, cardSuit(uv, suit, vec2( 0.0, 0.0), 0.12));\n    } else if(number==10) {\n        color = min(color, cardSuit(uv, suit, vec2(-0.3,-0.7), 0.12));\n        color = min(color, cardSuit(uv, suit, vec2(-0.3,-0.23), 0.12));\n        color = min(color, cardSuit(uv, suit, vec2(-0.3, 0.23), 0.12));\n        color = min(color, cardSuit(uv, suit, vec2(-0.3, 0.7), 0.12));\n        color = min(color, cardSuit(uv, suit, vec2( 0.3,-0.7), 0.12));\n        color = min(color, cardSuit(uv, suit, vec2( 0.3,-0.23), 0.12));\n        color = min(color, cardSuit(uv, suit, vec2( 0.3, 0.23), 0.12));\n        color = min(color, cardSuit(uv, suit, vec2( 0.3, 0.7), 0.12));\n        color = min(color, cardSuit(uv, suit, vec2( 0.0, -0.45), 0.12));\n        color = min(color, cardSuit(uv, suit, vec2( 0.0, 0.45), 0.12));\n    }\n    *\/\n    \n    if(number==1) {\n        newUV = min(newUV,isInsideBox(uv, vec2(0.0,0.0), 0.5));\n    } else if(number==2) {\n        newUV = min(newUV,isInsideBox(uv, vec2(0.0,-0.5), 0.25));\n        newUV = min(newUV,isInsideBox(uv, vec2(0.0,0.5), 0.25));\n    } else if(number==3) {\n        newUV = min(newUV,isInsideBox(uv, vec2(0.0,-0.7), 0.2));\n        newUV = min(newUV,isInsideBox(uv, vec2(0.0,0.0), 0.2));\n        newUV = min(newUV,isInsideBox(uv, vec2(0.0,0.7), 0.2));\n    } else if(number==4) {\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.25,-0.5), 0.2));\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.25, 0.5), 0.2));\n        newUV = min(newUV,isInsideBox(uv, vec2( 0.25,-0.5), 0.2));\n        newUV = min(newUV,isInsideBox(uv, vec2( 0.25, 0.5), 0.2));\n    } else if(number==5) {\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.3,-0.55), 0.2));\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.3, 0.55), 0.2));\n        newUV = min(newUV,isInsideBox(uv, vec2( 0.0,0.0), 0.2));\n        newUV = min(newUV,isInsideBox(uv, vec2( 0.3, -0.55), 0.2));\n        newUV = min(newUV,isInsideBox(uv, vec2( 0.3, 0.55), 0.2));\n    } else if(number==6) {\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.3,-0.65), 0.18));\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.3, 0.0), 0.18));\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.3, 0.65), 0.18));\n        newUV = min(newUV,isInsideBox(uv, vec2(0.3, -0.65), 0.18));\n        newUV = min(newUV,isInsideBox(uv, vec2(0.3, 0.0), 0.18));\n        newUV = min(newUV,isInsideBox(uv, vec2(0.3, 0.65), 0.18));\n    } else if(number==7) {\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.3,-0.7), 0.15));\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.3, 0.0), 0.15));\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.3, 0.7), 0.15));\n        newUV = min(newUV,isInsideBox(uv, vec2(0.3, -0.7), 0.15));\n        newUV = min(newUV,isInsideBox(uv, vec2(0.3, 0.0), 0.15));\n        newUV = min(newUV,isInsideBox(uv, vec2(0.3, 0.7), 0.15));\n        newUV = min(newUV,isInsideBox(uv, vec2(0.0, 0.35), 0.15));\n    } else if(number==8) {\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.3,-0.7), 0.15));\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.3, 0.0), 0.15));\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.3, 0.7), 0.15));\n        newUV = min(newUV,isInsideBox(uv, vec2(0.3, -0.7), 0.15));\n        newUV = min(newUV,isInsideBox(uv, vec2(0.3, 0.0), 0.15));\n        newUV = min(newUV,isInsideBox(uv, vec2(0.3, 0.7), 0.15));\n        newUV = min(newUV,isInsideBox(uv, vec2(0.0, 0.35), 0.15));\n        newUV = min(newUV,isInsideBox(uv, vec2(0.0, -0.35), 0.15));\n    } else if(number==9) {\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.3,-0.7), 0.12));\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.3,-0.23), 0.12));\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.3, 0.23), 0.12));\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.3, 0.7), 0.12));\n        newUV = min(newUV,isInsideBox(uv, vec2( 0.3,-0.7), 0.12));\n        newUV = min(newUV,isInsideBox(uv, vec2( 0.3,-0.23), 0.12));\n        newUV = min(newUV,isInsideBox(uv, vec2( 0.3, 0.23), 0.12));\n        newUV = min(newUV,isInsideBox(uv, vec2( 0.3, 0.7), 0.12));\n        newUV = min(newUV,isInsideBox(uv, vec2( 0.0, 0.0), 0.12));\n    } else if(number==10) {\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.3,-0.7), 0.12));\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.3,-0.23), 0.12));\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.3, 0.23), 0.12));\n        newUV = min(newUV,isInsideBox(uv, vec2(-0.3, 0.7), 0.12));\n        newUV = min(newUV,isInsideBox(uv, vec2( 0.3,-0.7), 0.12));\n        newUV = min(newUV,isInsideBox(uv, vec2( 0.3,-0.23), 0.12));\n        newUV = min(newUV,isInsideBox(uv, vec2( 0.3, 0.23), 0.12));\n        newUV = min(newUV,isInsideBox(uv, vec2( 0.3, 0.7), 0.12));\n        newUV = min(newUV,isInsideBox(uv, vec2( 0.0, -0.45), 0.12));\n        newUV = min(newUV,isInsideBox(uv, vec2( 0.0, 0.45), 0.12));\n    }\n\n\t\n    if(newUV.x < INFINITY\/2.0) {return min(vec3(1.0), cardSuit(newUV, suit, vec2(0.0,0.0), 1.0)); }\n    else {return vec3(1.0);}\n    \n    return color;\n}\n#endif\n\n\n\/\/ card front face\nvec4 cardFace(vec2 uv, int number, int suit, int borderTint) {\n    vec3 color = vec3(1);\n    float x = uv.x;\n    float y = uv.y;\n\n    color = vec3(1.0);\n    color = minVec3(color, cardSymbol(uv,number,vec2(-0.75,1.05),0.12, suit<3?1:0));\n    color = minVec3(color, cardSuit(uv,suit,vec2(-0.75,0.6),0.12));\n    color = minVec3(color, cardSymbol(-uv,number,vec2(-0.75,1.05),0.12, suit<3?1:0));\n    color = minVec3(color, cardSuit(-uv,suit,vec2(-0.75,0.6),0.12));\n\n    \n    \/\/ draw the face or the suit pattern\n    if( number==11 || number==12 || number==13 ) {\n        color = min(color, cardHead(uv,number,vec2(0.0,0.0),0.9));\n    } else {\n#ifdef COMPILE_PATTERNS\n        color = min(color, cardPattern(uv, number, suit, suit<3?1:0));\n#endif\n    }\n    \n    \n    \/\/ border\n    if(x<-CARD_WIDTH+CARD_BORDER_SIZE  || x>CARD_WIDTH-CARD_BORDER_SIZE ||\n       y<-CARD_HEIGHT+CARD_BORDER_SIZE || y>CARD_HEIGHT-CARD_BORDER_SIZE )\n    {\n        if(borderTint==1) {\n            color = vec3(CARD_BORDER_TINT1);\n        } else {\n            color = vec3(CARD_BORDER_TINT2);\n        }\n        \n    }\n    \n    return vec4(color, 1.0);\n}\n\n\n\/\/ card back face, based on the original Solitaire desing.\nvec4 cardBack(vec2 uv, int borderTint) {\n    \n    float x = uv.x;\n    float y = uv.y;\n    \n    \/\/ sky\n    vec4 color = vec4(0.0, 1.0, 1.0, 1.0);\n    \/\/ water\n    if(0.5 + 0.025*sin(PI*8.0*x) - y >= 0.0) {\n        color = vec4(0.0, 43.0\/255.0, 170.0\/255.0, 1.0);\n    }\n    \/\/ sand\n    if( -0.3 + 0.045*sin(PI*5.0*x - 0.6214) - y >= 0.0) {\n        color = vec4(1.0, 1.0, 111.0\/255.0, 1.0);\n    }\n    \/\/ sun\n    if( 1.0 - 25.0*(-0.6 + x)*(-0.6 + x) - 25.0*(-1.0 + y)*(-1.0 + y) >= 0.0 ) {\n        color = vec4(1.0, 1.0, 0.0, 1.0);\n    }\n    \/\/ tree\n    if( multiMin4(0.6-y, 1.05+y, 0.397485+(0.724928-0.25*x)*x + (-0.277479-0.25*y)*y, -0.217087+(-0.723458+0.173611*x)*x + (0.142472+0.173611*y)*y) >= 0.0 ) {\n        color = vec4(110.0\/255.0, 61.0\/255.0, 56.0\/255.0, 1.0);\n    }\n    \/\/ leaves\n    if( multiMax4(min(0.23242+(0.208239-8.16327*x)*x+(5.00205-8.16327*y)*y,-0.20324+x*(3.45391+6.25*x)+y*(-2.82657+6.25*y)),min(-4.32311+(-7.66587-8.16327*x)*x+(10.7262-8.16327*y)*y,1.82316+x*(6.44035+6.25*x)+y*(-5.39452+6.25*y)),min(0.0499321+(2.03551-6.25*x)*x+(4.42814-6.25*y)*y,-0.919179+x*(-0.616931+4.0*x)+y*(-0.955262+4.0*y)),min(0.0212551+(-3.72533-4.93827*x)*x+(2.33562-4.93827*y)*y,-0.910767+x*(1.07096+3.30579*x)+y*(-0.18162+3.30579*y))) >= 0.0 ) {\n        color = vec4(42.0\/255.0, 222.0\/255.0, 61.0\/255.0, 1.0);\n    }\n    \/\/ border\n    if(x<-CARD_WIDTH+CARD_BORDER_SIZE  || x>CARD_WIDTH-CARD_BORDER_SIZE ||\n       y<-CARD_HEIGHT+CARD_BORDER_SIZE || y>CARD_HEIGHT-CARD_BORDER_SIZE )\n    {\n        if(borderTint==1) {\n            color = vec4(vec3(CARD_BORDER_TINT1), 1.0);\n        } else {\n            color = vec4(vec3(CARD_BORDER_TINT2), 1.0);\n        }\n    }\n    \n    return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if( texture2D( iChannel0, vec2(65.5\/256.0,0.25)).x > 0.0 ) {\n        \n        \/\/=============================================\n        \/\/ if space is pressed : 2D mode\n        \n        vec2 uvScreen = vec2(fragCoord.xy\/iResolution.xy);\n        uvScreen = 1.4*(2.0*uvScreen - vec2(1.0))*iResolution.xy\/iResolution.y;\n    \n        fragColor = vec4(vec3(0.0,127.0\/255.0,9.0\/255.0),1.0);\n    \n        for(int i=0; i<14; i++) {\n            vec2 center = vec2( -2.1 + mod(float(i),7.0)*4.2\/6.0, (i<7?0.65:-0.65) );\n            vec2 uv = (uvScreen-center)*3.0;\n        \n               if(abs(uv.x)<=CARD_WIDTH && abs(uv.y)<=CARD_HEIGHT) {\n                fragColor = vec4(vec3(1.0), 1.0);\n            }\n        }\n    \n        for(int i=0; i<13; i++) {\n            vec2 center = vec2( -2.1 + mod(float(i),7.0)*4.2\/6.0, (i<7?0.65:-0.65) );\n            vec2 uv = (uvScreen-center)*3.0;\n            if(abs(uv.x)<=CARD_WIDTH && abs(uv.y)<=CARD_HEIGHT) {\n                vec3 color = cardFace(uv, i+1, int(mod(float(i),4.0))+1, 1).xyz;\n                fragColor = min(vec4(vec3(color),1.0),fragColor);\n            }\n        }\n        vec2 center = vec2( 2.1, -0.65 );\n        vec2 uv = (uvScreen-center)*3.0;\n        if(abs(uv.x)<=CARD_WIDTH && abs(uv.y)<=CARD_HEIGHT) {\n            vec3 color = cardBack(uv, 1).xyz;\n            fragColor = min(vec4(vec3(color),1.0),fragColor);\n        }\n        \n        \n        \n    } else {\n\t\t\n        \/\/=============================================\n        \/\/ if space is not pressed : 3D mode\n    \n    \n    \tfloat time = iGlobalTime;\n    \tvec3 uvw = vec3(fragCoord.xy\/iResolution.xy, 0.0);\n    \tvec2 scrPixelPos = (2.0*uvw.xy - vec2(1.0))*iResolution.xy\/iResolution.x;\n\n    \tvec3 camPos = camPosFun(time);\n    \tvec3 camLookAt = vec3(0.0, 0.0, 0.0);\n    \tvec3 camLookForward = normalize(camLookAt - camPos);\n\n    \tvec3 worldUp = vec3(0.0, 1.0, 0.0);\n    \tvec3 camLookRight = normalize(cross(camLookForward, worldUp));\n    \tvec3 camLookUp = normalize(cross(camLookRight, camLookForward));\n\n    \t\/\/ screen is at distance 1 from eye.\n    \tfloat worldScreenHalfWidth = 0.5;\n    \tvec3 worldPixelPos =\n        \tcamPos\n        \t+ camLookForward\n        \t+ scrPixelPos.x*worldScreenHalfWidth*camLookRight\n        \t+ scrPixelPos.y*worldScreenHalfWidth*camLookUp;\n    \tvec3 worldPixelLookDir = normalize(worldPixelPos-camPos);\n\n    \tIntersection closestInter;\n    \tclosestInter.dist = -1.0;\n\n    \t\/\/ objects. Ugly hardcoded pre-processor stuff, but it's the only way I could parameterize the number of cards and still have the shader compile.\n\n#ifdef OBJECT20\n    \tconst int nbObjects = 21;\n#else\n#ifdef OBJECT19\n    \tconst int nbObjects = 20;\n#else\n#ifdef OBJECT18\n    \tconst int nbObjects = 19;\n#else\n#ifdef OBJECT17\n    \tconst int nbObjects = 18;\n#else\n#ifdef OBJECT16\n    \tconst int nbObjects = 17;\n#else\n#ifdef OBJECT15\n    \tconst int nbObjects = 16;\n#else\n#ifdef OBJECT14\n    \tconst int nbObjects = 15;\n#else\n#ifdef OBJECT13\n    \tconst int nbObjects = 14;\n#else        \n#ifdef OBJECT12\n    \tconst int nbObjects = 13;\n#else\n#ifdef OBJECT11\n    \tconst int nbObjects = 12;\n#else\n#ifdef OBJECT10\n        const int nbObjects = 11;\n#else\n#ifdef OBJECT9\n        const int nbObjects = 10;\n#else\n#ifdef OBJECT8\n        const int nbObjects = 9;\n#else\n#ifdef OBJECT7\n        const int nbObjects = 8;\n#else\n#ifdef OBJECT6\n        const int nbObjects = 7;\n#else\n#ifdef OBJECT5\n        const int nbObjects = 6;\n#else\n#ifdef OBJECT4\n        const int nbObjects = 5;\n#else\n#ifdef OBJECT3\n        const int nbObjects = 4;\n#else\n#ifdef OBJECT2\n        const int nbObjects = 3;\n#else\n#ifdef OBJECT1\n        const int nbObjects = 2;\n#endif\n#endif\n#endif\n#endif\n#endif\n#endif\n#endif\n#endif\n#endif\n#endif        \n#endif\n#endif\n#endif\n#endif\n#endif\n#endif\n#endif\n#endif        \n#endif\n#endif\n    \tIntersection objects[nbObjects];\n\t    \n\t    objects[ 0] = rectangle(camPos, worldPixelLookDir, vec3(0.0,-CARD_HEIGHT,0.0), vec3(0.0,1.0,0.0), vec2(50.0,50.0));\n#ifdef OBJECT1\n        objects[ 1] = fallingCard(time, camPos, worldPixelLookDir, 0.678, 0.0);\n#endif\n#ifdef OBJECT2\n\t    objects[ 2] = fallingCard(time, camPos, worldPixelLookDir, 1.053, 0.25);\n#endif\n#ifdef OBJECT3\n\t    objects[ 3] = fallingCard(time, camPos, worldPixelLookDir, 0.817, 0.5);\n#endif\n#ifdef OBJECT4\n\t    objects[ 4] = fallingCard(time, camPos, worldPixelLookDir, 0.985, 0.75);\n#endif\n#ifdef OBJECT5\n\t    objects[ 5] = fallingCard(time, camPos, worldPixelLookDir, 1.164, 0.33);\n#endif\n#ifdef OBJECT6\n\t    objects[ 6] = fallingCard(time, camPos, worldPixelLookDir, 0.773, 0.66);\n#endif\n#ifdef OBJECT7\n\t    objects[ 7] = fallingCard(time, camPos, worldPixelLookDir, 0.876, 0.15);\n#endif\n#ifdef OBJECT8\n\t    objects[ 8] = fallingCard(time, camPos, worldPixelLookDir, 1.350, 0.30);\n#endif\n#ifdef OBJECT9\n\t    objects[ 9] = fallingCard(time, camPos, worldPixelLookDir, 0.718, 0.45);\n#endif\n#ifdef OBJECT10\n\t    objects[10] = fallingCard(time, camPos, worldPixelLookDir, 0.989, 0.60);\n#endif\n#ifdef OBJECT11\n\t    objects[11] = fallingCard(time, camPos, worldPixelLookDir, 1.261, 0.75);\n#endif\n#ifdef OBJECT112\n\t    objects[12] = fallingCard(time, camPos, worldPixelLookDir, 0.877, 0.90);\n#endif\n#ifdef OBJECT113\n\t    objects[13] = fallingCard(time, camPos, worldPixelLookDir, 1.111, 0.125);\n#endif\n#ifdef OBJECT114\n\t    objects[14] = fallingCard(time, camPos, worldPixelLookDir, 0.871, 0.325);\n#endif\n#ifdef OBJECT115\n\t    objects[15] = fallingCard(time, camPos, worldPixelLookDir, 1.095, 0.625);\n#endif\n#ifdef OBJECT116\n\t    objects[16] = fallingCard(time, camPos, worldPixelLookDir, 0.941, 0.875);\n#endif\n#ifdef OBJECT117\n\t    objects[17] = fallingCard(time, camPos, worldPixelLookDir, 1.123, 0.513);\n#endif\n#ifdef OBJECT118\n\t    objects[18] = fallingCard(time, camPos, worldPixelLookDir, 0.799, 0.791);\n#endif\n#ifdef OBJECT119\n\t    objects[19] = fallingCard(time, camPos, worldPixelLookDir, 0.800, 0.437);\n#endif\n#ifdef OBJECT120\n\t    objects[20] = fallingCard(time, camPos, worldPixelLookDir, 1.110, 0.966);\n#endif        \n\t        \n\t    for(int i=0; i<nbObjects; i++) {\n\t        if(objects[i].dist > 0.0 && (closestInter.dist < 0.0 || objects[i].dist < closestInter.dist)) {\n\t          closestInter = objects[i];\n\t        }\n\t    }\n\t    \n        \/\/ if a collision occured, get color depending on material.\n\t    if(closestInter.dist > 0.0) {\n\t        if(closestInter.material == MATERIAL_UVW){\n\t            fragColor = vec4( closestInter.uvw, 1.0 );\n\t        } else if(closestInter.material == MATERIAL_FLOOR){\n\t            fragColor = vec4( 0.7*vec3(0.0,127.0\/255.0,9.0\/255.0), 1.0 );\n\t        } else if(closestInter.material == MATERIAL_NORMAL) {\n\t            fragColor = vec4( closestInter.normal, 1.0 );\n\t        } else if(closestInter.material == MATERIAL_CARD_BACK) {\n\t            if( mod( EPSILON + closestInter.uvw.z ,2.0\/CARD_DENSITY) <= 1.0\/CARD_DENSITY ) {\n\t                fragColor = cardBack( vec2(-closestInter.uvw.x, closestInter.uvw.y) , 1 );\n\t            } else {\n\t                fragColor = cardBack( vec2(-closestInter.uvw.x, closestInter.uvw.y) , 2 );\n\t            }\n\t            \n\t        } else if(closestInter.material == MATERIAL_CARD_FACE) {\n\t            if( mod( -EPSILON + closestInter.uvw.z ,2.0\/CARD_DENSITY) <= 1.0\/CARD_DENSITY ) {\n\t                fragColor = cardFace(closestInter.uvw.xy, closestInter.info1, closestInter.info2, 1);\n\t            } else {\n\t                fragColor = cardFace(closestInter.uvw.xy, closestInter.info1, closestInter.info2, 2);\n\t            }\n\t        } else if (closestInter.material == MATERIAL_CARD_SIDE_XM ||\n\t                   closestInter.material == MATERIAL_CARD_SIDE_XP ||\n\t                   closestInter.material == MATERIAL_CARD_SIDE_YM || \n\t                   closestInter.material == MATERIAL_CARD_SIDE_YP)\n\t        {\n\t            if( mod( closestInter.uvw.z ,2.0\/CARD_DENSITY) <= 1.0\/CARD_DENSITY ) {\n\t                fragColor = vec4(vec3(CARD_BORDER_TINT1), 1.0);\n\t            } else {\n\t                fragColor = vec4(vec3(CARD_BORDER_TINT2), 1.0);\n\t            }\n\t        }\n            \n\t    } else {\n\t        fragColor = vec4( vec3(0.0,127.0\/255.0,9.0\/255.0), 1.0);\n\t    }\n    \n    }\n    \n\n}","name":"","description":"","type":"image"}]}}