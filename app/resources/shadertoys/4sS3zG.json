{"Shader":{"ver":"0.1","info":{"id":"4sS3zG","date":"1391423499","viewed":15668,"name":"Dolphin","username":"iq","description":"Dolphin jumping (with very broken geometry and UVs, and water normals)","likes":96,"published":3,"flags":0,"tags":["procedural","3d","raymarching","distancefield"],"hasliked":0},"renderpass":[{"inputs":[{"id":7,"src":"\/presets\/tex06.jpg","ctype":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":10,"src":"\/presets\/tex09.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/#define HIGH_QUALITY_NOISE\n\t\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n#ifdef HIGH_QUALITY_NOISE\t\n\tfloat a = texture2D( iChannel0, (p+vec2(0.5,0.5))\/256.0, -100.0 ).x;\n\tfloat b = texture2D( iChannel0, (p+vec2(1.5,0.5))\/256.0, -100.0 ).x;\n\tfloat c = texture2D( iChannel0, (p+vec2(0.5,1.5))\/256.0, -100.0 ).x;\n\tfloat d = texture2D( iChannel0, (p+vec2(1.5,1.5))\/256.0, -100.0 ).x;\n\treturn -1.0 + 2.0*mix( mix(a,b,f.x), mix(c,d,f.x), f.y );\n#else\n\treturn -1.0 + 2.0*texture2D( iChannel0, (p+f+0.5)\/256.0, -100.0 ).x;\n#endif\t\n}\n\nvec2 sd2Segment( vec3 a, vec3 b, vec3 p )\n{\n\tvec3  pa = p - a;\n\tvec3  ba = b - a;\n\tfloat t = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\tvec3  v = pa - ba*t;\n\treturn vec2( dot(v,v), t );\n}\n\nfloat udBox(vec3 p, vec3 b)\n{\n    return length(max(abs(p)-b, 0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\/\/-----------------------------------------------------------------------------------\n\n#define NUMI 11\n#define NUMF 11.0\n\nvec3 fishPos;\nfloat fishTime;\nfloat isJump;\nfloat isJump2;\n\nvec2 anima( float ih, float t )\n{\n    float an1 = 0.9*(0.5+0.2*ih)*cos(5.0*ih - 3.0*t + 6.2831\/4.0);\n    float an2 = 1.0*cos(3.5*ih - 1.0*t + 6.2831\/4.0);\n    float an = mix( an1, an2, isJump );\n    float ro = 0.4*cos(4.0*ih - 1.0*t)*(1.0-0.5*isJump);\n\treturn vec2( an, ro );\n}\n\nvec3 anima2( void )\n{\n    vec3 a1 = vec3(0.0,        sin(3.0*fishTime+6.2831\/4.0),0.0);\n    vec3 a2 = vec3(0.0,1.5+2.5*cos(1.0*fishTime),0.0);\n\tvec3 a = mix( a1, a2, isJump );\n\ta.y *= 0.5;\n\ta.x += 0.1*sin(0.1 - 1.0*fishTime)*(1.0-isJump);\n    return a;\n}\n\nvec2 sdDolphinCheap( vec3 p )\n{\n    vec2 res = vec2( 1000.0, 0.0 );\n\n\tp -= fishPos;\n\t\t\n\tvec3 a = anima2();\n\t\n\tfloat or = 0.0;\n\tfloat th = 0.0;\n\tfloat hm = 0.0;\n\n\tvec3 mp = a;\n\tfor( int i=0; i<NUMI; i++ )\n\t{\t\n\t\tfloat ih = float(i)\/NUMF;\n\t\tvec2 anim = anima( ih, fishTime );\n\t\t\n\t\tfloat ll = 0.48; if( i==0 ) ll=0.655;\n\t\tvec3 b = a + ll*normalize(vec3(sin(anim.y), sin(anim.x), cos(anim.x)));\n\t\t\n\t\tvec2 dis = sd2Segment( a, b, p );\n\n\t\tif( dis.x<res.x ) {res=vec2(dis.x,ih+dis.y\/NUMF); mp=a+(b-a)*dis.y; }\n\t\t\n\t\ta = b;\n\t}\n\tfloat h = res.y;\n\tfloat ra = 0.04 + h*(1.0-h)*(1.0-h)*2.7;\n\n\tres.x = 0.75 * (distance(p,mp) - ra);\n\n\treturn res;\n}\n\nvec3 ccd, ccp;\n\t\nvec2 sdDolphin( vec3 p )\n{\n    vec2 res = vec2( 1000.0, 0.0 );\n\n\tp -= fishPos;\n\n\tvec3 a = anima2();\n\t\n\tfloat or = 0.0;\n\tfloat th = 0.0;\n\tfloat hm = 0.0;\n\n\tvec3 p1 = a; vec3 d1=vec3(0.0);\n\tvec3 p2 = a; vec3 d2=vec3(0.0);\n\tvec3 p3 = a; vec3 d3=vec3(0.0);\n\tvec3 mp = a;\n\tfor( int i=0; i<NUMI; i++ )\n\t{\t\n\t\tfloat ih = float(i)\/NUMF;\n\t\tvec2 anim = anima( ih, fishTime );\n\t\tfloat ll = 0.48; if( i==0 ) ll=0.655;\n\t\tvec3 b = a + ll*normalize(vec3(sin(anim.y), sin(anim.x), cos(anim.x)));\n\t\t\n\t\tvec2 dis = sd2Segment( a, b, p );\n\n\t\tif( dis.x<res.x ) {res=vec2(dis.x,ih+dis.y\/NUMF); mp=a+(b-a)*dis.y; ccd = b-a;}\n\t\t\n\t\tif( i==3 ) { p1=a; d1 = b-a; }\n\t\tif( i==4 ) { p3=a; d3 = b-a; }\n\t\tif( i==(NUMI-1) ) { p2=b; d2 = b-a; }\n\n\t\ta = b;\n\t}\n\tccp = mp;\n\t\n\tfloat h = res.y;\n\tfloat ra = 0.05 + h*(1.0-h)*(1.0-h)*2.7;\n\tra += 7.0*max(0.0,h-0.04)*exp(-30.0*max(0.0,h-0.04)) * smoothstep(-0.1, 0.1, p.y-mp.y);\n\tra -= 0.03*(smoothstep(0.0, 0.1, abs(p.y-mp.y)))*(1.0-smoothstep(0.0,0.1,h));\n\tra += 0.05*clamp(1.0-3.0*h,0.0,1.0);\n    ra += 0.035*(1.0-smoothstep( 0.0, 0.025, abs(h-0.1) ))* (1.0-smoothstep(0.0, 0.1, abs(p.y-mp.y)));\n\t\n\t\/\/ body\n\tres.x = 0.75 * (distance(p,mp) - ra);\n\t\/\/res.x = 0.75 * (res.x*3.0 - ra);\n\n    \/\/ fin\t\n\td3 = normalize(d3);\n\tfloat k = sqrt(1.0 - d3.y*d3.y);\n\tmat3 ms = mat3(  d3.z\/k, -d3.x*d3.y\/k, d3.x,\n\t\t\t\t        0.0,            k, d3.y,\n\t\t\t\t    -d3.x\/k, -d3.y*d3.z\/k, d3.z );\n\tvec3 ps = p - p3;\n\tps = ms*ps;\n\tps.z -= 0.1;\n    float d5 = length(ps.yz) - 0.9;\n\td5 = max( d5, -(length(ps.yz-vec2(0.6,0.0)) - 0.35) );\n\td5 = max( d5, udRoundBox( ps+vec3(0.0,-0.5,0.5), vec3(0.0,0.5,0.5), 0.02 ) );\n\tres.x = smin( res.x, d5, 0.1 );\n\n\t\n#if 1\n    \/\/ fin\t\n\td1 = normalize(d1);\n\tk = sqrt(1.0 - d1.y*d1.y);\n\tms = mat3(  d1.z\/k, -d1.x*d1.y\/k, d1.x,\n\t\t\t\t   0.0,            k, d1.y,\n               -d1.x\/k, -d1.y*d1.z\/k, d1.z );\n\tps = p - p1;\n\tps = ms*ps;\n\tps.x = abs(ps.x);\n\tfloat l = ps.x;\n\tl=clamp( (l-0.4)\/0.5, 0.0, 1.0 );\n\tl=4.0*l*(1.0-l);\n\tl *= 1.0-clamp(5.0*abs(ps.z+0.2),0.0,1.0);\n\tps.xyz += vec3(-0.2,0.36,-0.2);\n    d5 = length(ps.xz) - 0.8;\n\td5 = max( d5, -(length(ps.xz-vec2(0.2,0.4)) - 0.8) );\n\td5 = max( d5, udRoundBox( ps+vec3(0.0,0.0,0.0), vec3(1.0,0.0,1.0), 0.015+0.05*l ) );\n\tres.x = smin( res.x, d5, 0.12 );\n#endif\n\t\n    \/\/ tail\t\n\td2 = normalize(d2);\n\tmat2 mf = mat2( d2.z, d2.y, -d2.y, d2.z );\n\tvec3 pf = p - p2 - d2*0.25;\n\tpf.yz = mf*pf.yz;\n    float d4 = length(pf.xz) - 0.6;\n\td4 = max( d4, -(length(pf.xz-vec2(0.0,0.8)) - 0.9) );\n\td4 = max( d4, udRoundBox( pf, vec3(1.0,0.005,1.0), 0.005 ) );\n\tres.x = smin( res.x, d4, 0.1 );\n\t\n\t\n\treturn res;\n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nvec3 sdWater( vec3 p )\n{\n\tvec2 q = 0.16*p.xz;\n    q.y *= 0.75;\n\n\tfloat f = 0.0;\n    f += 0.50000*abs(noise( q )); q = m2*q*2.02; q -= 0.1*iGlobalTime;\n    f += 0.25000*abs(noise( q )); q = m2*q*2.03; q += 0.2*iGlobalTime;\n    f += 0.12500*abs(noise( q )); q = m2*q*2.01; q -= 0.4*iGlobalTime;\n    f += 0.06250*abs(noise( q )); q = m2*q*2.02; q += 1.0*iGlobalTime;\n    f += 0.03125*abs(noise( q ));\n\t\n\tfloat sss = abs(sdDolphinCheap(p).x);\n\tfloat spla = exp(-4.0*sss);\n\tspla += 0.5*exp(-14.0*sss);\n\tspla *= mix(1.0,texture2D( iChannel0, 0.2*p.xz ).x,spla*spla);\n\tspla *= -0.85;\n\tspla *= isJump;\n\tspla *= mix( 1.0, smoothstep(0.0,0.5,p.z-fishPos.z-1.5), isJump2 );\n\n\treturn vec3( p.y-1.5+1.2*f + 0.1 + spla, f, sss );\n}\n\nfloat sdWaterCheap( vec3 p )\n{\n\tvec2 q = 0.16*p.xz;\n    q.y *= 0.75;\n\n\tfloat f = 0.0;\n    f += 0.50000*abs(noise( q )); q = m2*q*2.02; q -= 0.1*iGlobalTime;\n    f += 0.25000*abs(noise( q )); q = m2*q*2.03; q += 0.2*iGlobalTime;\n    f += 0.12500*abs(noise( q )); q = m2*q*2.01; q -= 0.4*iGlobalTime;\n    f += 0.06250*abs(noise( q )); q = m2*q*2.02; q += 1.0*iGlobalTime;\n    f += 0.03125*abs(noise( q ));\n\treturn f;\n}\n\nvec2 intersectDolphin( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 10.0;\n\tconst float precis = 0.001;\n    float h = precis*3.0;\n    float t = 0.0;\n\tfloat l = 0.0;\n    for( int i=0; i<50; i++ )\n    {\n        \/\/if( h>precis && t<maxd )\n\t\tif( h<precis || t>maxd ) break;\n\t\t{\n        t += h;\n\t    vec2 res = sdDolphin( ro+rd*t );\n        h = res.x;\n\t\tl = res.y;\n\t\t}\n    }\n\n    if( t>maxd ) t=-1.0;\n    return vec2( t, l);\n}\n\nvec3 intersectWater( vec3 ro, in vec3 rd )\n{\n\tconst float precis = 0.001;\n    float h = precis*3.0;\n\tfloat l = 0.0;\n\tfloat s = 0.0;\n\n\tfloat t = (2.5-ro.y)\/rd.y; \n\tif( t<0.0 ) return vec3(-1.0);\n\n\tfor( int i=0; i<12; i++ )\n    {\n\t\tif( h<precis ) break;\n\t\t{\n        t += h;\n\t    vec3 res = sdWater( ro+rd*t );\n        h = res.x;\n\t\tl = res.y;\n\t\ts = res.z;\n\t\t}\n    }\n\n    return vec3( t, l, s );\n}\n\n\nvec3 calcNormalFish( in vec3 pos )\n{\n    const vec3 eps = vec3(0.08,0.0,0.0);\n\tfloat v = sdDolphin(pos).x;\n\treturn normalize( vec3(\n           sdDolphin(pos+eps.xyy).x - v,\n           sdDolphin(pos+eps.yxy).x - v,\n           sdDolphin(pos+eps.yyx).x - v ) );\n}\n\nvec3 calcNormalWater( in vec3 pos )\n{\n    const vec3 eps = vec3(0.025,0.0,0.0);\n    float v = sdWater(pos).x;\t\n\treturn normalize( vec3( sdWater(pos+eps.xyy).x - v,\n                            eps.x,\n                            sdWater(pos+eps.yyx).x - v ) );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    for( int i=0; i<25; i++ )\n    {\n        h = sdDolphinCheap(ro + rd*t).x;\n        res = min( res, k*h\/t );\n\t\tt += clamp( h, 0.05, 0.5 );\n\t\tif( h<0.0001 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\n\/\/vec3 lig = normalize(vec3(0.9,0.15,0.5));\nconst vec3 lig = vec3(0.86,0.15,0.48);\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, float glossy, float glossy2, float shadows, in vec3 col, float occ )\n{\n\tvec3 ref = reflect(rd,nor);\n\t\n    \/\/ lighting\n    float sky = clamp(nor.y,0.0,1.0);\n\tfloat bou = clamp(-nor.y,0.0,1.0);\n    float dif = max(dot(nor,lig),0.0);\n    float bac = max(0.3 + 0.7*dot(nor,-vec3(lig.x,0.0,lig.z)),0.0);\n    float sha = 1.0-shadows; if( (shadows*dif)>0.001 ) sha=softshadow( pos+0.01*nor, lig, 0.0005, 32.0 );\n    float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 5.0 );\n    float spe = max( 0.0, pow( clamp( dot(lig,ref), 0.0, 1.0), 0.01+glossy ) ) * glossy;\n    float sss = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 3.0 );\n\t\t\n    \/\/ lights\n    vec3 brdf = vec3(0.0);\n\tbrdf += 8.0*dif*vec3(1.80,1.35,0.90)*vec3(sha,sha*0.5+0.5*sha*sha,sha*sha);\n    brdf += 1.0*sky*vec3(0.20,0.40,0.55)*occ;\n    brdf += 1.0*bac*vec3(0.40,0.60,0.70)*occ;\n    brdf += 1.0*bou*vec3(0.10,0.20,0.25);\n    brdf += 1.0*sss*vec3(0.40,0.40,0.40)*(0.3+0.7*dif*sha)*glossy*occ;\n    brdf += 0.5*spe*vec3(1.3,1.0,0.8)*sha*(0.3+0.7*fre)*occ*glossy;\n    brdf += glossy*0.3*vec3(0.8,0.9,1.0)*occ*smoothstep( 0.0, 0.2, ref.y )*(0.5+0.5*smoothstep( 0.0, 1.0, ref.y ));\/\/*smoothstep(-0.1,0.0,dif);\n\t\n    col = col*brdf;\n\n    col += (0.5 + 1.5*fre)*occ*glossy2*glossy2*10.0*vec3(1.0,0.9,0.8)*smoothstep( 0.0, 0.2, ref.y )*(0.5+0.5*smoothstep( 0.0, 1.0, ref.y ));\/\/*smoothstep(-0.1,0.0,dif);\n    col += 0.25*glossy*pow(spe\/(0.01+glossy),8.0)*vec3(1.3,1.0,0.8)*sha*(0.3+0.7*fre)*occ;\n\t\n\treturn col;\n}\n\nvec3 normalMap( in vec2 pos )\n{\n\tpos *= 6.0;\n\tpos.y *= 0.375;\n\t\n\tfloat v = texture2D( iChannel2, 0.015*pos ).x;\n\tvec3 nor = vec3( texture2D( iChannel2, 0.015*pos+vec2(1.0\/1024.0,0.0)).x - v,\n\t                 1.0\/16.0,\n\t                 texture2D( iChannel2, 0.015*pos+vec2(0.0,1.0\/1024.0)).x - v );\n\tnor.xz *= -1.0;\n\treturn normalize( nor );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x\/iResolution.y;\n    vec2 m = vec2(0.5);\n\tif( iMouse.z>0.0 ) m = iMouse.xy\/iResolution.xy;\n\n\n    \/\/-----------------------------------------------------\n    \/\/ animate\n    \/\/-----------------------------------------------------\n\t\n\tfishTime = 0.6 + 2.0*iGlobalTime - 20.0;\n\t\n\tfishPos = vec3( 0.0, 0.0-0.2, -1.1*fishTime );\n\t\n\tisJump  = 0.5 + 0.5*cos(     -0.4+0.5*fishTime);\n\tisJump2 = 0.5 + 0.5*cos( 0.6+0.5*fishTime);\n\tfloat isJump3 = 0.5 + 0.5*cos(-1.4+0.5*fishTime);\n\n    \/\/-----------------------------------------------------\n    \/\/ camera\n    \/\/-----------------------------------------------------\n\n\tfloat an = 1.2 + 0.1*iGlobalTime - 12.0*(m.x-0.5);\n\n\tvec3 ta = vec3(fishPos.x,0.8,fishPos.z) - vec3(0.0,0.0,-2.0);\n\tvec3 ro = ta + vec3(4.0*sin(an),3.1,4.0*cos(an));\n\n    \/\/ shake\n\tro += 0.05*sin(4.0*iGlobalTime*vec3(1.1,1.2,1.3)+vec3(3.0,0.0,1.0) );\n\tta += 0.05*sin(4.0*iGlobalTime*vec3(1.7,1.5,1.6)+vec3(1.0,2.0,1.0) );\n\n    \/\/ camera matrix\n    vec3 ww = normalize( ta - ro );\n    \/\/vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n\tvec3 uu = normalize( vec3(-ww.z,0.0,ww.x) );\n    vec3 vv = normalize( cross(uu,ww));\n\t\n\t\/\/ create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww*(1.0+0.7*smoothstep(-0.4,0.4,sin(0.34*iGlobalTime))) );\n\n    \/\/-----------------------------------------------------\n\t\/\/ render\n    \/\/-----------------------------------------------------\n\n\tfloat t = 1000.0;\n\t\n\tvec3 col = vec3(0.0);\n\tvec3 bgcol = vec3(0.6,0.7,0.8) - .2*clamp(rd.y,0.0,1.0);\n\n    \/\/ quick step till y=3 bounding plane\n\tfloat pt = (3.0-ro.y)\/rd.y;\n\tif( rd.y<0.0 && pt>0.0 ) ro=ro+rd*pt;\n\n\t\/\/ raymarch\n    vec2 tmat1 = intersectDolphin(ro,rd);\n\tvec3 posy = vec3(-100000.0);\n    if( tmat1.x>0.0 )\n    {\n\t\tvec2 tmat = tmat1;\n\t\tt = tmat.x;\n        \/\/ geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormalFish(pos);\n\t\tvec3 ref = reflect( rd, nor );\n\t\tvec3 fpos = pos - fishPos;\n\n\t\tvec3 auu = normalize( vec3(-ccd.z,0.0,ccd.x) );\n\t\tvec3 avv = normalize( cross(ccd,auu) );\n\t\tvec3 ppp = vec3( dot(fpos-ccp,auu),  dot(fpos-ccp,avv),  tmat.y );\n\t\tvec2 uv = vec2( 1.0*atan(ppp.x,ppp.y)\/3.1416, 4.0*ppp.z );\n\n\t\tvec3 bnor = -1.0+2.0*texture2D(iChannel0,uv).xyz;\n        nor += 0.01*bnor;\n\n\t\tvec3 te = texture2D( iChannel2, uv ).xyz;\n\t\tvec4 mate;\n\t\tmate.w = 17.0;\n        mate.xyz = mix( vec3(0.3,0.35,0.4), vec3(0.8,0.85,0.9)*0.9, 0.8*smoothstep(-0.05,0.05,ppp.y) );;\n\n        mate.xyz *= 1.0 + 0.3*te;\n\t\tmate.xyz *= smoothstep( 0.0, 0.06, distance(vec3(abs(ppp.x),ppp.yz)*vec3(1.0,1.0,4.0),vec3(0.35,0.0,0.4)) );\n\t\tmate.xyz *= 1.0 - 0.75*(1.0-smoothstep( 0.0, 0.02, abs(ppp.y) ))*(1.0-smoothstep( 0.07, 0.11, tmat.y ));\n\t\t\n\t\tmate.xyz *= 0.1*0.23;\n\t\t\n        mate.w *= (0.7+0.3*te.x)*smoothstep( 0.0, 0.01, pos.y-sdWaterCheap( pos ) );\n\t\t\t\n        \/\/ surface-light interacion\n        col = doLighting( pos, nor, rd, mate.w, 0.0, 0.0, mate.xyz, 1.0 );\n\t\n\t\tposy = pos;\n\t}\n\n\t\n    vec3 tmat2 = intersectWater(ro,rd);\n\tvec3 col2 = vec3(0.0);\n\tif( tmat2.x>0.0 && (tmat1.x<0.0 || tmat2.x<tmat1.x) )\n\t{\n\t\tvec3 tmat = tmat2;\n\n        t = tmat.x;\n\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormalWater(pos);\n\t\tvec3 ref = reflect( rd, nor );\n\n        vec4 mate = vec4(0.4,0.4,0.4,0.0);\n\n\t\tvec3 bnor = normalMap(pos.xz);\n        nor = normalize( nor + 0.2*bnor );\n\n        float fre = pow( clamp(1.0 + dot( rd, nor ),0.0,1.0), 2.0 );\n\n\t\tmate.xyz = 0.3*mix( vec3(0.0,0.03,0.07), 0.1*vec3(0.0,0.3,0.4), fre );\n\t\tmate.w = fre;\t\n\n        float foam = 1.0-smoothstep( 0.1, 0.65, tmat.y );\n        foam *= smoothstep( 0.0, 0.3, abs(nor.x) );\n\t\t\n        foam *= clamp(1.0-texture2D( iChannel2, vec2(1.0,0.75)*0.45*pos.xz ).x*2.0,0.0,1.0);\n        mate = mix( mate, vec4(0.7,0.7,0.7,0.0), 0.2*foam );\n\n\t\tfloat al = clamp( 0.5 + 0.2*(pos.y - posy.y), 0.0, 1.0 );\n\t\t\n\t\t\/\/foam = exp( -3.0*abs(sdFishCheap(pos).x) );\n\t\tfoam = exp( -3.0*abs(tmat.z) );\n\t\t\n\t\tfoam *= texture2D( iChannel3, pos.zx ).x;\n\t\tfoam = clamp( foam*3.0, 0.0, 1.0 );\n\t\tfoam *= isJump;\n\t\tfoam *= mix( 1.0, smoothstep(0.0,0.5,pos.z-fishPos.z-1.5), isJump2 );\n\t\tmate.xyz = mix( mate.xyz, vec3(0.9,0.95,1.0)*0.3, foam*foam );\n\t\tcol = mix( col, vec3(0.9,0.95,1.0)*1.2, foam );\n\t\tal *= 1.0-foam;\n\n\t\tfloat occ = clamp(3.5*sdDolphinCheap(pos+vec3(0.0,0.4,0.0)).x * sdDolphinCheap(pos+vec3(0.0,1.0,0.0)).x,0.0,1.0);\n        occ = mix(1.0,occ,isJump);\n        occ = 0.35 + 0.65*occ;\n\t\tmate.xyz *= occ;\n        col *= occ;\n\n\t\tmate.xyz = doLighting( pos, nor, rd, mate.w*10.0, mate.w*0.5, 1.0, mate.xyz, occ );\n\t\t\n        \/\/ caustics\n        float cc  = 0.65*texture2D( iChannel0, 2.5*0.02*posy.xz + 0.007*iGlobalTime*vec2( 1.0, 0.0) ).x;\n        cc += 0.35*texture2D( iChannel0, 1.8*0.04*posy.xz + 0.011*iGlobalTime*vec2( 0.0, 1.0) ).x;\n        cc = 0.6*(1.0-smoothstep( 0.0, 0.05, abs(cc-0.5))) + \n\t         0.4*(1.0-smoothstep( 0.0, 0.20, abs(cc-0.5)));\n        col *= 1.0 + 0.8*cc;\n\t\t\n\t\tcol = mix( col, mate.xyz, al );\n\t}\n\t\t\n\t\n\tfloat sun = pow( max(0.0,dot( lig, rd )),8.0 );\n\tcol += vec3(0.8,0.5,0.1)*sun*0.3;\n\n    \/\/ gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\n    \/\/ color\n\tcol = col*vec3(0.9,0.85,0.8) + 0.4*col*col*(3.0-2.0*col);\n\t\t\n    \/\/ vigneting\t\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\n    \/\/ fade\t\n\tcol *= smoothstep( 0.0, 1.0, iGlobalTime );\n\t\n\tfragColor = vec4( col, 1.0 );\n}\n","name":"","description":"","type":"image"}]}}