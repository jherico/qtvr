{"Shader":{"ver":"0.1","info":{"id":"4ljGDd","date":"1433703045","viewed":1160,"name":"Magic Fractal","username":"dgreensp","description":"Experiment with this beautiful, cheap-to-compute fractal.  Inspired by Kali's \"Star Nest\".","likes":28,"published":3,"flags":0,"tags":["fractal"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"const int MAGIC_BOX_ITERS = 13;\nconst float MAGIC_BOX_MAGIC = 0.55;\n\nfloat magicBox(vec3 p) {\n    \/\/ The fractal lives in a 1x1x1 box with mirrors on all sides.\n    \/\/ Take p anywhere in space and calculate the corresponding position\n    \/\/ inside the box, 0<(x,y,z)<1\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\n    \n    float lastLength = length(p);\n    float tot = 0.0;\n    \/\/ This is the fractal.  More iterations gives a more detailed\n    \/\/ fractal at the expense of more computation.\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\n      \/\/ The number subtracted here is a \"magic\" paremeter that\n      \/\/ produces rather different fractals for different values.\n      p = abs(p)\/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\n      float newLength = length(p);\n      tot += abs(newLength-lastLength);\n      lastLength = newLength;\n    }\n\n    return tot;\n}\n\n\/\/ A random 3x3 unitary matrix, used to avoid artifacts from slicing the\n\/\/ volume along the same axes as the fractal's bounding box.\nconst mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                    0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                    -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ uv are screen coordinates, uniformly scaled to go from 0..1 vertically\n\tvec2 uv = fragCoord.xy \/ iResolution.yy;\n    \n    \/\/ scroll a certain number of screenfuls\/second\n    uv.x += iGlobalTime*0.4;\n\n    \/\/ Rotate uv onto the random axes given by M, and scale\n    \/\/ it down a bit so we aren't looking at the entire\n    \/\/ 1x1x1 fractal volume.  Making the coefficient smaller\n    \/\/ \"zooms in\", which may reduce large-scale repetition\n    \/\/ but requires more fractal iterations to get the same\n    \/\/ level of detail.\n    vec3 p = 0.5*M*vec3(uv, 0.0);\n    \n    float result = magicBox(p);\n    \/\/ Scale to taste.  Also consider non-linear mappings.\n    result *= 0.03;\n    \n\tfragColor = vec4(vec3(result),1.0);\n}","name":"","description":"","type":"image"}]}}