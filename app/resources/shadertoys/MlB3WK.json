{"Shader":{"ver":"0.1","info":{"id":"MlB3WK","date":"1432381290","viewed":683,"name":"Moving Spheres on vintage monito","username":"ManuManu","description":"Here I wanted two things :<br\/>* Apply the same transformation to all the pixel of one sphere ( so the sphere is not deformed ) in a repetition operator.<br\/>* Apply a vintage monitor effect.<br\/><br\/>Made on GlSlSandbox here :<br\/>http:\/\/glslsandbox.com\/e#24816.10<br\/>","likes":2,"published":3,"flags":0,"tags":["raymarching","vintage"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/precision mediump float;\nprecision highp float;\n\n\nfloat rand(vec2 co) { return fract(sin(dot(co.xy ,vec2(12.98,78.23))) * 43758.54); }\n\n\n#define NB_ITER 128\n#define FAR \t300.\n\n\n\/\/#define EDIT\n\n\n\nvec4 mapFloor ( vec3 pos )\n{\n\tconst float rep = 5.0;\n\tfloat n1 = floor( pos.x \/ rep );\n\tfloat n2 =.1* floor( pos.z \/ rep );\n\t\/\/float n = n1 + n2;\n\tfloat n = .1*pos.x + .0*sin(iGlobalTime) + .01*pos.z;\n\tfloat c = cos(.5*n);\n\tfloat s = sin( .05*n );\n\tmat2 m = mat2(c, -s, s, c);\n\tpos  = vec3( m*pos.xy, pos.z);\n\tvec3 col1 = vec3( 1., 0., 0.);\n\tvec3 col2 = vec3( 0., 1., 0.);\n\tfloat val = sign( fract( .25*pos.x) -.5 ) * sign( fract( .25*pos.z) -.5 );\n\tvec3 col =mix( col1, col2, val );\n\tfloat dist = pos.y;\n\treturn vec4( col, dist );\n}\n\nvec4 mapSphere( vec3 pos )\n{\n\t\/\/vec4 ret = vec4( abs(atan (pos.x ) ) *abs(atan (pos.y ) )  );\n\t\/\/float m = smoothstep( 0., 1.5, abs(pos.y) -1.5 );\n\t\/\/ret = mix ( ret, vec4( 0., 1., 0., 0.), m );\n\t\/\/vec4 ret = vec4(fract( pos.z ) > .5);\n\tfloat DEP_VAL =sin(iGlobalTime) +2.;\n\tfloat dist = length(  pos ) - 5.+ .2*sin(DEP_VAL *pos.x + sin(5.*iGlobalTime)) * sin(DEP_VAL *pos.y+ cos(6.*iGlobalTime)) * sin(DEP_VAL *pos.z+ sin(iGlobalTime));\n\tvec3 col = vec3( 1.0, .2, .2 );\n\treturn  vec4( col, dist);\n}\n\n\nfloat Mylength( vec3 pos )\n{\n\treturn max(abs(pos.x), max( abs(pos.y), abs( pos.z)) );\n}\n\nfloat Mylength2( vec3 pos )\n{\n\treturn abs(pos.x) + abs(pos.y) + abs( pos.z);\n}\n\nvec4 mapCube( vec3 pos )\n{\n\t\/\/vec4 ret = vec4( abs(atan (pos.x ) ) *abs(atan (pos.y ) ), .0, .0, 1.  );\n\t\/\/vec4 ret = vec4(fract( pos.z ) > .5);\n\tvec3 col = vec3( .0, .9, .1);\n\tfloat dist = Mylength(  pos ) - 5.0;\n\treturn vec4( col, dist );\n}\n\n\nvec4 combine(vec4 val1, vec4 val2 )\n{\n\tif ( val1.w < val2.w ) return val1;\n\treturn val2;\n}\n\n\nvec4 subst( vec4 val1, vec4 val2 )\n{\n\tfloat dist = max(-val2.w, val1.w);\n\treturn vec4(vec3(val1), dist);\n}\n\n\nvec4 mapLotsOfSpheres( vec3 pos)\n{\n\tvec3 col = vec3(.3, .8, .2 );\n\n\tfloat repVal = 20.;\n\tfloat n = floor( (pos.z+repVal*.5) \/ repVal );\n\tfloat val = .2*n*sin(iGlobalTime);\n\tfloat c = cos(val);\n\tfloat s = sin( val );\n\t\/\/float c = cos(.09*n);\n\t\/\/float s = sin( .09*n );\n\tmat2 m = mat2(c, -s, s, c);\n\tpos  = vec3( m*pos.xy, pos.z);\n\t\n\tconst float radius=5.0;\n\tfloat DEP_VAL =.5*sin(10.*iGlobalTime) +2.5;\n\tfloat dist = length( mod( pos+repVal*.5, repVal)-repVal*.5) -radius+ .2*sin(DEP_VAL *pos.x + sin(5.*iGlobalTime)) * sin(DEP_VAL *pos.y+ cos(6.*iGlobalTime)) * sin(DEP_VAL *pos.z+ sin(iGlobalTime));\n\treturn vec4( col, dist);\n}\nvec4 mapLotsOfCubes( vec3 pos)\n{\n\tvec3 col = vec3(.3, .8, .2 );\n\tconst float radius=6.0;\n\tfloat dist = Mylength( mod( pos+8., 16.)-8.) -radius;\n\treturn vec4( col, dist);\n}\n\n\nvec4 map( vec3 pos)\n{\n\treturn mapLotsOfSpheres(pos);\n}\n\nvec4 pixel3D( void ) {\n#ifdef EDIT\n\tgl_FragColor = vec4( .1);\n#else\n\tvec2 uv = ( gl_FragCoord.xy \/ iResolution.xy );\n\tuv -= .5;\n\tuv.x *= iResolution.x \/ iResolution.y;\n\t\/\/uv.x += cos( uv.x)*3.02;\n\t\/\/float fish_eye =  -length(uv)*1.+ sin(time);\n\t\/\/float fish_eye = sin(5.*uv.x) + sin(5.*uv.y) + 1.;\n\tfloat fish_eye =  0.;\n\tvec3 dir = vec3( uv, 1.0 + fish_eye);\n\tdir = normalize(dir);\n\t\n\tvec3 pos = vec3( .0, 8.1, .0);\n\t\/\/vec3 pos = vec3( 20.*sin(time), 8.1, 20.*cos(time));\n\t\n\tfloat nbIterF = 0.;\n\tvec4 result;\n\tfor (int i =0; i < NB_ITER; i++)\n\t{\n\t\tresult = map( pos );\n\t\tpos += result.w * dir;\n\t\tif ( (pos.z > FAR) || (abs(result.w) < .001)) break;\n\t\t\n\t\tnbIterF += 1.0;\t\n\t}\n\tvec3 col = result.xyz;\n\tif ( pos.z> FAR ) \n\t{\n\t\tcol = vec3(.0, .0, .8);\n\t}\n\telse\n\t{\n\t\tvec3 lightPos = vec3(10.* sin(3.*iGlobalTime) + 10., 8.5, 10.*cos(3.*iGlobalTime) + 30. );\n\t\tvec3 light2Pos = normalize( lightPos - pos);\n\t\tvec3 eps = vec3( .1, .0, .0 );\n\t\tvec3 n = vec3( result.w - map( pos - eps.xyy ).w,\n\t\t\t       result.w - map( pos - eps.yxy ).w,\n\t\t\t       result.w - map( pos - eps.yyx ).w );\n\t\tn = normalize(n);\n\t\t\/\/col =abs(n);\n\t\t\t\t\n\t\tfloat lambert = max(.0, dot( n, light2Pos));\n\t\tcol *= vec3(lambert);\n\t\t\n\t\t\/\/vec3 light = vec3( sin( time ), 20 , cos(time) );\n\t\t\/\/col = col* vec3(dot ( -dir, n ));\n\t\t\n\t\t\/\/ specular : \n\t\tvec3 h = normalize( -dir + light2Pos);\n\t\tfloat spec = max( 0., dot( n, h ) );\n\t\tcol += vec3(pow( spec, 16.)) ;\n\t\t\n\t}\n\t\/\/vec3 col = vec3( nbIterF\/64. );\n    \n    \/\/ Monitor effect :\n\tcol = mix( col, vec3(.0, .5, .5), pow(pos.z\/float(FAR),sin(iGlobalTime*5.)+2.));\n\tcol -= .2*rand( uv.xy *iGlobalTime);\n\t\/\/col = vec3(1.0, .0, .0 );\n\tcol *= .5+.5*sin( 20000.*uv.y+5.*iGlobalTime);\n\tcol *= .7+.4*sin( 20.*uv.y+5.*iGlobalTime);\n\/\/\tcol = mix( col, vec3(.0, .5, .5), pos.z\/float(FAR));\n\treturn vec4( col, 1.0);\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ( gl_FragCoord.xy \/ iResolution.xy );\n\tuv -=.5;\n\n\tuv.x *= iResolution.x\/ iResolution.y;\n\tfragColor = pixel3D();\n}\n","name":"","description":"","type":"image"}]}}