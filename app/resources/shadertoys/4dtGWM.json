{"Shader":{"ver":"0.1","info":{"id":"4dtGWM","date":"1450089159","viewed":4601,"name":"Arlo","username":"iq","description":"Arlo, from the movie The Good Dinosaur, approximated by a procedural distance field. Go see the movie! <br\/>Also, I'm using analytical derivatives (ray differentials) to do heightmap and texture filtering without edge artifacts.","likes":47,"published":3,"flags":0,"tags":["procedural","3d","raymarching","distancefield"],"hasliked":0},"renderpass":[{"inputs":[{"id":10,"src":"\/presets\/tex09.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":45,"src":"\/presets\/tex17.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":47,"src":"\/presets\/tex19.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n\treturn vec2(-b - h, -b+h);\n}\n\n\nvec2 sdSegment( in vec3 p, vec3 a, vec3 b )\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\nfloat sdSphere( in vec3 p, in vec3 c, in float r )\n{\n    return length(p-c) - r;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 c, in vec3 r )\n{\n    return (length( (p-c)\/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n\/\/ http:\/\/research.microsoft.com\/en-us\/um\/people\/hoppe\/ravg.pdf\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec3 getClosest( vec2 b0, vec2 b1, vec2 b2 ) \n{\n\t\n  float a =     det(b0,b2);\n  float b = 2.0*det(b1,b0);\n  float d = 2.0*det(b2,b1);\n  float f = b*d - a*a;\n  vec2  d21 = b2-b1;\n  vec2  d10 = b1-b0;\n  vec2  d20 = b2-b0;\n  vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n  vec2  pp = -f*gf\/dot(gf,gf);\n  vec2  d0p = b0-pp;\n  float ap = det(d0p,d20);\n  float bp = 2.0*det(d10,d0p);\n  float t = clamp( (ap+bp)\/(2.0*a+b+d), 0.0 ,1.0 );\n  return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\n\nvec2 sdBezier( vec3 a, vec3 b, vec3 c, vec3 p )\n{\n\tvec3 w = normalize( cross( c-b, a-b ) );\n\tvec3 u = normalize( c-b );\n\tvec3 v = normalize( cross( w, u ) );\n\n\tvec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n\tvec2 b2 = vec2( 0.0 );\n\tvec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n\tvec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n\tvec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy );\n\n\treturn vec2( sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z), cp.z );\n}\n\n\nvec2 sdLine( vec3 p, vec3 a, vec3 b )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 smin( vec2 a, vec2 b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b.x-a.x)\/k, 0.0, 1.0 );\n\treturn vec2( mix( b.x, a.x, h ) - k*h*(1.0-h), mix( b.y, a.y, h ) );\n}\n\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\n\n\/\/---------------------------------------------------------------------------\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n, in float k, in vec3 g1, in vec3 g2 )\n{\n    vec3 m = pow( abs( n ), vec3(k) );\n\tvec4 x = texture2DGradEXT( sam, p.yz, g1.yz, g2.yz );\n\tvec4 y = texture2DGradEXT( sam, p.zx, g1.zx, g2.zx );\n\tvec4 z = texture2DGradEXT( sam, p.xy, g1.xy, g2.xy );\n\treturn (x*m.x + y*m.y + z*m.z) \/ (m.x + m.y + m.z);\n}\n\n\/\/ http:\/\/www.iquilezles.org\/www\/articles\/texture\/texture.htm\nvec4 textureImproved( sampler2D tex, in vec2 res, in vec2 uv, in vec2 g1, in vec2 g2 )\n{\n\tuv = uv*res + 0.5;\n\tvec2 iuv = floor( uv );\n\tvec2 fuv = fract( uv );\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\n\tuv = (uv - 0.5)\/res;\n\treturn texture2DGradEXT( tex, uv, g1, g2 );\n}\n\/\/---------------------------------------------------------------------------\n\nmat3 base( in vec3 ww )\n{\n    vec3  vv  = vec3(0.0,0.0,1.0);\n    vec3  uu  = normalize( cross( vv, ww ) );\n    return mat3(uu.x,ww.x,vv.x,\n                uu.y,ww.y,vv.y,\n                uu.z,ww.z,vv.z);\n}\n\n\/\/---------------------------------------------------------------------------\n\nvec2 leg( in vec3 p, in vec3 pa, in vec3 pb, in vec3 pc, float m, float h )\n{\n    float l = sign(pa.z);\n    \n    vec2 b = sdLine( p, pa, pb );\n\n    float tr = 0.15;\/\/ - 0.2*b.y;\n    float d3 = b.x - tr;\n\n    b = sdLine( p, pb, pc );\n    tr = 0.15;\/\/ - 0.2*b.y;\n    d3 = smin( d3, b.x - tr, 0.1 );\n\n    \/\/ knee\n    float d4 = sdEllipsoid( p, pb+vec3(-0.02,0.05,0.0), vec3(0.14) );\n    \/\/d4 -= 0.01*abs(sin(50.0*p.y));\n    d4 -= 0.015*abs(sin(40.0*p.y));\n    d3 = smin( d3, d4, 0.05 );\n\n    \/\/ paw        \n    vec3 ww = normalize( mix( normalize(pc-pb), vec3(0.0,1.0,0.0), h) );\n    mat3 pr = base( ww );\n    vec3 fc = pr*((p-pc))-vec3(0.2,0.0,0.0)*(-1.0+2.0*h);\n    d4 = sdEllipsoid( fc, vec3(0.0), vec3(0.4,0.25,0.4) );\n\n    \/\/ nails\n    float d6 = sdEllipsoid( fc, vec3(0.32,-0.06,0.0)*(-1.0+2.0*h), 0.95*vec3(0.1,0.2,0.15));\n    d6 = min( d6, sdEllipsoid( vec3(fc.xy,abs(fc.z)), vec3(0.21*(-1.0+2.0*h),-0.08*(-1.0+2.0*h),0.26), 0.95*vec3(0.1,0.2,0.15)) );\n    \/\/ space for nails\n    d4 = smax( d4, -d6, 0.03 );\n\n    \/\/ shape paw\n    float d5 = sdEllipsoid( fc, vec3(0.0,1.85*(-1.0+2.0*h),0.0), vec3(2.0,2.0,2.0) );\n    d4 = smax( d4, d5, 0.03 );\n    d6 = smax( d6, d5, 0.03 );\n    d5 = sdEllipsoid( fc, vec3(0.0,-0.75*(-1.0+2.0*h),0.0), vec3(1.0,1.0,1.0) );\n    d4 = smax( d4, d5, 0.03 );\n    d6 = smax( d6, d5, 0.03 );\n\n    d3 = smin( d3, d4, 0.1 );\n\n    \n\n    \/\/ muslo\n    d4 = sdEllipsoid( p, pa+vec3(0.0,0.2,-0.1*l), vec3(0.35)*m );\n    d3 = smin( d3, d4, 0.1 );\n\n\treturn vec2(d3,d6);\n}\n\nvec2 mapArlo( vec3 p )\n{\n\n    \/\/ body\n    vec3 q = p;\n    float co = cos(0.2);\n    float si = sin(0.2);\n    q.xy = mat2(co,si,-si,co)*q.xy;\n    float d1 = sdEllipsoid( q, vec3(0.0,0.0,0.0), vec3(1.3,0.75,0.8) );\n    float d2 = sdEllipsoid( q, vec3(0.05,0.45,0.0), vec3(0.8,0.6,0.5) );\n    float d = smin( d1, d2, 0.4 );\n    \n    \/\/neck wrinkles\n    float r = length(p-vec3(-1.2,0.2,0.0));\n    d -= 0.05*abs(sin(35.0*r))*exp(-7.0*abs(r)) * clamp(1.0-(p.y-0.3)*10.0,0.0,1.0);\n\n    \/\/ tail\n    {\n    vec2 b = sdBezier( vec3(1.0,-0.4,0.0), vec3(2.0,-0.96,-0.5), vec3(3.0,-0.5,1.5), p );\n    float tr = 0.3 - 0.25*b.y;\n    float d3 = b.x - tr;\n    d = smin( d, d3, 0.2 );\n    }\n    \n    \/\/ neck\n    {\n    vec2 b = sdBezier( vec3(-0.9,0.3,0.0), vec3(-2.2,0.5,0.0), vec3(-2.6,1.7,0.0), p );\n    float tr = 0.35 - 0.23*b.y;\n    float d3 = b.x - tr;\n    d = smin( d, d3, 0.15 );\n    \/\/d = min(d,d3);\n\t}\n\n\n    float dn;\n    \/\/ front-left leg\n    {\n    vec2 d3 = leg( p, vec3(-0.8,-0.1,0.5), vec3(-1.5,-0.5,0.65), vec3(-1.9,-1.1,0.65), 1.0, 0.0 );\n    d = smin(d,d3.x,0.2);\n    dn = d3.y;\n    }\n    \/\/ back-left leg\n    {\n    vec2 d3 = leg( p, vec3(0.5,-0.4,0.6), vec3(0.3,-1.05,0.6), vec3(0.8,-1.6,0.6), 0.5, 1.0 );\n    d = smin(d,d3.x,0.2);\n    dn = min(dn,d3.y);\n    }\n    \/\/ front-right leg\n    {\n    vec2 d3 = leg( p, vec3(-0.8,-0.2,-0.5), vec3(-1.0,-0.9,-0.65), vec3(-0.7,-1.6,-0.65), 1.0, 1.0 );\n    d = smin(d,d3.x,0.2);\n    dn = min(dn,d3.y);\n    }\n    \/\/ back-right leg\n    {\n    vec2 d3 = leg( p, vec3(0.5,-0.4,-0.6), vec3(0.8,-0.9,-0.6), vec3(1.6,-1.1,-0.7), 0.5, 0.0 );\n    d = smin(d,d3.x,0.2);\n    dn = min(dn,d3.y);\n    }\n    \n    \n    \/\/ head\n    vec3 s = vec3(p.xy,abs(p.z));\n    {\n    vec2 l = sdLine( p, vec3(-2.7,2.36,0.0), vec3(-2.6,1.7,0.0) );\n    float d3 = l.x - (0.22-0.1*smoothstep(0.1,1.0,l.y));\n        \n    \/\/ mouth\n    \/\/l = sdLine( p, vec3(-2.7,2.16,0.0), vec3(-3.35,2.12,0.0) );\n    vec3 mp = p-vec3(-2.7,2.16,0.0);\n    l = sdLine( mp*vec3(1.0,1.0,1.0-0.2*abs(mp.x)\/0.65), vec3(0.0), vec3(-3.35,2.12,0.0)-vec3(-2.7,2.16,0.0) );\n        \n    float d4 = l.x - (0.12 + 0.04*smoothstep(0.0,1.0,l.y));      \n    float d5 = sdEllipsoid( s, vec3(-3.4,2.5,0.0), vec3(0.8,0.5,2.0) );\n    d4 = smax( d4, d5, 0.03 );\n    \n        \n    d3 = smin( d3, d4, 0.1 );\n\n        \n    \/\/ mouth bottom\n    {\n    vec2 b = sdBezier( vec3(-2.6,1.75,0.0), vec3(-2.7,2.2,0.0), vec3(-3.25,2.12,0.0), p );\n    float tr = 0.11 + 0.02*b.y;\n    d4 = b.x - tr;\n    d3 = smin( d3, d4, 0.001+0.06*(1.0-b.y*b.y) );\n    }\n        \n    \/\/ brows    \n    vec2 b = sdBezier( vec3(-2.84,2.50,0.04), vec3(-2.81,2.52,0.15), vec3(-2.76,2.4,0.18), s+vec3(0.0,-0.02,0.0) );\n    float tr = 0.035 - 0.025*b.y;\n    d4 = b.x - tr;\n    d3 = smin( d3, d4, 0.025 );\n\n\n    \/\/ eye wholes\n    d4 = sdEllipsoid( s, vec3(-2.79,2.36,0.04), vec3(0.12,0.15,0.15) );\n    d3 = smax( d3, -d4, 0.025 );    \n        \n    \/\/ nose holes    \n    d4 = sdEllipsoid( s, vec3(-3.4,2.17,0.09), vec3(0.1,0.025,0.025) );\n    d3 = smax( d3, -d4, 0.04 );    \n\n        \n    d = smin( d, d3, 0.01 );\n    }\n    vec2 res = vec2(d,0.0);\n    \n    \n    \/\/ eyes\n    float d4 = sdSphere( s, vec3(-2.755,2.36,0.045), 0.16 );\n    if( d4<res.x ) res = vec2(d4,1.0);\n    \n    float te = texture2D( iChannel0, 3.0*p.xy ).x;\n    float ve = normalize(p).y;\n    res.x -= te*0.01*(1.0-smoothstep(0.6,1.5,length(p)))*(1.0-ve*ve);\n    \n    if( dn<res.x )  res = vec2(dn,3.0);\n\n    return res;\n}\n\n\n\nvec2 legSimple( in vec3 p, in vec3 pa, in vec3 pb, in vec3 pc, float m, float h )\n{\n    float l = sign(pa.z);\n    \n    vec2 b = sdLine( p, pa, pb );\n\n    float tr = 0.15;\/\/ - 0.2*b.y;\n    float d3 = b.x - tr;\n\n    b = sdLine( p, pb, pc );\n    tr = 0.15;\/\/ - 0.2*b.y;\n    d3 = smin( d3, b.x - tr, 0.1 );\n\n    \/\/ paw        \n    vec3 ww = normalize( mix( normalize(pc-pb), vec3(0.0,1.0,0.0), h) );\n    mat3 pr = base( ww );\n    vec3 fc = pr*((p-pc))-vec3(0.2,0.0,0.0)*(-1.0+2.0*h);\n    float d4 = sdEllipsoid( fc, vec3(0.0), vec3(0.4,0.25,0.4) );\n\n    \/\/ nails\n    float d6 = sdEllipsoid( fc, vec3(0.32,-0.06,0.0)*(-1.0+2.0*h), 0.95*vec3(0.1,0.2,0.15));\n    d6 = min( d6, sdEllipsoid( vec3(fc.xy,abs(fc.z)), vec3(0.21*(-1.0+2.0*h),-0.08*(-1.0+2.0*h),0.26), 0.95*vec3(0.1,0.2,0.15)) );\n    \/\/ space for nails\n    d4 = smax( d4, -d6, 0.03 );\n\n    \/\/ shape paw\n    float d5 = sdEllipsoid( fc, vec3(0.0,1.85*(-1.0+2.0*h),0.0), vec3(2.0,2.0,2.0) );\n    d4 = smax( d4, d5, 0.03 );\n    d6 = smax( d6, d5, 0.03 );\n    d5 = sdEllipsoid( fc, vec3(0.0,-0.75*(-1.0+2.0*h),0.0), vec3(1.0,1.0,1.0) );\n    d4 = smax( d4, d5, 0.03 );\n    d6 = smax( d6, d5, 0.03 );\n\n    d3 = smin( d3, d4, 0.1 );\n\n\treturn vec2(d3,d6);\n}\n\nfloat mapArloSimple( vec3 p )\n{\n\n    \/\/ body\n    vec3 q = p;\n    float co = cos(0.2);\n    float si = sin(0.2);\n    q.xy = mat2(co,si,-si,co)*q.xy;\n    float d1 = sdEllipsoid( q, vec3(0.0,0.0,0.0), vec3(1.3,0.75,0.8) );\n    float d2 = sdEllipsoid( q, vec3(0.05,0.45,0.0), vec3(0.8,0.6,0.5) );\n    float d = smin( d1, d2, 0.4 );\n    \n    \/\/ tail\n    {\n    vec2 b = sdBezier( vec3(1.0,-0.4,0.0), vec3(2.0,-0.96,-0.5), vec3(3.0,-0.5,1.5), p );\n    float tr = 0.3 - 0.25*b.y;\n    float d3 = b.x - tr;\n    d = smin( d, d3, 0.2 );\n    }\n    \n    \/\/ neck\n    {\n    vec2 b = sdBezier( vec3(-0.9,0.3,0.0), vec3(-2.2,0.5,0.0), vec3(-2.6,1.7,0.0), p );\n    float tr = 0.35 - 0.23*b.y;\n    float d3 = b.x - tr;\n    d = smin( d, d3, 0.15 );\n    \/\/d = min(d,d3);\n\t}\n\n\n    float dn;\n    \/\/ front-left leg\n    {\n    vec2 d3 = legSimple( p, vec3(-0.8,-0.1,0.5), vec3(-1.5,-0.5,0.65), vec3(-1.9,-1.1,0.65), 1.0, 0.0 );\n    d = smin(d,d3.x,0.2);\n    dn = d3.y;\n    }\n    \/\/ back-left leg\n    {\n    vec2 d3 = legSimple( p, vec3(0.5,-0.4,0.6), vec3(0.3,-1.05,0.6), vec3(0.8,-1.6,0.6), 0.5, 1.0 );\n    d = smin(d,d3.x,0.2);\n    dn = min(dn,d3.y);\n    }\n    \/\/ front-right leg\n    {\n    vec2 d3 = legSimple( p, vec3(-0.8,-0.2,-0.5), vec3(-1.0,-0.9,-0.65), vec3(-0.7,-1.6,-0.65), 1.0, 1.0 );\n    d = smin(d,d3.x,0.2);\n    dn = min(dn,d3.y);\n    }\n    \/\/ back-right leg\n    {\n    vec2 d3 = legSimple( p, vec3(0.5,-0.4,-0.6), vec3(0.8,-0.9,-0.6), vec3(1.6,-1.1,-0.7), 0.5, 0.0 );\n    d = smin(d,d3.x,0.2);\n    dn = min(dn,d3.y);\n    }\n    \n    \n    \/\/ head\n    vec3 s = vec3(p.xy,abs(p.z));\n    {\n    vec2 l = sdLine( p, vec3(-2.7,2.36,0.0), vec3(-2.6,1.7,0.0) );\n    float d3 = l.x - (0.22-0.1*smoothstep(0.1,1.0,l.y));\n        \n    \/\/ mouth\n    \/\/l = sdLine( p, vec3(-2.7,2.16,0.0), vec3(-3.35,2.12,0.0) );\n    vec3 mp = p-vec3(-2.7,2.16,0.0);\n    l = sdLine( mp*vec3(1.0,1.0,1.0-0.2*abs(mp.x)\/0.65), vec3(0.0), vec3(-3.35,2.12,0.0)-vec3(-2.7,2.16,0.0) );\n        \n    float d4 = l.x - (0.12 + 0.04*smoothstep(0.0,1.0,l.y));      \n    float d5 = sdEllipsoid( s, vec3(-3.4,2.5,0.0), vec3(0.8,0.5,2.0) );\n    d4 = smax( d4, d5, 0.03 );\n    \n        \n    d3 = smin( d3, d4, 0.1 );\n\n        \n    \/\/ mouth bottom\n    {\n    vec2 b = sdBezier( vec3(-2.6,1.75,0.0), vec3(-2.7,2.2,0.0), vec3(-3.25,2.12,0.0), p );\n    float tr = 0.11 + 0.02*b.y;\n    d4 = b.x - tr;\n    d3 = smin( d3, d4, 0.001+0.06*(1.0-b.y*b.y) );\n    }\n        \n    \/\/ brows    \n    vec2 b = sdBezier( vec3(-2.84,2.50,0.04), vec3(-2.81,2.52,0.15), vec3(-2.76,2.4,0.18), s+vec3(0.0,-0.02,0.0) );\n    float tr = 0.035 - 0.025*b.y;\n    d4 = b.x - tr;\n    d3 = smin( d3, d4, 0.025 );\n\n    d = smin( d, d3, 0.01 );\n    }\n    \n    return min(d,dn);\n}\n\n\nvec3 drddx;\nvec3 drddy;\n\nvec2 mapTerrain( vec3 p, float t )\n{\n    float h = -2.0+0.03;\n\n    h += 5.0*textureImproved( iChannel2, iChannelResolution[2].xy, 0.0004*p.xz, 0.0004*t*drddx.xz, 0.0004*t*drddy.xz ).x;\n    \n    float di = smoothstep(100.0,500.0,length(p.xz) );\n    h += 2.0*di;\n    h *= 1.0 + 3.0*di;\n\n\n    if( (p.y-h)<0.5 && t<100.0 )\n    {\n        float at = 1.0-smoothstep( 50.0, 100.0, t );\n        float gr = texture2DGradEXT( iChannel2, 0.004*p.xz, 0.004*t*drddx.xz, 0.004*t*drddy.xz ).x;\n        float pi = texture2DGradEXT( iChannel0, 0.400*p.xz, 0.400*t*drddx.xz, 0.400*t*drddy.xz ).x;\n            \n        gr = smoothstep( 0.2, 0.3, gr-pi*0.3+0.15 );\n        h += at*(1.0-gr)*0.15*pi;\n        h += at*0.1*texture2DGradEXT( iChannel2, 0.04*p.xz, 0.04*t*drddx.xz, 0.04*t*drddy.xz ).x;\n    }\n\n\n    float d = 0.8*(p.y-h);\n    \n    return vec2(d,2.0);\n}\n\nfloat mapTotal( in vec3 pos )\n{\n    float d1 = mapArlo( pos ).x;\n    float d2 = mapTerrain( pos, length(pos) ).x;\n    return min(d1,d2);\n}\n\nvec3 calcNormal( in vec3 pos, in float eps )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*mapTotal( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*mapTotal( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*mapTotal( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*mapTotal( pos + e.xxx ) );\n}\n\nfloat calcOcclusionArlo( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        float h = 0.005 + 0.25*float(i)\/7.0;\n        vec3 dir = normalize( sin( float(i)*73.4 + vec3(0.0,2.1,4.2) ));\n        dir = normalize( nor + dir );\n        occ += (h-mapArlo( pos + h*dir ).x);\n    }\n    return clamp( 1.0 - 9.0*occ\/8.0, 0.0, 1.0 );    \n}\n\nfloat calcOcclusionTerrain( in vec3 pos, in vec3 nor, float t )\n{\n\tfloat occ = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        float h = 0.005 + 0.25*float(i)\/7.0;\n        vec3 dir = normalize( sin( float(i)*73.4 + vec3(0.0,2.1,4.2) ));\n        dir = normalize( nor + dir );\n        occ += (h-mapTerrain( pos + h*dir, t ).x);\n    }\n    return clamp( 1.0 - 9.0*occ\/8.0, 0.0, 1.0 );    \n}\n\n\nfloat calcShadowArlo( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    \n    \/\/ check bounding volume first\n    vec2 bv = sphIntersect( ro, rd, vec4(-0.5,0.5,0.0,3.4) );\n    if( bv.y>0.0 )\n    {\n        float t = 0.01;\n        for( int i=0; i<32; i++ )\n        {\n            float h = mapArloSimple(ro + rd*t );\n            res = min( res, smoothstep(0.0,1.0,k*h\/t) );\n            t += clamp( h, 0.04, 0.5 );\n\t\t    if( res<0.01 ) break;\n        }\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat calcShadowTerrain( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n\n    float t = 0.1;\n    for( int i=0; i<32; i++ )\n    {\n        vec3 pos = ro + rd*t;\n        float h = mapTerrain(pos, length(pos)).x;\n        res = min( res, smoothstep(0.0,1.0,8.0*h\/t) );\n        t += clamp( h, 0.05, 10.0 );\n\t\tif( res<0.01 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 sunDir = normalize( vec3(0.1,0.05,0.2) );\n\n\n\/\/ compute screen space derivatives of positions analytically without dPdx()\nvoid calcDpDxy( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy, in float t, in vec3 nor, out vec3 dpdx, out vec3 dpdy )\n{\n    dpdx = t*(rdx*dot(rd,nor)\/dot(rdx,nor) - rd);\n    dpdy = t*(rdy*dot(rd,nor)\/dot(rdy,nor) - rd);\n}\n\nvec3 shade( in vec3 ro, in vec3 rd, in float t, in float m, in vec3 rdx, in vec3 rdy )\n{\n    float eps = 0.001;\n    \n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal( pos, eps*t );\n    float kk;\n\n    vec3 mateD = vec3(0.2,0.16,0.11);\n    vec3 mateS = vec3(0.2,0.12,0.07);\n    float mateK = 0.0;\n    float focc = 1.0;\n    \n    \/\/ derivatives\n    vec3 dposdx = t*drddx;\n    vec3 dposdy = t*drddy;\n    calcDpDxy( ro, rd, rdx, rdy, t, nor, dposdx, dposdy );\n\n    \n    if( m<0.5 ) \/\/ arlo\n    {\n        mateD = vec3(0.05,0.2,0.04)*0.7;\n        mateS = vec3(2.0,1.0,1.0)*0.5;\n    \n        \/\/ back\n        float pz = smoothstep(0.0,1.0,max(0.0,pos.y-0.0));\n        float pp = smoothstep( 0.6, 1.6, sin(pos.x*18.0) + pz*1.5 );\n        pp *= 1.0-smoothstep(0.1,1.5,length(pos-vec3(0.0,1.0,0.0)));\n        mateD = mix( mateD, vec3(0.05,0.2,0.08)*0.54, pp );         \n    \n        \/\/ nose\n        mateD = mix( mateD, vec3(0.13,0.21,0.04)*0.7,1.0-smoothstep(0.0,0.5,length(pos-vec3(-3.45,2.15,0.0))));\n\n        \/\/ belly\n        mateD = mix( mateD, vec3(0.16,0.22,0.10)*0.55,smoothstep(0.5,1.0,-nor.y)*(1.0-smoothstep(0.9,1.2,length(pos))));\n\n        \/\/ neck\n        vec2 b = sdSegment( pos, vec3(-0.9,-0.3,0.0), vec3(-2.6,1.7,0.0) );\n        float tr = 0.3;\/\/ - 0.25*b.y;\n        float d3 = b.x - tr;\n        float bn = 1.0-smoothstep(0.05,0.15,d3);\n        bn *= smoothstep(0.0,0.5,-nor.y);\n        bn *= 1.0-smoothstep(0.7,1.0,b.y);\n        mateD = mix( mateD, vec3(0.1,0.23,0.07)*0.7,bn);\n\n        \n        vec3 tc = texcube( iChannel1, 0.2*pos, nor, 4.0, 0.2*dposdx, 0.2*dposdy ).xyz;\n        mateD *= 0.7+0.6*tc*tc;\n\n        float te = texcube( iChannel0, 2.0*pos, nor, 4.0, 2.0*dposdx, 2.0*dposdy ).x;\n        mateD *= 0.9 + 0.1*te;    \n    \n        mateK = 0.75*(0.5+0.5*tc.x*te);\n        \n        mateD.z += 0.05*(texcube( iChannel1, 0.025*pos, nor, 4.0, 0.025*dposdx, 0.025*dposdy ).x-0.5);\n    }\n\telse if( m<1.5 ) \/\/ eyes\n    {\n        mateD = vec3(0.2,0.2,0.2)*0.7;\n        mateK = 2.0;\n        mateS = vec3(0.4);\n        \n        vec3 cen = vec3(-2.755,2.36,0.1*sign(pos.z));\n        vec3 dir = normalize(pos-cen);\n        vec3 view = vec3(-1.0,-0.1,0.1);\/\/normalize( ro-(cen) );\n        float d = dot( dir, view ); \n        \n        float p = 1.0-smoothstep( 0.82, 0.83, d );\n        mateD *= p;\n        mateS *= p;\n        float r  = pow(clamp( (d-0.83)\/(1.0-0.83),0.0,1.0),2.0);\n        \n        float br = 3.5*pow(clamp(dot( nor, view ),0.0,1.0),32.0);\n        mateD = mix( mateD, vec3(0.03,0.015,0.0)*2.5*(1.0+br), smoothstep(0.0,0.05,r) );\n        mateD = mix( mateD, vec3(0.00,0.000,0.0), smoothstep(0.5,0.60,r) );\n        \n        float ff = smoothstep( 0.0, 0.1, -pos.x-2.75 );\n        mateD *= ff;\n        mateS *= ff;\n        mateK *= ff;\n    }\n\telse if( m<2.5 ) \/\/ terrain\n    {\n        mateD = vec3(0.1,0.05,0.02);\n        mateD = pow( texture2DGradEXT( iChannel1, 0.3*pos.xz, 0.3*dposdx.xz, 0.3*dposdy.xz ).xyz, vec3(1.5))*0.3*vec3(1.1,1.0,0.9);\n        mateK = 1.0;\n        mateS = vec3(0.0,0.0,0.0);\n        focc = texture2DGradEXT( iChannel0, 0.5*pos.xz, 0.5*dposdx.xz, 0.5*dposdy.xz ).x;\n        \n        \/\/ grass        \n        float gr = texture2DGradEXT( iChannel2, 0.004*pos.xz, 0.004*dposdx.xz, 0.004*dposdy.xz ).x;\n        float pi = texture2DGradEXT( iChannel0, 0.400*pos.xz, 0.400*dposdx.xz, 0.400*dposdy.xz ).x;\n        gr = smoothstep( 0.2, 0.3, gr-pi*0.3+0.15 );\n        float hi = smoothstep( 0.85, 1.0, nor.y )*gr;\/\/iq\n        mateD = mix( mateD, vec3(0.25,0.14,0.0)*0.4*(0.75+0.5*pi), hi );\n        focc = mix( focc, 1.0, hi );\n        mateK *= 1.0-hi;\n        \n        mateD *= 0.9;\n    }\n\telse \/\/if( m<3.5 ) \/\/ nails\n    {\n        mateD = vec3(0.12,0.12,0.05)*1.3;\n        mateK = 0.0;\n        mateS = vec3(0.0,0.0,0.0);\n        float gr = texcube( iChannel2, 0.8*pos*vec3(1.0,0.2,1.0), nor, 4.0, 0.8*dposdx*vec3(1.0,0.2,1.0), 0.8*dposdy*vec3(1.0,0.2,1.0) ).x;\n        mateD *= 0.6 + 0.8*gr;\n    }    \n    \n    vec3 hal = normalize( sunDir-rd );\n    float fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );\n    float occ = min(calcOcclusionArlo(pos,nor),\n                    calcOcclusionTerrain(pos,nor,t) )*focc;\n        \n    float dif1 = clamp( dot(nor,sunDir), 0.0, 1.0 );\n    float bak = clamp( dot(nor,normalize(vec3(-sunDir.x,0.0,-sunDir.z))), 0.0, 1.0 );\n    float sha = min( calcShadowArlo( pos, sunDir, 32.0 ),\n                     calcShadowTerrain( pos, sunDir, 32.0 ) );\n    dif1 *= sha;\n    float spe1 = clamp( dot(nor,hal), 0.0, 1.0 );\n    float bou = clamp( 0.5-0.5*nor.y, 0.0, 1.0 );\n\n    \/\/ sun\n    vec3 col = 4.0*vec3(1.1,0.7,0.3)*dif1;\/\/*(0.5+0.5*occ);\n    \/\/ sky\n    col +=1.35*4.0*vec3(0.2,0.6,1.3)*occ*(0.5+0.5*nor.y);\n    \/\/ ground\n    col += 2.5*vec3(0.4,0.1,0.1)*bou*(0.5+0.5*occ);\n    \/\/ back\n    col += 1.0*vec3(0.8,0.5,0.4)*bak*occ;\n    \/\/ sss\n    col += 10.0*fre*(0.2+0.8*dif1*occ)*mateS;\n\n    col *= mateD;\n\n    \/\/ sun\n    col += 0.5*vec3(1.0,0.9,0.8)*pow( spe1, 16.0 )*dif1*mateK;\n    \/\/ sky\n    col += 0.3*vec3(0.2,0.3,1.0)*occ*mateK*smoothstep( -0.3, 0.5, reflect( rd, nor ).y )*occ;\n\n    \/\/ fog\n    col = mix( col, vec3(0.4,0.5,0.8), 1.0-exp(-.0007*t));\n    \n    return col;        \n}\n\nvec2 intersect( in vec3 ro, in vec3 rd )\n{\n    vec2 resA = vec2(-1.0);\n    vec2 resT = vec2(-1.0);\n    float maxdist = 16.0;\n    float t = 8.0;\n\n    for( int i=0; i<128; i++ )\n    {\n        vec3 p = ro + t*rd;\n        vec2 h = mapArlo( p );\n        resA = vec2(t,h.y);\n        if( h.x<(0.0001*t) ||  t>maxdist ) break;\n        t += h.x*0.75;\n    }\n\n    vec2 res = vec2(-1.0);\n    if( t<maxdist )\n    {\n        maxdist = t;\/\/min(t,1500.0);\n        res = resA;\n    }\n    else\n    {\n        maxdist = 1500.0;\n    }\n\n    \/\/float h = (25.0-ro.y)\/rd.y; if( h>0.0 ) maxdist =min(maxdist,h);\n        \n    t = 5.;\n    for( int i=0; i<256; i++ )\n    {\n\n        vec3 p = ro + t*rd;\n        vec2 h = mapTerrain( p, t );\n        resT = vec2(t,h.y);\n        if( h.x<(0.0001*t) ||  t>maxdist ) break;\n        t += h.x*0.75;\n    }\n\n    if( t<maxdist )\n    {\n       \tres = resT;\n    }\n\n    return res;\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{\n    \/\/ sky\n    vec3 col = clamp(vec3(0.2,0.4,0.5)*1.3 - rd.y,0.0,1.0);\n    \/\/ clouds\n    float t = (1000.0-ro.y)\/rd.y;\n    if( t>0.0 )\n    {\n    vec2 uv = (ro+t*rd).xz;\n    float cl = texture2D( iChannel2, .000013*uv ).x;\n    cl = smoothstep(0.4,1.0,cl);\n    col = mix( col, vec3(1.0), 0.4*cl );\n    }\n    \/\/ horizon\n    col = mix( col, vec3(0.4,0.5,0.6), exp(-abs(15.0*rd.y)) ) ;\n\n    vec2 tm = intersect( ro, rd );\n    if( tm.y>-0.5  )\n    {\n        col = shade( ro, rd, tm.x, tm.y, rdx, rdy );\n    }\n\n    return pow( col, vec3(0.4545) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 p = (-iResolution.xy+2.0*fragCoord.xy)\/iResolution.y;\n\n    \/\/ camera\n    float an = 5.3 + 0.5 - 0.5*cos(0.1*(iGlobalTime-10.0));;\n    vec3 ro = vec3(12.5*sin(an),0.45,12.5*cos(an));\n    vec3 ta = vec3(0.0,0.6,0.0);\n\n    \/\/ ray\n    mat3 ca = setCamera( ro, ta, -0.05 );\n    vec3 rd = normalize( ca * vec3(p,-4.5) );\n\n    \/\/ ray differentials\n    vec2 px = (-iResolution.xy+2.0*(fragCoord.xy+vec2(1.0,0.0)))\/iResolution.y;\n    vec2 py = (-iResolution.xy+2.0*(fragCoord.xy+vec2(0.0,1.0)))\/iResolution.y;\n    vec3 rdx = normalize( ca * vec3(px,-4.5) );\n    vec3 rdy = normalize( ca * vec3(py,-4.5) );\n    drddx = rdx - rd;\n    drddy = rdy - rd;\n\n    \/\/ render\n    vec3 col = render( ro, rd, rdx, rdy);\n\n    \/\/float sun = clamp( 0.2 + 0.8*dot(rd,sunDir), 0.0, 1.0 );\n\t\/\/col += vec3(0.4,0.3,0.2)*1.0*pow(sun,8.0);\n\n    \/\/ grade\n    col = col*0.6 + 0.4*col*col*(3.0-2.0*col);\n        \n    \/\/ vignete    \n    vec2 q = fragCoord.xy\/iResolution.xy;\n    col *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n\n    fragColor = vec4( col, 1.0 );\n}\n","name":"","description":"","type":"image"}]}}