{"Shader":{"ver":"0.1","info":{"id":"4ddGD2","date":"1453110510","viewed":143,"name":"Playing with a coke...","username":"ManuManu","description":"Try to create a webcam game <img src=\"\/img\/emoticonHappy.png\"\/><br\/><br\/>The goal is to lead the ball to the yellow zone.<br\/>Use a red thing in front of the camera as a pad.<br\/><br\/>Press Space once you win the level to go to the next level (3 levels ).<br\/>","likes":2,"published":3,"flags":50,"tags":["webcam","sincity","multipass"],"hasliked":0},"renderpass":[{"inputs":[{"id":31,"src":"\/presets\/webcam.png","ctype":"webcam","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":260,"src":"\/presets\/previz\/buffer03.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\n\/\/ Not surprinsgly, a lot come from the brick game from IQ: https:\/\/www.shadertoy.com\/view\/MddGzf\n\n\nconst vec2 txBallPosVel = vec2(0.0,0.0);\nconst vec2 txState      = vec2(1.0,0.0);\nconst vec2 txDebug      = vec2(2.0,0.0);\nconst vec2 txScore      = vec2(3.0,0.0);\n\nconst float ballRadius = 0.025;\nconst vec2 shadowOffset = vec2(0.015,0.015);\n\nfloat hash1( float n ) { return fract(sin(n)*138.5453123); }\n\n\nfloat SampleDigit(const in float n, const in vec2 vUV)\n{\n    if( abs(vUV.x-0.5)>0.5 || abs(vUV.y-0.5)>0.5 ) return 0.0;\n\n    \/\/ digit data by P_Malin (https:\/\/www.shadertoy.com\/view\/4sf3RN)\n    float data = 0.0;\n         if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    else if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n    else if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n    else if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n    else if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n    else if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    else if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    \n    vec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n    float fIndex = vPixel.x + (vPixel.y * 4.0);\n    \n    return mod(floor(data \/ pow(2.0, fIndex)), 2.0);\n}\n\nfloat PrintInt( in vec2 uv, in float value )\n{\n    float res = 0.0;\n    float maxDigits = 1.0+ceil(.01+log2(value)\/log2(10.0));\n    float digitID = floor(uv.x);\n    if( digitID>0.0 && digitID<maxDigits )\n    {\n        float digitVa = mod( floor( value\/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n        res = SampleDigit( digitVa, vec2(fract(uv.x), uv.y) );\n    }\n\n    return res;\n}\n\n\nvec2 getNormalDir( vec2 pos)\n{\n    vec3 diff \t\t= vec3(vec2( 1., 1.) \/ iResolution.xy, .0);\n    vec3 rightColor = vec3(texture2D(iChannel0, pos + diff.xz ));\n    vec3 upColor  \t= vec3(texture2D(iChannel0, pos + diff.zy ));\n    vec3 leftColor  = vec3(texture2D(iChannel0, pos - diff.xz ));\n    vec3 downColor  = vec3(texture2D(iChannel0, pos - diff.zy ));\n\n    float difX = rightColor.r - leftColor.r;\n    float difY = upColor.r - downColor.r;\n    return vec2( -difX, -difY);\n}\nvec2 getNormal(vec2 pos)\n{\n    vec2 n = getNormalDir(pos);\n    if ( length( n ) > .00001)\n    \treturn normalize(n);\n    return vec2(.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float px = 1.0\/iResolution.y;\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    uv.x =1. - uv.x;\n    \n    vec2  ballPos   = texture2D( iChannel1, (txBallPosVel+0.5)\/iChannelResolution[0].xy ).xy;\n    float debug     = texture2D( iChannel1, (txDebug+0.5)\/iChannelResolution[0].xy ).x;\n    float debug2    = texture2D( iChannel1, (txDebug+0.5)\/iChannelResolution[0].xy ).y;\n    float score     = texture2D( iChannel1, (txScore+0.5)\/iChannelResolution[0].xy ).x;\n    float state     = texture2D( iChannel1, (txState+0.5)\/iChannelResolution[0].xy ).x;\n    \n    vec3 redColor = vec3( texture2D(iChannel2, uv));\n\n    \/\/ Use a grey camera as the background :\n    float grey = dot(vec3(texture2D(iChannel3, uv)), vec3(0.299, 0.587, 0.114) );\n\n    vec3 col;\n     \/\/ board\n    {\n        col = 0.6*vec3(0.4,0.6,0.7)*(1.0-0.4*length( 2.*(uv-.5) ));\n        col *= 1.0 - 0.1*smoothstep( 0.0,1.0,sin(uv.x*320.0)*sin(uv.y*320.0))*(1.0 - smoothstep( 1.0, 1.01, abs(uv.x) ) );\n    }\n    col += vec3(grey * .5);\n    \/\/ add normal halo:\n    vec2 normalMap = getNormalDir( uv );\n    if( length(normalMap) > .002)\n        col += vec3( .0, length(normalMap)*10., .0);\n\n    \/\/ add red color :\n    if ( length(redColor) > .001)\n    {\n    \tcol = redColor;\n        if (redColor.b > .5 )\n        {\n            vec3 col1= vec3(.98,.95,.1);\n            vec3 col2= vec3(.0);\n            if( state > 0.5 )\n            {\n            \tcol1= vec3(hash1(iGlobalTime), hash1(iGlobalTime+.3), hash1(iGlobalTime+.5));\n            \tcol2= vec3(hash1(iGlobalTime+1.), hash1(iGlobalTime+.2), hash1(iGlobalTime+.1));\n            }\n\n            vec2 square = step( .5, fract(uv*20.) ) * 2. - 1.;\n            float squareVal = square.x * square.y;\n            squareVal = (squareVal +1.) \/ 2.;\n            col = mix( col1, col2, squareVal);\n        }\n    }\n\n    vec3 emi = vec3(0.0);\n    \/\/ ball \n    {\n        float hit = .0;\n\n        \/\/ shadow\n        float f = 1.0-smoothstep( ballRadius*0.5, ballRadius*2.0, length( uv - ballPos + shadowOffset ) );\n        col = mix( col, col*0.4, f );\n\n        \/\/ shape\n        f = length( uv - ballPos ) - ballRadius;\n        vec3 bcol = vec3(1.0,0.6,0.2);\n        bcol *= 1.0 + 0.7*smoothstep( -3.0*px, -1.0*px, f );\n        bcol *= 0.7 + 0.3*hit;\n        col = mix( col, bcol, 1.0-smoothstep( 0.0, px, f ) );\n        \n        emi  += bcol*0.75*hit*exp(-500.0*f*f );\n    }\n    \/\/ add emmission\n    col += emi;\n    \n    {\n        vec2 uv3 = vec2( 1.-uv.x, uv.y);\n        float f = PrintInt( (uv3-vec2(.001, .002))*10.0, score);\n        col = mix( col, vec3(.0,1.0,1.0), f );\n    }\n    \n    \n    \n    \/\/ debug info :\n   \/*\n    {\n        float f;\n        \/\/f= PrintInt( (uv-vec2(.001, .001))*10.0, debug);\n        \/\/col = mix( col, vec3(.0,1.0,1.0), f );\n\n\t\tf = PrintInt( (uv-vec2(.7, .001))*10.0, debug2);\n        col = mix( col, vec3(.0,.0,1.0), f );\n    }\n\t\/\/*\/\n\n    fragColor = vec4(col, .1);\n}","name":"","description":"","type":"image"},{"inputs":[{"id":31,"src":"\/presets\/webcam.png","ctype":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\nconst vec2 txState      = vec2(1.0,0.0);\nvec4 loadValue( in vec2 re )\n{\n    return texture2D( iChannel1, (0.5+re) \/ iChannelResolution[1].xy, -100.0 );\n}\n\n\/\/#define NO_WEBCAMPRESENT\n\nfloat isRedColorRGB( vec3 color )\n{\n    vec3 wantedColor=  vec3( 1.0, .0, .0 );\n    float distToColor = distance( color.rgb, wantedColor ) ;\n    return distToColor;\n}\n\nfloat isRedColor( vec3 color )\n{\n    return isRedColorRGB(color);\n}\n\n\nconst float threshold = .6;\nvec3 onlyRedImage( vec3 color, float grey, float isRed )\n{\n    vec3 resColor = vec3(0.);\n    if ( isRed  < threshold )\n        resColor = color;\n    return resColor;\n}\n\nfloat Circle( vec2 uv, float size )\n{\n    if ( length(uv) < size )\n        return 1.;\n    return 0.;\n}\n\nfloat HorizontalLine( vec2 uv, float size )\n{\n    uv = uv \/  vec2( size, .02);\n    vec2 absUV = abs(uv);\n    \n    return 1.-step( 1., max(absUV.x, absUV.y) );\n}\nfloat VerticalLine( vec2 uv, float size )\n{\n    uv = uv \/  vec2( .02, size);\n    vec2 absUV = abs(uv);\n    \n    return 1.-step( 1., max(absUV.x, absUV.y) );\n}\n\n\nfloat WorldLimit( vec2 uv )\n{\n    float level = .0;\n    level = max( level, VerticalLine(uv-vec2( .02, .5), .5));\n    level = max( level, VerticalLine(uv-vec2( .04, .5), .5));\n    level = max( level, VerticalLine(uv-vec2( 1.48, .5), .5 ));\n    level = max( level, VerticalLine(uv-vec2( 1.46, .5), .5 ));\n    level = max( level, HorizontalLine(uv-vec2(.75, .01), .75 ));\n    level = max( level, HorizontalLine(uv-vec2(.75, .03), .75 ));\n    level = max( level, HorizontalLine(uv-vec2(.75, .99), .75 ));\n\tlevel = max( level, HorizontalLine(uv-vec2(.75, .97), .75 ));\n\treturn level;\n}\n\nvec3 level2( vec2 uv )\n{\n    uv.x *=1.5;\n    vec3 color = vec3(.0);\n    \n\n    \/\/ create the level :\n    float level = WorldLimit(uv);\n    \n    level = max( level, HorizontalLine(uv-vec2(.34, .3), .31 ));\n    level = max( level, HorizontalLine(uv-vec2(1.16, .3), .31 ));\n    level = max( level, HorizontalLine(uv-vec2( .75, .5), .54 ));\n    level = max( level, VerticalLine(uv-vec2( .3, .9), .2 ));\n    level = max( level, VerticalLine(uv-vec2( 1.2, .9), .2 ));\n    level = max( level, HorizontalLine(uv-vec2(.42, .7), .18 ));\n    level = max( level, HorizontalLine(uv-vec2(1.08, .7), .18 ));\n    level = max( level, Circle( uv - vec2(.75, .11 ), .05) );\n    \n    const vec3 redColor = vec3(1., .0, .0);\n    color = mix( color, redColor, level );\n\n    \n    \/\/ add the blue zone :\n    vec2 uv2 = uv -vec2( .75,.99);\n    uv2.y *= 3.;\n    vec2 b = vec2(.1, .1);\n    float zone = 1.- step( .3, length(max(abs(uv2)-b,0.0)));\n\tconst vec3 blueColor = vec3(.0, .0, 1.);\n    color = mix( color, blueColor, zone );\n\n    return color;\n}\nvec3 level0( vec2 uv )\n{\n    uv.x *=1.5;\n    vec3 color = vec3(.0);\n    \n\n    \/\/ create the level :\n    float level = WorldLimit(uv);\n    \n    \n    const vec3 redColor = vec3(1., .0, .0);\n    color = mix( color, redColor, level );\n\n    \n    \/\/ add the blue zone :\n    vec2 uv2 = uv -vec2( .75,.99);\n    uv2.y *= 3.;\n    vec2 b = vec2(.1, .1);\n    float zone = 1.- step( .3, length(max(abs(uv2)-b,0.0)));\n\tconst vec3 blueColor = vec3(.0, .0, 1.);\n    color = mix( color, blueColor, zone );\n\n    return color;\n}\nvec3 level1( vec2 uv )\n{\n    uv.x *=1.5;\n    vec3 color = vec3(.0);\n    \n\n    \/\/ create the level :\n    float level = WorldLimit(uv);\n    \n    level = max( level, HorizontalLine(uv-vec2( .75, .5), .54 ));\n    \n    const vec3 redColor = vec3(1., .0, .0);\n    color = mix( color, redColor, level );\n\n    \n    \/\/ add the blue zone :\n    vec2 uv2 = uv -vec2( .75,.99);\n    uv2.y *= 3.;\n    vec2 b = vec2(.1, .1);\n    float zone = 1.- step( .3, length(max(abs(uv2)-b,0.0)));\n\tconst vec3 blueColor = vec3(.0, .0, 1.);\n    color = mix( color, blueColor, zone );\n\n    return color;\n}\nvec3 level(vec2 uv )\n{\n    float level     = mod(loadValue( txState ).y, 3.);\n    \n    if ( level < 1. )\n        return level0(uv);\n    else if (level < 2.)\n        return level1(uv);\n    return level2(uv);\n}\n\n\n\n#ifndef  NO_WEBCAMPRESENT\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec3 origColor = vec3( texture2D(iChannel0, uv));\n    float grey = dot(vec3(origColor), vec3(0.299, 0.587, 0.114) );\n    \n    float isRed = isRedColor( origColor );\n    \n    \/\/ get red color from camera :\n\tvec3 color = onlyRedImage( origColor, grey, isRed );\n    \n    \/\/ add level :\n    color += level(uv);\n    \n    \/\/ to help debug without camera :)\n    if (iMouse.z > .5 )\n    {\n        vec2 mouseUV = iMouse.xy \/ iResolution.xy;\n        mouseUV.x = (1.-mouseUV.x);\n        \n        float m = HorizontalLine( uv - mouseUV, .05);\n        const vec3 redColor = vec3(1., .0, .0);\n    \tcolor = mix( color, redColor, m );\n    }\n    \n\tfragColor = vec4(color, .1);\n}\n#else\n\n\/\/-------------------------------------------------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    uv -= vec2(.5);\n    \n    vec3 color = vec3(.0);\n    \/\/vec3 color = vec3(1., .0, .0);\n    const float repeatValue = .2;\n    const float repeatValue2 = repeatValue \/2.;\n    uv = mod( uv+vec2(repeatValue2), repeatValue) - vec2(repeatValue2);\n    \/\/if ( length(uv )  < .05)\n    \/\/    color = vec3(1., .0, .0);\n    const vec3 redColor = vec3(1., .0, .0);\n    color = mix( color, redColor, 1.-step( .05, length(uv) ) );\n\tfragColor = vec4(color, .1);\n}\n#endif \/\/  NO_WEBCAMPRESENT\n","name":"","description":"","type":"buffer"},{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":260,"src":"\/presets\/previz\/buffer03.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/\n\/\/ Gameplay computation.\n\/\/\n\/\/ The gameplay buffer is 14x14 pixels. The whole game is run\/played for each one of these\n\/\/ pixels. A filter in the end of the shader takes only the bit  of infomration that needs \n\/\/ to be stored in each texl of the game-logic texture.\n\nconst vec2 txBallPosVel = vec2(0.0,0.0);\nconst vec2 txState      = vec2(1.0,0.0);\nconst vec2 txDebug      = vec2(2.0,0.0);\nconst vec2 txScore      = vec2(3.0,0.0);\n\n\nconst float KEY_SPACE = 32.5\/256.0;\n\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nfloat isInside( vec2 p, vec4 c ) { vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y); }\n\nfloat hash1( float n ) { return fract(sin(n)*138.5453123); }\n\n\nvec4 loadValue( in vec2 re )\n{\n    return texture2D( iChannel0, (0.5+re) \/ iChannelResolution[0].xy, -100.0 );\n}\n\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\nvoid storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\nbool hasCollision( vec2 pos )\n{\n    vec3 origColor = vec3( texture2D(iChannel1, pos));\n    if ( origColor.r > .0001)\n    {\n        return true;\n    }\n    return false;\n}\nbool hasWon( vec2 pos )\n{\n    vec3 origColor = vec3( texture2D(iChannel1, pos));\n    if ( origColor.b > .5)\n    {\n        return true;\n    }\n    return false;\n}\n\nvec2 getNormal( vec2 pos)\n{\n    vec3 diff \t\t= vec3(vec2( 1., 1.) \/ iResolution.xy, .0);\n    vec3 rightColor = vec3(texture2D(iChannel1, pos + diff.xz ));\n    vec3 downColor  = vec3(texture2D(iChannel1, pos + diff.zy ));\n    vec3 leftColor  = vec3(texture2D(iChannel1, pos - diff.xz ));\n    vec3 upColor    = vec3(texture2D(iChannel1, pos - diff.zy ));\n\n    float difX = rightColor.r - leftColor.r;\n    float difY = downColor.r - upColor.r;\n    vec2 norm1 = vec2( -difX, -difY);\n    if ( length( norm1 ) > .00001)\n    \treturn normalize(norm1);\n    return vec2(.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ don't compute gameplay outside of the data area\n    if( fragCoord.x > 4.0 || fragCoord.y>1.0 ) discard;\n    \n    \n    vec4  balPosVel = loadValue( txBallPosVel );\n    float state     = loadValue( txState ).x;\n    float debug \t= loadValue( txDebug).x;\n    float debug2 \t= loadValue( txDebug).y;\n    float level     = loadValue( txState ).y;\n    float score     = loadValue( txScore ).x;\n    \n    \n    \/\/---------------------------------------------------------------------------------\n    \/\/ init\n\t\/\/---------------------------------------------------------------------------------\n\tif( iFrame==0 )\n    {\n        state = -1.0;\n        level = .5;\n    }\n\t\n    if( state < -0.5 )\n    {\n        state = 0.0;\n        balPosVel = vec4(.94,.1, -.01,.01);\n        state = 0.0;\n        debug = 1.0;\n        debug2 = 1.0;\n    }\n\n    \/\/ Game :\n    \/\/ game over (or won), wait for space key press to resume\n    if( state > 0.5 )\n    {\n        float pressSpace = texture2D( iChannel2, vec2(KEY_SPACE,0.25) ).x;\n        if( pressSpace>0.5 )\n        {\n            state = -1.0;\n            level += 1.;\n        }\n    }\n    \n    \/\/ if game mode (not game over), play game\n    else \n    {\n        \/\/balPosVel = vec4(.3,.3+fTrame*.02, 0.6,1.0);\n         \/\/ bounce\n         balPosVel.xy += balPosVel.zw;\n        \n        if ( hasCollision( balPosVel.xy) )\n        {\n            vec2 n = getNormal(balPosVel.xy);\n            balPosVel.zw = reflect(  balPosVel.zw, n );\n            debug += 1.;\n        }\n        if ( hasWon(balPosVel.xy) )\n        {\n            score += 1.;\n            state = 1.;\n        }\n        \n        if ( balPosVel.x < .05 || balPosVel.x > .95)\n            balPosVel.z = -balPosVel.z;\n        if ( balPosVel.y < .05 || balPosVel.y > .95 )\n            balPosVel.w = - balPosVel.w;\n    }\n    \n    \/\/---------------------------------------------------------------------------------\n\t\/\/ store game state\n\t\/\/---------------------------------------------------------------------------------\n    fragColor = vec4(0.0);\n \n    storeValue( txBallPosVel, vec4(balPosVel),             fragColor, fragCoord );\n    storeValue( txState,      vec4(state,level,0.0,0.0),   fragColor, fragCoord );\n    storeValue( txDebug,      vec4(debug,debug2,0.0,0.0),  fragColor, fragCoord );\n    storeValue( txScore,      vec4(score,0.,0.0,0.0),  \t   fragColor, fragCoord );\n    \n}","name":"","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Blur ( Buffer C and D ) is coming from TambakoJaguar here :\n\/\/ https:\/\/www.shadertoy.com\/view\/XstGWB\n\nconst int blur_size = 14;\nconst float blur_width = 1.;\n\nfloat gauss(float x, float e)\n{\n    return exp(-pow(x, 2.)\/e); \n}\n\n\/\/ Horizontal blurring\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 pos = fragCoord.xy \/ iResolution.xy;\n   vec4 pixval = vec4(0.);\n   float tot = 0.;\n    \n   const int nb = 2*blur_size+1;\n   \n   for (int x=0; x<nb; x++)\n   { \n       float x2 = blur_width*float(x-blur_size);\n       vec2 ipos = pos + vec2(x2\/iResolution.x, 0.);\n       float g = gauss(x2, float(20*blur_size));\n       pixval+= g*texture2D(iChannel0, ipos);\n       tot+= g;\n   }\n   fragColor = pixval\/tot;\n}","name":"","description":"","type":"buffer"},{"inputs":[{"id":259,"src":"\/presets\/previz\/buffer02.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"const int blur_size = 14;\nconst float blur_width = 1.;\n\nfloat gauss(float x, float e)\n{\n    return exp(-pow(x, 2.)\/e); \n}\n\n\/\/ Vertical blurring\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 pos = fragCoord.xy \/ iResolution.xy;\n   vec4 pixval = vec4(0.);\n   float tot = 0.;\n    \n   const int nb = 2*blur_size+1;\n   \n   for (int x=0; x<nb; x++)\n   { \n       float x2 = blur_width*float(x-blur_size);\n       vec2 ipos = pos + vec2(0., x2\/iResolution.x);\n       float g = gauss(x2, float(20*blur_size));\n       pixval+= g*texture2D(iChannel0, ipos);\n       tot+= g;\n   }\n   fragColor = pixval\/tot;\n}","name":"","description":"","type":"buffer"}]}}