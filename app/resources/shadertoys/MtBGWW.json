{"Shader":{"ver":"0.1","info":{"id":"MtBGWW","date":"1428985857","viewed":1106,"name":"pbr sphere","username":"cgikoray","description":"An adaption of physically-based shading for use in education.","likes":10,"published":3,"flags":0,"tags":["sphere","metal","pbr","tdm"],"hasliked":0},"renderpass":[{"inputs":[{"id":3,"src":"\/presets\/tex02.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":23,"src":"\/presets\/cube01_0.png","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/* Thank you TDM for inspiration: https:\/\/www.shadertoy.com\/view\/XsfXWX *\/\n\n# define PI 3.14159265358979323846\n# define GEOMETRY 1\n# define TEXTURING 1\n# define ENVIRONMENT 1\n# define FISHEYE 1\n# define REFLECT 1\n# define BLURRED 1\n# define FRESNEL 1\n# define HDR 1\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n    \nstruct Contact {\n    vec3 normal;\n    vec3 position;\n};\n\nstruct Material {\n    vec3 diffuse;\n    float roughness;\n    float fresnel;\n};\n    \nstruct Sphere {\n    Material material;\n    vec3 position;\n    float radius;\n};\n    \nstruct Light {\n    vec3 direction;\n    vec3 color;\n};\n    \nstruct Fragment {\n    vec3 color;\n    float gamma;\n};\n    \nvoid fish_eye(out Ray ray, in vec2 perspective){\n    float fish_eye = length(perspective.xy);\n    ray.direction.z += fish_eye * 0.3;\n    ray.direction = normalize(ray.direction);\n}\n    \nfloat intersect(in Ray ray, in Sphere sphere) {\n    vec3 look = -sphere.position;\n    float a = dot(look, ray.direction);\n    float t = a * a - (dot(look,look) - sphere.radius * sphere.radius);\n    if(t <= 0.0) return -1.0;\n    return -a - sqrt(t);\n}\n\nvec3 ray_position(in Ray ray, float t) {\n    return ray.origin + ray.direction * t;\n}\n\nvoid horizontal_rotation(out vec3 vec, float delta) {\n    float c = cos(delta);\n    float s = sin(delta);\n    vec.xz = vec2(vec.x * c - vec.z * s, vec.x * s + vec.z * c);\n}\n\nvec3 spherical_texturing(in vec3 normal, in sampler2D texture, float delta) {\n     float u = atan(normal.z, normal.x) \/ PI * 2.0 + delta;\n     float v = asin(normal.y) \/ PI * 2.0;\n     return texture2D(texture, vec2(u, v)).xyz;\n}\n\nvec3 tone_map(in Fragment fragment, float luma)\n{\n    fragment.color = exp(-1.0 \/ (2.72 * fragment.color + 0.15));\n    fragment.color = pow(fragment.color, vec3(1.0 \/ (fragment.gamma * luma)));\n    return fragment.color;\n}\n\nvec3 hdr(in Fragment fragment) {\n    float luma = dot(fragment.color, vec3(0.2126, 0.7152, 0.0722));\n    return mix(fragment.color, tone_map(fragment, luma), 1.0 - luma);\n}\n\nfloat some_step(float t) {\n    return pow(t, 4.0);\n}\n\nvec3 texture_average(samplerCube texture, vec3 tc) {\n    const float diff0 = 0.35;\n    const float diff1 = 0.12;\n    vec3 s0 = textureCube(texture, tc).xyz;\n    vec3 s1 = textureCube(texture, tc + vec3(diff0)).xyz;\n    vec3 s2 = textureCube(texture, tc + vec3(-diff0)).xyz;\n    vec3 s3 = textureCube(texture, tc + vec3(-diff0, diff0, -diff0)).xyz;\n    vec3 s4 = textureCube(texture, tc + vec3(diff0, -diff0, diff0)).xyz;\n    vec3 s5 = textureCube(texture, tc + vec3(diff1)).xyz;\n    vec3 s6 = textureCube(texture, tc + vec3(-diff1)).xyz;\n    vec3 s7 = textureCube(texture, tc + vec3(-diff1, diff1,- diff1)).xyz;\n    vec3 s8 = textureCube(texture, tc + vec3(diff1, -diff1, diff1)).xyz;\n     \n    return (s0 + s1 + s2 + s3 + s4 + s5 + s6 + s7 + s8) * 0.111111111;\n}\n\nvec3 texture_blurred(samplerCube texture, vec3 tc) {\n#if BLURRED\n    vec3 r = texture_average(texture, vec3(1.0, 0.0, 0.0));\n    vec3 t = texture_average(texture, vec3(0.0, 1.0, 0.0));\n    vec3 f = texture_average(texture, vec3(0.0, 0.0, 1.0));\n    vec3 l = texture_average(texture, vec3(-1.0, 0.0, 0.0));\n    vec3 b = texture_average(texture, vec3(0.0, -1.0, 0.0));\n    vec3 a = texture_average(texture, vec3(0.0, 0.0, -1.0));\n        \n    float kr = dot(tc,vec3(1.0,0.0,0.0)) * 0.5 + 0.5; \n    float kt = dot(tc,vec3(0.0,1.0,0.0)) * 0.5 + 0.5;\n    float kf = dot(tc,vec3(0.0,0.0,1.0)) * 0.5 + 0.5;\n    float kl = 1.0 - kr;\n    float kb = 1.0 - kt;\n    float ka = 1.0 - kf;\n    \n    kr = some_step(kr);\n    kt = some_step(kt);\n    kf = some_step(kf);\n    kl = some_step(kl);\n    kb = some_step(kb);\n    ka = some_step(ka);    \n    \n    float d = 0.0;\n    vec3 ret = vec3(0.0);\n    ret  = f * kf; d  = kf;\n    ret += a * ka; d += ka;\n    ret += l * kl; d += kl;\n    ret += r * kr; d += kr;\n    ret += t * kt; d += kt;\n    ret += b * kb; d += kb;\n    \n    return ret \/ d;\n#else\n    return textureCube(texture, tc).xyz;\n#endif\n}\n\nvec3 bdrf(in Contact contact, in Ray eye, in Sphere sphere, in Light light, float t, float delta) {\n    Fragment fragment;\n#if ENVIRONMENT\n    fragment.color = textureCube(iChannel0, eye.direction).xyz;\n    fragment.gamma = 2.3;\n#else\n    fragment.color = vec3(0.0);\n    fragment.gamma = 0.0;\n#endif\n    \n    if(t > 0.0) {\n        float ndotv = clamp(dot(contact.normal, -eye.direction), 0.0, 1.0);\n        float ndotl = clamp(dot(light.direction, contact.normal), 0.0, 1.0);\n        vec3 rrefn = reflect(eye.direction, contact.normal);\n        float ldotr = clamp(dot(light.direction, rrefn), 0.0, 1.0);\n        float specular_mod = 1.0 - sphere.material.roughness;\n        float specular_power = clamp(pow(ldotr, 1.0 \/ specular_mod) * specular_mod, 0.0, 1.0);\n        vec3 material_reflection = texture_blurred(iChannel0, rrefn);\n#if FRESNEL\n        float fresnel_base = ndotv;\n        float fresnel_exp = pow(fresnel_base, sphere.material.fresnel);\n        float fresnel_term = specular_power + fresnel_exp;\n#else\n        float fresnel_term = 0.0;\n#endif\n        float normalization_term = ((specular_power + 4.0) \/ 4.0 * PI);\n        float specular_term = normalization_term * specular_power;\n        float vis_alpha = 1.0 \/ (sqrt((PI \/ 4.0) * specular_power + (PI \/ 2.0)));\n        float vis_term = clamp((ndotl * (1.0 - vis_alpha) + vis_alpha) * (ndotv * (1.0 - vis_alpha) + vis_alpha), 0.0, 1.0);\n#if REFLECT\n        vec3 reflection = textureCube(iChannel0, rrefn).xyz;\n        reflection = mix(reflection, material_reflection, 1.0 - vis_term);\n        reflection = mix(reflection, material_reflection, sphere.material.roughness);\n#endif\n        vec3 specular_color = specular_term * fresnel_term * vis_term * light.color;\n#if REFLECT\n        vec3 diffuse_color = mix(sphere.material.diffuse, reflection, vis_term);\n#else \n        vec3 diffuse_color = sphere.material.diffuse;\n#endif   \n        fragment.color = diffuse_color + specular_color;\n#if HDR\n        fragment.color = hdr(fragment);\n#endif\n    }\n    \n    return fragment.color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {   \n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x \/ iResolution.y;\n    \n    float delta = iGlobalTime;\n    float half_delta = delta * 0.5;\n    float quarter_delta = delta * 0.25;\n    float rotation_delta = delta \/ 20.0;\n    \n    Ray eye;\n    eye.origin = vec3(0.0);\n    eye.direction = normalize(vec3(uv.xy, -1.0));\n    \n    Material material;\n    material.roughness = sin(half_delta) * 0.5 + 0.5;\n    material.fresnel = 35.0;\n    \n    Sphere sphere;\n#if GEOMETRY\n    sphere.position = vec3(0.0, 0.0, -10.0);\n    sphere.radius = 6.0;\n#else\n    sphere.position = vec3(0.0);\n    sphere.radius = 0.0;\n#endif\n\n#if FISHEYE\n    fish_eye(eye, uv);\n#endif    \n    \n    horizontal_rotation(eye.direction, rotation_delta);\n    horizontal_rotation(sphere.position, rotation_delta);\n    \n    float t = intersect(eye, sphere);\n    \n    Contact contact;\n    contact.position = ray_position(eye, t);\n    contact.normal = normalize(contact.position - sphere.position);\n    \n#if TEXTURING\n    material.diffuse = spherical_texturing(contact.normal, iChannel1, rotation_delta);\n#else\n    material.diffuse = vec3(0.2);\n#endif\n    sphere.material = material;\n    \n    Light light;\n    light.direction = normalize(vec3(0.5, 1.0, 0.0));\n    light.color = texture_blurred(iChannel0, eye.direction).xyz;\n    \n    fragColor = vec4(bdrf(contact, eye, sphere, light, t, quarter_delta), 1.0);\n}","name":"","description":"","type":"image"}]}}