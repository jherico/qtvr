{"Shader":{"ver":"0.1","info":{"id":"XdlGzX","date":"1375835030","viewed":549,"name":"Procedural Noise Cubemap","username":"4rknova","description":"Use the mouse to control the camera.","likes":12,"published":3,"flags":0,"tags":["procedural","noise","cubemap"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ by Nikos Papadopoulos, 4rknova \/ 2013\n\/\/ Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n#define USE_MOUSE\n#define ANIMATE\n\n#define PI\t\t\t3.14159265359\n#define RADIAN\t\t180. \/ PI\n#define CAMERA_FOV\t60.4 * RADIAN\n\nfloat hash(in vec3 p)\n{\n    return fract(sin(dot(p,vec3(127.1,311.7, 321.4)))*43758.5453123);\n}\n\nfloat noise(in vec3 p)\n{\n#ifdef ANIMATE\n\tp.z += iGlobalTime * .75;\n#endif\n\t\n    vec3 i = floor(p);\n\tvec3 f = fract(p); \n\tf *= f * (3.-2.*f);\n\n    vec2 c = vec2(0,1);\n\n    return mix(\n\t\tmix(mix(hash(i + c.xxx), hash(i + c.yxx),f.x),\n\t\t\tmix(hash(i + c.xyx), hash(i + c.yyx),f.x),\n\t\t\tf.y),\n\t\tmix(mix(hash(i + c.xxy), hash(i + c.yxy),f.x),\n\t\t\tmix(hash(i + c.xyy), hash(i + c.yyy),f.x),\n\t\t\tf.y),\n\t\tf.z);\n}\n\nfloat fbm(in vec3 p)\n{\n\tfloat f = 0.;\n\tf += .50000 * noise(1. * p);\n\tf += .25000 * noise(2. * p);\n\tf += .12500 * noise(4. * p);\n\tf += .06250 * noise(8. * p);\n\treturn f;\n}\n\nstruct Camera\t{ vec3 p, t, u; };\nstruct Ray\t\t{ vec3 o, d; };\n\nvoid generate_ray(Camera c, out Ray r, in vec2 fragCoord)\n{\n\tfloat ratio = iResolution.x \/ iResolution.y;\n\n\tvec2  uv = (2.0 * fragCoord.xy \/ iResolution.xy - 1.)\n\t\t\t * vec2(ratio, 1.0);\n\t\n\tr.o = c.p;\n\tr.d = normalize(vec3(uv.x, uv.y, 1.0 \/ tan(CAMERA_FOV * .5)));\n\t\n\tvec3 cd = c.t - c.p;\n\n\tvec3 rx,ry,rz;\n\trz = normalize(cd);\n\trx = normalize(cross(rz, c.u));\n\try = normalize(cross(rx, rz));\n\t\n\tmat3 tmat = mat3(rx.x, rx.y, rx.z,\n\t\t\t  \t\t ry.x, ry.y, ry.z,\n\t\t\t\t\t rz.x, rz.y, rz.z);\n\n\tr.d = normalize(tmat * r.d);\n}\n\nvec3 cubemap(vec3 d, vec3 c1, vec3 c2)\n{\n\treturn fbm(d) * mix(c1, c2, d * .5 + .5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tCamera c;\n\tc.p = vec3(0., 0., 75.);\n\tc.u = vec3(0., 1., 0.);\n\n#ifdef USE_MOUSE\n\tc.t = vec3(iMouse.x \/ iResolution.x * 180. -90., \n\t\t\t   iMouse.y \/ iResolution.y * 180. -90., 0.);\n#else\n\tc.t = vec3( 26. * sin(mod(iGlobalTime * .64, 2. * PI)),\n\t\t\t    28. * cos(mod(iGlobalTime * .43, 2. * PI)),\n\t\t\t   -25. * cos(mod(iGlobalTime * .20, 2. * PI)));\n#endif\t\t\n\n\tRay r;\n\tgenerate_ray(c, r, fragCoord);\n\t\n\tfragColor = vec4(cubemap(r.d,vec3(.5,.9,.1), vec3(.1,.1,.9)), 1);\n}","name":"","description":"","type":"image"}]}}