{"Shader":{"ver":"0.1","info":{"id":"4tjGzV","date":"1430507655","viewed":689,"name":"The Box","username":"xbe","description":"Using my 2d marquetry shader as a procedural texture in 3d raytracing. All objects are lighted using cubemap. The cube as also simpla bumpmapping. Shape on the box is changing at every shutter.<br\/>","likes":3,"published":3,"flags":0,"tags":["procedural","3d","raytracing"],"hasliked":0},"renderpass":[{"inputs":[{"id":6,"src":"\/presets\/tex05.jpg","ctype":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":22,"src":"\/presets\/cube00_0.jpg","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"id":23,"src":"\/presets\/cube01_0.png","ctype":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ The Box\n\/\/ Raytracing procedural texture\n\/\/\n\/\/ Envmap adapted from \"Cubemap shading\" by vanburgler\n\/\/ https:\/\/www.shadertoy.com\/view\/4ds3RN\n\/\/\n\/\/ Box intersection code adapted from \"Box - intersection\" by iq\n\/\/ https:\/\/www.shadertoy.com\/view\/ld23DV\n\/\/\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Comment to undef antia-alias\n\/\/ 3 sampling points\n#define AA3\n\/\/ 4 sampling points\n\/\/#define AA4\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Utils\n\nvec2 rotate(vec2 p, float a)\n{\n\treturn vec2(p.x * cos(a) + p.y * sin(a),\n\t\t\t\tp.y * cos(a) - p.x * sin(a));\n}\n\nvec3 rotateXZ(vec3 p, float a)\n{\n\treturn vec3(p.x * cos(a) + p.z * sin(a),\n                p.y,\n\t\t\t\tp.z * cos(a) - p.x * sin(a));\n}\n\nmat4 identity()\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t 0.0, 0.0, 0.0, 1.0 );\n}\n\nmat4 rotationXYZ( float x, float y, float z )\n{\n    mat4 rotx = mat4(  1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, cos(x), -sin(x), 0.0,\n\t\t\t\t 0.0, sin(x), cos(x), 0.0,\n\t\t\t\t 0.0,   0.0,   0.0,   1.0 );\n    mat4 roty = mat4(  cos(y), 0.0, sin(y), 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t -sin(y), 0.0, cos(y), 0.0,\n\t\t\t\t 0.0,   0.0,   0.0,   1.0 );\n    mat4 rotz = mat4(  cos(z), -sin(z), 0.0, 0.0,\n\t\t\t\t sin(z), cos(z), 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t 0.0,   0.0,   0.0,   1.0 );\n\treturn rotz*roty*rotx;\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\nmat4 inverse( in mat4 m )\n{\n\treturn mat4(\n        m[0][0], m[1][0], m[2][0], 0.0,\n        m[0][1], m[1][1], m[2][1], 0.0,\n        m[0][2], m[1][2], m[2][2], 0.0,\n        -dot(m[0].xyz,m[3].xyz),\n        -dot(m[1].xyz,m[3].xyz),\n        -dot(m[2].xyz,m[3].xyz),\n        1.0 );\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Marquetry texture\n\n#define PI 3.14159265\n#define NUM 10.\n#define diff .001\n\nfloat delta = 0.005 + 0.0425*(1.-exp(-0.00025*iResolution.x));\n\nmat2 rotate(in float a)\n{\n    float c = cos(a), s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat tri(in float x)\n{\n    return abs(fract(x)-.5);\n}\n\nvec2 tri2(in vec2 p)\n{\n    return vec2(tri(p.x+tri(p.y*2.)),tri(p.y+tri(p.x*2.)));\n}\n\nmat2 trinoisemat = mat2( 0.970,  0.242, -0.242,  0.970 );\n\nfloat triangleNoise(in vec2 p)\n{\n    float z=1.5;\n    float z2=1.5;\n\tfloat rz = 0.;\n    vec2 bp = 2.*p;\n\tfor (float i=0.; i<=4.; i++ )\n\t{\n        vec2 dg = tri2(bp*2.)*.8;\n        dg *= rotate(0.314);\n        p += dg\/z2;\n\n        bp *= 1.6;\n        z2 *= .6;\n\t\tz *= 1.8;\n\t\tp *= 1.2;\n        p*= trinoisemat;\n        \n        rz+= (tri(p.x+tri(p.y)))\/z;\n\t}\n\treturn rz;\n}\n\nfloat arc(in vec2 plr, in float radius, in float thickness)\n{\n    \/\/ clamp arc start\/end\n    float res = step(0., plr.y) * step(plr.y, PI);\n    \/\/ smooth outside\n    res *= smoothstep(plr.x, plr.x+delta,radius+thickness);\n    \/\/ smooth inside\n    float f = radius - thickness;\n    res *= smoothstep( f, f+delta, plr.x);\n    \/\/ smooth start\n    res *= smoothstep( 0., delta, plr.y);\n    \/\/ smooth end\n    res *= 1. - smoothstep( PI-delta, PI, plr.y);\n    return res;\n}\n\nvec3 marquetry(in vec2 uv, in float k0, in float k1)\n{\n    vec2 p = uv;\n    p = 2.*abs(fract(p)-0.5);\n    \n    p *= rotate(PI*(k0)\/180.);\n    p = 2. - ( 0.2 + k1 )*(1.-exp(-abs(p)));\n    \n    float lp = length(p);\n    float id = floor(lp*NUM+.5)\/NUM;\n    vec4 n = texture2D( iChannel2, vec2(id, 0.0025*iGlobalTime));\n    \n    \/\/polar coords\n    vec2 plr = vec2(lp, atan(p.y, p.x));\n    \n    \/\/Draw concentric arcs\n    float rz = arc(plr, id, 0.425\/NUM+delta);\n    \n    float m = rz;\n    rz *= (triangleNoise(p)*0.5+0.5);\n    vec4 nn = texture2D(iChannel2, vec2(0.123, id));\n\tvec3 col = (texture2D(iChannel3, uv+nn.xy).rgb*nn.z+0.25) * rz;\n\tcol *= 1.25;\n    col = smoothstep(0., 1., col);\n   \tcol = exp(col) - 1.;\n    col = clamp(col, 0., 1.);\n    \n    return col;\n}\n\nvec3 marquetryNormal(vec2 coord, in float k0, in float k1)\n{\n\tfloat diffX = marquetry(vec2(coord.x+diff, coord.y),k0,k1).r - marquetry(vec2(coord.x-diff, coord.y),k0,k1).r;\n\tfloat diffY = marquetry(vec2(coord.x, coord.y+diff),k0,k1).r - marquetry(vec2(coord.x, coord.y-diff),k0,k1).r;\n\tvec2 localDiff = vec2(diffX, diffY);\n\tlocalDiff *= -1.0;\n\tlocalDiff = (localDiff\/2.0)+.5;\n\tfloat localDiffMag = length(localDiff);\n\tfloat z = sqrt(max(0.,1.0-pow(localDiffMag, 2.0)));\n\treturn vec3(localDiff, z);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Raytracing Structs\n\nstruct Material {\n\tvec3 \tcolor;\t\t\t\/\/ diffuse color\n    float\tambiant;\t\t\/\/ ambiant coeff\n    float\tk0;\n    float\tk1;\n};\n\nstruct Inter {\n\tvec3 p;\t\t\/\/pos\n\tvec3 n; \t\/\/normal\n\tvec3 vd;\t\/\/ viewdir\n\tfloat d;\t\/\/distance\n    vec2 uv;\t\/\/ uv coordinates\n\tMaterial mat; \/\/ object material\n};\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Sphere\n\nvoid intSphere(vec3 ro, vec3 rd, vec3 p, float r, Material mat, inout Inter i)\n{\n\tfloat dist = -1.;\n\tvec3 v = ro-p;\n\tfloat b = dot(v,rd);\n\tfloat c = dot(v,v) - r*r;\n\tfloat d = b*b-c;\n\tif (d>0.)\n\t{\n\t\tfloat t1 = (-b-sqrt(d));\n\t\tfloat t2 = (-b+sqrt(d));\n\t\tif (t2>0.)\n\t\t{\n\t\t\tdist = t1>0.?t1:t2;\n\t\t\tif ((dist<i.d)||(i.d<0.))\n\t\t\t{\n\t\t\t\ti.p = ro+dist*rd;\n\t\t\t\ti.n = normalize(i.p-p);\n\t            i.n *= t1<0. ? -1. : 1.;\n\t\t\t\ti.d = dist;\n\t\t\t\ti.vd = -rd;\n                vec3 local = i.p-p;\n                i.uv = local.xy; \/\/ Dummy uv but sufficient here\n\t\t\t\ti.mat = mat;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Cube\n\nvoid intCube( in vec3 ro, in vec3 rd, in float c, in mat4 txx, in mat4 txi, Material mat, inout Inter i ) \n{\n    \/\/ convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t\/\/ ray-box intersection in box space\n    vec3 m = 1.0\/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*c;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN < tF && tF > 0.0)\n    {\n        if ((tN<i.d)||(i.d<0.))\n        {\n            vec3 nor = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n            i.p = ro+tN*rd;\n            i.d = tN;\n            i.vd = -rd;\n            vec3 local = (txx*vec4(i.p,1.0)).xyz;\n            vec3 inor = 1.-abs(nor);\n            vec3 tn = vec3(0.);\n            if (inor.x==0.)\n            {\n                i.uv = local.yz\/(2.*c);\n                tn = marquetryNormal(i.uv, mat.k0, mat.k1);\n                tn = vec3(0., tn.x, tn.y);\n            }\n            else if (inor.y==0.)\n            {\n                i.uv = local.xz\/(2.*c);\n                tn = marquetryNormal(i.uv, mat.k0, mat.k1);\n                tn = vec3(tn.x, 0., tn.y);\n            }\n            else\n            {\n                i.uv = local.yx\/(2.*c);\n                tn = marquetryNormal(i.uv, mat.k0, mat.k1);\n                tn = vec3(tn.x, tn.y, 0.);\n            }\n            nor += normalize(tn);\n            i.n = normalize((txi * vec4(nor,0.0)).xyz);\n            i.mat = mat;\n        }\n    }\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Raytracing\n\n#define FocalCoeff 1.33\n#define TargetPoint vec3(0.0, 0.0, 0.0)\n#define OriginPoint vec3(0.0, 0.0, 2.85)\n#define AmbiantContrib 0.35\n\nvoid camera(in vec2 px, out vec3 ro, out vec3 rd)\n{\n    vec2 pos = 2.*(px \/ iResolution.xy) -1.;\n    pos.x *= iResolution.x\/iResolution.y;\n    \n\tvec3 ta = TargetPoint;\n\tro = rotateXZ(OriginPoint, 0.1*iGlobalTime);\n\n    \/\/ camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\trd = normalize( pos.x*cu + pos.y*cv + FocalCoeff*cw );\n}\n\n\nvec3 sampleHemisphere(float u1, float u2, vec3 normal)\n{\n\tvec3 u = normal;\n\tvec3 v = abs(u.y) < abs(u.z) ? vec3(0.0, 1.0, 0.0) : vec3(0.0, 0.0, 1.0);\n\tvec3 w = normalize(cross(u, v));\n\tv = cross(w, u);\n\n\tfloat r = sqrt(u1);\n\tfloat theta = 2.0 * 3.1415926535 * u2;\n\tfloat x = r * cos(theta);\n\tfloat y = r * sin(theta);\n\treturn normalize(u * sqrt(1.0 - u1) + v * x + w * y);\n}\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 diffuse(vec3 n, vec2 p)\n{\t\n\tvec3 col = vec3(0.0);\n\tfor (float i = 0.0; i < 4.0; i++)\n\t\tfor (float j = 0.0; j < 8.0; j++)\t\t\n\t\t{\n\t\t\tvec2 s = vec2(i, j)+p;\n\t\t\tfloat u = (rand(n.xy+s)+i)*0.25;\n\t\t\tfloat v = (rand(n.yz+s)+j)*0.125;\n\t\t\t\n\t\t\tvec3 ns = sampleHemisphere(u*0.5, v, n);\n\t\t\tcol += pow(textureCube(iChannel1, ns).rgb, vec3(2.2));\n\t\t}\n\t\n\treturn col * 0.25 * 0.125;\n}\n\nvec3 shade( in Inter i)\n{\n\tvec3 col = vec3(0.);\n    \n\tvec3 dif = i.mat.color*diffuse(i.n, i.p.xy);\n    vec3 spec = pow(textureCube(iChannel0, reflect(-i.vd, i.n)).rgb, vec3(2.2));\n    \n    float costheta = dot(i.n, i.vd);\n    float f = 1.0 - pow(1.0 - clamp(costheta, 0.0, 1.0), 2.0);\n\n    col = mix(spec, dif, f) + i.mat.ambiant*i.mat.color;\n    return col;\n}\n\nvec3 raytrace(in vec3 ro, in vec3 rd)\n{\n    \/\/ Background cubemap\n    vec3 col = textureCube(iChannel0, rd).rgb;\n\t\n    Material mat;\n    mat.ambiant = AmbiantContrib;\n\n    Inter inter;\n    inter.d = -1.;\n\n    float d = 1.75;\n    float r = 0.4;\n    \n    mat.k0 = 90.;\n    mat.k1 = 2.;\n    intSphere(ro, rd, vec3(d, -0.75, 0.), r, mat, inter );\n\n    mat.k0 = 230.;\n    mat.k1 = -2.5;\n    intSphere(ro, rd, vec3(-d, -0.75, 0.), r, mat, inter );\n\n    mat.k0 = 180.;\n    mat.k1 = 1.;\n    intSphere(ro, rd, vec3(0., d, 0.), r, mat, inter );\n\n    mat.k0 = 260.;\n    mat.k1 = 2.0;\n    intSphere(ro, rd, vec3(0., -0.75, d), r, mat, inter );\n\n    mat.k0 = 30.;\n    mat.k1 = -2.5;\n    intSphere(ro, rd, vec3(0., -0.75, -d), r, mat, inter );\n\n    float k = clamp(fract(iGlobalTime\/(20.*PI)), 0.,1.);    \n    float sum = 0.;\n    float s = 1.\/10.;\n    float ss = s;\n    for (int i=0; i<10; i++)\n    {\n        sum += step(k, ss);\n        ss += s;\n    }\n    mat.k0 = 72.*sum;\n    mat.k1 = -2.;\n    if (k>0.5)\n        mat.k1 *= -1.;\n    \/\/ rotate and translate box\n    vec4 n = texture2D(iChannel2, vec2(0.123, 0.0025*iGlobalTime));\n    float x = n.x;\n    float y = n.y;\n    float z = n.z;\n\tmat4 txi = rotationXYZ(x,y,z);\n\tmat4 txx = inverse( txi );\n    intCube(ro, rd, 0.75, txx, txi, mat, inter );\n    \n    if (inter.d>0.)\n    {\n        inter.mat.color = marquetry(inter.uv, inter.mat.k0, inter.mat.k1);\n        col = shade(inter);\n    }\n    \n    return col;\n}\n\n#define RADIAN(x) PI*x\/180.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ro = vec3(0.);\n    vec3 rd = vec3(0.);\n    \n    \/\/ raytrace\n#ifdef AA4\n\tvec3 col = vec3(0.0);\n    camera(fragCoord.xy + vec2(-0.25, -0.25), ro, rd);\n    col += raytrace(ro, rd) * 0.25;\n    camera(fragCoord.xy + vec2(0.25, -0.25), ro, rd);\n    col += raytrace(ro, rd) * 0.25;\n    camera(fragCoord.xy + vec2(-0.25, 0.25), ro, rd);\n    col += raytrace(ro, rd) * 0.25;\n    camera(fragCoord.xy + vec2(0.25, 0.25), ro, rd);\n    col += raytrace(ro, rd) * 0.25;\n#else\n#ifdef AA3\n\tvec3 col = vec3(0.0);\n    vec2 paa = vec2(0., 0.333);\n    camera(fragCoord.xy + paa, ro, rd);\n    col += raytrace(ro, rd) * 0.334;\n    camera(fragCoord.xy + rotate(paa, RADIAN(120.)), ro, rd);\n    col += raytrace(ro, rd) * 0.333;\n    camera(fragCoord.xy + rotate(paa, RADIAN(240.)), ro, rd);\n    col += raytrace(ro, rd) * 0.333;\n#else\n    camera(fragCoord.xy, ro, rd);\n    vec3 col = raytrace(ro, rd);\n#endif\n#endif\n    \n    \/\/ Vignetting\n\tvec2 p = fragCoord.xy \/ iResolution.xy;\t\n\tvec2 r = -1.0 + 2.0*p;\n\tfloat vb = max(abs(r.x), abs(r.y));\n\tcol *= (0.15 + 0.85*(1.0-exp(-(1.0-vb)*30.0)));\n\n    \/\/ line strips\n\tcol *=.9+.1*sin(0.666*r.y*iResolution.y);\t\n    \n    \/\/ shutter\n    float k = clamp(exp(1.-abs(sin(0.5*iGlobalTime)))-exp(0.5), 0., 1.);\n    float shutter = 1. - smoothstep( 0., 1., 5.*(k-0.75) );\n    \n\tfragColor = vec4(col*shutter, 1.0);\n}","name":"","description":"","type":"image"}]}}