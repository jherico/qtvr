{"Shader":{"ver":"0.1","info":{"id":"llf3zs","date":"1424298185","viewed":912,"name":"Yet Another Raymarching Template","username":"elias","description":".","likes":12,"published":3,"flags":0,"tags":["raymarching","template"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ [x] Pointlights\n\/\/ [x] Spotlights\n\/\/ [x] Reflection\n\/\/ [x] Materials\n\/\/ [x] Soft shadows\n\/\/ [ ] Antialiasing\n\/\/ [ ] Transparency\n\/\/ [ ] Ambient Occlusion\n\n\/\/ Precision\n#define P 0.001\n\/\/ Steps\n#define S 64\n\/\/ Distance\n#define D 15.\n\/\/ Time in ms\n#define T iGlobalTime\n\/\/ Shadows softness\n#define K 4.0\n\/\/ Number of reflections\n#define R 1\n\/\/ Camera zoom\n#define Z 1.0\n\n#define PI 3.14159265359\n#define TAU (PI*2.0)\n#define PERSPECTIVE\n\n\/* ========================== *\/\n\/* ====== STRUCT SETUP ====== *\/\n\/* ========================== *\/\n\nstruct Ray\n{\n\tvec3 o; \/\/ origin\n\tvec3 d; \/\/ direction\n};\n    \nstruct Camera\n{\n    vec3 p; \/\/ position\n    vec3 t; \/\/ target\n};\n\t\nstruct PointLight\n{\n\tvec3 p; \/\/ position\n\tvec3 c; \/\/ color\n};\n    \nstruct SpotLight\n{\n\tvec3  p; \/\/ position\n\tvec3  d; \/\/ direction\n    vec3  c; \/\/ color\n    float a; \/\/ angle\n};\n\nstruct Hit\n{\n\tvec3  p; \/\/ position\n\tfloat t; \/\/ distance traveled\n\tfloat d; \/\/ distance to object\n};\n\nstruct Material\n{\n    vec3  c; \/\/ color\n    float d; \/\/ diffuse\n    float s; \/\/ specular\n    float r; \/\/ reflection\n};\n    \n\/\/ Some mobile devices can't handle constructors\n\/\/ so we need to assign each value manually\nRay createRay(vec3 o, vec3 d)\n{\n    Ray r;\n    r.o = o;\n    r.d = d;\n\treturn r;\n}\n\nHit createHit(vec3 p, float t, float d)\n{\n    Hit h;\n    h.p = p;\n    h.t = t;\n    h.d = d;\n\treturn h;\n}\n    \nPointLight createPointLight(vec3 p, vec3 c)\n{\n    PointLight pl;\n    pl.p = p;\n    pl.c = c;\n    return pl;\n}\n\nMaterial createMaterial(vec3 c, float d, float s, float r)\n{\n    Material m;\n    m.c = c;\n    m.d = d;\n    m.s = s;\n\tm.r = r;\n    return m;\n}\n\n\/* ========================= *\/\n\/* ====== SCENE SETUP ====== *\/\n\/* ========================= *\/\n\n\/\/ Camera\nCamera _cam;\n\n\/\/ Distance to objects in scene\nfloat _d, _d1, _d2;\n\n\/\/ Lights and materials\nconst int  _numPointLights = 3;\nconst int  _numSpotLights  = 0;\nconst int  _numMaterials   = 2;\n\n\/\/ Setup arrays\nPointLight _pointLights [_numPointLights + 1];\nSpotLight  _spotLights  [_numSpotLights  + 1];\nMaterial   _materials   [_numMaterials   + 1];\n\n\/\/ Forward declarations\nHit castRay(Camera,vec2);\nvec3 getNormal(vec3);\n\n\/* ============================= *\/\n\/* ====== SCENE UTILITIES ====== *\/\n\/* ============================= *\/\n\n\/\/ Rotation\nmat3 rotZ(float a){float s=sin(a),c=cos(a);return mat3(c,-s,0,s,c,0,0,0,1);}\nmat3 rotX(float a){float s=sin(a),c=cos(a);return mat3(1,0,0,0,c,s,0,-s,c);}\nmat3 rotY(float a){float s=sin(a),c=cos(a);return mat3(c,0,-s,0,1,0,s,0,c);} \n\n\/\/ Distance functions\nfloat udBox(vec3 p,vec3 s,float r){return length(max(abs(p)-s,0.))-r;}\nfloat sdSphere(vec3 p,float r){return length(p)-r;}\nfloat sdFloor(vec3 p,float h){return p.y-h;}\nfloat sdCylinder(vec3 p,float r){return length(p.xz)-r;}\n\n\/\/ Miscellaneous\nvec3 repeat(vec3 p,vec3 s)\n{\n\treturn mod(p-s\/2.,s)-s\/2.;\n}\n\n\/\/ circular repeat\n\/\/ r = radius (distance from center p)\n\/\/ n = number of repetitions\n\/\/ s = rotational shift\nvec3 repeat(vec3 p, float r, float n, float s)\n{\n    float a = mod(s+atan(p.x,p.z),TAU\/n)-PI\/n;\n    float l = length(p.xz);\n    return vec3(l*cos(a)-r,p.y,l*sin(a));\n}\n\n\/* ========================= *\/\n\/* ====== SCENE SETUP ====== *\/\n\/* ========================= *\/\n\nvoid initialize()\n{\n    _cam.p = vec3(0,1.5,2)*rotY(-T*0.5);\n    _cam.t = vec3(0,0,0);\n    \n    \/\/Hit h = castRay(_cam,(2.*iMouse.xy-iResolution.xy)\/iResolution.xx);\n\t\/\/_spotLights[0] = SpotLight(_cam.p,normalize(h.p-_cam.p),vec3(1,0,0),PI\/16.);\n    \n    float y = 1.0;\n\n    _pointLights[0] = createPointLight(1.5*vec3(cos(TAU*1.\/3.-PI\/6.),y,sin(TAU*1.\/3.-PI\/6.)),vec3(0.8,1,0)*2.);    \n    _pointLights[1] = createPointLight(1.5*vec3(cos(TAU*2.\/3.-PI\/6.),y,sin(TAU*2.\/3.-PI\/6.)),vec3(0,0.8,1)*2.);    \n    _pointLights[2] = createPointLight(1.5*vec3(cos(TAU*3.\/3.-PI\/6.),y,sin(TAU*3.\/3.-PI\/6.)),vec3(1,0,0.8)*2.);    \n    \n    _materials[0] = createMaterial(vec3(1),1.0,1.0,0.0);\n    _materials[1] = createMaterial(vec3(1),1.0,1.0,1.0);\n}\n\nfloat scene(vec3 p)\n{\n\t_d = _d2 = 1e10;\n\n\t_d1 = sdFloor(p,-0.15);\n    \n    _d2 = min(_d2,udBox(repeat(p,1.,3.,0.),vec3(0.15),0.01));\n    _d2 = min(_d2,sdSphere(repeat(p,1.,3.,PI\/3.),0.15));\n    _d2 = min(_d2,sdCylinder(repeat(p,1.,3.,0.),0.1));\n       \n\t_d = min(_d,_d1);\n\t_d = min(_d,_d2);\n\n\treturn _d;\n}\n\nMaterial getMaterial(Hit h)\n{\n    \/\/ floor\n    if (_d == _d1) return _materials[0];\n    \/\/ balls & pillars\n    if (_d == _d2) return _materials[1];\n    \n    return _materials[0];\n}\n\n\/* ====================== *\/\n\/* ====== MARCHING ====== *\/\n\/* ====================== *\/\n\nHit march(Ray r)\n{\n\tfloat t = 0.0, d;\n\n\tfor(int i = 0; i < S; i++)\n\t{\n\t\td = scene(r.o + r.d*t);\n\n\t\t\/\/ Close enough or too far out\n        if (d < P || t > D) { break; }\n\n\t\tt += d;\n\t}\n\n\treturn createHit(r.o+r.d*t,t,d);\n}\n\nfloat getShadow(vec3 ro, vec3 rt)\n{    \n    vec3 rd = normalize(rt-ro);\n    float tmax = length(rt-ro);\n\tfloat t = P*10.;\n    float s = 1.0;\n\t\n\tfor(int i = 0; i < S; i++)\n\t{\n\t\tfloat d = scene(ro+rd*t);\n\n\t\t\/\/ Direct occlusion -> no light\n        if (d < P) { return 0.0; }\n        \n        \/\/ No occlusion or unreachable -> shadow\n        if (t > tmax || t > D) { break; }\n\n\t\ts = min(s,K*d\/t);\n\t\tt += d;\n\t}\n\t\n\treturn s\/tmax;\n}\n\nvec3 getColor(Hit h)\n{\n    vec3 col = vec3(0);\n    float ref = 1.0;\n    \n    \/\/ Reflection loop\n    for(int i = 0; i < 1+R; i++)\n    {\n        vec3 n = getNormal(h.p);\n        vec3 c = vec3(0);\n        Material m = getMaterial(h);\n\n        \/\/ Calculate point light\n        for(int j = 0; j < _numPointLights; j++)\n        {\n            PointLight l = _pointLights[j];\n            vec3 ln = normalize(l.p-h.p);\n            \n            c += getShadow(h.p,l.p) * mix(l.c, m.c, 0.5) * (\n                mix(1.,max(dot(ln,n),0.0),m.d) +\n                m.s * pow(max(dot(reflect(-ln,n),normalize(_cam.p-h.p)),0.0),100.)\n            )\/length(h.p-l.p);\n        }\n        \n        \/\/ Calculate spot light\n        for(int j = 0; j < _numSpotLights; j++)\n        {\n            SpotLight l = _spotLights[j];\n            vec3 ln = normalize(l.p-h.p);\n            \n            float mask = pow(l.a\/max(acos(dot(l.d,normalize(h.p-l.p))),l.a),20.);\n\n            c += getShadow(h.p,l.p) * mix(l.c, m.c, 0.5) * (\n                m.d * max(dot(ln,n),0.0) +\n                m.s * pow(max(dot(reflect(-ln,n),normalize(_cam.p-h.p)),0.0),100.)\n            )\/length(h.p-l.p) * mask;\n        }\n        \n        \/\/ Mix reflection\n        col = mix(col,c,ref);\n        ref *= m.r;\n\n        \/\/ Only continue if the current object is reflective\n        if (m.r == 0.0) { break; }\n        \n        vec3 r = normalize(reflect(h.p-_cam.p,n));\n        h = march(createRay(h.p+r*P*10.,r));\n    }\n    \n\treturn clamp(col,0.,1.);\n}\n\n\/* ================================ *\/\n\/* ====== MARCHING UTILITIES ====== *\/\n\/* ================================ *\/\n\nvec3 getNormal(vec3 p)\n{\n\tvec2 e = vec2(P,0);\n\n\treturn normalize(vec3(\n\t\tscene(p+e.xyy)-scene(p-e.xyy),\n\t\tscene(p+e.yxy)-scene(p-e.yxy),\n\t\tscene(p+e.yyx)-scene(p-e.yyx)\n\t));\n}\n\nRay lookAt(Camera cam, vec2 c)\n{\n\tvec3 dir = normalize(cam.t-cam.p);\n\tvec3 right = normalize(cross(dir,vec3(0,1,0)));\n\tvec3 up = cross(right,dir);\n\n    #ifdef PERSPECTIVE    \n    return createRay(cam.p*Z,normalize(right*c.x+up*c.y+dir));\n    #else\n   \treturn createRay(cam.p+(right*c.x+up*c.y)*Z*2.0,dir);\n    #endif\n}\n\nHit castRay(Camera _cam, vec2 p)\n{\n\tRay ray = lookAt(_cam,p);\n    Hit hit = march(ray);\n    \n    return hit;\n}\n\n\/* ================== *\/\n\/* ====== MAIN ====== *\/\n\/* ================== *\/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initialize();\n    \n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)\/iResolution.xx;\n\tfragColor = vec4(getColor(march(lookAt(_cam,uv))),1);\n}","name":"","description":"","type":"image"}]}}