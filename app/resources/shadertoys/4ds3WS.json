{"Shader":{"ver":"0.1","info":{"id":"4ds3WS","date":"1378461634","viewed":8388,"name":"Minecraft","username":"reinder","description":"port of javascript minecraft: http:\/\/jsfiddle.net\/uzMPU\/ combined with voxel-shader by inigo quilez (https:\/\/www.shadertoy.com\/view\/4dfGzs)<br\/><br\/>All credits goes to inigo quilez!","likes":70,"published":3,"flags":0,"tags":["voxels","voxel","minecraft"],"hasliked":0},"renderpass":[{"inputs":[{"id":2,"src":"\/presets\/tex01.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Minecraft. Created by Reinder Nijhoff 2013\n\/\/ @reindernijhoff\n\/\/\n\/\/ https:\/\/www.shadertoy.com\/view\/4ds3WS\n\/\/\n\/\/ port of javascript minecraft: http:\/\/jsfiddle.net\/uzMPU\/\n\/\/ original code by Markus Persson: https:\/\/twitter.com\/notch\/status\/275331530040160256\n\/\/ combined with voxel-shader by inigo quilez (https:\/\/www.shadertoy.com\/view\/4dfGzs)\n\/\/ \n\/\/ All credits goes to inigo quilez!\n\/\/\n\n#define SEALEVEL -25.\n#define MAXSTEPS 180 \n\/\/#define HOUSE\n\nvec3 sundir = normalize( vec3(-0.5,0.6,0.7) );\n\nfloat hash( in float n ) {\n    return fract(sin(n)*43758.5453);\n}\nfloat hash( in vec3 x ) {\n\tfloat n = dot( x, vec3(1.0,113.0,257.0) );\n    return fract(sin(n)*43758.5453);\n}\nvec3 hash3( vec3 n ) {\n\treturn fract(sin(n)*vec3(653.5453123,4456.14123,165.340423));\n}\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D( iChannel0, (uv+ 0.5)\/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\nfloat noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn texture2D( iChannel0, (uv+118.4)\/256.0, -100.0 ).x;\n}\nfloat sum(vec3 v) { return dot(v, vec3(1.0)); }\n\n\/\/ port of minecraft\n\nbool getMaterialColor( int i, vec2 coord, out vec3 color ) {\n\t\/\/ 16x16 tex\n\tvec2 uv = floor( coord );\n\n    float n = uv.x + uv.y*347.0 + 4321.0 * float(i);\n\tfloat h = hash(n);\n\t\t\n    float br = 1. - h * (96.\/255.);\n\tcolor = vec3( 150.\/255., 108.\/255.,  74.\/255.); \/\/ 0x966C4A;\n\t\t\t\n\tfloat xm1 = mod((uv.x * uv.x * 3. + uv.x * 81.) \/ 4., 4.);\n\t\n\tif (i == 1) {\n\t\tif( uv.y < (xm1 + 18.)) {\n\t\t\tcolor = vec3( 106.\/255., 170.\/255.,  64.\/255.); \/\/ 0x6AAA40;\n\t\t} else if (uv.y < (xm1 + 19.)) {\n\t\t\tbr = br * (2. \/ 3.);\n\t\t}\n\t}\n\tif (i == 4) {\n\t\tcolor = vec3( 127.\/255., 127.\/255., 127.\/255.); \/\/ 0x7F7F7F;\n\t}\t\n\tif (i == 7) {\n\t\tcolor = vec3( 103.\/255., 82.\/255.,  49.\/255.); \/\/ 0x675231;\n\t\tif ( h < 0.5 ) {\n\t\t\tbr = br * (1.5 - mod(uv.x, 2.));\n\t\t}\t\n\t}\t\n#ifdef HOUSE\n\tif (i == 5) {\n\t\tcolor = vec3( 181.\/255.,  58.\/255.,  21.\/255.); \/\/ 0xB53A15;\n\t\tif ( mod(uv.x + (floor(uv.y \/ 4.) * 5.), 8.) == 0. || mod( uv.y, 4.) == 0.) {\n\t\t\tcolor = vec3( 188.\/255., 175.\/255., 165.\/255.); \/\/ 0xBCAFA5;\n\t\t}\n\t}\n#endif\n\tif (i == 9) {\n\t\tcolor = vec3(  64.\/255.,  64.\/255., 255.\/255.); \/\/ 0x4040ff;\n\t}\t\n\tif (i == 8) {\n\t\tcolor = vec3(  80.\/255., 217.\/255.,  55.\/255.); \/\/ 0x50D937;\n\t\tif ( h < 0.5) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (i == 10) {\n\t\tcolor = vec3(0.65,0.68,0.7)*1.35; \n\t\tbr = 1.;\n\t}\n\tcolor *= br;\n\t\n\treturn true;\n}\n\n\/\/=====================================================================\n\/\/ Code by inigo quilez - iq\/2013:\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat mapTerrain( vec2 p ) {\n\tp *= 0.02;\n\n\tfloat f;\n    f  = 0.500*texture2D( iChannel1, p*0.01, -100. ).x;\n    f += 0.1250*noise( p*4.01 );\n\treturn  max( 50.0*f-30., SEALEVEL);\n}\n\nvec3 gro = vec3(0.0);\n\nbool map(in vec3 c ) {\n\tvec3 p = c + 0.5;\n    \n\tfloat f = mapTerrain( p.xz );\n\n\tvec2 fc = floor( c.xz * 0.05 );\n\tvec3 h = hash3( vec3( fc*vec2(213.123,2134.125), mapTerrain(fc) ) );\t\n\tbool hit = false;\n\t\n\tif( h.z > 0.75 ) {\n\t\tvec2 tp = floor(fc*20.+mod(h.yx*154.43125, 10.)) + 5.5;\n\t\tfloat h = mapTerrain( tp );\n\t\tif( h > SEALEVEL ) {\t\t\n\t\t\tif( all( equal( tp, p.xz ) ) ) hit = c.y < h+4.; \/\/ treetrunk\n\t\t\tif( distance( p, vec3( tp.x, h+6., tp.y ) ) < 2.5 ) hit = true; \/\/ leaves\n\t\t} \n\t}\n\t\n\thit = c.y < f ? true:hit; \/\/ ground\n\t\n\tif( c.y > 8. && \n\t   sin( (c.y-8.)*(3.1415\/32.)) * (10.\/(c.y-7.)) * noise( c*0.08+(0.7*iGlobalTime)*vec3(0.3, 0.07, 0.12) ) \n\t   > 0.6 ) hit = true; \/\/ clouds\n\n#ifdef HOUSE\n\tvec2 hc = abs(c.xz - vec2( 32., 130.)); \/\/ house\n\tif( all( lessThan( hc, vec2( 6., 10. ) ) ) && c.y < -hc.x-12. ) {\n\t\thit = true;\n\t\tif( all( lessThan( hc, vec2( 2., 10. ) ) ) && c.y < -18. && c.y > -23. ) {\n\t\t\thit = false;\n\t\t}\n\t\tif( all( lessThan( hc, vec2( 5., 9. ) ) ) && c.y < -18. && c.y > -23. ) {\n\t\t\thit = false;\n\t\t}\n\t}\n#endif\n\t\n\tif( distance( gro, c ) < 1.5 ) return false;\n\t\n\treturn hit;\n}\n\n\nint mapMaterial(in vec3 c ) {\n\tint mat = 0;\n\tvec3 p = c + 0.5;\n    \n\tfloat f = ceil( mapTerrain( p.xz ) ); \n\t\n\tif( p.y <= f ) mat = 1; \/\/ ground\n\telse if( p.y < f+3. ) mat = 7; \/\/ treetrunk\n\telse if( p.y < f+10. ) mat = 8; \/\/ leaves\n\telse mat = 10; \/\/ clouds\n\t\n#ifdef HOUSE\n\tvec2 hc = abs(c.xz - vec2( 32., 130.));\n\tif( c.y < 0. && all( lessThan( hc, vec2( 6., 10. ) ) ) ) {\n\t\tmat = 5;\n\t\tif( !map( c+vec3(0.,1.,0.) ) ) mat = 6;\n\t}\n#endif\n\t\n\treturn mat;\n}\n\nfloat castRay( in vec3 ro, in vec3 rd, out vec3 oVos, out vec3 oDir ) {\n\tvec3 pos = floor(ro);\n\tvec3 ri = 1.0\/rd;\n\tvec3 rs = sign(rd);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tfloat res = 0.0;\n\tvec3 mm = vec3(0.0);\n\tbool hit = false;\n\t\n\tfor( int i=0; i<MAXSTEPS; i++ ) \n\t{\n\t\tif( hit ) break;\n\t\tmm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t\tif( map(pos) ) { hit = true;}\n\t}\n\n\tvec3 nor = -mm*rs;\n\tvec3 vos = pos;\n\t\n    \/\/ intersect the cube\t\n\tvec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n\tfloat t = max ( mini.x, max ( mini.y, mini.z ) );\n\t\n\toDir = mm;\n\toVos = vos;\n\n\treturn hit?t:0.;\n\n}\n\nfloat castVRay( in vec3 ro, in vec3 rd, in float maxDist ) {\n\n\tvec3 pos = floor(ro);\n\tvec3 ri = 1.0\/rd;\n\tvec3 rs = sign(rd);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tfloat res = 1.0;\n\t\n\tfor( int i=0; i<18; i++ ) \n\t{\n\t\tif( map(pos) ) {res=0.0; break; }\n\t\tvec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n\t\n\treturn res;\n\n}\n\nvec3 path( float t ) {\n    vec2 p  = 100.0*sin( 0.02*t*vec2(1.0,1.2) + vec2(0.1,0.9) );\n\t     p +=  50.0*sin( 0.04*t*vec2(1.3,1.0) + vec2(1.0,4.5) );\n\t\n\treturn vec3( p.x, mapTerrain(p)+2.+4.*(1.-cos(iGlobalTime*0.1)), p.y );\n}\n\n\n\/\/=====================================================================\n\/\/ Ambient occlusion \n\nvec4 edges( in vec3 vos, in vec3 nor, in vec3 dir )\n{\n\tvec3 v1 = vos + nor + dir.yzx;\n\tvec3 v2 = vos + nor - dir.yzx;\n\tvec3 v3 = vos + nor + dir.zxy;\n\tvec3 v4 = vos + nor - dir.zxy;\n\n\tvec4 res = vec4(0.0);\n\tif( map(v1) ) res.x = 1.0;\n\tif( map(v2) ) res.y = 1.0;\n\tif( map(v3) ) res.z = 1.0;\n\tif( map(v4) ) res.w = 1.0;\n\n\treturn res;\n}\n\nvec4 corners( in vec3 vos, in vec3 nor, in vec3 dir )\n{\n\tvec3 v1 = vos + nor + dir.yzx + dir.zxy;\n\tvec3 v2 = vos + nor - dir.yzx + dir.zxy;\n\tvec3 v3 = vos + nor - dir.yzx - dir.zxy;\n\tvec3 v4 = vos + nor + dir.yzx - dir.zxy;\n\n\tvec4 res = vec4(0.0);\n\tif( map(v1) ) res.x = 1.0;\n\tif( map(v2) ) res.y = 1.0;\n\tif( map(v3) ) res.z = 1.0;\n\tif( map(v4) ) res.w = 1.0;\n\n\treturn res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \/\/ inputs\t\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x\/ iResolution.y;\n\t\n    vec2 mo = iMouse.xy \/ iResolution.xy;\n    if( iMouse.w<=0.00001 ) mo=vec2(0.0);\n\t\n\tfloat time = 2.0*iGlobalTime + 50.0*mo.x;\n    \/\/ camera\n\t\n\tfloat cr = 0.2*cos(0.1*iGlobalTime);\t\n\tvec3 ro = path( time );\n\tvec3 ta = path( time+4. );\n\tta.y = ro.y;\n\tgro = ro;\n\t\n\t\/\/ build ray\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize(cross( vec3(sin(cr),cos(cr),0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n\tfloat r2 = p.x*p.x*0.32 + p.y*p.y;\n    p *= (7.0-sqrt(37.5-11.5*r2))\/(r2+1.0);\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n\tfloat sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n\tvec3 col = vec3(0.6,0.71,0.75) - rd.y*0.2*vec3(1.0,0.5,1.0) + 0.15*0.5;\n\tcol += 0.2*vec3(1.0,.6,0.1)*pow( sun, 8.0 );\n\tcol *= 0.95;\n\t\n\tvec3 vos, dir;\n\tfloat t = castRay( ro, rd, vos, dir );\n\t\n\tif( t>0.0 ) {\n\t\tvec3 nor = -dir*sign(rd);\n\t\t\n\t\tvec3 pos = ro + rd*t;\n\t\tint mMat = mapMaterial( vos );\t\t\t\n\t\tvec3 mpos = mod( pos * 16., 16. );\n\t\t\n\t\tif( mMat == 1 ) {\n\t\t\tif( map( vos + vec3(0., 1., 0. ) ) ) {\n\t\t\t\tmMat = hash(vos) > 0.5?2:4; \n\t\t\t\tif( map( vos + vec3(0., 2., 0. ) ) ) mMat = 4;\n\t\t\t}\n\t\t\tif ( vos.y < SEALEVEL ) mMat = 9;\t\n\t\t} \n\t\t\n\t\tvec3 mCol;\n\t\tgetMaterialColor( mMat, nor.y!=0.?mpos.xz:nor.x!=0.?-mpos.zy+vec2(32.,32.):-mpos.xy+vec2(32.,32.),mCol );\n\t\t\n\t\t\/\/ lighting\n\t\tfloat dif = clamp( dot( nor, sundir ), 0.0, 1.0 );\n\t\tfloat sha = 0.0; if( dif>0.01) sha=castVRay(pos+nor*0.01,sundir,32.0);\n\t\tfloat bac = clamp( dot( nor, normalize(sundir*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\n\t\tfloat sky = 0.5 + 0.5*nor.y;\n\t\tfloat amb = 1.0;\/\/clamp(0.75 + pos.y\/100.0,0.0,1.0);\n\t\t\t\n        \/\/ ambient occlusion\n\t\t\n        vec4 ed = edges( vos, nor, dir );\n        vec4 co = corners( vos, nor, dir );\n        vec3 uvw = pos - vos;\n        vec2 uv = vec2( dot(dir.yzx, uvw), dot(dir.zxy, uvw) );\n\t\t\n        float occ = 0.0; \n        \/\/ (for edges)\n        occ += (    uv.x) * ed.x;\n        occ += (1.0-uv.x) * ed.y;\n        occ += (    uv.y) * ed.z;\n        occ += (1.0-uv.y) * ed.w;\n        \/\/ (for corners)\n        occ += (      uv.y *     uv.x ) * co.x*(1.0-ed.x)*(1.0-ed.z);\n        occ += (      uv.y *(1.0-uv.x)) * co.y*(1.0-ed.z)*(1.0-ed.y);\n        occ += ( (1.0-uv.y)*(1.0-uv.x)) * co.z*(1.0-ed.y)*(1.0-ed.w);\n        occ += ( (1.0-uv.y)*     uv.x ) * co.w*(1.0-ed.w)*(1.0-ed.x);\n        occ = 1.0 - occ\/8.0;\n        occ = occ*occ;\n        occ = occ*occ;\n\t\t\n\t\t\n\t\tvec3 lin = vec3(0.0);\n\t\tlin += 4.0*dif*vec3(1.)*(0.5+0.5*occ)*(0.25+0.75*sha);\n\t\tlin += 1.8*bac*vec3(1.0,0.5,1.0)*(0.5+0.5*occ);\n\t\tlin += 4.0*sky*vec3(0.6,0.71,0.75)*occ;\n\t\n\t\t\n\t\tif( mMat == 10 ) {\n\t\t\tcol = mix( col, mCol*lin*0.6, 0.3);\t\t\n\t\t} else {\n\t\t\t\/\/ atmospheric\n\t\t\tcol = mix( mCol*lin*0.2, col, 1.0-exp(-0.0000001*t*t*t) );\n\t\t}\t\t\t\n\t}\n\t\n\tcol += 0.2*vec3(1.0,0.4,0.2)*pow( sun, 3.0 );\n\t\n    \/\/ gamma\t\n\tcol = pow( col, vec3(0.45) );\n\t\n\t\/\/ contrast\n    col = col* 0.25 + 0.75*col*col*(3.0-2.0*col);\n\t\t\n    col = clamp( col, 0.0, 1.0 );\n\n\t\/\/ vignetting\t\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}