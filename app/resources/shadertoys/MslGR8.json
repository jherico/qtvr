{"Shader":{"ver":"0.1","info":{"id":"MslGR8","date":"1362747060","viewed":2491,"name":"dithering: Color Banding Removal","username":"hornet","description":"See http:\/\/loopit.dk\/banding_in_games.pdf for details.<br\/>Test for various ways of removing banding, including a number of different dithering patterns and a color-offset algorithm for purely grayscale images.","likes":19,"published":3,"flags":0,"tags":["noise","banding","grayscale","color","dither","dithering"],"hasliked":0},"renderpass":[{"inputs":[{"id":15,"src":"\/presets\/tex10.png","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":28,"src":"\/presets\/tex15.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/#define ANIMATED\n\/\/#define CHROMATIC\n\n\n\/\/note: from https:\/\/www.shadertoy.com\/view\/4djSRW\n\/\/ This set suits the coords of of 0-1.0 ranges..\n#define MOD3 vec3(443.8975,397.2973, 491.1871)\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n\/\/ ====\n\n\/\/note: outputs x truncated to n levels\nfloat trunc( float x, float n )\n{\n\treturn floor(x*n)\/n;\n}\n\n\/\/note: returns [-intensity;intensity[, magnitude of 2x intensity\n\/\/note: from \"NEXT GENERATION POST PROCESSING IN CALL OF DUTY: ADVANCED WARFARE\"\n\/\/      http:\/\/advances.realtimerendering.com\/s2014\/index.html\nfloat InterleavedGradientNoise( vec2 uv )\n{\n    const vec3 magic = vec3( 0.06711056, 0.00583715, 52.9829189 );\n    return fract( magic.z * fract( dot( uv, magic.xy ) ) );\n}\n\n\/\/ note: valve edition\n\/\/       from http:\/\/alex.vlachos.com\/graphics\/Alex_Vlachos_Advanced_VR_Rendering_GDC2015.pdf\n\/\/ note: input in pixels (ie not normalized uv)\nvec3 ScreenSpaceDither( vec2 vScreenPos )\n{\n\t\/\/ Iestyn's RGB dither (7 asm instructions) from Portal 2 X360, slightly modified for VR\n\t\/\/vec3 vDither = vec3( dot( vec2( 171.0, 231.0 ), vScreenPos.xy + iGlobalTime ) );\n    vec3 vDither = vec3( dot( vec2( 171.0, 231.0 ), vScreenPos.xy ) );\n    vDither.rgb = fract( vDither.rgb \/ vec3( 103.0, 71.0, 97.0 ) );\n    return vDither.rgb \/ 255.0; \/\/note: looks better without 0.375...\n\n    \/\/note: not sure why the 0.5-offset is there...\n    \/\/vDither.rgb = fract( vDither.rgb \/ vec3( 103.0, 71.0, 97.0 ) ) - vec3( 0.5, 0.5, 0.5 );\n\t\/\/return (vDither.rgb \/ 255.0) * 0.375;\n}\n\n\/\/ ===============================================\n\/\/note: from https:\/\/www.shadertoy.com\/view\/4sBSDW\n#define F1 float\n#define F2 vec2\n#define F3 vec3\n#define F4 vec4\n\nF1 Noise(F2 n,F1 x){n+=x;return fract(sin(dot(n.xy,F2(12.9898, 78.233)))*43758.5453)*2.0-1.0;}\n\n\/\/ Step 1 in generation of the dither source texture.\nF1 Step1(F2 uv,F1 n){\n    F1 a=1.0,b=2.0,c=-12.0,t=1.0;   \n    return (1.0\/(a*4.0+b*4.0-c))*(\n        Noise(uv+F2(-1.0,-1.0)*t,n)*a+\n        Noise(uv+F2( 0.0,-1.0)*t,n)*b+\n        Noise(uv+F2( 1.0,-1.0)*t,n)*a+\n        Noise(uv+F2(-1.0, 0.0)*t,n)*b+\n        Noise(uv+F2( 0.0, 0.0)*t,n)*c+\n        Noise(uv+F2( 1.0, 0.0)*t,n)*b+\n        Noise(uv+F2(-1.0, 1.0)*t,n)*a+\n        Noise(uv+F2( 0.0, 1.0)*t,n)*b+\n        Noise(uv+F2( 1.0, 1.0)*t,n)*a+\n        0.0);}\n\n\/\/ Step 2 in generation of the dither source texture.\nF1 Step2(F2 uv,F1 n){\n    F1 a=1.0,b=2.0,c=-2.0,t=1.0;\n    return (4.0\/(a*4.0+b*4.0-c))*(\n        Step1(uv+F2(-1.0,-1.0)*t,n)*a+\n        Step1(uv+F2( 0.0,-1.0)*t,n)*b+\n        Step1(uv+F2( 1.0,-1.0)*t,n)*a+\n        Step1(uv+F2(-1.0, 0.0)*t,n)*b+\n        Step1(uv+F2( 0.0, 0.0)*t,n)*c+\n        Step1(uv+F2( 1.0, 0.0)*t,n)*b+\n        Step1(uv+F2(-1.0, 1.0)*t,n)*a+\n        Step1(uv+F2( 0.0, 1.0)*t,n)*b+\n        Step1(uv+F2( 1.0, 1.0)*t,n)*a+\n        0.0);}\n\n\/\/ Used for stills.\nF3 Step3(F2 uv){\n    F1 a=Step2(uv,0.07);    \n    #ifdef CHROMATIC\n    F1 b=Step2(uv,0.11);    \n    F1 c=Step2(uv,0.13);\n    return F3(a,b,c);\n    #else\n    \/\/ Monochrome can look better on stills.\n    return F3(a);\n    #endif\n}\n\n\/\/ Used for temporal dither.\nF3 Step3T(F2 uv){\n    F1 a=Step2(uv,0.07*(fract(iGlobalTime)+1.0));    \n    F1 b=Step2(uv,0.11*(fract(iGlobalTime)+1.0));    \n    F1 c=Step2(uv,0.13*(fract(iGlobalTime)+1.0));\n    return F3(a,b,c);}\n\/\/ ====\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pos = ( fragCoord.xy \/ iResolution.xy );\n\n    const float c0 = 32.0;\n    \n    #if defined( ANIMATED )\n\tfloat its = mix( 0.0, 1.0 \/ c0, pos.x + 0.25*sin(0.5*iGlobalTime) );\n    #else\n    float its = mix( 0.0, 1.0 \/ c0, pos.x );\n    #endif\n    \n\tvec3 outcol;\n\n    if ( pos.y > 11.0\/12.0 )\n\t{\n\t\toutcol = vec3(its);\n\t}\n\telse if ( pos.y > 10.0\/12.0 )\n\t{\n\t\toutcol = vec3( its + 0.5 \/ 255.0 ); \/\/rounded\n\t}\n\telse if ( pos.y > 9.0\/12.0 )\n\t{\n\t\t\/\/note: scanline dithering\n\t\tfloat ofs = floor(mod(fragCoord.y,2.0))*0.5;\n\t\toutcol = vec3( its + ofs\/255.0);\t\t\n\t}\n\telse if( pos.y > 8.0\/12.0)\n\t{\n        \/\/note: offset r, g, b, limbo-style\n\t\toutcol = vec3(its, its + 1.0\/3.0\/256.0, its + 2.0\/3.0\/256.0);\t\t\n        \n\t\t\/\/note: \"luminance\" incr\n\t\t\/\/float e = its - trunc( its, 255.0 ); \/\/ = fract( 255.0 * its ) \/ 255.0;\n\t\t\/\/vec2 rg = mod( floor( vec2(4.0,2.0) * e * 255.0), 2.0 );\n\t\t\/\/outcol = floor( its*255.0 )\/255.0 + vec3(rg,0.0) \/ 255.0;\t\t\n\t}\n    else if ( pos.y > 7.0\/12.0 )\n    {\n        \/\/note: 2x2 ordered dithering, ALU-based (omgthehorror)\n\t\tvec2 ij = floor(mod( fragCoord.xy, vec2(2.0) ));\n\t\tfloat idx = ij.x + 2.0*ij.y;\n\t\tvec4 m = step( abs(vec4(idx)-vec4(0,1,2,3)), vec4(0.5) ) * vec4(0.75,0.25,0.00,0.50);\n\t\tfloat d = m.x+m.y+m.z+m.w;\n\n\t\t\/\/alternative version, from https:\/\/www.shadertoy.com\/view\/MdXXzX\n\t\t\/\/vec2 n = floor(abs( fragCoord.xy ));\n\t\t\/\/vec2 s = floor( fract( n \/ 2.0 ) * 2.0 );\n\t\t\/\/float f = (  2.0 * s.x + s.y  ) \/ 4.0;\n\t\t\/\/float rnd = (f - 0.375) * 1.0;\n\t\t\/\/outcol = vec3(its + rnd\/255.0 );\n\t\t\n\t\toutcol = vec3( its + d\/255.0 );\n    }\n\telse if ( pos.y > 6.0\/12.0 )\n\t{\n\t\t\/\/note: 8x8 ordered dithering, texture-based\n\t\tconst float MIPBIAS = -10.0;\n\t\tfloat ofs = texture2D( iChannel0, fragCoord.xy\/iChannelResolution[0].xy, MIPBIAS ).r;\n\n\t\toutcol = vec3( its + ofs\/255.0 );\n\t}\n    else if ( pos.y > 5.0\/12.0 )\n    {\n        float rnd = InterleavedGradientNoise( fragCoord ) \/ 255.0;\n        outcol = its + vec3(rnd);\n    }\n\telse if( pos.y > 4.0\/12.0 )\n\t{\n\t\toutcol = vec3(its) + ScreenSpaceDither( fragCoord );\n\t}\n    else if( pos.y > 3.0\/12.0 )\n    {\n        \/\/note: from comment by CeeJayDK\n\t\tfloat dither_bit = 8.0; \/\/Bit-depth of display. Normally 8 but some LCD monitors are 7 or even 6-bit.\t\n\n\t\t\/\/Calculate grid position\n\t\tfloat grid_position = fract( dot( fragCoord.xy - vec2(0.5,0.5) , vec2(1.0\/16.0,10.0\/36.0) + 0.25 ) );\n\n\t\t\/\/Calculate how big the shift should be\n\t\tfloat dither_shift = (0.25) * (1.0 \/ (pow(2.0,dither_bit) - 1.0));\n\n\t\t\/\/Shift the individual colors differently, thus making it even harder to see the dithering pattern\n\t\tvec3 dither_shift_RGB = vec3(dither_shift, -dither_shift, dither_shift); \/\/subpixel dithering\n\n\t\t\/\/modify shift acording to grid position.\n\t\tdither_shift_RGB = mix(2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position); \/\/shift acording to grid position.\n\n\t\t\/\/shift the color by dither_shift\n\t\toutcol = its + 0.5\/255.0 + dither_shift_RGB; \n    }\n    else if ( pos.y > 2.0\/12.0 )\n\t{\n        #if defined( ANIMATED )\n        outcol = vec3(its) + (0.5+Step3T(fragCoord.xy))\/255.0;\n        #else\n        outcol = vec3(its) + (0.5+Step3(fragCoord.xy))\/255.0;\n        #endif\n\t}\n    else if ( pos.y > 1.0\/12.0 )\n    {\n        \/\/note: triangluarly distributed noise, 1.5LSB\n        vec2 seed = pos;\n        #if defined( ANIMATED )\n        seed += fract(iGlobalTime);\n        #endif\n        \n        #ifdef CHROMATIC\n\t\tvec3 rnd = hash32( seed ) + hash32(seed + 0.59374) - 0.5;\n        #else\n        vec3 rnd = vec3(hash12( seed ) + hash12(seed + 0.59374) - 0.5 );\n        #endif\n        \n\t\toutcol = vec3(its) + rnd\/255.0;\n    }\n\telse\n\t{\n        \/\/note: uniform noise by 1 LSB\n\t\t\/\/note: better to use separate rnd for rgb\n        vec2 seed = pos;\n        #if defined( ANIMATED )\n        seed += fract(iGlobalTime);\n        #endif\n        \n        #ifdef CHROMATIC\n\t\tvec3 rnd = hash32( seed ); \n        #else\n        vec3 rnd = vec3( hash12( seed ) );\n        #endif\n\t\t\n\t\t\/\/note: texture-based\n\t\t\/\/const float MIPBIAS = -10.0;\n\t\t\/\/vec2 uv = fragCoord.xy \/ iChannelResolution[1].xy + vec2(89,27)*fract(iGlobalTime);\n\t\t\/\/float rnd = texture2D( iChannel1, uv, MIPBIAS ).r;\n\t\t\n\t\toutcol = vec3( its ) + rnd\/255.0;\n\t}\n\n\toutcol.rgb = floor( outcol.rgb * 255.0 ) \/ 255.0;\n    outcol.rgb *= c0;\n\n    \/\/note: black bars\n    outcol -= step( mod(pos.y, 1.0\/12.0), 0.0025);\n\n\tfragColor= vec4( outcol, 1.0 );\n}\n","name":"","description":"","type":"image"}]}}