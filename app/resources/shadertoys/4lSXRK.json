{"Shader":{"ver":"0.1","info":{"id":"4lSXRK","date":"1444764867","viewed":601,"name":"Another Cloudy Tunnel","username":"aiekick","description":"the cloudy tech come from the <a href=\"https:\/\/www.shadertoy.com\/view\/MljXDw\"  class=\"regular\" target=\"_blank\">Cloudy Spikeball<\/a> shader from duke<br\/>jute for the fun => click on screen for a second visu mode<br\/>Comment line 14 to see antoher cloud version","likes":6,"published":3,"flags":0,"tags":["3d","raymarching","tunnel","cloud","cloudy"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Stephane Cuillerdier - Aiekick\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/* \n\tbased on my Tunnel experiment 1 : \n\t\thttps:\/\/www.shadertoy.com\/view\/llBXWR\n\n\tthe cloudy famous tech come from the shader of duke : https:\/\/www.shadertoy.com\/view\/MljXDw\n        Himself a Port of a demo by Las => http:\/\/www.pouet.net\/topic.php?which=7920&page=29&x=14&y=9\n\n\tJust for the fun, if you click on screen you have a second mode of cam :)\n*\/\n\n#define BASE_VERSION\n\nfloat t;\n\nfloat cosPath(vec3 p, vec3 dec){return dec.x * cos(p.z * dec.y + dec.z);}\nfloat sinPath(vec3 p, vec3 dec){return dec.x * sin(p.z * dec.y + dec.z);}\n\nvec2 getCylinder(vec3 p, vec2 pos, float r, vec3 c, vec3 s)\n{\n\treturn p.xy - pos - vec2(cosPath(p, c), sinPath(p, s));\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ FROM Shader Cloudy spikeball from duke : https:\/\/www.shadertoy.com\/view\/MljXDw\nfloat pn( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D(iChannel0, (uv+ 0.5)\/256.0, -100.0 ).yx;\n\treturn -1.0+2.4*mix( rg.x, rg.y, f.z );\n}\n\nfloat fpn(vec3 p) \n{\n\tp.z += t*50.*(1.-step(iMouse.z,0.));\n#ifdef BASE_VERSION \n\treturn pn(p*.06125)*.6 + pn(p*.125)*.3 + pn(p*.25)*.15; \/\/original\n#else\n    return pn(p*0.02)*1.98 + pn(p*0.02)*0.62 + pn(p*0.09)*0.5;\n#endif\n}\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat map(vec3 p)\n{\n\tfloat pnNoise = fpn(p*13.);\n\tfloat path = sinPath(p ,vec3(6.2, .33, 0.));\n\tfloat bottom = p.y + pnNoise;\n\tfloat cyl = 0.;vec2 vecOld;\n\tfor (float i=0.;i<6.;i++)\n\t{\n\t\tfloat x = 1. * i;\n\t\tfloat y\t= .88 + 0.0102*i;\n\t\tfloat z\t = -0.02 -0.16*i;\n\t\tfloat r = 4.4 + 2.45 * i;\n\t\tvec2 vec = getCylinder(p, vec2(path, 3.7 * i), r , vec3(x,y,z), vec3(z,x,y));\n\t\tcyl = r - min(length(vec), length(vecOld));\n\t\tvecOld = vec;\t\n\t}\n\tcyl += pnNoise;\n\tcyl = min(cyl, bottom);\n\treturn cyl;\n}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cu, vec3 cv)\n{\n\tvec3 rov = normalize(cv-ro);\n    vec3 u =  normalize(cross(cu, rov));\n    vec3 v =  normalize(cross(rov, u));\n\tfloat fov = 3.;\n    vec3 rd = normalize(rov + fov*u*uv.x + fov*v*uv.y);\n    return rd;\n}\n\nvoid mainImage( out vec4 f, in vec2 g )\n{\n    f = vec4(0.0);\n    t = iGlobalTime;\n\tvec2 si = iResolution.xy;\n\tvec2 uv = (2.*g-si)\/min(si.x, si.y);\n    vec3 p = vec3(0);\n\tp.y = sin(t*.2)*16.+16.; \/\/ 0 => 32\n\tp.z = t*5.*step(iMouse.z,0.);\n\tvec3 rd = cam(uv, p, vec3(0,1,0), p + vec3(0,0,1));\n\tfloat s = 1., h = 0.1, td = 0., w, prec=0.001;\n    for(int i=0;i<200;i++)\n\t{      \n\t\tif(s<prec||td>.95) break;\n        s = map(p) * (s>0.001?.1:.2);\n\t\tif (s < h)\n\t\t{\n\t\t\tw = (1.-td) * (h-s);\n\t\t\tf += w;\n\t\t\ttd += w;\n\t\t}\n\t\ttd += .005;\n\t\ts = max(s, 0.03);\n\t\tp += rd*s;\t\n   \t}\n}\n","name":"","description":"","type":"image"}]}}