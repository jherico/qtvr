{"Shader":{"ver":"0.1","info":{"id":"Xsd3Wj","date":"1452205911","viewed":94,"name":"psychedeliscope","username":"wjbgrafx","description":"Vertex coordinates of polygons of varying number of sides and radii are calculated and connected with lines to form \"star polygons\".","likes":0,"published":3,"flags":0,"tags":["2d","geometry","polarcoordinates","starpolygons"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/*\n\tPsychedeliscope\n\t===============\n\n\t1-05-16\t\n\tRecreating an old java applet in a shader.\t\n\t\n\tI first encountered \"star polygons\" in Robert Dixon's 1987 book,\n\t'Mathographics' ( pg. 126 ). \n\t\n\tOne of the formulas in the \"Computer Drawings\" chapter shows how a star \n\tpolygon of a given number of points can be drawn, working in polar\n    coordinates. The formula is roughly this :\n\n\tFor a polygon of N points and S sides:\n \n\tfor( S = 0; S <= N; S++ )\n                                             \n    Angle = 360 * S * M \/ N; \/\/ where M is a whole number between 1 and N\n                             \/\/ which shares no common factor with N. \n\n\tThe angle increment from one star point to the next is determined by this\n\tequation, above, and then the polar coordinates ( angle, radius ) are\n\tconverted to Cartesian with these equations:\n\t\n                       x = R * Cos( Angle );\n                       y = R * Sin( Angle );\n                       \n\tIf values of M and N are chosen which do share a common factor, the angle \n\tincrement is still 360 * M \/ N, but since M \/ N can be reduced by a common \n\tfactor, the number of sides in the polygon is the reduced value of N, and \n\tthat polygon is drawn over itself the reduced value of M times.\n    \n    For example, if M = 8 and N = 12, 8 \/ 12 = 2 \/ 3, and a 3-sided polygon is\n    drawn in the exact same position, 2 times.\n \t\t\n*\/\n\/\/==============================================================================\n\n\/\/ cosine based palette, 4 vec3 params\n\/\/ http:\/\/www.iquilezles.org\/www\/articles\/palettes\/palettes.htm\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b * cos( 6.28318 * ( c * t + d ) );\n}\n\n\/\/------------------------------------------------------------------------------\n\n\/\/ IQ rainbow palette.\n\nvec3 b = vec3( 0.5, 0.5,  0.5 ),\n     c = vec3( 0.5, 0.5,  0.5 ),\n     d = vec3( 1.0, 1.0,  1.0 ),\n     e = vec3( 0.0, 0.33, 0.67 );\t\t\n\n\/\/------------------------------------------------------------------------------\n\nfloat random( vec2 p )\n{\n\treturn fract( sin( dot( p.xy, vec2( 12.9898, 78.233 ) ) ) * \n\t                                             43758.5453123 + iGlobalTime );\n}\n\t                                                           \n\/\/------------------------------------------------------------------------------\n\n\/\/ DRAW LINE : antialiased\n\/\/ =========\n\n\/\/ by mlatu\n\/\/ https:\/\/stackoverflow.com\/questions\/15276454\/\n\/\/                   is-it-possible-to-draw-line-thickness-in-a-fragment-shader\n\nfloat drawLine( vec2 p1, vec2 p2, vec2 uv, float thickness ) \n{\n\tfloat a = abs( distance( p1, uv ) ),\n\t      b = abs( distance( p2, uv ) ),\n\t      c = abs( distance( p1, p2 ) );\n\t\n\tif ( a >= c || b >=  c ) return 0.0;\n\t\n\tfloat p = (a + b + c) * 0.5;\n\t\n\t\/\/ median to ( p1, p2 ) vector\n\tfloat h = 2.0 \/ c * sqrt( p * ( p - a ) * ( p - b ) * ( p - c ) );\n\t\n\treturn mix( 1.0, 0.0, smoothstep( 0.5 * thickness, 1.5 * thickness, h ) );\n}\n\n\/\/------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\/\/ -1 to 1 screen\n\t\/\/ --------------\n\t\/\/ Adjust aspect ratio, normalize coords, center origin in xy-plane.\t\n\t\/\/ xRange = -1.7777778 to 1.775926, yRange = -1.0 to 0.9981482 at 1920x1080\n\tvec2 curPix = ( -iResolution.xy + 2.0 * fragCoord.xy ) \/ iResolution.y;\n\n\tfloat time = iGlobalTime;\n\t\n\t\/\/ Rotating screen.\n\t\/\/-----------------\t\n\tfloat x = curPix.x,\n\t      y = curPix.y,\n\t      ang = 2.0 * sin( time * 1.5 ); \n\t\n\tcurPix.x += x * cos( ang ) - y * sin( ang );\n\tcurPix.y += x * sin( ang ) + y * cos( ang );\t\n\t\/\/--------------------------------------\n\t\n\t\/\/ ( 1.0 - abs( 2.0 * fract( time ) - 1.0 ) ) produces a linear progression\n\t\/\/ from 0.0 to 1.0 to 0.0.\n\t\n\tint numSides =  \n\t       4 + int( 24.0 * ( 1.0 - abs( 2.0 * fract( time * 0.05 ) - 1.0 ) ) ),\n\t    \n\t    \/\/ Randomized numRevs value makes fuzzy figures. \n\t    \/\/ Larger multiplier = fuzzier.\n\t    \/\/numRevs = 17 + int( random( curPix ) * 1.5 ); \/\/ * 3.0\n\t    \n\t    \/\/ Constant numRevs for sharp lines. 17 is lowest prime that avoids \n\t    \/\/ drawing straight horizontal lines\t\n\t    numRevs = 17; \n\t\n\tfloat angle = 0.0,\n\t      maxPolyRadius = 2.25,\n\n\t\t  \/\/ A linear radius size progression.\n\/\/\t      polyRadius = maxPolyRadius *  \n\/\/\t                                ( 1.0 - abs( 2.0 * fract( time ) - 1.0 ) ),\n\t      \n\t      \/\/ Controls speed of radius size change for non-linear progression.\n\t      t = time,\/\/ * 2.0,\n\t      \n\t      \/\/ A non-linear radius size progression\n\t      polyRadius = maxPolyRadius * ( abs( sin( t * 1.63 ) * \n\t                                    sin( t * 1.79 ) + sin ( t * 2.39 ) ) ),\n\t      oldx,\n\t      oldy,\n\t      firstx,\n\t      firsty,\n\t      \/\/thickness = 0.025,\n\t      thickness = 0.0075 +  \/\/ minimum line thickness plus varying\n\t                          \/\/ additional thickness over time.\n\t                0.05 * ( 1.0 - abs( 2.0 * fract( time * 0.025 ) - 1.0 ) ),\t                                                                 \n\t      clr;\t    \n\t\n\t\/\/ POLYGON DRAWING LOOP. ( Sets the value of 'clr' to non-zero in the \n\t\/\/ drawLine() function to indicate the current pixel is part of a line,\n\t\/\/ if it is. The pixel's color is not set until this loop completes. )\n\t\/\/ ---------------------\n\t\n    const int maxSides = 28;\n    \/\/ Because loop index must be compared with a constant expression, the value\n    \/\/ of 'numSides' is used within the loop to break out, rather than in the\n    \/\/ 'for(... ) line. This value should be >= the actual maximum value\n    \/\/ numSides can be assigned, above.\n    \n    for( int curSide = 0; curSide < maxSides; curSide++ )\n    {\n        angle = 360.0 * float( curSide ) * float( numRevs ) \/ float( numSides );\n                                                    \n        x = polyRadius * cos( radians( angle ) );\n        y = polyRadius * sin( radians( angle ) );\n        \n        if ( curSide == 0 )\n        {\n        \t\/\/Store the first coord\n        \tfirstx = x;\n        \tfirsty = y;\n        }\n        else\n        {\n        \tclr += drawLine( vec2( oldx, oldy ), vec2( x, y ), \n        \t                                               curPix, thickness );       \n        \t\/\/ Connect the last vertex to the first.\n        \tif ( curSide == numSides - 1 )\n        \t{\n        \t\tclr += drawLine( vec2( firstx, firsty ), vec2( x, y ), \n        \t\t                                           curPix, thickness );\t\n\t\t\t\tbreak;\n            }\n\t\t}        \t\t                                           \n        \t\n        oldx = x;\n        oldy = y;\n        \t\n\t}\n\t\n\t\/\/ end polygon drawing loop\n\t\n\t\/\/----------------------------------------------------------------\n\t\n\t\/\/ Prevent erasure of previous drawing by drawing only pixels with\n\t\/\/ non-zero values, and discarding those with a zero value.\n\tif ( clr != 0.0 )\n\t{\t\n\t\t\/\/ Modifiying the b vector components of the rainbow palette over time.\t\t\n\t\tb  = vec3( fract( sin( time * 0.07 ) ),\n\t\t\t\t   fract( sin( time * 0.13 ) ),\t\n\t\t\t\t   fract( sin( time * 0.11 ) ) );\n\t\t\t\t  \n\t\tvec3 color = palette( fract( clr + clr + time ), b, c, d, e );\t\t\t\t\n\t\tfragColor = vec4( color, 1.0 );\n\t\t\n\t\t\/\/ Low alpha value blends colors but looks blurrier and not as bright.\n\t\t\/\/fragColor = vec4( color, 0.2 );\n\t\t\n\t\t\/\/ Grey-scale figures only. Can combine with black screen erase.\n\t\t\/\/fragColor = vec4( vec3( clr ), 1.0 );\n\t}\n\telse\n    {\n\t\t\/\/-------------------------------------------------------------------\n\t\t\/\/ I think I read somewhere that the shadertoy app disregards the alpha\n\t    \/\/ value ( appears so ), so these comments don't apply here.\n\t        \n\t    \/\/ ERASE occasionally. The alpha value can be set low to make the old\n\t\t\/\/ drawing fade out slowly, rather than abruptly disappearing.\n\t\t\n\t\t\/\/ With a very low alpha value, a larger compare value is needed to \n\t\t\/\/ erase the background completely. When alpha = 0.15, compare needs to \t\t \n\t\t\/\/ be around 0.0075 to erase ( almost ) completely. \t\n\t\tfloat compare = 0.001,\n\t\t      alpha = 1.0;\n\t\t\n\t\tif ( 1.0 + sin( time * 0.5 ) < compare )\n\t\t{\n\t\t\t\/\/fragColor = vec4( vec3( 0.0 ), 0.175 );\n\t\t\t\n\t\t\t\/\/ Erase to black screen:\n\t\t\t\/\/fragColor = vec4( vec3( 0.0 ), 1.0 );\n\t\t\t\n\t\t\t\/\/ Erase to current palette color:\n\t\t\t\/\/ Adjust the 'compare' value so that it's low enough to prevent \n\t\t\t\/\/ the entire screen flashing through multiple erase colors before\n\t\t\t\/\/ drawing starts again.\n\t\t\tvec3 color = palette( clr + time, b, c, d, e );\t\t\t\t\n\t\t\tfragColor = vec4( fract( color.r ), fract( color.g ), \n\t\t\t                                       fract( color.b ), alpha );\n\t\t}\n\t\t\/\/-------------------------------------------------------------------\t\n\t    \n        else\n\t    {\n\t        discard;   \n\t    }\n    }\n\n}","name":"","description":"","type":"image"}]}}