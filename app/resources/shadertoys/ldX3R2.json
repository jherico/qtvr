{"Shader":{"ver":"0.1","info":{"id":"ldX3R2","date":"1374415104","viewed":956,"name":"Worley noise","username":"FabriceNeyret2","description":"Worley cellular noise (same spirit than Perlin noise, but discontinuities-oriented).<br\/>The #define TYPE on line 3 set the tuning choice. -1 (auto-demo) explore them randomly.","likes":8,"published":3,"flags":0,"tags":["procedural","noise","worley","cellular"],"hasliked":0},"renderpass":[{"inputs":[{"id":16,"src":"\/presets\/tex11.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":31,"src":"\/presets\/webcam.png","ctype":"webcam","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ --- Workey noise ---    Fabrice Neyret, July 2013\n\n#define TYPE -1    \/\/ shader tunings: 1,11,12,  2,21,22,  3,31,32,33,34, 4,41\n                   \/\/                 -1 = autodemo\n\n#define MODULATE 1\n#define ANIM true\n\nfloat time = iGlobalTime;\n\n\/\/ --- noise functions from https:\/\/www.shadertoy.com\/view\/XslGRr\n\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\/\/ --- End of Created by inigo quilez\n\n\/\/ gives a random 1..N integer for index i\n\/\/#define rnd(i,N) int(1.+float(N)*hash(float(i)))\nint rnd(float i,int N) { return int(1.+float(N)*hash(i)); }\n\n\/\/ gives a random 1..N integer every T seconds, starting at i.\n\/\/#define rndT(i,N,T) int(1.+float(N)*hash(float(i)+floor(iGlobalTime\/(T))))\nint rndT(float i,int N,float T) { return int(1.+float(N)*hash(i+floor(iGlobalTime\/(T)))); }\n\nvec2 noise2_2( vec2 p )     \/\/ 2 noise channels from 2D position\n{\n\tvec3 pos = vec3(p,.5);\n\tif (ANIM) pos.z += time;\n\tpos *= m;\n    float fx = noise(pos);\n    float fy = noise(pos+vec3(1345.67,0,45.67));\n    return vec2(fx,fy);\n}\nvec3 noise3_2( vec2 p )     \/\/ 3 noise channels from 2D position\n{\n\tvec3 pos = vec3(p,.5);\n\tif (ANIM) pos.z += time;\n\tpos *= m;\n    float fx = noise(pos);\n    float fy = noise(pos+vec3(1345.67,0,45.67));\n    float fz = noise(pos+vec3(0,134.67,3245.67));\n    return vec3(fx,fy,fz);\n}\nvec2 noise2_3( vec3 p )     \/\/ 2 noise channels from 3D position\n{\n\tif (ANIM) p.z += time;\n\tp *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1345.67,0,45.67));\n    return vec2(fx,fy);\n}\nvec3 noise3_3( vec3 p )     \/\/ 3 noise channels from 3D position\n{\n\tif (ANIM) p.z += time;\n\tp *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1345.67,0,45.67));\n    float fz = noise(p+vec3(0,134.67,3245.67));\n    return vec3(fx,fy,fz);\n}\n\nvec2 fbm2( vec2 p )\n{\n\tif (ANIM) p += iGlobalTime;\n    float fx = fbm(vec3(p,.5));\n    float fy = fbm(vec3(p,.5)+vec3(1345.67,0,45.67));\n    return vec2(fx,fy);\n}\nvec2 perturb2(vec2 p, float scaleX, float scaleI)\n{\n    scaleX *= 2.;\n\treturn scaleI*scaleX*fbm2(p\/scaleX); \/\/ usually, to be added to p\n}\n\n\/\/ --- Worley -------------------------------------------------\n\n#define id(i,j,k)   (float(128+i)+256.*float(128+j)+65536.*float(k))  \n#define id2cell(id) vec3(mod(id,256.)-128.,mod(floor(id\/256.),256.)-128.,id\/65536.)\n\n\/\/ d2 and id are vectors or 4 sorted distances + corresponding cell id\n\/\/ id is relative to current position (add floor(p) to get absolute cell id).\nvoid sort(float tmp_d2, int i, int j, int k, inout vec4 d2, inout vec4 id)\n{\n\tif (tmp_d2 < d2.x)\n\t{                                         \/\/ nearest point\n\t\td2.yzw = d2.xyz; d2.x = tmp_d2;\n\t\tid.yzw = id.xyz; id.x = id(i,j,k);\n\t}\n\telse if (tmp_d2 < d2.y)\n\t{                                         \/\/ 2nd nearest point\n\t\td2.zw = d2.yz; d2.y = tmp_d2;\n\t\tid.zw = id.yz; id.y = id(i,j,k);\n\t}\t\n\telse if (tmp_d2 < d2.z)\n\t{                                         \/\/ 3rd nearest point\n\t\td2.w = d2.z; d2.z = tmp_d2;\n\t\tid.w = id.z; id.z = id(i,j,k);\n\t}\n\telse \n\t{                                         \/\/ 4th nearest point\n\t\td2.w = tmp_d2;\n\t\tid.w = id(i,j,k);\n\t}\n}\n\nvec4 worley2( in vec2 p, out vec4 id ) \/\/ 2D procedural texture\n{\n\tvec2 ip = floor(p);\n\tvec4 d2 = vec4(1.e30); \/\/ 4 nearests initialized to infinity\n\t\n\tfor (int j=-2; j<=2; j++)          \/\/ browse points in neighborhood cells\n\t\tfor (int i=-2; i<=2; i++)\n\t\t{\n\t\t\tvec2 tmp_p   = ip+vec2(float(i),float(j)); \/\/ one cell\n\t\t\tvec2 tmp_pos = tmp_p+noise2_2(tmp_p)-p;    \/\/ pixel pos to cell point\n\t\t\tfloat tmp_d2 = dot(tmp_pos,tmp_pos);       \/\/ square distance of it\n\t\t\tsort (tmp_d2, i,j,0, d2,id);\n\t\t}\n\tid += vec4(ip.x+256.*ip.y); \/\/ id = vector of nearest cells\n\treturn sqrt(d2);      \/\/ return vector of nearest distances\n}\n\nvec4 worley3( in vec3 p, out vec4 id ) \/\/ 3D procedural texture\n{\n\tvec3 ip = floor(p);\n\tvec4 d2 = vec4(1.e30); \/\/ 4 nearests initialized to infinity\n\t\n\tfor (int k=-2; k<=2; k++)          \/\/ browse points in neighborhood cells\n\t  for (int j=-2; j<=2; j++)       \n\t\tfor (int i=-2; i<=2; i++)\n\t\t{\n\t\t\tvec3 tmp_p   = ip+vec3(float(i),float(j),float(k));  \/\/ one cell\n\t\t\tvec3 tmp_pos = tmp_p+noise3_3(tmp_p)-p;   \/\/ pixel pos to cell point\n\t\t\tfloat tmp_d2 = dot(tmp_pos,tmp_pos);      \/\/ square distance of it\n\t\t\tsort (tmp_d2, i,j,k, d2,id);\n\t\t}\n\tid += vec4(ip.x+256.*ip.y+65536.*ip.z); \/\/ id = vector of nearest cells\n\treturn sqrt(d2);      \/\/ return vector of nearest distances\n}\n\nvec3 cellId2Color(float id)\n{\n\treturn texture2D(iChannel0,vec2(mod(id,64.)\/64., mod(floor(id\/64.),64.)\/64.)).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv  = fragCoord.xy \/ iResolution.y;\n\tvec2 mouse = iMouse.xy \/ iResolution.y;\n\tuv  = (uv  - mouse)\/(1.+mouse.y);\n\tvec3 col;\n\tfloat c;\n\n\t\n#if TYPE == -1 \/\/ demo mode \n\tfloat duv = -.3*sin(4.*uv.y+uv.x+time) - .1*sin(10.*uv.y+6.*uv.x+10.*time);\n\tfloat k = floor(.7*(uv.x+duv)+time\/5.); \n    int demo = rnd(k,13);\n#else\n\tconst int demo=0;\n#endif\n\t\n#if MODULATE\n\ttime = 1.*(2.*time + .5*sin(1.*time+10.*length(uv)));\n#endif\n\t\n\tvec4 id; vec4 D = worley2(10.*uv, id);\n\n    if((TYPE == 1)||(demo==1))\n\t{\n\t\tcol = vec3(D.x);\n\t}\n    else if ((TYPE == 11)||(demo==2))\n\t{\n\t\tc = D.x + .5*worley2(20.*uv, id).x + .25*worley2(40.*uv, id).x;\n\t\tc = 1.-c;\n\t\tcol = vec3(c);\n\t}\n\telse if ((TYPE == 12)||(demo==3))\n\t{\n\t\tcol = vec3(D.x, worley2(20.*uv, id).x, worley2(40.*uv, id).x);\n\t}\n\t\n\t\n\telse if ((TYPE == 2)||(demo==4))\n\t{\n\t\tcol = vec3(D.y-D.x);\n\t}\n\telse if ((TYPE == 21)||(demo==5))\n\t{\n\t\tfloat I=1.;\n\t\tc = (D.y-D.x);\n\t\tI*=.5; uv*=2.; D = I*worley2(10.*uv, id); c += (D.y-D.x);\n\t\tI*=.5; uv*=2.; D = I*worley2(10.*uv, id); c += (D.y-D.x);\n\t\tcol = .75*vec3(c);\n\t}\n\telse if ((TYPE == 22)||(demo==6))\n\t{\n\t\tfloat I=1.;\n\t\tc = (D.y-D.x);\n\t\tI*=.5; uv*=2.; D = I*worley2(10.*uv, id); c -= (D.y-D.x);\n\t\tI*=.5; uv*=2.; D = I*worley2(10.*uv, id); c += (D.y-D.x);\n\t\tcol = vec3(c);\n\t}\n\t\n\tif ((TYPE == 3)||(demo==7))\n\t{\n\t\tc =.7*D.y-D.x; \n\t\tcol = (c<0.)? -c*vec3(2.,.5,0.) : 2.*c*cellId2Color(id.x);\n\t}\n\telse if ((TYPE == 31)||(demo==8))\n\t{\n\t\t\/\/c = (.7*D.y-D.x); \n\t\tc=D.x*(.7*D.y-D.x); \n\t\tcol = (c<0.)? vec3(-c) : (1.-c)*cellId2Color(id.x);\n\t}\n\telse if ((TYPE == 32)||(demo==9))\n\t{\n\t\tc=pow(D.x,.5)*(.7*D.y-D.x); \n\t\tcol = (c<0.)? vec3(-c) : 9.*c*cellId2Color(id.x);\n\t}\n\telse if ((TYPE == 33)||(demo==10))\t\n\t{\n\t\tc=.7*D.y-D.x; \n\t\tD = worley2(40.*uv, id); c -= .5*D.x;\n\t\tcol = (c<0.)? vec3(0.) : 4.*c*cellId2Color(id.x);\n\t}\n\telse if ((TYPE == 34)||(demo==11))\n\t{\n\t\tfloat id0=id.x;\n\t\tc= (.7*D.y-D.x); \n\t\tD = worley2(60.*uv, id); c -= .2*D.x;\n\t\tc = mix(-.1,1.,c);\n\t\tcol = (c<0.)? -c*vec3(1.,.5,0.) : 3.*(1.-sqrt(c))*cellId2Color(id0);\n\t}\n\t\n\telse if ((TYPE == 4)||(demo==12))\n\t{\n\t\tuv -= .1*noise2_2(id2cell(id.x).xy);\n    \tuv = mod( uv*vec2(iResolution.y\/iResolution.x,1.), 1.);\n\t\tc = pow(D.y-D.x,.1);\n\t\t\/\/ c += pow(1.-D.x,5.);\n\t\tcol = c*texture2D(iChannel1,uv).rgb;\n\t}\n\telse if ((TYPE == 41)||(demo==13))\t\n\t{\n\t\tuv -= .1*noise2_2(id2cell(id.x).xy);\n    \tuv = mod( uv*vec2(iResolution.y\/iResolution.x,1.), 1.);\n\t\tc=D.x*(.7*D.y-D.x); \n\t\tcol = (c<0.)? vec3(-c) : (1.-c)*cellId2Color(id.x)*2.*texture2D(iChannel1,uv).rgb;\n\t}\n\t\t\t   \n    fragColor = vec4(col, 0.); \n}","name":"","description":"","type":"image"}]}}