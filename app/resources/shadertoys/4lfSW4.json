{"Shader":{"ver":"0.1","info":{"id":"4lfSW4","date":"1452014271","viewed":276,"name":"Reactive Voxel","username":"glk7","description":"3D noise displayed on a voxelized cube. Reacts to the change in the lowest frequency playing on iChannel1. The cube can be rotated with the mouse.","likes":8,"published":3,"flags":0,"tags":["interactive","reactive","voxel","ao","hardshadows"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":35,"src":"\/presets\/mzk06.mp3","ctype":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by genis sole - 2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define EPS 0.001\n\n\n\/\/ Taken from http:\/\/iquilezles.org\/www\/articles\/palettes\/palettes.htm\nvec3 ColorPalette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\/\/ From https:\/\/www.shadertoy.com\/view\/XsX3RB (iq's Volcanic)\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D( iChannel0, (uv+ 0.5)\/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nbool map(in vec3 p, out float v) \n{\n    p += iGlobalTime*0.3 - texture2D(iChannel1, vec2(0.0, 0.0)).r*1.2;\n    \n    float d = noise(p*vec3(0.2));\n    v = mix(0.4, 0.7, (d - 0.3)*3.33);\n    return d < 0.6 && d > 0.3;\n}\n\nbool IRayAABox(in vec3 ro, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax, out vec3 p0, out vec3 p1) \n{\n    vec3 t0 = (bmin - ro) * invrd;\n    vec3 t1 = (bmax - ro) * invrd;\n\n    vec3 tmin = min(t0, t1);\n    vec3 tmax = max(t0, t1);\n    \n    float fmin = max(max(tmin.x, tmin.y), tmin.z);\n    float fmax = min(min(tmax.x, tmax.y), tmax.z);\n    \n    p0 = ro + rd*fmin;\n    p1 = ro + rd*fmax;\n    return fmax >= fmin;   \n}\n\nvec3 AABoxNormal(vec3 bmin, vec3 bmax, vec3 p) \n{\n    vec3 n1 = -(1.0 - smoothstep(0.0, 0.1, p - bmin));\n    vec3 n2 = (1.0 -  smoothstep(0.0, 0.1, bmax - p));\n    \n    return normalize(n1 + n2);\n}\n\nbool Voxels(in vec3 ro, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax, out vec3 n, out vec3 p, out float v)\n{\n    n = vec3(0.0);\n    p = vec3(0.0);\n    v = 0.0;\n    \n    vec3 re = vec3(0.0);\n    vec3 pa = vec3(0.0);\n    if (!IRayAABox(ro, rd, invrd, bmin, bmax, ro, re)) return false;\n    \n    if (length(re - ro) <= EPS) return false;\n    vec3 ep = floor(ro + rd*EPS);\n\n    bool ret = false;\n    for (int i = 0; i < 100; ++i) {\n        if (map(ep, v)) {\n            ret = true;\n            break;\n        }\n\n        IRayAABox(ro - rd*2.0, rd, invrd, ep, ep+1.0, pa, ro);\n        ep = floor(ro + rd*EPS);\n\n        if (length(re - ro) <= EPS) {\n            ret = false;\n            break;\n        }\n\n    }\n    \n    if (ret) {\n    \tn = AABoxNormal(ep, ep+1.0, ro);\n        p = ro;   \n    }\n    return ret;\n}\n\nfloat ShadowFactor(in vec3 ro, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax) \n{\n    vec3 re = vec3(0.0);\n    vec3 pa = vec3(0.0);\n    \n    IRayAABox(ro + rd*((length(bmin - bmax) + EPS)), -rd, -invrd, bmin, bmax, re, pa);\n    if (length(re - ro) <= EPS) return 1.0;\n    \n    vec3 ep = floor(ro + rd*EPS);\n    float v = 0.0;\n    float ret = 1.0;\n    for (float i = 0.0; i < 100.0; ++i) {\n        if (map(ep, v)) {\n            ret = -i;\n        \tbreak;\n        }\n        \n        IRayAABox(ro - rd*2.0, rd, invrd, ep, ep+1.0, pa, ro);\n        ep = floor(ro + rd*EPS);\n        \n        if (length(re - ro) <= EPS) {\n            ret = 1.0;\n            break;\n        }\n    }\n    \n    return ret;\n}\n\nfloat AOFactor(in vec3 ro, in vec3 n, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax) \n{\n    float t = ShadowFactor(ro, rd, invrd, bmin, bmax);\n    return (1.0 - step(0.0, t)) * clamp(-t * 0.3, 0.0, 1.0) + (step(0.0, t)) * t;\n}\n\nfloat AmbientOcclusion(in vec3 ro, in vec3 n, in vec3 bmin, in vec3 bmax) \n{   \n    const float nf = 0.707;\n    const vec3 v0 = (vec3(1.0, 1.0, 0.0) * nf) + EPS;\n    const vec3 v1 = (vec3(-1.0, 1.0, 0.0) * nf) + EPS;\n    const vec3 v2 = (vec3(0.0, 1.0, 1.0) * nf) + EPS;\n    const vec3 v3 = (vec3(0.0, 1.0, -1.0) * nf) + EPS;\n    \n    const vec3 v4 = -v0;\n    const vec3 v5 = -v1;\n    const vec3 v6 = -v2;\n    const vec3 v7 = -v3;\n    \n    const vec3 invv0 = 1.0\/v0;\n    const vec3 invv1 = 1.0\/v1;\n    const vec3 invv2 = 1.0\/v2;\n    const vec3 invv3 = 1.0\/v3;\n    const vec3 invv4 = 1.0\/v4;\n    const vec3 invv5 = 1.0\/v5; \n    const vec3 invv6 = 1.0\/v6;\n    const vec3 invv7 = 1.0\/v7;\n    vec3 invn = 1.0\/(n);\n    \n    float r = 0.0;\n    r += AOFactor(ro, n, n, invn, bmin, bmax);\n\tr += AOFactor(ro, n, v0, invv0, bmin, bmax);\n    r += AOFactor(ro, n, v1, invv1, bmin, bmax);\n    r += AOFactor(ro, n, v2, invv2, bmin, bmax);\n    r += AOFactor(ro, n, v3, invv3, bmin, bmax);\n    r += AOFactor(ro, n, v4, invv4, bmin, bmax);\n    r += AOFactor(ro, n, v5, invv5, bmin, bmax);\n\tr += AOFactor(ro, n, v6, invv6, bmin, bmax);\n    r += AOFactor(ro, n, v7, invv7, bmin, bmax);\n    \n    return clamp(r * 0.2, 0.0, 1.0);\n}\n\n\nvec3 GetColor(float v) \n{\n    \/\/return vec3(1.0);\n\treturn ColorPalette(v, vec3(0.5, 0.5, 0.5), \n                           vec3(0.5), \n                           vec3(0.6, 0.4, 0.3), \n                           vec3(0.6, 0.4, 0.3));  \n}\n\nvoid CameraOrbitRay(in vec2 fragCoord, in float n, in vec3 c, in float d, \n                    out vec3 ro, out vec3 rd, out mat3 t) \n{\n    float a = 1.0\/max(iResolution.x, iResolution.y);\n    rd = normalize(vec3((fragCoord - iResolution.xy*0.5)*a, n));\n \n    ro = vec3(0.0, 0.0, -d);\n    \n    float mxc = clamp(-((iMouse.x \/ iResolution.x)*2.0 - 1.0), -1.0, 1.0);\n    float mxs = sqrt(1.0-(mxc*mxc));\n    \n\tfloat myc = clamp((iMouse.y \/ iResolution.y)*2.0 - 1.0, -1.0, 1.0);\n    float mys = sqrt(1.0-(myc*myc));\n    \n    t = mat3(mxc, mxs, 0, -mxs*myc, mxc*myc, mys, mxs*mys, -mxc*mys, myc);\n        \n    ro = t * ro;\n    ro = c + ro;\n\n    rd = t * rd;\n    \n    rd = normalize(rd);\n}\n\nvec3 LightDir(in mat3 t) \n{\n    vec3 l = normalize(vec3(-1.0, -1.0, 1.0));\n    return t * l;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n   \tvec3 bpos = vec3(-5.0);\n    \n   \tvec3 bmin = vec3(10.0, 10.0, 10.0) + bpos;\n    vec3 bmax = vec3(0.0, 0.0, 0.0) + bpos;\n    \n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    mat3 t = mat3(1.0);\n    CameraOrbitRay(fragCoord, 0.5, bpos+vec3(5.0), 20.0, ro, rd, t);\n    \n    vec3 l = LightDir(t);\n    \n    vec3 invrd = 1.0 \/ rd;\n    vec3 invl = 1.0 \/ l;\n    \n    vec3 p = vec3(0.0);\n    vec3 n = vec3(0.0);\n    float v = 0.0;\n    \n    vec3 color = vec3(0.03, 0.03, 0.03);\n \n    if (Voxels(ro, rd, invrd, bmin, bmax, n, p, v)) {\n    \tcolor = GetColor(v);\n        vec3 diff = color * max(dot(-l, n), 0.0);\n        diff *= clamp(ShadowFactor(p, -l, -invl, bmin, bmax), 0.0, 1.0);\n        vec3 amb = color * AmbientOcclusion(p, n, bmin, bmax) * 0.7 + color * 0.3;\n        color = diff*0.8 + amb*0.2;\n    }\n   \n    color = pow(color, vec3(0.55));\n    fragColor = vec4(color, 1.0);\n}","name":"","description":"","type":"image"}]}}