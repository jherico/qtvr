{"Shader":{"ver":"0.1","info":{"id":"4s33RN","date":"1448276892","viewed":485,"name":"Luceat lux vestra visualiser","username":"weyland","description":"Quick hack based on https:\/\/www.shadertoy.com\/view\/Xdf3zB by sjb3d and added some cheap res dependent glitch\/MPEG distortion from https:\/\/www.shadertoy.com\/view\/Md2GDw# by Kusma<br\/><br\/>You can disable the fake mpeg articfacts and adjust the amount of spheres","likes":9,"published":3,"flags":64,"tags":["light","audio","volumetric","fog","shadows","visualiser","soundcloud"],"hasliked":0},"renderpass":[{"inputs":[{"id":16,"src":"\/presets\/tex11.png","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":182,"src":"https:\/\/soundcloud.com\/modeselektor\/modeselektion-vol-03-07-akkord-gradient-mtr045-out-june-27-2014","ctype":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ based on: https:\/\/www.shadertoy.com\/view\/Xdf3zB\n\/\/ Implementation of equi-angular sampling for raymarching through homogenous media\n\/\/ 2013 @sjb3d\n\n#define PI\t\t\t\t3.1415926535\n#define SIGMA\t\t\t0.3\n#define STEP_COUNT\t\t16\n#define DIST_MAX\t\t10.0\n#define LIGHT_POWER\t\t32.0\n#define SURFACE_ALBEDO\t0.7\n#define EPS\t\t\t\t0.01\n#define BALL_AMOUNT\t\t20\n#define GLITCH\t\t\ttrue\n#define time\t\t\tiGlobalTime\n\nfloat audioEnvelope;\n\n\/\/ shamelessly stolen from iq!\nfloat hash(float n)\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nvoid sampleCamera(vec2 fragCoord, vec2 u, out vec3 rayOrigin, out vec3 rayDir)\n{\n\tvec2 filmUv = (fragCoord.xy + u)\/iResolution.xy;\n\t\n\tfloat tx = (2.0*filmUv.x - 1.0)*(iResolution.x\/iResolution.y);\n\tfloat ty = (1.0 - 2.0*filmUv.y);\n\tfloat tz = 0.0;\n\t\n\trayOrigin = vec3(0.0, 0.0, 5.0);\n\trayDir = normalize(vec3(tx, ty, tz) - rayOrigin);\n}\n\nvoid intersectSphere(\n\tvec3 rayOrigin,\n\tvec3 rayDir,\n\tvec3 sphereCentre,\n\tfloat sphereRadius,\n\tinout float rayT,\n\tinout vec3 geomNormal)\n{\n\t\/\/ ray: x = o + dt, sphere: (x - c).(x - c) == r^2\n\t\/\/ let p = o - c, solve: (dt + p).(dt + p) == r^2\n\t\/\/\n\t\/\/ => (d.d)t^2 + 2(p.d)t + (p.p - r^2) == 0\n\tvec3 p = rayOrigin - sphereCentre;\n\tvec3 d = rayDir;\n\tfloat a = dot(d, d);\n\tfloat b = 2.0*dot(p, d);\n\tfloat c = dot(p, p) - sphereRadius*sphereRadius;\n\tfloat q = b*b - 4.0*a*c;\n\tif (q > 0.0) {\n\t\tfloat denom = 0.5\/a;\n\t\tfloat z1 = -b*denom;\n\t\tfloat z2 = abs(sqrt(q)*denom);\n\t\tfloat t1 = z1 - z2;\n\t\tfloat t2 = z1 + z2;\n\t\tbool intersected = false;\n\t\tif (0.0 < t1 && t1 < rayT) {\n\t\t\tintersected = true;\n\t\t\trayT = t1;\n\t\t} else if (0.0 < t2 && t2 < rayT) {\n\t\t\tintersected = true;\n\t\t\trayT = t2;\n\t\t}\n\t\tif (intersected) {\n\t\t\tgeomNormal = normalize(p + d*rayT);\n\t\t}\n\t}\n}\n\nvoid intersectScene(\n\tvec3 rayOrigin,\n\tvec3 rayDir,\n\tinout float rayT,\n\tinout vec3 geomNormal)\n{\n    float z = 1.0;\n    float xfactor = .75;\n    float yfactor = 1.0;\n    \n    for (int stepIndex = 0; stepIndex < BALL_AMOUNT; ++stepIndex)\n    {\t\n        float xtime = time + float(stepIndex)*142.;\n        float posx = sin(xtime\/(2.0+sin(hash(float(stepIndex*1342)))));\n        float posy = cos(xtime\/(2.0+sin(hash(float(stepIndex*3234)))));\n        float posz = tan(xtime\/(2.0+tan(hash(float(stepIndex*2323)))))\/3.;\n\t\tintersectSphere(rayOrigin, rayDir, vec3( posx\/xfactor, posy, z+posz), 0.2*(2.0+sin((float(stepIndex*1342))))\/2., rayT, geomNormal);\n    }\n}\n\nvoid sampleUniform(\n\tfloat u,\n\tfloat maxDistance,\n\tout float dist,\n\tout float pdf)\n{\n\tdist = u*maxDistance;\n\tpdf = 1.0\/maxDistance;\n}\n\nvoid sampleScattering(\n\tfloat u,\n\tfloat maxDistance,\n\tout float dist,\n\tout float pdf)\n{\n\t\/\/ remap u to account for finite max distance\n\tfloat minU = exp(-SIGMA*maxDistance);\n\tfloat a = u*(1.0 - minU) + minU;\n\n\t\/\/ sample with pdf proportional to exp(-sig*d)\n\tdist = -log(a)\/SIGMA;\n\tpdf = SIGMA*a\/(1.0 - minU);\n}\n\nvoid sampleEquiAngular(\n\tfloat u,\n\tfloat maxDistance,\n\tvec3 rayOrigin,\n\tvec3 rayDir,\n\tvec3 lightPos,\n\tout float dist,\n\tout float pdf)\n{\n\t\/\/ get coord of closest point to light along (infinite) ray\n\tfloat delta = dot(lightPos - rayOrigin, rayDir);\n\t\n\t\/\/ get distance this point is from light\n\tfloat D = length(rayOrigin + delta*rayDir - lightPos);\n\n\t\/\/ get angle of endpoints\n\tfloat thetaA = atan(0.0 - delta, D);\n\tfloat thetaB = atan(maxDistance - delta, D);\n\t\n\t\/\/ take sample\n\tfloat t = D*tan(mix(thetaA, thetaB, u));\n\tdist = delta + t;\n\tpdf = D\/((thetaB - thetaA)*(D*D + t*t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/amplitude envelope\n    audioEnvelope = (texture2D(iChannel2, vec2(iChannelTime[1],0.0))).x;\n   \tint c =0;\n  \tfor(float k = 0.0; k<0.02; k+=0.001)\n    {\n    \tc++;\n    \tfloat val = abs((texture2D(iChannel0, vec2(iChannelTime[1]+k,0.0))).x);\n    \taudioEnvelope+=  val*val;\n    }\n    \n    audioEnvelope = audioEnvelope\/float(c);\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec2 block = floor(fragCoord.xy \/ vec2(16));\n\tvec2 uv_noise = block \/ vec2(64);\n\tuv_noise += floor(vec2(iGlobalTime) * vec2(1234.0, 3543.0)) \/ vec2(64);\n\t\n\tfloat block_thresh = pow(fract(iGlobalTime * 1236.0453), 2.0) * 0.2;\n\tfloat line_thresh = pow(fract(iGlobalTime * 2236.0453), 3.0) * 0.7;\n\t\n\tvec2 uv_r = uv, uv_g = uv, uv_b = uv;\n\n   \t\/\/ glitch some blocks and lines\n\tif  (GLITCH && (texture2D(iChannel1, uv_noise).r < block_thresh ||\n\t\ttexture2D(iChannel1, vec2(uv_noise.y, 0.0)).g < line_thresh)) {\n\n\t\tvec2 dist = (fract(uv_noise) - 0.5) * audioEnvelope;\n\t\tfragCoord.x -= dist.x * 250.1 * audioEnvelope;\n\t\tfragCoord.y -= dist.y * 250.2 * audioEnvelope;\n\t}\n\n    fragCoord.x += audioEnvelope * 50.;\n\tvec3 lightPos = vec3(0.8*sin(iGlobalTime*3.2\/4.0), 0.8*sin(iGlobalTime*1.2\/4.0), 0.0);\n\tvec3 lightIntensity = vec3(LIGHT_POWER*audioEnvelope);\n\tvec3 surfIntensity = vec3(SURFACE_ALBEDO\/PI);\n\tvec3 particleIntensity = vec3(1.0\/(4.0*PI));\n\t\n\tvec3 rayOrigin, rayDir;\n\tsampleCamera((fragCoord+uv_r,fragCoord+uv_b), vec2(0.5, 0.5), rayOrigin, rayDir);\n\t\n\/\/\tfloat splitCoord = (iMouse.x == 0.0) ? iResolution.x\/2.0 : iMouse.x; \/\/ old compare indicator\n\tfloat splitCoord = 0.0;\n\t\n\tvec3 col = vec3(0.0);\n\tfloat t = DIST_MAX;\n\t{\n\t\tvec3 n;\n\t\tintersectScene(rayOrigin, rayDir, t, n);\n\t\t\n\t\tif (t < DIST_MAX) {\n\t\t\t\/\/ connect surface to light\n\t\t\tvec3 surfPos = rayOrigin + t*rayDir;\n\t\t\tvec3 lightVec = lightPos - surfPos;\n\t\t\tvec3 lightDir = normalize(lightVec);\n\t\t\tvec3 cameraDir = -rayDir;\n\t\t\tfloat nDotL = dot(n, lightDir);\n\t\t\tfloat nDotC = dot(n, cameraDir);\n\t\t\t\n\t\t\t\/\/ only handle BRDF if entry and exit are same hemisphere\n\t\t\tif (nDotL*nDotC > 0.0) {\n\t\t\t\tfloat d = length(lightVec);\n                float t2 = d;\n                vec3 n2;\n                vec3 rayDir = normalize(lightVec);\n\t\t\t\tintersectScene(surfPos + EPS*rayDir, rayDir, t2, n2);\n                \n                \/\/ accumulate surface response if not occluded\n                if (t2 == d) {\n\t\t\t\t\tfloat trans = exp(-SIGMA*(d + t));\n\t\t\t\t\tfloat geomTerm = abs(nDotL)\/dot(lightVec, lightVec);\n\t\t\t\t\tcol = surfIntensity*lightIntensity*geomTerm*trans;\n                }\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfloat offset = hash(fragCoord.y*iResolution.x + fragCoord.x + iGlobalTime);\n\tfor (int stepIndex = 0; stepIndex < STEP_COUNT; ++stepIndex) {\n\t\tfloat u = (float(stepIndex)+offset)\/float(STEP_COUNT);\n\t\t\n\t\t\/\/ sample along ray from camera to surface\n\t\tfloat x;\n\t\tfloat pdf;\n\t\tif (fragCoord.x < splitCoord) {\n\t\t\t\/\/sampleScattering(u, t, x, pdf);\n\t\t} else {\n\t\t\tsampleEquiAngular(u, t, rayOrigin, rayDir, lightPos, x, pdf);\n\t\t}\n\t\t\n\t\t\/\/ adjust for number of ray samples\n\t\tpdf *= float(STEP_COUNT);\n\t\t\n\t\t\/\/ connect to light and check shadow ray\n\t\tvec3 particlePos = rayOrigin + x*rayDir;\n\t\tvec3 lightVec = lightPos - particlePos;\n\t\tfloat d = length(lightVec);\n\t\tfloat t2 = d;\n\t\tvec3 n2;\n\t\tintersectScene(particlePos, normalize(lightVec), t2, n2);\n\t\t\n\t\t\/\/ accumulate particle response if not occluded\n\t\tif (t2 == d) {\n\t\t\tfloat trans = exp(-SIGMA*(d + x));\n\t\t\tfloat geomTerm = 1.0\/dot(lightVec, lightVec);\n\t\t\tcol += SIGMA*particleIntensity*lightIntensity*geomTerm*trans\/pdf;\n\t\t}\n\t}\n\/*\n\t\/\/ show slider position in original shader\n\tif (abs(fragCoord.x - splitCoord) < 1.0) {\n\t\tcol.x = 1.0;\n\t}\n*\/\t\n\tcol = pow(col, vec3(1.0\/2.2));\n\t\n\tfragColor = vec4(col, 1.0);\n    \n\t\/\/ interleave lines in some blocks\n\tif (GLITCH && (texture2D(iChannel1, uv_noise).g * 1.5 < block_thresh ||\n\t\ttexture2D(iChannel1, vec2(uv_noise.y, 0.0)).g * 2.5 < line_thresh)) {\n\t\tfloat line = fract(fragCoord.y \/ 3.0);\n\t\tvec3 mask = vec3(2.0, 0.0, 0.0);\n\t\tif (line > 0.333)\n\t\t\tmask = vec3(0.0, 2.0, 0.0);\n\t\tif (line > 0.666)\n\t\t\tmask = vec3(0.0, 0.0, 2.0);\n\t\t\n\t\tfragColor.xyz *= mask;\n\t}\n}\n","name":"","description":"","type":"image"}]}}