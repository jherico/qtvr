{"Shader":{"ver":"0.1","info":{"id":"XtfSRj","date":"1437860833","viewed":828,"name":"Quadratic Bezier Rectangle","username":"demofox","description":"Using ray marching to render a bezier rectangle.  Raytrace bounding box, raymarch interior.  The control points of the rectangle are 1d, which makes it easier to render, but limits the control points to only moving on the Y axis.","likes":7,"published":3,"flags":0,"tags":["3d","bezier"],"hasliked":0},"renderpass":[{"inputs":[{"id":24,"src":"\/presets\/cube02_0.jpg","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/*\nFor more information, check this out:\nhttp:\/\/blog.demofox.org\/2015\/07\/28\/rectangular-bezier-patches\/\n*\/\n\n#define SHOW_BOUNDINGBOX   0\n#define SHOW_CONTROLPOINTS 0\n\nfloat CP00 = sin(iGlobalTime*0.3) * 0.5 + 0.5;\nfloat CP01 = sin(iGlobalTime*0.1) * 0.5 + 0.5;\nfloat CP02 = sin(iGlobalTime*0.7) * 0.5 + 0.5;\n\nfloat CP10 = sin(iGlobalTime*0.2) * 0.5 + 0.5;\nfloat CP11 = sin(iGlobalTime*0.4) * 0.5 + 0.5;\nfloat CP12 = sin(iGlobalTime*0.8) * 0.5 + 0.5;\n\nfloat CP20 = sin(iGlobalTime*0.5) * 0.5 + 0.5;\nfloat CP21 = sin(iGlobalTime*0.9) * 0.5 + 0.5;\nfloat CP22 = sin(iGlobalTime*0.6) * 0.5 + 0.5;\n\nfloat CPMin = min(CP00,min(CP01,min(CP02,min(CP10,min(CP11,min(CP12,min(CP20,min(CP21,CP22))))))));\nfloat CPMax = max(CP00,max(CP01,max(CP02,max(CP10,max(CP11,max(CP12,max(CP20,max(CP21,CP22))))))));\n\n#define FLT_MAX 3.402823466e+38\n\n\/\/=======================================================================================\nfloat LinearBezier (float A, float B, float t)\n{\n    return A * (1.0-t) + B * t;\n}\n\n\/\/=======================================================================================\nfloat QuadraticBezier (float A, float B, float C, float t)\n{\n    float s = 1.0 - t;\n    float s2 = s * s;\n    float t2 = t * t;\n    \n    return A*s2 + B*2.0*s*t + C*t2;\n}\n\n\/\/=======================================================================================\nfloat HeightAtPos(vec2 P)\n{\n    #if 1\n    float ut = P.x;\n    float ut2 = ut * ut;\n    float us = 1.0 - ut;\n    float us2 = us * us;\n\n    float vt = P.y;\n    float vt2 = vt * vt;\n    float vs = 1.0 - vt;\n    float vs2 = vs * vs;    \n        \n    float u0 = us2;\n    float u1 = 2.0*us*ut;\n    float u2 = ut2;\n    \n    float v0 = vs2;\n    float v1 = 2.0*vs*vt;\n    float v2 = vt2;\n    \n    return\n        CP00*u0*v0 + CP01*u1*v0 + CP02*u2*v0 +\n        CP10*u0*v1 + CP11*u1*v1 + CP12*u2*v1 +\n        CP20*u0*v2 + CP21*u1*v2 + CP22*u2*v2\n    ;\n        \n    #else\n    float CP0X = QuadraticBezier(CP00, CP01, CP02, P.x);\n    float CP1X = QuadraticBezier(CP10, CP11, CP12, P.x);\n    float CP2X = QuadraticBezier(CP20, CP21, CP22, P.x);\n    \n    return QuadraticBezier(CP0X, CP1X,CP2X, P.y);\n    #endif\n}\n\n\/\/=======================================================================================\nfloat F ( in vec3 coords )\n{\n    return HeightAtPos(coords.xz) - coords.y;\n}\n\n\/\/=======================================================================================\nvec3 Gradient (vec2 p)\n{\n    float CP0_ = QuadraticBezier(CP00, CP01, CP02, p.x);\n    float CP1_ = QuadraticBezier(CP10, CP11, CP12, p.x);\n    float CP2_ = QuadraticBezier(CP20, CP21, CP22, p.x);\n    float FY1 = CP1_ - CP0_;\n    float FY2 = CP2_ - CP1_;\n    float valueY = 2.0 * LinearBezier(FY1, FY2, p.y);\n    \n    float CP_0 = QuadraticBezier(CP00, CP10, CP20, p.y);\n    float CP_1 = QuadraticBezier(CP01, CP11, CP21, p.y);\n    float CP_2 = QuadraticBezier(CP02, CP12, CP22, p.y);\n    float FX1 = CP_1 - CP_0;\n    float FX2 = CP_2 - CP_1;\n    float valueX = 2.0 * LinearBezier(FX1, FX2, p.x);  \n    \n    return vec3(valueX,-1.0,valueY)*-1.0;\n}\n\n\/\/=======================================================================================\nvec3 NormalAtPos( vec2 p )\n{\n    #if 1\n    return normalize(Gradient(p));\n    #else\n\tfloat eps = 0.01;\n    vec3 n = vec3( HeightAtPos(vec2(p.x-eps,p.y)) - HeightAtPos(vec2(p.x+eps,p.y)),\n                         2.0*eps,\n                         HeightAtPos(vec2(p.x,p.y-eps)) - HeightAtPos(vec2(p.x,p.y+eps)));\n    return normalize( n );\n    #endif\n}\n\n\/\/=======================================================================================\n\/\/ signed distance from point to curve\nfloat SDF (vec3 coords)\n{\n    float v = F(coords);\n    vec3  g = Gradient(coords.xz);\n    return abs(v)\/length(g);\n}\n\n\n\/\/=======================================================================================\nbool RayIntersectAABox (vec3 boxMin, vec3 boxMax, in vec3 rayPos, in vec3 rayDir, out vec2 time)\n{\n\tvec3 roo = rayPos - (boxMin+boxMax)*0.5;\n    vec3 rad = (boxMax - boxMin)*0.5;\n\n    vec3 m = 1.0\/rayDir;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    time = vec2( max( max( t1.x, t1.y ), t1.z ),\n                 min( min( t2.x, t2.y ), t2.z ) );\n\t\n    return time.y>time.x && time.y>0.0;\n}\n\n\/\/=======================================================================================\nfloat RayIntersectSphere (vec4 sphere, in vec3 rayPos, in vec3 rayDir)\n{\n\t\/\/get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    \/\/get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t\/\/exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn -1.0;\n\n\t\/\/calculate discriminant\n\tfloat discr = b * b - c;\n\n\t\/\/a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn -1.0;\n\n\t\/\/ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat collisionTime = -b - sqrt(discr);\n\n\t\/\/if t is negative, ray started inside sphere so clamp t to zero and remember that we hit from the inside\n\tif(collisionTime < 0.0)\n\t\tcollisionTime = -b + sqrt(discr);\n    \n    return collisionTime;\n}\n\n\/\/=======================================================================================\nvec3 DiffuseColor (in vec3 pos)\n{\n\t\/\/ checkerboard pattern\n    return vec3(mod(floor(pos.x * 10.0) + floor(pos.z * 10.0), 2.0) < 1.0 ? 1.0 : 0.4);\n}\n\n\/\/=======================================================================================\nvec3 ShadePoint (in vec3 pos, in vec3 rayDir, float time, bool fromUnderneath)\n{\n\tvec3 diffuseColor = DiffuseColor(pos);\n\tvec3 reverseLightDir = normalize(vec3(1.0,1.0,-1.0));\n\tvec3 lightColor = vec3(0.95,0.95,0.95);\t\n\tvec3 ambientColor = vec3(0.05,0.05,0.05);\n\n\tvec3 normal = NormalAtPos(pos.xz);\n    normal *= fromUnderneath ? -1.0 : 1.0;\n\n    \/\/ diffuse\n\tvec3 color = diffuseColor * ambientColor;\n\tfloat dp = dot(normal, reverseLightDir);\n\tif(dp > 0.0)\n\t\tcolor += (diffuseColor * dp * lightColor);\n    \n    \/\/ specular\n    vec3 reflection = reflect(reverseLightDir, normal);\n    dp = dot(rayDir, reflection);\n    if (dp > 0.0)\n        color += pow(dp, 15.0) * vec3(0.5);\t\n    \n    \/\/ reflection (environment mappping)\n    reflection = reflect(rayDir, normal);\n    color += textureCube(iChannel0, reflection).rgb * 0.25;\n    \n    return color;\n}\n\n\/\/=======================================================================================\nvec3 HandleRay (in vec3 rayPos, in vec3 rayDir, in vec3 pixelColor, out float hitTime)\n{\n\tfloat time = 0.0;\n\tfloat lastHeight = 0.0;\n\tfloat lastY = 0.0;\n\tfloat height;\n\tbool hitFound = false;\n    hitTime = FLT_MAX;\n    bool fromUnderneath = false;\n    \n    vec2 timeMinMax = vec2(0.0);\n    if (!RayIntersectAABox(vec3(0.0,CPMin,0.0), vec3(1.0,CPMax,1.0), rayPos, rayDir, timeMinMax))\n        return pixelColor;\n    \n    time = timeMinMax.x;\n    \n    const int c_numIters = 100;\n    float minT = (timeMinMax.y - timeMinMax.x) \/ float(c_numIters);\n    \n    vec3 pos = rayPos + rayDir * time;\n    float firstSign = sign(pos.y - HeightAtPos(pos.xz));\n    \n    float deltaT = minT;\n\tfor (int index = 0; index < c_numIters; ++index)\n\t{\t\t           \n\t\tpos = rayPos + rayDir * time;\n        \/\/deltaT = max(minT, SDF(pos));\n        \n        height = HeightAtPos(pos.xz);\n        \n        if (sign(pos.y - height) * firstSign < 0.0)\n        {\n            fromUnderneath = firstSign < 0.0; \n        \thitFound = true;\n\t\t\tbreak;\n        }\n\t\t\n\t\tlastHeight = height;\n\t\tlastY = pos.y;\n        time += deltaT;\t\n\t}\n\t\n\tif (hitFound) {\n\t\ttime = time - deltaT + deltaT*(lastHeight-lastY)\/(pos.y-lastY-height+lastHeight);\n\t\tpos = rayPos + rayDir * time;\n\t\tpixelColor = ShadePoint(pos, rayDir, time, fromUnderneath);\n        hitTime = time;\n\t}\n    else {\n        #if SHOW_BOUNDINGBOX\n        \tpixelColor += vec3(0.2);\n        #endif\n    }\n        \n\treturn pixelColor;\n}\n\n\/\/=======================================================================================\nvec3 HandleControlPoints (in vec3 rayPos, in vec3 rayDir, in vec3 pixelColor, inout float hitTime)\n{\n    #if SHOW_CONTROLPOINTS\n    float cpHitTime = RayIntersectSphere(vec4(0.0, CP00, 0.0, 0.01), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(1.0,0.0,0.0);\n    }\n    cpHitTime = RayIntersectSphere(vec4(0.5, CP01, 0.0, 0.01), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(1.0,0.0,0.0);\n    }    \n    cpHitTime = RayIntersectSphere(vec4(1.0, CP02, 0.0, 0.01), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(1.0,0.0,0.0);\n    }    \n    \n    cpHitTime = RayIntersectSphere(vec4(0.0, CP10, 0.5, 0.01), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(0.0,1.0,0.0);\n    }\n    cpHitTime = RayIntersectSphere(vec4(0.5, CP11, 0.5, 0.01), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(0.0,1.0,0.0);\n    }    \n    cpHitTime = RayIntersectSphere(vec4(1.0, CP12, 0.5, 0.01), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(0.0,1.0,0.0);\n    }        \n    \n    cpHitTime = RayIntersectSphere(vec4(0.0, CP20, 1.0, 0.01), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(0.0,0.0,1.0);\n    }\n    cpHitTime = RayIntersectSphere(vec4(0.5, CP21, 1.0, 0.01), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(0.0,0.0,1.0);\n    }    \n    cpHitTime = RayIntersectSphere(vec4(1.0, CP22, 1.0, 0.01), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(0.0,0.0,1.0);\n    }     \n    #endif\n    \n    return pixelColor;\n}\n\n\/\/=======================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\t\n    \/\/ keep it from degenerating when all control points are the same - like at the start!\n    CPMin -= 0.005;\n    CPMax += 0.005;\n        \n    \/\/----- camera\n    vec2 mouse = iMouse.xy \/ iResolution.xy;\n\n    vec3 cameraAt \t= vec3(0.5,0.5,0.5);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14 + iGlobalTime * 0.25;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.5;\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 3.0;\n    cameraPos += vec3(0.5,0.5,0.5);\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y \/ iResolution.x;\n    float cameraDistance\t= 6.0;  \/\/ intuitively backwards!\n\t\n\t\t\n\t\/\/ Objects\n\tvec2 rawPercent = (fragCoord.xy \/ iResolution.xy);\n\tvec2 percent = rawPercent - vec2(0.5,0.5);\n\t\n\tvec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n\t\t\t\t   - (cameraLeft * percent.x * cameraViewWidth)\n\t\t           + (cameraUp * percent.y * cameraViewHeight);\n\tvec3 rayDir = normalize(rayTarget);\n\t\n\t\n    float hitTime = FLT_MAX;\n\tvec3 pixelColor = textureCube(iChannel0, rayDir).rgb;\n    pixelColor = HandleRay(cameraPos, rayDir, pixelColor, hitTime);\n    pixelColor = HandleControlPoints(cameraPos, rayDir, pixelColor, hitTime);\n    \n    fragColor = vec4(clamp(pixelColor,0.0,1.0), 1.0);\n}","name":"","description":"","type":"image"}]}}