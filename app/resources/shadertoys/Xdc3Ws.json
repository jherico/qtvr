{"Shader":{"ver":"0.1","info":{"id":"Xdc3Ws","date":"1452652155","viewed":185,"name":"Rectangle Parallel Projection","username":"paniq","description":"Analytic projection of arbitrary oriented and sized rectangle to arbitrarily oriented line; I assume the 3D case is similar","likes":1,"published":3,"flags":0,"tags":["projection","rectangle","planar"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\n#define time iGlobalTime\n#define resolution iResolution\n\nvec2 anglevector (float r) {\n\treturn vec2(cos(r), sin(r));\n}\n\nfloat cube (vec2 p, vec2 r) {\n\treturn max(abs(p.x) - r.x, abs(p.y) - r.y);\n}\n\nvec3 dist2color (float d) {\n    return abs((mod(abs(d),0.1)\/0.1)-0.5)\/0.5 * mix(vec3(1.0,0.0,0.0),vec3(0.0,1.0,0.0),step(0.0,d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 position = fragCoord.xy \/ resolution.xy * 2.0 - 1.0;\n\tposition.x *= resolution.x \/ resolution.y;\n\n\tposition *= 4.0;\n\t\n\tvec2 offs = anglevector(time) * 1.0;\n\tvec2 hsize = vec2(0.5,1.0);\n    vec2 vsize = vec2(2.0,0.25);\n\t\n    vec2 cp = position - offs;\n\tfloat d = cube(cp, hsize);\n    d = min(d, cube(cp, vsize));\n\t\n\tvec2 pl = anglevector(time * 0.1);\n\tfloat pd = dot(pl, position);\n    \n        vec2 bcp = pl.yx;\n\t\tvec2 bb = bcp * hsize;\n\t\tfloat dmin = (abs(bb.x) + abs(bb.y));\n        vec2 bb2 = bcp * vsize;\n        dmin = max(dmin, (abs(bb2.x) + abs(bb2.y)));\n\t\tvec2 pp = vec2(pl.y, -pl.x);\n\t\tfloat planed = dot(pp, position - offs);\n\t\tfloat d2 = abs(planed) - dmin;\n    \n    vec3 c0 = dist2color(d);\n    vec3 c1 = dist2color(d2);\n    \n\t\n\tfragColor = vec4(max(c0, c1), 1.0 );\n}","name":"","description":"","type":"image"}]}}