{"Shader":{"ver":"0.1","info":{"id":"MtfSzX","date":"1438430675","viewed":664,"name":"Raymarching First Attempt","username":"Aspect","description":"Updates: Fixed reflection colors. Soft shadows. Cleaned up my main.  Improved the speed a bit.","likes":0,"published":3,"flags":0,"tags":["raymarching","distancefields"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/My first raymarching attempt. Shadow rays + 1 bounce reflection.\n\/\/ I tried to improvise as much as I could, and \"steal\" the minimum amount of code\n\/\/References were iq's articles and the \/r\/twotriangles raymarching tutorial on reddit. \n\nfloat sphere(vec3 pos, float radius)\n{\n    \n    return length(pos) - radius ;\n}\n\n\/\/http:\/\/www.iquilezles.org\/www\/articles\/smin\/smin.htm\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float minid=(a.x<b.x)? a.y:b.y;\n    float h = clamp( 0.5+0.5*(b.x-a.x)\/k, 0.0, 1.0 );\n    return vec2(mix( b.x, a.x, h ) - k*h*(1.0-h),minid);\n}\n\n\/\/from iq's raymarching primitives\nvec2 box( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return vec2(min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)),-44.0);\n}\n\nvec2 boxTwist( vec3 p,vec3 size )\n{\n    float c = cos(5.0*p.y);\n    float s = sin(5.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return box(q,size);\n}\nvec2 plane(vec3 pos)\n{\n return vec2(pos.y+90.0,-99.0);   \n}\n\n\/\/http:\/\/www.iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n\/\/http:\/\/www.iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nvec2 boxDisplace( vec3 p,vec3 size )\n{\n    vec2 d1 = box((abs(cos(0.25*iGlobalTime))*.25-0.7)*p,size);\n    float d2 =sin(1.9*p.x*abs(sin(0.1*iGlobalTime+90.)-0.5))*0.3*sin(1.5*p.y*abs(cos(0.1*iGlobalTime)-0.5))*0.3*cos(1.5*p.z*abs(cos(0.1*iGlobalTime)*0.3-0.5));\n    \n    return vec2(d1.x+d2,d1.y);\n}\n\nvec2 spheremore(vec3 pos,float radius)\n{\n    float min = 10000.0;\n    int mindex=-1;\n\n    \n    for(int i=0;i<5;i++)\n    {\n     vec3 center=vec3(16.5*cos(float(i))*sin(iGlobalTime),0.0,float(i)*11.5*cos(iGlobalTime));\n     float distance = length(pos-center)-radius;\n     if((distance)<(min)) \n     {\n         min=distance;\n         mindex=i;\n     }\n\n    }\n    \n    return vec2(min,float(mindex));\n}\n\n\n\/\/http:\/\/www.iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nvec2 distfunc(vec3 pos)\n{  \n    vec2 inter=smin(( spheremore(pos\/1.0,2.0)),boxDisplace(pos-vec3(0.0-7.0*cos(iGlobalTime),-10.0,4.0*sin(0.3*iGlobalTime)),vec3(5.0,5.0,5.0)),3.0 );\n    vec2 ops=opU(plane(pos),inter );\n    return ops;\n\n}\n\n\nvec3 retcol(float identif)\n{\n vec3 color=vec3(0.0);\n    \n    if(identif==0.0)\n    {\n        color=vec3(0.7,0.7,0.9);\n    }\n    else if(identif==1.0)\n    {\n     \tcolor=vec3(0.0,0.0,0.00);   \n    }\n     else if(identif==2.0)\n    {\n     \tcolor=vec3(0.1,0.2,0.8);   \n    }\n     else if(identif==3.0)\n    {\n     \tcolor=vec3(0.1,0.6,0.9);   \n    }\n     else if(identif==4.0)\n    {\n     \tcolor=vec3(0.2,0.9,0.6);   \n    }\n     else if(identif==-44.0)\n    {\n     \tcolor=vec3(1.0,1.0,1.0);   \n    }\n     else if(identif==-99.0)\n    {\n     \tcolor=vec3(0.8,0.1,0.2);   \n    }\n    else\n    {\n        color=vec3(0.0,1.0,1.0);   \n    }\n    \n    return color;\n    \n}\n\nvec3 rayMarch(vec3 pos,vec3 rayDir,float EPSILON,out vec2 dist)\n{\n    float mini=999999.0;\n    float origid=dist.y;\n    for (int i = 0; i < 80; i++)\n    {       \n        if ((dist.x < EPSILON)&&(dist.y!=origid))   continue;   \n        \n        dist = distfunc(pos); \n        pos += dist.x * rayDir;\n        if(dist.x<mini) mini=dist.x;\n        dist.x=mini;\n    }\n    return pos;\n}\n\nvec3 shadowMarch(vec3 pos,vec3 rayDir,float EPSILON,out vec2 dist)\n{\n    float mini=999999.0;\n    float origid=dist.y;\n    for (int i = 0; i < 40; i++)\n    {       \n        if ((dist.x < EPSILON)&&(dist.y!=origid))   continue;   \n        \n        dist = distfunc(pos); \n        pos += dist.x * rayDir;\n        if(dist.x<mini) mini=dist.x;\n        dist.x=mini;\n    }\n    return pos;\n}\n\n\n\n\/\/https:\/\/www.reddit.com\/r\/twotriangles\/comments\/1hy5qy\/tutorial_1_writing_a_simple_distance_field\/\nvec3 calculateNormal(float EPSILON, vec3 pos)\n{\n  \tvec2 eps = vec2(0.0, EPSILON);\n\tvec3 normal = normalize(vec3(\n    distfunc(pos + eps.yxx).x - distfunc(pos - eps.yxx).x,\n    distfunc(pos + eps.xyx).x - distfunc(pos - eps.xyx).x,\n    distfunc(pos + eps.xxy).x - distfunc(pos - eps.xxy).x));\n            \n    return normal;\n}\n\nvec3 tempNormal(vec3 pos,float id,float EPSILON)\n{\n    vec3 normal=vec3(0.0);\n    if(id>=0.0)\n    {\n         normal=normalize(pos-vec3(16.5*cos(float(id))*sin(iGlobalTime),0.0,float(id)*11.5*cos(iGlobalTime)));\n\n    }\n    else if(id==-99.0)\n    {\n        normal=normalize(vec3(0.0,pos.y+90.01,0.0));\n    }\n    else\n    {\n        normal=calculateNormal(EPSILON,pos);\n    }\n   return normal;\n    \n}\n\nvoid getRay(vec2 screenPos,out vec3 cameraOrigin,out vec3 rayDir)\n{\n    cameraOrigin = vec3(2.0+3.0*cos(iGlobalTime), +16.0+6.0*cos(iGlobalTime), 5.0+1.0*cos(iGlobalTime));  \n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n    vec3 upDirection = vec3(0.0, 1.0, 0.0);\n    vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n    vec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n\tvec3 cameraUp = cross(cameraDir, cameraRight);\n    rayDir = normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n   \n\n}\n\n\nvec4 render(vec2 ScreenPos)\n{\n    vec3 rayDir=vec3(0.0);\n    vec3 pos=vec3(0.0);\n    getRay(ScreenPos,pos,rayDir);\n    \n \n    const int MAX_ITER = 100;\n    const float MAX_DIST = 20.0; \n    float EPSILON = 0.01;\n    float totalDist = 0.0;\n    vec2 dist = vec2(EPSILON,0.0);\n    vec3 lightpos=vec3(25.0,55.0,0.0);\n\n    \/\/initial march towards objects\n    pos=rayMarch(pos,rayDir,EPSILON,dist);\n                     \n   if (dist.x <EPSILON)\n{\n     vec3 normal=tempNormal(pos,dist.y,EPSILON);\n    \n   \n    vec3  lightdir=   normalize(lightpos-pos);  \n    vec3 halfvec= normalize(lightdir-rayDir);\n    vec3 reflected= normalize(reflect(rayDir,normal));\n    vec3 color=vec3(0.0);\n    \n    EPSILON=0.01;\n        \n    \/\/shadow ray \n    vec2 shadowdist=vec2(EPSILON,dist.y);\n    vec3 shadowpos=shadowMarch(pos+2.0*lightdir,lightdir,EPSILON,shadowdist);\n    if((shadowdist.x<EPSILON)&&(shadowdist.y!=dist.y))\n    {\n        color=vec3(0.0,0.0,0.0);\n    }\n    else\n    {\n     \n        \n    float diffuse = max(0.0, dot(lightdir, normal));\n    float specular = pow(dot(normal,halfvec), 64.0);\n    color = vec3(retcol(dist.y)*(diffuse + specular));\n          \n     \/\/soft shadows\n    float penumbra=50.0;\n    if(shadowdist.x<penumbra*EPSILON) color*=shadowdist.x\/(penumbra*EPSILON);  \n            \n    \/\/reflection rays  \n    EPSILON=0.0001;    \n        \n    vec2 reflectdist=vec2(EPSILON,dist.y);\n    vec3 reflecpos=shadowMarch(pos+0.1*reflected,reflected,EPSILON,reflectdist);\n      if((reflectdist.x<EPSILON)&&(reflectdist.y!=dist.y))\n      {\n              \n        vec3 lightdir2= normalize(lightpos-reflecpos);\n        vec3 halfvec2= normalize(lightdir2-reflected);\n        \n        \/\/check if reflection point is in shadow\n        vec2 shadowrefdist=vec2(EPSILON,reflectdist);\n        vec3 shadowrefpos= shadowMarch(reflecpos+0.01*lightdir2,lightdir2,EPSILON,shadowrefdist);                      \n                 if((shadowrefdist.x>=EPSILON))\n                 {                  \n                                          \n                vec3 reflecnormal=tempNormal(reflecpos,reflectdist.y,EPSILON);\n\n                float diffuseR = max(0.0, dot(lightdir2, reflecnormal));\n                float specularR =pow(dot(reflecnormal,halfvec2), 4.0);      \n                vec3 reflecolor= vec3(retcol(reflectdist.y)*(diffuseR+specularR));\n                color= color+0.2*reflecolor;\n                 }\n\n      }\n        \n    }    \n    \n\treturn vec4(color, 1.0);\n}\nelse\n{\n    return vec4(vec3(retcol(dist.y)),1.0);\n}\n  \n}\n\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{         \n\tvec2 uv = fragCoord.xy \/ iResolution.xy;   \n    vec2 xy = -1.0 + 2.0*fragCoord.xy\/iResolution.xy;\n \n    vec2 screenPos = -1.0 + 2.0 * gl_FragCoord.xy \/ iResolution.xy; \n\tscreenPos.x *= iResolution.x \/ iResolution.y; \n     vec2 mo = iMouse.xy\/iResolution.xy;\n  \n    fragColor=render(screenPos);\n\n}","name":"","description":"","type":"image"}]}}