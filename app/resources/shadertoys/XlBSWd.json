{"Shader":{"ver":"0.1","info":{"id":"XlBSWd","date":"1447184574","viewed":403,"name":"cube with slabs","username":"fischel","description":"This is my second shader. I wantet to build a simple cube with colors. So the easiest way was to use slabs (I think). To save the color of the slabs I build the struct. So it was not necessary to calc the color later (find the slab).","likes":3,"published":3,"flags":0,"tags":["cube","slabs"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/\n\/\/ This is my second shader. I wantet to build a simple cube with colors.\n\/\/ So the easiest way was to use slabs (I think).\n\/\/ To save the color of the slabs I build the struct. So it was\n\/\/ not necessary to calc the color later (find the slab).\n\/\/\n\/\/ The cam (eye) is flying around the cube. The cube is fix.\n\/\/\n\/\/ some tutorials and docs\n\/\/ https:\/\/www.shadertoy.com\/view\/Md23DV - GLSL Turorials\n\/\/ https:\/\/www.shadertoy.com\/view\/ldfXW2 - Distance function with normals\n\/\/ https:\/\/www.opengl.org\/sdk\/docs\/man\/\n\n\/\/ struct of a slab\nstruct slab\n{\n  vec3 dir; \/\/ direction (perpendicular of the layer)\n  float t; \/\/ 't' of the ray crossing the slab\n  vec3 color; \/\/ color of the slab\n};\n\nslab z1 = slab(vec3(0,0, 1), 0.0, vec3(1,0,0));\nslab z2 = slab(vec3(0,0,-1), 0.0, vec3(1,0,0));\n\nslab x1 = slab(vec3( 1,0,0), 0.0, vec3(0,1,0));\nslab x2 = slab(vec3(-1,0,0), 0.0, vec3(0,1,0));\n\nslab y1 = slab(vec3(0, 1,0), 0.0, vec3(1,1,0));\nslab y2 = slab(vec3(0,-1,0), 0.0, vec3(1,1,0));\n\n\/\/ min function for slab\nslab minSlab(in slab s1, in slab s2)\n{\n    if (s2.t < s1.t) {\n        return s2;\n    }\n    return s1;\n}\n\n\/\/ max function for slab\nslab maxSlab(in slab s1, in slab s2)\n{\n    if (s2.t > s1.t) {\n        return s2;\n    }\n    return s1;\n}\n\nbool intersect(out vec4 color, in vec3 ro, in vec3 d)\n{   \n    \/\/ z slab\n    z1.t = (z1.dir.z - ro.z) \/ d.z; \/\/ div by zero, not nice, but works :)\n    z2.t = (z2.dir.z - ro.z) \/ d.z;\n    slab zmin = minSlab(z1, z2);\n    slab zmax = maxSlab(z1, z2);\n    \n    \/\/ x slab\n    x1.t = (x1.dir.x - ro.x) \/ d.x;\n    x2.t = (x2.dir.x - ro.x) \/ d.x;\n    slab xmin = minSlab(x1, x2);\n    slab xmax = maxSlab(x1, x2);\n    \n    \/\/ y slab\n    y1.t = (y1.dir.y - ro.y) \/ d.y;\n    y2.t = (y2.dir.y - ro.y) \/ d.y;\n    slab ymin = minSlab(y1, y2);\n    slab ymax = maxSlab(y1, y2);\n   \n    slab tmin = maxSlab(zmin, maxSlab(ymin, xmin));\n    slab tmax = minSlab(zmax, minSlab(ymax, xmax));\n    \n    \/\/ hit or not hit :)\n    if (tmin.t > tmax.t) {\n        return false;\n    }\n    \n    vec3 p = tmin.t * d; \/\/ ray to the hit-point\n    \/\/ angle between ray and layer\n    float h = dot(p, tmin.dir)\/(length(p) * length(tmin.dir));\n    h = 1.0 - smoothstep(0.0, 0.5, (h + 1.0) \/ 2.0);\n    color = vec4(h * tmin.color, 1.0);\n    return true;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 uv = 2.0 * (fragCoord.xy \/ iResolution.xy) - 1.0;\n    uv.x *= iResolution.x \/ iResolution.y; \/\/ aspect ratio\n    \n    float height = iMouse.y \/ iResolution.y * 2.0;\n    float angle = iGlobalTime;\n    if (iMouse.z > 0.0) {\n    \tangle = iMouse.x \/ iResolution.x * 4.0;\n    }\n    \n    vec3 ro = 4.0 * vec3(sin(angle), cos(angle), 0.5 + height); \/\/ eye\n    vec3 d = normalize(-ro); \/\/ direction - looks to 0,0,0\n    vec3 k = vec3(ro.xy, 0) - ro; \/\/ vec to down\n    vec3 x = cross(d, normalize(k)); \/\/ x is the ray left\/right to the eye\n    vec3 y = cross(d, x); \/\/ y is the ray up\/down to the eye\n    d = normalize(d + x * uv.x + y * uv.y); \/\/ result to dir\n    \n    if (!intersect(fragColor, ro, d)) {\n        \/\/ blue background\n        fragColor = vec4(0.0, 0.0, fragCoord.y \/ iResolution.y, 1.0);\n    }\n}","name":"","description":"","type":"image"}]}}