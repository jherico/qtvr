{"Shader":{"ver":"0.1","info":{"id":"4scGW7","date":"1449913353","viewed":211,"name":"RollingHillsXP","username":"nslottow","description":"Understanding raymarching via iq's nice article: http:\/\/www.iquilezles.org\/www\/articles\/terrainmarching\/terrainmarching.htm","likes":2,"published":3,"flags":0,"tags":["raymarching"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\nfloat f(float x, float z)\n{\n    return sin(x + cos(z * 3.0 + iGlobalTime * 0.5)) * sin(z + iGlobalTime);\n}\n\nbool castRay(vec3 ro, vec3 rd, out float resT)\n{\n    const float mint = 0.001;\n    const float maxt = 20.0;\n    const float dt = 0.08;\n    float lh = 0.0;\n    float ly = 0.0;\n    \n    float t = mint;\n    \n    for (float t = mint; t < maxt; t += dt)\n    {\n        vec3 p = ro + rd * t;\n        float h = f(p.x, p.z);\n        if (p.y < h)\n        {\n            resT = t - dt + dt * (lh - ly) \/ (p.y - ly - h + lh);\n            return true;\n        }\n        lh = h;\n        ly = p.y;\n    }\n    \n    return false;\n}\n\nvec3 getNormal(vec3 p)\n{\n    const float eps = 0.02;\n    vec3 n = vec3(\n        f(p.x - eps, p.z) - f(p.x + eps, p.z),\n        2.0 * eps,\n        f(p.x, p.z - eps) - f(p.x, p.z + eps));\n    return normalize(n);  \n}\n\nvec3 getShading(vec3 p, vec3 n)\n{\n    return dot(n, vec3(0.0, 1.0, 0.0)) * vec3(0.2, 0.7, 0.2);\n}\n\nvec3 terrainColor(vec3 ro, vec3 rd, float t)\n{\n    vec3 p = ro + rd * t;\n    vec3 n = getNormal(p);\n    vec3 s = getShading(p, n);\n    \n    return s;\n}\n\nvec3 skyColor(vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    return vec3(0.4, 0.6, 0.9 * uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x \/ iResolution.y;\n    const float hfov = 45.0 * 0.5 * 3.1415926535 \/ 180.0;\n    const float tanhfov = tan(hfov);\n    const float near = 0.1;\n    const float far = 1.0;\n    \n    vec2 uv = fragCoord.xy \/ (iResolution.xy * 0.5) - vec2(1.0, 1.0);\n    float dx = tanhfov * uv.x \/ aspect;\n    float dy = tanhfov * uv.y;\n    \n    vec3 viewRayDir = normalize(vec3(dx, dy, 1.0) * (far - near));\n    \n    float bob = -0.4 + 0.1 * cos(iGlobalTime * 0.5);\n    mat4 inverseViewMatrix = mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, bob, 1.0, 0.0,\n        0.0, 0.0, 0.0, 0.0\n        );\n    \n    const vec3 ro = vec3(0.0, 7.0, 0.0);\n    vec3 rd = (inverseViewMatrix * vec4(viewRayDir, 0.0)).xyz;\n    float resT;\n    \n    if (castRay(ro, rd, resT))\n    {\n        fragColor = vec4(terrainColor(ro, rd, resT), 1.0);\n    }\n    else\n    {\n        fragColor = vec4(skyColor(fragCoord), 1.0);\n    }\n}","name":"","description":"","type":"image"}]}}