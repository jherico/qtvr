{"Shader":{"ver":"0.1","info":{"id":"XdXGWr","date":"1366820199","viewed":770,"name":"Akiyoshi's Snakes Illusion","username":"Dave_Hoskins","description":"*** This should be viewed full-screen to work correctly. ***<br\/>This is my attempt at recreating an \"anomalous motion illusion\" from here:-<br\/>http:\/\/www.ritsumei.ac.jp\/~akitaoka\/index-e.html<br\/>It does NOT animate, it just seems like it does!<br\/>","likes":13,"published":3,"flags":0,"tags":["2d","illusion","snakes","akiyoshi"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Akiyoshi's Snakes Illusion\n\/\/ Shader code by David Hoskins - 2013.\n\/\/ This is my attempt at recreating an \"anomalous motion illusion\" from here:-\n\/\/ http:\/\/www.ritsumei.ac.jp\/~akitaoka\/index-e.html\n\/\/ *** This should be viewed full screen to work correctly. ***\n\/\/\n\/\/ It is NOT ANIMATED, it just seems like it is!\n\/\/ It works by using psychovisual research into how the brain interprets images\n\/\/ in the visual cortex - cool huh?!\n\/\/ You can stop it by staring at a single point,\n\/\/ Can't make it stop? Then you're drinking too much coffee!! :)\n\/\/ CAT's can see it too! Look:-\n\/\/ http:\/\/www.youtube.com\/watch?v=CcXXQ6GCUb8\n\nfloat Circle(vec2 p, float r)\n{\n    float ret = length(p)-r;    return ret;\n}\n\nvec3 Colour(vec2 pos, float r, float odd)\n{\n    if (r > .235) return vec3(0.0, 0.0, 0.0);\n    vec3 rgb;\n    r = pow(r, 1.5)*90.0;\n    float ring = floor(r);\n    r = pow(fract(r), 1.0\/1.5);\n    float ang = atan(pos.x,pos.y)*6.37;\n    ang += ring;\n    float fra = fract(ang);\n    float si = length(vec2(fra*1.25, r)-vec2(.5, .5))-.5;\n    if (si <= 0.0)\n    {\n        rgb = mix(vec3(.825, .825, 0.0), vec3(0.0, 0.399, 1.0), step(mod(ang+odd, 2.0), 1.0));\n    }\n    else\n    {\n        rgb = mix(vec3(.0, .0, 0.0), vec3(1.0, 1.0, 1.0), step(mod(ang+.5, 2.0), 1.0));\n    }\n    return rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy \/ iResolution.xy)*2.0-1.0;\n    uv *= .85;\n    uv.x *= iResolution.x \/ iResolution.y;\n    vec2 pixelSize = vec2(1.0, 1.0) \/ iResolution.xy;\n    vec3 rgb;\n    vec3 colAdd = vec3(0.0, 0.0, 0.0);\n    float r;\n\n    \/\/ Anti-aliasing...\n    float y = -1.0;\n    for (int yi = 0; yi < 4; yi++)\n    {\n        float x = -1.0;\n        for (int xi = 0; xi < 4; xi++)\n        {\n            rgb = vec3(1.0, 1.0, 1.0);\n            vec2 pos = uv+vec2(0.0, .25)+pixelSize*vec2(x, y)+.5;\n            float odd = mod(floor(pos.x*2.0)+floor(pos.y*2.0),2.0);                    \n            if (length(max(abs(uv*vec2(.5, 1.0))-.75,0.0)) <= .0)            \n            {                \n                pos = mod(pos, .5)-.25;                \n                r = Circle(pos, .25);                \n                if (r < 0.0)                \n                {                    \n                    rgb = Colour(pos, -r, odd);                \n                }            \n            }            \n            if (length(max(abs(uv*vec2(.4, 1.0))-.5,0.0)) <= .0)            \n            {                \n                pos = uv+vec2(0.0, .25)+pixelSize*vec2(x, y)+.25;                \n                float odd = mod(floor(pos.x*2.0)+floor(pos.y*2.0),2.0);                \n                pos = mod(pos, .5)-.25;                \n                r = Circle(pos, .25);                \n                if (r < 0.0)                \n                {                    \n                    rgb = Colour(pos, -r, odd);\n                }            \n            }            \n            colAdd += rgb;            \n            x += .5;        \n        }        \n        y += .5;    \n    }    \n    colAdd *= 1.0\/16.0;        \n    fragColor = vec4(colAdd, 1.0);\n}","name":"","description":"","type":"image"}]}}