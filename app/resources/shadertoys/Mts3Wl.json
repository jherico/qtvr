{"Shader":{"ver":"0.1","info":{"id":"Mts3Wl","date":"1426289073","viewed":764,"name":"4D Grid Slice","username":"TekF","description":"A 3D slice through a 4D grid. ","likes":12,"published":3,"flags":0,"tags":["4d"],"hasliked":0},"renderpass":[{"inputs":[{"id":10,"src":"\/presets\/tex09.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Ben Quantock 2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ https:\/\/creativecommons.org\/licenses\/by-nc-sa\/3.0\/\n\n\/\/ consts\nconst float tau = 6.2831853;\nconst float phi = 1.61803398875;\n\nvec2 Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec4 rg = texture2D( iChannel0, (uv+0.5)\/256.0, -100.0 );\n\treturn mix( rg.yw, rg.xz, f.z );\n}\n\n\n\nvec4 Map( vec3 p3 )\n{\n    \/\/ construct an orthonormal frame for the slice\n\/\/\tum... there's no 4D cross product, is there? There can't be! Would need 3 inputs. balls.\n    vec4 i = vec4(1,0,0,0);\n    vec4 j = vec4(0,1,0,0);\n    vec4 k = vec4(0,0,1,0);\n    \n    \/\/ rules for rotation should still behave afaik\n    float a,c;\n    vec2 s;\n    a = iGlobalTime*.1;\n    c = cos(a); s = vec2(1,-1)*sin(a);\n    i.xz = i.xz*c + i.zx*s;\n    j.xz = j.xz*c + j.zx*s;\n    k.xz = k.xz*c + k.zx*s;\n    i.yw = i.yw*c + i.wy*s;\n    j.yw = j.yw*c + j.wy*s;\n    k.yw = k.yw*c + k.wy*s;\n    i.xw = i.xw*c + i.wx*s;\n    j.xw = j.xw*c + j.wx*s;\n    k.xw = k.xw*c + k.wx*s;\n    i.yz = i.yz*c + i.zy*s;\n    j.yz = j.yz*c + j.zy*s;\n    k.yz = k.yz*c + k.zy*s;\n    \n    \/\/ form a basis perp to vec4(1,1,1,1)\n\/\/    actually easier than it sounds, just make it so dot prods sum to 0\n\/*    vec4 i = vec4(1,1,-1,-1)\/2.0;\n    vec4 j = vec4(-1,1,-1,1)\/2.0;\n    vec4 k = vec4(1,-1,-1,1)\/2.0;*\/\n    \n    \/\/vec4 p = vec4(p3,0);\n    vec4 p = i*p3.x + j*p3.y + k*p3.z;\/\/ + vec4(1,1,1,1)*.5*.25;\n\n    return p;\n}\n    \nfloat DistanceField( vec3 p3 )\n{\n    vec4 p = Map(p3);\n    \n    \/\/ offset to centre of cell\n    float f = 100.0;\n    \n    \/\/ cells\n    vec4 o = .5 - abs(fract(p+.5)-.5);\n    f = min(f, .2 - min(min(min(o.x, o.y), o.z), o.w ) );\n        \n\t\/\/ or grid edges (is this meaningful? - apparently, yes)\n    f = min(f, min(min(min(min(min(length(o.xy),length(o.xz)),length(o.xw)),length(o.yz)),length(o.yw)),length(o.zw)) - .03);\n    \n    p = abs(p);\n    return max( f, max(max(max(p.x,p.y),p.z),p.w)-1.53 );\n}\n\n\n\n\nvec3 Sky( vec3 ray )\n{\n\treturn mix( vec3(.8), vec3(0), exp2(-(1.0\/max(ray.y,.01))*vec3(.4,.6,1.0)) );\n}\n\n\nvec3 Shade( vec3 pos, vec3 ray, vec3 normal, vec3 lightDir, vec3 lightCol, float shadowMask, float distance )\n{\n    vec4 p = Map(pos);\n\n    vec4 c = (p+1.5)\/3.0;\n    \/\/vec3 albedo = (c.xyz);\/\/ + c.www)*.5;\/\/vec3(.25);\n\/\/    vec3 albedo = vec3(.75,0,0)*c.x + vec3(.25,.5,0)*c.y + vec3(0,.5,.25)*c.z + vec3(0,0,.75)*c.w;\n    \n    vec4 o = .5 - abs(fract(p+.5)-.5);\n    vec3 albedo = mix( vec3(1,0,0), vec3(1), step(.1,min(min(min(o.x, o.y), o.z), o.w )) );\n\n\n\t\/\/ direct light\n\tfloat ndotl = max(.0,dot(normal,lightDir));\n\tfloat lightCut = smoothstep(.0,.1,ndotl);\/\/pow(ndotl,2.0);\n\tvec3 light = lightCol*shadowMask*ndotl;\n\n\n\t\/\/ ambient light\n\tvec3 ambient = mix( vec3(.2,.27,.4), vec3(.4), (-normal.y*.5+.5) ); \/\/ ambient\n\n\t\/\/ ambient occlusion, based on my DF Lighting: https:\/\/www.shadertoy.com\/view\/XdBGW3\n\tfloat aoRange = distance\/20.0;\n\tfloat occlusion = max( 0.0, 1.0 - DistanceField( pos + normal*aoRange )\/aoRange ); \/\/ can be > 1.0\n\tocclusion = exp2( -2.0*pow(occlusion,2.0) ); \/\/ tweak the curve\n\tambient *= occlusion;\n\n\n\t\/\/ subsurface scattering\n\tfloat transmissionRange = 0.1;\n\tfloat transmission = DistanceField( pos + lightDir*transmissionRange )\/transmissionRange;\n\tvec3 sslight = lightCol * smoothstep(0.0,1.0,transmission);\n\tvec3 subsurface = vec3(1,.8,.5) * sslight;\n\n\n\t\/\/ specular\n\tfloat specPower = 400.0;\n\t\n\tvec3 h = normalize(lightDir-ray);\n    float specFres = mix( .02, 1.0, pow( 1.0 - dot(h,lightDir), 5.0 ) );\n\tvec3 specular = lightCol*shadowMask*pow(max(.0,dot(normal,h))*lightCut, specPower)*specFres*(specPower+6.0)\/32.0;\n\t\n\n\t\/\/ reflections\n\tvec3 rray = reflect(ray,normal);\n\tvec3 reflection = Sky( rray );\n\t\n\t\/\/ reflection occlusion, adjust the divisor for the gradient we expect\n\tfloat specOcclusion = max( 0.0, 1.0 - DistanceField( pos + rray*aoRange )\/(aoRange*max(.01,dot(rray,normal))) ); \/\/ can be > 1.0\n\tspecOcclusion = exp2( -2.0*pow(specOcclusion,2.0) ); \/\/ tweak the curve\n\t\n\t\/\/ prevent sparkles in heavily occluded areas\n\tspecOcclusion *= occlusion;\n\n\treflection *= specOcclusion; \/\/ could fire an additional ray for more accurate results\n\t\n\t\/\/ fresnel\n\tfloat fresnel = pow( 1.0+dot(normal,ray), 5.0 );\n\tfresnel = mix( .02, 1.0, fresnel );\n\t\n\tvec3 result = vec3(0);\n\n\t\n\t\/\/ Combine all shading stages\n\t\/\/ comment these out to toggle various parts of the effect\n\tlight += ambient;\n\n\/\/\tlight = mix( light, subsurface, .5 );\n\t\n\tresult = light*albedo;\n\n\/\/\tresult = mix( result, reflection, fresnel );\n\t\n\tresult += specular;\n\n\treturn result;\n}\n\n\n\n\n\/\/ Isosurface Renderer\n#ifdef FAST\nconst int traceLimit=40;\nconst float traceSize=.005;\n#else\nconst int traceLimit=100;\nconst float traceSize=.001;\/\/before *t: .002;\n#endif\t\n\nfloat Trace( vec3 pos, vec3 ray, float traceStart, float traceEnd )\n{\n\tfloat t = traceStart;\n\tfloat h;\n\tfor( int i=0; i < traceLimit; i++ )\n\t{\n\t\th = DistanceField( pos+t*ray );\n\t\tif ( h < traceSize*t || t > traceEnd )\n\t\t\tbreak;\n\t\tt = t+h;\n\t}\n\t\n\tif ( t > traceEnd )\/\/|| h > .001 )\n\t\treturn 0.0;\n\t\n\treturn t;\n}\n\nfloat TraceMin( vec3 pos, vec3 ray, float traceStart, float traceEnd )\n{\n\tfloat Min = traceEnd;\n\tfloat t = traceStart;\n\tfloat h;\n\tfor( int i=0; i < traceLimit; i++ )\n\t{\n\t\th = DistanceField( pos+t*ray );\n\t\tif ( h < .001 || t > traceEnd )\n\t\t\tbreak;\n\t\tMin = min(h,Min);\n\t\tt = t+max(h,.1);\n\t}\n\t\n\tif ( h < .001 )\n\t\treturn 0.0;\n\t\n\treturn Min;\n}\n\nvec3 Normal( vec3 pos, vec3 ray, float t )\n{\n\t\/\/ in theory we should be able to get a good gradient using just 4 points\n\n\tfloat pitch = .2 * t \/ iResolution.x;\n#ifdef FAST\n\t\/\/ don't sample smaller than the interpolation errors in Noise()\n\tpitch = max( pitch, .005 );\n#endif\n\t\n\tvec2 d = vec2(-1,1) * pitch;\n\n\tvec3 p0 = pos+d.xxx; \/\/ tetrahedral offsets\n\tvec3 p1 = pos+d.xyy;\n\tvec3 p2 = pos+d.yxy;\n\tvec3 p3 = pos+d.yyx;\n\t\n\tfloat f0 = DistanceField(p0);\n\tfloat f1 = DistanceField(p1);\n\tfloat f2 = DistanceField(p2);\n\tfloat f3 = DistanceField(p3);\n\t\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3);\n\t\n\t\/\/ prevent normals pointing away from camera (caused by precision errors)\n\tfloat gdr = dot ( grad, ray );\n\tgrad -= max(.0,gdr)*ray;\n\t\n\treturn normalize(grad);\n}\n\n\n\/\/ Camera\n\nvec3 Ray( float zoom, vec2 fragCoord )\n{\n\treturn vec3( fragCoord.xy-iResolution.xy*.5, iResolution.x*zoom );\n}\n\nvec3 Rotate( inout vec3 v, vec2 a )\n{\n\tvec4 cs = vec4( cos(a.x), sin(a.x), cos(a.y), sin(a.y) );\n\t\n\tv.yz = v.yz*cs.x+v.zy*cs.y*vec2(-1,1);\n\tv.xz = v.xz*cs.z+v.zx*cs.w*vec2(1,-1);\n\t\n\tvec3 p;\n\tp.xz = vec2( -cs.w, -cs.z )*cs.x;\n\tp.y = cs.y;\n\t\n\treturn p;\n}\n\n\n\/\/ Camera Effects\n\nvoid BarrelDistortion( inout vec3 ray, float degree )\n{\n\t\/\/ would love to get some disperson on this, but that means more rays\n\tray.z \/= degree;\n\tray.z = ( ray.z*ray.z - dot(ray.xy,ray.xy) ); \/\/ fisheye\n\tray.z = degree*sqrt(ray.z);\n}\n\nvec3 LensFlare( vec3 ray, vec3 lightCol, vec3 light, float lightVisible, float sky, vec2 fragCoord )\n{\n\tvec2 dirtuv = fragCoord.xy\/iResolution.x;\n\t\n\tfloat dirt = 1.0-texture2D( iChannel1, dirtuv ).r;\n\t\n\tfloat l = (dot(light,ray)*.5+.5);\n\t\n\treturn (\n\t\t\t((pow(l,30.0)+.05)*dirt*.1\n\t\t\t+ 1.0*pow(l,200.0))*lightVisible + sky*1.0*pow(l,5000.0)\n\t\t   )*lightCol\n\t\t   + 5.0*pow(smoothstep(.9999,1.0,l),20.0) * lightVisible * normalize(lightCol);\n}\n\n\nfloat SmoothMax( float a, float b, float smoothing )\n{\n\treturn a-sqrt(smoothing*smoothing+pow(max(.0,a-b),2.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 ray = Ray( .7, fragCoord );\n\t\n\tBarrelDistortion( ray, .5 );\n\t\n\tray = normalize(ray);\n\tvec3 localRay = ray;\n\n    vec2 rot = vec2(.2,0.0);\n    \n\tfloat T = iGlobalTime*.13;\n\tvec2 mouse = vec2(.2,.5);\n\tif ( iMouse.z > .0 )\n\t\trot += vec2(1.0,-6.3) * (vec2(.5)-iMouse.yx\/iResolution.yx);\n    else\n        rot -= vec2(0,1)*T;\n\t\t\n    float dist = 7.0;\/\/ * (-sin(iGlobalTime\/10.0)+1.0);\n\tvec3 pos = dist*Rotate( ray, rot );\n\t\/\/pos += vec3(0,.3,0) + T*vec3(0,0,-1);\n\t\n\tvec3 col;\n\n\tvec3 lightDir = normalize(vec3(3,1,-2));\n\t\n\tvec3 lightCol = vec3(1.1,1,.9)*1.0;\n\t\n\t\/\/ can adjust these according to the scene, even per-pixel to a bounding volume\n\tfloat near = .0;\n\tfloat far = 40.0;\n\t\n\tfloat t = Trace( pos, ray, near, far );\n\tif ( t > .0 )\n\t{\n\t\tvec3 p = pos + ray*t;\n\t\t\n\t\t\/\/ shadow test\n\t\tfloat s = 0.0;\n\t\t\/\/s = TraceMin( p, lightDir, .05, far );\n        s = Trace( p, lightDir, .01*t, far );\n\t\t\n\t\tvec3 n = Normal(p, ray, t);\n\t\tcol = Shade( p, ray, n, lightDir, lightCol,\n\t\t\t\t\t\/\/smoothstep( .0, .01, s ),\n                    step( s, .001 ),\n                    t );\n\t\t\n\t\t\/\/ fog\n\t\tfloat f = 200.0;\n\t\tcol = mix( vec3(.8), col, exp2(-t*vec3(.4,.6,1.0)\/f) );\n\t}\n\telse\n\t{\n\t\tcol = Sky( ray );\n\t}\n\t\n\t\/\/ lens flare\n\tfloat s = TraceMin( pos, lightDir, .5, 40.0 );\n\tcol += LensFlare( ray, lightCol, lightDir, smoothstep(.01,.1,s), step(t,.0), fragCoord );\n\t\n\t\/\/ vignetting:\n\tcol *= smoothstep( 1.0, .0, dot(localRay.xy,localRay.xy) );\n\t\n\t\/\/ compress bright colours, ( because bloom vanishes in vignette )\n\tvec3 c = (col-1.0);\n\tc = sqrt(c*c+.05); \/\/ soft abs\n\tcol = mix(col,1.0-c,.48); \/\/ .5 = never saturate, .0 = linear\n\t\n\t\/\/ grain\n\tvec2 grainuv = fragCoord.xy + floor(iGlobalTime*60.0)*vec2(37,41);\n\tvec2 filmNoise = texture2D( iChannel0, .5*grainuv\/iChannelResolution[0].xy ).rb;\n\tcol *= mix( vec3(1), mix(vec3(1,.5,0),vec3(0,.5,1),filmNoise.x), .1*filmNoise.y );\n\t\n\t\/\/ compress bright colours\n\tfloat l = max(col.x,max(col.y,col.z));\/\/dot(col,normalize(vec3(2,4,1)));\n\tl = max(l,.01); \/\/ prevent div by zero, darker colours will have no curve\n\tfloat l2 = SmoothMax(l,1.0,.01);\n\tcol *= l2\/l;\n\t\n\tfragColor = vec4(pow(col,vec3(1.0\/2.2)),1);\n}\n","name":"","description":"","type":"image"}]}}