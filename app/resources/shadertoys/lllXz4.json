{"Shader":{"ver":"0.1","info":{"id":"lllXz4","date":"1446535483","viewed":850,"name":"Inverse Spherical Fibonacci","username":"iq","description":"Spherical Fibonacci points, as described by this paper <a href=\"http:\/\/lgdv.cs.fau.de\/uploads\/publications\/spherical_fibonacci_mapping_opt.pdf\"  class=\"regular\" target=\"_blank\">http:\/\/lgdv.cs.fau.de\/uploads\/publications\/spherical_fibonacci_mapping_opt.pdf<\/a>","likes":27,"published":3,"flags":0,"tags":["3d","fibonazzi"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\n\/\/ Spherical Fibonnacci points, as described by Benjamin Keinert, Matthias Innmann, \n\/\/ Michael Sanger and Marc Stamminger in their paper (below)\n\n\n\/\/=================================================================================================\n\/\/ http:\/\/lgdv.cs.fau.de\/uploads\/publications\/spherical_fibonacci_mapping_opt.pdf\n\/\/=================================================================================================\nconst float PI  = 3.14159265359;\nconst float PHI = 1.61803398875;\n\nfloat round( float x ) { return floor(x+0.5); }\n\nvec2 inverseSF( vec3 p, float n ) \n{\n    float m = 1.0 - 1.0\/n;\n    \n    float phi = min(atan(p.y, p.x), PI), cosTheta = p.z;\n    \n    float k  = max(2.0, floor( log(n * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))\/ log(PHI+1.0)));\n    float Fk = pow(PHI, k)\/sqrt(5.0);\n    vec2  F  = vec2( round(Fk), round(Fk * PHI) ); \/\/ k, k+1\n\n    vec2 ka = 2.0*F\/n;\n    vec2 kb = 2.0*PI*( fract((F+1.0)*PHI) - (PHI-1.0) );    \n    \n    mat2 iB = mat2( ka.y, -ka.x, \n                    kb.y, -kb.x ) \/ (ka.y*kb.x - ka.x*kb.y);\n    \n    vec2 c = floor( iB * vec2(phi, cosTheta - m));\n    float d = 8.0;\n    float j = 0.0;\n    for( int s=0; s<4; s++ ) \n    {\n        vec2 uv = vec2( float(s-2*(s\/2)), float(s\/2) );\n        \n        float i = dot(F, uv + c); \/\/ all quantities are ingeters (can take a round() for extra safety)\n        \n        float phi = 2.0*PI*fract(i*PHI);\n        float cosTheta = m - 2.0*i\/n;\n        float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n        \n        vec3 q = vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta );\n        float squaredDistance = dot(q-p, q-p);\n        if (squaredDistance < d) \n        {\n            d = squaredDistance;\n            j = i;\n        }\n    }\n    return vec2( j, sqrt(d) );\n}\n\n\n\/\/=================================================================================================\n\/\/ iq code starts here\n\/\/=================================================================================================\n\nfloat hash1( float n ) { return fract(sin(n)*158.5453123); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) \/ iResolution.y;\n\n     \/\/ camera movement\t\n\tfloat an = 0.5*iGlobalTime;\n\tvec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 1.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    \/\/ sphere center\t\n\tvec3 sc = vec3(0.0,1.0,0.0);\n    \n    vec3 col = vec3(1.0);\n\n    \/\/ raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tfloat occ = 1.0;\n\tvec3  pos = vec3(0.0);\n\t\n\t\/\/ raytrace-plane\n\tfloat h = (0.0-ro.y)\/rd.y;\n\tif( h>0.0 ) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.0,1.0,0.0); \n\t\tpos = ro + h*rd;\n\t\tvec3 di = sc - pos;\n\t\tfloat l = length(di);\n\t\tocc = 1.0 - dot(nor,di\/l)*1.0*1.0\/(l*l); \n        col = vec3(1.0);\n\t}\n\n\t\/\/ raytrace-sphere\n\tvec3  ce = ro - sc;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - 1.0;\n\th = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\th = -b - sqrt(h);\n\t\tif( h<tmin ) \n\t\t{ \n\t\t\ttmin=h; \n\t\t\tnor = normalize(ro+h*rd-sc); \n\t\t\tocc = 0.5 + 0.5*nor.y;\n\t\t}\n        \n        const float precis = 150.0;\n        vec2 fi = inverseSF(nor, precis);\n        col = 0.5 + 0.5*sin( hash1(fi.x*13.0)*3.0 + 1.0 + vec3(0.0,1.0,1.0));\n        col *= smoothstep(0.02, 0.03, fi.y);\n        col *= mix( 1.0, 1.0 - smoothstep(0.12, 0.125, fi.y), smoothstep(-0.1,0.1,sin(iGlobalTime) )) ;\n        col *= 1.0 + 0.1*sin(250.0*fi.y);\n        col *= 1.5;\n\t}\n\n\tif( tmin<100.0 )\n\t{\n\t    pos = ro + tmin*rd;\n\t\tcol *= occ;\n\t\tcol = mix( col, vec3(1.0), 1.0-exp( -0.003*tmin*tmin ) );\n\t}\n\t\n\tcol = sqrt( col );\n\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}