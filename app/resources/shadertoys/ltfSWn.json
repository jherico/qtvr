{"Shader":{"ver":"0.1","info":{"id":"ltfSWn","date":"1360571561","viewed":1872,"name":"Mandelbulb - derivative","username":"iq","description":"A Mandelbulb implementation. Two tricks worth noting: [1] it doesn't use pow() functions to compute complex number powers, but it uses algebra instead.  [2] the distance estimator (DE) is analytic, not based on numerically computed gradient.  ","likes":2,"published":3,"flags":0,"tags":["3d","raymarching","fractal","distancefield"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ The source code for these videos from 2009: \n\/\/ https:\/\/www.youtube.com\/watch?v=eKUh4nkmQbc\n\/\/ https:\/\/www.youtube.com\/watch?v=erS6SKqtXLY\n\n\/\/ More info here: http:\/\/iquilezles.org\/www\/articles\/mandelbulb\/mandelbulb.htm\n\n\/\/ See https:\/\/www.shadertoy.com\/view\/MdfGRr to see the Julia counterpart\n\nbool isphere( in vec4 sph, in vec3 ro, in vec3 rd, out vec2 t )\n{\n    vec3 oc = ro - sph.xyz;\n    \n\tfloat b = dot(oc,rd);\n\tfloat c = dot(oc,oc) - sph.w*sph.w;\n    float h = b*b - c;\n    \n    if( h<0.0 ) return false;\n\n    h = sqrt( h );\n\n    t = -b + vec2(-h,h);\n    return true;\n}\n\nfloat map( in vec3 p, out vec4 resColor )\n{\n    vec3 zz = p;\n    float m = dot(zz,zz);\n\n    vec4 trap = vec4(abs(zz.xyz),m);\n\tfloat dz = 1.0;\n    \n    \n\tfor( int i=0; i<4; i++ )\n    {\n#if 1\n        float m2 = m*m;\n        float m4 = m2*m2;\n\t\tdz = 8.0*sqrt(m4*m2*m)*dz + 1.0;\n\n        float x = zz.x; float x2 = x*x; float x4 = x2*x2;\n        float y = zz.y; float y2 = y*y; float y4 = y2*y2;\n        float z = zz.z; float z2 = z*z; float z4 = z2*z2;\n\n        float k3 = x2 + z2;\n        float k2 = inversesqrt( k3*k3*k3*k3*k3*k3*k3 );\n        float k1 = x4 + y4 + z4 - 6.0*y2*z2 - 6.0*x2*y2 + 2.0*z2*x2;\n        float k4 = x2 - y2 + z2;\n\n        zz.x = p.x +  64.0*x*y*z*(x2-z2)*k4*(x4-6.0*x2*z2+z4)*k1*k2;\n        zz.y = p.y + -16.0*y2*k3*k4*k4 + k1*k1;\n        zz.z = p.z +  -8.0*y*k4*(x4*x4 - 28.0*x4*x2*z2 + 70.0*x4*z4 - 28.0*x2*z2*z4 + z4*z4)*k1*k2;\n#else\n\t\tdz = 8.0*pow(m,3.5)*dz + 1.0;\n        \n        float r = length(zz);\n        float b = 8.0*acos( clamp(zz.y\/r, -1.0, 1.0));\n        float a = 8.0*atan( zz.x, zz.z );\n        zz = p + pow(r,8.0) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );\n#endif        \n        \n        trap = min( trap, vec4(abs(zz.xyz),m) );\n\n        m = dot(zz,zz);\n\t\tif( m > 1000.0 )\n            break;\n    }\n    trap.x = m;\n    resColor = trap;\n\n    return 0.25*log(m)*sqrt(m)\/dz;\n}\n\nfloat intersect( in vec3 ro, in vec3 rd, out vec4 rescol, float fov )\n{\n    float res = -1.0;\n\n    \/\/ bounding volume\n    vec2 dis;\n    if( !isphere( vec4( 0.0, 0.0, 0.0, 1.25 ), ro, rd, dis ) )\n        return -1.0;\n    if( dis.y<0.0 ) \n        return -1.0;\n    if( dis.x<0.0 )dis.x = 0.0;\n    dis.x = max( dis.x, 0.0 );\n    dis.y = min( dis.y, 100.0 );\n\n\tvec4 trap;\n\n\tfloat fovfactor = 1.0\/sqrt(1.0+fov*fov);\n\n    float surface = 0.0;\n\tfloat t = dis.x;\n\tfor( int i=0; i<128; i++  )\n    { \n        vec3 p = ro + rd*t;\n\n        surface = clamp( 0.002*t*fovfactor, 0.0002, 1.0 );\n\n\t\tfloat dt = map( p, trap );\n\t\tif( t>dis.y || dt<surface ) break;\n\n        t += dt;\n    }\n    \n    \n    if( t<dis.y )\n    {\n        rescol = trap;\n        res = t;\n    }\n\n    return res;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<64; i++ )\n    {\n        vec4 kk;\n        float h = map(ro + rd*t, kk);\n        res = min( res, k*h\/t );\n        if( res<0.001 ) break;\n        t += clamp( h, 0.01, 0.2 );\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos, in float t, in float fovfactor )\n{\n    vec4 tmp;\n    float surface = clamp( 0.5 * 0.002*t*fovfactor, 0.0002, 1.0 );\n    vec2 eps = vec2( surface, 0.0 );\n\treturn normalize( vec3(\n           map(pos+eps.xyy,tmp) - map(pos-eps.xyy,tmp),\n           map(pos+eps.yxy,tmp) - map(pos-eps.yxy,tmp),\n           map(pos+eps.yyx,tmp) - map(pos-eps.yyx,tmp) ) );\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = -1.0 + 2.0*fragCoord.xy \/ iResolution.xy;\n\n\tvec2 s = xy*vec2(1.75,1.0);\n\n    float time = iGlobalTime*.15;\n\n\tvec3 light1 = vec3(  0.577, 0.577, -0.577 );\n\tvec3 light2 = vec3( -0.707, 0.000,  0.707 );\n\n\n\tfloat r = 1.3+0.1*cos(.29*time);\n\tvec3  ro = vec3( r*cos(.33*time), 0.8*r*sin(.37*time), r*sin(.31*time) );\n\tvec3  ta = vec3(0.0,0.1,0.0);\n\tfloat cr = 0.5*cos(0.1*time);\n\n    vec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n\tfloat fov = 1.5;\n\tvec3 rd = normalize( s.x*cu + s.y*cv + fov*cw );\n\n\tvec3 col;\n\tvec4 tra;\n    float t = intersect( ro, rd, tra, fov );\n    if( t<0.0 )\n    {\n     \tcol = 1.3*vec3(0.8,.95,1.0)*(0.7+0.3*rd.y);\n\t\tcol += vec3(0.8,0.7,0.5)*pow( clamp(dot(rd,light1),0.0,1.0), 32.0 );\n\t}\n\telse\n\t{\n\t\tvec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t, fov );\n        vec3 hal = normalize( light1-rd);\n        vec3 ref = reflect( rd, nor );\n        \n        col = vec3(1.0,1.0,1.0)*0.3;\n        col = mix( col, vec3(0.7,0.2,0.2), tra.w );\n\t\tcol = mix( col, vec3(1.0,0.5,0.2), sqrt(tra.y) );\n\t\tcol = mix( col, vec3(1.0,1.0,1.0), tra.z );\n        col *= 0.4;\n        \n        \n\t\tfloat dif1 = clamp( dot( light1, nor ), 0.0, 1.0 );\n\t\tfloat dif2 = clamp( 0.5 + 0.5*dot( light2, nor ), 0.0, 1.0 );\n        float occ = 0.05*log(tra.x);\n        float sha = softshadow( pos,light1, 0.0001, 32.0 );\n        float fre = 0.04 + 0.96*pow( clamp(1.0-dot(-rd,nor),0.0,1.0), 5.0 );\n        float spe = pow( clamp(dot(nor,hal),0.0,1.0), 12.0 ) * dif1 * fre*8.0;\n        \n\t\tvec3 lin  = 1.5*vec3(0.15,0.20,0.23)*(0.7+0.3*nor.y)*(0.2+0.8*occ);\n\t\t     lin += 3.5*vec3(1.00,0.90,0.60)*dif1*sha;\n\t\t     lin += 4.1*vec3(0.14,0.14,0.14)*dif2*occ;\n             lin += 2.0*vec3(1.00,1.00,1.00)*spe*sha * occ;\n             lin += 2.0*vec3(0.20,0.30,0.40)*(0.02+0.98*occ);\n             \/\/lin += 2.0*vec3(0.8,0.9,1.0)*smoothstep( 0.0, 1.0, ref.y )*occ;\n\t\tcol *= lin;\n        col += spe*1.0*occ*sha;\n    }\n\n\tcol = sqrt( col );\n\n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}