{"Shader":{"ver":"0.1","info":{"id":"XsVGzm","date":"1453953874","viewed":160,"name":"Elephant Ear Plants","username":"hsiangyun","description":"try to model elephant ear plants...","likes":9,"published":3,"flags":0,"tags":["raymarching","distancefield","leaf"],"hasliked":0},"renderpass":[{"inputs":[{"id":46,"src":"\/presets\/tex18.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Hsiang Yun 2016 \n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ This shader is inspired by the leaf in https:\/\/www.shadertoy.com\/view\/ld3Gz2  (iq's Snail)\n\n\n\/***************************\n\t\tUtility\n****************************\/\n\nfloat rand(float id){\n    return fract(sin(id * 37.0) * 43758.5453);\n}\n\nfloat smin( float a, float b, float k )\n{\n  \tfloat h = clamp( 0.5+0.5*(b-a)\/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax ( float a, float b, float k )\n{\n    return -smin(-a,-b, k);\n}\n\nfloat sub ( float a , float b )\n{\n    return smax(-b, a, 0.10);\n}\nvec2 rot ( vec2 p, float a ) \n{\n    a = radians(a);\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(vec2(c, s), vec2( -s, c )) * p; \n}\n\n\/\/ http:\/\/research.microsoft.com\/en-us\/um\/people\/hoppe\/ravg.pdf\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec3 getClosest( vec2 b0, vec2 b1, vec2 b2 ) \n{\n    float a =     det(b0,b2);\n    float b = 2.0*det(b1,b0);\n    float d = 2.0*det(b2,b1);\n    float f = b*d - a*a;\n    vec2  d21 = b2-b1;\n    vec2  d10 = b1-b0;\n    vec2  d20 = b2-b0;\n    vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n    vec2  pp = -f*gf\/dot(gf,gf);\n    vec2  d0p = b0-pp;\n    float ap = det(d0p,d20);\n    float bp = 2.0*det(d10,d0p);\n    float t = clamp( (ap+bp)\/(2.0*a+b+d), 0.0 ,1.0 );\n    return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\n\nvec4 sdBezier( vec3 a, vec3 b, vec3 c, vec3 p )\n{\n\tvec3 w = normalize( cross( c-b, a-b ) );\n\tvec3 u = normalize( c-b );\n\tvec3 v = normalize( cross( w, u ) );\n\n\tvec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n\tvec2 b2 = vec2( 0.0 );\n\tvec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n\tvec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n\tvec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy );\n\n\treturn vec4( sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z), cp.z, length(cp.xy), p3.z );\n}\n\nfloat sdEllipse( vec2 p, vec2 r ) \n{\n    return ( length(p\/r) - 1.0 ) * min(r.x,r.y);\n}\n\n\/***************************\n\t\tGlobal\n****************************\/\n#define INF 1.0e38\nstruct Hit\n{\n    float d;\n    float mID;\n    vec3 diff;\n    float thickness;\n};\n\nfloat leafID;\nvec3 darkgreen = vec3 ( 0.2,0.8,0.05) *0.02;\nvec3 yellow = vec3 ( 0.8,0.8,0.2)*0.04;\nvec3 leafClr()\n{\n    if ( leafID < 0.5 )\n        return darkgreen;\n    else if (leafID < 1.5 )\n        return darkgreen.yxz;\n    else if (leafID < 2.5 )\n        return darkgreen.zxy;\n    return yellow;\n}\nvec3 edgeClr()\n{\n    return yellow;\n}\n\n\/***************************\n\tAlocasia Modeling\n****************************\/\nvec2 sdVeins ( in vec3 p, in float rot_a, vec2 w, vec3 range, vec2 yoff, vec2 cnt_) \n{\n    float cntR = cnt_.x;\n    float cntL = cnt_.y;\n    float cnt = (p.x> 0.0) ? cntR : cntL;\n    float yoffsetR = yoff.x;\n    float yoffsetL = yoff.y;\n    float w2 = 0.01;\n    vec3 q = p ;\n    \/\/ stem \n    float dStem = abs(p.x) - w.x;\n    \/\/ offset & mirror\n    p.y += ( p.x > 0.0 ) ? yoffsetR : yoffsetL;\n    p.x = abs(p.x);    \n    q.x = abs(q.x);\n    \/\/ rotate\n    p.xy = rot ( p.xy, rot_a);\n    q.xy = rot ( q.xy, rot_a);\n    \/\/ repeat\n    p.y = sin (cnt* p.y) \/ cnt;\n    \n    float dVeins = abs(p.y) - 0.0005;\n    float dVeinRange = abs ( q.y + range.x  ) - range.y ;\n    \/\/ intersetion with range\n    dVeins = max ( dVeins, dVeinRange  ) ;\n    dVeins = smin ( dVeins, dStem, 0.01);\n    return vec2(dVeins, w.y);\n}\n\n\nHit sdLeaf ( in vec3 p, float rbias ) \n{\n    vec3 q = p;\n    float a = atan ( p.y, p.x ) ;\n    \n    \/\/ sharpen the heart shape\n    p.x = 1.1 * p.x * exp( -0.4*((p.y)));\n    float r = 1.0 - sin ( a ) ;  r += rbias;\n    \n    \/\/ veins \n  \tvec2 dVeins = sdVeins( p,28.0,  vec2(0.02,0.01), vec3(0.75,0.55,0.0), vec2(0.4,0.43), vec2(15.0,15.0));\n    vec3 p1 = p;\n    p1.x = abs(p1.x);\n    p1.y +=0.4;\n    p1.xy = rot(p1.xy,-110.0);\n    vec2 dVeins2 = sdVeins (p1, 42.0, vec2(0.005,0.01),vec3(0.8,0.7,0.1), vec2(0.0,0.03), vec2(20.0,15.0) );\n\n    vec3 p0 = p; \n    p.z += (1.0-smoothstep ( 0.0, 0.1, dVeins.x)) * 0.01; \n    p.z += (1.0-smoothstep ( 0.0, 0.05, dVeins2.x)) * 0.0025; \n   \n    \/\/ domain operation  \n    float dheart = length ( p ) -r ;\n    float mID = (p.z > 0.0) ? 1.5 : 0.5;\n    float dslab = abs(p.z) - 0.02;\n    float dhole = sdEllipse ( q.xy + vec2(0,-0.3), vec2(0.05,0.4));\n    float d = dheart ;\n    d = smax( d, dslab, 0.4);\n    d = sub ( d, dhole);   \n      \n    \/\/ vein material\n    float mVein1 = (1.0-smoothstep ( 0.0, dVeins.y, dVeins.x));\n    float mVein2 = (1.0-smoothstep ( 0.0, dVeins2.y, dVeins2.x));\n    float mVein = max ( mVein1, mVein2);\n   \t\/\/ leaf material \n    vec3 mat = mix( leafClr(), edgeClr() , smoothstep(-0.5 ,0.0, dheart )) ;\n    \/\/ final material  \n    mat += yellow * mVein * (1.0-smoothstep(-1.0,-0.25, dheart));\n    \n    \/\/ material stuff\n    Hit hit;\n    hit.d = d;\n    hit.mID = mID;\n    hit.diff = (mID > 1.0 ) ? mat :  mix( mix(edgeClr()*5.0,leafClr()*5.0,0.7), leafClr()*5.0 , smoothstep(-0.9 ,0.0, dheart ));;\n    hit.thickness = mVein * (1.0-clamp(smoothstep(-1.0,-0.35, dheart),0.0,1.0));\n \treturn hit;\n}\n\nHit sdDistortLeaf ( vec3 p ) \n{\n    \/\/ scale \n    p *= 0.45;\n    \/\/ bias\n    p.y -= 0.4;\n    p.z -= length(p.xy) *0.3 ;\n    p.z += 0.1;\n    \/\/ z vibration around the edge\n    vec3 q = p;\n    if ( q.x < 0.0 ) q.y-= 0.2;\n    q.x = abs(p.x);\n    float w = smoothstep(0.3,1.0, -q.y ) ; \n    q.xy = rot (q.xy, 30.0);\n    p.z += w * 0.1* sin(30.0*q.y*(1.0+q.y))* abs(p.x*p.x*p.x*q.x);\n  \n    \/\/ r vibration \n    vec3 v = q - vec3(0.0,-0.6,0.0);\n    float a2 = atan ( v.y, v.x);\n    float rbias = 0.04 * cos ( 22.0*a2);\n    \/\/ alocasia shape \n    return sdLeaf( p, rbias)   ;    \n}\n\nHit sdStem ( in vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    float d = sdBezier( a, b, c, p ).x;\n    d = abs(d) - mix(0.08, 0.1, clamp(-p.y,0.0,1.0));\n\tHit hit;\n    hit.d = d ;\n    hit.mID = 2.5;\n    vec3 yellow = vec3 ( 0.8,0.8,0.2)*0.08;\n    hit.diff = yellow ;\n    hit.thickness = 1.0;\n    return hit;\n}\n\nHit sdAlocasia( in vec3 p, vec3 a, vec3 b, vec3 c, float leaf_rot )\n{\n    \/\/ translate the leaf to the top of the stem\n    vec3 offset =  a ;\n    vec3 q = p ;\n   \tq = q - offset; \n    q.yz = rot (q.yz, leaf_rot) ;\n    \n    Hit hitA = sdDistortLeaf ( q  ) ; \n    Hit hitB = sdStem ( p, a, b,c ) ;\n    Hit hit = hitA;\n    if ( hitB.d < 0.0001 ) hit = hitB;\n    hit.d = min ( hitA.d, hitB.d ) ;\n    return hit;\n}\n\nHit sdGround ( in vec3 p)\n{\n    Hit hit;\n    hit.d = p.y - 0.3;\n    hit.mID = 1.5;\n    hit.diff = texture2D ( iChannel0 ,p.xz*0.05).xyz*0.2;\n    hit.thickness = 1.0;\n    return hit;\n}\n\nHit sdScene ( in vec3 p )\n{\n    Hit h_grnd = sdGround ( p ) ;\n    \n    leafID = 0.0;    \n    if ( p.z > 0.0 )\n    {\n        p *= 0.9;\n        leafID = 0.0;\n        if (p.x > 0.0 )\n        {\n            leafID = 1.0;\n        }\n    }\n    else\n    {\n        leafID = 2.0;\n        if (p.x > 0.0 )\n        {\n            p *= 0.85;\n            leafID = 3.0;\n        }\n    }\n    float heightBais = rand( leafID + 5.0 ) * 4.0;\n    float sideBias = rand( leafID + 1.0 )* 1.5 +2.5; \n    vec3 a = vec3(0.0, 4.0+heightBais,sideBias);\n    vec3 b = vec3(0.0, 2.0+heightBais,sideBias * 0.1); \n    vec3 c = vec3(0.0, 0.0,0.0);    \n    p.x = abs(p.x);  \n\tp.z = abs(p.z);\n    p.xz = rot(p.xz, 40.0);\n    Hit h = sdAlocasia ( p, a, b, c, mix ( 30.0,40.0, rand(leafID))) ;\n    \n    \n    h.d = min ( h.d, h_grnd.d ) ;\n    if ( abs(h_grnd.d) < 0.001 )  return h_grnd;\n    return h;\n}\n\n\/***************************\n\t\trender\n****************************\/\n\nHit getMaterial( in vec3 p ) \n{\n    return sdScene ( p ); \n}\n\nfloat map( in vec3 p )\n{\n    return sdScene ( p ).d ;     \n}\n\nfloat raymarch( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 50.0;          \n\tconst float precis = 0.0001;      \n    float h = precis*2.0;\n    float t = 0.00;\n\tfloat res = INF;\n    for( int i=0; i<90; i++ )         \n    {\n        if( h<precis||t>maxd ) break;\n\t    h = map( ro+rd*t );\n        t += h;\n    }\n    if( t<maxd ) res = t;\n    return res;\n}\n\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.001;            \n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\treturn normalize( v1*map( pos + v1*eps ) + \n\t\t\t\t\t  v2*map( pos + v2*eps ) + \n\t\t\t\t\t  v3*map( pos + v3*eps ) + \n\t\t\t\t\t  v4*map( pos + v4*eps ) );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0001;                 \n\tfloat h = 1.0;\n    for( int i=0; i<20; i++ )         \n    {\n        h = map(ro + rd*t);\n        res = min( res, 32.0*h\/t );   \n\t\tt += clamp( h, 0.02, 2.0 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 getLightPos()\n{\n    float t = iGlobalTime;\n    return vec3(5.0*sin(t)*1.0,15.0+ 0.1*sin(t),cos(t)*5.0);\n}\n\nvec3 doLighting( in vec3 pos, in vec3 nml, in vec3 rd, in float dis, in Hit hit )\n{\n    vec3 lin = vec3(0.0);\n    \/\/ ambient \n    lin += vec3(0.5);  \n    \/\/ lighting factors\n    vec3 ldir = normalize( getLightPos());    \n    vec3 hal = normalize( ldir -rd );\n    float fre = clamp(1.0+dot(nml,rd), 0.0, 1.0 );\n    float ndl = dot( nml, ldir ) ;\n    float dif = max(ndl,0.0);\n    float spe1 = clamp( dot(nml,hal), 0.0, 3.0 );\n    \/\/ shadow \n    float sha = 0.0; \n    if( dif>0.01 ) sha= softshadow( pos+0.01*nml, ldir );\n    \/\/ simple lighiting\n    lin += pow( spe1, 1.0  + 5.0) * vec3(0.0);\n    lin += pow( fre,3.0) * dif * vec3(15.0) ;   \n    lin += dif * vec3(7.00)*sha;\n    \n    vec3 col = vec3(0.0);\n    col = hit.diff*lin;\n    \n    \/\/ leaf backface lighting \n    \/\/ http:\/\/http.developer.nvidia.com\/GPUGems3\/gpugems3_ch16.html\n    if (hit.mID < 1.0)\n    {       \n\t    float edl = clamp(dot (rd, ldir), 0.0, 1.0);\n\t    edl *= edl;     \n    \tlin +=  mix ( edl, -ndl, 0.1) *10.0* (1.0-hit.thickness);\n       \tcol = hit.diff * lin;\n    }\n    \/\/ fog\n\tcol *= exp(-0.01*dis*dis);\n\n    return col;\n}\n\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)\/iResolution.y;\n    vec2 m = iMouse.xy\/iResolution.xy;\n    \/\/ camera \n    vec3 ro, ta;\n    float an = 0.3*iGlobalTime + 5.0*m.x;\n    float r = 10.0;\n\tro = vec3(r*sin(an), 3.0 +3.0* m.y,r*cos(an));\n    ta = vec3(0.0,6.0,0.0);    \n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  \n\tvec3 rd = normalize( camMat * vec3(p.xy,1.0) ); \n    \n\tvec3 col = vec3 (0.0);\n\t\/\/ raymarch\n    float d  = raymarch( ro, rd );\n    if( d != INF )\n    {\n        float t = d;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n        col = doLighting( pos, nor, rd, t,  getMaterial ( pos ) );        \n\t}\n    \/\/ sprite\n    vec3 ldir = normalize(getLightPos());\n    float lsprite =  clamp(pow (dot ( normalize(getLightPos()- ro), rd )*0.5+0.5, 128.0),0.0, 10.0);\n    lsprite = smoothstep(0.98,1.0, lsprite);\n\tcol += lsprite* lsprite;\n\n    \/\/ gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\t   \n    fragColor = vec4( col, 1.0 );\n}\n","name":"","description":"","type":"image"}]}}