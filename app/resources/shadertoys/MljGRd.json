{"Shader":{"ver":"0.1","info":{"id":"MljGRd","date":"1431819828","viewed":9834,"name":"Earthbound Battle Scene VR","username":"RavenWorks","description":"<a href=\"https:\/\/www.shadertoy.com\/view\/MtsXRX\"  class=\"regular\" target=\"_blank\">Check out the expanded version by clicking HERE!<\/a>","likes":22,"published":3,"flags":9,"tags":["retro","snes","earthbound","rpg"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"vec3 diamondShine(float i){\n    float shine = abs(mod(i,2.0)-1.0);\n    shine *= 7.0;\n    return vec2(32.0+shine*24.0,4.0+shine*20.0).xxy\/255.0;\n}\n\nvec3 bgTexture(vec2 tileCoord)\n{\n\t\n    tileCoord.y += iGlobalTime*0.1;\n    tileCoord.y += pow(sin(tileCoord.y+iGlobalTime*0.75),2.0);\n    \n    vec2 withinTile = mod(tileCoord,1.0);\n    vec2 tileStep = floor(tileCoord);\n    \n    bool inDiamond = (abs(withinTile.x-0.5) + abs(withinTile.y-0.5)) < 0.5;\n    \n    vec3 color;\n    if (inDiamond) {\n        return diamondShine( tileStep.x*1.1 + tileStep.y*1.6 + iGlobalTime*0.5 );\n    } else {\n        return vec3(80.0\/255.0,96.0\/255.0,72.0\/255.0);\n    }\n\t\n}\n\n\n\n\n\n\n\n\n\n\nconst float PI =3.141592;\nconst float PI2=6.2831853;\n\n\n\n\nfloat smooth( float a, float b, float k ){\n    float h = clamp(0.5+0.5*(b-a)\/k,0.0,1.0);\n    return mix(b,a,h) - k*h*(1.0-h);\n}\n\nvoid hardAdd(inout int curMaterial, inout float curD, int newMaterial, float newD){\n    if (newD < curD) {\n        curD = newD;\n        curMaterial = newMaterial;\n    }\n}\nvoid hardSubtract(inout float curD, float newD) {\n    curD = max( -newD, curD );\n}\nvoid smoothAdd(inout float curD, float newD, float blendPower){\/\/blend colors too?\n    curD = smooth( newD, curD, blendPower );\n}\nvoid smoothSubtract(inout float curD, float newD, float blendPower){\n    curD = -smooth( newD , -curD , blendPower );\n}\n\n\nfloat obj_ball(vec3 p, vec3 center, float radius){\n    return length(p-center)-radius;\n}\nfloat obj_cylinder(vec3 p, vec3 center, vec2 size, float roundness){\n    vec3 tp = p-center;\n    vec2 d = abs(vec2(length(tp.yz),tp.x)) - (size-roundness);\n    return min(max(d.x,d.y)+roundness,0.0) + length(max(d,0.0))-roundness;\n}\nfloat obj_cylForever(vec2 p, vec2 middle, float radius){\n    return abs(length(p-middle)) - radius;\n}\nfloat obj_planeY(vec3 p, float planeY){\n    return p.y-planeY;\n}\nfloat obj_roundline( vec3 p, vec3 a, vec3 b, float r ){\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nfloat obj_box(vec3 p, vec3 center, vec3 size, float roundness){\n    vec3 d = abs(p-center) - (size-roundness);\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - roundness;\n}\nfloat obj_torus( vec3 p, vec3 center, vec2 t ){\n    vec3 tp = p-center;\n\tvec2 q = vec2(length(tp.xy)-t.x,tp.z);\n\treturn length(q)-t.y;\n}\nfloat obj_quartertorus( vec3 p, vec3 center, vec2 t ){\n    vec3 tp = p-center;\n    tp.x = max(tp.x,0.0);\n    tp.y = max(tp.y,0.0);\n    \/\/ okay that honestly isn't what I set out to make, but it saves me several other shapes..!\n\tvec2 q = vec2(length(tp.xy)-t.x,tp.z);\n\treturn length(q)-t.y;\n}\n\n\nconst float bgDist = 10.0;\nconst float statusDist = -0.75;\nconst float statusHeight = 0.85;\nconst float enemyDist = -2.0;\nconst float enemyHeight = 1.0;\nconst float enemyOffX = 0.6;\n\nfloat sceneDistance(vec3 p, inout int material){\n    \n    float distance = 9999.9;\n    material = 0;\n    \n    \n    \n    hardAdd(material,distance,1,\n    \t-obj_cylForever(p.xz, vec2(0.0),bgDist)\n    );\n    \n    \n    const float outlineRad = 0.02;\n    float healthModX = 0.35;\n    vec2 healthSize = vec2(0.25,0.35)\/2.0;\n    if (abs(p.x)<healthModX*2.0) {\n        \n        vec3 healthP = p;\n        healthP.y -= statusHeight;\n        \n        healthP.x = mod(healthP.x,healthModX);\n        healthP.x -= healthModX\/2.0;\n        \n        vec3 healthFrameP = healthP;\n        healthFrameP.y = abs(healthFrameP.y);\n        healthFrameP.x = abs(healthFrameP.x);\n        \n        \n        const float boxThickness = 0.03;\n        hardAdd(material,distance,3,\n\t\t\tobj_box(healthFrameP,vec3(0.0,0.0,statusDist-boxThickness+0.01),vec3(healthSize.xy,boxThickness),0.0)\n\t\t);\n        \n        const float healthInset = 0.01;\n        smoothSubtract(distance,\n            obj_box(healthP,vec3(0.05,-0.1,statusDist),vec3(0.075,0.125,healthInset),0.0),\n        \t0.01\n        );\n\n        \n        hardAdd(material,distance,2,\n            obj_quartertorus(healthFrameP,vec3(healthSize.xy,statusDist),vec2(outlineRad,outlineRad-0.001))\n        );\n        \n        \n        \n        vec3 wheelP = healthP;\n        wheelP.x -= 0.05;\n        wheelP.x = abs(wheelP.x);\n\n\n        wheelP.y += 0.075;\n        wheelP.y = abs(wheelP.y);\n\n        hardAdd(material,distance,2,\n        \tobj_cylinder(wheelP,vec3(0.0,0.05,statusDist-healthInset),vec2(0.05,0.025),0.0075)\n        );\n        hardAdd(material,distance,2,\n        \tobj_cylinder(wheelP,vec3(0.05,0.05,statusDist-healthInset),vec2(0.05,0.025),0.0075)\n        );\n\n    }\n    \n    vec3 statusP = p;\n    statusP.y -= statusHeight+1.0;\n    statusP.y = abs(statusP.y);\n    \n    statusP.x += 0.25;\n    statusP.x = abs(statusP.x);\n    \n    hardAdd(material,distance,2,\n    \tobj_quartertorus(statusP,vec3(0.4,0.1,statusDist),vec2(0.02,0.01))\n    );\n    hardAdd(material,distance,4,\n    \tobj_box(statusP,vec3(0.0,0.0,statusDist-0.005),vec3(0.41,0.12,0.01),0.0)\n    );\n    \n    \n    \n    \n    float ufoHeight = enemyHeight+sin(iGlobalTime*2.5)*0.02;\n    \n    vec3 ufoRotP = p;\n    \n    vec3 ufoBodyP = ufoRotP;\n    ufoBodyP.y -= ufoHeight+0.3;\n    ufoBodyP.y = abs(ufoBodyP.y);\n    \n    hardAdd(material,distance,5,\n\t\tobj_ball(ufoBodyP,vec3(-enemyOffX,-1.0,enemyDist),1.1)\n\t);\n    smoothAdd(distance,\n\t\tobj_ball(ufoBodyP,vec3(-enemyOffX,0.03,enemyDist),0.2),\n    0.1);\n    \n    vec3 ufoEyeP = ufoRotP;\n    ufoEyeP.x -= -enemyOffX+0.05;\n    ufoEyeP.x = abs(ufoEyeP.x);\n    \n    hardAdd(material,distance,6,\n\t\tobj_ball(ufoEyeP,vec3(0.045,ufoHeight+0.41,enemyDist+0.25),0.025)\n\t);\n    \n    \n    \n    \n    const float foppyWidth = 0.1;\n    float foppyBob = pow(1.0-(sin(iGlobalTime*4.0)*0.5+0.5),1.1);\n    float foppyHeight = enemyHeight+0.3 + foppyBob*0.03;\n    hardAdd(material,distance,7,\n    \tobj_ball(p,vec3(enemyOffX+foppyWidth,foppyHeight,enemyDist),0.2)\n\t);\n    smoothAdd(distance,\n    \tobj_ball(p,vec3(enemyOffX-foppyWidth,foppyHeight,enemyDist),0.2),\n\t0.3);\n    \n    float legOff = 0.25 - foppyBob*0.02;\n    float legSize = 0.09 - foppyBob*0.01;\n    hardAdd(material,distance,7,\n    \tobj_ball(p,vec3(enemyOffX-legOff,enemyHeight+0.1,enemyDist+0.2),legSize)\n\t);\n    hardAdd(material,distance,7,\n    \tobj_ball(p,vec3(enemyOffX+legOff,enemyHeight+0.08,enemyDist-0.1),legSize)\n\t);\n    \n    \n    vec3 foppyEyeP = p;\n    foppyEyeP.x -= enemyOffX-0.05;\n    foppyEyeP.x = abs(foppyEyeP.x);\n    \n    hardAdd(material,distance,8,\n    \tobj_ball(foppyEyeP,vec3(0.1,foppyHeight+0.07,enemyDist+0.26),0.015)\n\t);\n    \n    \n    \n    return distance;\n    \n}\n\n\n\n\nconst vec3 e=vec3(0.00007,0,0);\nconst float maxd=256.0; \/\/Max depth\nfloat nearestD = maxd;\nvec3 color;\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ) {\n    \n    \n    \n    vec3 scrCoord = fragRayOri;\n    vec3 curCameraRayUnit = fragRayDir;\n    \n    \n    color = vec3(0.0);\n    \n    \n    scrCoord.y += 1.5;\n    \n    \n    \n    \n    \n    vec3 p = scrCoord;\n\n    float f=0.0;\n    float d=0.01;\n    int mat, dummyMat;\n    for(int i=0;i<64;i++){\n        if ((abs(d) < .001) || (f > maxd)) break;\n        f+=d;\n        p=scrCoord + curCameraRayUnit*f;\n        d = sceneDistance(p,mat);\n    }\n    \n    if (f < nearestD) {\n\n        nearestD = f;\n        \n        vec3 n = normalize(vec3(d-sceneDistance(p-e.xyy,dummyMat),\n                                d-sceneDistance(p-e.yxy,dummyMat),\n                                d-sceneDistance(p-e.yyx,dummyMat)));\n        \n        \n        \n        vec3 lightDir = normalize(vec3(0.0,0.25,1.0));\n        float specP = 1.0;\n        float specA = 0.0;\n        \n        float diffMin = 0.0;\n        \n        \/\/ BG\n        if (mat == 1) {\n            color = bgTexture(vec2(atan(p.x,p.z)\/PI2*32.0,p.y\/bgDist*4.0));\n            color *= 1.0-pow(min((abs(p.y)\/30.0),1.0),2.0);\/\/1.0- should be inside, but it looks cooler this way~\n            \n        \/\/frame outline\n        } else if (mat == 2) {\n            color = vec3(1.0);\n            \n        \/\/health pattern\n        } else if (mat == 3) {\n            const float checkerSize = 0.05;\n            if ( (mod(p.x,checkerSize)<checkerSize*0.5) == (mod(p.y,checkerSize)<checkerSize*0.5) ) {\n                color = vec3(144.0\/255.0,128.0\/255.0,168.0\/255.0);\n            } else {\n                color = vec3(144.0\/255.0,144.0\/255.0,232.0\/255.0);\n            }\n            \n        \/\/status pattern\n        } else if (mat == 4) {\n            color = vec3(0.0);\n            \n        \/\/UFO skin\n        } else if (mat == 5) {\n            color = vec3(0.7);\n            specA = 1.0;\n            specP = 6.0;\n            lightDir = normalize(vec3(0.25,0.5,1.0));\n            \n        \/\/UFO eyes\n        } else if (mat == 6) {\n            color = vec3(0.2);\n            specA = 0.65;\n            specP = 16.0;\n            lightDir = normalize(vec3(0.25,0.5,1.0));\n            \n        \/\/Foppy skin\n        } else if (mat == 7) {\n            \n            float normGap = pow(dot(-curCameraRayUnit,n),1.7);\n            color = mix(\n                vec3(144.0\/255.0,0.0,48.0\/255.0)*0.75,\n                vec3(240.0\/255.0,0.0,96.0\/255.0),\n            normGap);\n            \n            specA = 0.75;\n            specP = 12.0;\n            lightDir = normalize(vec3(1.0,1.0,0.0));\n            diffMin = 1.0;\n            \n            \n            \n            \n            \n        \/\/Foppy eyes\n        } else if (mat == 8) {\n            color = vec3(0.2);\n            specA = 0.3;\n            specP = 48.0;\n        }\n        \n        color *= dot(n,lightDir)*(1.0-diffMin)+diffMin;\n        \n        float specular = max(0.0,dot(normalize(lightDir-curCameraRayUnit),n));\n        color += pow(specular,specP)*specA;\n        \n        \n        \n        const float shadowPlane = enemyHeight;\n        float stepsToPlane = (shadowPlane-scrCoord.y)\/curCameraRayUnit.y;\n        vec3 planePt = scrCoord+curCameraRayUnit*stepsToPlane;\n        planePt.x = abs(planePt.x);\n        \n        if (planePt.z < 0.0 && planePt.z > -3.0 && planePt.z > p.z) {\n            float occlusion = length(planePt.xz-vec2(enemyOffX,enemyDist));\n            occlusion = pow(occlusion,0.5);\n            occlusion = max(0.0,min(1.0,(occlusion*1.7)));\n            occlusion = 0.3+occlusion*0.7;\n        \tcolor *= occlusion;\n        }\n        \n        \n        \n    }\n\n\n    \n    \n    \n    fragColor = vec4(color,1.0);\n    \n    \n}\n\n\nconst float transitionTime = 2.5;\nconst float fadeSpd = 1.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    \n    float introTime = iGlobalTime - 1.25;\n    \n    \n    if (introTime < transitionTime) {\n        \n        \n        float extent = min(iResolution.x,iResolution.y);\n        vec2 uv = fragCoord.xy \/ extent;\n        uv *= 2.0;\n        uv -= 1.0;\n        uv -= ((iResolution.xy\/extent)-1.0);\n        \n        uv.x *= 0.8;\n        \n        \n        vec3 color = vec3(0.35+sin(uv.x*16.0+uv.y*6.0)*0.15);\n        \n\n        float dist = length(uv);\n        dist = pow(dist,0.42);\n        float ang = atan(uv.y,uv.x);\n        float angFrac = ang\/(PI*2.0)+0.5;\n\n        const float stripeWidth = 0.15;\n\n        dist += angFrac*stripeWidth*2.0;\n\n        float stripeProgress = floor(dist\/stripeWidth)-angFrac*2.0;\n        \n        float swirlOff = introTime*10.0;\n        if (mod(dist,stripeWidth*2.0) < stripeWidth) swirlOff -= 1.5;\n        \n        float stripeLit = (stripeProgress-swirlOff)*16.0;\n        float greenVal = max(0.0,min(1.0,(0.8-stripeLit)));\n        \n        \n        float fadeOutAmt = pow(min(1.0,(transitionTime-introTime)*fadeSpd),2.0);\n        \n        \n        color *= vec3(1.0-greenVal,1.0,1.0-greenVal);\n        color *= fadeOutAmt;\n        \n        fragColor = vec4(color,1.0);\n        \n        \n        \n    } else {\n\n\n\n        vec3 cameraPos = vec3(0.0,0.06,0.75);\n\n        vec2 mouseFrac = iMouse.xy\/iResolution.xy;\n        mouseFrac -= 0.5;\n        mouseFrac *= 2.0;\n\n        if (iMouse.z != 0.0) {\n\n            cameraPos.x -= mouseFrac.x*0.75;\n            cameraPos.y -= mouseFrac.y*0.75;\n\n        } else {\n            \n            float waveTime = iGlobalTime - transitionTime - 2.0;\n            cameraPos.x += sin(waveTime*0.5)*0.4;\n            cameraPos.y += sin(waveTime*1.0)*-0.05;\n            \n        }\n        \n        \n        vec3 cameraFwd = normalize(vec3(0.0,-0.4,-2.0)-cameraPos);\n        vec3 cameraUp = vec3(0.0,1.0,0.0);\n        vec3 cameraRight = normalize(-cross(cameraUp,cameraFwd));\n        \n        \n        \n        \n        \/\/ all this stuff with working from FOVs is for the sake of WebVR compatibility,\n        \/\/ which is redundant for shadertoy, but handy for my personal site\n\n        float vertFov = 50.0;\n        float horizFov = 2.0*atan(tan((vertFov\/180.0*PI)\/2.0)*(iResolution.x\/iResolution.y))*180.0\/PI;\n        vec4 fovAngsMono = vec4(horizFov\/2.0, horizFov\/2.0, vertFov\/2.0, vertFov\/2.0);\n\n\n\n        vec2 fragFrac = fragCoord.xy\/iResolution.xy;\n\n        vec2 eyeRes = iResolution.xy;\n        vec4 fovAngs = fovAngsMono;\n\n        \n\n\n\n\n\n\n\n        float fovL = -fovAngs.x\/180.0*PI;\n        float fovR =  fovAngs.y\/180.0*PI;\n        float fovU = -fovAngs.z\/180.0*PI;\n        float fovD =  fovAngs.w\/180.0*PI;\n\n        float fovMiddleX = (fovR + fovL) * 0.5;\n        float fovMiddleY = (fovU + fovD) * 0.5;\n        float fovHalfX = (fovR - fovL) * 0.5;\n        float fovHalfY = (fovD - fovU) * 0.5;\n\n\n\n        float scrWorldHalfX = sin(fovHalfX)\/sin(PI*0.5 - fovHalfX);\n        float scrWorldHalfY = sin(fovHalfY)\/sin(PI*0.5 - fovHalfY);\n\n\n        \/\/ determine screen plane size from FOV values, then interpolate to find current pixel's world coord\n\n        vec2 vPos = fragFrac;\/\/0 to 1\n        vPos.x -= (-fovL\/(fovHalfX*2.0));\n        vPos.y -= (-fovU\/(fovHalfY*2.0));\n\n        vec3 screenPlaneCenter = cameraPos+cameraFwd;\n        vec3 scrCoord = screenPlaneCenter + vPos.x*cameraRight*scrWorldHalfX*2.0 + vPos.y*cameraUp*scrWorldHalfY*2.0;\n        vec3 curCameraRayUnit = normalize(scrCoord-cameraPos);\n\n\n\n        mainVR(fragColor,fragCoord,cameraPos,curCameraRayUnit);\n        \n        \n        \n        float fadeInAmt = min(1.0,(introTime-transitionTime)*fadeSpd);\n        fragColor.xyz *= pow(fadeInAmt,2.0);\n        \n\n    }\n    \n    \n}","name":"","description":"","type":"image"},{"inputs":[],"outputs":[{"channel":"0"}],"code":"\nvec2 pan(float panAmt){\n    return vec2(0.5-panAmt*0.5,0.5+panAmt*0.5);\n}\n\nfloat noteFreq(int note){\n    float oct = 1.0;\n    if (note >= 12) {\n        note -= 12;\n        oct = 2.0;\n    }\n    if (note < 0) {\n        note += 12;\n        oct = 0.5;\n    }\n    if (note ==  0) return oct*440.000;\n    if (note ==  1) return oct*466.164;\n    if (note ==  2) return oct*493.883;\n    if (note ==  3) return oct*523.251;\n    if (note ==  4) return oct*554.365;\n    if (note ==  5) return oct*587.330;\n    if (note ==  6) return oct*622.254;\n    if (note ==  7) return oct*659.255;\n    if (note ==  8) return oct*698.456;\n    if (note ==  9) return oct*739.989;\n    if (note == 10) return oct*391.995*2.0;\n    if (note == 11) return oct*415.305*2.0;\n    return 0.0;\n}\n\n\nfloat introHorn(int note, float time){\n    \n    float glissandoTime = time - 0.5;\n    if (glissandoTime < 0.0) {\n        glissandoTime = -pow(1.0-glissandoTime,1.0-glissandoTime*0.4);\n    } else {\n        glissandoTime = -(1.0-glissandoTime);\n    }\n    \n    float baseFreq = 6.2831*noteFreq(note)*glissandoTime*0.5;\n    \n    float mix = 0.0;\n    \n    mix += sin(baseFreq*1.0)*1.0;\n    mix += sin(baseFreq*2.0)*0.75;\n    mix += sin(baseFreq*3.0)*0.75;\n    mix += sin(baseFreq*4.0)*0.5;\n    mix += sin(baseFreq*5.0)*0.75;\n    mix += sin(baseFreq*6.0)*0.5;\n    \n    mix *= 0.25;\n    \n    return mix;\n    \n}\n\n\nconst float beatLength = 1.0\/7.5;\n\nfloat krakenSynth(int note, float time, float octave, float sawTweak){\n    \n    float baseFreq = noteFreq(note);\n    \n    float sinFreq = baseFreq*pow(2.0,octave+2.0);\n    float sawFreq = baseFreq*pow(2.0,octave-3.0-sawTweak);\n    \n    float sinWave = cos(6.2831*time*sinFreq);\n    float sawWave = 1.0-mod(time*sawFreq,1.0);\n    sawWave = pow(sawWave,8.0);\n    \n    return sawWave*sinWave - sawWave;\n    \n}\n\nfloat krakenLead(float songTime){\n    \n    float beatNum = songTime\/beatLength;\n    float beatStep = mod(floor(beatNum),32.0);\n    float barStep = floor(beatNum\/32.0);\n\n\n    if (mod(beatNum,1.0)<0.68){\n\n        float triplet = floor(beatStep\/3.0);\n        float withinTriplet = mod(beatStep,3.0);\n        if (beatStep >= 16.0) {\n            triplet = 5.0-floor((beatStep-16.0)\/3.0);\n            withinTriplet = mod(beatStep-16.0,3.0);\n        }\n        if (beatStep >= 29.0) {\n            withinTriplet++;\n        }\n\n\n\n        int curNote = 3;\n        if ((barStep > 0.0) && (mod(barStep,2.0)==0.0)) curNote += 4;\n\n        float octave = -triplet;\n        if (withinTriplet == 2.0) octave++;\n\n        return krakenSynth(curNote,mod(songTime,beatLength),octave,-triplet);\n\n    } else {\n        \n        return 0.0;\n        \n    }\n    \n}\n\n\nfloat bassSynth(int note, float time){\n    \n    const float noteLength = 0.5;\n    \n    if (time > noteLength) return 0.0;\n    \n    float baseFreq = 6.2831*time*noteFreq(note);\n    \n    float fadeIn = 1.0-pow(1.0-(time\/noteLength),32.0);\n    float fadeOut = 1.0-pow(time\/noteLength,8.0);\n    \n    return (\n        sin(baseFreq*pow(2.0,-6.0))*1.5 +\n        sin(baseFreq*pow(2.0,-5.0))*0.5 + \n        sin(baseFreq*pow(2.0,-4.0))*0.05\n    )*fadeIn*fadeOut;\n    \n}\n\nfloat krakenBass(float songTime){\n    \n    \/\/ this redundancy isn't great but whatev\n    float beatNum = songTime\/beatLength;\n    float beatStep = mod(floor(beatNum),8.0);\/\/DIFFERENT BAR LENGTH FOR BASSLINE\n    float barStep = mod(floor(beatNum\/8.0),4.0);\n    \n    if ( beatStep == 3.0 && barStep < 2.0) return 0.0;\n    if ( beatStep == 6.0 && barStep < 3.0) return 0.0;\n    if ( beatStep == 7.0 && barStep == 3.0) return 0.0;\n    \n    int bassNote = (mod(floor(beatNum\/32.0),2.0) == 0.0) ? 8 : 4 ;\n    \n    return bassSynth(bassNote, mod(beatNum,1.0));\n    \n}\n\n\nfloat wailSynth(int note, float time){\n    \n    const float noteEnd = 32.0;\n    const float noteStart = 4.0;\n    \n    float noteFrac = max(0.0,min(1.0,(time-noteStart)\/(noteEnd-noteStart)));\n    float fadeIn = pow(noteFrac,2.0);\n    float fadeOut = 1.0-(pow(noteFrac,2.0));\n    \n    float baseFreq = 6.2831*time*noteFreq(note)*0.25;\n    baseFreq += sin(time*4.5)*3.0;\n    \n    return (\n        sin(baseFreq)+\n        sin(baseFreq*3.0)+\n        sin(baseFreq*4.0)*0.75\n    )*fadeIn*fadeOut*0.5;\n    \n}\n\nfloat krakenWail(float songTime){\n    \n    float beatNum = songTime\/beatLength;\n    \n    int wailNote = (mod(floor(beatNum\/32.0),2.0) == 0.0) ? 2 : 3;\n    \n    return wailSynth(wailNote, mod(beatNum,32.0));\n    \n}\n\n\nfloat noise(float time){\n    return sin( time*200034.2666 * sin(time*600078.6576) );\n}\n\nfloat kick(float time) {\n    \n    float sinWave = sin(pow(time*1000.0,0.6));\n    \n    const float fadeInTime = 0.00015;\n    float fadeIn = max(0.0,min(1.0,(time\/fadeInTime)));\n    \n    const float fadeOutTime = 1.0;\n    float fadeOut = max(0.0,min(1.0,((fadeOutTime-time)\/fadeOutTime)));\n    \n    return sinWave*fadeIn*fadeOut;\n    \n}\n\nfloat snare(float time) {\n    \n    float sinWave = sin(pow(time*1000.0,0.7));\n    float sineFadeIn = max(0.0,min(1.0,(time\/0.00015)));\n    float sineFadeOut = max(0.0,min(1.0,(1.0-(time\/0.25))));\n    \n    float noiseWave = noise(time);\n    float noiseFadeIn = max(0.0,min(1.0,(time\/0.00015)));\n    float noiseFadeOut = max(0.0,min(1.0,(1.0-(time\/0.25))));\n    \n    return noiseWave*noiseFadeIn*noiseFadeOut*0.75 + sinWave*sineFadeIn*sineFadeOut*0.5;\n    \n}\n\nfloat hihatClosed(float time){\n    \n    float sinWaveA = sin(pow(time*8700.0,0.99));\n    float sinWaveB = sin(pow(time*7200.0,0.99));\n    float sineFadeIn = max(0.0,min(1.0,(time\/0.15)));\n    float sineFadeOut = max(0.0,min(1.0,(1.0-(time))));\n    \n    float noiseWave = noise(time);\n    float noiseFadeOut = max(0.0,min(1.0,(1.0-(time\/0.75))));\n    noiseFadeOut = pow(noiseFadeOut,2.0);\n    \n    return noiseWave*noiseFadeOut*0.5 + (sinWaveA+sinWaveB)*sineFadeIn*sineFadeOut*0.05;\n    \n}\n\nfloat hihatOpen(float time){\n    \n    float noiseVol;\n    float sineVolA;\n    float sineVolB;\n    \n    if (time < 0.125) {\n    \t\n        noiseVol = 2.0;\n        \n        sineVolA = 0.1;\n        sineVolB = 0.15;\n        \n    } else if (time < 1.0) {\n        \n        noiseVol = 0.6;\n        \n        sineVolA = 0.1;\n        sineVolB = 0.15;\n        \n    } else if (time < 2.0) {\n        \n        noiseVol = max(0.0,min(1.0,(2.0-(time*1.0))));\n        noiseVol = pow(1.0-noiseVol,1.0);\n        noiseVol *= 0.1;\n        \n        sineVolA = max(0.0,min(1.0,(2.0-(time*0.5))));\n        sineVolA = 1.0-pow(1.0-sineVolA,1.0);\n        sineVolA *= 0.0125;\n        \n        sineVolB = sineVolA*1.5;\n        \n    } else {\n        \n        return 0.0;\n        \n    }\n    \n    float mix = 0.0;\n    \n    mix += noise(time)*noiseVol;\n    \n    mix += sin(time*6300.0) * sineVolA;\n    mix += sin(time*7200.0) * sineVolB;\n    \n    return mix;\n    \n}\n\n\n\nvec2 mainSound(float time){\n    \n    \n    \n    const float introStartTime = 1.35;\n    const float introEndTime = 4.0;\n    \n    if (time < introStartTime) {\n        return vec2(0.0);\n    } else if (time < introEndTime) {\n        \n        float introTime = time - introStartTime;\n        \n        vec2 mix = vec2(0.0);\n        \n        const float numEchos = 3.0;\n        for(float i=0.0; i<numEchos; i++){\n            \n            float echoTime = introTime - i*0.03;\n            float echoVol = 1.0-(i\/numEchos);\n            \n            const float hornOffset = 0.0;\n            \n            mix += (\n                (introHorn(-4,echoTime)*1.0*pan(-0.6))+\n                (introHorn( 3,echoTime)*1.0*pan(-0.2))+\n                (introHorn( 5,echoTime)*1.0*pan( 0.2))+\n                (introHorn(10,echoTime)*1.0*pan( 0.6))+\n                (introHorn(14,echoTime)*0.5*pan( 0.0))\n            )*0.5*echoVol;\n        }\n        \n        \n        float volEnv = cos(pow(introTime*0.5,0.8)*6.2831)*0.5+0.5;\n        const float volEnvMin = 0.3;\n        volEnv = volEnv*(1.0-volEnvMin)+volEnvMin;\n        \n        \n        const float fadeInStart = introStartTime;\n        const float fadeInEnd = introStartTime + 0.3;\n        float fadeIn = max(0.0,min(1.0,(time-fadeInStart)\/(fadeInEnd-fadeInStart)));\n        fadeIn = 1.0-pow(1.0-fadeIn,2.0);\n        \n        const float fadeOutStart = introEndTime - 0.45;\n        const float fadeOutEnd = introEndTime - 0.1;\n        float fadeOut = max(0.0,min(1.0,(time-fadeOutStart)\/(fadeOutEnd-fadeOutStart)));\n        fadeOut = 1.0-pow(fadeOut,4.0);\n        \n        return mix*volEnv*fadeOut*fadeIn;\n        \n    } else {\n        \n        \n        \n        float songTime = time - introEndTime;\n    \n\n\n        float mix = 0.0;\n\n\n        float beatNum = songTime\/beatLength;\n        float beatStep = mod(floor(beatNum),32.0);\n        float barStep = floor(beatNum\/32.0);\n\n\n        if (barStep == 0.0) {\n            mix += krakenLead(songTime);\n        } else {\n            mix += krakenLead(songTime);\n            mix += krakenLead(songTime-0.1)*0.3;\n        }\n\n\n        if (barStep > 0.0) {\n            if (barStep == 1.0) {\n                if (beatStep < 28.0) {\n                    mix += kick(mod(beatNum,4.0))*1.5;\n                } else {\n                    mix += kick(mod(beatNum,1.0))*1.5;\n                }\n                float snareHatBeat;\n                float snareHatVol;\n                if (beatStep < 24.0) {\n                    snareHatBeat = mod(beatNum,2.0);\n                    if (mod(beatStep,8.0) > 4.0) snareHatBeat = mod(beatNum+1.0,2.0);\n                    snareHatVol = 1.0;\n                } else {\n                    snareHatBeat = mod(beatNum,1.0);\n                    snareHatVol = 1.25 + 0.5*((beatStep-24.0)\/8.0);\n                }\n                mix += snare(snareHatBeat)*snareHatVol;\n                mix += hihatClosed(snareHatBeat)*0.5*snareHatVol;\n            } else {\n\n                float beatStepHalf = mod(beatStep,16.0);\n\n                if (\n                    beatStepHalf ==  0.0 ||\n                    beatStepHalf ==  8.0 ||\n                    beatStepHalf == 10.0 ||\n                    beatStepHalf == 14.0 ||\n                    beatStep == 21.0\n                ) {\n                    mix += kick(mod(beatNum,1.0))*1.5;\n                }\n\n                if (\n                    beatStepHalf ==  4.0 ||\n                    beatStepHalf ==  7.0 ||\n                    beatStepHalf ==  9.0 ||\n                    beatStepHalf == 12.0 \n                ){\n                    mix += snare(mod(beatNum,1.0))*1.5;\n                }\n                if (\n                    beatStepHalf ==  3.0 ||\n                    beatStepHalf == 11.0 ||\n                    beatStepHalf == 13.0 \n                ){\n                    mix += snare(mod(beatNum,1.0))*0.5;\n                }\n\n                float hihatBeatNum = beatNum-2.0;\n                if (mod(floor(beatStep\/2.0),8.0)==4.0) hihatBeatNum += 2.0;\n                mix += hihatOpen(mod(hihatBeatNum,4.0))*0.3;\n\n\n                mix += krakenBass(songTime)*1.15;\n\n                mix += krakenWail(songTime)*0.8;\n                mix += krakenWail(songTime-0.1)*0.4;\n\n\n            }\n        }\n\n\n        const float fadeStart = 128.0;\n        const float fadeEnd = fadeStart+64.0;\n        float fadeOut = max(0.0,min(1.0,(beatNum-fadeStart)\/(fadeEnd-fadeStart)));\n        fadeOut = (1.0-fadeOut);\n        fadeOut = 1.0-pow(1.0-fadeOut,2.0);\n\n\n        return vec2(mix)*0.3*fadeOut;\n        \n        \n    }\n    \n    \n}","name":"","description":"","type":"sound"}]}}