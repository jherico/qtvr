{"Shader":{"ver":"0.1","info":{"id":"MsX3D2","date":"1379555891","viewed":1925,"name":"Loxodrome","username":"fb39ca4","description":"Loxodromes make quite the shadows. Speaking of shadows, most soft shadows found on Shadertoy increase the size of the umbra, but fail to reduce the size of the penumbra, something this shader takes into account.","likes":22,"published":3,"flags":0,"tags":["raymarching","shadow","spiral","distance","soft","loxodrome","spherical","polar","estimator"],"hasliked":0},"renderpass":[{"inputs":[{"id":6,"src":"\/presets\/tex05.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/Thank you iquilez for some of the primitive distance functions!\n\nconst float PI = 3.14159265358979323846264;\n\nconst int MAX_PRIMARY_RAY_STEPS = 48; \/\/decrease this number if it runs slow on your computer\nconst int MAX_SECONDARY_RAY_STEPS = 24;\n\n\/\/Uncomment to see the full loxodrome shadow\n#define LOXODROME_ONLY\n\n\/\/mix takes a number between 0 and 1 and maps it to a number between a and b.\n\/\/inverseMix takes a number between a and b and maps it to a number between 0 and 1.\nfloat inverseMix(float a, float b, float x) {\n\treturn (x - a) \/ (b - a);\t\n}\n\nvec2 rotate2d(vec2 v, float a) { \n\treturn vec2(v.x * cos(a) - v.y * sin(a), v.y * cos(a) + v.x * sin(a)); \n}\n\nfloat polarDist(vec2 v1, vec2 v2) { \n\t\/\/Formula ripped from \n\t\/\/http:\/\/math.ucsd.edu\/~wgarner\/math4c\/derivations\/distance\/distancepolar.htm\n\treturn sqrt(v1.x * v1.x + v2.x * v2.x - 2.0 * v1.x * v2.x * cos(v1.y - v2.y));\n}\n\nvec3 rectToSpher(vec3 v) {\n\tconst float pi = 3.14159265359;\n\tvec3 res;\n\tres.x = length(v);\n\tres.y = atan(v.z, v.x); \/\/longditude\n\tres.y += 2.0 * pi * step(0.0, res.y);\n\tres.z = atan(v.y, length(v.xz)); \/\/latitude\n\treturn res;\n}\n\nfloat secIntegral(float x) {\n\treturn log(1.0 \/ cos(x) + tan(x));\n}\n\nfloat invSecIntegral(float x) {\n\treturn acos(2.0 \/ (exp(-x) + exp(x))) * sign(x);\n}\n\nfloat floorCustom(float x, float c) {\n\treturn floor(x \/ c) * c;\t\n}\n\nfloat ceilCustom(float x, float c) {\n\treturn ceil(x \/ c) * c;\t\n}\n\nfloat sdLoxodrome(vec3 p, float twist, float rotSymm, float thickness) {\n\tconst float pi = 3.14159265359;\n\tvec3 s = rectToSpher(p);\n\ts.y += iGlobalTime;\n\tfloat offset = thickness * cos(s.z);\n\tvec2 s1 = vec2(1.0 - offset, invSecIntegral((ceilCustom(secIntegral(s.z) * twist - s.y, pi * 2.0 \/ rotSymm) + s.y) \/ twist));\n\tvec2 s2 = vec2(1.0 - offset, invSecIntegral((floorCustom(secIntegral(s.z) * twist - s.y, pi * 2.0 \/ rotSymm) + s.y) \/ twist));\n\tfloat res = min(polarDist(s.xz, s1), polarDist(s.xz, s2));\n\tres -= offset;\n\treturn res * 1.0;\n}\n\nfloat sdCylinder( vec3 p, vec2 c ) {\n    return max(length(p.xy) - c.x, abs(p.z) - c.y);\n}\n\nfloat distanceField(vec3 p) {\n\tfloat wall = -p.z + 1.5;\n\tfloat loxodrome = sdLoxodrome(p - vec3(0.0, 0.0, 0.0), 2.0, 4.0, 0.075);\n\tfloat holder = 9001.0;\n\t#ifndef LOXODROME_ONLY\n\tholder = sdCylinder(p.xzy - vec3(0.0, 0.0, -1.125), vec2(0.5, 0.25));\n\tholder = min(holder, sdCylinder(p.xzy - vec3(0.0, 0.0, -1.625), vec2(0.125, 0.75)));\n\tholder = min(holder, sdCylinder(p.xzy - vec3(0.0, 0.0, -2.125), vec2(0.25, 0.25)));\n\tholder = min(holder, sdCylinder(p.xyz - vec3(0.0, -2.125, 0.75), vec2(0.125, 0.75)));\n\tholder = min(holder, sdCylinder(p.xyz - vec3(0.0, -2.125, 1.5), vec2(0.5, 0.125)));\n\t#endif\n\treturn min(wall, min(holder, loxodrome));\n}\n\nfloat shadowDistanceField(vec3 p) {\n\tfloat loxodrome = sdLoxodrome(p - vec3(0.0, 0.0, 0.0), 2.0, 4.0, 0.075);\n\tfloat holder = 9001.0;\n\t#ifndef LOXODROME_ONLY\n\tholder = sdCylinder(p.xzy - vec3(0.0, 0.0, -1.125), vec2(0.5, 0.25));\n\t#endif\n\treturn min(holder, loxodrome);\n}\n\nfloat getMaterial(vec3 p) {\n\tfloat wall = -p.z + 1.5;\n\tfloat loxodrome = sdLoxodrome(p - vec3(0.0, 0.0, 0.0), 2.0, 4.0, 0.075);\n\tfloat holder = 9001.0;\n\t#ifndef LOXODROME_ONLY\n\tholder = sdCylinder(p.xzy - vec3(0.0, 0.0, -1.125), vec2(0.5, 0.25));\n\tholder = min(holder, sdCylinder(p.xzy - vec3(0.0, 0.0, -1.625), vec2(0.125, 0.75)));\n\tholder = min(holder, sdCylinder(p.xzy - vec3(0.0, 0.0, -2.125), vec2(0.25, 0.25)));\n\tholder = min(holder, sdCylinder(p.xyz - vec3(0.0, -2.125, 0.75), vec2(0.125, 0.75)));\n\tholder = min(holder, sdCylinder(p.xyz - vec3(0.0, -2.125, 1.5), vec2(0.5, 0.125)));\n\t#endif\n\treturn step(min(holder, loxodrome), wall);\n}\n\nvec3 calcNormal(vec3 pos) {\n\tconst float derivDist = 0.0001;\n\tvec3 surfaceNormal;\n\tsurfaceNormal.x = distanceField(vec3(pos.x + derivDist, pos.y, pos.z)) \n\t\t\t\t\t- distanceField(vec3(pos.x - derivDist, pos.y, pos.z));\n\tsurfaceNormal.y = distanceField(vec3(pos.x, pos.y + derivDist, pos.z)) \n\t\t\t\t\t- distanceField(vec3(pos.x, pos.y - derivDist, pos.z));\n\tsurfaceNormal.z = distanceField(vec3(pos.x, pos.y, pos.z + derivDist)) \n\t\t\t\t\t- distanceField(vec3(pos.x, pos.y, pos.z - derivDist));\n\treturn normalize(surfaceNormal \/ derivDist);\n}\n\nvec3 castRay(vec3 pos, vec3 dir, float treshold) {\n\tfor (int i = 0; i < MAX_PRIMARY_RAY_STEPS; i++) {\n\t\t\tfloat dist = distanceField(pos);\n\t\t\t\/\/if (abs(dist) < treshold) break;\n\t\t\tpos += dist * dir;\n\t}\n\treturn pos;\n}\n\nfloat castSoftShadowRay(vec3 pos, vec3 lightPos) {\n\tconst float pi = 3.14159265359;\n\tconst float k = 0.005;\n\tfloat res = 1.0;\n\tvec3 rayDir = normalize(lightPos - pos);\n\tfloat maxDist = length(lightPos - pos);\n\t\n\tvec3 rayPos = pos + 0.01 * rayDir;\n\tfloat distAccum = 0.1;\n\t\n\tfor (int i = 1; i <= MAX_SECONDARY_RAY_STEPS; i++) {\n\t\trayPos = pos + rayDir * distAccum;\n\t\tfloat dist = shadowDistanceField(rayPos);\n\t\tfloat penumbraDist = distAccum * k;\n\t\tres = min(res, inverseMix(-penumbraDist, penumbraDist, dist));\n\t\tdistAccum += (dist + penumbraDist) * 0.5;\n\t\tdistAccum = min(distAccum, maxDist);\n\t}\n\tres = max(res, 0.0);\n\tres = res * 2.0 - 1.0;\n\treturn (0.5 * (sqrt(1.0 - res * res) * res + asin(res)) + (pi \/ 4.0)) \/ (pi \/ 2.0);\n}\n\nfloat lightPointDiffuseSoftShadow(vec3 pos, vec3 lightPos, vec3 normal) {\n\tvec3 lightDir = normalize(lightPos - pos);\n\tfloat lightDist = length(lightPos - pos);\n\tfloat color = max(dot(normal, lightDir), 0.0) \/ (lightDist * lightDist);\n\tif (color > 0.00) color *= castSoftShadowRay(pos, lightPos);\n\treturn max(0.0, color);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 mousePos = (iMouse \/ iResolution.xyxy) * 2.0 - 1.0;\n\tmousePos *= vec2(PI \/ 2.0, PI \/ 2.0).xyxy;\n\tif (iMouse.zw == vec2(0.0)) mousePos.xy = vec2(0.5, -0.2);\n\t\n\tvec2 screenPos = (fragCoord.xy \/ iResolution.xy) * 2.0 - 1.0;\n\t\n\tvec3 cameraPos = vec3(0.0, 0.0, -8.0);\n\t\/\/vec3 cameraPos = vec3(0.0);\n\t\n\tvec3 cameraDir = vec3(0.0, 0.0, 1.0);\n\tvec3 planeU = vec3(1.0, 0.0, 0.0);\n\tvec3 planeV = vec3(0.0, iResolution.y \/ iResolution.x * 1.0, 0.0);\n\tvec3 rayDir = normalize(cameraDir + screenPos.x * planeU + screenPos.y * planeV);\n\t\n\tcameraPos.yz = rotate2d(cameraPos.yz, mousePos.y);\n\trayDir.yz = rotate2d(rayDir.yz, mousePos.y);\n\t\n\tcameraPos.xz = rotate2d(cameraPos.xz, mousePos.x);\n\trayDir.xz = rotate2d(rayDir.xz, mousePos.x);\n\t\n\tvec3 rayPos = castRay(cameraPos, rayDir, 0.01);\n\tvec3 normal = calcNormal(rayPos);\n\t\n\tfloat material = getMaterial(rayPos);\n\t\n\tvec3 color;\n\tif (material == 0.0) color = pow(texture2D(iChannel0, rayPos.yx * 0.125).rgb, vec3(2.2));\n\tif (material == 1.0) color = vec3(0.05);\n\t\n\tcolor *= 32.0 * lightPointDiffuseSoftShadow(rayPos, vec3(0.0, 0.0, -0.6), normal) + 0.05 * smoothstep(10.0, 0.0, length(rayPos));\n\t\n\tcolor = pow(color, vec3(1.0 \/ 2.2));\t\n\t\n\tfragColor = vec4(color, 1.0);\n}","name":"","description":"","type":"image"}]}}