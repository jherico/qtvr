{"Shader":{"ver":"0.1","info":{"id":"XtS3R3","date":"1431208918","viewed":573,"name":"projectivity","username":"Doublefresh","description":"shows how to transform a parabola to a circle as the image of a projective transformation.","likes":4,"published":3,"flags":0,"tags":["2d","transformation","projective"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"struct conic_t {\n    float a, b, c, d, e, f;\n};\n    \nconic_t newconic(in float a, in float b, in float c, in float d, in float e, in float f) {\n    conic_t cs;\n    cs.a = a;\n    cs.b = b;\n    cs.c = c;\n    cs.d = d;\n    cs.e = e;\n    cs.f = f;\n    return cs;\n}\n\n\/\/ Projective coordinate transformation under which the  \n\/\/ image of a parabola y^2 - xis transformed to the unit circle\nvec3 parabola2circle(in vec3 p) {\n    vec3 q;\n    \n    q.y = p.z - p.y;\n    q.z = p.z + p.y;\n    q.x = p.x;\n    \n    return q; \n}\n    \n\/\/ ax^2 + by^2 + cxy + dx + ey + f \nfloat conic(in vec3 p, in conic_t z) {\n    float Z = p.z;\n    p \/=  p.z;\n    float v = z.a*p.x*p.x + z.b*p.y*p.y + z.c*p.y*p.x + z.d*p.x + z.e*p.y + p.z * z.f;\n    \n    \/\/ technique from iq: divide by gradient:\n    vec3 grad;\n    grad.x = 2.0*z.a*p.x + p.y*z.c + z.d;\n    grad.y = 2.0*z.b*p.y + p.x*z.c + z.e;\n    grad.z = p.z;\n    v \/= dot(grad, grad) \/ max(Z, 0.35);\n    \n    return smoothstep(0.01, 0.00, abs(v));\n}\n\nfloat gridlines(vec3 p) {\n    float Z = p.z;\n    float th = 0.3;\n    p \/= p.z;\n    \n    vec2 l = mod( p.xy, th );\n    \n    l = vec2(l.x > 0.5*th ? th - l.x : l.x,\n             l.y > 0.5*th ? th - l.y : l.y);\n\n    float z = 1.0-smoothstep(0.0, 0.08*th, l.x);\n    float w = 1.0-smoothstep(0.0, 0.08*th, l.y);\n    \n    return pow(min(max(z,w), clamp(Z, 0.0, 1.0)), 2.0);\n}\n\nconic_t parabola() {\n    return newconic(1.0, 0.0, 0.0, 0.0, -1.0, 0.0);\n}\n\nconic_t line() {\n    return newconic(0.0, 0.0, 0.0, 1.0, -1.0, 0.0);\n}\n\nconic_t circle() {\n    return newconic(1.0, 1.0, 0.0, 0.0, 0.0, -1.0);\n}\n\nconic_t hyperbola() {\n    return newconic(1.0, -1.0, 0.0, 0.0, 0.0, -1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uva = fragCoord.xy \/ iResolution.xy;\n    vec3 col, col_h;\n    \n    uva = 2.0 * uva - 1.0;\n    uva.x *= iResolution.x \/ iResolution.y;\n    vec3 uv = vec3(uva.xy*2.5, 1.0);\n    \n        \n    col = vec3(0.3+ 0.1*uv.y, 0.3 + 0.1*uv.y, 0.3 + 0.1*uv.y);\n    \n    uv = mix(uv, parabola2circle(uv), 0.5 + 0.5*sin(iGlobalTime));\n \n    col = mix(col, vec3(0.7), gridlines(uv));\n    col = mix(col, vec3(0.8, 0.4, 1.0), conic(uv, parabola()));\n    col = mix(col, vec3(0.4, 0.8, 1.0), conic(uv, line()));\n    col = mix(col, vec3(0.0, 0.8, 0.0), conic(uv, circle()));\n    \/\/col = mix(col, vec3(1.0, 0.0, 0.0), conic(uv, hyperbola()));\n    \n     \n    fragColor = vec4(col, 1.0);\n}","name":"","description":"","type":"image"}]}}