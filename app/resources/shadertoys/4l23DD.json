{"Shader":{"ver":"0.1","info":{"id":"4l23DD","date":"1429367571","viewed":811,"name":"Mirage Ball","username":"aiekick","description":"Mirage Ball","likes":10,"published":3,"flags":0,"tags":["ball","mirage"],"hasliked":0},"renderpass":[{"inputs":[{"id":8,"src":"\/presets\/tex07.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":22,"src":"\/presets\/cube00_0.jpg","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Stephane Cuillerdier - Aiekick\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define mpi 3.14159\n#define m2pi 6.28318\n\n\/\/ tex2d to sphere 3d\nvec2 uvMap(vec3 p)\n{\n    p = normalize(p);\n    vec2 tex2DToSphere3D;\n    tex2DToSphere3D.x = 0.5 + atan(p.z, p.x) \/ m2pi;\n    tex2DToSphere3D.y = 0.5 - asin(p.y) \/ mpi;\n    return tex2DToSphere3D;\n}\n\nvec4 displace(vec2 uv)\n{\n    vec3 tex = texture2D(iChannel1, uv).rgb;\n    \n    return vec4(dot(tex, vec3(0.02)), tex);\n}\n\nvec4 map(vec3 p, float d)\n{\n    vec4 c = displace(uvMap(p));\n    float dist = length(p) -1.;\n    c.x = dist - c.x;\n    return c;\n}\n\nvec3 nor(vec3 p, float prec, float d)\n{\n    vec2 e = vec2(prec, 0.);\n    \n    float x = map(p+e.xyy,d).x - map(p-e.xyy,d).x; \n    float y = map(p+e.yxy,d).x - map(p-e.yxy,d).x; \n    float z = map(p+e.yyx,d).x - map(p-e.yyx,d).x;  \n    \n    vec3 n = vec3(x,y,z);\n        \n    return normalize(n); \n}\n\nvec4 scene(vec4 col, vec3 ro, vec3 rd)\n{\n    vec2 md = vec2(0.000001, 20.); \/\/ distance mini \/ maxi du ray marcher pour l'evaluation de la distance avec la map \n    float s = md.x; \/\/ rayon de sphere du sphere tracer\n    float d = 0.; \/\/ distance to ro \/\/ somme des rayons de sphere\n    vec3 p = ro+rd*d; \/\/ point trouve sur la map\n    \n    vec2 hit = vec2(0.); \n    \n    float b = 0.35;\n    \n    vec4 c;\n    \n    float t = 1.1*(sin(iGlobalTime*.3)*.5+.6);\n    \n    \/\/ evaluation de la map\n    for(int i=0;i<100;i++)\n    {\n        hit = vec2(s\/md.x,s\/md.y); \/\/ ratio des limites\n        if ( s < md.x || s > md.y ) break;\n        c = map(p,d)*t;\n        s = c.x;\n        d += s;\n        p = ro+rd*d;\n    }\n    \n    if (s<md.x)\n    {\n        vec3 n = nor(p, 0.05,d); \/\/ normale de la map au point p\n\n        vec3 ray = reflect(rd, n);\n        vec4 cubeRay = textureCube(iChannel0, ray) * 0.6 ;\n\n        col += cubeRay + c; \n    }\n    else\n    {\n        col = textureCube(iChannel0, rd);\n    }\n    \n    return col;\n}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cu, vec3 org, float persp)\n{\n\tvec3 rorg = normalize(org-ro); \/\/ direction de la camera\n    vec3 u =  normalize(cross(cu, rorg)); \/\/ u du plan de la camera\n    vec3 v =  normalize(cross(rorg, u)); \/\/ v du plan de la camera\n    vec3 rd = normalize(rorg + u*uv.x + v*uv.y); \/\/ direction de rendu\n    return rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 s = iResolution.xy;\n    vec2 g = fragCoord.xy;\n    vec2 uv = (2.*g-s)\/s.y;\n    vec2 m = iMouse.xy;\n    \n    float t = iGlobalTime*0.2;\n    float axz = -t; \/\/ angle XZ\n    float axy = .4; \/\/ angle XY\n    float cd = 1.5; \/\/ cam dist to scene origine\n    \n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    if ( iMouse.z>0.) axz = m.x\/s.x * m2pi; \/\/ mouse x axis \n    if ( iMouse.z>0.) axy = m.y\/s.y * m2pi; \/\/ mouse y axis \n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n   \n    float ap = 0.; \/\/ angle de perspective\n    vec3 cu = vec3(0.,1.,0.); \/\/ haut de la camera suivant\n    vec3 org = vec3(0., 0., 0.); \/\/ origine de la scene\n    vec3 ro = vec3(cos(axz),sin(axy),sin(axz))*cd; \/\/ origine de la camera\n    \n    vec3 rd = cam(uv, ro, cu, org, ap);\n    \n    vec4 c = vec4(0.,0.,0.,1.); \/\/ couleur\n    \n    c = scene(c, ro, rd);\n    \n    fragColor = c;\n}","name":"","description":"","type":"image"}]}}