{"Shader":{"ver":"0.1","info":{"id":"lssXWS","date":"1406723972","viewed":2736,"name":"Music - Harry Potter","username":"iq","description":"Experiment for sequencing a simple melody (the instrument is simple too). So there, Hedwig's Theme from Harry Potter) generated completely in a GPU shader!","likes":19,"published":3,"flags":8,"tags":["2d","sound","music","synthesis","melody"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/-----------------------------------------------------------------------\n\nfloat hash( float n ) { return fract(sin(n)*43758.5453); }\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n\n}\n\nfloat fbm( vec2 p, float sp)\n{\n    const mat2 m = mat2( 0.8, 0.6, -0.6, 0.8 );\n\n\tfloat f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02; p.y -= sp*iGlobalTime;\n    f += 0.2500*noise( p ); p = m*p*2.03; p.x -= sp*iGlobalTime;\n    f += 0.1250*noise( p ); p = m*p*2.01; p.x += sp*iGlobalTime;\n    f += 0.0625*noise( p );\n    return f\/0.9375;\n}\n\n\/\/-----------------------------------------------------------------------\n\nfloat box( in vec2 p, in float x, in float y, in float dirx, in float diry, in float radx, in float rady )\n{\n\tvec2  q = p - vec2(x,y);\n\tfloat u = dot( q, vec2(dirx,diry) );\n\tfloat v = dot( q, vec2(diry,dirx)*vec2(-1.0,1.0) );\n\tvec2  d = abs(vec2(u,v)) - vec2(radx,rady);\n\treturn max(d.x,d.y);\n}\n\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec3 sdBezier( vec2 b0, vec2 b1, vec2 b2, in vec2 p ) \n{\n  b0 -= p;\n  b1 -= p;\n  b2 -= p;\n\t\n  float a =     det(b0,b2);\n  float b = 2.0*det(b1,b0);\n  float d = 2.0*det(b2,b1);\n  float f = b*d - a*a;\n  vec2  d21 = b2-b1;\n  vec2  d10 = b1-b0;\n  vec2  d20 = b2-b0;\n  vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n  vec2  pp = -f*gf\/dot(gf,gf);\n  vec2  d0p = b0-pp;\n  float ap = det(d0p,d20);\n  float bp = 2.0*det(d10,d0p);\n  float t = clamp( (ap+bp)\/(2.0*a+b+d), 0.0 ,1.0 );\n  return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\n\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)\/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)\/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)\/dot(e2,e2), 0.0, 1.0 );\n    \n    vec2 d = min( min( vec2( dot( pq0, pq0 ), v0.x*e0.y-v0.y*e0.x ),\n                       vec2( dot( pq1, pq1 ), v1.x*e1.y-v1.y*e1.x )),\n                       vec2( dot( pq2, pq2 ), v2.x*e2.y-v2.y*e2.x ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nvec2 sdSegment( vec2 a, vec2 b, vec2 p )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn vec2( length( pa - ba*h ), h );\n}\n\/\/------------------------------------------------------\n\nfloat fillRectangle( in vec2 p, in float x, in float y, in float dirx, in float diry, in float radx, in float rady )\n{\n\tfloat d = box(p,x,y,dirx,diry,radx,rady);\n    float w = fwidth(d)*4.0;\n\treturn 1.0 - smoothstep(-w, w, d);\n}\n\nfloat fillTriangle( in vec2 p, float x1, float y1, float x2, float y2, float x3, float y3 )\n{ \n    float d = sdTriangle( vec2(x1,y1), vec2(x2,y2), vec2(x3,y3), p );\n\t\n    float w = fwidth(d)*4.0;\n\treturn 1.0 - smoothstep(0.0, w, d);\n}\n\nfloat fillQuad( in vec2 p, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4 )\n{ \n    float d1 = sdTriangle( vec2(x1,y1), vec2(x2,y2), vec2(x3,y3), p );\n    float d2 = sdTriangle( vec2(x1,y1), vec2(x3,y3), vec2(x4,y4), p );\n    float d = min( d1, d2 );\n    float w = fwidth(d)*4.0;\n\treturn 1.0 - smoothstep(0.0, w, d);\n}\n\nfloat fillBezier( in vec2 p, float x1, float y1, float x2, float y2, float x3, float y3, float th1, float th2 )\n{ \n\tvec3 be = sdBezier( vec2(x1,y1), vec2(x2,y2), vec2(x3,y3), p );\n    float d = length(be.xy) - mix(th1,th2,be.z);\n\t\n    float w = fwidth(d)*4.0;\n\treturn 1.0 - smoothstep(-w, w, d);\n}\n\nfloat fillLine( in vec2 p, float x1, float y1, float x2, float y2, float th1, float th2 )\n{ \n\tvec2 li = sdSegment( vec2(x1,y1), vec2(x2,y2), p );\n    float d = li.x - mix(th1,th2,li.y);\n\t\n    float w = fwidth(d)*4.0;\n\treturn 1.0 - smoothstep(-w, w, d);\n}\n\/\/------------------------------------------------------\n\t\nfloat logo( vec2 q )\n{\n\tvec2 p = q - vec2(0.1,0.0);\n\tfloat f = 0.0;\n\n\tf = mix( f, 1.0, fillRectangle( p, -0.70, 0.00,  1.00, 0.000,  0.08, 0.40) );\n\tf = mix( f, 1.0, fillRectangle( p, -0.30, 0.00,  1.00, 0.000,  0.08, 0.50) );\n\tf = mix( f, 1.0, fillTriangle(  p, -0.84, 0.45, -0.56, 0.450, -0.70, 0.30) );\t\n\tf = mix( f, 1.0, fillTriangle(  p, -0.56,-0.45, -0.84,-0.450, -0.70,-0.30) );\t\n\tf = mix( f, 1.0, fillTriangle(  p, -0.44, 0.55, -0.16, 0.550, -0.30, 0.35) );\t\n\tf = mix( f, 1.0, fillTriangle(  p, -0.16,-0.55, -0.44,-0.550, -0.30,-0.35) );\t\n\tf = mix( f, 1.0, fillBezier(    p, -0.85,-0.01, -1.00, 0.080, -0.83, 0.10, 0.015, 0.002) );\t\n\tf = mix( f, 1.0, fillQuad(      p, -0.05, 0.70,  0.20, 0.705,  0.24,-0.10, 0.050, 0.200) );\t\n\tf = mix( f, 1.0, fillTriangle(  p, -0.07, 0.25,  0.15, 0.150,  0.24,-0.50) );\t\n\tf = mix( f, 1.0, fillTriangle(  p,  0.00,-0.10,  0.18,-0.150,  0.17,-0.80) );\t\n\tf = mix( f, 1.0, fillRectangle( p,  0.30, 0.60,  0.90, 0.440,  0.12, 0.03) );\n\tf = mix( f, 1.0, fillQuad(      p,  0.40, 0.68,  0.60, 0.400,  0.58, 0.100, 0.40, 0.150) );\n\tf = mix( f, 1.0, fillTriangle(    p,  0.58, 0.10,  0.35,-0.050,  0.40, 0.15) );\t\n\tf = mix( f, 1.0, fillTriangle(    p,  0.37, 0.03,  0.35,-0.050,  0.15, 0.17) );\t\n\t\n\tfloat d = (abs(sin(4.5*(p.x-1.15))*0.15+0.05-p.y) - 0.01 - 0.04*clamp(1.0-abs(p.x+0.45)\/0.5,0.0,1.0));\n\td = max( abs(p.x+0.4)-0.45, d );\n    float w = fwidth(d)*8.0;\n\tf = mix( f, 1.0, 1.0 - smoothstep(0.0, w, d) );\n\t\n\treturn f;\n}\n\n\/\/ bumped logo\nfloat slogo( in vec2 p )\n{\n\tfloat s = logo( p );\n\ts -= s*0.02*pow(fbm( 20.0*p.yx, 0.0 ),3.0);\n\t\n\treturn s;\n}\n\n\/\/-----------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = mod( iGlobalTime, 40.0 );\n\t\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) \/ iResolution.y;\n\n\tp *= 1.5-1.45*smoothstep(0.0,36.0,time);\n\t\n\tfloat al = smoothstep( 3.0,12.0, time);\n\t\n    \/\/ logo\n\tfloat f = 1.0 - al*0.4*logo( p );\n\t\n\t\/\/ background color\n\tvec3 col = vec3(f*0.2,f*0.6,f*0.7);\n\n    \/\/ add texture\n\tcol += f*3.0*smoothstep( 0.53, 0.9, fbm( 0.8*p.yx + 9.0, 0.0 ) );\n\tcol *= 0.7 + 0.3*smoothstep( 0.2, 0.8, fbm( 4.0*p  + fbm(32.0*p, 1.0), 2.0 ) );\n    col *= 0.4;\n\t\n    \/\/ calc normal\t\n\tfloat a = slogo( p );\n\tfloat b = slogo( p + vec2(2.0,0.0)\/ iResolution.y );\n\tfloat c = slogo( p + vec2(0.0,2.0)\/ iResolution.y );\n\tvec3 nor = normalize( vec3(a-b,1.0\/iResolution.y,a-c) );\n\n\t\/\/ lighting\n\tcol += al*a*    vec3(0.7,0.55,0.4)*(1.0-f)*(0.75+0.25*dot(nor,normalize(vec3(-1.0,0.2,1.0))));\n\tcol += al*a*2.0*vec3(2.0,0.80,0.3)*0.3*pow(clamp(dot(nor,normalize(vec3(-1.0,0.5,1.0))),0.0,1.0),2.0);\n\tcol += al*a*3.0*vec3(1.0,1.00,1.0)*0.6*pow(clamp(dot(nor,normalize(vec3(-1.0,0.5,1.0))),0.0,1.0),8.0);\n\n\t\n\t\/\/ vigneting\n\tcol *= 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y);\n\t\n    \/\/ fade in\t\n\tcol *=     smoothstep(  0.0,  6.0, time );\n\tcol *= 1.0-smoothstep( 30.0, 36.0, time );\n\n\tfragColor = vec4(col,1.0);\n}","name":"","description":"","type":"image"},{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec2 mainSound( float time )\n{\n  time = mod( time, 40.0 );\n\n  \/\/ do 3 echo\/reverb bounces\n  vec2 tot = vec2(0.0);\n  for( int i=0; i<3; i++ )\n  {\n    float h = float(i)\/(3.0-1.0);\n\n    \/\/ compute note\t\n    float t = (time - 0.57*h)\/0.18;\n    float n = 0.0, b = 0.0, x = 0.0;\n    #define D(u,v)   b+=float(u);if(t>b){x=b;n=float(v);}\n    D(10,71)D(2,76)D(3,79)D(1,78)D( 2,76)D( 4,83)D(2,81)D(6,78)D(6,76)D(3,79)\n    D( 1,78)D(2,74)D(4,77)D(2,71)D(10,71)D( 2,76)D(3,79)D(1,78)D(2,76)D(4,83)\n    D( 2,86)D(4,85)D(2,84)D(4,80)D( 2,84)D( 3,83)D(1,82)D(2,71)D(4,79)D(2,76)\n    D(10,79)D(2,83)D(4,79)D(2,83)D( 4,79)D( 2,84)D(4,83)D(2,82)D(4,78)D(2,79)\n    D( 3,83)D(1,82)D(2,70)D(4,71)D( 2,83)D(10,79)D(2,83)D(4,79)D(2,83)D(4,79)\n    D( 2,86)D(4,85)D(2,84)D(4,80)D( 2,84)D( 3,83)D(1,82)D(2,71)D(4,79)D(2,76) \n        \n    \/\/ calc frequency and time for note\t  \n    float noteFreq = 440.0*pow( 2.0, (n-69.0)\/12.0 );\n    float noteTime = 0.18*(t-x);\n\t\n    \/\/ compute instrument\t\n    float y  = 0.5*sin(6.2831*1.00*noteFreq*noteTime)*exp(-0.0015*1.0*noteFreq*noteTime);\n\t      y += 0.3*sin(6.2831*2.01*noteFreq*noteTime)*exp(-0.0015*2.0*noteFreq*noteTime);\n\t      y += 0.2*sin(6.2831*4.01*noteFreq*noteTime)*exp(-0.0015*4.0*noteFreq*noteTime);\n          y += 0.1*y*y*y;\t  \n          y *= 0.9 + 0.1*cos(40.0*noteTime);\n\t      y *= smoothstep(0.0,0.01,noteTime);\n          \n    \/\/ accumulate echo\t  \n    tot += y * vec2(0.5+0.2*h,0.5-0.2*h) * (1.0-sqrt(h)*0.85);\n  }\n  tot \/= 3.0;\n\t\n  return tot;\n}\n","name":"","description":"","type":"sound"}]}}