{"Shader":{"ver":"0.1","info":{"id":"4ll3Dn","date":"1420909375","viewed":163,"name":"knighty's dragon in 3d","username":"eiffie","description":"3d dragon ifs from Knighty's code found here:<br\/><a href=\"https:\/\/www.shadertoy.com\/view\/MsBXW3\"  class=\"regular\" target=\"_blank\">https:\/\/www.shadertoy.com\/view\/MsBXW3<\/a>","likes":1,"published":3,"flags":0,"tags":["dragon","indexedsearch"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/this is an attempted 3d version of knighty's excellent dragon ifs indexed DE\n\n\/\/original at: https:\/\/www.shadertoy.com\/view\/MsBXW3\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Distance estimation for dragon IFS. by knighty (nov. 2014).\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/play with these to see how they effect speed\/accuracy...\n#define DEPTH 9\n#define REFINEMENT_STEPS 36\n\n\n#define time iGlobalTime\n#define size iResolution\n\n#define ITER_NUM pow(2., float(DEPTH))\n\/\/Bounding radius to bailout. must be >1. higher values -> more accurate but slower (try 1000)\n\/\/for raymarching a value of 2 or 4 is enought in principle. A vuale of 1 (when REFINE_DE is undefined) will show the bounding circle and its transformations\n\/\/I found 1.5 (with a slider) to be the fastest trade off between DE speed and March speed - eiffie\n#define BR2BO 1.5\n\nmat3 rmx1,rmx2;\/\/the scaled rotations are in these matrices - eiffie\nvec3  A0   = vec3(1.,-1., 0.);\/\/1st IFS's transformation similatrity\nvec3  F0   = vec3(-1.,0.,0.);\/\/fixed point of 1st IFS's transformation.\nvec3  T0; \/\/Translation term Computed in ComputeBC().\nfloat scl0 = length(A0);\/\/scale factor of the 1st IFS's \n\n\/\/2nd IFS's transformation.\nvec3  A1   = vec3(-1.,-1.,0.);\nvec3  F1   = vec3(1.,0.,0.);\nvec3  T1;\nfloat scl1 = length(A1);\n\nfloat Findex=0.;\/\/mapping of IFS point to [0,1[\nfloat minFindex=0.;\/\/for colouring\nfloat BR;\/\/Computed in ComputeBC(). Bounding circle radius. The smaller, the better (that is faster) but it have to cover the fractal (actually it have to cover it's images under the transforms)\nfloat BO;\/\/Computed in ComputeBC(). Bailout value. it should be = (BR*s)^2 where s>1. bigger s give more accurate results but is slower.\n\nmat3 matRight(vec3 rt){\/\/like a scaled lookat matrix given the right hand dir - eiffie\n\tfloat r=length(rt);\n\trt=normalize(rt);\n\tvec3 up=normalize(cross(vec3(0.0,0.0,1.0),rt));\n\treturn r*mat3(rt,up,cross(rt,up));\n}\nvec3 Cmult(vec3 a, vec3 b){\n\treturn b*matRight(a);\/\/i couldn't think of a better way to do the scaled rotation :( - eiffie\n} \n\n\/\/Compute bounding circle\nvoid ComputeBC(){\n    \/\/Compute bounding circle center w.r.t. fixed points\n    float ss0=length(vec3(1.,0.,0.)-A0);\n    float ss1=length(vec3(1.,0.,0.)-A1);\n    float s= ss1*(1.-scl0)\/(ss0*(1.-scl1)+ss1*(1.-scl0));\n    vec3 C=F0+s*(F1-F0);\n    \/\/Translate the IFS in order to center the bounding circle at (0,0)\n    F0-=C;\n    F1-=C;\n    \/\/Pre-compute translations terms\n    T0 = Cmult(vec3(1.,0.,0.)-A0,F0);\n    T1 = Cmult(vec3(1.,0.,0.)-A1,F1);\n    \/\/Bounding circle radius\n    BR = -ss0*length(F0)\/(1.-scl0);\n    \/\/\n    BO = BR*BR*BR2BO;\n\trmx1=matRight(A0);rmx2=matRight(A1);\/\/compute the scaled rotation mats - eiffie\n}\nvoid SetupDragon(float t){\n    vec3 rot=vec3(cos(t*0.3)*vec2(cos(t),sin(t)),sin(t*0.3));\n\t\/\/vec3 rot=vec3(vec2(cos(t),sin(t)),0.0);\n    A1=Cmult(rot,A0);\n    ComputeBC();\n}\n\/\/Computes distance to the point in the IFS which index is the current index.\n\/\/lastDist is a given DE. If at some level the computed distance is bigger than lastDist\n\/\/that means the current index point is not the nearest so we bail out and discard all\n\/\/children of the current index point.\n\/\/We also use a static Bail out value to speed things up a little while accepting less accurate DE.\n\nfloat dragonSample(vec3 p, float lastDist){\n\tfloat q=Findex;\/\/Get the index of the current point\n\tfloat dd=1.;\/\/running scale\n\tfloat j=ITER_NUM;\n\tfor(int i=0; i<DEPTH; i++){\n\t\tfloat l2=dot(p,p);\n\t\t\/\/float temp=BR+lastDist*dd;\/\/this is to avoid computing length (sqrt)\n\t\t\/\/if(l2>0.001+temp*temp || l2>BO) break;\/\/since BO is so tight this didn't seem to help?? - eiffie\n\t\tif(l2>BO) break;\n\t\t\/\/get the sign of the translation from the binary representation of the index\n\t\tq*=2.;\n\t\tfloat sgn=floor(q); q=fract(q); j*=.5;\n\t\tif(sgn==0.){p=p*rmx1+T0;dd*=scl0;}\n\t\telse {p=p*rmx2+T1;dd*=scl1;}\n\t}\n\t\/\/update current index. it is not necessary to check the next j-1 points.\n\t\/\/This is the main optimization\n\tFindex = ( Findex + j\/ITER_NUM );\n\tfloat d=(length(p)-BR)\/dd;\/\/distance to current point\n\tif(d<lastDist) minFindex=Findex;\n\treturn min(d,lastDist);\n}\n\nfloat DE(vec3 p){\n\tFindex=0.0;\n\t\/\/Get an estimate. not necessary, but it's faster this way.\n\tfloat d=length(p)+0.5;\n\t\/\/refine the DE\n\tfor(int i=0; i<REFINEMENT_STEPS; i++){\/\/experiment: try other values\n\t\/\/ In principle max number of iteration should be ITER_NUM but we actually\n\t\/\/do much less iterations. Maybe less than O(DEPTH^2). Depends also on scl.\n\t\td=dragonSample(p,d);\n\t\tif(Findex>=1.) break;\n\t}\n\treturn d;\n}\nfloat rnd(vec2 c){return fract(sin(dot(vec2(1.317,19.753),c))*413.7972);}\nfloat rndStart(vec2 fc){\n\treturn 0.5+0.5*rnd(fc);\n}\nmat3 lookat(vec3 fw){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0.0,1.0,0.0)));return mat3(rt,cross(rt,fw),fw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tSetupDragon(time);\n\tvec3 ro=vec3(0.0,0.0,3.0);\n\tvec3 rd=lookat(-ro)*normalize(vec3((2.0*fragCoord.xy-size.xy)\/size.y,1.0));\n\tfloat t=DE(ro)*rndStart(fragCoord.xy),d=0.0,dm=100.0,tm,px=1.0\/size.y;\n\tfor(int i=0;i<32;i++){\n\t\tt+=d=DE(ro+rd*t);\n\t\tif(d<dm){dm=d;tm=t;}\n\t\tif(t>6.0 || d<px)break;\n\t}\n\tvec3 col=vec3(0.5+0.5*rd.y);\n\tif(dm<px*4.0){\n\t\tro+=rd*tm;\n\t\tvec2 e=vec2(0.5*px,0.0);\n\t\tvec3 N=normalize(vec3(DE(ro+e.xyy),DE(ro+e.yxy),DE(ro+e.yyx))-vec3(DE(ro-e.xxx*0.577)));\n\t\tvec3 L=normalize(vec3(0.4,0.7,-0.2));\n\t\tcol=0.75+0.25*sin(vec3(15.,6.5,3.25)*minFindex);\n\t\tcol*=(0.5+0.5*dot(N,L));\n\t}\n\tfragColor = vec4(col,1.0);\n\t\n}\n","name":"","description":"","type":"image"}]}}