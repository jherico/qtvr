{"Shader":{"ver":"0.1","info":{"id":"MdB3Dw","date":"1389235253","viewed":4358,"name":"Analytical Motionblur 3D","username":"iq","description":"Analytic motion blur. A sphere is checked for intersection while moving linearly. The resulting equation is a quadratic in two parameters (distance and time), and returns the time coverage of the swept disk over the aperture of the camera for a given ray","likes":72,"published":3,"flags":0,"tags":["3d","blur","motionblur","motion","analytic"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Analytic motion blur, for spheres\n\/\/\n\/\/ (Linearly) Moving Spheres vs ray intersection test. The resulting equation is a double\n\/\/ quadratic in two parameters, distance (as usual in regular raytracing) and time. It's sort\n\/\/ of space-time raytracing if you wish.\n\/\/ \n\/\/ The quadratic(s) are solved to get the time interval of the intersection, and the distances.\n\/\/ Shading is performed only once at the middle of the time interval.\n\/\/\n\/\/ This method allows for (virtually) inexpensive motion blur, without time supersampling.\n\/\/\n\/\/ Uncomment the define bellow to have a side by side comparison with brute force supersampled \n\/\/ motion blur. Most of the look differences come from the choice of a single shading instant\/point\n\/\/ rather than the full sequence. I think I might have done some small mistake somewhere in the \n\/\/ maths though.\n\/\/\n\/\/ 2D case here: https:\/\/www.shadertoy.com\/results?sort=newest\n\n#define USE_ANALYTICAL_MBLUR\n\n\/\/ intersect a MOVING sphere\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sp, in vec3 ve, out vec3 nor )\n{\n    float t = -1.0;\n\tfloat s = 0.0;\n\tnor = vec3(0.0);\n\t\n\tvec3  rc = ro - sp.xyz;\n\tfloat A = dot(rc,rd);\n\tfloat B = dot(rc,rc) - sp.w*sp.w;\n\tfloat C = dot(ve,ve);\n\tfloat D = dot(rc,ve);\n\tfloat E = dot(rd,ve);\n\tfloat aab = A*A - B;\n\tfloat eec = E*E - C;\n\tfloat aed = A*E - D;\n\tfloat k = aed*aed - eec*aab;\n\t\t\n\tif( k>0.0 )\n\t{\n\t\tk = sqrt(k);\n\t\tfloat hb = (aed - k)\/eec;\n\t\tfloat ha = (aed + k)\/eec;\n\t\t\n\t\tfloat ta = max( 0.0, ha );\n\t\tfloat tb = min( 1.0, hb );\n\t\t\n\t\tif( ta < tb )\n\t\t{\n            ta = 0.5*(ta+tb);\t\t\t\n            t = -(A-E*ta) - sqrt( (A-E*ta)*(A-E*ta) - (B+C*ta*ta-2.0*D*ta) );\n            nor = normalize( (ro+rd*t) - (sp.xyz+ta*ve ) );\n            s = 2.0*(tb - ta);\n\t\t}\n\t}\n\n\treturn vec2(t,s);\n}\n\n\/\/ intersect a STATIC sphere\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sp, out vec3 nor )\n{\n    float t = -1.0;\n\tnor = vec3(0.0);\n\t\n\tvec3  rc = ro - sp.xyz;\n\tfloat b =  dot(rc,rd);\n\tfloat c =  dot(rc,rc) - sp.w*sp.w;\n\tfloat k = b*b - c;\n\tif( k>0.0 )\n\t{\n\t\tt = -b - sqrt(k);\n\t\tnor = normalize( (ro+rd*t) - sp.xyz );\n\t}\n\n\treturn t;\n}\n\nvec3 getPosition( float time ) { return vec3(     2.5*sin(8.0*time), 0.0,      1.0*cos(8.0*time) ); }\nvec3 getVelocity( float time ) { return vec3( 8.0*2.5*cos(8.0*time), 0.0, -8.0*1.0*sin(8.0*time) ); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n\tvec2 p = -1.0 + 2.0*q;\n\tp.x *= iResolution.x\/iResolution.y;\t\n\n\t\/\/ camera\n\tvec3  ro = vec3(0.0,0.0,4.0);\n    vec3  rd = normalize( vec3(p.xy,-2.0) );\n\t\n    \/\/ sphere\t\n\t\n\t\/\/ render\n\tvec3  col = vec3(0.0);\n\t\n\t#ifdef USE_ANALYTICAL_MBLUR\n\t\n    \/\/---------------------------------------------------\t\n    \/\/ render with analytical motion blur\n    \/\/---------------------------------------------------\t\n\tvec3  ce = getPosition( iGlobalTime );\n\tvec3  ve = getVelocity( iGlobalTime );\n    \t\n\tcol = vec3(0.25) + 0.3*rd.y;\n\tvec3 nor = vec3(0.0);\n\tvec3 tot = vec3(0.25) + 0.3*rd.y;\n    vec2 res = iSphere( ro, rd, vec4(ce,1.0), ve\/24.0, nor );\n\tfloat t = res.x;\n\tif( t>0.0 )\n\t{\n\t\tfloat dif = clamp( dot(nor,vec3(0.5703)), 0.0, 1.0 );\n\t\tfloat amb = 0.5 + 0.5*nor.y;\n\t\tvec3  lcol = dif*vec3(1.0,0.9,0.3) + amb*vec3(0.1,0.2,0.3);\n\t\tcol = mix( tot, lcol, res.y );\n\t}\n\t\n\t#else\n\t\n    \/\/---------------------------------------------------\t\n    \/\/ render with brute force sampled motion blur\n    \/\/---------------------------------------------------\t\n\t\n    #define NUMSAMPLES 32\n\tvec3 tot = vec3(0.0);\n\tfor( int i=0; i<NUMSAMPLES; i++ )\n\t{\n\t\tfloat fi = float(i)\/float(NUMSAMPLES);\n        vec3  ce = getPosition( iGlobalTime + fi\/24.0 );\n        vec3 nor = vec3(0.0);\n        vec3 tmp = vec3(0.25) + 0.3*rd.y;\n        float t = iSphere( ro, rd, vec4(ce,1.0), nor );\n        if( t>0.0 )\n        {\n            float dif = clamp( dot(nor,vec3(0.5703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*nor.y;\n            tmp = dif*vec3(1.0,0.9,0.3) + amb*vec3(0.1,0.2,0.3);\n        }\n        col += tmp;\n\t}\t\t\n\tcol \/= float(NUMSAMPLES);\n\t\t\n    #endif\n\t\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}