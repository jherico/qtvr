{"Shader":{"ver":"0.1","info":{"id":"XtjSRV","date":"1445011781","viewed":516,"name":"3D Dot Rose","username":"yasuo","description":"It's just my drawing stuff.","likes":1,"published":3,"flags":0,"tags":["3d","animation","art","rose"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define NEAR 0.01\n#define FAR 128.\n#define ITER 128\nfloat tt;\nfloat atime;\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI \/ 180.0;\n\nmat4 matRotateX(float rad)\n{\n    return mat4(1,       0,        0,0,\n                0,cos(rad),-sin(rad),0,\n                0,sin(rad), cos(rad),0,\n                0,       0,        0,1);\n}\n\nmat4 matRotateY(float rad)\n{\n    return mat4( cos(rad),0,-sin(rad),0,\n                0,       1,        0,0,\n                sin(rad),0, cos(rad),0,\n                0,       0,        0,1);\n}\n\nmat4 matRotateZ(float rad)\n{\n    return mat4(cos(rad),-sin(rad),0,0,\n                sin(rad), cos(rad),0,0,\n                0,        0,1,0,\n                0,        0,0,1);\n}\n\nmat3 mat3RotateX(float rad)\n{\n    return mat3(1,       0,        0,\n                0,cos(rad),-sin(rad),\n                0,sin(rad), cos(rad));\n}\n\n\/\/ http:\/\/www.iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nvec4 combine(vec4 val1, vec4 val2 )\n{\n    if ( val1.w < val2.w ) return val1;\n    return val2;\n}\n\n\/\/ http:\/\/www.iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\/\/ http:\/\/www.iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nfloat sdCone( vec3 p, float r, float h )\n{\n    vec2 c = normalize( vec2( h, r ) );\n    float q = length(p.xy);\n    return max( dot(c,vec2(q,p.z)), -(p.z + h) );\n}\n\nfloat cubicInOut(float t) {\n    return t < 0.5\n        ? 4.0 * t * t * t\n        : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n\nfloat perlin(vec3 p) {\n    vec3 i = floor(p);\n    vec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n    vec3 f = cos((p-i)*PI)*(-.5)+.5;\n    a = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n    a.xy = mix(a.xz, a.yw, f.y);\n    return mix(a.x, a.y, f.z);\n}\n\nvec4 map( vec3 pos, mat4 m)\n{\n    vec4 q = vec4(pos+vec3(0,0,-50.0),1.0)*m;\n\n    float t = floor(iGlobalTime);\n    float f = fract(iGlobalTime);\n    t += cubicInOut(2. - exp(-f*5.));\n    atime = t*0.2;\n\n    float deg = atime*50.0;\n    float deg2 = -1.0*atime*50.0+30.0;\n    float deg3 = atime*50.0+60.0;\n    float deg4 = -1.0*atime*50.0+90.0;\n    float deg5 = atime*50.0+120.0;\n    float deg6 = -1.0*atime*50.0+150.0;\n    float deg7 = atime*50.0+180.0;\n    float deg8 = -1.0*atime*50.0+210.0;\n    float deg9 = atime*50.0+240.0;\n    float deg10 = -1.0*atime*50.0+280.0;\n\n    vec4 newP = vec4(q.xyz + vec3( 0, 0, 0 ),1.0)*matRotateX(deg*DEG_TO_RAD)*matRotateY(deg*DEG_TO_RAD)*matRotateZ(deg*DEG_TO_RAD);\n    vec4 newP2 = vec4(q.xyz + vec3( 0, 0, 0 ),1.0)*matRotateX(deg2*DEG_TO_RAD)*matRotateY(deg2*DEG_TO_RAD)*matRotateZ(deg2*DEG_TO_RAD);\n    vec4 newP3 = vec4(q.xyz + vec3( 0, 0, 0 ),1.0)*matRotateX(deg3*DEG_TO_RAD)*matRotateY(deg3*DEG_TO_RAD)*matRotateZ(deg3*DEG_TO_RAD);\n    vec4 newP4 = vec4(q.xyz + vec3( 0, 0, 0 ),1.0)*matRotateX(deg4*DEG_TO_RAD)*matRotateY(deg4*DEG_TO_RAD)*matRotateZ(deg4*DEG_TO_RAD);\n    vec4 newP5 = vec4(q.xyz + vec3( 0, 0, 0 ),1.0)*matRotateX(deg5*DEG_TO_RAD)*matRotateY(deg5*DEG_TO_RAD)*matRotateZ(deg5*DEG_TO_RAD);\n    vec4 newP6 = vec4(q.xyz + vec3( 0, 0, 0 ),1.0)*matRotateX(deg6*DEG_TO_RAD)*matRotateY(deg6*DEG_TO_RAD)*matRotateZ(deg6*DEG_TO_RAD);\n    vec4 newP7 = vec4(q.xyz + vec3( 0, 0, 0 ),1.0)*matRotateX(deg7*DEG_TO_RAD)*matRotateY(deg7*DEG_TO_RAD)*matRotateZ(deg7*DEG_TO_RAD);\n    vec4 newP8 = vec4(q.xyz + vec3( 0, 0, 0 ),1.0)*matRotateX(deg8*DEG_TO_RAD)*matRotateY(deg8*DEG_TO_RAD)*matRotateZ(deg8*DEG_TO_RAD);\n    vec4 newP9 = vec4(q.xyz + vec3( 5.0, 10.0, 0 ),1.0)*matRotateX(90.0*DEG_TO_RAD)*matRotateY(-40.0*DEG_TO_RAD);\n    vec4 newP10 = vec4(q.xyz + vec3( -7.0, 15.0, 0 ),1.0)*matRotateX(90.0*DEG_TO_RAD)*matRotateY(45.0*DEG_TO_RAD);\n\n    float glow = 0.0;\n    vec3 p = pos;\n    float grid = max(0.0, max((mod((p.x+p.y+p.z*50.0)-atime*0.01, 50.0)-40.0), 0.0) );\n\n    float size1 = 7.2;\n    float size2 = 7.2;\n    float size3 = 7.2;\n    float size4 = 7.2;\n    float size5 = 7.2;\n    float size6 = 7.2;\n    float size7 = 7.2;\n\n    vec3 roseCl = vec3(0.35,0.0,0.0)+vec3(grid,0.0,0.0);\n    vec3 scale1 = vec3(abs(sin(atime)*size1),size1,abs(sin(atime)*size1));\n    vec3 scale2 = vec3(size2,abs(sin(atime)*size2),size2);\n    vec3 scale3 = vec3(size3,size3,abs(sin(atime)*size3));\n    vec3 scale4 = vec3(size4,abs(sin(atime)*size4),size4);\n    vec3 scale5 = vec3(abs(sin(atime)*size5),size5,size5);\n    vec3 scale6 = vec3(abs(sin(atime)*size6),abs(sin(atime)*size6),size6);\n    vec3 scale7 = vec3(size7,abs(sin(atime)*size7),size7);\n\n    float noise = perlin(pos * 0.5) * 0.2;\n    vec4 val1 = vec4(roseCl,sdBox(newP.xyz,scale1 ) + noise);\n    vec4 val2 = vec4(roseCl,sdBox(newP2.xyz,scale2 ) + noise);\n    vec4 val3 = vec4(roseCl,sdBox(newP3.xyz,scale3 ) + noise);\n    vec4 val4 = vec4(roseCl,sdBox(newP4.xyz,scale4 ) + noise);\n    vec4 val5 = vec4(roseCl,sdBox(newP5.xyz,scale5 ) + noise);\n    vec4 val6 = vec4(roseCl,sdBox(newP6.xyz,scale6 ) + noise);\n    vec4 val7 = vec4(roseCl,sdBox(newP7.xyz,scale7 ) + noise);\n\n    vec4 val8 = vec4(vec3(0.0,0.1,0.0)+vec3(0.0,grid,0.0),sdBox(q.xyz + vec3( 0, 16.0, 0 ),vec3(1.0,10.0,1.0) ) + noise);\n    vec4 val9 = vec4(vec3(0.0,0.1,0.0)+vec3(0.0,grid,0.0),sdCone(newP9.xyz,1.0,7.0 ) + noise);\n    vec4 val10 = vec4(vec3(0.0,0.1,0.0+vec3(0.0,grid*-1.0,0.0)),sdCone(newP10.xyz,1.0,9.0 ) + noise);\n\n    vec4 val11 = combine ( val1, val2 );\n    vec4 val12 = combine ( val3, val4 );\n    vec4 val13 = combine ( val5, val6 );\n    vec4 val14 = combine ( val7, val8 );\n    vec4 val15 = combine ( val9, val10 );\n    vec4 val16 = combine ( val11, val12 );\n    vec4 val17 = combine ( val13, val14 );\n    vec4 val18 = combine ( val15, val16 );\n    vec4 val19 = combine ( val17, val18 );\n\n    return val19;\n}\n\nvec2 rot(vec2 p, float a) {\n    return vec2(\n        cos(a) * p.x - sin(a) * p.y,\n        sin(a) * p.x + cos(a) * p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 position = ( fragCoord.xy \/ iResolution.xy );\n    position -= .5;\n    position = floor(position*150.0)\/150.0;\n    vec3 dir = vec3( position, 1.0 );\n\n    float aspect = iResolution.x \/ iResolution.y;\n    dir = normalize(vec3(position * vec2(aspect, 1.0), 1.0));\n    dir.yz = rot(dir.yz, 0.2);\n\n    vec3 pos = vec3(0.0, 5.0, 15.0);\n    mat4 m = matRotateY(iGlobalTime*0.5);\n\n    vec4 result;\n    int march = 0;\n\n    for (int i =0; i < ITER; i++)\n    {\n        result = map(pos, m);\n        march = i;\n        if (result.w < NEAR || result.w > FAR) break;\n        pos += result.w * dir;\n    }\n\n    vec3 col = map(pos, m).xyz;\n    vec4 bgCol;\n    if ( pos.z> 100. )\n    {\n        \/\/ bg\n        position.y \/= 1.5;\n        vec3 pw\t= vec3(position.y - position.x, position.y + position.x, -(position.y * 2.));\n        pw\t\t*= .8;\n\n        float t = atime*-7.0;\n        float tau = (8. * atan(1.));\n        vec2 m = vec2((t-1.5) \/ tau, (t - .5) \/ tau);\n\n        vec3 r = vec3(m.x, tau\/2., m.y);\n\n        mat3 rm3 = mat3RotateX(r.z*5.);\n        pw *= tau\/1.;\n\n        float s = 1.\/0.7;\n        vec3 d = vec3(pw);\n\n        float w  = 0.0001\/iResolution.x;\n        vec3 color = vec3(0);\n\n        pw = abs(pw)-s;\n        pw *= rm3;\n\n        color += float(pw.z*0.5<w);\n        float temp = length(vec2(position.xy))+0.5;\n\n        col = vec3(vec3(vec3(.2,.0,.0)\/vec3(temp)))+vec3(color.y*0.1,0,0.);\n    }\n    else\n    {\n        \/\/ shade\n        vec3 lightPos = vec3(20.0, 20.0, 20.0 );\n        vec3 light2Pos = normalize( lightPos - pos);\n        vec3 eps = vec3( .1, .01, .0 );\n        vec3 n = vec3( result.w - map( pos - eps.xyy, m ).w,\n                      result.w - map( pos - eps.yxy, m ).w,\n                      result.w - map( pos - eps.yyx, m ).w );\n        n = normalize(n);\n\n        float lambert = max(.0, dot( n, light2Pos));\n        col *= vec3(lambert);\n\n        col += vec3(result.xyz);\n    }\n\tfloat cline = mod(fragCoord.y, 4.0) < 2.0 ? 0.5 : 1.0;\n    fragColor = vec4( col, 1.0)*cline;\n\n}","name":"","description":"","type":"image"}]}}