{"Shader":{"ver":"0.1","info":{"id":"llf3Wl","date":"1426094581","viewed":768,"name":"heyx3 Distance-estimated fractal","username":"heyx3","description":"Playing around with distance-estimated 3D fractals","likes":3,"published":3,"flags":0,"tags":["3d","fractal","distancefield"],"hasliked":0},"renderpass":[{"inputs":[{"id":8,"src":"\/presets\/tex07.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":23,"src":"\/presets\/cube01_0.png","ctype":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/------Distance field--------\n\n\/\/Returns the following values:\n\/\/X: distance to the fractal.\n\/\/Y: number of iterations needed, from 0 to 1.\n\/\/Z: The 'r' value.\n\/\/W: The 'dr' value.\nvec4 getDistanceToFractal(vec3 pos, float timeScale, float bailoutScale)\n{\n    const int Iterations = 6;\n    float Bailout = 2.0 * bailoutScale;\n    float powLerp = 0.5 + (0.5 * sin((iGlobalTime * timeScale) + 4.9));\n    float Power = mix(1.0, 8.0, pow(powLerp, 1.0));\n    \n    vec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n    float nIterations = 0.0;\n\tfor (int i = 0; i < Iterations ; i++) {\n\t\tr = length(z);\n        nIterations += 1.0;\n        \n\t\tif (r>Bailout)\n        {\n            break;\n        }\n\t\t\n\t\t\/\/ convert to polar coordinates\n\t\tfloat theta = acos(z.z\/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t\/\/ scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta *= Power;\n\t\tphi *= Power;\n\t\tphi = (phi);\n        \n\t\t\/\/ convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn vec4(0.5*log(r)*r\/dr,\n                nIterations \/ float(Iterations),\n                r,\n                dr);\n}\n\nmat3 rotPos2 = mat3(-0.7071067812, -0.7071067812, 0.0,\n                   \t0.70710678120, -0.7071067812, 0.0,\n                    0.0, \t\t   0.0, \t\t  1.0);\n\/\/Returns the following values:\n\/\/X: distance to the surface.\n\/\/Y: number of iterations needed, from 0 to 1.\n\/\/Z: The 'r' value.\n\/\/W: The 'dr' value.\nvec4 getDistanceToSurface(vec3 pos)\n{\n    return getDistanceToFractal(pos, 1.0, 1.0);\n    vec4 first = getDistanceToFractal(pos, 1.0, 1.0),\n         second = getDistanceToFractal(pos, 1.04, 1.0);\n    if (first.x < -second.x) return first;\n    else return second;\n}\n\nvec3 getNormal(vec3 pos)\n{\n    const vec2 epsilon = vec2(0.0, 0.0001);\n    \n    return normalize(vec3(getDistanceToSurface(pos + epsilon.yxx).x -\n                              getDistanceToSurface(pos - epsilon.yxx).x,\n                     \t  getDistanceToSurface(pos + epsilon.xyx).x -\n                              getDistanceToSurface(pos - epsilon.xyx).x,\n                     \t  getDistanceToSurface(pos + epsilon.xxy).x -\n                              getDistanceToSurface(pos - epsilon.xxy).x));\n}\n\n\n\n\/\/-----Ray-marching---------\n\nstruct RayMarchData\n{\n    float moveDist;\n    vec3 hitPos;\n    float nIterations;\n    \n    float nFractalIterations;\n    float fractalR, fractalDR;\n};\n\n#define MAX_ITERATIONS 100\n#define MAX_ITERATIONS_F float(MAX_ITERATIONS)\n\n#define SHADOW_AMBIENT 0.6\n    \n#define DISTANCE_EPSILON 0.001\n\n\/\/Performs the ray-marching algo. Returns whether something was hit.\nbool marchRay(out RayMarchData dat, vec3 rayStart, vec3 rayDir)\n{\n    dat.hitPos = rayStart;\n    dat.nIterations = 0.0;\n    vec4 distData;\n    \n    for (int i = 0; i < MAX_ITERATIONS; ++i)\n    {\n        dat.nIterations += 1.0;\n        distData = getDistanceToSurface(dat.hitPos);\n        \n        if (distData.x < DISTANCE_EPSILON)\n        {\n            dat.nFractalIterations = distData.y;\n            dat.nIterations \/= float(MAX_ITERATIONS);\n            dat.fractalR = distData.z;\n            dat.fractalDR = distData.w;\n            return true;\n        }\n        \n        dat.hitPos += (distData.x * rayDir);\n        dat.moveDist += distData.x;\n    }\n    \n    dat.nIterations \/= float(MAX_ITERATIONS);\n    return false;\n}\n\n\n\n\/\/-----------Main------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    \n    \/\/Cam data.\n    float distFromCenter = 2.5 + (0.0000 * sin(1.8 * iGlobalTime));\n    const float camRotSpeed = 0.25;\n    vec3 camForward = normalize(vec3(cos((camRotSpeed * iGlobalTime) + (iMouse.x \/ iResolution.x * -8.0)),\n                                     sin((camRotSpeed * iGlobalTime) + (iMouse.x \/ iResolution.x * -8.0)),\n                                     mix(-1.5, 1.5, iMouse.y \/ iResolution.y))),\n         camPos = distFromCenter * -camForward,\n         camUp = vec3(0.0, 0.0, 1.0),\n         camSide = cross(camForward, camUp);\n    camUp = cross(camSide, camForward);\n    \n    \n    \/\/Ray data.\n    const float fovScale = 1.0;\n    vec2 uvNormalized = -1.0 + (2.0 * uv);\n    vec3 rayStart = camPos + (camForward * fovScale) +\n        \t\t\t(camSide * uvNormalized.x) +\n        \t\t\t(camUp * uvNormalized.y * (iResolution.y \/ iResolution.x));\n    vec3 rayDir = normalize(rayStart - camPos);\n    \n     \n    \/\/Ray-march through the scene.\n    RayMarchData dat;\n    bool hit = marchRay(dat, rayStart, rayDir);\n    \n    \/\/Color the scene.\n    if (hit)\n    {\n        \/\/fragColor.xyz = fract(dat.hitPos * 2.0);\n        float val = 1.0 - smoothstep(0.0, 1.0, smoothstep(0.0, 1.0, pow(dat.nIterations, 0.35)));\n        \/\/float val = pow(dat.fractalR, 0.25);\n        \n        fragColor.xyz = vec3(val);\n        fragColor = texture2D(iChannel0, vec2(val, iGlobalTime * 0.01));\n        \n        fragColor = vec4(dat.hitPos * pow(val, 0.5), 1.0);\n    }\n    else\n    {\n        fragColor = vec4(textureCube(iChannel1, rayDir.xzy).xyz, 1.0);\n    }\n    \n    \n    \/\/Some debug-logging color outputs.\n    \/\/fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    \/\/fragColor = vec4(0.5 + (0.5 * getNormal(dat.hitPos)), 1.0);\n}","name":"","description":"","type":"image"}]}}