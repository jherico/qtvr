{"Shader":{"ver":"0.1","info":{"id":"XsVGzz","date":"1453072990","viewed":303,"name":"Art1","username":"predatiti","description":"stupid camera movement <img src=\"\/img\/emoticonSad.png\"\/>","likes":15,"published":3,"flags":32,"tags":["3d","raymarching","fractal","gi","global","pathtracing","montecarlo"],"hasliked":0},"renderpass":[{"inputs":[{"id":5,"src":"\/presets\/tex04.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":6,"src":"\/presets\/tex05.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\/\/ Display : average down and do gamma adjustment\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\n    vec3 col = vec3(0.0);\n    int fr = iFrame;\n    \n    if( iFrame>0 )\n    {\n        col = texture2D( iChannel0, uv ).xyz;\n        if( iMouse.z > 0.0 ) fr = 1;\n          col \/= float(fr);\n        col = pow( col, vec3(0.4545) );\n    }\n    \n    \n    \/\/ color grading and vigneting\n    col = pow( col, vec3(0.8,0.85,0.9) );\n    \n    col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"},{"inputs":[{"id":2,"src":"\/presets\/tex01.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":6,"src":"\/presets\/tex05.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":28,"src":"\/presets\/tex15.png","ctype":"texture","channel":3,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"const float t = 4.0;\/\/nr. sample per pixel\n\nvec2 p;\nvec2 rv2;\nfloat time ;\n\nvec2 randv2= vec2(0.0);\nvec2 rand2(){\/\/ implementation derived from one found at: lumina.sourceforge.net\/Tutorials\/Noise.html\n   randv2+=vec2(1.0,1.0);\n   return vec2(fract(sin(dot(randv2.xy ,vec2(12.9898,78.233))) * 43758.5453),\n      fract(cos(dot(randv2.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec3 rx(vec3 p, float a)\n{\n   float c, s;\n   vec3 q = p;\n\n   c = cos(a); \n   s = sin(a);\n   p.y = c * q.y - s * q.z;\n   p.z = s * q.y + c * q.z;\n   return p;\n}\n\nfloat sMin( float a, float b, float k )\n{\n    \n   float h = clamp(0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n   return mix( b, a, h ) - k*h*(1.-h);\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 cosineDirection( in vec2 seed, in vec3 nor)\n{\n    \/\/ compute basis from normal\n    \/\/ see http:\/\/orbit.dtu.dk\/fedora\/objects\/orbit:113874\/datastreams\/file_75b66578-222e-4c7d-abdf-f7e255100209\/content\n    \/\/ (link provided by nimitz)\n    vec3 tc = vec3( 1.0+nor.z-nor.xy*nor.xy, -nor.x*nor.y)\/(1.0+nor.z);\n    vec3 uu = vec3( tc.x, tc.z, -nor.x );\n    vec3 vv = vec3( tc.z, tc.y, -nor.y );\n    \n    float u = seed.x;\n    float v = seed.y;\n    float a = 6.283185 * v;\n\n    return  sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n}\n\nvec3 bump1(vec3 hit, vec3 n, sampler2D tex, vec2 uv,float scale, float invbump)\n{\n   float e =0.0001;\n   vec3 sxx = texture2D(tex,uv + vec2(e,0.0)).rgb - \n              texture2D(tex,uv - vec2(e,0.0)).rgb;\n   vec3 syy = texture2D(tex,uv + vec2(0.0,e)).rgb - \n              texture2D(tex,uv - vec2(0.0,e)).rgb;\n\n   float sx = dot(sxx,vec3(0.2));\n   float sy = dot(syy,vec3(0.2));\n         \n   vec3 s = dFdx( hit );\n   vec3 t = dFdy( hit );\n   vec3 uu = cross(t,n);\n   vec3 vv = cross(n,s);\n   float d = 0.0001;\n\n   n = normalize(n - (sx*uu + sy*vv)\/d * scale * invbump);\n\n   return n;\n}\n\n\/\/ http:\/\/research.microsoft.com\/en-us\/um\/people\/hoppe\/ravg.pdf\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec3 getClosest( vec2 b0, vec2 b1, vec2 b2 ) \n{\n    float a =     det(b0,b2);\n    float b = 2.0*det(b1,b0);\n    float d = 2.0*det(b2,b1);\n    float f = b*d - a*a;\n    vec2  d21 = b2-b1;\n    vec2  d10 = b1-b0;\n    vec2  d20 = b2-b0;\n    vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n    vec2  pp = -f*gf\/dot(gf,gf);\n    vec2  d0p = b0-pp;\n    float ap = det(d0p,d20);\n    float bp = 2.0*det(d10,d0p);\n    float t = clamp( (ap+bp)\/(2.0*a+b+d), 0.0 ,1.0 );\n    return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\n\nvec4 sdBezier( vec3 a, vec3 b, vec3 c, vec3 p )\n{\n   vec3 w = normalize( cross( c-b, a-b ) );\n   vec3 u = normalize( c-b );\n   vec3 v = normalize( cross( w, u ) );\n\n   vec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n   vec2 b2 = vec2( 0.0 );\n   vec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n   vec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n   vec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy );\n\n   return vec4( sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z), cp.z, length(cp.xy), p3.z );\n}\n\nvec2 f(vec3 p)\n{\n   float f = 1000.0;\n   float o = 1.0;\n   vec3  q = p + vec3(-0.1,0.0,0.25);\n\n\/\/sol\n   \/\/vec3 bump = bump1(q, vec3(0.0,1.0,0.0), tex1, q.zx*vec2(-0.16,-0.17)*1.0, 0.7, -1.0);\n   q = p;\/\/+bump*0.05;\n   float d1 = q.y+0.65;\n   \n\/\/perete\n   float d2 = p.z+0.65;\n   float d3 = length(max(abs(p+vec3(2.67,0.55,0.65))-vec3 (8.5,0.09,0.05),0.0))-0.02;\n   d2 = min(d2,d3);\n   if(d2<d1) {d1=d2; o=2.0;}\n\n\/\/canapea   \n   q = p + vec3(1.5,0.0,0.0);\n   d2 = length(max(abs(q+vec3(-1.5,0.0,0.0))-vec3 (1.476,0.19,0.52),0.0))-0.07;\/\/sezut \n   d3 = length(max(abs(q+vec3( 0.3,0.0,0.0))-vec3 (0.2,0.215,0.5),0.0))-0.07;\/\/maner si picior   \n   float d4 = length(max(abs(q+vec3(0.2,0.45,0.0))-vec3 (0.3,0.15,0.5),0.0))-0.07;\n   d3 = sMin(d3,d4,0.05);\n   d4 = length(max(abs(q+vec3(0.2,-.5,-0.10))-vec3 (0.3,0.2,0.4),0.0))-0.07;\n   \n   d3 = sMin(d3,d4,0.05);\n   d2 = min(d2,d3);\n\n   d3 = length(max(abs(q+vec3(-1.67,0.38,-0.45))-vec3 (1.5,0.1,0.1),0.0))-0.02;\/\/suport sezut\n   q = rx(q, 0.2);\n   d4 = length(max(abs(q+vec3(-1.2,-0.84,0.28))-vec3 (1.7,0.5,0.1),0.0))-0.07;\/\/ spatar\n\n   d2 = min(d4,min(d2,d3));\n   q=p;\n   d3 = length(max(abs(q+vec3(3.1,-1.8,0.7))-vec3 (0.7,1.3,0.1),0.0));\/\/tablou\n\n   \/\/if(d2.x<d1.x) d1=d2;\n   if(d2<d1) {d1 = d2; o=3.0;}\n   if(d3<d1) {d1 = d3; o=4.0;}  \n\n   q = p+vec3(2.5,0.0,0.15);\n   d2 = p.y + 1.9;\n   d3 = sin(d2*5.0)*0.07;\n   d4 = sdCylinder(q, vec2(0.15+d3,0.7))*0.7;\/\/vaza\n   if(d4<d1) {d1 = d4; o=5.0;}\n\n\/\/veioza\n   q = p+vec3(5.0,0.6,0.15);\n   d2 = sdCylinder(q, vec2(0.35,0.10))*0.7;\/\/suport veioza\n   if(d2<d1) {d1 = d2; o=6.0;}\n\n   vec3 head = vec3(0.0,0.0,-0.0); \/\/teava veioza\n   q = p+vec3(0.0,-0.0,0.0);\n   vec4 b1 = sdBezier( vec3(-5.0,-0.5,-0.15), vec3(-5.1,3.5,-0.15), head+vec3(-3.1,1.5,-0.15), q );\n   d2 = b1.x-0.02;\n   if(d2<d1) {d1 = d2; o=6.0;}\n\n   q = p + vec3(3.0,-1.4,0.15);\/\/bec\n   d2 = length(q) - 0.3;\n   d3 = length(q+vec3(-0.04,0.04,0.0)) - 0.27;\n   d2 = max(-d3, d2)*0.7;\n   if(d2<d1) {d1 = d2; o=6.0;}\n\n   return vec2(d1, o);\n}\n\nvec2 march(vec3 ro, vec3 rd)\n{\n   float t = 0.0;\n\n   for(int steps =0; steps < 200; steps++)\n   {\n      vec2 d = f(ro  + t * rd); \n      if(d.x < 0.0001*t) return vec2(t, d.y);\n      t += d.x;\n      if(t>50.) break;\n   }\n   return vec2(-1);\n}\n\nfloat shadow( in vec3 ro, in vec3 rd )\n{\n    float res = 0.0;\n    float tmax = 20.0;\n    \n    float t = 0.001;\n    for(int i=0; i<40; i++ )\n    {\n        float h = f(ro+rd*t).x;\n        if(t>tmax) break;\n        t += h;\n    }\n\n    if( t>tmax ) res = 1.0;\n    \n    return res;\n}\n\nvec3 MaterialColor(vec3 h, inout vec3 n, inout float refp, float id)\n{\n   vec3 color = vec3(0.1, 0.7, 0.7);\n   refp = 0.0;\n   \n   if(id==1.0)\n   {\n      vec2 uv = h.zx; \n      uv = 1.0-(uv - vec2(1.0,1.0))\/5.0;\n      color = texture2D(iChannel1,uv*vec2(0.8,0.85)).xyz;\n      refp = pow(color.x*1.0,4.0);\n      \/\/color = vec3(1.0);\n   }\n   if(id==2.0)  {color = vec3(0.7,0.8,0.3); refp=0.0;}\n   if(id==3.0)  {color = vec3(0.9,0.9,0.9); refp=0.0;}\n   if(id==4.0)\n   {\n       color = vec3(0.1,0.1,0.1)*1.5; refp=0.09;\n       vec2 uv = h.zy; \n       uv = abs(n.y) > 0.0 ? h.zx : uv;\n       uv = abs(n.z) > 0.0 ? h.xy : uv; \n       uv = (uv-vec2(1.0,-0.7))\/1.7;\n       color = texture2D(iChannel2,uv).xyz;\n       if(uv.x >-2.05 || uv.x <-2.77) color = vec3(0.03);\n       if(uv.y > 2.17 || uv.y < 0.77) color = vec3(0.03);\n   }\n   if(id==5.0)  \n   {\n\t\tcolor = vec3(0.7,0.0,0.0)*1.0;\n\t\trefp =0.0;\/\/0.5 - abs(sin(h.y*10.5))*1.2;; \n   }\n    if(id==6.0)  {color = vec3(0.9,0.9,0.9)*1.0; refp = 0.0;}\n   \n   return color;\n}\n\nvec3 getColor(vec3 ro, vec3 rd)\n{\n\n   vec3 color = vec3(0.0);\n   vec3 col = vec3(1.0);\n   vec3 sun = normalize(vec3(-300.0,280.0,180.0));\n   vec3 sunc = 0.8*vec3(1.0,0.8,0.6);\n   vec3 skyc = 0.8*vec3(0.2,0.35,0.5);\n   float refp = 1.0;\n\n   for(int i=0; i<4; i++)\n   {\n      vec2 hit = march(ro, rd);\n\n      if(hit.x<-0.5) \n   \t\treturn color += col*mix(0.05*vec3(0.9,1.0,1.0), skyc, smoothstep(0.1,0.25,rd.y));\n\n      vec3 h = ro + hit.x * rd;\n      float e = 0.0001;\n      vec3 n = vec3(f(h + vec3(e,   0.0, 0.0)).x - f(h - vec3(e,   0.0, 0.0)).x, \n                    f(h + vec3(0.0, e,   0.0)).x - f(h - vec3(0.0, e,   0.0)).x, \n                    f(h + vec3(0.0, 0.0, e)).x   - f(h - vec3(0.0, 0.0, e)).x);\n      n = normalize(n);\n      \/\/h = h + n * e;\n      col *= MaterialColor(h, n, refp, hit.y); \n      vec2 rnd = rand2();\n      vec3 rnd3 = vec3(rand2(),rand2().x)*2.0 - 1.0;\n   \n      if(refp == 0.0)\n      {\n         float sunDif = max(0.0, dot(sun, n));\n         float sunSha = 1.0; if(sunDif > 0.00001) sunSha = shadow(h + n*0.01, sun+rnd3*0.05);\n         color += col * sunc * sunDif * sunSha;\n\n         vec3 skyPoint = cosineDirection( rnd, n);\n         float skySha = shadow( h + n*0.001, skyPoint);\n         color += col * skyc * skySha;\n\n         rd = cosineDirection(rand2(), n);\n      }\n     else \n      {\n         rd = reflect(rd+rnd3*refp, n);\n         \/\/color += col * refp*0.5;\n      }\n\n      ro = h + rd * 0.01;\n   }\n   \n   return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    randv2=fract(cos((fragCoord.xy+fragCoord.yx*vec2(1000.0,1000.0))+vec2(iGlobalTime))*10000.0);\n    vec2 rnd = 2.0*randv2-1.5;\n    p = -1.0+2.0*(fragCoord.xy+rnd)\/iResolution.xy;\n\tp.x *= iResolution.x\/iResolution.y;\n    vec2 mo = iMouse.xy\/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iGlobalTime;\n    float seed = iGlobalTime + iResolution.y *(p.x+1.0) + p.y;\n\t\n    \/\/move camera with mouse\n\tvec3 ro =vec3(-5.5+3.0*cos(8.0*mo.x), 1.0+ 2.5*(mo.y), 3.2+ 3.0*sin(5.0*mo.x));\n    \/\/vec3 ro = vec3(-2.6, 1.0, 3.5);\n\tvec3 ta = vec3(-2.6, 0.7, 0.0);   \n    \n\t\/\/ camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n    time = iGlobalTime;\n    \/\/randv2=fract(cos((fragCoord.xy+fragCoord.yx*vec2(1000.0,1000.0))+vec2(iGlobalTime))*10000.0);\n\trandv2=vec2(iGlobalTime)*100.0;\n    \n\tvec3 col = texture2D( iChannel0, fragCoord\/iResolution.xy ).xyz;\n    \/\/if( iFrame==0 ) col = vec3(0.0);\n    if( iMouse.z > 0.0 ) col = getColor( ro, rd );\n\n    col += getColor( ro, rd );\n\n    fragColor=vec4( col, 1.0 );\n}","name":"","description":"","type":"buffer"}]}}