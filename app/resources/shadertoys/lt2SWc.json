{"Shader":{"ver":"0.1","info":{"id":"lt2SWc","date":"1447152433","viewed":499,"name":"heightfield plotter","username":"dzozef","description":"Classical dot effect, needs more optimization.<br\/>Rotate with mouse. Fullscreen may be too slow.<br\/><br\/>Vertex shader version: http:\/\/www.vertexshaderart.com\/art\/TGGLggjxQgLPEFHWx","likes":12,"published":3,"flags":0,"tags":["heightfield","retro","demoscene","dots"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define NUMDOTS 900\n#define DOTDIST 12.0\n#define FOCAL 300.\n#define DOTCOLOR vec3( 1.0 )\n#define YSCALE 64.\n#define TSCALE .2\n\nfloat DOTSQ = sqrt( float(NUMDOTS) );\nfloat scale = 1.0;\n\nvec3 rotateY( vec3 p, float a )\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    vec3 r;\n    r.x = ca*p.x + sa*p.z;\n    r.y = p.y;\n    r.z = -sa*p.x + ca*p.z;\n    return r;\n}\n\n\/\/ terrain function from mars shader by reider\n\/\/ https:\/\/www.shadertoy.com\/view\/XdsGWH\nconst mat2 mr = mat2 (0.84147,  0.54030,\n\t\t\t\t\t  0.54030, -0.84147 );\nfloat hash( in float n )\n{\n\treturn fract(sin(n)*43758.5453);\n}\nfloat noise(in vec2 x)\n{\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\t\t\n\tf = f*f*(3.0-2.0*f);\t\n\tfloat n = p.x + p.y*57.0;\n\t\n\tfloat res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n\t\t\t\t\tmix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n\treturn res;\n}\nfloat fbm( in vec2 p )\n{\n\tfloat f;\n\tf  =      0.5000*noise( p ); p = mr*p*2.02;\n\tf +=      0.2500*noise( p ); p = mr*p*2.33;\n\tf +=      0.1250*noise( p ); p = mr*p*2.01;\n\tf +=      0.0625*noise( p ); p = mr*p*5.21;\n\t\n\treturn f\/(0.9375)*smoothstep( 260., 1024., p.y ); \/\/ flat at beginning\n}\n\nvec3 GetDotXZ( int index )\n{\n    float x = mod( float(index), DOTSQ );\n    float y = floor( float(index) \/ DOTSQ );\n    x = (x - DOTSQ\/2.) * DOTDIST;\n    y = (y - DOTSQ\/2.) * DOTDIST;\n    return vec3( x, 0., y );\n}\n\nfloat GetDotY( int index )\n{\n    float x = mod( float(index), DOTSQ );\n    float y = floor( float(index) \/ DOTSQ );\n    vec2 npos = vec2( x, y );\n    vec2 trans = vec2( iGlobalTime * 16.0, iGlobalTime * 23. );\n    float z = fbm( (npos + trans)* TSCALE );\n    return z*YSCALE;\n}\n\nfloat PerspX( vec3 point )\n{\n    return iResolution.x\/2. + (point.x * FOCAL) \/ (point.z + FOCAL) * scale;\n}\n\nint Persp( vec3 point, out vec2 trans )\n{\n    if (point.z > -FOCAL)\n    {\n        trans = vec2(  iResolution.x\/2. + (point.x * FOCAL) \/ (point.z + FOCAL) * scale, \n                       iResolution.y\/2. + (point.y*FOCAL) \/ (point.z + FOCAL) * scale );\n        return 1;\n    }\n    else return 0;\n}\n\nvec3 Dots( vec2 pix )\n{\n    vec3 trans = vec3( 0., -160., 100. );\n    \n    \/\/ hacky optimize\n \tif (pix.y > iResolution.y*(2.\/3.)) return vec3(0.);\n    \n    \/\/ corner points optimize\n    float sqsize2 = DOTSQ*DOTDIST*0.5;\n    vec3 c1 = vec3( -sqsize2, 0.0, -sqsize2 ) + trans;\n    vec3 c2 = vec3( -sqsize2, 0.0,  sqsize2 ) + trans;\n    vec3 c3 = vec3(  sqsize2, 0.0,  sqsize2 ) + trans;\n    vec3 c4 = vec3(  sqsize2, 0.0, -sqsize2 ) + trans;\n    vec2 sc1, sc2, sc3, sc4;\n    float sc1x = PerspX( c1 );\n    float sc2x = PerspX( c2 );\n    float sc3x = PerspX( c3 );\n    float sc4x = PerspX( c4 );\n    float lx = min( min( min( sc1x, sc2x ), sc3x ), sc4x );\n    float rx = max( max( max( sc1x, sc2x ), sc3x ), sc4x );\n    if (pix.x < lx || pix.x > rx) return vec3(0.);\n    \n    for (int i=0; i < NUMDOTS; i++)\n    {\n        \/\/ first check just x position on screen\n        vec3 dot = GetDotXZ( i );\n        vec3 rdot = rotateY( dot, (-iMouse.x \/ iResolution.x) * 3.14159 );\n        rdot += trans;\n        float scdotx = PerspX( rdot );\n        if (floor(scdotx) == pix.x)\n        {\n\t        rdot.y += GetDotY( i );\n            \/\/vec3 rdot = rotateY( dot, iMouse.x \/ iResolution.x * 3.14159 );\n            vec2 scdot;\n            if (Persp( rdot, scdot )==1)\n            {\n                if (floor(scdot) == pix)\n                    return DOTCOLOR * min( 1.-(rdot.z\/FOCAL), 1.0 );\n            }\n        }\n    }\n\treturn vec3(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    scale = iResolution.x \/ 640.;\n\tvec2 pix = floor( fragCoord.xy );\n        \n\tfragColor = vec4( Dots( pix ), 1.0 );\n}","name":"","description":"","type":"image"}]}}