{"Shader":{"ver":"0.1","info":{"id":"lssGDX","date":"1381076781","viewed":736,"name":"Quadrics","username":"eiffie","description":"Ray tracing goo.","likes":7,"published":3,"flags":0,"tags":["raytrace","quadratic","surface"],"hasliked":0},"renderpass":[{"inputs":[{"id":1,"src":"\/presets\/tex00.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Quadrics by eiffie, just tired of raytraced spheres and planes\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst int AA=2, MaxBounces=6;\nconst float fov = 2.0,maxDepth=10.0;\nconst vec3 sunColor=vec3(1.0,0.9,0.8),skyColor=vec3(0.5,0.5,0.7);\nvec3 sunDir=normalize(vec3(0.1,0.1,-1.0));\nconst vec3 ior=vec3(1.0,1.52,1.0\/1.52);\/\/w=1.33,g=1.52,d=2.42\n\n#define time iGlobalTime\n#define size iResolution\n#define tex iChannel0\n\nstruct material {vec3 color;float refrRefl,spec,specExp;}mtrl;\nstruct hit {float t;vec3 n,p;};\/\/hit time, normal and untransformed position (for texturing)\nstruct intersect {hit h1,h2;bool bInside;int obj;}intr;\n\nhit bogusHit=hit(maxDepth,vec3(0.0),vec3(0.0));\nconst mat3 idm=mat3(1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0);\n\nfloat fRay=0.0;\nvec3 ro,rd;\nmat3 rmx;\n\nintersect Quadric(vec3 p, vec3 abc, float r, int obj){\/\/Ax^2 + By^2 + Cz^2 - r = 0 \n\thit h1=bogusHit,h2=bogusHit;\n\tvec3 e=rmx*ro-p,dr=rmx*rd;\/\/transform \n\tfloat A=dot(abc*dr,dr),B=2.0*dot(abc*e,dr),C=dot(abc*e,e)-abs(r)*r,inner=B*B-4.0*A*C;\t\t\n\tif(inner<0.0){\/\/throw out if not inside (if inside your looking thru the middle of a cylinder etc.)\n\t\tif(C<0.0){h1=hit(-maxDepth,vec3(1.0),vec3(0.0));h2=hit(maxDepth,vec3(1.0),vec3(0.0));}\n\t}else {\n\t\tinner=sqrt(inner);\n\t\tvec2 t=vec2(-B-inner,-B+inner)\/(2.0*A);\n\t\tif(t.x>t.y){if(t.y>0.0)t.x=-maxDepth; else t.y=maxDepth;}\/\/below inverse transform the normals (rotate back)\n\t\th1=hit(t.x,normalize(abc*(e+dr*t.x))*rmx,e+dr*t.x);h2=hit(t.y,normalize(abc*(e+dr*t.y))*rmx,e+dr*t.y);\t\n\t}\n\treturn intersect(h1,h2,C<0.0,obj);\n}\n\nvoid Sort(inout intersect i1, in intersect i2){\/\/if the second object is closer and not behind, switch\n\tif(i2.h1.t<i1.h1.t && i2.h2.t>0.0)i1=i2;\n}\n\n\/*void Intersection(inout intersect i1, in intersect i2){\n\tif(i2.h1.t>i1.h1.t)i1.h1=i2.h1;\n\tif(i2.h2.t<i1.h2.t)i1.h2=i2.h2;\n\tif(i1.h2.t<i1.h1.t){i1.h1.t=i1.h2.t=maxDepth;i1.obj=-1;}\/\/no intersection\n\ti1.bInside=(i1.h1.t<0.0 && i1.h2.t>0.0);\n}*\/\n\nmat3 matPyr(vec3 rot){vec3 c=cos(rot),s=sin(rot);\/\/orient the mat3 (pitch yaw roll)\n\treturn mat3(c.z*c.y+s.z*s.x*s.y,s.z*c.x,-c.z*s.y+s.z*s.x*c.y,-s.z*c.y+c.z*s.x*s.y,c.z*c.x,s.z*s.y+c.z*s.x*c.y,c.x*s.y,-s.x,c.x*c.y);\n}\nmat3 rm2;\/\/=matPyr(vec3(0.0,0.0,time));\nvec3 ABC;\/\/=vec3(sin(time*0.21),sin(time*0.34),0.8+sin(time*0.13)*0.2);\nvec3 goo;\nfloat radius;\/\/=sin(time*0.2)*0.5;\nvoid Trace(){\n\tintr.h1.t = maxDepth; intr.bInside=false; intr.obj = -1;rmx=idm;\/\/reset\n\tSort(intr, Quadric(vec3(0.0,0.0,3.0),vec3(0.0,0.0,1.0),1.0,0) );\n\trmx=rm2;\n\tSort(intr, Quadric(goo,ABC,radius,1) );\n}\n\nvoid getMaterial(){\n\tif( intr.obj == 0 ){\/\/plane\n\t\tvec2 xy=intr.h1.p.xy*0.5;\n\t\tvec3 c=texture2D(tex,xy).rgb;\n\t\tmtrl.color = c.rbg;mtrl.refrRefl=0.1;mtrl.spec=1.0;mtrl.specExp=64.0;\n\t\tfloat dx=c.b-texture2D(tex,xy-vec2(0.004,0.0)).b,dy=c.b-texture2D(tex,xy-vec2(0.0,0.004)).b;\n\t\tintr.h1.n=normalize(intr.h1.n+vec3(dx,dy,0.0));\n\t}else {\n\t\tmtrl.color=vec3(1.0,1.0,0.9);mtrl.refrRefl=-1.0;mtrl.spec= 1.0;mtrl.specExp= 256.0;\/\/glass\n\t}\n}\n\nvec3 getBackground( in vec3 rdir ){\n\treturn clamp(skyColor+rd*0.25+sunColor*(pow(max(0.0,dot(rdir,sunDir)),2.0)*0.25+pow(max(0.0,dot(rdir,sunDir)),80.0)*0.75),0.0,1.0);\n}\n \nvec3 scene() {\/\/ find color of scene\n\tvec3 fcol=vec3(1.0),acol=vec3(0.0);\n\tintr.obj = 0;\n\tfor(int i=0; i<MaxBounces; i++ ){\/\/ bounce loop\n\t\tif(intr.obj < 0)continue;\n\t\tTrace();\/\/get distance into scene\n\t\tif(intr.obj >= 0){\/\/hit something\n\t\t\tbool bInside=intr.bInside;\n\t\t\tif(bInside){intr.h1=intr.h2;intr.h1.n*=-1.0;}\n\t\t\tintr.h1.t=max(0.0,intr.h1.t);\n\t\t\tro += rd * intr.h1.t;\/\/ advance ray position to hit point\n\t\t\tgetMaterial();\/\/match material properties to item hit\n\t\t\tvec3 nor=intr.h1.n;\n\t\t\tvec3 refl=reflect(rd,nor),newRay=refl;\/\/setting up for a new ray direction and defaulting to a reflection\n\t\t\tif(mtrl.refrRefl<0.0){\/\/if the material refracts use the fresnel eq.\n\t\t\t\tvec3 refr=refract(rd,nor,(bInside)?ior.y:ior.z);\/\/calc the probabilty of reflecting instead\n\t\t\t\tvec2 ca=vec2(dot(nor,rd),dot(nor,refr)),n=(bInside)?ior.yx:ior.xy,nn=vec2(n.x,-n.y);\n\t\t\t\tif(fRay>0.5*(pow(dot(nn,ca)\/dot(n,ca),2.0)+pow(dot(nn,ca.yx)\/dot(n,ca.yx),2.0))){newRay=refr;nor=-nor;}\n\t\t\t\tfcol*=mtrl.color;\n\t\t\t}else if(mtrl.refrRefl<=fRay){\n\t\t\t\tnewRay=sunDir;\n\t\t\t\tfcol*=mix(mtrl.color*max(0.2,dot(nor,sunDir)*0.8),vec3(1.0),pow(max(0.0,dot(refl,newRay)),mtrl.specExp)*mtrl.spec);\n\t\t\t\tacol+=fcol*0.1;\n\t\t\t}else{\/\/these have perfect reflections\n\t\t\t\tfcol*=mtrl.color;\n\t\t\t}\n\t\t\trd=newRay;\n\t\t\tro += rd * 0.0001;\/\/pushs away\/thru the surface\n\t\t\tif(dot(fcol,fcol)<0.01)intr.obj = -1;\/\/bail out since light energy is low\n\t\t}\n\t}\n\treturn clamp(acol+fcol*getBackground(rd),0.0,1.0);\/\/light the scene\n}\t\n\nmat3 lookat(vec3 fw,vec3 up){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,normalize(up)));return mat3(rt,cross(rt,fw),fw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\/\/for slow accumulation (needs alphaAccum.anim)\n\tvec3 clr=vec3(0.0);\n    rm2=matPyr(vec3(0.0,0.0,time));\n    ABC=vec3(sin(time*0.21),sin(time*0.34),0.8+sin(time*0.13)*0.2);\n    radius=sin(time*0.2)*0.5;\n\tgoo=sin(vec3(fragCoord.xy\/iResolution.xy*10.0,0.0)+vec3(time))*0.15;\n\tconst vec3 ey=vec3(0.0,-1.0,-1.5);\n\tmat3 rotCam=lookat(vec3(0.0,1.25,2.0),vec3(0.0,1.0,0.0));\n\tconst float aa = float(AA),iaa = 1.0\/aa;\n\tfor(int i=0;i<AA*AA;i++){\n\t\tvec2 xy = vec2(mod(float(i),aa),floor(float(i)*iaa+iaa*0.5))*iaa;\n\t\tvec2 pxl = (-size.xy+2.0*(fragCoord.xy+xy))\/size.y;\n\t\tro = ey;\n\t\trd = rotCam * normalize( vec3( pxl, fov ) );\n\t\tclr+=scene();\n\t\tfRay+=iaa*iaa;\n\t}\n\tclr*=iaa*iaa;\n\tfragColor = vec4(clr,1.0);\n}\n","name":"","description":"","type":"image"}]}}