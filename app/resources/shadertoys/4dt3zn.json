{"Shader":{"ver":"0.1","info":{"id":"4dt3zn","date":"1447773428","viewed":611,"name":"Raymarched Reflections","username":"Shane","description":"A very basic demonstration of raymarching a distance field with reflections and shadows. Definitely not cutting edge, but hopefully, interesting to anyone who isn't quite familiar with the process.","likes":23,"published":3,"flags":0,"tags":["raymarching","reflection","cubes","rounded"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/*\n\tRaymarched Reflections\n\t----------------------\n\n\tA very basic demonstration of raymarching a distance field with reflections \n\tand reasonably passable shadows. Definitely not cutting edge, but hopefully, \n\tinteresting to anyone who isn't quite familiar with the process.\n\n\tReflections are pretty easy: Raymarch to the hit point, then obtain the color \n\tat that point. Continue on from the hit point in the direction of the reflected \n\tray until you reach a new hit point. Obtain the color at the new point, then\n\tadd a portion of it to your original color. Repeat the process.\n\n\tUnfortunately, the extra work can slow things down, especially when you apply\n\tshadows, which is probably why you don't see too many shadowed,\treflected \n\texamples. However, for relatively simple distance fields, it's pretty doable.\n\n\tIt was tempting to do this up, but I figured a simpler example would be more\n\thelpful. Take away the rambling comments, and there isn't a great deal of code.\n\tI'll post a more sophisticated one later.\n\n    \/\/ Reasonably simple examples featuring reflection:\n\n    To the road of ribbon - XT95\n    https:\/\/www.shadertoy.com\/view\/MsfGzr\n\n    704.2 - PauloFalcao\n    https:\/\/www.shadertoy.com\/view\/Xdj3Dt\n\n    \/\/ Reflections and refraction. Really cool.\n    Glass Polyhedron - Nrx\n    https:\/\/www.shadertoy.com\/view\/4slSzj\n\n*\/\n\n#define FAR 30.\n\n\/\/ Distance function. This one is pretty simple. I chose rounded\n\/\/ spherical boxes, because they're cheap and they display the \n\/\/ reflections reasonably well.\nfloat map(vec3 p)\n{\n    \n    \/\/ Positioning the rounded cubes a little off center, in order\n    \/\/ to break up the space a little.\n    \/\/\n    \/\/ \"floor(p)\" represents a unique number (ID) for each cube \n    \/\/ (based on its unique position). Take that number and produce \n    \/\/ a randomized 3D offset, then add it to it's regular position. \n    \/\/ Simple.\n    float n = sin(dot(floor(p), vec3(7, 157, 113)));\n    vec3 rnd = fract(vec3(2097152, 262144, 32768)*n)*.16-.08;\n    \n    \/\/ Repeat factor. If irregularity isn't your thing, you can get \n    \/\/ rid of \"rnd\" to line things up again.\n    p = fract(p + rnd) - .5;\n    \n    \n    \/\/ Rounded spherical boxes. The following is made up, but kind of\n    \/\/ makes sense. Box, minus a bit of sphericalness, gives you a \n    \/\/ rounded box.\n    p = abs(p); \n    return max(p.x, max(p.y, p.z)) - 0.25 + dot(p, p)*0.5;\n    \n    \/\/return length(p) - 0.225; \/\/ Just spheres.\n}\n\n\/\/ Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0.0;\n    \n    for (int i = 0; i < 96; i++){\n\n        float d = map(ro + rd*t);\n        \n        if(abs(d)<0.0025 || t>FAR) break;\n        \n        t += d*.75;  \/\/ Using more accuracy, in the first pass.\n    }\n    \n    return t;\n}\n\n\/\/ Second pass, which is the first, and only, reflected bounce. \n\/\/ Virtually the same as above, but with fewer iterations and less \n\/\/ accuracy.\n\/\/\n\/\/ The reason for a second, virtually identical equation is that \n\/\/ raymarching is usually a pretty expensive exercise, so since the \n\/\/ reflected ray doesn't require as much detail, you can relax things \n\/\/ a bit - in the hope of speeding things up a little.\nfloat traceRef(vec3 ro, vec3 rd){\n    \n    float t = 0.0;\n    \n    for (int i = 0; i < 48; i++){\n\n        float d = map(ro + rd*t);\n        \n        if(abs(d)<0.0025 || t>FAR) break;\n        \n        t += d;\n    }\n    \n    return t;\n}\n\n\n\/\/ Cheap shadows are hard. In fact, I'd almost say, shadowing repeat objects - in a setting like this - with limited \n\/\/ iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    \/\/ More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = (lp-ro); \/\/ Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = 0.01;    \n    float end = max(length(rd), 0.001);\n    float stepDist = end\/float(maxIterationsShad);\n    \n    rd \/= end;\n\n    \/\/ Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    \/\/ number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        \/\/shade = min(shade, k*h\/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h\/dist)); \/\/ Subtle difference. Thanks to IQ for this tidbit.\n        dist += min( h, stepDist*2. ); \/\/ So many options here, and none are perfect: dist += min( h, 0.2 ), etc\n        \n        \/\/ Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.001 || dist > end) break; \n    }\n\n    \/\/ I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    \/\/ Really dark shadows look too brutal to me.\n    return min(max(shade, 0.) + 0.5, 1.0); \n}\n\n\/\/ Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 getNormal( in vec3 p ){\n\n    \/\/ Note the slightly increased sampling distance, to alleviate\n    \/\/ artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.005, -0.005); \n    return normalize(\n        e.xyy * map(p + e.xyy) + \n        e.yyx * map(p + e.yyx) + \n        e.yxy * map(p + e.yxy) + \n        e.xxx * map(p + e.xxx));\n}\n\n\/\/ Alternating the cube colors in a 3D checkered arrangement.\n\/\/ You could just return a single color, if you wanted, but I\n\/\/ thought I'd mix things up a bit.\n\/\/\n\/\/ Color scheme mildly influenced by: Sound Experiment 3 - aiekick\n\/\/ https:\/\/www.shadertoy.com\/view\/Ml2XWt\nvec3 getObjectColor(vec3 p){\n    \n    vec3 col = vec3(1);\n    \n    \/\/ \"floor(p)\" is analogous to a unique ID - based on postion.\n    \/\/ This could be stepped, but it's more intuitive this way.\n    if(fract(dot(floor(p), vec3(.5))) > 0.001) col = vec3(0.9, 0.7, 1.0);\n    \n    return col;\n    \n}\n\n\/\/ Using the hit point, unit direction ray, etc, to color the \n\/\/ scene. Diffuse, specular, falloff, etc. It's all pretty \n\/\/ standard stuff.\nvec3 doColor(in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp){\n    \n    vec3 ld = lp-sp; \/\/ Light direction vector.\n    float lDist = max(length(ld), 0.001); \/\/ Light to surface distance.\n    ld \/= lDist; \/\/ Normalizing the light vector.\n    \n    \/\/ Attenuating the light, based on distance.\n    float atten = 1.0 \/ (1.0 + lDist*0.25 + lDist*lDist*0.05);\n    \n    \/\/ Standard diffuse term.\n    float diff = max(dot(sn, ld), 0.);\n    \/\/ Standard specualr term.\n    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 8.0);\n    \n    \/\/ Coloring the object. You could set it to a single color, to\n    \/\/ make things simpler, if you wanted.\n    vec3 objCol = getObjectColor(sp);\n    \n    \/\/ Combining the above terms to produce the final scene color.\n    vec3 sceneCol = (objCol*(diff + 0.15) + vec3(1., .6, .2)*spec*2.) * atten;\n\n    \n    \/\/ Return the color. Done once every pass... of which there are\n    \/\/ only two, in this particular instance.\n    return sceneCol;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \/\/ Screen coordinate.\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) \/ iResolution.y;\n    \n    \/\/ Unit direction ray.\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n\n    \/\/ Some cheap camera movement, for a bit of a look around. I use this far\n    \/\/ to often. I'm even beginning to bore myself, at this point. :)\n    float cs = cos(iGlobalTime * 0.25), si = sin(iGlobalTime * 0.25);\n    rd.xy *= mat2(cs, -si, si, cs);\n    rd.xz *= mat2(cs, -si, si, cs);\n    \n    \/\/ Ray origin. Doubling as the surface postion, in this particular example.\n    \/\/ I hope that doesn't confuse anyone.\n    vec3 ro = vec3(0., 0., iGlobalTime*1.5);\n    \n    \/\/ Light position. Set in the vicinity the ray origin.\n    vec3 lp = ro + vec3(0., 1., -.5);\n    \n    \n    \/\/ FIRST PASS.\n    \n    float t = trace(ro, rd);\n    \n    \/\/ Fog based off of distance from the camera. Not used here.\n    \/\/float fog = smoothstep(FAR*.9, 0., t); \n    \n    \/\/ Advancing the ray origin, \"ro,\" to the new hit point.\n    ro += rd*t;\n    \n    \/\/ Retrieving the normal at the hit point.\n    vec3 sn = getNormal(ro);\n    \n    \/\/ Retrieving the color at the hit point, which is now \"ro.\" I agree, reusing \n    \/\/ the ray origin to describe the surface hit point is kind of confusing. The reason \n    \/\/ we do it is because the reflective ray will begin from the hit point in the \n    \/\/ direction of the reflected ray. Thus the new ray origin will be the hit point. \n    \/\/ See \"traceRef\" below.\n    vec3 sceneColor = doColor(ro, rd, sn, lp);\n    \n    \/\/ Checking to see if the surface is in shadow. Ideally, you'd also check to\n    \/\/ see if the reflected surface is in shadow. However, shadows are expensive, so\n    \/\/ it's only performed on the first pass. If you pause and check the reflections,\n    \/\/ you'll see that they're not shadowed. OMG! - Better call the shadow police. :)\n    float sh = softShadow(ro, lp, 16.);\n    \n    \n    \/\/ SECOND PASS - REFLECTED RAY\n    \n    \/\/ Standard reflected ray, which is just a reflection of the unit\n    \/\/ direction ray off of the intersected surface. You use the normal\n    \/\/ at the surface point to do that. Hopefully, it's common sense.\n    rd = reflect(rd, sn);\n    \n    \n    \/\/ The reflected pass begins where the first ray ended, which is the suface\n    \/\/ hit point, or in a few cases, beyond the far plane. By the way, for the sake\n    \/\/ of simplicity, we'll perform a reflective pass for non hit points too. Kind\n    \/\/ of wasteful, but not really noticeable. The direction of the new ray will\n    \/\/ obviously be in the direction of the reflected ray. See just above.\n    \/\/\n    \/\/ To anyone who's new to this, don't forgot to nudge the ray off of the \n    \/\/ initial surface point. Otherwise, you'll intersect with the surface\n    \/\/ you've just hit. After years of doing this, I still forget on occasion.\n    t = traceRef(ro +  rd*.01, rd);\n    \n    \/\/ Advancing the ray origin, \"ro,\" to the new reflected hit point.\n    ro += rd*t;\n    \n    \/\/ Retrieving the normal at the reflected hit point.\n    sn = getNormal(ro);\n    \n    \/\/ Coloring the reflected hit point, then adding a portion of it to the final scene color.\n    \/\/ How much you add is up to you, but I'm going with 35 percent.\n    sceneColor += doColor(ro, rd, sn, lp)*.35;\n    \n    \n    \/\/ APPLYING SHADOWS\n    \/\/\n    \/\/ Multiply the shadow from the first pass by the final scene color. Ideally, you'd check to\n    \/\/ see if the reflected point was in shadow, and incorporate that too, but we're cheating to\n    \/\/ save cycles and skipping it. It's not really noticeable anyway. By the way, ambient\n    \/\/ occlusion would make it a little nicer, but we're saving cycles and keeping things simple.\n    sceneColor *= sh;\n    \n    \/\/ Technically, it should be applied on the reflection pass too, but it's not that\n    \/\/ noticeable, in this case. Either way, it's not being used here.\n    \/\/sceneColor *= fog;\n    \n   \n\n    \/\/ Clamping the scene color, then presenting to the screen.\n\tfragColor = vec4(clamp(sceneColor, 0.0, 1.0), 1.0);\n}","name":"","description":"","type":"image"}]}}