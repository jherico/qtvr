{"Shader":{"ver":"0.1","info":{"id":"XlXGD8","date":"1421261309","viewed":848,"name":"Britbot","username":"eiffie","description":"Frolicking endlessly with my gal pal Britbot. I was going to view all the shaders here but after spending an hour playing with the first one I gave up.","likes":8,"published":3,"flags":0,"tags":["fake3d"],"hasliked":0},"renderpass":[{"inputs":[{"id":12,"src":"\/presets\/vid01.webm","ctype":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/Britbot by eiffie\n\/\/A little bit like mode7 from poljere https:\/\/www.shadertoy.com\/view\/ltsGWn\n\/\/...and a lot of tunnel from iq https:\/\/www.shadertoy.com\/view\/Ms2SWW\n\n#define PI 3.14159\nvec3 tunnel(vec3 rd){\n\tvec2 uv=rd.xy\/rd.z;\n\tfloat tm=iGlobalTime*sign(rd.z)*1.5;\n\tfloat pw=0.5+pow(min(abs(sin(tm*0.1))+0.25,1.0),16.0)*16.0;\n\tfloat r=pow(pow(uv.x*uv.x,pw)+pow(uv.y*uv.y,pw),0.5\/pw);\n\tfloat x;\n\tfor(int i=1;i<10;i++){\/\/what kind of maths are these?\n\t\tx=uv.x+sin((0.5\/r+0.5*tm)*2.0)*float(i)*float(i)*0.001;\n        pw=0.5+pow(min(abs(sin((tm+max(1.0-r,0.0))*0.1))+0.25,1.0),16.0)*16.0;\n\t\tr=pow(pow(x*x,pw)+pow(uv.y*uv.y,pw),0.5\/pw);\n\t}\n\tuv.x=x;\n\tfloat a=atan(uv.y,uv.x)\/3.14159;\n\tvec2 p=vec2(0.5\/r+0.5*tm,a)*8.0;\n\tp.y*=sign(uv.x);\n\tvec2 c=floor(p);\n\tp=fract(p);\n\tp.x=pow(p.x,clamp(abs(rd.z)+pw\/16.0,1.0,2.0));\n\tuv=p;\n\tuv=2.0*(uv-0.5);\n\tfloat r2=pow(pow(uv.x*uv.x,pw)+pow(uv.y*uv.y,pw),0.5\/pw);\n\tp=clamp(p*1.5-0.25,0.0,1.0);\n\tvec3 col=vec3(0.5)+0.5*sin(vec3(c.xy,c.x+c.y));\n    if((a<0.25 && a>-0.25) || a<-0.75 || a>0.75){\n        float d=max(abs(p.x-0.5),abs(p.y-0.5))-0.5;\n        if(d<0.0){\/\/min(p.x,p.y)>0.0 && max(p.x,p.y)<1.0){\n        \tif(rd.z<0.0)p.y=1.0-p.y;\n\t\t\tcol=mix(col,texture2D(iChannel0,p).rgb,smoothstep(0.0,0.05,-d));\n        }\n    }\n\tcol*=2.0*pow(r,1.75)*clamp(3.0-r2*3.0,0.0,1.0);\n\tif(col!=col)col=vec3(0.0);\n\treturn clamp(col,0.0,1.0);\n}\nmat3 lookat(vec3 fw, vec3 up){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,normalize(up)));return mat3(rt,cross(rt,fw),fw);\n}\nstruct intersect{float t, d; vec3 N;}I1,I2; \nvoid zStack(intersect I, float px){\n\tif(I.t<=0.0 || I.d>px*I.t)return;\n\tif(I.t<I1.t){I2=I1;I1=I;}\n\telse if(I.t<I2.t)I2=I;\n}\n#define maxDepth 10.0\n\/\/pS=p1-ro, pD=p2-p1 Hopefully no one thinks this actually works!\nintersect Segment(in vec3 pS, in vec3 pD, in float r, in vec3 rd){\/\/mod from iq's\n\tintersect intr=intersect(0.0,maxDepth,vec3(0.0));\n\tfloat d=dot(rd,pD);\n\tfloat t=clamp((dot(rd,pS)*d-dot(pS,pD))\/(dot(pD,pD)-d*d),0.0,1.0);\n\tpS+=pD*t;\n\tintr.N=-pS;\n\tfloat b=dot(pS,rd);\n\tfloat h=b*b-dot(pS,pS);\n\td=sqrt(max(0.0,-h))-r;\n\tintr.d=max(0.0,d);\n\tintr.t=b+min(d,0.0)-sqrt(max(0.0,h+r*r));\n\treturn intr;\n\t\/\/dist: intr.t\n\t\/\/aa\/dof: clamp(intr.d\/(px*intr.t),0.0,1.0);\n\t\/\/shad: clamp(k*intr.d\/intr.t,0.0,1.0);\n\t\/\/normal: normalize(rd*intr.t+intr.N);\n}\nvec3 Light(intersect I, vec3 rd, float px, vec3 col){\n\tfloat aac=1.0-clamp(I.d\/(px*I.t),0.0,1.0);\n\tif(aac>0.0){\n\t\tvec3 N=normalize(rd*I.t+I.N);\n\t\tvec3 L=normalize(vec3(0.5,0.8,0.4));\n\t\tvec3 R=reflect(rd,N);\n\t\tcol=mix(col,(vec3(1.0,0.3,0.4)+0.2*tunnel(R))*(0.5+0.5*dot(L,N)),aac);\n\t}\n\treturn col;\n}\nvec3 jsolve( vec3 a, vec3 b, float ln, vec3 rt )\/\/mod from iq's\n{\/\/simple joint with equal lengths\n\tvec3 p=b-a,q=p*0.5;\n\treturn a+q+sqrt(max(0.0,ln*ln-dot(q,q)))*normalize(cross(p,rt));\n}\nvec3 britbot(vec3 ro, vec3 rd, vec3 col){\n\tfloat px=2.5\/iResolution.y,tm=iGlobalTime*10.0;\n\tI1.t=I2.t=I1.d=I2.d=maxDepth;\n\tfloat ct=cos(tm),st=sin(tm),st2=sin(tm*0.3);\n\tfloat h=(ct+st)*ct*-0.25;\n\tvec3 b1=vec3(0.0,h,0.0),b2=vec3(st2*0.2,-0.75+h,-0.2);\n\t\n\tvec3 le,lh=vec3(-0.75+0.1*st,-0.4-0.2*ct,0.3-0.3*ct),re,rh=vec3(0.75+0.1*st,-0.4-0.2*st,0.3+0.3*ct);\n\tvec3 lk,lf=vec3(-0.25,-2.0+max(0.0,ct*0.5),-0.25+0.4*st),rk,rf=vec3(0.25,-2.0+max(0.0,-ct*0.5),-0.25-0.4*st);\n\tvec3 rt=normalize(vec3(1.0+0.4*st2,-0.4*st2,0.0));\n\tle=jsolve(b1,lh,0.6,rt.yxz);\n\tre=jsolve(b1,rh,0.6,-rt.yxz);\n\tlk=jsolve(b2,lf,0.7,rt);\n\trk=jsolve(b2,rf,0.7,rt);\n\tfloat TR=0.15;\n\tvec3 n=vec3(TR,0.0,-TR*0.5);\n\tzStack(Segment(b1-ro,b2-b1,TR,rd),px);\n\tTR*=0.75;\n\tzStack(Segment(lk-ro,b2-n.xyy-lk,TR,rd),px);\n\tzStack(Segment(rk-ro,b2+n.xyy-rk,TR,rd),px);\n\tTR*=0.75;\n\tzStack(Segment(lf-ro,lk-lf,TR,rd),px);\n\tzStack(Segment(rf-ro,rk-rf,TR,rd),px);\n\tTR*=0.75;\n\tzStack(Segment(le-ro,b1-n.xyy-le,TR,rd),px);\n\tzStack(Segment(re-ro,b1+n.xyy-re,TR,rd),px);\n\tTR*=0.75;\n\tzStack(Segment(lh-ro,le-lh,TR,rd),px);\n\tzStack(Segment(rh-ro,re-rh,TR,rd),px);\n\tTR*=0.75;\n\tmat3 mx=lookat(vec3(st2*ct,0.25*(st2+st),1.0),vec3(0.25*st2*st,1.0,0.25*st2*ct));\n\tvec3 n1=vec3(0.0,0.25+h,0.0)*mx,h1=vec3(-0.4,0.25+h,0.0)*mx,h2=vec3(-0.4,0.75+h,0.0)*mx;\n\tvec3 h3=vec3(0.4,0.75+h,0.0)*mx,h4=vec3(0.4,0.25+h,0.0)*mx;\n\t\n\tn=vec3(0.0,0.0,1.0)*mx;\n\tfloat t=-dot(n,ro)\/dot(n,rd);\n\tif(t>0.0){\n\t\tvec3 p=mx*(ro+rd*t);\n\t\tp.y-=h;\n\t\tif(p.x>-0.4 && p.x<0.4 && p.y>0.25 && p.y<0.75){\n\t\t\tcol=texture2D(iChannel0,vec2(1.25,2.0)*(p.xy+vec2(0.4,-0.25))).rgb;\n\t\t}\n\t}\n\tzStack(Segment(b1-ro,n1-b1,TR,rd),px);\n\tzStack(Segment(h1-ro,h2-h1,TR,rd),px);\n\tzStack(Segment(h2-ro,h3-h2,TR,rd),px);\n\tzStack(Segment(h3-ro,h4-h3,TR,rd),px);\n\tzStack(Segment(h1-ro,h4-h1,TR,rd),px);\n\t\n\tcol=Light(I2,rd,px,col);\n\tcol=Light(I1,rd,px,col);\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord.xy-iResolution.xy)\/ iResolution.y;\n\tfloat tm=iGlobalTime*0.1;\n\tvec3 ro=vec3(sin(tm),0.0,cos(tm)*3.0);\n\ttm=abs(sin(tm*1.5));\n\tvec3 up=vec3(1.0-tm,1.0,0.0);\n\tvec3 rd=lookat(-ro,up)*normalize(vec3(uv,1.0));\n \tvec3 col=tunnel(rd);\n\tcol=britbot(ro,rd,col);\n\tfragColor = vec4(col,1.0);\n}","name":"","description":"","type":"image"}]}}