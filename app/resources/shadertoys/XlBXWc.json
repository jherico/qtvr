{"Shader":{"ver":"0.1","info":{"id":"XlBXWc","date":"1446777372","viewed":529,"name":"2015\/11\/05","username":"hughsk","description":"Trying out voxel raytracing for kicks, click and drag to change the terrain. Initial technique sourced from here: https:\/\/www.shadertoy.com\/view\/4dfGzs","likes":14,"published":3,"flags":0,"tags":["3d","sdf","voxel"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"vec2 noiseOffset = iMouse.z > 0.0\n  ? iMouse.xy * 0.005\n  : vec2(0.0);\n\nvec2 squareFrame_6_0(vec2 screenSize, vec2 coord) {\n  vec2 position = 2.0 * (coord.xy \/ screenSize.xy) - 1.0;\n  position.x *= screenSize.x \/ screenSize.y;\n  return position;\n}\n\n\n\nmat3 calcLookAtMatrix_8_1(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\n\n\n\nvec3 getRay_7_2(mat3 camMat, vec2 screenPos, float lensLength) {\n  return normalize(camMat * vec3(screenPos, lensLength));\n}\n\nvec3 getRay_7_2(vec3 origin, vec3 target, vec2 screenPos, float lensLength) {\n  mat3 camMat = calcLookAtMatrix_8_1(origin, target, 0.0);\n  return getRay_7_2(camMat, screenPos, lensLength);\n}\n\n\n\n\nvoid orbitCamera_2_3(\n  in float camAngle,\n  in float camHeight,\n  in float camDistance,\n  in vec2 screenResolution,\n  out vec3 rayOrigin,\n  out vec3 rayDirection,\n  in vec2 fragCoord\n) {\n  vec2 screenPos = squareFrame_6_0(screenResolution, fragCoord);\n  vec3 rayTarget = vec3(0.0);\n\n  rayOrigin = vec3(\n    camDistance * sin(camAngle),\n    camHeight,\n    camDistance * cos(camAngle)\n  );\n\n  rayDirection = getRay_7_2(rayOrigin, rayTarget, screenPos, 2.0);\n}\n\n\n\n\/\/\n\/\/ Description : Array and textureless GLSL 2D\/3D\/4D simplex\n\/\/               noise functions.\n\/\/      Author : Ian McEwan, Ashima Arts.\n\/\/  Maintainer : ijm\n\/\/     Lastmod : 20110822 (ijm)\n\/\/     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n\/\/               Distributed under the MIT License. See LICENSE file.\n\/\/               https:\/\/github.com\/ashima\/webgl-noise\n\/\/\n\nvec3 mod289_1_4(vec3 x) {\n  return x - floor(x * (1.0 \/ 289.0)) * 289.0;\n}\n\nvec4 mod289_1_4(vec4 x) {\n  return x - floor(x * (1.0 \/ 289.0)) * 289.0;\n}\n\nvec4 permute_1_5(vec4 x) {\n     return mod289_1_4(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_1_6(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise_1_7(vec3 v)\n  {\n  const vec2  C = vec2(1.0\/6.0, 1.0\/3.0) ;\n  const vec4  D_1_8 = vec4(0.0, 0.5, 1.0, 2.0);\n\n\/\/ First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n\/\/ Other corners\n  vec3 g_1_9 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_1_9;\n  vec3 i1 = min( g_1_9.xyz, l.zxy );\n  vec3 i2 = max( g_1_9.xyz, l.zxy );\n\n  \/\/   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  \/\/   x1 = x0 - i1  + 1.0 * C.xxx;\n  \/\/   x2 = x0 - i2  + 2.0 * C.xxx;\n  \/\/   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; \/\/ 2.0*C.x = 1\/3 = C.y\n  vec3 x3 = x0 - D_1_8.yyy;      \/\/ -1.0+3.0*C.x = -0.5 = -D.y\n\n\/\/ Permutations\n  i = mod289_1_4(i);\n  vec4 p = permute_1_5( permute_1_5( permute_1_5(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n\/\/ Gradients: 7x7 points over a square, mapped onto an octahedron.\n\/\/ The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; \/\/ 1.0\/7.0\n  vec3  ns = n_ * D_1_8.wyz - D_1_8.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  \/\/  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    \/\/ mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  \/\/vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  \/\/vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1_1_10 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0_1_11 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1_1_10.xy,h.z);\n  vec3 p3 = vec3(a1_1_10.zw,h.w);\n\n\/\/Normalise gradients\n  vec4 norm = taylorInvSqrt_1_6(vec4(dot(p0_1_11,p0_1_11), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_1_11 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n\/\/ Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0_1_11,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\n\nfloat orenNayarDiffuse_5_12(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float albedo) {\n  \n  float LdotV = dot(lightDirection, viewDirection);\n  float NdotL = dot(lightDirection, surfaceNormal);\n  float NdotV = dot(surfaceNormal, viewDirection);\n\n  float s = LdotV - NdotL * NdotV;\n  float t = mix(1.0, max(NdotL, NdotV), step(0.0, s));\n\n  float sigma2 = roughness * roughness;\n  float A = 1.0 + sigma2 * (albedo \/ (sigma2 + 0.13) + 0.5 \/ (sigma2 + 0.33));\n  float B = 0.45 * sigma2 \/ (sigma2 + 0.09);\n\n  return albedo * max(0.0, NdotL) * (A + B * s \/ t) \/ 3.14159265;\n}\n\n\nfloat gaussianSpecular_3_13(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float shininess) {\n  vec3 H = normalize(lightDirection + viewDirection);\n  float theta = acos(dot(H, surfaceNormal));\n  float w = theta \/ shininess;\n  return exp(-w*w);\n}\n\n\nfloat fogFactorExp2_4_14(\n  const float dist,\n  const float density\n) {\n  const float LOG2 = -1.442695;\n  float d = density * dist;\n  return 1.0 - clamp(exp2(d * d * LOG2), 0.0, 1.0);\n}\n\n\n\n  \nfloat voxelModel(vec3 p) {\n  return 5.0 * snoise_1_7(p.xyz * 0.05 + vec3(0, noiseOffset.x * sin(noiseOffset.y), 0)) - p.y > 8.0 ? 1.0 : 0.0;\n}\n  \nvec2 raymarchVoxel(vec3 ro, vec3 rd, out vec3 nor) {\n  vec3 pos = floor(ro);\n  vec3 ri = 1.0 \/ rd;\n  vec3 rs = sign(rd);\n  vec3 dis = (pos - ro + 0.5 + rs * 0.5) * ri;\n  \n  float res = -1.0;\n  vec3 mm = vec3(0.0);\n  \n  for (int i = 0; i < 96; i++) {\n    float k = voxelModel(pos);\n    if (k > 0.5) {\n      res = k;\n      break;\n    }\n     \n    mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\tdis += mm * rs * ri;\n    pos += mm * rs;\n  }\n  \n  if (res < -0.5) {\n    return vec2(-1.0);\n  }\n  \n  nor = -mm * rs;\n  \n  vec3 vpos = pos;\n  vec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n  float t = max(mini.x, max(mini.y, mini.z));\n  \n  return vec2(t, 0.0);\n}\n\nfloat attenuate(float d) {\n  return pow(clamp(1.0 - d \/ 60.0, 0.0, 1.0), 2.95);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord.xy \/ iResolution.xy * 2.0 - 1.0;\n  vec3 color = vec3(1.1, 0.98, 1.3);\n  vec3 ro, rd;\n\n  float rotation = sin(iGlobalTime * 0.124) * 3.3;\n  float height   = 2.0 + (sin(iGlobalTime) * 0.5 + 0.5) * 0.5;\n  float dist     = 4.0;\n  orbitCamera_2_3(rotation, height, dist, iResolution.xy, ro, rd, fragCoord);\n  \n  ro.z -= iGlobalTime * 10.;\n\n  vec3 nor;\n  vec2 t = raymarchVoxel(ro, rd, nor);\n  if (t.x > -0.5) {\n    vec3 pos = ro + rd * t.x;\n    vec3 mat = abs(fract(pos + 0.5));\n    \n    mat = fract(smoothstep(-0.3, 0.15, mat - 0.5) + 0.5);\n    mat = pow(1.0 - (mat) * 4., vec3(0.8));\n    mat = 1.0 - clamp(vec3(mat.x * mat.y + mat.y * mat.z + mat.x * mat.z), 0.2, 0.35);\n    \n    vec3 lpos1 = ro + vec3(sin(iGlobalTime) * 5., cos(iGlobalTime) * 5., 2.);\n    vec3 lcol1 = vec3(1, 0.5, 0.3) * 3.;\n    vec3 ldir1 = normalize(lpos1 - pos);\n    float att1 = attenuate(length(lpos1 - pos));\n    float dif1 = orenNayarDiffuse_5_12(ldir1, -rd, nor, 0.3, 1.0);\n    float spc1 = gaussianSpecular_3_13(ldir1, -rd, nor, 2.25) * 0.5;\n    vec3 lpos2 = ro + vec3(cos(iGlobalTime) * 3., sin(iGlobalTime) * 3., 2.);\n    vec3 lcol2 = vec3(0.3, 0.5, 0.9) * 1.9;\n    vec3 ldir2 = normalize(lpos2 - pos);\n    float att2 = attenuate(length(lpos2 - pos));\n    float dif2 = orenNayarDiffuse_5_12(ldir2, -rd, nor, 0.3, 1.0);\n    float spc2 = gaussianSpecular_3_13(ldir2, -rd, nor, 2.25) * 0.5;\n    \n    color = mix(color,\n      att1 * lcol1 * (spc1 + dif1 * mat) +\n      att2 * lcol2 * (spc2 + dif2 * mat) ,\n      1.0 - fogFactorExp2_4_14(t.x, 0.028 - pos.y * 0.001)\n    );\n  }\n\n  color.r *= 1.0 - dot(uv, uv) * 0.15;\n  color.r = smoothstep(0.1, 1.0, color.r);\n  \n  fragColor.rgb = color;\n  fragColor.a   = 1.0;\n}","name":"","description":"","type":"image"}]}}