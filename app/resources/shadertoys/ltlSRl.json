{"Shader":{"ver":"0.1","info":{"id":"ltlSRl","date":"1439049423","viewed":2355,"name":"Life of a tree","username":"adam27","description":"Tree and leaves rendered with distance fields.","likes":18,"published":3,"flags":0,"tags":["3d","raymarching","distancefield","tree","leaf","nature","warsztat","leaves"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\n\/\/ Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst int MAX_STEPS = 100;\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nstruct Distance\n{\n\tfloat value;\n\tvec3 color;\n};\n\nstruct Hit\n{\n\tbool is;\n\tvec3 pos;\n\tvec3 color;\n};\n    \nmat4 rotateX(float angle)\n{\n\tangle = -angle\/180.0*3.1415926536;\n    float c = cos(angle);\n    float s = sin(angle);\n\treturn mat4(1.0, 0.0, 0.0, 0.0, 0.0, c, -s, 0.0, 0.0, s, c, 0.0, 0.0, 0.0, 0.0, 1.0);\n}\nmat4 rotateY(float angle)\n{\n\tangle = -angle\/180.0*3.1415926536;\n    float c = cos(angle);\n    float s = sin(angle);\n\treturn mat4(c, 0.0, s, 0.0, 0.0, 1.0, 0.0, 0.0, -s, 0.0, c, 0.0, 0.0, 0.0, 0.0, 1.0);\n}\nmat4 rotateZ(float angle)\n{\n\tangle = -angle\/180.0*3.1415926536;\n    float c = cos(angle);\n    float s = sin(angle);\n\treturn mat4(c, -s, 0.0, 0.0, s, c, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n}\nmat4 translate(vec3 t)\n{\n\treturn mat4(1.0, 0.0, 0.0, -t.x, 0.0, 1.0, 0.0, -t.y, 0.0, 0.0, 1.0, -t.z, 0.0, 0.0, 0.0, 1.0);\n}\n\nvec3 repeat(vec3 p, vec3 s)\n{\n\treturn mod(p, s) - s\/2.0;\n}\n    \n    \nfloat sphere(vec3 p, float d)\n{ \n    return length(p) - d\/2.0;  \n}\n\nfloat box(vec3 p, vec3 s)\n{ \n    vec3 w = abs(p) - s\/2.0;\n    return min(max(w.x,max(w.y,w.z)),0.0) + length(max(w,0.0));   \n}\n\nfloat capsule(vec3 p, float h, float d)\n{\n    float x = clamp(p.y\/h, 0.0, 1.0);\n    return length(p - vec3(0.0, h*x, 0.0)) - d*0.5;\n}\n    \nDistance add(Distance d1, Distance d2)\n{\n    if (d2.value > d1.value)\n        return d1;\n    else\n        return d2;\n}\n\nDistance smooth_add(Distance d1, Distance d2, float k)\n{\n    float a = d1.value;\n    float b = d2.value;\n    float h = clamp(0.5+0.5*(b-a)\/k, 0.0, 1.0);\n    return Distance(mix(b, a, h) - k*h*(1.0-h), mix(d2.color, d1.color, pow(h, 2.0)));\n}\n\nDistance intersection(Distance d1, Distance d2)\n{\n\tif (d1.value > d2.value)\n\t\treturn d1;\n\telse\n\t\treturn d2;\n}\n    \nDistance distance(vec3 p0)\n{         \n    vec4 p = vec4(p0, 1.0);\n    mat4 m;   \n    \n        \n    vec3 color = vec3(0.7, 0.52, 0.4) * 0.7;\/\/ * (sin(p.x*30.0)*sin(p.y*2.0)*sin(p.z*30.0)*0.1+0.7);    \n    \n    Distance d = Distance(sphere(p0 + vec3(0.0, 100.0, 0.0), 200.0) + sin(p.x\/2.0)*cos(p.z\/2.0)\/2.0, vec3(0.2, 0.8, 0.5));\n    \n    \n    d = smooth_add(d, Distance(capsule(p.xyz, 3.0, 0.6), color), 0.8);     \n    \n    p *= rotateY(sin(iGlobalTime)*2.0+sin(p.y)*2.0); \n    m = translate(vec3(0.0, 3.0, 0.0)) * rotateY(40.0) * rotateX(35.0);    \n    p.x = abs(p.x) - 0.05;\n    p.z = abs(p.z) - 0.05;    \n    p = p * m;    \n    d = smooth_add(d, Distance(capsule(p.xyz, 2.0, 0.4), color), 0.1); \n    \n    p *= rotateY(10.0+sin(iGlobalTime+p.x)*5.0+sin(p.x)*5.0);    \n    m = translate(vec3(0.0, 2.0, 0.0)) * rotateY(45.0) * rotateX(30.0);    \n    p.x = abs(p.x) - 0.03;\n    p.z = abs(p.z) - 0.03;\n    p = p * m;    \n    d = smooth_add(d, Distance(capsule(p.xyz, 1.5, 0.2), color), 0.1); \n    \n    p *= rotateY(15.0+sin(iGlobalTime+p.z)*8.0+cos(p.z)*8.0);  \n    m = translate(vec3(0.0, 1.5, 0.0)) * rotateY(55.0+sin(p.x)*10.0) * rotateX(35.0);    \n    p.x = abs(p.x) - 0.01;\n    p.z = abs(p.z) - 0.01;\n    p = p * m;    \n    d = smooth_add(d, Distance(capsule(p.xyz, 2.3, 0.08), color), 0.1); \n    \n    \n    float leafSize = min(sin(iGlobalTime \/ 3.0) * 0.06 + 0.11, 0.15);\n    vec3 leafColor = hsv2rgb(vec3(cos((iGlobalTime) \/ 3.0 + sin((p.x+p.y+p.z)*5.0)\/3.0) * 0.14 + 0.18, 0.7, 0.8));\n    \n    vec4 r = p;\n    r.x = abs(r.x);\n    r.z = abs(r.z);\n    Distance leafs = Distance(max(sphere(repeat((r.xyz+vec3(0.0, 0.09, 0.1))\/vec3(1.0, 2.0, 1.0)-vec3(0.05), vec3(0.19, 0.2, 0.19)), leafSize), box(p.xyz, vec3(0.03, 4.6, 0.2))), leafColor);\n    d = add(d, leafs);\n    \n    p *= rotateY(10.0+sin(iGlobalTime+r.x)*10.0+sin(r.x)*10.0);  \n    m = translate(vec3(0.0, 1.0, 0.0)) * rotateY(55.0) * rotateX(40.0);    \n    p.x = abs(p.x) - 0.01;\n    p.z = abs(p.z) - 0.01;\n    p = p * m;    \n    d = smooth_add(d, Distance(capsule(p.xyz, 1.2, 0.04), color), 0.1); \n    \n    p.x = abs(p.x);\n    p.z = abs(p.z);\n    leafs = Distance(max(sphere(repeat((p.xyz+vec3(0.0, 0.0, 0.1))\/vec3(1.0, 2.0, 1.0)-vec3(0.05), vec3(0.19, 0.2, 0.19)), leafSize), box(p.xyz, vec3(0.03, 2.5, 0.2))), leafColor);\n    d = add(d, leafs); \n    \n    \n    return d;\n}\n\nHit castRay(inout vec3 p, vec3 dir)\n{\t\n\tHit hit;\n\tDistance dist = distance(p);\n\tfloat eps = 0.001;\n\t\n\tfor (int i = 0; i < MAX_STEPS; i++)\n\t{\n\t\tDistance dist = distance(p);\n\t\tfloat d = dist.value;\n                \n\t\tif (d <= eps)\n\t\t{\n            hit.is = true;\n            hit.pos = p;\n            hit.color = dist.color * (1.0 - float(i) \/ float(MAX_STEPS));\n            return hit;\n\t\t}\n        \n\t\tp += dir*d*0.9;\n\t}\t\n\thit.is = false;\n\thit.color = vec3(0);\n\treturn hit;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 angle = vec2(-iMouse.x\/200.0+2.2, radians(25.0));\n    vec3 center = vec3(0.0, 4.0, 0.0);\n    float zoom = 10.0;\n    \n    vec3 p = vec3(cos(angle.x)*cos(angle.y), sin(angle.y), sin(angle.x)*cos(angle.y));\n\tvec2 uv = (fragCoord.xy) \/ iResolution.yy - vec2(iResolution.x \/ iResolution.y \/ 2.0, 0.5);\n    \n    vec3 tx = vec3(-sin(angle.x), 0.0, cos(angle.x));\n    vec3 ty = vec3(-cos(angle.x)*sin(angle.y), cos(angle.y), -sin(angle.x)*sin(angle.y));\n    \n    vec3 p2 = p * 0.8;\n    p = p * zoom + center;\n    \n    vec3 dir = tx * uv.x + ty * uv.y - p2;\n    \n    vec3 color = vec3(0.0);\n    vec3 light = normalize(vec3(-0.6, 0.8, -0.3));\n    \n    \n\tHit hit = castRay(p, dir);\n    \n\tif (hit.is)\n    {        \n        vec3 normal;\n\t\tfloat eps = 0.001;\n        normal.x = distance(p + vec3(eps,0,0)).value - distance(p - vec3(eps,0,0)).value;\n        normal.y = distance(p + vec3(0,eps,0)).value - distance(p - vec3(0,eps,0)).value;\n        normal.z = distance(p + vec3(0,0,eps)).value - distance(p - vec3(0,0,eps)).value;\n        normal = normalize(normal);\n        vec3 c = mix(hit.color, vec3(0.8), normal.y * pow(1.0 - (cos(iGlobalTime \/ 3.0 - 1.5) \/ 2.0 + 0.5), 4.0) * (sign(hit.pos.y - 1.0) \/ 2.0 + 0.5));\n\t\tcolor = c * (max(dot(normal, light), 0.0) * 0.8 + 0.4) * min(5.0\/length(p-vec3(0.0, 5.0, 0.0)), 2.0);\n        \n    }\n\telse\n\t\tcolor = vec3(0);\n\t\n    \n    fragColor = vec4(color, 1.0);\n}","name":"","description":"","type":"image"}]}}