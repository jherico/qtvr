{"Shader":{"ver":"0.1","info":{"id":"ltlXzl","date":"1439081837","viewed":1299,"name":"[SIG15] Fight Club End Scene","username":"movAX13h","description":"With your feet in the air and your head on the ground, try this trick and spin it, yeah.<br\/>Partial making of (screen capture of movAX13h, 30 videos): http:\/\/bit.ly\/1IC3exn","likes":24,"published":3,"flags":8,"tags":["explosion","text","raymarcher","sig15"],"hasliked":0},"renderpass":[{"inputs":[{"id":4,"src":"\/presets\/tex03.jpg","ctype":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":6,"src":"\/presets\/tex05.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":8,"src":"\/presets\/tex07.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":10,"src":"\/presets\/tex09.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/*====================================================================\n[SIG15] Fight Club End Scene\n\tfragment shader by movAX13h and srtuss\n\tsound shader by srtuss\n\t19.July - 10.August 2015\n======================================================================\nMaking of (screen capture of movAX13h,30 videos):http:\/\/bit.ly\/1IC3exn\n======================================================================\n\n\tSCRIPT:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   FADE IN\n\t\t\t\t\t\t\t\tJACK\n                     Trust me. Everything's gonna be fine.\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   MUSIC START\n\t\t\t\t\t\t\t\t\t\t\t\t      EXPLOSIONS START\n\n\tMASSIVE EXPLOSION... the glass walls rattle...\n         Jack and Marla look -- OUT THE WINDOWS: a BUILDING EXPLODES;\n         collapsing upon itself.  Then, ANOTHER BUILDING IMPLODES\n         into a massive cloud of dust.  Jack and Marla are\n         silhouetted against the SKYLINE.  Jack,\n         reaches to take her hand.\n\n                                JACK\n                     I'm sorry... you met me at a very\n                     strange time in my life.\n\n         ANOTHER BUILDING IMPLODES and COLLAPSES\n         inward... and ANOTHER BUILDING... and ANOTHER ...\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tMUSIC FADE OUT\n                                                              FADE OUT\n\n======================================================================*\/\n\n#define ROOM\n#define ROOM_SHADOW\n#define CITY\n#define EXPLOSIONS\n#define PARTICLES\n#define FLASH_AND_SHAKE\n#define SILHOUETTES\n#define TEXT\n#define BACK\n#define POST\n\n\/\/======================================================================\n\n#define resolution iResolution\n#define mouse iMouse\n\n#define pi  3.14159265358979323846264338328\n#define pi2 6.28318530717958647692528676656\n#define pih 1.5707963267949\n\n#define eStart 18.0\n#define wtcStart 12.0\n\nfloat time = iGlobalTime;\/\/ - smoothstep(eStart+wtcStart+6.0, eStart+wtcStart+16.0, iGlobalTime)*iGlobalTime;\nfloat et1 = max(0.0, time-eStart); \nfloat ef1 = max(0.0, time-eStart+0.3);\n\n#ifdef FLASH_AND_SHAKE\nvec2 constShake = (fract(sin(vec2(time, time - 2.0) * 42.412) * 28972.0) - 0.5);\nvec2 shake = smoothstep(0.0, 1.0, et1-0.3)*smoothstep(wtcStart+2.0, wtcStart-4.0, et1)*constShake;\n#else\nvec2 constShake = vec2(0.0);\nvec2 shake = vec2(0.0);\n#endif\n\n\/\/ == helpers ============================================================\nfloat ctri(float x, float s) {return abs(fract(x \/ s + 0.5) - 0.5) * s;}\nvec2 ctri(vec2 x, vec2 s) {return abs(fract(x \/ s + 0.5) - 0.5) * s;}\nvec2 ctri2(vec2 x, vec2 s) {return (fract(x \/ s + 0.5) - 0.5) * s;}\nfloat ctriid(float x, float s) {return floor(x \/ s + 0.5);}\nvec2 ctriid(vec2 x, vec2 s) {return floor(x \/ s + 0.5);}\nvec3 ctriid(vec3 x, vec3 s) {return floor(x \/ s + 0.5);}\nfloat rrect(vec2 p, vec2 sz) {return length(max(abs(p) - sz, vec2(0.0)));}\nfloat rmax(vec2 p) {return max(p.x, p.y);}\nvec2 rotate(vec2 p, float a) { return vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a)); }\n\n\/\/ == silhouettes ========================================================\n#define FXA(uv) (texture2D(iChannel1, uv).x - 0.5)\n#ifdef SILHOUETTES\nfloat silhouettes(vec2 uv)\n{\n    float a = smoothstep(4.0, 5.0, et1);\n    \n    uv.x += 0.22;\n    uv.y += 0.22;\n    uv *= 2.8-et1*0.01;\n    \n    vec2 p = uv;\n    vec2 q = abs(p);\n    float v, w;\n    \n    \/\/ jack\n    float r = -0.2-0.1*a;\n    \n    v = rrect(q, vec2(0.23, 0.54)) - 0.05 + FXA(uv * 0.1 - 0.599) * 0.15;\n    w = dot(vec2(abs(p.x), p.y - 0.77), normalize(vec2(1.0, 1.2)));\n    w = max(w, 0.7 - p.y) + FXA(uv * 0.1 - 0.2) * 0.15;\n    v = min(v, w);\n    \n    w = length(rotate((p - vec2(0.04, 0.94)), 0.2) * vec2(1.3, 1.0)) - 0.11 + FXA(uv * 0.2 + 0.1) * 0.15;\n    v = min(v, w);\n    \n    q = abs(p - vec2(-0.08, -0.6));\n    w = rrect(q, vec2(0.0, 0.2)) - 0.035 + FXA(uv * 0.1 - 0.1) * 0.1;\n    v = min(v, w);\n    \n    q = abs(rotate(p - vec2(-0.05, -1.1), -0.08));\n    w = rrect(q, vec2(0.0, 0.28)) - 0.02 + FXA(uv * 0.11 - 0.13) * 0.1;\n    v = min(v, w);\n    \n    vec2 qq = rotate(p - vec2(-0.05, -1.39), -1.3);\n    q = abs(qq);\n    w = max(rrect(q, vec2(0.0, 0.05)) - 0.02, 0.01 - qq.x) + FXA(uv * 0.1 - 0.64) * 0.1;\n    v = min(v, w);\n    \n    q = abs(rotate(p - vec2(0.13, -0.6), -0.1));\n    w = rrect(q, vec2(0.0, 0.2)) - 0.065 + FXA(uv * 0.12 + 0.5) * 0.05;\n    v = min(v, w);\n    \n    q = abs(rotate(p - vec2(0.14, -1.1), 0.05));\n    w = rrect(q, vec2(0.0, 0.28)) - 0.02 + FXA(uv * 0.11 - 0.14) * 0.1;\n    v = min(v, w);\n    \n    qq = rotate(p - vec2(0.14, -1.36), 0.4);\n    q = abs(qq);\n    w = rrect(q, vec2(0.0, 0.05)) - 0.02 + FXA(uv * 0.1 - 0.64) * 0.1;\n    v = min(v, w);\n    \n    q = rotate(p - vec2(-0.22, .1), -0.09);\n    w = length(q * vec2(3.0, 1.0)) - 0.49 + FXA(uv * 0.15 - 0.15) * 0.1;\n    v = min(v, w);\n    \n    q = abs(rotate(p - vec2(0.36, 0.2), r)); \/\/ upper arm\n    w = rrect(q, vec2(0.0, 0.35)) - 0.03 + FXA(uv * 0.11 - 0.14) * 0.1;\n    v = min(v, w);\n    \n    q = abs(rotate(p - vec2(0.16-r, -0.12), r-0.2)); \/\/ lower arm\n    w = rrect(q, vec2(0.0, 0.15)) - 0.03 + FXA(uv * 0.11 - 0.14) * 0.1;\n    v = min(v, w);\n    \n    \n    \/\/ marla\n    r = 0.3+0.08*a;\n    \n    q = abs(rotate(p - vec2(1.1, -0.12), 0.05)); \/\/ body\n    w = rrect(q, vec2(0.18, 0.55)) - 0.05 + FXA(uv * -0.05 - 0.1) * 0.15;\n    v = min(v, w);\n    \n    q = abs(rotate(p - vec2(1.15, 0.3), 0.2)); \/\/ neck\n    w = rrect(q, vec2(0.1, 0.2)) - 0.05 + FXA(uv * 0.05 - 0.3) * 0.15;\n    v = min(v, w);\n    \n    qq = rotate(p-vec2(1.04-r+0.33,-0.05), r); \/\/ arm\n    q = abs(qq);\n    w = max(max(rrect(q, vec2(0.1, 0.3)) - 0.32, qq.x + 0.13), -0.3 - qq.y)\n        + FXA(uv * 0.4 + vec2(0.24, -0.1)) * 0.1 + 0.03;\n    v = min(v, w);\n    \n    q = abs(p - vec2(1.15, 0.8)); \/\/ head\n    w = rrect(q, vec2(0.035, 0.07)) - 0.083 + FXA(uv * 0.4 - 0.33) * 0.15;\n    v = min(v, w);\n    \n    q = p - vec2(1.35, 0.09);\n    w = length(q * vec2(2.5, 1.0)) - 0.43 + FXA(uv * 0.4 - 0.15) * 0.1;\n    v = min(v, w);\n    \n    q = abs(rotate(p - vec2(1.09, -1.0), 0.05));\n    w = rrect(q, vec2(0.0, 0.28)) - 0.01 + FXA(uv * 0.11 - 0.15) * 0.1;\n    v = min(v, w);\n    \n    q = abs(rotate(p - vec2(1.24, -1.0), -0.02));\n    w = rrect(q, vec2(0.0, 0.28)) - 0.01 + FXA(uv * 0.03 - 0.21) * 0.1;\n    v = min(v, w);\n    \n    qq = rotate(p - vec2(1.08, -1.29), 0.0);\n    q = abs(qq);\n    w = rrect(q, vec2(0.03, 0.06)) - 0.005 + FXA(uv * 0.1 - 0.15) * 0.1;\n    v = min(v, w);\n    \n    qq = rotate(p - vec2(1.23, -1.3), 0.2);\n    q = abs(qq);\n    w = rrect(q, vec2(0.03, 0.06)) + 0.002 + FXA(uv * 0.1 - 0.254) * 0.1;\n    v = min(v, w);\n   \n    return v;\n}\n#endif\n\n\/\/ == textures ===========================================================\nfloat tex1(vec2 p, float ps)\n{\n    vec2 q = ctri(p, vec2(0.5));\n    vec2 q1 = ctri2(p, vec2(0.5));\n    vec2 z = ctriid(p, vec2(0.5));\n    float id = step(fract(sin(z.x * 124.123 + z.y) * 129867.253), 0.5);\n    float v0 = max(q.x - 0.15, q.y - 0.15);\n    float v1 = v0 - 0.005;\n    v1 = max(v1, -v0);\n    float tmp = min(q1.y + 0.07, q.x - 0.005);\n    float w = max(tmp, v0);\n    v1 = min(v1, w);\n\n    float cm = texture2D(iChannel1, p*0.1).x * 0.5 * id + 0.3;\n\n    float c = 0.2;\n    c = mix(c, cm, smoothstep(ps, 0.0, v0));\n    c = mix(c, 0.1, smoothstep(ps, 0.0, v1));\n    return c;\n}\nfloat tex2_msk(vec2 id)\n{\n    float v = fract(sin(id.x * 121.298672 + id.y) * 296235.16712);\n    float v2 = fract(sin(floor(id.x * 0.11 + id.y * 0.14) * 121.298672 + id.y) * 296235.16712);\n    return step(0.5, (v2 * (sin(id.y * 0.4-1.9) * 0.3 + 0.7) - (v - 0.5) * 0.5));\n}\nfloat tex2(vec2 p, float ps)\n{\n    if (p.y < 0.06) return 0.2;\n\n    p.y *= 20.0;\n    p.x *= 10.0;\n\n    vec2 sz = vec2(0.5);\n    vec2 q = ctri(p, sz);\n    vec2 q1 = ctri2(p, sz);\n    vec2 z = ctriid(p, sz);\n\n    float v0 = q.y - 0.21;\n    float v1 = abs(q1.x) - 0.08;\n\n    float c = 0.2;\n    c = mix(c, smoothstep(wtcStart+1.2, wtcStart+1.0, et1-0.8*step(-0.3, p.x))*tex2_msk(z) * 0.6 + 0.15, smoothstep(ps, 0.0, rmax(abs(q) - vec2(0.17, 0.23))));\n    return c;\n}\nfloat tex3(vec2 p)\n{\n    if (p.y < 0.06) return 0.24; \/\/ roof\n    p*=1.6;\n    float c = 0.1;\n    float a = mod(p.y, 0.12);\n    c = mix(0.2, 0.5, step(mod(p.x,0.4), 0.05));\n    float d = mix(0.56, 0.4, smoothstep(0.002, 0.01, mod(p.y+0.003,0.03)));\n    c = mix(c,d, smoothstep(0.05, 0.075, a));\n    return c;\n}\nfloat tex4(vec2 p)\n{\n    if (p.y < 0.02) return 0.24; \/\/ roof\n    p.y -= 0.2;\n    p.y *= 1.4;\n    float c = tex1(-8.0*p, 0.001);\n    c = mix(0.24, c, smoothstep(0.18,0.22, mod(p.x-0.18,0.5))); \/\/ vertical flat\n    return c;\n}\n\n\n\/\/ == interior ===========================================================\nvec3 sunPos = vec3(1.0, 7.0, 15.0);\nvec3 sun = normalize(sunPos);\nfloat focus = 5.0;\nfloat far = 30.0;\n\nstruct Hit\n{\n\tfloat d;\n\tvec3 color;\n\tfloat edge;\n    float spec;\n};\n\n#define CONCRETE_COLOR vec3(0.9, 0.9, 0.9)\n#define CONCRETE_SPEC 0.4\n#define WINDOW_BARS_COLOR vec3(0.01,0.01,0.01)\n#define WINDOW_BARS_SPEC 0.6\n#define INTERIOR_COLOR vec3(0.1)\n#define INTERIOR_SPEC 0.8\n\n#ifdef ROOM\nfloat sdBox( vec3 p, vec3 b ) \n{\t\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n    \nfloat interior(vec3 p)\n{\n    float d1 = sdBox(p-vec3(-1.2,0.3,-6.5),vec3(1.1,0.7,0.4));\n    d1 = min(d1, sdBox(p-vec3(-1.76,1.1,-6.5),vec3(0.5,0.17,0.2)));\n    return d1;\n}\n   \nHit scene(vec3 p0)\n{\n\tfloat d = 10000.0, d1, e = 0.04;\n    float spec = CONCRETE_SPEC;\n\tvec3 col = vec3(0.0);\n    \n    \/\/ floor\n    d1 = sdBox(p0-vec3(0.0,-0.92,-19.5),vec3(20.0,0.8,20.0)); \n    if (d1 < d) \n    { \n        d = d1; \n        col = CONCRETE_COLOR; \n        spec = CONCRETE_SPEC;\n    }\n\n    \/\/ pillars\n    vec3 p1=vec3(mod(p0.x,8.0)-4.0,p0.y,p0.z); \n    d1 = sdBox(p1-vec3(1.0,0.6,-0.7),vec3(0.3,3.8,1.0)); \n    if (d1 < d) \n    { \n        d = d1; \n        col = CONCRETE_COLOR; \n        spec = CONCRETE_SPEC;        \n    }\n\n    \/\/ vertical bars\n    vec3 p2=vec3(mod(p0.x,2.0)-1.0,p0.y,p0.z); \n    d1 = sdBox(p2-vec3(0.0,0.0,0.5),vec3(0.04,8.0,0.04)); \n    if (d1 < d) \n    { \n        d = d1; \n        col = WINDOW_BARS_COLOR; \n        spec = WINDOW_BARS_SPEC;\n        e = 0.0;\n    }\n\n    \/\/ horizontal bars\n    vec3 p3=vec3(p0.x,mod(p0.y,3.4)-1.7,p0.z); \n    d1 = sdBox(p3-vec3(0.0,1.6,0.5),vec3(20.0,0.04,0.04)); \n    if (d1 < d) \n    { \n        d = d1; \n        col = WINDOW_BARS_COLOR; \n        spec = WINDOW_BARS_SPEC;\n        e = 0.0;\n    }\n\n    \/\/ top wall fragment\n    d1 = sdBox(p0-vec3(0.0,5.0,0.5),vec3(20.0,0.8,0.2)); \n    if (d1 < d) \n    { \n        \n        d = d1; \n        col = mix(CONCRETE_COLOR, WINDOW_BARS_COLOR, step(p0.y,4.22)); \n        spec = CONCRETE_SPEC;\n    }\n\n    \/\/ ceiling\n    d1 = sdBox(p0-vec3(1.0,5.2,-2.6),vec3(2.65,1.0,2.5)); \n    d1 = max(d1,-sdBox(p0-vec3(1.0,4.2,-2.6),vec3(2.2,0.17,2.0))); \n    d1 = max(d1,-sdBox(p0-vec3(1.0,4.2,-2.6),vec3(1.94,0.4,1.6))); \n    if (d1 < d) \n    { \n        d = d1; \n        col = CONCRETE_COLOR; \n        spec = CONCRETE_SPEC;        \n    }\n\t\n    if (p0.y > 0.0)\n    {\n        d1 = interior(p0);\n        if (d1 < d)\n        {\n            d = d1;\n            col = INTERIOR_COLOR;\n            spec = INTERIOR_SPEC;\n        }\n    }    \n\treturn Hit(d, col, e, spec);\n}\n\nvec3 normal(vec3 p)\n{\n\tfloat c = scene(p).d;\n\tvec2 h = vec2(0.01, 0.0);\n\treturn normalize(vec3(scene(p + h.xyy).d - c, \n\t\t\t\t\t\t  scene(p + h.yxy).d - c, \n\t\t                  scene(p + h.yyx).d - c));\n}\n\nfloat edges(vec3 p)\n{\n\tfloat acc = 0.0;\n\tfloat h = 0.01;\n\tacc += scene(p + vec3(-h, -h, -h)).d;\n\tacc += scene(p + vec3(-h, -h, +h)).d;\n\tacc += scene(p + vec3(-h, +h, -h)).d;\n\tacc += scene(p + vec3(-h, +h, +h)).d;\n\tacc += scene(p + vec3(+h, -h, -h)).d;\n\tacc += scene(p + vec3(+h, -h, +h)).d;\n\tacc += scene(p + vec3(+h, +h, -h)).d;\n\tacc += scene(p + vec3(+h, +h, +h)).d;\n\treturn acc \/ h;\n}\n\nvec3 colorize(Hit hit, vec3 n, vec3 dir, const in vec3 lightPos, vec3 pos)\n{\n\tfloat diffuse = 0.2*max(0.0, dot(n, lightPos));\n\t\n\tvec3 ref = normalize(reflect(dir, n));\n\tfloat specular = hit.spec*pow(max(0.0, dot(ref, lightPos)), 6.5);\n\n\tvec3 c = texture2D(iChannel3, pos.xz*0.2).rgb;\n    float i = 0.1*smoothstep(0.6, 0.9, 1.0-c.g);\n    c = mix(hit.color.rgb, c, i);    \n    \n\treturn  c +  \n\t\t\tdiffuse * vec3(0.9) +\n\t\t\tspecular * vec3(1.0);\n}\n#endif\n\n\/\/ == explosions =========================================================\n#define FXD(uv) texture2D(iChannel0, uv + seed).x\n#define FXE(uv) texture2D(iChannel2, uv - seed).y\n#define FXF(uv) texture2D(iChannel2, uv + seed, 4.0).y\n#define FXG(uv) texture2D(iChannel3, uv - seed).y\n#ifdef EXPLOSIONS\n\/\/ t (time in sec, effect lasts from 0-2s) \nvoid explosion(vec2 uv, inout vec3 col, float t, float size, float seed)\n{\n    uv \/= size;\n    float x = t - 0.1;\n    float iCore = exp(t * -20.0); \/\/exp(x * x * -200.0);\n    float szEx = smoothstep(0.2, 0.4, t) - smoothstep(0.4, 1.0, t) * 0.1;\n    float szEx2 = smoothstep(0.2, 0.4, t);\n    float flwEx = 1.0 - t * 0.5;\n    float flwCore = 1.0 - t * 0.2;\n    float iTotal = smoothstep(1.2, 0.5, t) * smoothstep(0.0, 0.01, t);\n    float iPrt = smoothstep(0.2, 0.5, t) * smoothstep(1.0, 0.5, t);\n    float szCorona = t;\n    float flwPrt = 1.0 - t * 0.4;\n    \n    float iPrt2 = smoothstep(0.2, 0.5, t) * smoothstep(0.6, 0.5, t);\n    float szCorona2 = t * 2.0;\n    float flwPrt2 = 1.0 - t * 0.8;\n    \n    t += seed;\n    \n    uv += (fract(sin(vec2(time, time - 2.0) * 42.412) * 28972.0) - 0.5) * 0.1 * szEx * iTotal;\n    \n    float v = length(uv), sum = 0.0;\n    sum = smoothstep(szEx * 0.6 + 0.1, 0.0,\n   \t\tv - szEx * 0.6\n        - FXF(rotate(uv * flwEx, t * 0.2) * 0.04) * 0.9 * szEx\n        - FXD(rotate(uv * flwEx, t * 0.4) * 0.2) * 0.2 * szEx                               \n        );\n    sum *= FXD(uv * flwEx * 0.02);\n    \n   \tsum -= smoothstep(1.0, 0.2, v + FXE(uv * 0.1 * flwCore) * 0.5) * FXE((uv - vec2(0.1, t)) * 0.02) * 3.0 * FXD(uv * 0.7 * flwCore);\n  \tsum = max(sum, 0.0);\n\n    sum += smoothstep(0.9, 0.0, v + 0.3 - iCore * 0.6);    \n    sum *= iTotal;\n    \n    sum += pow(FXG(uv * 0.5 * flwPrt), 5.0) * iPrt * smoothstep(0.04, 0.0, v - szCorona - 0.7);\n    sum += pow(FXG(-uv * 0.5 * flwPrt2 - 0.3333), 5.0) * iPrt2 * smoothstep(0.04, 0.0, v - szCorona2 - 0.7);\n    \n    \/\/ map intensity to color\n    vec3 c = pow(vec3(sum), vec3(0.44, 0.6, 1.0) * 2.5) * 1.5;\n    col += c;\n}\n\nvoid explosions(vec2 uv, inout vec3 col)\n{\n    vec2 a,b,c;\n    float id, aet1,s1,s2,s3,t1,t2,t3;\n\n    if (et1 > wtcStart+1.6)\n    {\n        float st = et1*0.8;\n        id = floor(st\/2.0);\n        aet1 = mod(st-0.4,2.0);\n        \n        uv.y -= 0.5;\n        \n        s1 = 0.4;\n        s2 = 0.4;\n        s3 = 0.4;\n        \n        t1 = aet1-0.15;\n        t2 = aet1+0.1*id;\n        t3 = aet1-0.02*id;\n        \n        float oy = -id*0.24;\n     \ta = vec2( 0.4, oy);\n     \tb = vec2( 0.0, oy);\n     \tc = vec2(-0.5, oy);        \n    }\n    else if (et1 > wtcStart) \/\/ wtc 1 & 2\n    {\n        float w = step(-0.3, uv.x); \/\/ left\/right\n        uv.y += 0.2;\n\t\tuv.y += (1.0-w)*max(0.0, pow(max(0.0, 0.5*(et1-(wtcStart+1.3))), 2.0));        \n\t\tuv.y += w*max(0.0, pow(max(0.0, 0.5*(et1-(wtcStart+1.8))), 2.0));        \n        uv.x += w*0.05*max(0.0, (et1-(wtcStart+1.3)));\n        uv.x -= (1.0-w)*0.05*max(0.0, (et1-(wtcStart+10.3)));\n        \n        id = floor((-uv.y+0.2)\/0.18)*step(uv.x,0.3)*step(-0.9, uv.x);\n        if (id != -1.0 && id != 1.0 && id != 2.0) return;\n        \n        uv.y =  mod(uv.y-0.2, 0.18)-0.06;\n        uv.x = mod(uv.x-0.3, 0.6)+0.5;\n        uv.x *= 0.2;\n        \n        aet1 = (et1-0.4*w)*0.97 + id * 0.6 - (wtcStart + 0.4);\n        \n        s1 = 0.016;\n        s2 = 0.016;\n        s3 = 0.016 - 0.006*w;\n        \n        float t = aet1*1.4;\n        t1 = t-0.001;\n        t2 = t+0.01;\n        t3 = t-0.004;\n        \n     \ta = vec2(0.13, 0.0);\n     \tb = vec2(0.16, 0.0);\n     \tc = vec2(0.19, w*(-uv.x*0.8+0.15));\n    } \n    else if (uv.x < 0.0) \/\/ building left\n    {\n        id = floor((-uv.y+0.32)\/0.4);\n        if (id < -1.0) return;\n        \n        uv.y = mod(uv.y-0.32, 0.4)-0.2;\n        uv.x *= 0.6;\n        uv.x -= 0.55;\n        uv.x = abs(uv.x);\n        \n        aet1 = et1 + id * 0.3 - 1.2;\n        \n        s1 = 0.15;\n        s2 = 0.1;\n        s3 = 0.13;\n        \n        t1 = aet1-0.05;\n        t2 = aet1+0.02;\n        t3 = aet1-0.02*id;\n        \n     \ta = vec2(1.5, 0.03);\n     \tb = vec2(1.3, 0.0);\n     \tc = vec2(1.2-0.1*(et1-1.2), 0.00);\n    }\n    else if (et1 > 2.0) \/\/ building mid right\n    {\n        id = floor((-uv.y+0.2)\/0.32);\n        if (id < -1.0) return;\n        \n        uv.y += 0.9*max(0.0, pow(max(0.0, 0.5*(et1-3.3)), 2.0));\n        if (uv.y > 0.5) return;\n        \n        uv.y =  mod(uv.y-0.2, 0.32)-0.16;\n        uv.x *= 0.6;\n        uv.x += 0.75;\n        \n        aet1 = et1*0.97 + id * 0.3 - 2.4;\n        \n        s1 = 0.04;\n        s2 = 0.06;\n        s3 = 0.04;\n        \n        t1 = aet1-0.01;\n        t2 = aet1+0.01;\n        t3 = aet1-0.004*id;\n        \n     \ta = vec2(1.242+0.02*(et1-2.4), 0.0);\n     \tb = vec2(1.13, 0.0);\n     \tc = vec2(0.99-0.02*(et1-2.4), 0.0);\n    }\n    else \/\/ building right (first to fall)\n    {\n        id = floor((-uv.y+0.25)\/0.7);\n        \n        uv.y = mod(uv.y-0.25, 0.7)-0.35;\n        uv.x *= 0.8;\n        uv.x += 0.3;\n        \n        aet1 = et1*1.2 + id * 0.3;\n        \n        s1 = 0.2;\n        s2 = 0.12;\n        s3 = 0.16;\n        \n        t1 = aet1*0.98-0.15;\n        t2 = aet1-0.1;\n        t3 = aet1-0.2;\n        \n     \ta = vec2(1.58, 0.0);\n     \tb = vec2(1.42, 0.0);\n     \tc = vec2(1.18-0.1*et1, 0.0);\n    }\n    \n    explosion(uv-a, col, t1, s1, 3.7512*id);\n    explosion(uv-b, col, t2, s2, 2.5822*id);\n    explosion(uv-c, col, t3, s3, 1.2833*id);\n    \n    \n    \n    \n}\n#endif\n\n\/\/ == city\/buildings, textured 2D band segments ==========================\n#ifdef CITY\n#define BAND_INIT vec3 a,b; vec2 q=p; float x,y,y1,y2;\n#define BAND_START(n) a=n; b=n; p=q;\n#define BAND_TO(n,c) a=b; b=n; if (p.x > a.x && p.x < b.x) { x = (p.x - a.x)\/(b.x - a.x); y1 = mix(a.y, b.y, x); y2 = mix(a.z, b.z, x); if (p.y > y1 && p.y < y2) { y = (p.y - y2)\/(y1-y2); col = c; }}    \n\nvoid city(vec2 p, inout vec3 col)\n{\n    float s = et1;\n    \n    \/\/ left\n    BAND_INIT;\n    BAND_START(vec3(-1.8,  -1.5,0.88))\n\tp.y+=max(0.0, pow(max(0.0, 0.8*(s-2.6)), 2.0));\n    float o = -0.7*texture2D(iChannel2, p*0.1).b*max(0.0, min(1.0, (s-1.6)*2.0));\n    \n    BAND_TO(   vec3(-1.58, -1.5,0.88),  o+vec3(tex3(vec2(x,y))))\n    BAND_TO(   vec3(-1.45, -1.42,0.8),  o+vec3(tex3(vec2(x,y))))\n    BAND_TO(   vec3(-1.2,  -1.4,0.8),   o+vec3(tex3(vec2(x,y))))\n    BAND_TO(   vec3(-0.9,  -1.25,0.65), o+vec3(tex3(vec2(x,y))))\n    \n    \/\/ wtc 1\n    float ft = max(0.0, s-(wtcStart+1.3));\n    float oy = max(0.0, pow(max(0.0, 0.5*ft), 2.0));\n    BAND_START(vec3(-0.8,  -0.83,0.3))\n    p = rotate(p, min(0.22, 0.1*ft));\n    p.x-=ft*0.1;\n\tp.y+=oy;\n    BAND_TO(   vec3(-0.4,  -0.82,0.28), vec3(tex2(vec2(x-5.4,y), 0.005)))\n    \n    \/\/ wtc 2\n    ft = max(0.0, s-(wtcStart+1.8));\n    oy = max(0.0, pow(max(0.0, 0.5*ft), 2.0));\n    BAND_START(vec3(-0.25, -0.8,0.27))\n    p = rotate(p, min(0.22, -0.06*ft));\n    p.x+=ft*0.1;        \n\tp.y+=oy;\n    BAND_TO(   vec3( 0.1,  -0.82,0.31), vec3(tex2(vec2(x,y), 0.005)))\n    BAND_TO(   vec3( 0.2,  -0.8,0.26), vec3(tex2(vec2(x,y), 0.005)))\n        \n    \/\/ tower\n    BAND_START(vec3( 0.35, -0.83,0.47))\n\tp.y+=max(0.0, pow(max(0.0, 0.5*(s-3.2)), 2.0));\n    BAND_TO(   vec3( 0.37, -0.8,0.51), vec3(tex4(vec2(x,y))))\n    BAND_TO(   vec3( 0.85, -0.8,0.51), vec3(tex4(vec2(x,y))))\n        \n    \/\/ right\n    BAND_START(vec3( 0.96, -1.18,0.8))\n\tp.y+=max(0.0, pow(max(0.0, s-1.2), 2.0));\n\t\n    o = -0.5*texture2D(iChannel2, p*0.1).b*max(0.0, min(1.0, (s-0.2)*2.0));\n    \n    BAND_TO(   vec3( 1.66, -1.4,1.01), o+vec3(tex1(2.0*vec2(x-0.4,-1.6*y-3.0), 0.001)))\n    BAND_TO(   vec3( 2.8,  -1.34,1.01),  o+vec3(tex1(2.0*vec2(x-0.12,-1.6*y), 0.001)))\n        \n    \/\/ flashing windows\n    float id = floor(ef1*3.0-1.0);\n    float dy = 0.36;\n    float c = smoothstep(0.1, 0.6, col.r);\n    float h = 0.2;\n    float sk = 0.0;\n\n    if (id > 1.0) \n    {\n        id = floor(ef1*6.0-1.0)-4.0;\n        if (id != 3.0 && id != 5.0 && id != 6.0) return;\n        p.x = -p.x-0.1;\n        p.y += 0.55;\n        dy = 0.128;\n        h = 0.09;\n        c = smoothstep(0.7, 0.8, 1.0-col.r);\n        sk = -0.15*max(0.0, 0.19*(id-2.0));\n    }\n    \n    col += step(0.8, p.x) * \/\/ cut\n           abs(sin(8.0*ef1*pi)) * \/\/ flicker\n           c * smoothstep(h, 0.0, abs(p.y+0.1-id*dy+p.x*sk)); \/\/ color replacement\n}\n#endif\n\n\n\/\/ == particle rain ======================================================\n#ifdef PARTICLES\nvoid particleRain(vec2 p, inout vec3 col)\n{\n\tvec3 c;\n    float i,b,x = p.x;\n        \n    float t = -0.5*step(p.x, 0.0);\n    p.x *= 1.0-2.0*step(0.0, p.x);\n\n    t += et1;\n    p = rotate(p, -0.08);\n    \n    b = 0.0;\n    i = 0.0;\n    \n    x = 1.5*step(0.0, x);\n    \n    vec2 uv = vec2(p.y + time*2.0+x , p.x + pow(p.y+0.2, 3.0)*0.3-2.4);\n    \n    c = texture2D(iChannel3, uv).rgb;\n    i = max(i, smoothstep(0.8, 0.9, c.r));\n    b += c.g + 0.5*step(0.5, c.b);\n    \n    c = texture2D(iChannel3, uv.xy+vec2(0.3+time*1.3, 0.5)).rgb;\n    i = max(i, smoothstep(0.86, 0.99, c.r));\n    b += c.g - 1.0*step(0.2, c.b);\n    \n    i *= smoothstep(0.6, 0.7, abs(p.x)) *\n         smoothstep(0.5, 0.6, t) *\n         smoothstep(4.0, 3.5, t);\n    \n    col = mix(col, vec3(clamp(b, 0.0, 1.0)), 0.6*i);\n}\n#endif\n\n\n\/\/ == TEXT ===============================================================\n#ifdef TEXT\nvoid letter(float n, vec2 p, inout float d) \/\/ 5x5\n{\n    p *= 50.0;\n\tp.y *= -1.0;\n\tp = floor(p + 2.5);\n\t\n\tif (clamp(p.x, 0.0, 4.0) == p.x && clamp(p.y, 0.0, 4.0) == p.y)\n\t{\n\t\tfloat k = p.x + p.y*5.0;\n\t\tif (int(mod(n\/(pow(2.0,k)),2.0)) == 1) d = max(d, 1.0);\n    }\n}\n\nvec3 txtPixel(vec2 p, float from1, float to2)\n{\n    p = floor(p*iResolution.x*2.0)\/(iResolution.x*2.0);\n    \n    float from2 = from1+1.0;\n    float to1 = to2-0.5;\n    vec2 r = vec2(2.0*fract(sin(p.x * 121.2972 + p.y) * 2965.167), 0.1*fract(sin(p.y * 42.468 + p.x) * 11235.482) - 0.05);\n    float t = time;\n    t += r.x*0.5;\n    float s = smoothstep(from1, from2, t) + 2.0*smoothstep(to1, to2, t);\n    p += r*(1.0-s);\n    s *= smoothstep(to2, to1, t);\n    return vec3(p,s);\n}\n\n#define _ 4194304.0\n#define _ap 132.0\n#define _a 9747759.0\n#define _b 16301615.0\n#define _e 15768623.0\n#define _f 1096767.0\n#define _g 16036911.0\n#define _h 9747753.0\n#define _i 14815374.0\n#define _l 15762465.0\n#define _m 710331.0\n#define _n 9745769.0\n#define _o 15255086.0\n#define _r 9739567.0\n#define _s 16006191.0\n#define _t 4329631.0\n#define _u 15255089.0\n#define _v 4532785.0\n#define _y 4357681.0\n\n#define CHAR_SIZE 0.11\n#define SPACE_SIZE 0.1\n#define TEXT_START(a) vec3 pix=txtPixel(p,from,to);float d=0.0;vec2 tp=a;\n\/\/#define P(l) letter(l-(145.110+time*10.3211)*step(0.8, fract(time*60.0+tp.x)),pix.xy-tp,d);tp.x+=CHAR_SIZE;\n\/\/#define P(l) letter(l+(18419.3382*sin(time*1.3211))*step(0.85, fract(time*60.0+tp.x*20.0)),pix.xy-tp,d);tp.x+=CHAR_SIZE;\n#define P(l) letter(l,pix.xy-tp,d);tp.x+=CHAR_SIZE;\n#define SPACE tp.x+=SPACE_SIZE;\n#define TEXT_END vec3 c=0.6+0.3*texture2D(iChannel2,p*vec2(0.3)).rrb;col=mix(col,c,pix.z*smoothstep(0.5,1.0,d));\n\n\/\/ trust me\nvoid txt1(vec2 p, inout vec3 col, float from, float to)\n{\n    TEXT_START(vec2(-0.94, -0.1))\n    P(_t) P(_r) P(_u) P(_s) P(_t) SPACE P(_m) P(_e)    \n    TEXT_END\n}\n\n\/\/ everything's gonna be fine\nvoid txt2(vec2 p, inout vec3 col, float from, float to)\n{\n\tTEXT_START(vec2(-1.35, -0.2)) \n    P(_e) P(_v) P(_e) P(_r) P(_y) P(_t) P(_h) P(_i) P(_n) P(_g) P(_ap) P(_s) SPACE\n    P(_g) P(_o) P(_n) P(_n) P(_a) SPACE P(_b) P(_e) SPACE P(_f) P(_i) P(_n) P(_e)        \n\tTEXT_END\n}\n\n\/\/ i'm sorry (not in the movie but in the original script)\nvoid txt3(vec2 p, inout vec3 col, float from, float to)\n{\n\tTEXT_START(vec2(-0.7, -0.1))\n    P(_i) P(_ap) P(_m) SPACE P(_s) P(_o) P(_r) P(_r) P(_y) P(_) P(_) P(_)       \n\tTEXT_END\n}\n\n\/\/ you met me at a very \nvoid txt4(vec2 p, inout vec3 col, float from, float to)\n{\n\tTEXT_START(vec2(-0.5, -0.1)) \n    P(_y) P(_o) P(_u) SPACE P(_m) P(_e) P(_t) SPACE P(_m) P(_e) SPACE\n    P(_a) P(_t) SPACE P(_a) SPACE P(_v) P(_e) P(_r) P(_y)\n\tTEXT_END\n}\n\n\/\/ strange time in my life\n void txt5(vec2 p, inout vec3 col, float from, float to)\n{\n\tTEXT_START(vec2(-1.2, -0.2)) \n    P(_s) P(_t) P(_r) P(_a) P(_n) P(_g) P(_e) SPACE P(_t) P(_i) P(_m) P(_e) SPACE\n    P(_i) P(_n) SPACE P(_m) P(_y) SPACE P(_l) P(_i) P(_f) P(_e)\n\tTEXT_END\n}\n\nvoid text(vec2 p, inout vec3 col)\n{\n    \/\/vec3 t = 0.05*texture2D(iChannel1, p).xyz;\n    \/\/p.xy += vec2(t-0.025);    \n    txt1(p, col, 6.0, 11.0);\n    txt2(p, col, 10.0, 16.0);\n    txt3(p, col, eStart+6.5,  eStart+9.0);\n    txt4(p, col, eStart+8.0,  eStart+12.0);\n    txt5(p, col, eStart+11.0, eStart+16.0);\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec2 pos = (fragCoord.xy*2.0 - resolution.xy) \/ resolution.y;\n\n\tpos += shake*0.01;\n    \n    if (abs(pos.y)>.75) \n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n\tfloat d = clamp(1.5*sin(0.3*time), 0.5, 1.0);\n    float j = et1*0.04;\n\tvec3 cp = vec3(1.0, 2.0, -18.0+j);\n    vec3 ct = vec3(1.0, 2.0, 0.0)+0.1*vec3(shake.x, shake.y, 0.0);\n\t\n    #if 0\n\tif (mouse.x > 10.0)\n\t{\n\t\tvec2 mrel = mouse.xy\/resolution.xy-0.5;\n        ct = vec3(1.0-6.0*mrel.x, 2.0+4.0*mrel.y, 0.0);\n\t}\n    #endif\n\t\n   \tvec3 cd = normalize(ct-cp);\n    vec3 cu  = vec3(0.0, 1.0, 0.0);\n    vec3 cs = cross(cd, cu);\n    vec3 dir = normalize(cs*pos.x + cu*pos.y + cd*focus);\t\n\t\n    Hit h;\n\tvec3 col = vec3(0.0);\n\tvec3 ray = cp;\n\tfloat dist = 0.0;\n\t\n\t\/\/ raytrace scene\n    #ifdef ROOM\n    for(int i=0; i < 60; i++) \n\t{\n        h = scene(ray);\n\t\t\n\t\tif(h.d < 0.001) break;\n\t\t\n\t\tdist += h.d;\n\t\tray += dir * h.d;\n\n        if(dist > far) \n\t\t{ \n\t\t\tdist = far; \n\t\t\tbreak; \n\t\t}\n    }\n\t\n\tfloat m = (1.0 - dist\/far);\n\tvec3 n = normal(ray);\n\tcol = colorize(h, n, dir, sun, ray)*m;\n    \n\t#else\n    vec3 n = vec3(0.0);\n    col = vec3(1.0, 0.0, 0.0);\n    dist = 10000.0;\n    #endif\n    \n    if (dist < far)\n    {\n    \t#ifdef ROOM        \n    \tfloat edge = edges(ray);\n\t\tcol = mix(col, vec3(0.5), min(1.0,h.edge*edge));\n    \n        \/\/ HARD SHADOW with low number of rm iterations (from obj to sun)\n        #ifdef ROOM_SHADOW\n        vec3 ray1 = ray;\n        dir = normalize(sunPos - ray1);\n        ray1 += n*0.002;\n\n        float sunDist = length(sunPos-ray1);\n        dist = 0.0;\n\n        for(int i=0; i < 35; i++) \n        {\n            h = scene(ray1 + dir*dist);\n            dist += h.d;\n        }\n\n        col -= 0.2*smoothstep(0.5, -0.3, min(dist, sunDist)\/max(0.0001,sunDist));\n        #endif\n        #endif\n    }\n    else\n    {\n        \/\/ outside world\n        #ifdef BACK\n        col = vec3(0.7*smoothstep(2.5, -3.0, pos.y))+0.4*texture2D(iChannel3, 0.04*pos+vec2(0.5-0.001*time, 0.0005*time)).g;\n        #endif\n        \n        #ifdef CITY\n        city(pos, col);\n        #endif\n        \n        #ifdef EXPLOSIONS\n        explosions(pos, col);\n        #endif\n        \n        #ifdef PARTICLES\n        particleRain(pos, col);\n        #endif\n        \n        #ifdef POST\n        #ifdef BACK\n        vec3 o = texture2D(iChannel3, pos*0.1+vec2(0.0, -0.001*time-0.5)).rrg;\n        col = mix(col, o, 0.2*smoothstep(0.6, 0.8, 1.0-o.g));\n        \n        o = texture2D(iChannel1, pos*0.1+vec2(0.3+time*0.001, -0.003*time+0.5)).ggg; \/\/ dust cloud\n        col = mix(col, o, (min(0.5, et1) + 0.2)*smoothstep(0.6, 0.8, 1.0-o.g)*smoothstep(0.1, -0.6, pos.y));\n        #endif\n        #endif\n    }\n    \n    #ifdef SILHOUETTES\n    vec2 uv = pos;\n    uv.y = abs(uv.y+0.71)-0.71;\n    float s = silhouettes(uv);\n    \n    vec3 scol = vec3(0.1*smoothstep(0.01, 0.0, s) + 0.2 * smoothstep(0.02, 0.0, abs(s)));\n    scol = mix(scol, col-0.2, smoothstep(0.71, 0.72, -pos.y));\n    col = mix(scol, col, smoothstep(0.0, 0.01, s));\n    float k = j*0.02;\n    vec2 a = vec2(0.09, 0.54+k);\n    \n    if (pos.x > -0.2) \n    {\n        a.x = 0.11;\n        a.y = 0.55+k;\n    }\n    \n    if (pos.x > 0.0)\n    {\n        a.x = 0.05;\n        a.y = 0.55+k;\n    }\n    \n    float b = smoothstep(0.0, 0.01, s);\n    float c = 0.6*(1.0-max(b, smoothstep(0.0, 0.01, abs(pos.y+a.y)-a.x)));\n    c += 0.6*(1.0-b)*smoothstep(0.2, 0.0, abs(pos.y-0.36+pos.x*0.14)-0.1);\n    \n    col = mix(col, vec3(0.35, 0.25, 0.18), c);\n\t#endif\n    \n    #ifdef FLASH_AND_SHAKE\n    col += 0.6*step(0.3, abs(shake.x))*step(0.48, abs(constShake.x)); \/\/ flash\n    #endif\n\n    #ifdef TEXT\n    text(pos, col);\n    #endif    \n    \n    #ifdef POST\n\tcol = clamp(col, vec3(0.0), vec3(1.0));\n\tcol = pow(col, vec3(4.0, 3.3, 3.25)) * 3.7; \/\/ farbton & s\u00e4ttigung\n\tcol = pow(col, vec3(1.0 \/ 2.2)); \/\/ gamma    \n    #endif\n\n    col *= smoothstep(1.0, 3.0, time)*smoothstep(45.0, 40.0, time);\n    \n\tfragColor = vec4(col, 1.0);\n}\n","name":"","description":"","type":"image"},{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ by srtuss\n\nfloat n2f(float n)\n{return 440.0*pow(2.0,n\/12.0);}\nfloat sine(float ph)\n{return sin(ph*6.283185307179586476925286766559);}\nfloat shns(float x)\n{return fract(sin(floor(x * 4000.0)) * 29919.0) - 0.5;}\nfloat hpns(float x, float h)\n{return (shns(x + h) - shns(x - h));}\nfloat adsr(float x, float a, float d)\n{return smoothstep(0.0, a, x) * exp(max(x - a, 0.0) * -d);}\nfloat adsr(float x, float a, float d, float g)\n{return smoothstep(0.0, a, x) * smoothstep(a + d + g, a + g, x);}\nfloat ade(float x, float a, float e, float g)\n{return smoothstep(0.0, a, x) * exp(max(x - (a + g), 0.0) * -e);}\nfloat pwm(float t, float v)\n{\n    float s = 0.001;\n    t = fract(t);\n    return smoothstep(v,  v + s, t) * smoothstep(1.0, 1.0 - s, t) - 0.5;\n}\n\nfloat nse(float x)\n{\n    float x2 = x;\n    return texture2D(iChannel0, vec2(x2 \/ 256.0, x * 0.01), -100.0).x - 0.5;\n}\n\nvec2 expl(float x, vec2 pan, float seed)\n{\n    float dist = fract(seed * 27623.5978623) * 0.5;\n    float dist2 = fract(seed * 2723.5978623);\n    \n    float ps = 0.2;\n    float verb = adsr(x - 0.1, 0.1, 3.0);\n    float xp = exp(-x \/ ps) * ps;\n    ps = 0.9;\n    float xp2 = mix(1.0, exp(-x \/ ps) * ps * 1.0, step(0.5, dist2));\n    vec2 v = nse(xp * 100.0 + seed) * (adsr(x, 0.01, 4.0) + verb * 0.2) * 2.0 * pan.xy;\n    v += nse(x * xp2 * 500.0 - seed) * (adsr(x, 0.1, 4.0) + verb * 0.2) * pan.yx;\n    v += sin(v * (dist2 * 5.0)) * dist2 * 0.3;\n    v += nse(x * 1340.0 + seed * 2.0) * (adsr(x, 0.1, 50.0) + verb * 0.3) * 0.5 * pan.xy;\n    v = (smoothstep(-1.0 + dist, 1.0 - dist, v) - 0.5) * exp(-dist * 1.0);\n    return v;\n}\n\n\/*\nt - time\npan - finetune direction of sound origin (1,1 = center)\npitch - change pitch\/size of explosion (1 = default)\nnr - number of subsequent explosions (sort of)\ndel - delay between subsequent explosions\nvari - maximum random variation in delay (0 = no variation)\n*\/\nvec2 explseq(float t, vec2 pan, float pitch, float nr, float del, float vari)\n{\n    float rp = del;\n    vec2 v = vec2(0.0);\n    float tb = t;\n    float sd = floor(tb \/ rp);\n    v += expl(max(fract(tb \/ rp) * rp, tb - nr * rp) * pitch - fract(sd * 19623.232) * vari, pan, sd) * step(0.0, tb);\n    tb = (t - rp * 0.5);\n    sd = floor(tb \/ rp);\n    v += expl(max(fract(tb \/ rp) * rp, tb - nr * rp) * pitch - fract(sd * 290.1233) * vari, pan, -sd) * step(0.0, tb);\n    return v;\n}\n\n\nfloat gts(float x, float tf)\n{\n    float ro = 1.0;\n    return sine(x) * 0.2 + sine(x * 2.0) * 0.7 * exp(tf * -1.0 * ro) + sine(x * 3.002) * 0.4 * exp(tf * -2.0 * ro);\n}\n\n#define GTMUL adsr(tf, 0.01, 0.85, 0.12) * step(0.0, tt)\n\nfloat tbt = 60.0 \/ 160.0;\nfloat tbr = tbt * 4.0;\n\nfloat riff(float time)\n{\n    float v = 0.0;\n    \n    time = mod(time, tbr * 4.0);\n    \n    float tf, tt;\n    \/\/ G#5\n    tt = time;\n    tf = max(mod(tt, tbt * 2.0), max(tt - tbr * 1.5, 0.0));\n    v += gts(time * n2f(-5.0), tf) * GTMUL;\n    \n    \/\/ D#5 short\n    tt = time - tbr * 1.001;\n    tf = max(mod(tt, tbt * 2.0), max(tt - tbr * 1.5, 0.0));\n    v += gts(time * n2f(-6.0), tf) * GTMUL * 0.5;\n    \n    \/\/ D#5\n    tt = time - tbr * 2.0;\n    tf = max(mod(tt, tbt * 2.0), max(tt - tbr * 0.5, 0.0));\n    v += gts(time * n2f(-6.0), tf) * GTMUL;\n    \n    \/\/ E5\n    tt = time - tbt;\n    tf = max(mod(tt, tbt * 2.0), max(tt - tbr * 2.5, 0.0));\n    v += gts(time * n2f(-1.0), tf) * GTMUL;\n    \n    \n    \/\/ E5\n    tt = time - tbr * 3.0;\n    tf = max(mod(tt, tbt * 1.0), max(tt - tbr * 0.5, 0.0));\n    v += gts(time * n2f(-5.0), tf) * GTMUL;\n    \n    \/\/ D#5\n    tt = time - tbr * 3.0 - tbt * 1.5;\n    tf = tt;\n    v += gts(time * n2f(-6.0), tf) * GTMUL;\n    \n    \/\/ A4 short\n    tt = time - tbr * 3.02;\n    tf = max(mod(tt, tbt * 2.0), max(tt - tbr * 0.5, 0.0));\n    v += gts(time * n2f(-12.0), tf) * GTMUL * 0.5;\n    \n    v = sin(v * (1.1 + 0.4 * sin(time * 4.0)));\n    \n    v = smoothstep(-0.25, 0.25, v);\n    \n    return v;\n}\n\nfloat sub(float t)\n{\n    t = mod(t, tbr * 4.0);\n\n    float f = n2f(-5.0);\n    f = mix(f, n2f(-8.0), step(tbr, t));\n    f = mix(f, n2f(-1.0), step(tbr * 2., t));\n    f = mix(f, n2f(0.0), step(tbr * 3., t));\n    \n    float ph = t * f * 0.25;\n    return (sine(ph) + sine(ph * 1.03) * 0.3) * adsr(mod(t, tbr), 0.1, 0.1, tbr * 0.85);\n}\n\nfloat riffhp(float t)\n{\n    float h = 0.0001 + sin(t) * 0.00005;\n    return riff(t + h) - riff(t - h);\n}\n\nfloat echos(float t)\n{\n    return riffhp(t);\n}\n\nvec2 echochn(float t)\n{\n    vec2 v = vec2(0.0);\n    float to = 0.0;\n    float ea = 1.0;\n    vec2 pan = vec2(1.0, 0.5);\n    vec2 of = vec2(0.002, 0.0);\n    float deltime = (60.0 \/ 160.0) * 4.0 \/ 3.0;\n    for(int i = 0; i < 10; i++)\n    {\n    \tv += vec2(echos(t - to + of.x), echos(t - to + of.y)) * pan * ea;\n        ea *= 0.2;\n        to += deltime;\n        of = of.yx;\n        pan = pan.yx;\n    }\n    return v;\n}\n\nvec2 mainSound(float time)\n{\n    float t = time - 16.5;\n    vec2 v = \texplseq(t - 1.0, vec2(1.8, 0.4), 0.6, -1.0, 0.5,   0.1) * 1.0;\n    \t v += \texplseq(t - 2.0, vec2(0.2, 1.0), 0.5,  1.0, 0.654, 0.2)  * 0.6;\n    \t v += \texplseq(t - 2.5, vec2(1.0, 1.0), 0.6, 0.5, 0.7,   0.1)  * 0.3;\n    \t v += \texplseq(t - 3.0, vec2(1.0, 0.0), 0.6,  0.8, 0.4,   0.1)  * 0.2;\n    \n    \t v += \texplseq(t - 4.0, vec2(0.8, 0.6), 0.7, 1.0, 0.5,   0.3)  * 0.8;\n    \t v += \texplseq(t - 4.0, vec2(0.1, 1.0), 0.65, 0.5, 0.45, 0.1)  * 0.4;\n    \t v += \texplseq(t - 5.5, vec2(0.5, 0.5), 0.5, 0.9, 0.4,   0.2)  * 0.3;\n\n    \t v += \texplseq(t - 13.4, vec2(0.8, 0.9), 0.5,-1.0, 0.5,   0.1)  * 0.8;\n    \t v += \texplseq(t - 14.4, vec2(0.8, 1.0), 0.4, 0.6, 0.7,   0.2) * 0.5;\n    \t v += \texplseq(t - 14.9, vec2(0.7, 1.0), 0.5, 0.4, 0.8,   0.1)  * 0.3;\n    \t v += \texplseq(t - 16.3, vec2(1.0, 1.0), 0.35, 0.6, 0.7,   0.2) * 0.6;\n\n    t = time - 15.0;\n    vec2 m = echochn(t);\n    m += vec2(sub(t) * 0.5);\n    m *= 0.2;\n    \n    v += m*smoothstep(-0.1, 2.0, t)*smoothstep(30.0, 10.0, t);\n    \n    return vec2(v);\n}","name":"","description":"","type":"sound"}]}}