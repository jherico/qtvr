{"Shader":{"ver":"0.1","info":{"id":"ldfXDj","date":"1406831817","viewed":779,"name":"3D Audio","username":"P_Malin","description":"Just playing around making horrible noises. Stereo panning, distance attenuation and independent doppler for each ear.<br\/>TODO: make nice noises","likes":11,"published":3,"flags":8,"tags":["3d","audio","stereo","doppler"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ These need to match the Sound shader\n\nmat3 GetCameraRotMatrix(const in vec3 vCameraPos, const in vec3 vCameraTarget )\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n    return mat3(vRight, vUp, vForward);\n}\n\nvoid GetCamera( const in float fTime, out vec3 vCameraPos, out mat3 mCameraRot )\n{\n\tvCameraPos = vec3(sin(fTime * 0.5) * 20.0, 0.0, -10.0);\n\t\/\/vec3 vCameraTarget = vec3(sin(fTime * 1.0) * 16.0, 0.0, 0.0);\n    vec3 vCameraTarget = vCameraPos + vec3(sin(fTime), 0.0, cos(fTime)) * 3.0;    \n    mCameraRot = GetCameraRotMatrix(vCameraPos, vCameraTarget);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec2 GetWindowCoord( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x \/ iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvec3 CameraToWorld( vec3 vCameraPos, const in mat3 mCameraRot )\n{\n    return vCameraPos * mCameraRot;\n}\n\nvec3 GetCameraRayDir( const in vec2 vWindow, const in mat3 mCameraRot )\n{\n\tvec3 vDir = normalize( CameraToWorld(vec3(vWindow.x, vWindow.y, 2.0), mCameraRot) );\n\n\treturn vDir;\n}\n\nvec3 ApplyVignetting( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0);\n\t\n\tfloat fDist = dot(vOffset, vOffset);\n\t\n\tconst float kStrength = 0.8;\n\t\n\tfloat fShade = mix( 1.0, 1.0 - kStrength, fDist );\t\n\n\treturn vInput * fShade;\n}\n\nvec3 ApplyTonemap( const in vec3 vLinear )\n{\n\tconst float kExposure = 1.0;\n\t\n\treturn 1.0 - exp2(vLinear * -kExposure);\t\n}\n\nvec3 ApplyGamma( const in vec3 vLinear )\n{\n\tconst float kGamma = 2.2;\n\n\treturn pow(vLinear, vec3(1.0\/kGamma));\t\n}\n\nfloat Checker(const in vec2 vUV)\n{\n\treturn step(fract((floor(vUV.x) + floor(vUV.y)) * 0.5), 0.25);\n}\n\nvec3 GetSource0Pos(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 GetSource1Pos(float t)\n{\n    return vec3(mod(t * 10.0, 50.0) - 25.0, 0.0, -5.0);\n}\n\nvec3 GetLight( vec3 vLightPos, vec3 vLightColour, const in vec3 vRayOrigin,  const in vec3 vRayDir )\n{    \n    vec3 vToLight = vLightPos - vRayOrigin;\n    float fPointDot = dot(vToLight, vRayDir);\n    fPointDot = clamp(fPointDot, 0.0, 100.0);\n\n    vec3 vClosestPoint = vRayOrigin + vRayDir * fPointDot;\n    float fDist = length(vClosestPoint - vLightPos);\n\treturn sqrt(vLightColour * 0.5 \/ (fDist * fDist));    \n}\n\nvec3 GetSceneColour( const in vec3 vRayOrigin,  const in vec3 vRayDir )\n{\n    vec3 vResult = vec3(0.0);\n\n    vec3 d = vec3(1.0, 1.0, 3.0) \/ vRayDir;\n\tfloat t = -d.y;\n    if( (t > 0.0) && (t < 20.0))\n    {\n\t\tvec3 vPos = vRayOrigin + vRayDir * t + vec3(0.5);\n\t\tvResult = mix(vec3(1.0), vec3(0.0), Checker(vPos.xz) );\n        if(vPos.x > 0.0)\n            vResult *= 0.5;\n    }\n \n    vec3 vLight0Colour = mix(vec3(1.0, 1.0, 0.1), vec3(0.1, 0.05, 0.0),  floor(fract(iGlobalTime) * 2.0)) * 10.0;\n    \n    vResult += GetLight(GetSource0Pos(iGlobalTime), vLight0Colour, vRayOrigin, vRayDir);\n\n    vec3 vLight1Colour = vec3(0.2, 0.9, 2.0) * 10.0;\n    \/\/vec3 vLight1Colour = mix(vec3(0.2, 0.9, 2.0), vec3(0.0, 0.25, 0.5),  floor(fract(iGlobalTime + 0.5) * 2.0)) * 10.0;\n    vResult += GetLight(GetSource1Pos(iGlobalTime), vLight1Colour, vRayOrigin, vRayDir);\n\n    return vResult;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vUV = fragCoord.xy \/ iResolution.xy;\n\n\tvec3 vCameraPos;\n    mat3 mCameraRot;\n    \n    GetCamera(iGlobalTime, vCameraPos, mCameraRot);\n\n\tvec3 vRayOrigin = vCameraPos;\n    vec3 vRayDir = GetCameraRayDir( GetWindowCoord(vUV), mCameraRot );\n\t\n\tvec3 vResult = GetSceneColour(vRayOrigin, vRayDir);\n\t\n\tvResult = ApplyVignetting( vUV, vResult );\t\n\t\n\tvec3 vFinal = ApplyGamma(ApplyTonemap(vResult));\n\t\n\tfragColor = vec4(vFinal, 1.0);\n}\n","name":"","description":"","type":"image"},{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define INVERT_STEREO\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ These need to match the Image shader\n\nmat3 GetCameraRotMatrix(const in vec3 vCameraPos, const in vec3 vCameraTarget )\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n    return mat3(vRight, vUp, vForward);\n}\n\nvoid GetCamera( const in float fTime, out vec3 vCameraPos, out mat3 mCameraRot )\n{\n\tvCameraPos = vec3(sin(fTime * 0.5) * 20.0, 0.0, -10.0);\n\t\/\/vec3 vCameraTarget = vec3(sin(fTime * 1.0) * 16.0, 0.0, 0.0);\n    vec3 vCameraTarget = vCameraPos + vec3(sin(fTime), 0.0, cos(fTime)) * 3.0;    \n    mCameraRot = GetCameraRotMatrix(vCameraPos, vCameraTarget);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nstruct C_Listener\n{\n    vec3 m_vPos;\n    mat3 m_ToWorld;\n    float m_fEarSeparation;\n    vec3 m_vEarDirL;\n    vec3 m_vEarDirR;\n};\n\nstruct C_MixerValues\n{\n    vec2 m_vPan;\n    vec2 m_vDopplerOffset;\n};\n\nstruct C_Source\n{\n    vec3 m_Pos;\n    float m_Volume;\n};    \n    \nC_Source g_SourceInfo[4];\n\n#define GET_VELOCITY(X, T) ((X(T + 0.1) - X(T)) \/ 0.1)\n\nvoid SetupListener( out C_Listener listener, const in vec3 vCameraCurrPos, const in mat3 mCameraCurrRot )\n{\n    listener.m_vPos = vCameraCurrPos;\n    listener.m_ToWorld = mCameraCurrRot;    \n    listener.m_fEarSeparation = 0.1;\n    listener.m_vEarDirL = normalize(vec3( -1.0, 0.0, 0.1));\n    listener.m_vEarDirR = normalize(vec3( 1.0, 0.0, 0.1));    \n}\n\n\nvoid GetMixerValues( const in C_Listener listener, const in C_Source source, out C_MixerValues mixerValues )\n{\n    vec3 vLocalEarPosL = vec3(-listener.m_fEarSeparation, 0.0, 0.0);\n    vec3 vLocalEarPosR = vec3( listener.m_fEarSeparation, 0.0, 0.0);\n    \n    vec3 vWorldEarPosL = vLocalEarPosL * listener.m_ToWorld + listener.m_vPos;\n    vec3 vWorldEarPosR = vLocalEarPosR * listener.m_ToWorld + listener.m_vPos;\n\n    vec3 vSourceToEarL = vWorldEarPosL - source.m_Pos;\n    vec3 vSourceToEarR = vWorldEarPosR - source.m_Pos;\n    \n    vec2 vDist = vec2(length(vSourceToEarL), length(vSourceToEarR));\n    const float kSpeedOfSound = 340.29;\n    mixerValues.m_vDopplerOffset = -vDist \/ kSpeedOfSound;\n    vec2 vVolume = vec2(source.m_Volume) \/ (vDist * vDist);\n\n    vec3 vWorldEarDirL = normalize(listener.m_vEarDirL * listener.m_ToWorld);\n    vec3 vWorldEarDirR = normalize(listener.m_vEarDirR * listener.m_ToWorld);\n    vec2 vPan = clamp(vec2( dot(normalize(vSourceToEarL), vWorldEarDirL), dot(normalize(vSourceToEarR), vWorldEarDirR) ) * 0.4 + 0.6 , 0.0, 1.0);\n    \n    mixerValues.m_vPan = vPan * vVolume;\n    \n#ifdef INVERT_STEREO\n    mixerValues.m_vPan = mixerValues.m_vPan.yx; \/\/ erm?!\n#endif\n}\n\n#define DOPPLER_PER_EAR\n\n#ifdef DOPPLER_PER_EAR\n\t#define MIX(SAMPLE_FN, TIME, MIXER_VALUES) (vec2(SAMPLE_FN(TIME + MIXER_VALUES.m_vDopplerOffset.x), SAMPLE_FN(TIME + MIXER_VALUES.m_vDopplerOffset.y)) * MIXER_VALUES.m_vPan);\n#else\n\t#define MIX(SAMPLE_FN, TIME, MIXER_VALUES) (SAMPLE_FN(TIME + dot(MIXER_VALUES.m_vDopplerOffset, vec2(0.5))) * MIXER_VALUES.m_vPan);\n#endif\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\nfloat Envelope( float time, float decay )\n{\t\n\treturn exp2( -time * (5.0 \/ decay) );\n}\n\nfloat Envelope( float time, float attack, float decay )\n{\n\tif( time < attack )\n\t{\n\t\treturn time\/attack;\/\/exp2( -(attack - time) * (5.0 \/ attack) );\n\t}\n\n\ttime -= attack;\n\n\treturn Envelope( time, decay );\n}\n\n\nfloat Envelope( float time, float attack, float sustain, float decay )\n{\n\tif( time < attack )\n\t{\n\t\treturn time\/attack;\/\/exp2( -(attack - time) * (5.0 \/ attack) );\n\t}\n\n\ttime -= attack;\n\t\n\tif(time < sustain)\n\t{\n\t\treturn 1.0;\n\t}\n\n\ttime -= sustain;\n\t\n\treturn Envelope( time, decay );\n}\n\nfloat Tri( float t )\n{\n\treturn abs(fract( t ) * 4.0 - 2.0) - 1.0;\n}\n\nfloat Saw( float t )\n{\n\treturn fract( t ) * 2.0 - 1.0;\n}\n\nfloat Cos( float t )\n{\n\treturn cos( t * radians(360.0) );\n}\n\nfloat Square( float t )\n{\n\treturn step( fract(t), 0.5 ) * 2.0 - 1.0;\n}\n\nfloat Hash( float x )\n{\n\treturn fract(sin(x * 1.2345678)*123456.78);\n}\n\nfloat Noise( float x )\n{\n\treturn Hash( floor(x * 32.0) ) * 2.0 - 1.0;\n}\n\nfloat SmoothNoise( float t )\n{\n\tfloat noiset = t * 32.0;\n\tfloat tfloor = floor(noiset);\n\tfloat ffract = fract(noiset);\n\t\n\tfloat n0 = Hash(tfloor);\n\tfloat n1 = Hash(tfloor + 1.0);\n\tfloat blend = ffract*ffract*(3.0 - 2.0*ffract);\n\treturn mix(n0, n1, blend) * 2.0 - 1.0;\n}\n\nfloat FBM( float t, float persistence )\n{\n    float result = 0.0;\n    \n    float a = 1.0;\n    float tot = 0.0;\n    result += SmoothNoise(t) * a; tot += a; t *= 2.02; a *= persistence;\n    result += SmoothNoise(t) * a; tot += a; t *= 2.02; a *= persistence; \n    result += SmoothNoise(t) * a; tot += a; t *= 2.02; a *= persistence; \n    result += SmoothNoise(t) * a; tot += a; t *= 2.02; a *= persistence; \n    tot += a; \n    return result \/ tot;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat GetSource0Sample(float t)\n{     \n    \/\/return 0.0;\n    return Square(220.0*fract(t)) * Envelope(fract(t), 0.05, 0.95);\n\n    \/\/return FBM( t * 30.0, 0.5 );\n    \/\/return Square(220.0*fract(t)) * Envelope(fract(t), 0.05, 0.95);\n    \/\/return Saw(220.0*fract(t)) * Envelope(fract(t), 0.05, 0.95);\n    \/\/return Cos(220.0*fract(t)) * Envelope(fract(t), 0.05, 0.95);\n    \/\/return Tri(220.0*fract(t)) * Envelope(fract(t), 0.05, 0.95);\n}\n\nvec3 GetSource0Pos(float t)\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n\nfloat GetSource1Sample(float t)\n{        \n    \/\/return 0.0;\n    t = t + 0.5;\n    \n    return FBM( t * 30.0, 0.5 ) * 2.0 + Saw(220.1*t + 0.5) * 0.5;\n    \n    \/\/return FBM( t * 30.0, 0.5 );\n    \/\/return Square(440.0*fract(t)) * Envelope(fract(t), 0.05, 0.95);\n    \/\/return Saw(220.1*t + 0.5);\/\/ * Envelope(fract(t), 0.05, 0.95);\n    \/\/return Cos(440.0*fract(t)) * Envelope(fract(t), 0.05, 0.95);\n    \/\/return Tri(440.0*fract(t)) * Envelope(fract(t), 0.05, 0.95);\n}\n\nvec3 GetSource1Pos(float t)\n{\n    return vec3(mod(t * 10.0, 50.0) - 25.0, 0.0, -5.0);\n}\n\nvec2 mainSound(float time)\n{\n    float iGlobalTime = time;\n    \n\tvec3 vCameraCurrPos;\n    mat3 mCameraCurrRot;    \n    GetCamera(iGlobalTime, vCameraCurrPos, mCameraCurrRot);\n    \n    C_Listener listener;\n    SetupListener( listener, vCameraCurrPos, mCameraCurrRot );\n\n    g_SourceInfo[0].m_Pos = GetSource0Pos(time);\n    g_SourceInfo[0].m_Volume = 10.0;\n\n    g_SourceInfo[1].m_Pos = GetSource1Pos(time);\n    g_SourceInfo[1].m_Volume = 20.0;\n    \n    vec2 vResult = vec2(0.0);    \n\n    C_MixerValues mixerValues;\n\n    GetMixerValues( listener, g_SourceInfo[0], mixerValues );\n    vResult += MIX( GetSource0Sample, time, mixerValues );\n\n    GetMixerValues( listener, g_SourceInfo[1], mixerValues );\n    vResult += MIX( GetSource1Sample, time, mixerValues );\n    \n    return vResult;   \n}\n","name":"","description":"","type":"sound"}]}}