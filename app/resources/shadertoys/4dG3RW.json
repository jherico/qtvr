{"Shader":{"ver":"0.1","info":{"id":"4dG3Rw","date":"1453589340","viewed":121,"name":"Fake SSS(Wrap Diffuse Lighting)","username":"consoleartist","description":"This is an example of a wrap light which can extend, or \"wrap\" lighting past the terminator angle and is good for a cheap SSS effect. Panning your mouse horizontally will change the wrap amount from 0 to 1","likes":2,"published":3,"flags":0,"tags":["raymarch","diffuse","wrap","shadingmodels"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/Source: http:\/\/http.developer.nvidia.com\/GPUGems\/gpugems_ch16.html\n\nfloat sphere (vec3 rayPos, vec3 center, float radius)\n{\n    return length(rayPos - center) - radius;\n}\n\n\n\n\nfloat scene(vec3 rayPos)\n{\n   float dist_a = sphere(rayPos, vec3(-0.0, -0.0, 0.0), 3.0);\n   return dist_a;\n}\n\n\/\/normals\nvec3 normal(vec3 rayPos)\n{\n    vec3 e = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(scene(rayPos + e.xyy) - scene(rayPos - e.xyy),\n                          scene(rayPos + e.yxy) - scene(rayPos - e.yxy),\n                          scene(rayPos + e.yyx) - scene(rayPos - e.yyx)));\n}\n\n\n\/\/Wrap Diffuse Lighting\nfloat wrapDiffuse(vec3 normal, vec3 lightVector, float wrap)\n{\n    return max(0.0, (dot(lightVector, normal) + wrap) \/ (1.0 + wrap));\n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ color outs\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    float alpha = 1.0;\n    \n    \/\/Scene directional light\n    vec3 lightPos = vec3(5.0, 1.0, 0.0); \n    vec3 lightDir = normalize(lightPos - vec3(0.0, 0.0, 0.0)); \/\/normalized light vector derived from lightPos. This vector is useful for shading and marching shadow rays\n    \n    \n\t\/\/Normalized device coordinates and aspect correction   \n    vec2 uv = fragCoord.xy \/ iResolution.xy;   \n    uv = uv * 2.0 - 1.0; \/\/ remap range from 0...1 to -1...1\n    \n    float aspectRatio = iResolution.x\/ iResolution.y;\n    uv.x *= aspectRatio; \/\/aspect correction\n    \n    \/\/Mouse values for navigation or other shenanigans. Normalized device coords and aspect correction to match UVs\n    vec2 daMouse = iMouse.xy\/ iResolution.xy;\n    \/\/daMouse = daMouse * 2.0 - 1.0;\n    daMouse.x *= aspectRatio;\n   \n\n    \n    \/\/mapping camera to UV cordinates\n    vec3 cameraOrigin = vec3(0.0,0.5, -5.0); \/\/cam controls\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n    vec3 upVector = vec3(0.0, 1.0, 0.0);\n    vec3 cameraDirection = normalize(cameraTarget - cameraOrigin);\n    vec3 cameraRight = normalize(cross(upVector, cameraOrigin));\n    vec3 cameraUp = cross(cameraDirection, -cameraRight); \/\/negate cameraRight to flip properly?\n   \n    vec3 rayDir = normalize(cameraRight * uv.x + cameraUp * uv.y + cameraDirection);\n    \n    \/\/Precision value used in the ray marching loop below. This number equals our \"surface\". If the distance returned from rayPos \n    \/\/to our scene function is less than this then we have \"touched\" our object and break out of the loop to do normals and lighting\n    const float EPSILON = 0.01; \n    \n    \/\/inital ray position per pixel. This is the value that gets marched forward and tested    \n    vec3 rayPos = cameraOrigin; \n   \n    \n    \n    for (int i = 0; i < 200; i++) \/\/ the larger the loop the more accurate\/slower the render time\n    {\n        float dist = scene(rayPos); \/\/ plug current rayPos into our scene function\n        \n        if (dist < EPSILON) \/\/then the ray has hit our surface so we calculate normals and lighting at this point\n        {\n            \n            vec3 n = normal(rayPos);\n            vec3 eye = normalize(cameraOrigin - rayPos);\n            float diffuseVal = wrapDiffuse(n, lightDir, daMouse.x);\n            color = vec3(diffuseVal);\n            break;\n        }\n        \n        rayPos += dist * rayDir;        \n    }\n    \n    fragColor = vec4(color,alpha);\n}","name":"","description":"","type":"image"}]}}