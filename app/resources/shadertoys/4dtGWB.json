{"Shader":{"ver":"0.1","info":{"id":"4dtGWB","date":"1452008533","viewed":370,"name":"GLSL smallpt (multipass)","username":"vgs","description":"A simple port of Zavie's GLSL smallpt that uses multipass.<br\/>Original source: https:\/\/www.shadertoy.com\/view\/4sfGDB#","likes":11,"published":3,"flags":32,"tags":["pathtracing","montecarlo","smallpt"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ A simple port of Zavie's GLSL smallpt that uses multipass.\n\/\/ Original source: https:\/\/www.shadertoy.com\/view\/4sfGDB#\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\tvec3 color = texture2D(iChannel0, uv).rgb;\n    \n\tfragColor = vec4(pow(clamp(color, 0., 1.), vec3(1.\/2.2)), 1.);\n}","name":"","description":"","type":"image"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ All code here is by Zavie (https:\/\/www.shadertoy.com\/view\/4sfGDB#)\n\n\/*\n\nThis shader is an attempt at porting smallpt to GLSL.\n\nSee what it's all about here:\nhttp:\/\/www.kevinbeason.com\/smallpt\/\n\nThe code is based in particular on the slides by David Cline.\n\nSome differences:\n\n- For optimization purposes, the code considers there is\n  only one light source (see the commented loop)\n- Russian roulette and tent filter are not implemented\n\nI spent quite some time pulling my hair over inconsistent\nbehavior between Chrome and Firefox, Angle and native. I\nexpect many GLSL related bugs to be lurking, on top of\nimplementation errors. Please Let me know if you find any.\n\n--\nZavie\n\n*\/\n\n\/\/ Play with the following value to change quality.\n\/\/ You want as many samples as your GPU can bear. :)\n#define MAXDEPTH 4\n\n\/\/ Uncomment to see how many samples never reach a light source\n\/\/#define DEBUG\n\n\/\/ Not used for now\n#define DEPTH_RUSSIAN 2\n\n#define PI 3.14159265359\n#define DIFF 0\n#define SPEC 1\n#define REFR 2\n#define NUM_SPHERES 9\n\nfloat seed = 0.;\nfloat rand() { return fract(sin(seed++)*43758.5453123); }\n\nstruct Ray { vec3 o, d; };\nstruct Sphere {\n\tfloat r;\n\tvec3 p, e, c;\n\tint refl;\n};\n\nSphere lightSourceVolume = Sphere(20., vec3(50., 81.6, 81.6), vec3(12.), vec3(0.), DIFF);\nSphere spheres[NUM_SPHERES];\nvoid initSpheres() {\n\tspheres[0] = Sphere(1e5, vec3(-1e5+1., 40.8, 81.6),\tvec3(0.), vec3(.75, .25, .25), DIFF);\n\tspheres[1] = Sphere(1e5, vec3( 1e5+99., 40.8, 81.6),vec3(0.), vec3(.25, .25, .75), DIFF);\n\tspheres[2] = Sphere(1e5, vec3(50., 40.8, -1e5),\t\tvec3(0.), vec3(.75), DIFF);\n\tspheres[3] = Sphere(1e5, vec3(50., 40.8,  1e5+170.),vec3(0.), vec3(0.), DIFF);\n\tspheres[4] = Sphere(1e5, vec3(50., -1e5, 81.6),\t\tvec3(0.), vec3(.75), DIFF);\n\tspheres[5] = Sphere(1e5, vec3(50.,  1e5+81.6, 81.6),vec3(0.), vec3(.75), DIFF);\n\tspheres[6] = Sphere(16.5, vec3(27., 16.5, 47.), \tvec3(0.), vec3(1.), SPEC);\n\tspheres[7] = Sphere(16.5, vec3(73., 16.5, 78.), \tvec3(0.), vec3(.7, 1., .9), REFR);\n\tspheres[8] = Sphere(600., vec3(50., 681.33, 81.6),\tvec3(12.), vec3(0.), DIFF);\n}\n\nfloat intersect(Sphere s, Ray r) {\n\tvec3 op = s.p - r.o;\n\tfloat t, epsilon = 1e-3, b = dot(op, r.d), det = b * b - dot(op, op) + s.r * s.r;\n\tif (det < 0.) return 0.; else det = sqrt(det);\n\treturn (t = b - det) > epsilon ? t : ((t = b + det) > epsilon ? t : 0.);\n}\n\nint intersect(Ray r, out float t, out Sphere s, int avoid) {\n\tint id = -1;\n\tt = 1e5;\n\ts = spheres[0];\n\tfor (int i = 0; i < NUM_SPHERES; ++i) {\n\t\tSphere S = spheres[i];\n\t\tfloat d = intersect(S, r);\n\t\tif (i!=avoid && d!=0. && d<t) { t = d; id = i; s=S; }\n\t}\n\treturn id;\n}\n\nvec3 jitter(vec3 d, float phi, float sina, float cosa) {\n\tvec3 w = normalize(d), u = normalize(cross(w.yzx, w)), v = cross(w, u);\n\treturn (u*cos(phi) + v*sin(phi)) * sina + w * cosa;\n}\n\nvec3 radiance(Ray r) {\n\tvec3 acc = vec3(0.);\n\tvec3 mask = vec3(1.);\n\tint id = -1;\n\tfor (int depth = 0; depth < MAXDEPTH; ++depth) {\n\t\tfloat t;\n\t\tSphere obj;\n\t\tif ((id = intersect(r, t, obj, id)) < 0) break;\n\t\tvec3 x = t * r.d + r.o;\n\t\tvec3 n = normalize(x - obj.p), nl = n * sign(-dot(n, r.d));\n\n\t\t\/\/vec3 f = obj.c;\n\t\t\/\/float p = dot(f, vec3(1.2126, 0.7152, 0.0722));\n\t\t\/\/if (depth > DEPTH_RUSSIAN || p == 0.) if (rand() < p) f \/= p; else { acc += mask * obj.e * E; break; }\n\n\t\tif (obj.refl == DIFF) {\n\t\t\tfloat r2 = rand();\n\t\t\tvec3 d = jitter(nl, 2.*PI*rand(), sqrt(r2), sqrt(1. - r2));\n\t\t\tvec3 e = vec3(0.);\n\t\t\t\/\/for (int i = 0; i < NUM_SPHERES; ++i)\n\t\t\t{\n\t\t\t\t\/\/ Sphere s = sphere(i);\n\t\t\t\t\/\/ if (dot(s.e, vec3(1.)) == 0.) continue;\n\n\t\t\t\t\/\/ Normally we would loop over the light sources and\n\t\t\t\t\/\/ cast rays toward them, but since there is only one\n\t\t\t\t\/\/ light source, that is mostly occluded, here goes\n\t\t\t\t\/\/ the ad hoc optimization:\n\t\t\t\tSphere s = lightSourceVolume;\n\t\t\t\tint i = 8;\n\n\t\t\t\tvec3 l0 = s.p - x;\n\t\t\t\tfloat cos_a_max = sqrt(1. - clamp(s.r * s.r \/ dot(l0, l0), 0., 1.));\n\t\t\t\tfloat cosa = mix(cos_a_max, 1., rand());\n\t\t\t\tvec3 l = jitter(l0, 2.*PI*rand(), sqrt(1. - cosa*cosa), cosa);\n\n\t\t\t\tif (intersect(Ray(x, l), t, s, id) == i) {\n\t\t\t\t\tfloat omega = 2. * PI * (1. - cos_a_max);\n\t\t\t\t\te += (s.e * clamp(dot(l, n),0.,1.) * omega) \/ PI;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfloat E = 1.;\/\/float(depth==0);\n\t\t\tacc += mask * obj.e * E + mask * obj.c * e;\n\t\t\tmask *= obj.c;\n\t\t\tr = Ray(x, d);\n\t\t} else if (obj.refl == SPEC) {\n\t\t\tacc += mask * obj.e;\n\t\t\tmask *= obj.c;\n\t\t\tr = Ray(x, reflect(r.d, n));\n\t\t} else {\n\t\t\tfloat a=dot(n,r.d), ddn=abs(a);\n\t\t\tfloat nc=1., nt=1.5, nnt=mix(nc\/nt, nt\/nc, float(a>0.));\n\t\t\tfloat cos2t=1.-nnt*nnt*(1.-ddn*ddn);\n\t\t\tr = Ray(x, reflect(r.d, n));\n\t\t\tif (cos2t>0.) {\n\t\t\t\tvec3 tdir = normalize(r.d*nnt + sign(a)*n*(ddn*nnt+sqrt(cos2t)));\n\t\t\t\tfloat R0=(nt-nc)*(nt-nc)\/((nt+nc)*(nt+nc)),\n\t\t\t\t\tc = 1.-mix(ddn,dot(tdir, n),float(a>0.));\n\t\t\t\tfloat Re=R0+(1.-R0)*c*c*c*c*c,P=.25+.5*Re,RP=Re\/P,TP=(1.-Re)\/(1.-P);\n\t\t\t\tif (rand()<P) { mask *= RP; }\n\t\t\t\telse { mask *= obj.c*TP; r = Ray(x, tdir); }\n\t\t\t}\n\t\t}\n\t}\n\treturn acc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tinitSpheres();\n    vec2 st = fragCoord.xy \/ iResolution.xy;\n\tseed = iGlobalTime + iResolution.y * fragCoord.x \/ iResolution.x + fragCoord.y \/ iResolution.y;\n\tvec2 uv = 2. * fragCoord.xy \/ iResolution.xy - 1.;\n\tvec3 camPos = vec3((2. * .5*iResolution.xy \/ iResolution.xy - 1.) * vec2(48., 40.) + vec2(50., 40.8), 169.);\n\tvec3 cz = normalize(vec3(50., 40., 81.6) - camPos);\n\tvec3 cx = vec3(1., 0., 0.);\n\tvec3 cy = normalize(cross(cx, cz)); cx = cross(cz, cy);\n    \n    \/\/ Moving average (multipass code)\n\tvec3 color = texture2D(iChannel0, st).rgb * float(iFrame);\n    color += radiance(Ray(camPos, normalize(.53135 * (iResolution.x\/iResolution.y*uv.x * cx + uv.y * cy) + cz)));\n\tfragColor = vec4(color\/float(iFrame + 1), 1.);\n}","name":"","description":"","type":"buffer"}]}}