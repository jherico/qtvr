{"Shader":{"ver":"0.1","info":{"id":"llfXRf","date":"1438474638","viewed":837,"name":"basic raymarching 000001","username":"mech4rhork","description":"basic raymarching<br\/>Edit: MSAA added<br\/>from BasicRaymarchingPrimitives by zlnimda","likes":3,"published":3,"flags":0,"tags":["3d","raymarching","distancefields","antialiasing","msaa"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define PI\t\t\t\t3.14159265359\n#define MAX_ITERATIONS\t100\n#define RENDER_INTERVAL\tvec2( 0.1, 1000.0 )\n\n#define MSAA\n#define MSAA_SAMPLES\t4\n\nconst float startDelta = RENDER_INTERVAL.x;\nconst float stopDelta = RENDER_INTERVAL.y;\n\n\/\/ primitve distance functions\nfloat distPlane( vec3 pos ) {\n    return pos.y;\n}\n\nfloat distSphere( vec3 pos, float radius ) {\n    return length( pos ) - radius;\n}\n\nfloat distBox( vec3 pos, vec3 scale ) {\n    return length( max( abs( pos ) - scale, vec3( 0.0 ) ) );\n}\n\n\/\/ closest object\nfloat computeDist( vec3 pos ) {\n    \n    \/\/ floor\n    float dist = distPlane( pos - vec3( 0.0 ) );\n    \n    \/\/ spheres\n    dist = min( dist, distSphere( pos - vec3( -0.2, 1.25 + 0.15 * sin( iGlobalTime * 1.5 ), 0.3 ), 1.0 ) );\n    dist = min( dist, distSphere( pos - vec3( cos( iGlobalTime ), 0.0, sin( iGlobalTime ) ) * 2.0, 0.6 ) );\n    dist = min( dist, distSphere( pos - vec3( sin( iGlobalTime ), 2.0, cos( iGlobalTime ) ), 0.33 ) );\n    \n    \/\/ boxes\n    dist = min( dist, distBox( pos - vec3( -0.2, 0.0, -0.0 ), 0.8 * vec3( 1.0, 0.1, 1.0 ) ) );\n    dist = min( dist, distBox( pos - vec3( 0.7, 0.0, -0.8 ), 0.6 * vec3( 0.5, 0.1, 0.5 ) ) );\n    \n    return dist;\n}\n\n\/\/ raymarching\nfloat getDistToObjects( vec3 camPos, vec3 rayDir ) {\n    float delta = startDelta;\n    float maxDist = 0.002;\n    \n    for( int i = 0; i < MAX_ITERATIONS; i++ ) {\n        float dist = computeDist( camPos + rayDir * delta );\n        if( dist <= maxDist || dist > stopDelta )\n            break;\n        delta += dist;\n    }\n    \n    return delta;\n}\n\nvec3 getNormalAtPoint( vec3 pos ) {\n    float delta = 0.001;\n    vec2 unit = vec2( 1.0, 0.0 );\n    return normalize(\n        vec3(\n            computeDist( pos + unit.xyy * delta ) - computeDist( pos - unit.xyy * delta ),\n            computeDist( pos + unit.yxy * delta ) - computeDist( pos - unit.yxy * delta ),\n            computeDist( pos + unit.yyx * delta ) - computeDist( pos - unit.yyx * delta )\n        )\n    );\n}\n\n\/\/ rendering\nvec3 render( vec3 camPos, vec3 rayDir ) {\n    float dist = getDistToObjects( camPos, rayDir );\n    vec3 pos = camPos + rayDir * dist;\n    \n    vec3 color = vec3( 1.0, 1.0, 1.0 );\n    vec3 lightColor1 = vec3( 1.0, 1.0, 1.0 );\n    vec3 lightColor2 = vec3( 1.0, 0.2, 0.3 );\n    vec3 lightColor3 = vec3( 0.2, 0.3, 1.0 );\n    vec3 ambient = vec3( 0.22, 0.193, 0.39 );\n    \n    \/\/ lighting\n    float atten;\n    vec3 normal = getNormalAtPoint( pos );\n    vec3 lightDir, lightPos;\n    vec3 diffuse = vec3( 0.0 );\n    vec3 specular = vec3( 0.0 );\n    \n    \/\/ 1st pass\n    lightDir = normalize( vec3( -0.4, 4.0, -2.6 ) );\n    atten = 1.5;\n    diffuse += atten * lightColor1 * clamp(\n        dot( normal, lightDir ),\n        0.0, 1.0 );\n    specular += atten * lightColor1 * pow( clamp(\n        dot( reflect( -lightDir, normal ), -rayDir ),\n        0.0, 1.0 ), 20.0 );\n    \n    \/\/ 2nd pass\n    lightPos = vec3( 2.0, 2.5, -1.6 );\n    lightDir = normalize( lightPos - pos );\n    atten = 1.0 \/ length( lightDir ) + 0.1;\n    diffuse += atten * lightColor2 * clamp(\n        dot( normal, lightDir ),\n        0.0, 1.0 );\n    specular += atten * lightColor2 * pow( clamp(\n        dot( reflect( -lightDir, normal ), -rayDir ),\n        0.0, 1.0 ), 15.0 );\n    \n    \/\/ 3rd pass\n    lightPos = vec3( -8.0, 3.5, 8.0 );\n    lightDir = normalize( lightPos - pos );\n    atten = 1.0 \/ length( lightDir ) + 0.1;\n    diffuse += atten * lightColor3 * clamp(\n        dot( normal, lightDir ),\n        0.0, 1.0 );\n    specular += atten * lightColor3 * pow( clamp(\n        dot( reflect( -lightDir, normal ), -rayDir ),\n        0.0, 1.0 ), 15.0 );\n    \n    color *= diffuse + specular + ambient;\n    \n\treturn color * vec3( 1.0 \/ dist );\n}\n\nmat3 rotate( mat3 mat, vec3 theta ) {\n    float sx = sin( theta.x ), sy = sin( theta.y ), sz = sin( theta.z ),\n        cx = cos( theta.x ), cy = cos( theta.y ), cz = cos( theta.z );\n\treturn mat *\n        mat3( 1.0, 0.0, 0.0, 0.0, cx, -sin( theta.x ), 0.0, sx, cx ) *\n        mat3( cy, 0.0, sy, 0.0, 1.0, 0.0, -sy, 0.0, cy ) *\n        mat3( cz, -sz, 0.0, sz, cz, 0.0, 0.0, 0.0, 1.0 );\n}\n\nvec2 rotate( vec2 p, vec2 c, float theta ) {\n    float co = cos( theta ), si = sin( theta );\n    return ( p - c ) * mat2( co, -si, si, co );\n}\n\n\/\/ camera matrix\nmat3 getCameraMatrix( vec3 camFow ) {\n    vec3 forward = normalize( camFow );\n    vec3 up = normalize( vec3( 0.0, 1.0, 0.0 ) );\n    vec3 right = normalize( cross( up, forward ) );\n    \n    mat3 mat = mat3( right, up, forward );\n    \n    \/\/ shaky cam effect\n    mat = rotate(\n        mat,\n        vec3(\n            0.005 * PI * sin( iGlobalTime * 5.0 ) - ( iMouse.xy \/ iResolution.xy ).y * PI * 0.25,\n            0.003 * PI * ( cos( iGlobalTime * 3.0 ) + sin( iGlobalTime * 1.0 ) ),\n            0.0 * PI * cos( iGlobalTime*2.0 ) ) );\n    \n    return mat;\n}\n\nvec3 renderAA( vec3 ro, vec3 rd ); \/\/ MSAA\n\nvoid mainImage( out vec4 o, in vec2 i ) {\n\tvec2 uv = i.xy \/ iResolution.xy;\n    vec2 pixel = uv * 2.0 - 1.0;\n    float viewRatio = iResolution.y \/ iResolution.x;\n    pixel.y *= viewRatio;\n    \n    vec2 mouse = iMouse.xy \/ iResolution.xy;\n    float deltaRot = mouse.x * PI * 2.0;\n\n    vec3 camPos = vec3( -4.0 * cos(deltaRot), 1.0 + mouse.y * 4.0, -4.0 * sin(deltaRot) );\n    vec3 camFow = vec3( 1.0 * cos(deltaRot), 0.0, 1.0 * sin(deltaRot) );\n    mat3 camMat = getCameraMatrix( camFow );\n    \n    vec3 rayDir = camMat * normalize( vec3( pixel, viewRatio * 1.5 ) );\n    \n    #ifdef MSAA\n    vec3 color = vec3( 0.05 ) + renderAA( camPos, rayDir );\n    #else\n    vec3 color = vec3( 0.05 ) + render( camPos, rayDir );\n    #endif\n    \n    o = vec4( color, 1.0 );\n}\n\nvec3 renderAA( vec3 ro, vec3 rd ) {\n    const int k = ( MSAA_SAMPLES < 0 ) ? 1 : MSAA_SAMPLES;\n    vec3 c = vec3(0); \/\/ color\n\tvec2 o = vec2(5, 0); \/\/ offset\n    o = rotate( o, vec2(0), PI\/8.0 );\n    for( int i = 0; i < k; i++ ) {\n        c += render( ro + o.x\/iResolution.x, rd ) \/ float(k);\n        o = rotate( o, vec2(0), 2.*PI\/float(k) );\n    }\n    return c;\n}","name":"","description":"","type":"image"}]}}