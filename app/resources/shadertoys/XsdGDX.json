{"Shader":{"ver":"0.1","info":{"id":"XsdGDX","date":"1452980243","viewed":331,"name":"Snake Game","username":"demofox","description":"Raytraced snake game.  Collect the red apples and don't crash! Arrow keys to move, mouse drag to control camera.  Space to reset if you crash the snake. <br\/>Primary rays + environment mapping only.  No reflection, refraction or shadows.","likes":12,"published":3,"flags":48,"tags":["3d","raytracing","game","snake"],"hasliked":0},"renderpass":[{"inputs":[{"id":6,"src":"\/presets\/tex05.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":7,"src":"\/presets\/tex06.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":24,"src":"\/presets\/cube02_0.jpg","ctype":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ the size in X and Y of our gameplay grid\nconst float c_gridSize = 16.0;\nconst float c_halfGridSize = c_gridSize * 0.5;\nconst float c_thirdGridSize = c_gridSize \/ 3.0;\nconst float c_quarterGridSize = c_gridSize * 0.25;\nconst float c_maxGridCell = c_gridSize - 1.0;\nconst float c_radius = 1.0\/c_gridSize;\n\nconst vec2 txApple = vec2(3.0, c_gridSize);  \/\/ x,y = location of apple. z = apple is spawned. w unused\n\n\/\/=======================================================================================\n\/\/ Debug Visualizations\n\n#define DV_PLAYBOX  0        \/\/ visualize the box of play - where the snake and apples are\n#define DV_PLAYGRID 0        \/\/ visualize the 2d grid in the box of play.\n\n\/\/============================================================\n\n\/\/ save\/load code from IQ's shader: https:\/\/www.shadertoy.com\/view\/MddGzf\n\nvec4 loadValue( in vec2 re )\n{\n    return texture2D( iChannel0, (0.5+re) \/ iChannelResolution[0].xy, -100.0 );\n}\n\n\/\/=======================================================================================\nbool RayIntersectAABox (vec3 boxMin, vec3 boxMax, in vec3 rayPos, in vec3 rayDir, out vec2 time)\n{\n\tvec3 roo = rayPos - (boxMin+boxMax)*0.5;\n    vec3 rad = (boxMax - boxMin)*0.5;\n\n    vec3 m = 1.0\/rayDir;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    time = vec2( max( max( t1.x, t1.y ), t1.z ),\n                 min( min( t2.x, t2.y ), t2.z ) );\n\t\n    return time.y>time.x && time.y>0.0;\n}\n\n\/\/=======================================================================================\nbool RayIntersectAABoxNormal (vec3 boxMin, vec3 boxMax, in vec3 rayPos, in vec3 rayDir, out vec3 hitPos, out vec3 normal, inout float maxTime)\n{\n    vec3 boxCenter = (boxMin+boxMax)*0.5;\n\tvec3 roo = rayPos - boxCenter;\n    vec3 rad = (boxMax - boxMin)*0.5;\n\n    vec3 m = 1.0\/rayDir;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    vec2 time = vec2( max( max( t1.x, t1.y ), t1.z ),\n                 min( min( t2.x, t2.y ), t2.z ) );\n    \n    \/\/ if the time is beyond the maximum allowed bail out (we hit somethign else first!)\n    if (time.x > maxTime)\n        return false;\n    \n    \/\/ if time invalid or we hit from inside, bail out\n    if (time.y < time.x || time.x < 0.0)\n        return false;\n\t\n    \/\/ calculate surface normal\n    hitPos = rayPos + rayDir * time.x;   \n    vec3 hitPosRelative = hitPos - boxCenter;\n    vec3 hitPosRelativeAbs = abs(hitPosRelative);\n    vec3 distToEdge = abs(hitPosRelativeAbs - rad);\n\n    float closestDist = 1000.0;\n    for(int axis = 0; axis < 3; ++axis)\n    {\n        if (distToEdge[axis] < closestDist)\n        {\n            closestDist = distToEdge[axis];\n            normal = vec3(0.0);\n            if (hitPosRelative[axis] < 0.0)\n                normal[axis] = -1.0;\n            else\n                normal[axis] = 1.0;\n        }\n    }        \n\n    \/\/ store the collision time as the new max time\n    maxTime = time.x;\n    return true;\n}\n\n\/\/=======================================================================================\nbool RayIntersectSphere (in vec4 sphere, in vec3 rayPos, in vec3 rayDir, out vec3 normal, out vec3 hitPos, inout float maxTime)\n{\n    if (sphere.w <= 0.0)\n        return false;\n    \n\t\/\/get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    \/\/get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t\/\/exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t\/\/calculate discriminant\n\tfloat discr = b * b - c;\n\n\t\/\/a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n\n\t\/\/ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat collisionTime = -b - sqrt(discr);\n\n\t\/\/if t is negative, ray started inside sphere so clamp t to zero and remember that we hit from the inside\n\tif(collisionTime < 0.0)\n        return false;\n    \n    \/\/ if the time is beyond the maximum allowed bail out (we hit somethign else first!)\n    if (collisionTime > maxTime)\n        return false;\n    \n    \/\/ store the collision time as the new max time\n    maxTime = collisionTime;\n    \n\t\/\/compute the point of intersection\n\thitPos = rayPos + rayDir * collisionTime;    \n    \n   \t\/\/ calculate the normal\n\tnormal = hitPos - sphere.xyz;\n\tnormal = normalize(normal); \n\n\treturn true;\n}\n\n\/\/=======================================================================================\nbool RayIntersectSnakeBody (in vec3 rayPos, in vec3 rayDir, out vec3 normal, out vec3 hitPos, inout float maxTime, out vec3 diffuseColor, out float shinyness)\n{\n\tconst float c_radius = 1.0\/c_gridSize;\n    bool hit = false;\n    \n    \/\/ find where the ray starts and ends within the grid, and then walk the grid to\n    \/\/ find cells to test against.\n    \/\/ grid cell walking from http:\/\/www.cse.yorku.ca\/~amana\/research\/grid.pdf\n    vec2 hitTime;\n    if (!RayIntersectAABox(vec3(-1.0,0.0,-1.0), vec3(1.0,c_radius*2.0,1.0), rayPos, rayDir, hitTime))\n        return false;\n    \n    #if DV_PLAYBOX\n    \thit = true;\n    \tdiffuseColor = vec3(0.0,1.0,0.0);\n    #endif\n       \n    \/\/ Grid traversal from http:\/\/www.cse.yorku.ca\/~amana\/research\/grid.pdf\n    vec3 lineStart = rayPos+(rayDir*hitTime.x);\n    vec3 lineEnd = rayPos+(rayDir*hitTime.y);\n    \n    \/\/ calculate where the line starts and stops in grid coordinates\n    vec2 lineStartGrid = max(min((lineStart.xz+1.0)*c_halfGridSize, c_gridSize-0.001),0.0);\n    vec2 lineEndGrid = max(min((lineEnd.xz+1.0)*c_halfGridSize, c_gridSize-0.001),0.0);\n    \n    \/\/ calculate where the cell positions that the line starts and stops at\n    vec2 lineStartCell = floor(lineStartGrid);\n    vec2 lineEndCell = floor(lineEndGrid);\n    \n    \/\/ step direction of traversal on each axis\n    float stepX = lineEndGrid.x > lineStartGrid.x ? 1.0 : -1.0;\n    float stepY = lineEndGrid.y > lineStartGrid.y ? 1.0 : -1.0;\n    \n    \/\/ how far to edge on each axis\n    vec2 len = abs(lineEndGrid - lineStartGrid);\n\n    \/\/ tDelta.x is time t that it takes to cross a cell horizontally (to next X cell)\n    \/\/ tDelta.y is time t that it takes to cross a cell vertically (to next Y cell)\n    vec2 tDelta = 1.0 \/ len;\n    \n    \/\/ tMaxX is time t when the line hits a vertical line in the grid (the next X cell)\n    \/\/ tMaxY is time t when the line hits a horizontal line in the grid (the next Y cell)\n    vec2 frac = fract(lineStartGrid);\n    float tMaxX = lineEndGrid.x > lineStartGrid.x ? (1.0 - frac.x) \/ len.x : frac.x \/ len.x;\n    float tMaxY = lineEndGrid.y > lineStartGrid.y ? (1.0 - frac.y) \/ len.y : frac.y \/ len.y; \n    \n    \/\/ debug visualization of first grid cell hit.\n    #if DV_PLAYGRID\n    hit = true;\n    diffuseColor = vec3(lineStartCell.x \/ c_gridSize, lineStartCell.y \/ c_gridSize, 1.0 - lineStartCell.x \/ c_gridSize);\n   \tshinyness = 0.0;\n    maxTime = hitTime.x;\n    return true;    \n\t#endif\n    \n    vec4 cell = texture2D( iChannel0, (lineStartCell+0.5) \/ iChannelResolution[0].xy, -100.0 );\n    float offsetY = sin(iGlobalTime*5.0) * (1.0 - cell.z) * c_radius \/ 3.0;\n    vec4 sphere;\n    sphere.x = (lineStartCell.x-c_halfGridSize)\/c_halfGridSize + c_radius;\n    sphere.y = c_radius + offsetY;\n    sphere.z = (lineStartCell.y-c_halfGridSize)\/c_halfGridSize + c_radius;\n    sphere.w = c_radius * cell.x;\n\n    if (RayIntersectSphere(sphere, rayPos, rayDir, normal, hitPos, maxTime))\n    {\n        hit = true;\n        diffuseColor = vec3(cell.y,cell.z,0.0);\n        shinyness = 0.5;\n        return true;\n    }    \n    \n    \/\/ Loop\n    const int c_loopCount = int(c_gridSize*2.0);\n    for (int i = 0; i < c_loopCount; ++i)\n    {\n        if (tMaxX < tMaxY)\n        {\n            tMaxX += tDelta.x;\n            lineStartCell.x += stepX;\n        }\n        else\n        {\n            tMaxY += tDelta.y;\n            lineStartCell.y += stepY;\n        }\n        \n        \/\/ bail out if we are out of bounds\n        if (lineStartCell.x < 0.0 || lineStartCell.y < 0.0\n           || lineStartCell.x > c_maxGridCell || lineStartCell.y > c_maxGridCell)\n        {\n            break;\n        }        \n        \n        vec4 cell = texture2D( iChannel0, (lineStartCell+0.5) \/ iChannelResolution[0].xy, -100.0 );\n        float offsetY = sin(iGlobalTime*5.0) * (1.0 - cell.z) * c_radius \/ 3.0;\n        vec4 sphere;\n        sphere.x = (lineStartCell.x-c_halfGridSize)\/c_halfGridSize + c_radius;\n        sphere.y = c_radius + offsetY;\n        sphere.z = (lineStartCell.y-c_halfGridSize)\/c_halfGridSize + c_radius;\n        sphere.w = c_radius * cell.x;\n        \n        if (RayIntersectSphere(sphere, rayPos, rayDir, normal, hitPos, maxTime))\n\t\t{\n            hit = true;\n            diffuseColor = vec3(cell.y,cell.z,0.0);\n            shinyness = 0.5;                          \n            return true;\n\t\t}            \n        \n        \/\/ bail out if we are done\n        if (lineStartCell == lineEndCell)\n        {     \n            break;\n        }\n    }\n    \n    return hit;\n}\n\n\/\/=======================================================================================\nvoid TraceRay (in vec3 rayPos, in vec3 rayDir, inout vec3 pixelColor, in vec4 apple)\n{\n    vec3 reverseLightDir = normalize(vec3(-1.0,3.0,-1.0));\n    const vec3 lightColor = vec3(0.5,0.5,0.5);\t\n    const vec3 ambientColor = vec3(0.2,0.2,0.2); \n    \n\tvec3 normal = vec3(0.0);            \n    vec3 diffuseColor;\n    float shinyness = 0.0;\n    float maxRayHitTime = 1000.0;\n    bool hit = false;\n    vec3 hitPos = vec3(0.0);\n    \n    \/\/----- Ray vs snake\n    if (RayIntersectSnakeBody(rayPos, rayDir, normal, hitPos, maxRayHitTime, diffuseColor, shinyness))\n        hit = true;\n    \n\t\/\/----- Ray vs game board\n    if (RayIntersectAABoxNormal(vec3(-1.0,-0.2,-1.0), vec3(1.0,0.0,1.0), rayPos, rayDir, hitPos, normal, maxRayHitTime))\n    {\n        hit = true;\n        \/\/ wooden game board framing\n        if (hitPos.x > 0.98 || hitPos.x < -0.98 || hitPos.z > 0.98 || hitPos.z < -0.98 || hitPos.y < -0.01)\n        {       \n            if (abs(normal.x) > 0.1)\n                diffuseColor = texture2D(iChannel1, hitPos.yz).rgb;\n            else if(abs(normal.y) > 0.1)\n                diffuseColor = texture2D(iChannel1, hitPos.xz).rgb;\n            else\n                diffuseColor = texture2D(iChannel1, hitPos.xy).rgb;\n            shinyness = diffuseColor.r * 0.25;\n        }\n        \/\/ tiled game board\n        else\n        {\n            bool tileIsWhite = mod(floor(hitPos.x * c_quarterGridSize) + floor(hitPos.z * c_quarterGridSize), 2.0) < 1.0;\n            vec3 textureSample = texture2D(iChannel2, hitPos.xz*0.25).rgb;       \n            shinyness = (tileIsWhite ? 1.0 : 0.5) * textureSample.r;\n            diffuseColor = mix(vec3(tileIsWhite ? 1.0 : 0.4), textureSample, 0.33);        \n        }\n    }\n\t\n    if (!hit)\n\t\treturn;\n    \n    \/\/ directional light diffuse\n    pixelColor = diffuseColor * ambientColor;\n    float dp = dot(normal, reverseLightDir);\n\tif(dp > 0.0)\n\t\tpixelColor += (diffuseColor * dp * lightColor);    \n    \n    \/\/ directional light specular    \n    vec3 reflection = reflect(reverseLightDir, normal);\n    dp = dot(rayDir, reflection);\n    if (dp > 0.0)\n        pixelColor += pow(dp, 15.0) * 0.5 * shinyness;\t\n    \n    \/\/ reflection (environment mappping)\n    reflection = reflect(rayDir, normal);\n    pixelColor += textureCube(iChannel3, reflection).rgb * 0.5 * shinyness;\n    \n    \/\/ handle point light at apple\n    if (apple.z == 1.0)\n    {\n        const vec3 appleLightColor = vec3(5.0,0.0,0.0);\n        vec2 appleGrid = floor(clamp(apple.xy * c_maxGridCell, 0.0, c_maxGridCell));\n        float offsetY = sin(iGlobalTime*5.0) * c_radius \/ 3.0;\n        vec3 applePos;\n        applePos.x = (appleGrid.x-c_halfGridSize)\/c_halfGridSize + c_radius;\n        applePos.y = c_radius + offsetY;\n        applePos.z = (appleGrid.y-c_halfGridSize)\/c_halfGridSize + c_radius;\n        \n        float dist = length(applePos - hitPos);\n        float distFactor = 1.0 - clamp(dist \/ 1.0, 0.0, 1.0);\n        distFactor = pow(distFactor, 5.0);\n        \n\t\t\/\/ diffuse\n\t\tvec3 hitToLight = normalize(applePos - hitPos);\n\t\tfloat dp = dot(normal, hitToLight);\n\t\tif(dp > 0.0)\n\t\t\tpixelColor += diffuseColor * dp * appleLightColor * distFactor;\n\t\t\t\n\t\t\/\/ specular\n\t\tvec3 reflection = reflect(hitToLight, normal);\n\t\tdp = dot(rayDir, reflection);\n\t\tif (dp > 0.0)\n\t\t\tpixelColor += pow(dp, 15.0) * appleLightColor * shinyness * distFactor;\n    }    \n}\n\n\/\/=======================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ load the location of the apple, so  we can use it for a dynamic point light\n    vec4 apple = loadValue(txApple);\n    \n    \/\/----- camera\n    vec2 mouse = iMouse.xy \/ iResolution.xy;\n\n    vec3 cameraAt \t= vec3(0.0,0.0,0.0);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 0.0;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) : 0.0;\n\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 4.0;\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y \/ iResolution.x;\n    float cameraDistance\t= 6.0;  \/\/ intuitively backwards!    \n    \n\tvec2 rawPercent = (fragCoord.xy \/ iResolution.xy);\n\tvec2 percent = rawPercent - vec2(0.5,0.5);\n\t\n\tvec3 rayPos;\n\tvec3 rayTarget;\n\t\n\t\/\/ if the mouse button is down\n\tif( iMouse.z > 0.0 ) {\n\t\trayTarget = (cameraFwd * cameraDistance)\n\t\t\t\t  + (cameraLeft * percent.x * cameraViewWidth)\n\t\t          + (cameraUp * percent.y * cameraViewHeight);\n\t\t\n\t\trayPos = cameraPos;\n\t}\n\t\/\/ else handle the case of the mouse button not being down\n\telse {\n\t\trayPos = vec3(0.0,3.0,-3.0);\n\t\tvec3 f = normalize(cameraAt - rayPos);\n\t\tvec3 l = normalize(cross(f,vec3(0.0,1.0,0.0)));\n\t\tvec3 u = normalize(cross(l,f));\n\t\t\n\t\trayTarget = (f * cameraDistance)\n\t\t\t\t  + (l * percent.x * cameraViewWidth)\n\t\t          + (u * percent.y * cameraViewHeight);\t\t\n\t}\n\t\n\tvec3 rayDir = normalize(rayTarget);\n    \n    \/\/vec3 pixelColor = texture2D(iChannel0, rawPercent).rbg;\n    vec3 pixelColor = textureCube(iChannel3, rayDir).rgb;\n    \n\tTraceRay(rayPos, rayDir, pixelColor, apple);\n    \n\tfragColor = vec4(pixelColor, 1.0);\n}","name":"","description":"","type":"image"},{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ the size in X and Y of our gameplay grid\nconst float c_gridSize = 16.0;\nconst float c_maxGridCell = c_gridSize - 1.0;\n\n\/\/ game speed (snake movement speed) in ticks per second\nconst float c_tickRate = 12.0;\n\n\/\/ The grid representing the board\n\/\/ x = radius\n\/\/ y,z = red,green\n\/\/ w = lifetime in ticks (0..255 -> 0..1)\nconst vec4 txCells = vec4(0.0, 0.0, c_gridSize - 1.0, c_gridSize - 1.0);\n\n\/\/ other variables\nconst vec2 txPos   = vec2(0.0, c_gridSize);  \/\/ x,y = snake head pos.   z,w unused\nconst vec2 txDir   = vec2(1.0, c_gridSize);  \/\/ x,y = snake direction.  z,w -> new desired dir based on key presses.\nconst vec2 txState = vec2(2.0, c_gridSize);  \/\/ x = state. y = percent til tick. z = snake length (0.255 -> 0..1). w unused.\nconst vec2 txApple = vec2(3.0, c_gridSize);  \/\/ x,y = location of apple. z = apple is spawned. w unused\n\n\/\/ keys\nconst float KEY_SPACE = 32.5\/256.0;\nconst float KEY_LEFT  = 37.5\/256.0;\nconst float KEY_UP    = 38.5\/256.0;\nconst float KEY_RIGHT = 39.5\/256.0;\nconst float KEY_DOWN  = 40.5\/256.0;\n\n\/\/============================================================\n\n\/\/ save\/load code from IQ's shader: https:\/\/www.shadertoy.com\/view\/MddGzf\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nfloat isInside( vec2 p, vec4 c ) { vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y); }\n\nvec4 loadValue( in vec2 re )\n{\n    return texture2D( iChannel0, (0.5+re) \/ iChannelResolution[0].xy, -100.0 );\n}\n\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\nvoid storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\n\/\/============================================================\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\/\/============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    if (fragCoord.x > c_gridSize || fragCoord.y > c_gridSize + 1.0)\n        discard;\n    \n    \/\/----- Load State -----\n    vec2 cellPos = floor(fragCoord);  \n    \n    vec4 pos   = loadValue(txPos);\n    vec4 dir   = loadValue(txDir);\n    vec4 state = loadValue(txState);\n    vec4 cell  = loadValue(fragCoord.xy-0.5);\n    vec4 apple = loadValue(txApple);\n    \n    \/\/ convert dir from 0..1 to -1..1\n    dir = (dir * 2.0) - 1.0;\n    \n    \/\/ reset game state on first frame\n    if (iFrame == 0)\n        state = vec4(0.0);\n    \n    \/\/ state .0 -> reset game state\n    if (state.x < 0.1)\n    {\n        state.x = 0.1;\n        state.y = 0.0;\n        state.z = 3.0 \/ 255.0;\n        pos   = vec4(0.5, 0.5, 0.0, 0.0);\n        dir   = vec4(0.0);\n        apple = vec4(0.0);\n        \n        \/\/ write a snake body at the starting position of the player\n        vec2 posGrid = floor(pos.xy * c_maxGridCell);\n        if (cellPos == posGrid)\n            cell = vec4(1.0,0.0,1.0,state.z);\n        else\n            cell = vec4(0.0);\n    }\n   \t\/\/ state .1 -> we are playing!\n    else if (state.x < 0.2)\n    {        \n        \/\/ try and spawn the apple if we need to\n        if (apple.z == 0.0)\n        {\n            apple.x = rand(vec2(float(iFrame)*0.122+iDate.w*0.845, float(iFrame)*0.647+iDate.w*0.753));\n            apple.y = rand(vec2(float(iFrame)*0.546+iDate.w*0.342, float(iFrame)*0.342+iDate.w*0.935));\n            vec2 appleCell = floor(apple.xy * c_maxGridCell);\n            \n            \/\/ if we fail to select an empty spot on the grid, try again next frame.\n            vec4 cellAtApple = texture2D( iChannel0, (appleCell+0.5) \/ iChannelResolution[0].xy, -100.0 );\n            if (cellAtApple.z == 0.0)\n            {\n                apple.z = 1.0;\n                \n                if (cellPos == appleCell)\n            \t\tcell = vec4(0.75,1.0,0.0,0.0);\n            }\n        }\n        \n        \/\/ handle queueing up directional changes\n        float moveLeft  = texture2D( iChannel1, vec2(KEY_LEFT,0.25) ).x;            \n        float moveRight = texture2D( iChannel1, vec2(KEY_RIGHT,0.25) ).x;\n        float moveUp    = texture2D( iChannel1, vec2(KEY_UP,0.25) ).x;\n        float moveDown  = texture2D( iChannel1, vec2(KEY_DOWN,0.25) ).x;\n\n        if (moveLeft == 1.0 && dir.x == 0.0)\n        {\n            dir.z =  1.0;\n            dir.w =  0.0;\n        }\n        else if (moveRight == 1.0 && dir.x == 0.0)\n        {\n            dir.z = -1.0;\n            dir.w =  0.0;\n        }\n        else if (moveUp == 1.0 && dir.y == 0.0)\n        {\n            dir.z =  0.0;\n            dir.w =  1.0;                \n        }\n        else if (moveDown == 1.0 && dir.y == 0.0)\n        {\n            dir.z =  0.0;\n            dir.w = -1.0;                \n        }        \n        \n        \/\/ tick() when we should\n        state.y += iTimeDelta * c_tickRate;\n        if (state.y > 1.0)\n        {\n            bool ateApple = false;\n            \n            state.y = 0.0;\n            \n        \t\/\/ handle queued direction changes\n            dir.xy = dir.zw;\n            \n            \/\/ if the snake is moving\n            if (length(dir) > 0.0)\n            {\n                \/\/ handle snake movement\n                vec2 posGrid = floor(pos.xy * c_maxGridCell);\n                posGrid += dir.xy;\n                pos.xy = posGrid \/ c_maxGridCell;\n\n                \/\/ you die if you go out of bounds\n                if (posGrid.x < 0.0 || posGrid.y < 0.0 || posGrid.x > c_maxGridCell || posGrid.y > c_maxGridCell)\n                    state.x = 0.2;         \n                \n                vec4 cellAtSnakeHead = texture2D( iChannel0, (posGrid+0.5) \/ iChannelResolution[0].xy, -100.0 );\n\n                \/\/ you also die if the new place you want to go already has a snake in it\n                if (length(dir) > 0.0 && texture2D( iChannel0, (posGrid+0.5) \/ iChannelResolution[0].xy, -100.0 ).x == 1.0)\n                    state.x = 0.2;\n                \n                \/\/ if you eat an apple, we need to spawn a new apple and also increment snake lifetime in state\n                if (cellAtSnakeHead.y == 1.0)\n                {\n                    apple.z = 0.0;\n                    state.z = (floor(state.z * 255.0) + 1.0) \/ 255.0;\n                    ateApple = true;\n                }                         \n                \n                \/\/ if the cell we are processing is the new head of the snake, put a snake body part there\n                if (cellPos == posGrid)\n                    cell = vec4(1.0,0.0,1.0, state.z); \n\t\t\t\t\/\/ if we didn't eat an apple this tick, decriment lifetime of all snake body parts\n                \/\/ and destroy any that hit zero\n                else if (!ateApple && cell.w > 0.0)\n                {\n                    cell.w = (floor(cell.w * 255.0) - 1.0) \/ 255.0;\n                    if (cell.w <= 0.0)\n                        cell = vec4(0.0);\n                }\n            }\n        }\n    }\n   \t\/\/ state .2 -> we are dead!\n    else if (state.x < 0.3)\n    {\n        \/\/ reset when user presses space\n        if (texture2D( iChannel1, vec2(KEY_SPACE,0.25) ).x == 1.0)\n        \tstate.x = 0.0;\n        \n        \/\/ Death effect - make snake yellow\n        state.y += iTimeDelta * 30.0;\n        if (state.y > 1.0)\n        {\n            if (cell.x > 0.9)\n                cell.y = min(cell.y+0.25,1.0);\n            \n            state.y = 0.0;\n        }\n    }\n    \n    \/\/ convert dir from -1..1 to 0..1\n    dir = (dir + 1.0) * 0.5;    \n    \n    \/\/----- Save State -----\n    fragColor = vec4(0.0);\n    storeValue(txPos  , pos  , fragColor, fragCoord);\n    storeValue(txDir  , dir  , fragColor, fragCoord);\n    storeValue(txState, state, fragColor, fragCoord);\n    storeValue(txCells, cell , fragColor, fragCoord);\n    storeValue(txApple, apple, fragColor, fragCoord);\n}","name":"","description":"","type":"buffer"}]}}