{"Shader":{"ver":"0.1","info":{"id":"4l2GWm","date":"1429676480","viewed":906,"name":"Quincunx Anti Aliasing","username":"demofox","description":"Quincunx Anti Aliasing on left, no antialiasing on right.  In real quincunx anti aliasing, you would render the scene twice so that \"corner samples\" could be shared to make rendering more efficient.","likes":7,"published":3,"flags":0,"tags":["aa","quincunx"],"hasliked":0},"renderpass":[{"inputs":[{"id":1,"src":"\/presets\/tex00.jpg","ctype":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":4,"src":"\/presets\/tex03.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":6,"src":"\/presets\/tex05.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":7,"src":"\/presets\/tex06.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/*\n  Written by Alan Wolfe\n  http:\/\/demofox.org\/\n  http:\/\/blog.demofox.org\/\n\nMore info here:\nhttp:\/\/blog.demofox.org\/2015\/04\/22\/quincunx-antialiasing\/\n\nQuincunx anti aliasing works by using 5 samples per pixel in the following configuration:\n\n  B        C\n  *--------*\n  |   A    |\n  |   *    |\n  |        |\n  *--------*\n  D        E\n\nA is the center of the pixel that you would normally draw.  It has a weight of 1\/2.\n\nB,C,D,E are offset from the center by half a pixel and each having a weighting of 1\/8.\n\nThe weights of all the samples add up to 1.0 but the center has the heaviest contribution to the final image.\n\nIn shadertoy, quincunx AA means that you have to do 5 times as much rendering per pixel, but\nin real rendering situations, you can achieve quincunx by doing two full screen renders.\n\nThe first render renders the screen with an offset of half a pixel (-0.5,-0.5) and the second render\nuses the results of that first render to get the corner pixels to mix into the center pixel.\n\nThe benefit of doing this is that those corner pixels can be shared by all the pixels that use them\nwhich makes it so you are basically doing 2x super sampling AA, but you get benefits closer to 5x!\n\n*\/\n\n#define MINSCALE 1.0\n#define MAXSCALE 8.0\n#define TIMEMULTIPLIER 0.5\n\n\/\/ camera wander: sin(time) controls magnitude, time controls angle\nfloat cameraAngle = iGlobalTime * 0.32;\nfloat cameraMag = sin(iGlobalTime*0.89) * 0.25 +1.0;\n\nvec2 cameraOffset = vec2(cameraMag * cos(cameraAngle), cameraMag * sin(cameraAngle));\n\n\/\/ aspect ratio correction\nvec2 resolution = vec2 (iResolution.x \/ 2.0, iResolution.x);\nfloat g_arcorrection = resolution.x \/ resolution.y;\n\n\/\/ image zoom, defined by time\nfloat g_scale = (sin(iGlobalTime * TIMEMULTIPLIER + 1.57) * 0.5 + 0.5) * (MAXSCALE - MINSCALE) + MINSCALE;\n\n\n#define DRAW_CIRCLE(_x,_y,_radius,_color) if (length(pos-vec2(_x,_y)) < _radius) return _color;\n\n#define DRAW_RECT(_x,_y,_w,_h,_color) if ((abs(pos.x-(_x)) < _w\/2.0)&&(abs(pos.y-(_y)) < _h\/2.0)) return _color;\n\n#define DRAW_OBB(_x,_y,_w,_h,_r,_color) {vec2 rel = vec2(pos.x-(_x), pos.y-(_y)); rel = vec2(cos(_r)*rel.x-sin(_r)*rel.y,sin(_r)*rel.x+cos(_r)*rel.y); if ((abs(rel.x) < _w\/2.0)&&(abs(rel.y-_y) < _h\/2.0)) return _color;}\n\nvec3 GetPixelColor(vec2 pos)\n{\n    \/\/ thin white grill\n    DRAW_RECT(-0.0,0.50,1.0,0.005,vec3(1,1,1));\n    DRAW_RECT(-0.0,0.52,1.0,0.005,vec3(1,1,1));\n    DRAW_RECT(-0.0,0.54,1.0,0.005,vec3(1,1,1));\n    DRAW_RECT(-0.0,0.56,1.0,0.005,vec3(1,1,1));\n    DRAW_RECT(-0.0,0.58,1.0,0.005,vec3(1,1,1));\n    DRAW_RECT(-0.0,0.60,1.0,0.005,vec3(1,1,1));\n    \n    \/\/ textured circles\n    DRAW_CIRCLE(-0.7, 0.7,0.25,texture2D(iChannel0, pos).xyz);\n    DRAW_CIRCLE(-0.7,-0.7,0.25,texture2D(iChannel1, pos).xyz);\n    DRAW_CIRCLE( 0.7,-0.7,0.25,texture2D(iChannel2, pos).xyz);\n    DRAW_CIRCLE( 0.7, 0.7,0.25,texture2D(iChannel3, pos).xyz);\n    \n    \/\/ spinning red and blue box\n    DRAW_OBB(-0.5, 0.0, 0.3, 0.1,  iGlobalTime, vec3(1.0, 0.0, 0.0));\n    DRAW_OBB(-0.5, 0.0, 0.1, 0.3, -iGlobalTime, vec3(0.0, 0.0, 1.0));\n    \n    \/\/ concentric spiral boxes\n    DRAW_OBB( 0.5, 0.0, 0.1, 0.1, 0.4, vec3(0.0));\n    DRAW_OBB( 0.5, 0.0, 0.2, 0.2, 0.3, vec3(1.0));\n    DRAW_OBB( 0.5, 0.0, 0.3, 0.3, 0.2, vec3(0.0));\n    DRAW_OBB( 0.5, 0.0, 0.4, 0.4, 0.1, vec3(1.0));\n    DRAW_OBB( 0.5, 0.0, 0.5, 0.5, 0.0, vec3(0.0));\n       \n    \/\/ untextured circles\n    DRAW_CIRCLE(0.0,0.0,0.1,vec3(0.9,0.1,0.9));\n    DRAW_CIRCLE(0.0,0.0,1.0,vec3(0.1,0.9,0.1));\n    \n    \/\/ grid background\n    float gridColor = mod(floor(pos.x*20.0),2.0) == mod(floor(pos.y*20.0),2.0) ? 0.8 : 0.0;  \n    return vec3(gridColor);\n}\n\nvec2 PixelToWorld (in vec2 coord)\n{\n    vec2 ret = ((coord \/ resolution) - vec2(0.5,0.5*g_arcorrection)) * g_scale;\n    ret *= vec2(g_arcorrection, -1.0);\n    return ret + cameraOffset;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pixelColor;\n    \n    \/\/ draw middle line\n    if (abs(fragCoord.x - resolution.x) < 2.0)\n    {\n        pixelColor = vec3(1.0,1.0,1.0);\n    }\n    \/\/ right side = no AA\n\telse if( fragCoord.x > resolution.x)\n\t{\n        fragCoord.x -= resolution.x;\n        pixelColor = GetPixelColor(PixelToWorld(fragCoord.xy));\n\t}\n\t\/\/ left side = quincunx rendering\n\telse\n    {\n\t\tpixelColor =  GetPixelColor(PixelToWorld(fragCoord.xy + vec2( 0.0, 0.0))) \/ 2.0;\n        pixelColor += GetPixelColor(PixelToWorld(fragCoord.xy + vec2( 0.5, 0.5))) \/ 8.0;\n        pixelColor += GetPixelColor(PixelToWorld(fragCoord.xy + vec2( 0.5,-0.5))) \/ 8.0;\n        pixelColor += GetPixelColor(PixelToWorld(fragCoord.xy + vec2(-0.5,-0.5))) \/ 8.0;\n        pixelColor += GetPixelColor(PixelToWorld(fragCoord.xy + vec2(-0.5, 0.5))) \/ 8.0;\t\n\t}\t\t\n\t\n    \/\/ write pixel\n\tfragColor = vec4(pixelColor, 1.0);\n}","name":"","description":"","type":"image"}]}}