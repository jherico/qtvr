{"Shader":{"ver":"0.1","info":{"id":"XljXW3","date":"1446923376","viewed":459,"name":"Hilbert curve 6","username":"FabriceNeyret2","description":"a variant of https:\/\/www.shadertoy.com\/view\/XljSW3<br\/><br\/>Sorry for the aliasing: shadertoy can't evaluate mipmap correctly at jumps. I had to force bias at -5) ","likes":8,"published":3,"flags":0,"tags":["hilbertcurve"],"hasliked":0},"renderpass":[{"inputs":[{"id":8,"src":"\/presets\/tex07.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define plot(U,l) ( dot(U,l) > 0. ?  abs( dot(U , vec2(-l.y,l.x)) ) : 0. )\n#define plotC(U,l)  abs( length(U-(l)\/2.) - .5 )\n#define ang(U,P) atan(U.y-P.y,U.x-P.x) \/ 1.57\n\nvoid mainImage( out vec4 o,  vec2 U )\n{\n    o = vec4(0.0);\n    U \/= iResolution.y; U.x -= .3; U+=1e-5; \/\/ or bug at depth 2. why ?\n    vec2 P = vec2(.5), I=vec2(1,0),J=vec2(0,1), fU, l=-I,r=l, k; \/\/,N=vec2(0); \n    float s = 1.,S=1.,T=0.,n,u,v, t=iGlobalTime;  \/\/  mat2 R = mat2(0,-1,-1,0);\n    \n    for (float i=0.; i<10.; i++) {\n        if (i > mod(t,7.) ) break;\n        fU = step(.5,U);         \/\/ select child\n        bvec2 c = bvec2(fU);     \n        U = 2.*U - fU;           \/\/ go to new local frame\n        n = (1.-fU.x)*(1.-fU.y)+fU.x*(2.+fU.y); \/\/ local index of nodes\n        T = 4.*T +  n *S +(1.-S)*1.5;           \/\/ global indexing\n        u =   (n==0.) ? 1.-ang(U,vec2(0)) \/\/ put after the loop ?\n            : (n==1.) ? 2.+ang(U,vec2(1))\n            : (n==2.) ? 1.+ang(U,  J  )\n            :           2.-ang(U,  I  ) ;\n        u = u*S +(1.-S)\/2.;          \/\/ local curvilinear coordinate (T+u = continuous index)\n        l = c.x ? c.y ? -J : -I            \/\/ node left segment\n                : c.y ?  l :  J;\n        r = (c.x==c.y)?  I : c.y ?-J:J;    \/\/ node right segment\n        \/\/ the heart of Hilbert curve : \n        if (c.x) { U.x = 1.-U.x;  l.x=-l.x;  r.x=-r.x;  k=l;l=r;r=k; S=-S; } \/\/ sym\n        if (c.y) { U   = 1.-U.yx; l  =-l.yx; r  =-r.yx; }  \/\/ .5+(U-.5)*R    \/\/ rot+sym        \n        s*=2.; \n    }\n    v = length(l+r) > 0. ? plotC (U-P, l+r) : plot (U-P, l) + plot (U-P, r); \/\/ axial coordinate\n    if (dot(l,r)!=0.) u= dot(U*S+(1.-S)\/2.,r);                \/\/ complete curvilinear coordinate\n    o += smoothstep(.33+.01*log2(s),.33-.01*log2(s),v);       \/\/ ribbon mask\n  \/\/o += smoothstep(.33+.03*log2(s),.33-.03*log2(s), length( vec2(.5*(fract(u-iGlobalTime)*2.-1.),v) ));\n  \/\/o *= texture2D(iChannel0,vec2(u-t,v),-5.); \/\/ without texture2DLod\n    o *= texture2DLodEXT(iChannel0,vec2(u-t,v),log2(s*iChannelResolution[0].y\/iResolution.y));\n  \/\/o *= (T+u)\/s\/s;  \/\/vec4(N,s-N)\/s;\n  \/\/o *= .6+.4*sin(10.*(T+u)-3.*iGlobalTime);\n    \n    fU = min(U,1.-U);  if (min(fU.x,fU.y) < 0.) o*=0.;        \/\/ clamp\n}","name":"","description":"","type":"image"}]}}