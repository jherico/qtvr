{"Shader":{"ver":"0.1","info":{"id":"ll2XR1","date":"1441743491","viewed":802,"name":"ray trace test","username":"CaiusTSM","description":"blah","likes":1,"published":3,"flags":0,"tags":["raytrace"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"float sphere(vec3 rayOrigin, vec3 rayDirection, vec3 sphereCenter, float sphereRadius)\n{\n    vec3 rc = rayOrigin - sphereCenter; \/\/ create arrow pointing from sphereCenter to ray origin\n    \n    float c = dot(rc, rc) - (sphereRadius * sphereRadius); \/\/ magnitude of rc minus sphere radius squared\n    \n    float b = dot(rayDirection, rc); \/\/ dot product between ray direction and rc which gives a unit vector along rc's axis\n    \n    float d = b * b - c; \/\/ b squared minus c (gives distance squared)\n    \n    float t = -b - sqrt(abs(d)); \/\/ sqrt to get distance d; -b minus distance d\n    \n    float st = step(0.0, min(t, d)); \/\/ step from 0 the min of distance d or t\n    \n    return mix(-1.0, t, st); \/\/ return the interpolation between t and stepped t (st)\n}\n\nvec3 background(float t, vec3 rd)\n{\n    vec3 light = normalize(vec3(sin(t), 0.6, cos(t)));\n    \n    float sun = max(0.0, dot(rd, light));\n    \n    float sky = max(0.0, dot(rd, vec3(0.0, 1.0, 0.0)));\n    \n    float ground = max(0.0, -dot(rd, vec3(0.0, 1.0, 0.0)));\n    \n    return (pow(sun, 256.0) + 0.2 * pow(sun, 2.0)) * vec3(2.0, 1.6, 1.0) + pow(ground, 0.5) * vec3(0.4, 0.3, 0.2) + pow(sky, 1.0) * vec3(0.5, 0.6, 0.7);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (-1.0 + 2.0*fragCoord.xy \/ iResolution.xy) * vec2(iResolution.x\/iResolution.y, 1.0);\n    \n    vec3 ro = vec3(0.0, 0.0, -3.0); \/\/ ray origin\n    \n    vec3 rd = normalize(vec3(uv, 1.0)); \/\/ ray direction.\n    \n    vec3 p = vec3(0.0, 0.0, 0.0); \/\/ sphere center\n    \n    float t = sphere(ro, rd, p, 1.0); \/\/ ray trace sphere (get the current float represtenting current distance to sphere surface)\n    \n    vec3 nml = normalize(p - (ro + rd * t)); \/\/ normalize(center - ((ray origin + ray direction) * distance)) \n    \n    vec3 bgCol = background(iGlobalTime, rd); \/\/ get the bg color\n    \n    rd = reflect(rd, nml); \/\/ relect off of the normal nml (from the sphere)\n    \n    vec3 col = background(iGlobalTime, rd) * vec3(0.9, 0.8, 1.0); \/\/ bg color times the color we want the bg to be (so its not just black and white and grey)\n    \n    fragColor = vec4( mix(bgCol, col, step(0.0, t)), 1.0 ); \/\/ interpolate the background color and the relected color\n}","name":"","description":"","type":"image"}]}}