{"Shader":{"ver":"0.1","info":{"id":"ltXSRr","date":"1434060151","viewed":756,"name":"Rock Sphere","username":"dgreensp","description":"Raymarch a rocky sphere","likes":7,"published":3,"flags":0,"tags":["sphererockstoneraymarch"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"const int MAX_STEPS = 64;\nconst float CLOSENESS = 0.01;\nconst float EPSILON = 0.01;\n\nfloat noise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.-2.*f);\n\t\n    float n = p.x + p.y*157. + 113.*p.z;\n    \n    vec4 v1 = fract(753.5453123*sin(n + vec4(0., 1., 157., 158.)));\n    vec4 v2 = fract(753.5453123*sin(n + vec4(113., 114., 270., 271.)));\n    vec4 v3 = mix(v1, v2, f.z);\n    vec2 v4 = mix(v3.xy, v3.zw, f.y);\n    return mix(v4.x, v4.y, f.x);\n}\n\nfloat field(vec3 p) {\n   \/\/ random rotation reduces artifacts\n   mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                 0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                 -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n   vec3 p1 = M*p;\n   vec3 p2 = M*p1;\n   float n1 = noise(p1*5.);\n   float n2 = noise(p2*10.);\n   float n3 = noise(p1*20.);\n   float n4 = noise(p1*40.);\n   float rocky = 0.1*n1*n1 + 0.05*n2*n2 + 0.02*n3*n3 + 0.01*n4*n4;\n   float sph_dist = length(p) - 1.0;\n   return sph_dist + (sph_dist < 0.1 ? rocky*0.8 : 0.);\n}\n\nfloat field_lores(vec3 p) {\n   \/\/ random rotation reduces artifacts\n   mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                 0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                 -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n   vec3 p1 = M*p;\n   float n1 = noise(p1*5.);\n   float rocky = 0.1*n1*n1;\n   return length(p) - 1.0 + rocky*0.8;\n}\n\n\nvec3 getNormal(vec3 p, float value, mat3 rot) {\n    vec3 n = vec3(field(rot*vec3(p.x+EPSILON,p.y,p.z)),\n                  field(rot*vec3(p.x,p.y+EPSILON,p.z)),\n                  field(rot*vec3(p.x,p.y,p.z+EPSILON)));\n    return normalize(n - value);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 src = vec3(3. * (fragCoord.xy - 0.5*iResolution.xy) \/ iResolution.yy, 2.0);\n    vec3 dir = vec3(0., 0., -1.);\n    \n    float ang = iGlobalTime*1.0;\n    mat3 rot = mat3(-sin(ang),0.0,cos(ang),0.,1.,0.,cos(ang),0.,sin(ang));\n\n    \n    float t = 0.0;\n    vec3 loc = src;\n    float value;\n    int steps = 0;\n    for (int i=0; i < MAX_STEPS; i++) {\n        steps++;\n        loc = src + t*dir;\n        if (loc.z < -1.) break;\n        value = field(rot*loc);\n        if (value <= CLOSENESS) break;\n        t += value*0.5;\n    }\n    \/\/ attempt at self-occlusion\n    float shad1 = max(0.,field_lores(rot*(loc+normalize(vec3(-1.,1.,1.))*0.1)))\/0.1;\n    float shad2 = max(0.,field_lores(rot*(loc+normalize(vec3(-1.,1.,1.))*0.15)))\/0.15;\n    float shad3 = max(0.,field_lores(rot*(loc+normalize(vec3(-1.,1.,1.))*0.2)))\/0.2;\n    float shad = clamp(shad1*0.333333 + shad2*0.333333 + shad3*0.333333, 0., 1.);\n    shad = mix(shad, 1.0, 0.3);\n    \/\/ attempt at some sort of ambient \"glow\"\n    float ambient = clamp(field(rot*(loc - 0.5 * dir))\/0.5*1.2, 0., 1.);\n        \n    if (value > CLOSENESS) fragColor = vec4(0., 0., 0., 1.);\n    else {\n      vec3 normal = getNormal(loc, value, rot);\n      float light = dot(normal, normalize(vec3(-1.,1.,3.)));\n      float totalLight = mix(ambient, 1.0*max(0.,shad*light), 0.6);\n    \n      vec3 color = mix(vec3(1.,0.5,0.3), vec3(0.7,1.0,0.8), 1.-(1.0-length(loc))*10.);\n        \n      fragColor = vec4(color*totalLight, 1.0);\n    }\n}","name":"","description":"","type":"image"}]}}