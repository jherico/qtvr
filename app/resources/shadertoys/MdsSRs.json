{"Shader":{"ver":"0.1","info":{"id":"MdsSRs","date":"1406019254","viewed":1334,"name":"Analytical Normals","username":"iq","description":"Left, numerical normals. Right, analytical normals.","likes":17,"published":3,"flags":0,"tags":["3d","noise","normals","analytical","numerical"],"hasliked":0},"renderpass":[{"inputs":[{"id":17,"src":"\/presets\/tex12.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\/\/ Computes analytical normals (right side of the screen) for a value-noise based fbm(), \n\/\/ and compares them to the numerically computer normals (left side of the screen) which\n\/\/ are computed by the standard central difference method.\n\/\/\n\/\/ Computing normals analytically has the benefit of being faster and \"free\", while\n\/\/ numerical normals are easier to filter for antialiasing.\n\n\n\/\/ value noise, and its analytical derivatives\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n\tfloat a = texture2D(iChannel0,(p+vec2(0.5,0.5))\/256.0,-100.0).x;\n\tfloat b = texture2D(iChannel0,(p+vec2(1.5,0.5))\/256.0,-100.0).x;\n\tfloat c = texture2D(iChannel0,(p+vec2(0.5,1.5))\/256.0,-100.0).x;\n\tfloat d = texture2D(iChannel0,(p+vec2(1.5,1.5))\/256.0,-100.0).x;\n\t\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nconst float scale  = 0.003;\nconst float height = 180.0;\n\nvec4 fbmd( in vec2 x )\n{\n    float a = 0.0;\n    float b = 1.0;\n\tfloat f = 1.0;\n    vec2  d = vec2(0.0);\n    for( int i=0; i<10; i++ ) \/\/ 10 octaves\n    {\n        vec3 n = noised(f*x*scale);\n        a += b*n.x;           \/\/ accumulate values\t\t\n        d += b*n.yz*f*scale;  \/\/ accumulate derivatives (note that in this case b*f=1.0)\n        b *= 0.5;             \/\/ amplitude decrease\n        f *= 2.0;             \/\/ frequency increase\n    }\n\n\ta *= height;\n\td *= height;\n\t\n\t\/\/ compute normal based on derivatives\n\treturn vec4( a, normalize( vec3(-d.x,1.0,-d.y) ) );\n}\n\n\/\/ raymarch against fbm heightfield\nvec4 interesect( in vec3 ro, in vec3 rd )\n{\n\tvec4 res = vec4(-1.0);\n    float t = 0.0;\n\tfor( int i=0; i<70; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n\t\tvec4 hnor = fbmd( pos.xz );\n\n\t\tres = vec4(t,hnor.yzw);\n\t\tif( (pos.y-hnor.x)<0.05 ||  t>2000.0) break;\n\t\t\n\t\tt += (pos.y-hnor.x)*(0.001+hnor.z);\n\t}\n\n\tif( t>2000.0 ) res = vec4(-1.0);\n\treturn res;\n}\n\n\/\/ compute normal numerically\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 e = vec3(0.01,0.0,0.0);\n\treturn normalize( vec3(fbmd(pos.xz-e.xy).x - fbmd(pos.xz+e.xy).x,\n                           2.0*e.x,\n                           fbmd(pos.xz-e.yx).x - fbmd(pos.xz+e.yx).x ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy) \/ iResolution.y;\n\n\t\/\/ camera anim\n\tvec3 ro = vec3( 1000.0*cos(0.001*iGlobalTime), 0.0, 1000.0*sin(0.001*iGlobalTime) );\n\tvec3 ta = vec3( 0.0 );\n    ro.y = fbmd(ro.xz).x + 2.0;\n    ta.y = fbmd(ro.xz).x + 2.0;\n\t\n    \/\/ camera matrix\t\n\tvec3  cw = normalize( ta-ro );\n\tvec3  cu = normalize( cross(cw,vec3(0.0,1.0,0.0)) );\n\tvec3  cv = normalize( cross(cu,cw) );\n\tvec3  rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n\t\/\/ render\n\tvec3 col = vec3(0.0);\n    vec4 tnor = interesect( ro, rd );\n\tfloat t = tnor.x;\n\t\n\t\/\/ commented out becasue of an ANGLE bug:\n    \/\/if( t>0.0 )\n\t{\n\t\tvec3 pos = ro + t*rd;\n\t\tcol = mix( tnor.yzw, calcNormal( pos ), step(0.0,p.x) );\n        col = 0.5 + 0.5*col;\n\t\tcol *= exp(-0.000015*t*t);\n\t}\n\t\n\t\/\/ here becasue of the ANGLE bug:\n\tcol *= smoothstep(-0.5,0.0,t);\n\n\tcol = mix( vec3(0.0), col, smoothstep(0.006,0.007,abs(p.x)) );\n\t\n    fragColor=vec4(col,1.0);\n}","name":"","description":"","type":"image"}]}}