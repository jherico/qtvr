{"Shader":{"ver":"0.1","info":{"id":"4dVGRR","date":"1453019067","viewed":173,"name":"3D paint","username":"josh","description":"3D painter. Hold mouse button to draw. Hold space to paint with webcam.","likes":6,"published":3,"flags":50,"tags":["paint","multipass"],"hasliked":0},"renderpass":[{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Started with cabbibo's https:\/\/www.shadertoy.com\/view\/Xl2XWt\n\n\nconst float MAX_TRACE_DISTANCE = 3.0;           \/\/ max trace distance\nconst float INTERSECTION_PRECISION = 0.001;        \/\/ precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\n\nconst float PI = 3.145;\n\nvec3 spCenter = vec3( 0.0 , 0.0 , -0.8 );\nfloat spRad = 1.1;\n\n\/\/----\n\/\/ Camera Stuffs\n\/\/----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n\/\/ checks to see which intersection is closer\n\/\/ and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\n\/\/--------------------------------\n\/\/ Modelling \n\/\/--------------------------------\nvec2 map( vec3 pos ){  \n    \n \tvec2 res = vec2( sdSphere( pos - spCenter , spRad ) , 1. );     \n    return res;\n    \n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n\n\n\/\/ Calculates the normal by taking a very small distance,\n\/\/ remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\n\n\nvec3 render( vec2 res , vec3 ro , vec3 rd ){\n   \n\n  vec3 color = vec3( 0. );\n    \n    \n  if( res.y > -.5 ){\n      \n    vec3 pos = ro + rd * res.x;\n    vec3 norm = calcNormal( pos );\n       \n      \n    \/\/ Balloon\n    if( res.y == 1. ){\n        \n        vec2 bUV;\n        bUV.x = 0.5 + atan( norm.z, norm.x ) \/ (2.0 * PI );\n        bUV.y = 0.5 + asin( norm.y ) \/ PI;\n    \tvec4 c = texture2D( iChannel0, bUV.xy );\n        \n        color = c.rgb * c.a  + vec3( 1., 1., 1. ) * ( 1. - c.a );\n        vec3 balloonColor = vec3( 1. , 0. , 0. );\n    }\n        \n  }\n   \n  return color;\n    \n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)\/iResolution.y;\n\n    float ang = iGlobalTime * 0.2;\n    vec3 ro = spCenter + vec3( cos( ang ), 0., sin(ang ) ) * 3.;\n    \n    \/\/ camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, spCenter, 0.0 );  \/\/ 0.0 is the camera roll\n    \n\t\/\/ create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); \/\/ 2.0 is the lens length\n    \n    vec2 res = calcIntersection( ro , rd  );\n\n\t\n    vec3 color = render( res , ro , rd );\n    \n\tfragColor = vec4(color,1.0);\n    \n}\n","name":"","description":"","type":"image"},{"inputs":[{"id":31,"src":"\/presets\/webcam.png","ctype":"webcam","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Started with cabbibo's https:\/\/www.shadertoy.com\/view\/Xl2XWt\n\n\nconst float MAX_TRACE_DISTANCE = 3.0;           \/\/ max trace distance\nconst float INTERSECTION_PRECISION = 0.001;        \/\/ precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\n\nconst float PI = 3.145;\n\nvec3 spCenter = vec3( 0.0 , 0.0 , -0.8 );\nfloat spRad = 1.1;\n\nvec3 drawColor = vec3( 0.1, 0.8, 0.1 );\n\n\/\/----\n\/\/ Camera Stuffs\n\/\/----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n\/\/ checks to see which intersection is closer\n\/\/ and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\n\/\/--------------------------------\n\/\/ Modelling \n\/\/--------------------------------\nvec2 map( vec3 pos ){  \n    \n \tvec2 res = vec2( sdSphere( pos - spCenter , spRad ) , 1. ); \n    \n    return res;\n    \n}\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\nconst float KEY_SP    = 32.5\/256.0;\n\nfloat isKeyPressed(float key)\n{\n\treturn texture2D( iChannel1, vec2(key, 0.1) ).x;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/vec2 mP = iMouse.xy \/ iResolution.xy;\n    \n    vec2 p =(-iResolution.xy + 2.0*iMouse.xy)\/iResolution.y;\n    \n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    \n    float hAngle = uv.x * 2.0 * -PI - PI * 0.5;\n    float vAngle = uv.y * PI;\n    vec3 n;    \n    n.x = sin(vAngle) * sin(hAngle);\n    n.y = -cos(vAngle);\n    n.z = sin(vAngle) * cos(hAngle);\n    \n    n = normalize(n);\n    \n    vec3 wPos = vec3( 0.0 , 0.0 , -0.8 ) + n * 1.1;\n\n    float ang = iGlobalTime * 0.2;\n    vec3 ro = spCenter + vec3( cos( ang ), 0., sin(ang ) ) * 3.;\n    \n    \/\/ camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, spCenter, 0.0 );  \/\/ 0.0 is the camera roll\n    \n\t\/\/ create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); \/\/ 2.0 is the lens length\n    \n    vec2 res = calcIntersection( ro , rd  );\n\n    vec4 c = texture2D(iChannel0, uv.xy );\n    \n    vec3 point = ( ro + rd * res.x );\n    if( iMouse.z > 0.0 && length( point - wPos ) < 0.1 ) \n    {\n        if( isKeyPressed( KEY_SP ) > 0.)\n        {\n            \n            vec3 prP = wPos - dot( wPos - point, n ) * n;\n            prP = prP - point;\n            prP = prP * 5. + 0.5; \n            vec4 b = texture2D(iChannel2, prP.xy );\n            c = c * ( 1.0 - b.a ) + b * b.a;  \n        }\n        else\n        {\n    \t\tc = vec4(drawColor.rgb, 1.0 );   \n        }\n    }\n\t\n    \n    \n\tfragColor = c;\n\n    \n        \n}\n\n","name":"","description":"","type":"buffer"}]}}