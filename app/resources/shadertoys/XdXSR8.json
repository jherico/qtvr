{"Shader":{"ver":"0.1","info":{"id":"XdXSR8","date":"1396274086","viewed":894,"name":"noise histogramm 2","username":"FabriceNeyret2","description":"Evaluates histogramm of Perlin noise algorithms.<br\/>In theory fbm should be Gaussian...<br\/>Try larger STEP to better average.","likes":3,"published":3,"flags":0,"tags":["noise","perlin","histogramm"],"hasliked":0},"renderpass":[{"inputs":[{"id":17,"src":"\/presets\/tex12.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define SAMPLE 200      \/\/ per 1x1 pixel bin\n#define STEP 32.        \/\/ bin width\n#define LAZZY 1         \/\/ lazzy exact noise evaluation\n#define SMOOTH 0.       \/\/ smooth histogramm on 3 values.  0. \/ 1. \/ sub-relaxation\n#define NOISE_SRC 1  \t\/\/ 0: texture 1: math\n\n\n#define NOISE_TYPE 1    \/\/ 1: linear  2: blobby (abs)  3:  hairy (1-abs)\n\n\n#define ANIM 1          \n#define PI 3.14159\n\n#if ANIM\n  float t = iGlobalTime;\n#else\n  float t = 0.; \n#endif\nvec2 FragCoord;\n\n\/\/ --- noise functions from https:\/\/www.shadertoy.com\/view\/XslGRr\n\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )  \/\/ base rand in [0,1]; \n{\n#if NOISE_SRC==0\n\treturn texture2D(iChannel0,vec2(n,n\/256.)).r;\n#elif NOISE_SRC==1\n\treturn fract(sin(n-765.36334)*43758.5453);\n#endif\n   \n    \n}\n\nfloat noise( in vec3 x ) \/\/ base noise in [0,1]; \n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n#if NOISE_TYPE==1\n\treturn res;\n#elif NOISE_TYPE==2\n\treturn abs(2.*res-1.);\n#elif NOISE_TYPE==3\n\treturn 1.-abs(2.*res-1.);\n#endif\n}\n\nfloat fbm( vec3 p ) \/\/ turbulent (=fractal) noise in [0,1]; \n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\/\/ --- End of: Created by inigo quilez --------------------\n\n\n\/\/ for noise to be thresholded, we not always need to compute high freq\n\nfloat fbm_lazzy( vec3 p , float v0, float v1) \/\/ v0,v1: min\/max thresholds\n{\n    float v01 = .5*(v0+v1), dv = .5*(v1-v0);\n\tfloat s=1.,f,r=1.,t;\n\t\n\t              s*=.5; f  = s*noise( p ); r-=s; if (abs(f-v01)>r+dv) return f+.5*r; \n\tp = m*p*2.02; s*=.5; f += s*noise( p ); r-=s; if (abs(f-v01)>r+dv) return f+.5*r; \n\tp = m*p*2.03; s*=.5; f += s*noise( p ); r-=s; if (abs(f-v01)>r+dv) return f+.5*r;\n\tp = m*p*2.01; s*=.5; f += s*noise( p );\n\n    return f;\n}\n\n\n\/\/ calc histogramm of noise\n\nfloat histogramm(vec2 uv) {\n\tfloat dx = dFdx(uv.x)*STEP;   \/\/ slice size\n\tfloat s = 0., q=0., n;\n\t\n\tfor (int j=0; j<= SAMPLE; j++)\n\t{\n\t\tfloat y = float(j)\/float(SAMPLE);\n#if !LAZZY\n\t\tn = fbm(8.*vec3(0.,y,t));\n#else\n\t\tn = fbm_lazzy(8.*vec3(0.,y,t), uv.x, uv.x+dx);\n#endif\n\n\t\tif (abs(n-uv.x) < .5*dx) s++;\n\t\tq++;\n\t}\n\treturn .1*s\/(q*dx);\n}\n\n\n\/\/ smmothing using hardware derivatives. if SMOOTH <1, sub-relaxation\n\nfloat smooth(float v)\n{\n\tfloat vx = -dFdx(v)*(2.*mod(FragCoord.x-.5,2.)-1.),\n\t\t  vy = -dFdy(v)*(2.*mod(FragCoord.y-.5,2.)-1.);\n\n\treturn v + SMOOTH*(vx+vy)\/3.;\n}\n\n\/\/ main loop\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    FragCoord=fragCoord;\n\tvec3 col=vec3(0.);\n\tif (uv.y < exp(-.5*pow((uv.x-.5)\/.15,2.))*.5) col = vec3(0.,0.,.5);\n\tif (mod(uv.y,.1)<=1.\/iResolution.y) col = vec3(0.,1.,0.);\n\tif (mod(uv.y,.5)<=4.\/iResolution.y) col = vec3(0.,1.,0.);\n\tif (mod(uv.x,.1)<=1.\/iResolution.x) col = vec3(1.,0.,0.);\n\tif (mod(uv.x,.5)<=4.\/iResolution.x) col = vec3(1.,0.,0.);\n\t\n\t\n\tfloat t = histogramm(uv);\n\t\n\tif (SMOOTH != 0.) t = smooth(t);  \/\/ average with neightboor pixels\n\tif (t > uv.y)  col=vec3(1.);\t\t     \/\/ draw bar\n\t\n\tfragColor = vec4(col,1.); \n}\n","name":"","description":"","type":"image"}]}}