{"Shader":{"ver":"0.1","info":{"id":"4lsSWB","date":"1439592942","viewed":825,"name":"RayMarch Test 02","username":"mouthlessbobcat","description":"A raymarch-generated sphere with run-time generated spec and normal maps. <br\/>Click and drag to move the light around.","likes":1,"published":3,"flags":0,"tags":["siggraph2015"],"hasliked":0},"renderpass":[{"inputs":[{"id":1,"src":"\/presets\/tex00.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"const float MAX_DIST = 25.0;\n#define TEX_SAMPLE 0.01\n#define NORMAL_STRENGTH 0.5\n#define MOUSE_SENSITIVITY 1000.0\nconst float TEXTURE_TILE_XY = 0.25;\n\n\nfloat cosNoise( in vec2 pos)\n{\n\treturn 0.5 * ( sin(pos.x) * sin(pos.y));   \n}\n\nfloat cube(in vec3 pos, vec3 center, vec3 dimensions)\n{\n    return length(max(abs(pos - center) - dimensions, 0.0));\n}\n\nfloat plane(vec3 pos, vec3 center, vec4 dimensions)\n{\n\treturn dot(center, dimensions.xyz) + dimensions.w;\n}\n\nfloat sphere(vec3 pos, vec3 center, float radius)\n{\n\treturn length(pos - center) - radius; \n}\n\nfloat scene(vec3 pos)\n{\n    return sphere(pos, vec3(0.0, 0.0, 5.0), 3.0);\n}\n\nfloat scene_Old(vec3 pos)\n{\n    return min( cube(pos, vec3(10.0, 0.0, 10.0), vec3(3.0, 3.0, 3.0)),\n        \tmin( \n        \t\tsphere(pos, vec3(0.0, 0.0, 5.0), 4.0),\n                sphere(pos, vec3(-15, 0.0, 5.0), 1.0) \n              ));\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n\tvec2 eps = vec2( 0.001, 0.0);\n\tvec3 nor = vec3(\n\t    scene(pos+eps.xyy) - scene(pos-eps.xyy),\n\t    scene(pos+eps.yxy) - scene(pos-eps.yxy),\n\t    scene(pos+eps.yyx) - scene(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\n\nfloat luminosity(vec3 color)\n{\n    return .33 * (color.r + color.g + color.b);\n\t\/\/return (color.r * 0.6 + color.g * 0.3, + color.b * 0.1);  \n}\n\nvec3 blendNormals(in vec3 norm1, in vec3 norm2)\n{\n\treturn normalize(vec3(norm1.xy + norm2.xy, norm1.z));\n}\n\n\nvec3 calcNormalTex(in vec3 pos)\n{\n    \n    float center = luminosity(texture2D(iChannel0, pos.xy*TEXTURE_TILE_XY).xyz) * NORMAL_STRENGTH;\n    float n = luminosity(texture2D(iChannel0, pos.xy*TEXTURE_TILE_XY + vec2(0.0, TEX_SAMPLE)).xyz) * NORMAL_STRENGTH;\n    float s = luminosity(texture2D(iChannel0, pos.xy*TEXTURE_TILE_XY + vec2(0.0, -TEX_SAMPLE)).xyz) * NORMAL_STRENGTH;\n    float e = luminosity(texture2D(iChannel0, pos.xy*TEXTURE_TILE_XY + vec2(TEX_SAMPLE, 0.0)).xyz) * NORMAL_STRENGTH; \n    float w = luminosity(texture2D(iChannel0, pos.xy*TEXTURE_TILE_XY + vec2(-TEX_SAMPLE, 0.0)).xyz) * NORMAL_STRENGTH; \n    \n    \n    float epsilon = 0.001;\n    float meshCenter = scene(pos);\n    float meshX = scene(pos - vec3(epsilon, 0.0, 0.0));\n    float meshY = scene(pos - vec3(0.0, epsilon, 0.0));\n    float meshZ = scene(pos - vec3(0.0, 0.0, epsilon));\n    \n    vec3 meshNorm = normalize(vec3(meshX-meshCenter, meshY-meshCenter, meshZ-meshCenter));\n    \n    vec3 norm = meshNorm;\n    vec3 temp = norm;\n    if (norm.x == 1.0)\n    {\n     \ttemp.y += 0.5;   \n    }\n    else\n    {\n     \ttemp.x += 0.5;   \n    }\n    \n    vec3 perp1 = normalize(cross(norm, temp));\n    vec3 perp2 = normalize(cross(norm, perp1));\n    \n    vec3 offset = -NORMAL_STRENGTH * (((n-center)-(s-center) * perp1) + ((e-center) - (w-center)) * perp2);\n    norm += offset;\n    \n    return norm;\n}\n\n\nfloat rayMarch(vec3 origin, vec3 dir)\n{\n    float dist = 0.0;\n    for (int i =0; i < 256; ++i)\n    {\n        vec3 pos = origin + dir*dist;\n        float h = scene(pos);\n        if (h < 0.001) break;\n        dist += h;\n    }\n    return dist;\n}\n\n\nvec3 shade(vec3 origin, vec3 dir, float dist)\n{\n    vec3 outColor = vec3(1.0, 1.0, 1.0);\n    \n    vec3 pos = origin + dir*dist; \/\/ World position\n    vec3 normal = calcNormalTex(pos); \/\/ Normal\n    \/\/return normal;\n    \n    vec3 _texSample = texture2D(iChannel0, pos.xy*TEXTURE_TILE_XY).xyz;\n    vec3 diffColor = _texSample;\n    \/\/vec3 specColor = vec3(1.0, 1.0, 1.0);\n    vec3 specColor = vec3(luminosity(_texSample));\n    \/\/vec3 specColor = vec3(dot(vec3(0.30, 0.59, 0.11),_texSample));\n    \n    float mouseDx = (iMouse.x\/iResolution.x*2.0) - 1.0;\n    float mouseDy = (iMouse.y\/iResolution.y*2.0) - 1.0;\n    vec3 lightPos = vec3(mouseDx * MOUSE_SENSITIVITY, mouseDy * MOUSE_SENSITIVITY, 500);\n    vec3 diffLightCol = vec3(1.0, 1.0, 0.7);\n    vec3 ambientColor = vec3(0.01, 0.01, 0.0);\n    \n    vec3 lightDir = normalize(lightPos - origin);\n    \n    vec3 reflectDir = normalize(lightDir + dir);\n    \n    \/\/vec3 reflectDir = reflect(-lightDir, normal);\n    float specAngle = max(dot(reflectDir, normal), 0.0);\n    float specular = pow(specAngle, 24.0);\n    \n    float NdotL = clamp(dot(normal, lightDir), 0.0, 1.0);\n    vec3 diffuse = diffLightCol * NdotL;\n    \n    outColor = ambientColor + (diffuse * diffColor) + (specular * specColor * 0.5);\n    return outColor;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 cameraOrigin = vec3(0.0, 0.0, -1.0);\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n    vec3 upDir = vec3(0.0, 1.0, 0.0);\n    \n    vec3 cameraDir = normalize(cameraTarget-cameraOrigin);\n    vec3 cameraRight = normalize(cross(upDir, cameraOrigin));\n    vec3 cameraUp = cross(cameraDir, cameraRight);\n    \n    vec2 screenPos = -1.0 + 2.0 * fragCoord \/ iResolution.xy; \/\/ Screenpos range from -1 to 1\n    screenPos.x *= iResolution.x \/ iResolution.y;\n    \n    vec3 rayDir = normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n\tfloat dist = rayMarch(cameraOrigin, rayDir);\n        \n    vec3 col = vec3(0.0, 0.0, 0.0);\n\n    if (dist < MAX_DIST)\n    {\n        col = shade(cameraOrigin, rayDir, dist);\n    }\n    \n    \/\/ Gamma correct\n    col = sqrt(col);\n    \/\/col = pow(col, vec3(1.0\/2.2));\n\n    fragColor = vec4(col, 1.0);\n    \n}","name":"","description":"","type":"image"}]}}