{"Shader":{"ver":"0.1","info":{"id":"MtjGz3","date":"1431078212","viewed":839,"name":"p6mm inversion","username":"curena","description":"A planar pattern with all p6mm wallpaper group symmetries, mapped through a hyperbolic circle inversion + time dependent shift. Click and drag mouse to move inversion center.","likes":13,"published":3,"flags":0,"tags":["group","tiling","inversion","p6mm","wallpapergroup","symmetries"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ \"p6mm inversion\" by Carlos Ure\u00f1a - 2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\/\/ *******************************************************************\n\/\/ global defs and params\n\/\/\n\nconst float \n    sqr2     = 1.4142135623730950488016887242096980785696, \/\/ square root of 2\n    sqr3     = 1.7320508075688772935274463415058723669428, \/\/ square root of 3.0\n    sqr2_inv = 1.0\/sqr2 ,\n    sqr3_inv = 1.0\/sqr3 ,\n    l        = 0.35,       \/\/ length of triangle in NDC (mind --> 1.0)\n    l_inv    = 1.0\/l ,\n    line_w   = 0.02 ;  \/\/ 0.015 \n\nconst vec2  \n    u        = 1.0*vec2( 1.0, 0.0  ) ,\n    v        = 0.5*vec2( 1.0, sqr3 ) ,\n    u_dual   = 1.0*vec2( 1.0, -sqr3_inv ) ,\n    v_dual   = 2.0*vec2( 0.0,  sqr3_inv ) ,\n    tri_cen  = vec2( 0.5, 0.5*sqr3_inv ) ; \/\/ triangle center\n\nvec2\n    center   = 0.5*iResolution.xy ;        \/\/ viewport center in DC \n\nfloat \n    mind   = min(iResolution.x,iResolution.y);\n\n\/\/ -------------------------------------------------------------------------------\n\/\/ mirror reflection of 'p' around and axis through 'v1' and 'v2'\n\/\/ (only for points to right of the line from v1 to v2)\n\/\/\n\nvec2 mirror( vec2 p, vec2 v1, vec2 v2 )\n{\n \tvec2   s = v2-v1 ,\n           n = normalize(vec2( s.y, -s.x )) ;\n    float  d = dot(p-v1,n) ;\n    \n    return p-max(0.0,2.0*d)*n ;\n}\n\/\/ -------------------------------------------------------------------------------\n\nfloat dist( vec2 p, vec2 v1, vec2 v2 )\n{\n \tvec2   s = v2-v1 ,\n           n = normalize(vec2( s.y, -s.x )) ;\n    return dot(p-v1,n) ;\n}\n\/\/ -------------------------------------------------------------------------------\n\nvec2 p6mm_ToFundamental( vec2 p0 ) \n{\n    \/\/ p1 = fragment coords. in the grid reference frame\n    \n    vec2 p1 = vec2( dot(p0,u_dual), dot(p0,v_dual) );\n    \n    \/\/ p2 = fragment coords in the translated grid reference frame \n    \n    vec2 p2 = vec2( fract(p1.x), fract(p1.y) ) ;\n    \n    \/\/ p3 = barycentric coords in the translated triangle\n    \/\/ (mirror, using line x+y-1=0 as axis, when point is right and above axis)\n    \n    vec2 p3 = mirror( p2, vec2(1.0,0.0), vec2(0.0,1.0) );\n    \n    \/\/ p4 = p3, but expressed back in cartesian coordinates\n    \n    vec2 p4 = p3.x*u + p3.y*v ;\n    \n    \/\/ p7 = mirror around the three lines through the barycenter, perp. to edges.\n    \n    vec2 p5 = mirror( p4, vec2(0.5,0.0), tri_cen );\n    vec2 p6 = mirror( p5, vec2(1.0,0.0), tri_cen );\n    vec2 p7 = mirror( p6, tri_cen, vec2(0.0,0.0) );\n  \n    return p7 ;\n}\n\n\/\/ --------------------------------------------------------------------\n\nfloat DistanceFunc( float d )\n{\n    \n   return 1.0-smoothstep( line_w*0.85, line_w*1.15, d );   \n}\n\n\/\/ -------------------------------------------------------------------------------\n\nvec4 p6mm_SimmetryLines( vec2 p_ndc )\n{\n\n    vec2 pf = p6mm_ToFundamental( p_ndc );\n    \n    float d1 = abs(pf.y),\n          d2 = abs(pf.x-0.5),\n          d3 = abs( dist( pf, tri_cen, vec2(0.0,0.0) ) );\n     \n    vec4 res = vec4( 0.0, 0.0, 0.0, 1.0 ) ;\n        \n    res.r = DistanceFunc(d2);\n    res.g = DistanceFunc(d1);\n    res.b = DistanceFunc(d3);\n    \n    return res ;    \n}\n\/\/ -------------------------------------------------------------------------------\n\nvec2 DCToNDC( vec2 p_dc )\n{\n    return l_inv*(p_dc - center)\/mind ;\n}\n\/\/ --------------------------------------------------------------------\n\nvec2 Inversion( vec2 p, vec2 cen )\n{\n   const float speedFactor = 5.0 ;\n   float secs = iGlobalTime*speedFactor ;\n   vec2  vr   = p  -cen ;\n   float r    = length( vr );\n   \n    return cen + normalize(vr)\/(r*0.1) \n              + secs\/4.0*vec2(1.0,0.5)  \n              + 1.0*l*vec2( sin(secs\/40.0), cos(secs\/42.0) ) ;\n}\n\n\/\/ -------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const int n = 9 ;\n    const float n_inv = 1.0\/float(n) ;\n    \n    vec4 res = vec4( 0.0, 0.0, 0.0, 1.0 );\n    \n    vec2 mou = DCToNDC( 0.5*iResolution.xy );\n    if ( iMouse.w != 0.0 )\n        mou  = DCToNDC( iMouse.xy  ) ;\n    \n    \n    for (int ix = 0 ; ix < n ; ix += 1 )\n    for (int iy = 0 ; iy < n ; iy += 1 )\n    {\n       float px = -0.5 + (0.5+float(ix))*n_inv,   \n             py = -0.5 + (0.5+float(iy))*n_inv ;\n        \n       vec2 pNDC = DCToNDC( fragCoord + vec2( px, py ) );\n            \n       vec2 pinv = Inversion( pNDC, mou ) ;\n        \n       res += p6mm_SimmetryLines( pinv );\n    }\n    \n    fragColor = n_inv*n_inv*res ;   \n}\n\/\/ -------------------------------------------------------------------------------","name":"","description":"","type":"image"}]}}