{"Shader":{"ver":"0.1","info":{"id":"llXGR4","date":"1418975438","viewed":4482,"name":"Antialiasing (sort of)","username":"iq","description":"More worms like in <a href=\"https:\/\/www.shadertoy.com\/view\/XsjXR1\"  class=\"regular\" target=\"_blank\">XsjXR1<\/a>, but edge-antialiased (more or less)","likes":72,"published":3,"flags":0,"tags":["procedural","3d","raymarching","distancefield"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ An edge antialising experiment (not multisampling used)\n\/\/\n\/\/ If slow_antialias is disabled, then only the 4 closest hit points are used for antialising, \n\/\/ otherwise all found partial-intersections are considered.\n\n#define ANTIALIASING\n\/\/#define SLOW_ANTIALIAS\n\nvec2 sincos( float x ) { return vec2( sin(x), cos(x) ); }\n\nvec2 sdSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa-ba*h ), h );\n}\n\nvec3 opU( vec3 d1, vec3 d2 ) { return (d1.x<d2.x) ? d1 : d2; }\n\nvec3 map( vec3 p )\n{\n    vec2 id = floor( (p.xz+1.0)\/2.0);\n    p.xz = mod( p.xz+1.0, 2.0 ) - 1.0;\n    \n    float ph = sin(0.5 + 3.1*id.x + sin(7.1*id.y));\n    \n    p.xz += 0.5*sincos(1.0+0.5*iGlobalTime+(p.y+11.0*ph)*0.8);\n\n    vec3 p1 = p; p1.xz += 0.15*sincos(1.0*p.y-1.0*iGlobalTime+0.0);\n    vec3 p2 = p; p2.xz += 0.15*sincos(1.0*p.y-1.0*iGlobalTime+2.0);\n    vec3 p3 = p; p3.xz += 0.15*sincos(1.0*p.y-1.0*iGlobalTime+4.0);\n    \n    vec2 h1 = sdSegment(p1, vec3(0.0,-50.0, 0.0), vec3(0.0, 50.0, 0.0) );\n    vec2 h2 = sdSegment(p2, vec3(0.0,-50.0, 0.0), vec3(0.0, 50.0, 0.0) );\n    vec2 h3 = sdSegment(p3, vec3(0.0,-50.0, 0.0), vec3(0.0, 50.0, 0.0) );\n    \n    return opU( opU( vec3(h1.x-0.12,                                         ph + 0.0\/3.0, h1.y), \n                     vec3(h2.x-0.12-0.05*cos( 500.0*h2.y - iGlobalTime*4.0), ph + 1.0\/3.0, h2.y) ), \n                     vec3(h3.x-0.12-0.02*cos(2000.0*h3.y - iGlobalTime*4.0), ph + 2.0\/3.0, h3.y) );\n}\n\n\/\/-------------------------------------------------------\n\nvec3 calcNormal( in vec3 pos, in float dt )\n{\n    vec2 e = vec2(1.0,-1.0)*dt;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nfloat calcOcc( in vec3 pos, in vec3 nor )\n{\n    const float h = 0.15;\n\tfloat ao = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        vec3 dir = sin( float(i)*vec3(1.0,7.13,13.71)+vec3(0.0,2.0,4.0) );\n        dir = dir + 2.5*nor*max(0.0,-dot(nor,dir));            \n        float d = map( pos + h*dir ).x;\n        ao += max(0.0,h-d);\n    }\n    return clamp( 1.0 - 0.7*ao, 0.0, 1.0 );\n}\n\n\/\/-------------------------------------------------------\nvec3 shade( in float t, in float m, in float v, in vec3 ro, in vec3 rd )\n{\n    float px = 0.0001;\/\/(2.0\/iResolution.y)*(1.0\/3.0);\n    float eps = px*t;\n\n    vec3  pos = ro + t*rd;\n    vec3  nor = calcNormal( pos, eps );\n    float occ = calcOcc( pos, nor );\n\n    vec3 col = 0.5 + 0.5*cos( m*vec3(1.4,1.2,1.0) + vec3(0.0,1.0,2.0) );\n    col += 0.05*nor;\n    col = clamp( col, 0.0, 1.0 );\n    col *= 1.0 + 0.5*nor.x;\n    col += 0.2*clamp(1.0+dot(rd,nor),0.0,1.0);\n    col *= 1.4;\n    col *= occ;\n    col *= exp( -0.15*t );\n    col *= 1.0 - smoothstep( 15.0, 35.0, t );\n    \n    return col;\n}\n\n\/\/-------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = (-iResolution.xy+2.0*fragCoord.xy)\/iResolution.y;\n    \n\tvec3 ro = 0.6*vec3(2.0,-3.0, 4.0);\n\tvec3 ta = 0.5*vec3(0.0, 4.0,-4.0);\n    \n    float fl = 1.0;\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize( cross( vec3(1.0,0.0,0.0), ww ) );\n    vec3 vv = normalize( cross(ww,uu) );\n    vec3 rd = normalize( p.x*uu + p.y*vv + fl*ww );\n\t\n    float px = (2.0\/iResolution.y)*(1.0\/fl);\n    \n    vec3 col = vec3(0.0);\n\n    \/\/---------------------------------------------\n    \/\/ raymach loop\n    \/\/---------------------------------------------\n    const float maxdist = 32.0;\n\n    vec3 res = vec3(-1.0);\n    float t = 0.0;\n    #ifdef ANTIALIASING\n    vec3 oh = vec3(0.0);\n    mat4 hit = mat4(-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0,-1.0);\n    #endif\n    \n    for( int i=0; i<128; i++ )\n    {\n\t    vec3 h = map( ro + t*rd );\n        float th1 = px*t;\n        res = vec3( t, h.yz );\n        if( h.x<th1 || t>maxdist ) break;\n\n        \n        #ifdef ANTIALIASING\n        float th2 = px*t*3.0;\n        if( (h.x<th2) && (h.x>oh.x) )\n        {\n            float lalp = 1.0 - (h.x-th1)\/(th2-th1);\n            #ifdef SLOW_ANTIALIAS\n             vec3  lcol = shade( t, oh.y, oh.z, ro, rd );\n             tmp.xyz += (1.0-tmp.w)*lalp*lcol;\n             tmp.w   += (1.0-tmp.w)*lalp;\n             if( tmp.w>0.99 ) break;\n            #else\n             if( hit[0].x<0.0 )\n             {\n             hit[0] = hit[1]; hit[1] = hit[2]; hit[2] = hit[3]; hit[3] = vec4( t, oh.yz, lalp );\n             }\n            #endif\n        }\n        oh = h;\n        #endif\n        \n        t += min( h.x, 0.5 )*0.5;\n    }\n    \n    if( t < maxdist )\n        col = shade( res.x, res.y, res.z, ro, rd );\n    \n    #ifdef ANTIALIASING\n    #ifdef SLOW_ANTIALIAS\n\tcol = mix( col, tmp.xyz\/(0.001+tmp.w), tmp.w );\n    #else\n    for( int i=0; i<4; i++ ) \/\/ blend back to front\n    if( hit[3-i].x>0.0 )\n        col = mix( col, shade( hit[3-i].x, hit[3-i].y, hit[3-i].z, ro, rd ), hit[3-i].w );\n    #endif\n    #endif\n \n    \/\/---------------------------------------------\n    \n    col = pow( col, vec3(0.5,0.7,0.5) );\n    \n    vec2 q = fragCoord.xy\/iResolution.xy;\n    col *= pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n    \n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}