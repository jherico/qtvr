{"Shader":{"ver":"0.1","info":{"id":"Mss3zM","date":"1367010098","viewed":10813,"name":"Insect","username":"iq","description":"An (unfinished) exercise on animating something alive. Shading is obviously very broken for now, and modelling is primitive-ish. But it looks good I think!","likes":68,"published":3,"flags":0,"tags":["procedural","3d","distancefield","rayarching","animation"],"hasliked":0},"renderpass":[{"inputs":[{"id":10,"src":"\/presets\/tex09.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":15,"src":"\/presets\/tex10.png","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":16,"src":"\/presets\/tex11.png","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat hash( float n )\n{\n    return fract(sin(n)*158.5453);\n}\n\nfloat noise( in float x )\n{\n    float p = floor(x);\n    float f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    return mix( hash(p+0.0), hash(p+1.0),f);\n}\n\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n    float a = texture2DLodEXT(iChannel1,(p+vec2(0.5,0.5))\/64.0, 0.0).x;\n\tfloat b = texture2DLodEXT(iChannel1,(p+vec2(1.5,0.5))\/64.0, 0.0).x;\n\tfloat c = texture2DLodEXT(iChannel1,(p+vec2(0.5,1.5))\/64.0, 0.0).x;\n\tfloat d = texture2DLodEXT(iChannel1,(p+vec2(1.5,1.5))\/64.0, 0.0).x;\n    float res = mix(mix( a, b,f.x), mix( c, d,f.x),f.y);\n\n\treturn 2.0*res;\n}\n\n\n\n\nvec3 texturize( sampler2D sa, vec3 p, vec3 n, in vec3 gx, in vec3 gy )\n{\n\tvec3 x = texture2DGradEXT( sa, p.yz, gx.yz, gy.yz ).xyz;\n\tvec3 y = texture2DGradEXT( sa, p.zx, gx.zx, gy.zx ).xyz;\n\tvec3 z = texture2DGradEXT( sa, p.xy, gx.xy, gy.xy ).xyz;\n\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\n\n\/\/----------------------------------------------------------------\n\nfloat terrainSoft( vec2 x )\n{\n\tx += 100.0;\n\tx *= 0.6;\n\n\tvec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n    float a = texture2DLodEXT(iChannel0,0.0+(p+vec2(0.5,0.5))\/1024.0,0.0).x;\n\tfloat b = texture2DLodEXT(iChannel0,0.0+(p+vec2(1.5,0.5))\/1024.0,0.0).x;\n\tfloat c = texture2DLodEXT(iChannel0,0.0+(p+vec2(0.5,1.5))\/1024.0,0.0).x;\n\tfloat d = texture2DLodEXT(iChannel0,0.0+(p+vec2(1.5,1.5))\/1024.0,0.0).x;\n\tfloat r = mix(mix( a, b,f.x), mix( c, d,f.x), f.y);\n\t\n\treturn 12.0*r;\n\n}\n\nfloat terrain( vec2 x )\n{\n\tfloat f = terrainSoft( x );\n\n\tfloat h = smoothstep( 0.4, 0.8, noise( 2.0*x ) );\n\tf -= 0.2*h;\n\n    float d = noise( 35.0*x.yx*vec2(0.1,1.0) );\n\tf += 0.003*d * h*h;\n\n\treturn f;\n}\n\n\nvec2 sdSegment2( vec3 a, vec3 b, vec3 p, float ll )\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)*ll, 0.0, 1.0 );\n\t\n\treturn vec2( length( pa - ba*h ), h );\n}\n\nvec3 solve( vec3 p, float l1, float l2, vec3 dir )\n{\n\tvec3 q = p*( 0.5 + 0.5*(l1*l1-l2*l2)\/dot(p,p) );\n\t\n\tfloat s = l1*l1 - dot(q,q);\n\ts = max( s, 0.0 );\n\tq += sqrt(s)*normalize(cross(p,dir));\n\t\n\treturn q;\n\n}\n\nvec3 solve( vec3 a, vec3 b, float l1, float l2, vec3 dir )\n{\n\treturn a + solve( b-a, l1, l2, dir );\n}\n\nfloat smin( float a, float b )\n{\n#if 0\n\tfloat k = 32.0;\n\tfloat res = exp( -k*a ) + exp( -k*b );\n    return -log( res )\/k;\n#else\n    float k = 0.1;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n#endif\t\n}\n\nstruct Monster\n{\n\tvec3 center;\n\tvec3 mww;\n\tvec3 ne[6];\n\tvec3 f0b[6];\n};\n\n\t\nMonster monster;\n\nvec2 sdMonster( in vec3 p )\n{\n\tvec3 q = p - monster.center;\n\t\n\tif( dot(q,q)>25.0 ) return vec2(32.0);\n\t\n\tvec3 muu = vec3(1.0,0.0,0.0);\n\tvec3 mvv = normalize( cross(monster.mww,muu) );\n\n\tq = vec3( q.x, dot(mvv,q), dot(monster.mww,q) );\n\n    \/\/ body\n\tfloat ab = (0.5 + 0.5*cos( 1.0 + 40.0*pow(0.5-0.5*q.z,2.0) ))*(0.5+0.5*q.z);\n\tfloat d1 = length( q*vec3(1.5,2.2,1.0) ) - 1.0 - 0.3*ab;\n\td1 += 0.03*sin(20.0*q.z)*(0.5+0.5*clamp(2.0*q.y,0.0,1.0));\n\tfloat f = 0.5 - 0.5*q.z;\n\td1 += f*0.04*sin(40.0*q.y)*sin(40.0*q.x)*sin(40.0*q.z)*clamp(2.0*q.y+0.5,0.0,1.0);\n\tfloat ho = 1.0-clamp( 3.0*abs(q.x), 0.0, 1.0 );\n\td1 += 0.1*(1.0-sqrt(1.0-ho*ho))*smoothstep( 0.0,0.1,-q.z );\n\t\n\t\/\/ legs\n\tfor( int i=0; i<6; i++ )\n\t{\n\t    float s = -sign( float(i)-2.5 );\n\t\tfloat h = mod( float(i), 3.0 )\/3.0;\n\t\t\n\t\tvec3 bas = monster.center + muu*s*0.5 + monster.mww*1.0*(h-0.33) ;\n\n\t\tvec3 n1 = monster.ne[i];\n\t\tvec2 hh = sdSegment2( bas, n1, p, 1.0\/(1.6*1.6) );\n\t\td1 = smin( d1, hh.x-mix(0.15,0.05,hh.y) + 0.05*sin(6.2831*hh.y) );\n\t\thh = sdSegment2( n1, monster.f0b[i], p, 1.0\/(1.2*1.2) );\n\t\td1 = smin( d1, hh.x-mix(0.06,0.02,hh.y) + 0.01*cos(2.0*6.2831*hh.y) );\n\t}\n\t\n\t\n\tvec2 res = vec2( 0.5*d1, 1.0 );\n\n\t\/\/ eyes\n\tq.x = abs(q.x);\n\tfloat d3 = length( q - vec3(0.3,0.05,0.9) ) - 0.3;\n\tif( d3<res.x ) res = vec2( d3, 0.0 );\n\n\treturn res;\n}\n\n\nvec2 map( in vec3 p )\n{\n    \/\/ monster\n    vec2 res = sdMonster( p );\n\n    \/\/ terrain\n\tfloat d2 = 0.7*(p.y - terrain(p.xz));\n\tif( d2<res.x ) res=vec2(d2,2.0);\n\t\n\treturn res;\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n\tfloat mind = 0.1;\n\tfloat maxd = 70.0;\n\t\n\tfloat precis = 0.001;\n    float h = precis*2.0;\n    float t = mind;\n\tfloat d = 0.0;\n    float m = 1.0;\n    for( int i=0; i<120; i++ )\n    {\n        if( h<precis||t>maxd ) break;\n        t += h;\n\t    vec2 res = map( ro+rd*t );\n        h = res.x;\n\t\td = res.y;\n\t\tm = res.y;\n    }\n\n    if( t>maxd ) m=-1.0;\n    return vec3( t, d, m );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.002,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    for( int i=0; i<32; i++ )\n    {\n        h = map(ro + rd*t).x;\n        res = min( res, smoothstep(0.0,1.0,k*h\/t) );\n\t\tt += clamp( h, 0.07, 1.0 );\n\t\tif( h<0.001 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\n\nvec3 lig = normalize(vec3(-1.0,0.4,0.2));\n\nvec3 path( float t )\n{\n    vec3 pos = vec3( 0.0 );\n    pos.z += t*0.4;\n\tpos.y = 1.0 + terrainSoft( pos.xz );\n\treturn pos;\n}\n\n\n\/\/ compute screen space derivatives of positions analytically without dPdx()\nvoid calcDpDxy( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy, in float t, in vec3 nor, out vec3 dpdx, out vec3 dpdy )\n{\n    dpdx = t*(rdx*dot(rd,nor)\/dot(rdx,nor) - rd);\n    dpdy = t*(rdy*dot(rd,nor)\/dot(rdy,nor) - rd);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x\/iResolution.y;\n    vec2 m = vec2(0.5);\n\tif( iMouse.z>0.0 ) m = iMouse.xy\/iResolution.xy;\n\n\n    \/\/-----------------------------------------------------\n    \/\/ animate\n    \/\/-----------------------------------------------------\n\t\n\tfloat ctime = 15.0 + iGlobalTime;\n\n\t\/\/ mobe body\n\tfloat atime = 2.0*ctime;\n\tfloat ac = noise( 0.5*ctime );\n\tatime += 4.0*ac;\n    monster.center = path( atime );\n\tvec3 centerN = path( atime+2.0 );\n\tmonster.mww = normalize( centerN - monster.center );\n    monster.center.y -= 0.25;\n\n\t\n\t\/\/ move legs\n\tfor( int i=0; i<6; i++ )\n\t{\n\t\tfloat s = -sign( float(i)-2.5 );\n\t\tfloat h = mod( float(i), 3.0 )\/3.0;\n\n\t\tfloat z = 0.5*atime + 1.0*h + 0.25*s;\n\t\tfloat iz = floor(z);\n\t\tfloat fz = fract(z);\n\t    float az = clamp((fz-0.66)\/0.34,0.0,1.0);\n\t\t\n\t\tvec3 fo = vec3(s*1.5, 0.7*az*(1.0-az), (iz + az + (h-0.3)*4.0)*0.4*2.0 );\n\t\tfo.y += terrain( fo.xz );\n        monster.f0b[i] = fo;\n\t\t\n\t\tvec3 ba = monster.center + vec3(1.0,0.0,0.0)*s*0.5 + monster.mww*1.0*(h-0.33) ;\n\n\t\tmonster.ne[i] = solve( ba, fo, 1.6, 1.2, s*vec3(0.0,0.0,-1.0) );\n\t}\n\n\t\n    \/\/-----------------------------------------------------\n    \/\/ camera\n    \/\/-----------------------------------------------------\n\t\n    \/\/ follow the monster\n\tfloat an = 0.0 + 0.1*ctime - 6.28*m.x;\n\tfloat cr = 0.3*cos(0.2*ctime);\n    vec3 ro = monster.center + vec3(4.0*sin(an),0.2,4.0*cos(an));\n    vec3 ta = monster.center;\n\tro.y = 0.5 + terrainSoft( ro.xz );\n\t\n    \/\/ shake\n\tro += 0.04*sin(4.0*ctime*vec3(1.1,1.2,1.3)+vec3(3.0,0.0,1.0) );\n\tta += 0.04*sin(4.0*ctime*vec3(1.7,1.5,1.6)+vec3(1.0,2.0,1.0) );\n\t\n    \/\/ camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(cr),cos(cr),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t\n    \/\/ barrel distortion\t\n    float r2 = p.x*p.x*0.32 + p.y*p.y;\n    p *= (7.0-sqrt(37.5-11.5*r2))\/(r2+1.0);\n\t\n\t\/\/ create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 3.0*ww );\n    \n    \/\/ ray differentials\n    vec2 px = (-iResolution.xy+2.0*(fragCoord.xy+vec2(1.0,0.0)))\/iResolution.y;\n    r2 = px.x*px.x*0.32 + px.y*px.y;\n    px *= (7.0-sqrt(37.5-11.5*r2))\/(r2+1.0);\n    vec2 py = (-iResolution.xy+2.0*(fragCoord.xy+vec2(0.0,1.0)))\/iResolution.y;\n    r2 = py.x*py.x*0.32 + py.y*py.y;\n    py *= (7.0-sqrt(37.5-11.5*r2))\/(r2+1.0);\n    vec3 rdx = normalize( px.x*uu + px.y*vv + 3.0*ww );\n    vec3 rdy = normalize( py.x*uu + py.y*vv + 3.0*ww );\n    \n\n    \/\/-----------------------------------------------------\n\t\/\/ render\n    \/\/-----------------------------------------------------\n\tfloat nds = clamp(dot(rd,lig),0.0,1.0);\n\tvec3 bgc = vec3(0.9+0.1*nds,0.95+0.05*nds,1.0)*(0.7 + 0.3*rd.y)*0.98;\n    vec3 col = bgc;\n\n\t\/\/ raymarch\n    vec3 tmat = intersect(ro,rd);\n    if( tmat.z>-0.5 )\n    {\n        float t = tmat.x;\n        \n        \/\/ geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\t\tvec3 ref = reflect( rd, nor );\n\n        \/\/ derivatives        \n        vec3 dpdx, dpdy;\n        calcDpDxy( ro, rd, rdx, rdy, t, nor, dpdx, dpdy );\n\n    \n        \/\/ materials\n        float mocc = 1.0;\n\t\tvec4 mate = vec4(0.0);\n\t\t\n\t\t\/\/ eyes\n\t\tif( tmat.z<0.5 )\n\t\t{\n\t\t\tmate = 3.0*vec4(0.002,0.002,0.002,10.0);\n\t\t\tmate.xyz *= 0.8 + 0.2*sin(2.0*ref);\n\t\t\tmate.w *= 0.8 + 0.2*sin(20.0*ref.x)*sin(20.0*ref.y)*sin(20.0*ref.z);\n\t\t\tmate.xyz += 0.005*vec3(1.0,0.1,0.0);\n\t\t}\n\t\t\/\/ body\n\t\telse if( tmat.z<1.5 )\n\t\t{\n            \/\/ do shading in mosnter space\t\t\t\n\t\t\tvec3 q = pos - monster.center;\n\t\t\tvec3 muu = vec3(1.0,0.0,0.0);\n\t\t\tvec3 mvv = normalize( cross(monster.mww,muu) );\n\t\t\tq = vec3( q.x, dot(mvv,q), dot(monster.mww,q) );\n\t\t\tvec3 n = vec3( nor.x, dot(mvv,nor), dot(monster.mww,nor) );\n\n            vec3 dqdx = vec3( dpdx.x, dot(mvv,dpdx), dot(monster.mww,dpdx) );\n            vec3 dqdy = vec3( dpdy.x, dot(mvv,dpdy), dot(monster.mww,dpdy) );\n\n\t\t\tq.x = abs( q.x );\n            \/\/ base color\t\t\t\n            mate.xyz = 0.3*vec3(1.0,0.7,0.4);\t\t\t\n\t\t\tmate = mix( mate, 0.3*vec4(1.0,0.9,0.6,1.0), smoothstep(0.0,1.0,-n.y) );\n\t\t\t\n            \/\/ texture\n\t\t\tmate.xyz *= 0.4+0.6*sqrt(smoothstep(0.0,0.7,texturize(iChannel0,0.5*q,n,0.5*dqdx, 0.5*dqdy).xyz));\n\t\t\t\n            \/\/ stripes\n\t\t\tfloat ss = smoothstep( 0.5, 0.8, texture2DGradEXT( iChannel1, 0.5*q.xz*vec2(1.0,0.1), 0.5*dqdx.xz, 0.5*dqdy.xz*0.1 ).x )*smoothstep( 0.0, 0.3, nor.y );\n\t\t\tmate.xyz += 0.15*ss;\n\n\t\t\t\/\/ color adjustment\n\t\t\tmate.w = 0.5;\n\t\t\tmate.xyz *= 0.8;\n\t\t\tmate.xyz *= 0.2+2.3*mate.xzy*vec3(1.0,1.6,1.4);\n\t\t\t\n            \/\/ occlusion\t\t\t\n\t\t\tfloat ho = 1.0-clamp( 5.0*abs(q.x), 0.0, 1.0 );\n            mocc *= 1.0-(1.0-sqrt(1.0-ho*ho))*smoothstep( 0.0,0.1,-q.z );\n\t\t\t\n\t\t\t\/\/ bump\n\t\t\tvec3 bnor = -1.0 + 2.0*texturize( iChannel2, 3.0*q, n, 3.0*dqdx, 3.0*dqdy ).xyz;\n\t\t\tbnor.y = abs(bnor.y);\n\t\t\tnor = normalize( nor + (1.0-ss)*0.2*normalize(bnor) );\n\n\t\t}\n        \/\/ terrain\t\t\n\t\telse if( tmat.z<2.5 )\n\t\t{\n\t\t\tmate = vec4(1.0, 0.9, 0.5, 0.0);\n            float nn =  noise( 2.0*pos.xz );\n\n            mate.xyz = mix( 0.7*mate.xyz, mate.xyz*0.65*vec3(0.8,0.9,1.0), 1.0-smoothstep( 0.4, 0.9, nn ) );\n\t\t\tmate.xyz *= 0.45;\n\n\t\t\tvec3 ff  = 0.05+0.95*texture2DGradEXT( iChannel0, 0.08*pos.xz, 0.08*dpdx.xz, 0.08*dpdy.xz ).xyz;\n\t\t\t     ff *= 0.05+0.95*texture2DGradEXT( iChannel0, 0.52*pos.xz, 0.52*dpdx.xz, 0.52*dpdy.xz ).xyz;\n\t\t\t     ff *= 0.05+0.95*texture2DGradEXT( iChannel0, 4.03*pos.xz, 4.03*dpdx.xz, 4.03*dpdy.xz ).xyz;\n\t\t\t\n\t\t\tfloat aa = mix( 1.0, 0.3, smoothstep( 0.65, 0.8, nn ) );\n            mate.xyz *= (1.0-aa) + aa*sqrt(ff)*3.0;\n\t\t\t\n            float d = smoothstep( 0.0, 0.5, abs(nn-0.75) );\n            mate.xyz *= 0.6+0.4*d;\n            d = smoothstep( 0.0, 0.2, abs(nn-0.75) );\n            mocc *= 0.7+0.3*d;\n\t\t\tmocc *= 0.03+0.97*pow( clamp( 0.5*length( pos.xz - monster.center.xz ), 0.0, 1.0 ), 2.0 );\n\n\t\t\tvec3 bnor = -1.0 + 2.0*texture2DGradEXT( iChannel2, 3.0*pos.xz, 3.0*dpdx.xz, 3.0*dpdy.xz ).xyz;\n\t\t\tbnor.y = abs(bnor.y);\n\t\t\tnor = normalize( nor + 0.1*normalize(bnor) );\n\t\t}\n\n\n\t\t\/\/ lighting\n\t\tfloat occ = (0.5 + 0.5*nor.y)*mocc;\n        float amb = 0.5 + 0.5*nor.y;\n        float dif = max(dot(nor,lig),0.0);\n        float bac = max(dot(nor,-lig),0.0);\n\t\tfloat sha = 0.0; if( dif>0.0 ) sha=softshadow( pos, lig, 0.05, 32.0 );\n        float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 2.0 );\n        float spe = pow( clamp( dot(lig,reflect(rd,nor)), 0.0, 1.0), 6.0 );\n\t\t\n\t\t\/\/ lights\n\t\tvec3 lin = vec3(0.0);\n        lin += 3.0*dif*vec3(1.50,1.00,0.65)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n\t\tlin += 5.0*amb*vec3(0.12,0.11,0.10)*occ;\n\t\tlin += 3.0*bac*vec3(0.30,0.20,0.15)*occ;\n        lin += 1.0*fre*vec3(0.50,0.50,0.50)*occ*15.0*mate.w*(0.05+0.95*dif*sha);\n\t\tlin += 1.0*spe*vec3(1.0)*6.0*occ*mate.w*dif*sha;\n\n\t\t\/\/ surface-light interacion\n\t\tcol = mate.xyz * lin;\n\n\t\t\/\/ fog\t\t\n\t\tcol = mix( col, 0.8*bgc, clamp(1.0-1.2*exp(-0.013*tmat.x ),0.0,1.0) );\n    }\n\telse\n\t{\n        \/\/ sun\t\t\n\t    vec3 sun = vec3(1.0,0.8,0.5)*pow( nds, 24.0 );\n\t    col += sun;\n\t}\n\n    \/\/ sun scatter\n\tcol += 0.4*vec3(0.2,0.14,0.1)*pow( nds, 7.0 );\n\n\n    \/\/-----------------------------------------------------\n\t\/\/ postprocessing\n    \/\/-----------------------------------------------------\n    \/\/ gamma\n\tcol = pow( col, vec3(0.45) );\n\n    \/\/ desat\n    col = mix( col, vec3(dot(col,vec3(0.333))), 0.2 );\n\n    \/\/ tint\n\tcol *= vec3( 1.0, 1.0, 1.0*0.9);\n\n\t\/\/ vigneting\n    col *= 0.2 + 0.8*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\n    \/\/ fade in\t\n\tcol *= smoothstep( 0.0, 2.0, iGlobalTime );\n\n    fragColor = vec4( col, 1.0 );\n}\n","name":"","description":"","type":"image"}]}}