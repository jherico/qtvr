{"Shader":{"ver":"0.1","info":{"id":"Xd2GzR","date":"1382730971","viewed":2057,"name":"Dual Complex Numbers","username":"iq","description":"Implementation of dual-complex numbers, which are useful to compute derivatives of complex functions analytically without central differences or limits\/epsilon differentiation. More info in dual numbers here: http:\/\/jliszka.github.io\/2013\/10\/24\/exact-nume","likes":18,"published":3,"flags":0,"tags":["2d","mandelbrot","distance","complex","analytic","dual","dualcomplex"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ An experiment on implementing \"dual complex\" numbers, in order to compute complex function\n\/\/ derivatives analytically without resorting to numerical differenciation. That way I can compute\n\/\/ derivatives, gradients and distance estimations analytically, easily and elegantly.!\n\n\/\/ In this case, I use them for rendering the Mandelbrot with a distance estimation coloring algorithm.\n\/\/ \n\/\/ See my \"Mandelbrot - distance\" shader for comparison: https:\/\/www.shadertoy.com\/view\/lsX3W4\n\/\/\n\/\/ See this article on dual numbers: http:\/\/jliszka.github.io\/2013\/10\/24\/exact-numeric-nth-derivatives.html\n\n\n\/\/-------------- dual complex numbers --------------\n\n\/\/ Z = { x, y, dx, dy } = (x + dx) + i\u00b7(y + dy)\n\nvec4 dcAdd( vec4 a, vec4 b )\n{\n    return a + b;\n}\n\nvec4 dcMul( vec4 a, vec4 b )\n{\n    return vec4( a.x*b.x - a.y*b.y, \n\t\t\t\t a.x*b.y + a.y*b.x,\n\t\t\t\t a.x*b.z + a.z*b.x - a.y*b.w - a.w*b.y,\n\t\t\t\t a.x*b.w + a.w*b.x + a.z*b.y + a.y*b.z );\n}\n\nvec4 dcSqr( vec4 a )\n{\n    return vec4( a.x*a.x - a.y*a.y, \n\t\t\t\t 2.0*a.x*a.y,\n\t\t\t\t 2.0*(a.x*a.z - a.y*a.w),\n\t\t\t\t 2.0*(a.x*a.w + a.y*a.z) );\n}\n\n\/\/--------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy \/ iResolution.xy;\n    p.x *= iResolution.x\/iResolution.y;\n\n    \/\/ animation\t\n\tfloat tz = 0.5 - 0.5*cos(0.225*iGlobalTime);\n    float zo = pow( 0.5, 13.0*tz );\n\t\n    vec4 c = vec4( vec2(-0.05,.6805) + p*zo, 1.0, 0.0 );\n\n\tfloat m2 = 0.0;\n    float co = 0.0;\n\t\n\tvec4 z = vec4( 0.0, 0.0, 0.0, 0.0 );\n\t\n    for( int i=0; i<256; i++ )\n    {\n        if( m2>1024.0 ) continue;\n\t\t\t\n        \/\/ Z -> Z\u00b2 + c\t\t\n\t\tz = dcAdd( dcSqr(z), c );\n\t\t\n\t\tm2 = dot( z.xy, z.xy );\n        co += 1.0;\n    }\n\n    \/\/ distance\t\n\t\/\/ d(c) = |Z|\u00b7log|Z|\/|Z'|\n\tfloat d = 0.0;\n\tif( co<256.0 ) d = sqrt( dot(z.xy,z.xy)\/dot(z.zw,z.zw) )*log(dot(z.xy,z.xy));\n\n\t\n    \/\/ do some soft coloring based on distance\n\td = clamp( 4.0*d\/zo, 0.0, 1.0 );\n\td = pow( d, 0.25 );\n    vec3 col = vec3( d );\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}