{"Shader":{"ver":"0.1","info":{"id":"Xts3zX","date":"1423872312","viewed":308,"name":"Obfuskali","username":"bergi","description":"kali fan shader","likes":3,"published":3,"flags":0,"tags":["3d","raymarching","fractal","kaliset","obfuscation"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/* KALI fan shader \n\n   2015, stefan berke\n   License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*\/\n\n\n#define Iterations \t\t5\n#define Surface \t\t0.05\n#define Time \t\t\t(iGlobalTime)\n\n#define TraceSteps\t\t20\n#define Fudge\t\t\t0.7\n#define MultiSample\t\t1\t\t\t\/\/ not quadratic, actual number of samples\n\n#define kTime (Time\/4.)\n#define KaliParam vec3(0.501+.5*sin(kTime\/11.1), .9, .3) + 0.1*vec3(sin(kTime), sin(kTime*1.1), sin(kTime*1.2));\n\nfloat kscale;\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    p.x = mod(p.x, 18.\/kscale);\n    p.y = mod(p.y, 13.\/kscale);\n    float koffs = .005;\n    a \/= kscale;\n    b \/= kscale;\n    r \/= kscale;\n\t\/\/ by IQ\n    vec3 pa = p - a - koffs, ba = b - a;\n    float h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n\/\/ the shape trap\nfloat inDE(in vec3 p)\n{\n    float d = sdCapsule(p, vec3(0,0,0), vec3(0,4,0), Surface);\n    d = min(d, sdCapsule(p, vec3(0,2,0), vec3(2,4,0), Surface));\n    d = min(d, sdCapsule(p, vec3(0,2,0), vec3(2,0,0), Surface));\n    \n    d = min(d, sdCapsule(p, vec3(3,0,0), vec3(4.5,4,0), Surface));\n    d = min(d, sdCapsule(p, vec3(6,0,0), vec3(4.5,4,0), Surface));\n    d = min(d, sdCapsule(p, vec3(4,2,0), vec3(5,2,0), Surface));\n    \n    d = min(d, sdCapsule(p, vec3(7,0,0), vec3(7,4,0), Surface));\n    d = min(d, sdCapsule(p, vec3(7,0,0), vec3(9,0,0), Surface));\n    \n    d = min(d, sdCapsule(p, vec3(10,0,0), vec3(10,4,0), Surface));\n    \n    return d;\n}\n\n\/\/ the arch structure\n\/\/ \"kali-set\" by Kali\nfloat DE(vec3 z)\n{\n\tfloat d = 100.;\n\tvec4 p = vec4(z, 1.);\n\tfloat s = Surface;\n    kscale = 1.;\n\tfor (int i=0; i<Iterations; ++i)\n\t{\n\t\tp = abs(p) \/ dot(p.xyz, p.xyz);\n        if (i!=0)\n\t\t\td = min(d, inDE(p.xyz\/p.w) - s); \n        s = s * .4;\n        kscale = pow(kscale,1.03) * 3.5;\n\t\tp.xyz -= KaliParam;\n\t}\n\treturn d;\n}\n\nvec3 calcNormal(in vec3 p )\n{\n    vec3 e = vec3(0.0001, 0,0);\n    return normalize(vec3(\n        \t\tDE(p + e.xyy) - DE(p - e.xyy),\n        \t\tDE(p + e.yxy) - DE(p - e.yxy),\n        \t\tDE(p + e.yyx) - DE(p - e.yyx)));\n}\n\n\/\/ nimitz https:\/\/www.shadertoy.com\/view\/lslXRS\nfloat hash(in vec2 x) { return fract(sin(dot(x, vec2(12.9898, 4.1414))) * 43758.5453); }\n\nfloat seed=0.;\nfloat rnd(in vec2 x) { float r = hash(x + seed); seed += 1.; return r; }\n\nmat2 rotate(float r) { float s = sin(r), c = cos(r); return mat2(c, -s, s, c); }\n\nvec3 render(in vec3 ro, in vec3 dir)\n{    \n\tvec3 col = vec3(0.);\n\n    \/\/ march\n    float d, t = DE(ro) * Fudge * rnd(dir.xy);\n    for (int i=0; i<TraceSteps; ++i)\n    {\n        vec3 p = ro + t * dir;\n        \n        float d = DE(p);\n        \n        col += 10.1\/max(0.002, d);\n       \n        t += d * Fudge;\n    }\n  \n\treturn col \/ (.1 + 10.*t*t*t) \/ float(TraceSteps);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ti = Time\/14.;\n    \n    vec3 ro = vec3(0.2*sin(ti*4.),0.,-1.5+sin(ti*1.21));\n    mat2 r = rotate(-ti);\n    ro.yz = r * ro.yz;\n    ro.x += 0.;\n\n    vec3 col = vec3(0.);\n    for (int i=0; i<MultiSample; ++i)\n    {\n\t\tvec2 uv = ((fragCoord.xy + rnd(fragCoord.xy)) * 2. - iResolution.xy) \/ iResolution.y;\n    \n        vec3 dir = normalize(vec3(uv, 1. - .4*dot(uv,uv)));\n        dir.yz = r * dir.yz;\n        dir.yz = rotate(.5+sin(ti*2.23)) * dir.yz;\n        dir.xy = rotate(2.*sin(ti*2.)) * dir.xy;\n        \n        col += render(ro, dir);\n    }\n    col \/= float(MultiSample);\n    \n    fragColor = vec4(clamp(pow(col,vec3(.5)),0.,1.),1.0);\n}\n\n\n\n","name":"","description":"","type":"image"}]}}