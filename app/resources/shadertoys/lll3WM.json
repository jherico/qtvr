{"Shader":{"ver":"0.1","info":{"id":"lll3WM","date":"1422586255","viewed":816,"name":"kali-traps c","username":"bergi","description":"Sorry for the fractal spamming lately - just this Kali set, it won't let go.<br\/>","likes":8,"published":3,"flags":0,"tags":["3d","fractal","volume","marching","kali","apolloneanlike"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/*\tkali-traps by bergi in 2015\n\t\n\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. \n\n\tman, just showing ..\n\ttry the other path as well ;)\n\n\there's a quick qt app that helped with the parameter scan\n\thttps:\/\/github.com\/defgsus\/kaliset\n\t(though it looks quite different with webgl float precision \n     compared to intel floats..)\n\n\tIt's really difficult to make a good shadertoy selfrunner,\n\tder Spass liegt im Explorieren dieser Menge.\n\t\n\t----- Interact with all the stuff below --------------\n*\/\n\n\/\/ 1 or 2\n#define PATH \t\t\t\t\t1\n\/\/ 0 or 1 (does not make sense at all times..)\n#define PARAM_MORPH\t\t\t\t0\n\n\/\/ animation time\n#if PATH == 1\nfloat ti = \t\t\t\t\t\tiGlobalTime * 1. + 76.;\n#else\nfloat ti = \t\t\t\t\t\tiGlobalTime * 2. + 500.;\n#endif\n\n\/\/ very slight param-set modifier\nfloat modf = \t\t\t\t\t.5 + .5 * sin(ti \/ 31.);\n\n#if PARAM_MORPH\n\t  vec3 KALI_PARAM = \t\tvec3(0.99-0.02*modf, 1., .7+.4*sin(ti\/71.));\n#else\n\t  vec3 KALI_PARAM = \t\tvec3(0.99-0.02*modf, 1., 1.01+0.02*modf);\n#endif\n\t  \nconst int  KALI_ITERS = \t\t29;\n\n\/\/ max traces\nconst int  NUM_ITERS = \t\t\t30;\n\/\/ multisample\nconst int  NUM_RAYS =\t\t\t1;\n\/\/ just for camera\nconst float PI = 3.14159265;\n\n\/** kali set as usual. \n\treturns last magnitude step and average *\/\nvec4 average;\nfloat kali(in vec3 p)\n{\n    average = vec4(0.);\n\tfloat mag;\n    for (int i=0; i<KALI_ITERS; ++i)\n    {\n        mag = dot(p, p);\n        p = abs(p) \/ mag;\n        average += vec4(p, mag);\n        p -= KALI_PARAM;\n    }\n\taverage \/= 32.;\n    return mag;\n}\n\n\/\/ steps from pos along dir and samples the cloud\n\/\/ stp is 1e-5 - 1e+?? :)\nvec3 ray_color(vec3 pos, vec3 dir, float stp)\n{\n    vec3 p, col = vec3(0.);\n\tfloat t = 0.;\n\tfor (int i=0; i<NUM_ITERS; ++i)\n\t{\n\t\tp = pos + t * dir;\n\t\tfloat d = kali(p);\n\n\t\t\/\/ define a surface and get trapped\n        \/\/ well it's all just numbers and signs really\n        \/\/ and trial-and-error\n        \/\/ the 'trap' is: making d small when close to what-looks-good\n\t\td = d*1.4-.3;\n            \/\/-d*1.3+1.;\n        \t\/\/1.4 - abs(1.1 - d);\n\t\t\n\t\t\/\/ always step within a certain range\n\t\tt += max(0.0001, min(0.0004+0.01*stp, d )) * (stp + 3. * t);\n\n\t\t\/\/ some color\n        d = max(-0.5, d-0.5);\n\t\tcol += average.rgb * (.7+.3*sin(average.rgb*vec3(3,5,7)*2.9)) \n\t\t\/\/ by distance to surface\n            \/ (1. + d * d * 400. + t * t \/ stp * 1000.);\n\t}\n    \n    return clamp(col \/ float(NUM_ITERS) * 7., 0., 1.);\n}\n\n\/\/ by D. Hoskins https:\/\/www.shadertoy.com\/view\/XlfGWN\nfloat hash(in vec2 uv)\n{\n\tvec3 p  = fract(vec3(uv,ti) \/ vec3(3.07965, 7.1235, 4.998784));\n    p += dot(p.xy, p.yx+19.19);\n    return fract(p.x * p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ frequency of slowness\n    float phasemf = 0.12;\n    float phasem = sin(ti*phasemf);\n    float phasem2 = sin(ti*phasemf+PI\/2.);\n    \n    \/\/ ray stepsize - or focus scale \n    float foc = 0.083 + 0.08*phasem2;\n\n    \/\/ camera circle phase\n    float rti = 0.05 * (ti + phasem \/ phasemf * 0.95);\n    \n    if (iMouse.z > .5) {\n        foc = pow(iMouse.y \/ iResolution.y, 2.)\/6.;\n    }\n\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) \/ iResolution.y * 2.;\n\n#if PATH == 1    \n\tvec3 pos = (vec3(0.3359+0.007*modf, 0.1139+0.0064*modf, -0.001-0.001*phasem2) \n                + (.0032 + 0.003 * phasem2) * vec3(uv, 0.)\n                + (0.113 + 0.005*modf) * vec3(sin(rti),cos(rti),0.) );\n    \n    vec3 dir = normalize(vec3(uv, 2.5-length(uv)\/1.3)).xyz;\n#else\n    \n    foc = foc * 3.4 + 0.01;\n    \n    vec3 pos = vec3(0.25 + .4*sin(rti), 0.1 * cos(rti), 0.),\n    \t posl = vec3(0.25 + .21*pow(sin(rti),3.), 0.02 * cos(rti) + 0.*sin(rti*2.3), -.1);\n    \n\tvec3 look = normalize(posl - pos);\n\tvec3 up = normalize(cross(vec3(0., 0., -1.), look));\n\tvec3 right = normalize(cross(look, up));\n\t\/\/look = normalize(cross(up, right));\n\tmat3 dirm = mat3(right, up, look);\n    \/\/ screen \/ near-plane\n    pos += dirm * (0.05 + 0.04 * phasem2) * vec3(uv, 0)\n        ;\n    vec3 dir = dirm * normalize(vec3(uv, 2.5-length(uv)\/1.3)).xyz;\n    \n#endif    \n\t\t\t\t\n\t\t\t\t\n    vec3 col = vec3(0.);\n    for (float i=0.; i<float(NUM_RAYS); ++i)\n    {\n        vec3 p = pos + dir * hash(uv*1114.+ti+i*17.) * (0.000002 + 0.001 * foc);\n\t\n    \tcol += ray_color(p, dir, foc * (1. + 0.03 * i));\n\t}\n    col \/= float(NUM_RAYS);\n        \n\n\tfragColor = vec4(pow(col,vec3(1.\/1.9)), 1.);\t\n}\n","name":"","description":"","type":"image"}]}}