{"Shader":{"ver":"0.1","info":{"id":"ltj3Dc","date":"1433422918","viewed":838,"name":"hypertexture - trabeculum","username":"FabriceNeyret2","description":"Trabeculum pattern. (camera follow mouse).<br\/>You can play with the defines for other patterns (NOISE) or larger trabelucum (VARIANT=0), and params in tweaknoise (thresh, scale).<br\/>Cheaper with SHADED=0 & FOG=1.","likes":11,"published":3,"flags":0,"tags":["procedural","noise","perlin","hypertexture","trabeculum"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define SHADED 1\n#define FOG 0\n#define NOISE 3 \/\/ Perlin, Worley, Trabeculum\n#define VARIANT 1\n\nconst vec3 skyColor = vec3(.7,.8,1.); const float skyTrsp = .5;\nconst vec3 sunColor = vec3(1.,.7,.1)*10.;   \nconst vec3 lightDir = vec3(.94,.24,.24); \/\/ normalize(vec3(.8,.2,-.2));\nconst vec3 ambient  = vec3(.2,0.,0.), \n           diffuse  = vec3(.8);\n\n#define PI 3.14159\n\n\/\/ --- noise functions from https:\/\/www.shadertoy.com\/view\/XslGRr\n\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n           \t\t    -0.80,  0.36, -0.48,\n             \t\t-0.60, -0.48,  0.64 );\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x ) { \/\/ in [0,1]\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.-2.*f);\n\n    float n = p.x + p.y*57. + 113.*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p ) { \/\/ in [0,1]\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\/\/ --- End of: Created by inigo quilez --------------------\n\n\/\/ more 3D noise\nvec3 hash13( float n ) {\n    return fract(sin(n+vec3(0.,12.345,124))*43758.5453);\n}\nfloat hash31( vec3 n ) {\n    return hash(n.x+10.*n.y+100.*n.z);\n}\nvec3 hash33( vec3 n ) {\n    return hash13(n.x+10.*n.y+100.*n.z);\n}\n\nvec4 worley( vec3 p ) {\n    vec4 d = vec4(1e15);\n    vec3 ip = floor(p);\n    for (float i=-1.; i<2.; i++)\n   \t \tfor (float j=-1.; j<2.; j++)\n            for (float k=-1.; k<2.; k++) {\n                vec3 p0 = ip+vec3(i,j,k),\n                      c = hash33(p0)+p0-p;\n                float d0 = dot(c,c);\n                if      (d0<d.x) { d.yzw=d.xyz; d.x=d0; }\n                else if (d0<d.y) { d.zw =d.yz ; d.y=d0; }\n                else if (d0<d.z) { d.w  =d.z  ; d.z=d0; }\n                else if (d0<d.w) {              d.w=d0; }   \n            }\n    return sqrt(d);\n}\n\n\nfloat grad=.2\/2., scale = 5., thresh=.5; \/\/ default value possibly overloaded below.\n\n\/\/ my noise\nfloat tweaknoise( vec3 p , bool step) {\n    float d1 = smoothstep(grad\/2.,-grad\/2.,length(p)-.5),\n          d2 = smoothstep(grad\/2.,-grad\/2.,abs(p.z)-.5),\n          d=d1;\n#if NOISE==1 \/\/ 3D Perlin noise\n    float v = fbm(scale*p);\n#elif NOISE==2 \/\/ Worley noise\n    float v = (.9-scale*worley(scale*p).x);\n#elif NOISE>=3 \/\/ trabeculum 3D\n  #if !VARIANT\n    d = (1.-d1)*d2; \n  #endif\n    if (d<0.5) return 0.;\n    grad=.8, scale = 10., thresh=.7+.3*(cos(.5*iGlobalTime)+.36*cos(.5*3.*iGlobalTime))\/1.36;\n    vec4 w=scale*worley(scale*p); \n    float v=1.-1.\/(1.\/(w.z-w.x)+1.\/(w.a-w.x)); \/\/ formula (c) Fabrice NEYRET - BSD3:mention author.\n#endif\n    \n    return (true)? smoothstep(thresh-grad\/2.,thresh+grad\/2.,v*d) : v*d;\n}\n\n\/\/ Cheap computation of normals+Lambert using directional derivative (see https:\/\/www.shadertoy.com\/view\/Xl23Wy )\n\/\/ still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\nfloat shadedNormal( vec3 p, float v ) {\n    float epsL = 0.01;\n#if 1\/\/ centered directional derivative\n    float dx = (tweaknoise(p+epsL*lightDir,false)-tweaknoise(p-epsL*lightDir,false))\/(2.*epsL);\n#else \/\/ cheap directional derivative\n    float dx = (tweaknoise(p+epsL*lightDir,false)-v)\/epsL;\n#endif\n    return clamp(-dx*grad\/scale\/v, 0.,1.); \/\/ Lambert shading\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ if (max(fragCoord.x,fragCoord.y)\/iResolution.y<.05) \n    \/\/ { fragColor = vec4(ambient,1.); return; }\n    \n    vec2 mouse=iMouse.xy\/iResolution.xy;\n    if (mouse.x+mouse.y==0.) mouse.xy=vec2(0.5);\n\n    \/\/camera\n    float theta = (mouse.x*2. - 1.)*PI;\n    float phi = (mouse.y - .5)*PI;\n#if 1 \/\/ camera shake \n    float t=10.*iGlobalTime,B=.02; theta += B*cos(t); phi += B*sin(t);\n#endif\n    vec3 cameraPos =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));   \n    vec3 cameraTarget = vec3(0.);\n    vec3 ww = normalize( cameraPos - cameraTarget );\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec2 q = 2.*(fragCoord.xy \/ iResolution.y -vec2(.9,.5));\n    vec3 rayDir = normalize( q.x*uu + q.y*vv -1.5*ww );\n  \n    \/\/ ray-trace volume\n    vec3 col=vec3(0.);\n \tfloat transp=1., epsC=.01\/2.;\n    float l = .5;\n    vec3 p=cameraPos+l*rayDir, p_=p;\n    \n    for (int i=0; i<200; i++) { \n        float Aloc = tweaknoise(p,true); \/\/ density field\n        if (Aloc>0.01) {\n            \n#if FOG \n\t      \tfloat fog = pow(skyTrsp,length(p_-p)); p_=p;\n            col += transp*skyColor*(1.-fog);\n    \t    transp *= fog; \n            if (transp<.001) break;\n#endif            \n\n#if SHADED          \n            vec3 c = ambient+diffuse*shadedNormal(p,Aloc);\n#else\n            vec3 c = vec3(0.);\n#endif\n \t        col += transp*c*Aloc;\n            \/\/if (c.r>1.) { fragColor = vec4(0.,0.,1.,1.); return; }\n            col = clamp(col,0.,1.); \/\/ anomaly :-(\n    \t    transp *= 1.-Aloc;\n\t        if (transp<.001) break;\n        }\n \n        p += epsC*rayDir;\n    }\n    \n   fragColor = vec4(col+ transp*skyColor, 1.);\n}","name":"","description":"","type":"image"}]}}