{"Shader":{"ver":"0.1","info":{"id":"XlsXDf","date":"1440337867","viewed":787,"name":"Bloodstream","username":"tsherif","description":"Flowing blood cells.","likes":1,"published":3,"flags":0,"tags":["3d","raymarching"],"hasliked":0},"renderpass":[{"inputs":[{"id":6,"src":"\/presets\/tex05.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":25,"src":"\/presets\/cube03_0.png","ctype":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"float map(in vec3 pos) {\n    pos.z += iGlobalTime * 2.0;\n    float a = sin(floor(pos.z \/ 12.0)) * 0.6;\n    float cosa = cos(a);\n    float sina = sin(a);\n    mat2 m2 = mat2(cosa, -sina, sina, cosa);\n    pos.xy = m2 * pos.xy;\n    \n    if (abs(pos.x) > 25.0 || abs(pos.y) > 25.0) {\n       return 200.0;\n    }\n    \n    vec3 c = mod(pos, 12.0) - 5.0;\n    c.y += sin(c.z) * 1.5;\n    \n    float r = 2.0;\n    r += 0.5 * sin(-pos.z + 0.1 * pos.x + 0.1 * pos.y + iGlobalTime * 4.0);\n    \n    float d = length(c) - r;\n    \n    \n    return d;\n}\n\nvec3 calcNormal(in vec3 pos) {\n    vec3 nor;\n    vec2 e = vec2(0.01, 0.0);\n    \n    nor.x = map(pos + e.xyy) - map(pos - e.xyy);\n    nor.y = map(pos + e.yxy) - map(pos - e.yxy);\n    nor.z = map(pos + e.yyx) - map(pos - e.yyx);\n    \n    return normalize(nor);\n}\n\nvec3 getRefl(in vec3 ro, in vec3 rd) {\n    float tmax = 20.0; \n    float t = 0.1;\n    \n    for (int i = 0; i < 32; i++) {\n        vec3 pos = ro + t * rd;\n        float h = map(pos);        \n       \n        if (t > tmax || h < 0.01) {\n        \tbreak;\n        };\n        \n        t += h * 0.5;\n    }\n    \n    vec3 pos = ro + t * rd;\n    \n    if (t > tmax) {\n        return textureCube(iChannel1, rd).rgb;\n    }\n    \n    vec3 light = normalize(vec3(1.0,1.0,0.5));\n    \n    vec3 nor = calcNormal(pos);\n        \n    vec3 mat = vec3(0.7, 0.0, 0.0);\n    vec3 spec = vec3(1.0) * pow(max(dot(-rd, reflect(-light, nor)), 0.0), 100.0);\n    vec3 diff = max(0.0, dot(light, nor)) * vec3(1.0);\n    \n    return mat * (diff + spec + 0.05) + 0.3;\n}\n\nvec3 getColor(in vec3 pos, in vec3 rd) {\n    vec3 light = normalize(vec3(1.0,1.0,0.5));\n    \n    vec3 nor = calcNormal(pos);\n        \n    vec3 mat = vec3(0.7, 0.0, 0.0);\n    vec3 refld = reflect(rd, nor);\n    vec3 refl = getRefl(pos, refld) + 1.0;\n    mat *= refl;   \n    vec3 spec = vec3(1.0) * pow(max(dot(-rd, reflect(-light, nor)), 0.0), 100.0);\n    vec3 diff = max(0.0, dot(light, nor)) * vec3(1.0);\n    vec3 color = mat * (diff + spec + 0.05);\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = fragCoord.xy \/ iResolution.xy;\n    \n    vec2 pos = p * 2.0 - 1.0;\n    \n    pos.x *= iResolution.x \/ iResolution.y;\n    \n    float r = length(pos);\n    float a = atan(pos.y, pos.x) + 0.3 * iGlobalTime;\n    \n    vec3 color = texture2D(iChannel0, vec2(1.0 \/ r + 0.8 * iGlobalTime + max(0.04 * sin(iGlobalTime * 4.0), 0.0), a)).rgb;\n    color *= vec3(100.0, 0.2, 0.2);\n    color = clamp(color, 0.0, 0.5);\n    color = mix(vec3(0.0), color, smoothstep(0.1, 0.4, r)); \n        \n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    a = 0.2 * sin(iGlobalTime * 0.2);\n    float cosa = cos(a);\n    float sina = sin(a);\n    mat2 m2 = mat2(cosa, -sina, sina, cosa);\n    vec3 rd = vec3(m2 * pos, -1.0);\n    \n    rd = normalize(rd);\n    \n    float tmax = 240.0;\n    float t = 0.0;\n    for (int i = 0; i < 256; i++) {\n      \tvec3 pos = ro + rd * t;\n        \n        float h = map(pos);\n        if (h < 0.001 || t > tmax) break;\n        t += h * 0.5;\n    }\n    \n    \n    \n    if (t < tmax) {\n        vec3 pos = ro + rd * t;\n        color = getColor(pos, rd);\n        float fog = exp(-0.00015 * t * t);\n    \tcolor = mix(vec3(0.0), color, fog);\n    }\n    \n    color = sqrt(color);\n    fragColor = vec4(color, 1.0);\n}","name":"","description":"","type":"image"}]}}