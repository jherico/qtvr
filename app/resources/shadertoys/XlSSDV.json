{"Shader":{"ver":"0.1","info":{"id":"XlSSDV","date":"1446421516","viewed":459,"name":"Raymarcher Visualisation","username":"jackdavenport","description":"A visualisation of how a raymarcher works. The left shows the distance of the objects from the camera, and the right shows the number of steps in the for loop.","likes":0,"published":3,"flags":0,"tags":["experiment","raymarcher","visualisation","step"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define MAX_ITERATIONS 256\n#define MIN_DISTANCE .001\n\nstruct Ray {\nvec3 ori;\nvec3 dir;\n};\nstruct Dist {\nfloat dst;\nint iter;\n};\n    \nfloat distSphere(vec3 p, vec3 pos, float r) {\n\n    return length(pos - p) - r;\n    \n}\n\nfloat distPlane(vec3 p, float y) {\n \n    return p.y - y;\n    \n}\n\nfloat scene(vec3 p) {\n \n    float dst = distPlane(p, -1.);\n    \n    for(int x = 0; x < 12; x++) {\n     \n        for(int z = 0; z < 12; z++) {\n         \n            vec3 pos = vec3(-6. + float(x) + 1., 0., -6. + float(z) + 1.);\n            dst = min(dst, distSphere(p - vec3(0.,0.,10.), pos, .3));\n            \n        }\n        \n    }\n    \n    return dst;\n    \n}\n\nDist raymarch(Ray ray) {\n \n    vec3 p = ray.ori;\n    int iter = 0;\n    float dist = 0.;\n    \n    for(int i = 0; i < MAX_ITERATIONS; i++) {\n     \n        dist = scene(p);\n        p += ray.dir * dist;\n        \n        iter = i;\n        \n        if(dist < MIN_DISTANCE) {\n\n            break;\n            \n        }\n        \n    }\n    \n    return Dist(distance(ray.ori,p),iter);\n    \n}\n\nvec4 shade(Ray ray) {\n \n    vec2 uv = gl_FragCoord.xy\/iResolution.xy;\n    float center = .5;\n    \n    if(iMouse.z>0.) center = iMouse.x\/iResolution.x;\n        \n    Dist dst = raymarch(ray);\n    \n    if(uv.x <= center) {\n        \n        float theDist = dst.dst;\n        float maxDist = 1000.;\n        \n        return vec4(vec3(theDist\/maxDist),1.);\n        \n    } else {\n     \n        float curI = float(dst.iter);\n    \tfloat maxI = float(MAX_ITERATIONS);\n    \n    \treturn vec4(vec3(curI\/maxI),1.);\n        \n    }\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy \/ 2.) \/ iResolution.y;\n    \n    vec3 ori = vec3(0.,2.,-2.);\n    vec3 dir = vec3(uv, 1.);\n    \n\tfragColor = shade(Ray(ori,dir));\n}","name":"","description":"","type":"image"}]}}