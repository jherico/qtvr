{"Shader":{"ver":"0.1","info":{"id":"XllGRl","date":"1424307327","viewed":1983,"name":"Surface Splats","username":"iq","description":"Stochastic rasterization of splats. Random points are generated at the surface of some parametric objects, and the points are projected into screen space. A z\/depth buffer mechanism resolves visibility, and then shading happens in a deferred manner.","likes":20,"published":3,"flags":0,"tags":["3d","projection","rasterization","splat","stochastic"],"hasliked":0},"renderpass":[{"inputs":[{"id":2,"src":"\/presets\/tex01.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Stochastic rasterization of splats.\n\/\/\n\/\/ Random points are generated at the surface of some parametric objects, and the points are\n\/\/ projected into screen space. A z\/depth buffer mechanism resolves visibility, and then shading\n\/\/ happens in a dererred manner.\n\/\/\n\/\/ I think I first saw this technique in Texel's entry to js01k a few years ago.\n\/\/\n\/\/ The object probability distribution is proportional to the area of the object's surface area.\n\nvec3 sphere( in vec2 t )\n{\n    #if 0\n     vec2 q = t * vec2(1.0,0.5) * 6.2831;\n     return vec3( cos(q.x)*sin(q.y), cos(q.y), sin(q.x)*sin(q.y) );\n    #else\n     float y = -1.0 + 2.0*t.y;\n     vec2 q = vec2( t.x*6.2831, acos(y) );\n     return vec3( cos(q.x)*sin(q.y), y, sin(q.x)*sin(q.y) );\n    #endif\n}\n\nvec3 cylinder( in vec2 t )\n{\n    float q = t.x*6.2831;\n    return vec3( 0.5*cos(q), -1.0 + 4.0*t.y, 0.5*sin(q) );\n}\n\nvec3 quad( in vec2 t )\n{\n    return 3.0*vec3( -1.0+2.0*t.x, 0.0, -1.0+2.0*t.y );\n}\n\nfloat rand( in float p )  { return fract( p\/0.123454); }\nvec3  rand( in vec3  p )  { return fract( p\/0.123454); }\n\nfloat hash1( in float n ) { return fract(sin(n)*43758.5453123); }\nvec2  hash2( in float n ) { return fract(sin(vec2(n,n+3.1))*43758.5453123); }\nvec3  hash3( in float n ) { return fract(sin(vec3(n,n+3.1,n+5.7))*43758.5453123); }\n\nmat4 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat4( cu.x, cu.y, cu.z, 0.0,\n                 cv.x, cv.y, cv.z, 0.0,\n                 cw.x, cw.y, cw.z, 0.0,\n                 ro.x, ro.y, ro.z, 1.0 );\n}\n\nmat4 inverse( in mat4 m )\n{\n\treturn mat4(\n        m[0][0], m[1][0], m[2][0], 0.0,\n        m[0][1], m[1][1], m[2][1], 0.0,\n        m[0][2], m[1][2], m[2][2], 0.0,\n        -dot(m[0].xyz,m[3].xyz),\n        -dot(m[1].xyz,m[3].xyz),\n        -dot(m[2].xyz,m[3].xyz),\n        1.0 );\n}\n\n\/\/==============================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ pixel    \n\tvec2 p = (-iResolution.xy+2.0*fragCoord.xy) \/ iResolution.y;\n    \n    \/\/ camera\n    float an = iGlobalTime;\n    vec3  ro = 4.0*normalize(vec3(cos(an), 0.0, sin(an)));\n\tvec3  ta = vec3(0.0, 0.0, 0.0);\n    \n    \/\/ camera-to-world abd world-to-camear transform\n    mat4 c2w = setCamera( ro, ta, 0.0 );\n    mat4 w2c = inverse(c2w);\n    \n    vec3 col = vec3( 0.0 );\n\n    float dither = smoothstep( -0.1, 0.1, sin(iGlobalTime) );\n    \n    float off = hash1( iGlobalTime*0.0 + dither*dot(fragCoord.xy,vec2(113.0,317.0)) );\n    vec3 t = 0.5 + hash3( off );\n    \n    \/\/ zbuffer\n    float fz = 1e10;\n    vec3  ft = vec3(-1.0);                  \n    float fi = 0.0;\n    for( int i=0; i<1024; i++ )\n    {\n        \/\/ pick a random point on the surface of the scene\n\n        \/\/ area of the sphere = 4.2, araa of the plane = 36.0, area of the cylidner = 15.7\n        vec3 w; float id;\n             if( t.z<((15.7     )\/55.9) ) { id=0.0; w = vec3(2.0, 0.0,0.0)+cylinder( t.xy ); }\n        else if( t.z<((15.7+36.0)\/55.9) ) { id=1.0; w = vec3(0.0,-1.0,0.0)+quad(     t.xy ); }\n        else                              { id=2.0; w =                    sphere(   t.xy ); }\n            \n        \/\/ convert to camera space\n        vec3 q = (w2c * vec4(w,1.0)).xyz;\n            \n        \/\/ discard if behind clipping plane\n        if( q.z<0.0 ) continue;\n\n        \/\/ project            \n        vec2 s = q.xy\/q.z;\n\n        \/\/ splat with depth test        \n        if( ((q.z*q.z*dot(s-p,s-p))<0.02) && q.z<fz )\n        {\n            fz = q.z;\n            ft = t;\n            fi = id;\n        }\n        \n        \/\/ generate new random sample        \n        t = rand( t );\n        \/\/t = hash3( float(i)*.2 + off );\n    }\n    \n    \/\/ if splat\n    if( ft.z>-0.5 )\n    {\n        t = ft;\n        \n        \/\/ compute position, normals and occlusion\n        vec3 pos, nor; float occ;\n        \n             if( fi<0.5 ) { pos = vec3(2.0, 0.0,0.0)+cylinder( t.xy ); nor = normalize( cylinder( t.xy )*vec3(1.0,0.0,1.0) ); occ = 0.5 + 0.5*smoothstep(-1.0,1.0,pos.y ); }\n        else if( fi<1.5 ) { pos = vec3(0.0,-1.0,0.0)+quad(     t.xy ); nor = vec3(0.0,1.0,0.0); occ = smoothstep(0.0,2.0,length(pos.xz)) * smoothstep(0.0,2.0,length(pos.xz-vec2(2.0,0.0)));}\n        else              { pos =                    sphere(   t.xy ); nor = normalize(sphere( t.xy )); occ = 0.5 + 0.5*nor.y; }\n\n        \/\/ shade        \n        col = texture2D( iChannel0, 2.0*t.xy, -1000.0 ).xyz * occ + 0.1*nor.yxz*occ;\n        \n        \/\/ gamma\n        col = sqrt( col );\n    }\n    \n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}