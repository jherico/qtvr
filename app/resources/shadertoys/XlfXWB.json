{"Shader":{"ver":"0.1","info":{"id":"XlfXWB","date":"1439244489","viewed":831,"name":"Red Space (NMS)","username":"mech4rhork","description":"No Man's Sky inspired","likes":2,"published":3,"flags":0,"tags":["3d","raymarching","distancefields"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define PI\t\t\t\t3.14159265359\n\n#define GAMMA \t\t\t2.2\n#define time\t\t\tvec4( iGlobalTime*.125, iGlobalTime*.25, iGlobalTime*1., iGlobalTime*5. )\n#define mouse \t\t\tvec2( iMouse.xy \/ iResolution.xy )\n#define MAX_ITERATIONS\t97\n#define RENDER_INTERVAL\tvec2( 0.1, 11000.0 )\n\n#define MATERIAL_01\t\t1.0\n#define MATERIAL_02\t\t2.0\n#define MATERIAL_03\t\t3.0\n#define MATERIAL_04\t\t4.0\n#define MATERIAL_05\t\t5.0\n#define MATERIAL_06\t\t6.0\n#define MATERIAL_07 \t7.0\n\n#define SHADOWS\n\/\/#define SPACE_STATION\n\/\/#define FREIGHTER\n\/\/#define PLANET\n\n\/\/#define ASTEROID_FIELD \/\/ TODO\n\n\nconst float startDelta = RENDER_INTERVAL.x;\nconst float stopDelta = RENDER_INTERVAL.y;\n\n\/\/ ________\n\/\/ |||||||| gamma correction\nvec3 toGamma( vec3 col ) {\n\treturn pow( col, vec3( 1.0 \/ GAMMA ) );\n}\n\n\/\/ ________\n\/\/ |||||||| transformations\nmat3 rotate( mat3 mat, vec3 theta ) {\n    float sx = sin( theta.x ), sy = sin( theta.y ), sz = sin( theta.z ),\n        cx = cos( theta.x ), cy = cos( theta.y ), cz = cos( theta.z );\n\treturn mat *\n        mat3( 1.0, 0.0, 0.0, 0.0, cx, -sin( theta.x ), 0.0, sx, cx ) *\n        mat3( cy, 0.0, sy, 0.0, 1.0, 0.0, -sy, 0.0, cy ) *\n        mat3( cz, -sz, 0.0, sz, cz, 0.0, 0.0, 0.0, 1.0 );\n}\nvec3 rotate( vec3 p, vec3 theta ) {\n    float  cx = cos( theta.x ), sx = sin( theta.x ), cy = cos( theta.y ),\n        sy = sin( theta.y ), cz = cos( theta.z ), sz = sin( theta.z );\n    p.yz *= mat2( cx, -sx, sx, cx ); p.xz *= mat2( cy, -sy, sy, cy ); p.xy *= mat2( cz, -sz, sz, cz );\n    return p;\n}\n\n\/\/ ________\n\/\/ |||||||| noise\n\/\/ by Dave_Hoskins\nfloat hash(float p) {\n\tvec2 p2 = fract(vec2(p) * vec2(443.8975,397.2973));\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);\n}\n\/\/ by iq\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\nfloat fbm( vec3 p, vec3 scale, vec3 offset ) {\n    const mat3 m = mat3( 0.00,  0.80,  0.60, -0.80,  0.36, -0.48, -0.60, -0.48,  0.64 );\n    vec3 q = scale*p + offset;\n    float f = 0.0;\n   \tf  = 0.5000*noise( q ); q = m*q*2.01;\n   \tf += 0.2500*noise( q ); q = m*q*2.02;\n   \tf += 0.1250*noise( q ); q = m*q*2.03;\n   \tf += 0.0625*noise( q ); q = m*q*2.01;\n\treturn f;\n}\n\n\/\/ ________\n\/\/ |||||||| primitives - from iq\nfloat sdPlane( vec3 p, vec4 n ) {\n    n = normalize( n );\n    return dot( p, n.xyz ) + n.w;\n}\nfloat sdBox( vec3 p, vec3 b ) {\n\tvec3 d = abs( p ) - b;\n  \treturn min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\nfloat sdSphere( vec3 p, float s ) {\n    return length( p ) - s;\n}\nfloat sdHexPrism( vec3 p, vec2 h ) {\n    vec3 q = abs( p );\n    float d1 = q.z - h.y;\n    float d2 = max( ( q.x * 0.866025 + q.y * 0.5 ), q.y ) - h.x;\n    return length( max( vec2( d1, d2), 0.0 ) ) + min( max( d1, d2 ), 0.0 );\n}\nfloat sdTriPrism( vec3 p, vec2 h ) {\n    vec3 q = abs( p );\n    float d1 = q.z - h.y;\n    float d2 = max( q.x * 0.866025 + p.y * 0.5, - p.y ) - h.x * 0.5;\n    return length( max( vec2( d1, d2 ),0.0 ) ) + min( max( d1, d2 ), 0.0 );\n}\nfloat sdCone( vec3 p, vec3 c ) {\n    vec2 q = vec2( length( p.xz ), p.y );\n    float d1 = -p.y - c.z;\n    float d2 = max( dot( q, c.xy ), p.y );\n    return length( max( vec2( d1, d2 ), 0.0 ) ) + min( max( d1, d2 ), 0.0 );\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n    return length( vec2( length( p.xz ) - t.x, p.y ) ) - t.y;\n}\n\/\/ ----\nvec2 opS( vec2 d1, vec2 d2 ) {\n    return ( -d2.x > d1.x ) ? vec2( -d2.x, d2.y ) : d1;\n}\nvec2 opU( vec2 d1, vec2 d2 ) {\n\treturn ( d1.x < d2.x ) ? d1 : d2;\n}\nvec2 opI( vec2 d1, vec2 d2 ) {\n\treturn ( d1.x > d2.x ) ? d1 : d2;\n}\n\/\/ ----\nvec2 udPyramid( vec3 p, vec2 s ) {\n    vec3 e = vec3( abs( p.x ), p.y, abs( p.z ) ) - vec3( 0.0, -s.x, 0.0 );\n    vec3 up = vec3( 0.0, 1.0, 0.0 );\n    float an = PI\/4.0 * s.y * 0.05;\n    vec2 d = vec2( sdPlane( e - vec3( 0.0, -2.0 * s.x, 0.0 ), vec4( rotate( up, vec3( 0.0, 0.0, PI ) ), 1.0 ) ), 7.1 );   \n   \td = opI(d, vec2(\n            sdPlane( e, vec4( rotate( up, vec3( an, 0.0, 0.0 ) ), 1.0 ) ),\n            7.1 ) );\n    d = opI(d, vec2(\n            sdPlane( e, vec4( rotate( up, vec3( 0.0, 0.0, -an ) ), 1.0 ) ),\n            7.1 ) );\n    d = opI(d, vec2(\n            sdPlane( e - vec3( 0.0, -2.0 * s.x, 0.0 ), vec4( rotate( up, vec3( 0.0, 0.0, PI ) ), 1.0 ) ),\n            7.1 ) );   \n    return d;\n}\nvec2 udPyramid2( vec3 p, vec2 s ) {    \n    vec3 e = vec3( abs( p.x ), p.y, abs( p.z ) ) - vec3( 0.0, -s.x, 0.0 );\n    vec3 up = vec3( 0.0, -1.0, 0.0 );\n    float an = ( -PI\/2.0 + PI\/4.0 ) * s.y * 0.05;\n    vec2 d = vec2(\n        sdPlane( e - vec3( 0.0, 2.0 * s.x, 0.0 ), vec4( rotate( up, vec3( 0.0, 0.0, PI ) ), 1.0 ) ),\n        7.1 );\n   \td = opI(d, vec2(\n            sdPlane( e, vec4( rotate( up, vec3( an, 0.0, 0.0 ) ), 1.0 ) ),\n            7.1 ) );\n    d = opI(d, vec2(\n            sdPlane( e, vec4( rotate( up, vec3( 0.0, 0.0, -an ) ), 1.0 ) ),\n            7.1 ) );\n    return d;\n}\nvec2 sdCockpit( vec3 p ) {\n    vec2 d = vec2( 1e10, -100.0 );\n \tvec3 s;\n    \/\/vec2 handle = 2.0 * mouse - 1.0;\n    \n    s = vec3( abs( p.x ), p.yz );\n    d = opU( d, vec2(\n        sdBox( rotate( s - vec3( 1.75, 0.0, 2.4 ), vec3( PI\/6.0, 0.0, PI\/6.5 ) ), vec3( 0.08, 2.0, 0.09 ) ),\n        3.1 ) );\n    d = opS( d, vec2(\n        sdBox( rotate( s - vec3( 1.68, 0.044, 2.383 ), vec3( PI\/6.0, 0.0, PI\/6.5 ) ), vec3( 0.04, 1.9, 0.045 ) ),\n        3.1 ) );\n    \n    d = opU( d, vec2(\n        sdBox( rotate( s - vec3( 1.66, -2.2, 2.5 ), vec3( 0.0, -PI\/7.0, 0.0 ) ), vec3( 0.25, 0.9, 2.8 ) ),\n        3.1 ) );\n    d = opS( d, vec2(\n        sdBox( rotate( s - vec3( 1.4, -1.07, 2.5 ), vec3( 0.0, -PI\/7.0, 0.0 ) ), vec3( 0.3, 0.3, 2.8 ) ),\n        3.1 ) );\n    \n    d = opU( d, vec2(\n        sdBox( s - vec3( 0.0, 1.57, 1.57 ), vec3( 3.0, 0.1, 0.05 ) ),\n        3.1 ) );\n    d = opU( d, vec2(\n        sdHexPrism( rotate( s - vec3( 1.0, -1.0, 2.85 ), vec3( PI\/40.0, 0.0, 0.0 ) ), vec2( 0.5, 0.2 ) ),\n        3.1 ) );\n    d = opU( d, vec2(\n        sdHexPrism( rotate( s - vec3( 0.0, -1.96, 2.8 ), vec3( -PI\/32.0, 0.0, 0.0 ) ), vec2( 1.55, 0.33 ) ),\n        3.1 ) );\n    d = opU( d, vec2(\n        sdBox( rotate( s - vec3( 2.2, 1.4, 1.91 ), vec3( -PI\/6.0, 0.0, -PI\/6.5 ) ), vec3( 0.05, 0.485, 0.03 ) ),\n        3.1 ) );\n    \/*d = opU( d, vec2(\n        sdBox( rotate( s - vec3( 1.65, -1.1, 2.92 ), vec3( -PI\/6.0, -PI\/20.0, -PI\/8.0 ) ), vec3( 0.03, 0.6, 0.07 ) ),\n        3.1 ) );*\/\n    d = opU( d, vec2(\n        sdBox( rotate( s - vec3( 1.85, -1.15, 2.5), vec3( -PI\/8.0, -PI\/8.0, -PI\/6.0 ) ), vec3( 0.03, 0.85, 0.08 ) ),\n        3.1 ) );\n    \/*d = opU( d, vec2(\n        sdBox( rotate( s - vec3( 2.0, -2.05, 0.27 ), vec3( -PI\/6.0, PI\/9.0, -PI\/16.0 ) ), vec3( 0.1, 1.4, 1.1 ) ),\n        3.1 ) );*\/ \/\/ R\n    d = opU( d, vec2(\n        sdBox( rotate( s - vec3( 0.0, -3.2, 1.9 ), vec3( PI\/4.0, 0.0, 0.0 ) ), vec3( 1.484, 1.2, 2.1 ) ),\n        3.1 ) );\n    \n    \/\/ monitors\n    d = opU( d, vec2(\n        sdBox( rotate( s - vec3( 0.0, -1.13, 2.6 ), vec3( PI\/4.0, 0.0, 0.0 ) ), vec3( 0.99, 0.3, 0.025 ) ),\n        5.1 ) );\n    d = opU( d, vec2(\n        sdBox( rotate( s - vec3( 0.53, -1.42, 2.0 ), vec3( -PI\/4.0, 0.0, 0.0 ) ), vec3( 0.47, 0.5, 0.05 ) ),\n        6.1 ) );\n    \n    \/\/ top\n    s = mod( vec3( abs( p.x * 1.33 ) - 0.2, p.yz - vec2( 0.1 * step( 0.99, abs( p.x ) ), 0.0 ) ), vec3( 2.0, 0.0, 0.0 ) ) - 0.15;\n    d = opU( d, vec2(\n        sdBox( rotate( s - vec3( 0.2, 1.39, 1.58 ), vec3( PI\/4.0, 0.0, 0.0 ) ), vec3( 1.4, vec2( 0.1 ) ) ),\n        3.1 ) );\n    \n    \/\/ buttons\n    s = mod( vec3( abs( p.x * 6.0 ) - 0.88, p.yz - vec2( 0.5 * step( 0.99, abs( p.x ) ), 0.0 ) ), vec3( 2.0, 0.0, 0.0 ) ) - 0.074;\n    d = opU( d, vec2(\n        sdBox( rotate( s - vec3( 0.0, 1.41, 1.59 ), vec3( PI\/4.0, 0.0, 0.0 ) ), vec3( 0.67, 0.06, 0.099 ) ),\n        4.1 ) );\n    \n    return d;\n}\nvec2 sdFreighter( vec3 p ) {\n    vec2 d = vec2( 1e10, -100.0 );\n \t\/\/vec3 s;\n    vec2 handle = 2.0 * mouse - 1.0;\n    \n    \/*d = opU( d, vec2(\n        sdBox( p, vec3( 35.0, 15.0, 125.0 ) ),\n        7.1 ) );*\/\n    p *= 1.1;\n    d = opU( d, vec2(\n        sdTriPrism( rotate( p * vec3( 0.5, 2.0, 1.0 ), vec3( PI, 0.0, 0.0 ) ), vec2( 23.0, 125.0 ) ),\n        7.1 ) );\n    d = opU( d, vec2(\n        sdBox( p - vec3( 0.0, 10.0, 60.0 ), vec3( 20.0, 33.0, 20.0 ) ),\n        7.1 ) );\n    d = opU( d, vec2(\n        sdBox( p - vec3( 0.0, 40.0, 60.0 ), vec3( 1.5, 30.0, 1.5 ) ),\n        7.1 ) );\n    \n    return d;\n}\nvec2 sdSpaceStation( vec3 p ) {\n    vec2 d = vec2( 1e10, -100.0 );\n \t\/\/vec3 s;\n    \/\/vec2 handle = 2.0 * mouse - 1.0;\n    \n    d = opU( d, udPyramid( p, vec2( 39.0, 24.0 ) ) );\n    d = opU( d, udPyramid2( p - vec3( 0.0, -155.0, 0.0 ), vec2( 40.0, 24.75 ) ) );\n    d = opU( d, vec2(\n        sdSphere( p - vec3( 0.0, -69.5, 0.0 ), 26.8 ),\n        7.1 ) );\n    d = opU( d, vec2(\n        sdSphere( p - vec3( 0.0, -45.5, 0.0 ), 10.6 ),\n        7.1 ) );\n    \n    d = opS( d, vec2(\n        sdBox( p - vec3( 0.0, -186.5, 0.0 ), vec3( 17.0 ) ),\n        7.1 ) );\n    \n    d = opU( d, vec2(\n        sdBox( p - vec3( 0.0, -169.5, 0.0 ), vec3( 13.8, 6.2, 13.8 ) ),\n        7.1 ) );\n    d = opU( d, vec2(\n        sdBox( p - vec3( 0.0, -175.5, 0.0 ), vec3( 4.0, 15.0, 4.0 ) ),\n        7.1 ) );\n    \n    return d;\n}\nvec2 sdAsteroidField( vec3 p ) { \/\/ TODO\n    return vec2( 0.0 );\n}\n\n\/\/ ________\n\/\/ |||||||| scene\nvec2 map( vec3 p ) {\n    vec2 d = vec2( 1e10, -100.0 );\n    vec3 s;\n    vec2 handle = mouse;\n    \n    \/\/ cockpit\n    d = opU( d, sdCockpit( p ) );\n    \n    \/\/ space station\n    #ifdef SPACE_STATION\n    d = opU( d, sdSpaceStation( rotate( p - vec3( -79.0, 212.0, 428.0 ), vec3( -PI\/15.0, -PI\/2.9, -PI\/7.2 ) ) ) );\n    #endif\n    \n    \/\/ freighter\n    #ifdef FREIGHTER\n    d = opU( d, vec2( sdFreighter( rotate( p - vec3( 165.0, 85.0, 550.0 ), vec3( PI\/6.5, PI\/3.25, -PI\/16.0 ) ) ) ) );\n    #endif\n    \n    \/\/ planet\n    #ifdef PLANET\n    d = opU( d, vec2( sdSphere( p - vec3( 6900.0, 750.0, 7450.0 ), 950.0 ), 2.1 ) );\n    #endif\n        \n    \/\/ asteroid field TODO\n    #ifdef ASTEROID_FIELD\n    \/\/ TODO\n    #endif\n    \n    \/\/ debug\n    \/*d = opU( d, vec2(\n        sdBox( rotate( p - vec3( -100.0, -180.0, 400.0 ), vec3( -PI\/2.0, 0.0, 0.0 ) ), vec3( 50.0, 1200.0, 50.0 ) ), \/\/ TEST BOX\n        1.1 ) );\n    d = opU( d, vec2(\n        sdBox( rotate( p - vec3( 100.0, -180.0, 400.0 ), vec3( 0.0, 0.0, 0.0 ) ), vec3( 20.0, 250.0, 20.0 ) ), \/\/ TEST BOX\n        1.1 ) );\n    d = opU( d, vec2(\n        sdPlane( p - vec3( 0.0, -200.0, 0.0 ), vec4( 0.0, 1.0, 0.0, 1.0 ) ),\n        1.1 ) );*\/\n    \n    return d;\n}\n\n\/\/ ________\n\/\/ |||||||| raymarching\nvec2 castRay( vec3 ro, vec3 rd ) {\n    vec2 delta = vec2( startDelta, -100.0 );\n    float maxDist = 0.002;\n    for( int i = 0; i < MAX_ITERATIONS; i++ ) {\n        vec2 dist = map( ro + rd * delta.x );\n        if( dist.x <= maxDist || dist.x > stopDelta ) break;\n        delta = vec2( delta.x + dist.x, dist.y );\n    }\n    return delta;\n}\n\nvec3 calcNormal( vec3 pos, float delta ) {\n    vec2 unit = vec2( 1.0, 0.0 );\n    return normalize( vec3(\n        map( pos + unit.xyy * delta ).x - map( pos - unit.xyy * delta ).x,\n        map( pos + unit.yxy * delta ).x - map( pos - unit.yxy * delta ).x,\n        map( pos + unit.yyx * delta ).x - map( pos - unit.yyx * delta ).x\n    ) );\n}\n\n\/\/ from \"Star Nest\" by Kali  --  https:\/\/www.shadertoy.com\/view\/XlfGRj\n\/\/ ------------------------------\n\/\/ Copyright Pablo Rom\u00e1n Andrioli\n\/\/ ------------------------------\nvec3 StarNest_by_Kali() {\n    \n    \/\/ parameters\n    #define iterations \t15\n\t#define formuparam \t0.53\n\t#define volsteps \t11\n\t#define stepsize \t0.25\n\t#define zoom   \t\t0.500\n\t#define tile   \t\t0.850\n\t#define speed  \t\t0.010 \n\t#define brightness \t0.0015\n\t#define darkmatter \t0.300\n\t#define distfading \t0.730\n\t#define saturation \t0.99\n    \n\t\/\/get coords and direction\n\tvec2 uv=gl_FragCoord.xy\/iResolution.xy-.5;\n\tuv.y*=iResolution.y\/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n\n\t\/\/mouse rotation\n\tfloat a1=.5+0.7151277;\n\tfloat a2=.8+0.2445;\n\tmat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n\tmat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n\tdir.xz*=rot1;\n\tdir.xy*=rot2;\n\tvec3 from=vec3(0.0,0.0,100.5);\n\tfrom.xz*=rot1;\n\tfrom.xy*=rot2;\n\t\n\t\/\/volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); \/\/ tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)\/dot(p,p)-formuparam; \/\/ the magic formula\n\t\t\ta+=abs(length(p)-pa); \/\/ absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); \/\/dark matter\n\t\ta*=a*a; \/\/ add contrast\n\t\tif (r>6) fade*=1.-dm; \/\/ dark matter, don't render near\n\t\tv+=fade;\n\t\tv+=vec3(s*s*s*s,s*s,s)*a*brightness*fade; \/\/ coloring based on distance\n\t\tfade*=distfading; \/\/ distance fading\n\t\ts+=stepsize;  \n\t}\n\tv=mix(vec3(length(v)),v,saturation); \/\/color adjust\n\treturn vec3(v*.01);\n}\n\nfloat getFog( float dist ) {\n    return 1.0 - exp( -dist * dist * 0.000003 );\n}\n\nvec3 getSkyColor( vec3 lig, vec3 rd ) {    \n    vec3 uv = vec3( gl_FragCoord.xy \/ iResolution.xy, 10.335454 ) + vec3( -1.0, 0.05, 0.03 );\n    \n    vec3 red = vec3( 0.67, 0.02, 0.01 );\n    vec3 color = red; \/\/ vec3( 0.89, 0.021, 0.02 ); \/\/ background\n        \n    float sun = 2.2 * pow( clamp( dot( rd, lig )*1.0055, 0.0, 1.0 ), 260.0 );\n    float halo = 3.0 * pow( clamp( sqrt( dot( rd, lig ) ), 0.0, 1.0 ), 150.0 ); \/\/ 0.8 * pow( clamp( length( lig - rd ), 0.0, 1.0 ), 0.99 );\n    vec3 stars = StarNest_by_Kali();\n    \n    \/\/ noise\n    float n = fbm( uv, vec3( 8.6 ), vec3( 0.0 ) );\n    n *= fbm( uv, vec3( 2.0, n*1.14, 5.0 ), vec3( n * 3.112 ) );\n    float n2 = exp(-n*n*21.0);\n    \n    color *= 0.5 + n2;\n    color = mix( color, stars * vec3( 1.0, 0.5, 0.6 ), n );\n    color += 0.5 * red;\n    color += 0.8 * halo + 0.4 * halo * red;\n    color += sun * vec3( 0.94, 0.93, 0.85 );\n    \n    \/*\n    color *= vec3( n*n, 0.1 * n, n );\n    \/\/color += 0.033 * mix( stars, color, 1.0 - halo * 10.0 );\n    color.gb *= n;\n    color += sun * vec3( 0.94, 0.93, 0.81 );\n    color += 0.95 * vec3( 0.89, 0.021, 0.02 ) * (0.77 + sun);*\/\n    \n    \/\/return vec3( exp(-n*n*25.0) * stars * vec3( 0.99, 0.025, 0.01 ) );\n\treturn color;\n}\n\n\/\/ by iq\nfloat calcSoftShadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in int samples ) {\n\tfloat res = 1.0;\n    float t = mint;\n    float stepDist = ( tmax - mint ) \/ float( samples );\n    for( int i = 0; i < 32; i++ ) {\n\t\tfloat h = map( ro + rd * t ).x;\n        res = min( res, 8.0 * h \/ t );\n        t += clamp( h, stepDist, 1e10 );\n        if( h < 0.001 || t > tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\/\/ by iq\nfloat calcAO( in vec3 pos, in vec3 nor ) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i = 0; i < 4; i++ ) {\n        float hr = 0.01 + 0.03 * float( i );\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -( dd - hr ) * sca;\n        sca *= 0.99;\n    }\n    return clamp( 1.0 - 4.0 * occ, 0.0, 1.0 );    \n}\nfloat calcSSS( in vec3 pos, in vec3 lig ) {\n    float sss = 0.0;\n    float sca = 1.0;\n    for( int i = 0; i < 4; i++ ) {\n        float delta = 0.01 + 0.03 * float( i );\n        vec3 sspos = pos + lig * delta;\n        float dist = map( sspos ).x;\n        sss += -( dist - delta ) * sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 4.0*sss, 0.0, 1.0 );\n}\n\n\/\/ ________\n\/\/ |||||||| rendering <_______________________________________________________________\nvec3 render( vec3 ro, vec3 rd ) {\n    vec3 color = vec3( 0.0 );\n    \n    vec2 res = castRay( ro, rd );\n    float dist = res.x;\n\tfloat material = res.y;\n    vec3 pos = ro + rd * dist;\n    \n    vec3 lightDir = normalize( vec3( 0.93, 0.5, 3.0 ) );\n    vec3 lightColor = vec3( 1.0, 0.942, 0.77 );\n    vec3 skyColor = getSkyColor( lightDir, rd );\n    vec3 ambientColor = vec3( 0.89, 0.021, 0.02 );\n    \n    if( dist > stopDelta )\n        return getSkyColor( lightDir, rd );\n    else {\n    \tvec3 nor = calcNormal( pos, 0.001);\n    \n    \tfloat dif = clamp( dot( nor, lightDir ), 0.0, 1.0 ), dif2;\n    \tfloat spe = pow( clamp( dot( reflect( -lightDir, nor ), -rd ), 0.0, 1.0 ), 10.0 );\n    \tfloat amb = 1.0;\n    \tfloat fre = pow( clamp( 1.0 + dot( nor, rd ), 0.0, 1.0 ), 5.0 );\n        \n        vec3 brdf = vec3( 0.0 );\n        \n        if( material - MATERIAL_01 < 0.5 ) { \/\/ MATERIAL : space station\n            color = vec3( 0.27, 0.25, 0.34 ) * 0.4;\n            \/\/dif *= calcSoftShadow( pos, lightDir, 0.1, 10.0, 4 );\n            \n            brdf += 1.2 * dif * lightColor; \/\/ lambert\n    \t\tbrdf += 1.2 * spe * lightColor * dif; \/\/ blinn phong\n    \t\tbrdf += 0.1 * amb * ambientColor; \/\/ ambient\n    \t\tbrdf += 1.0 * fre * lightColor; \/\/ fresnel schlick\n            \n            color *= brdf;\n            color = mix( color, vec3( 0.89, 0.021, 0.02 ) * 100.0 \/ dist, getFog( dist ) ); \/\/ fog\n        }\n        \n        else if( material - MATERIAL_02 < 0.5 ) { \/\/ MATERIAL : planet            \n            float n = fbm( pos, vec3( 2.0, 10.0, 2.0 ) * 0.0006, vec3( -6.0 ) );\n            n += 0.5 * fbm( vec3( n * pos.x, pos.y, n * pos.z ) * 0.0006, vec3( 5.0 ), vec3( 0.0 ) );\n            \n            color = vec3( n * n );\n            nor = calcNormal( pos, 0.01);\n            vec3 pll = vec3( -1.0, 0.5, 2.5 ); \/\/ planet light\n            float dif2 = clamp( dot( nor, pll ), 0.0, 1.0 );\n            fre += mix( fre, 0.7, step( 0.25, fre ) );\n            \n            brdf += 1.45 * dif2 * lightColor; \/\/ lambert\n    \t\tbrdf += 1.9 * spe * lightColor * dif; \/\/ blinn phong\n    \t\tbrdf += 0.2 * amb * ambientColor; \/\/ ambient\n    \t\tbrdf += 1.4 * fre * vec3( 0.5, 1.0, 0.8 ) * lightColor; \/\/ fresnel schlick\n            \n            color *= brdf;\n        }\n        \n        else if( material - MATERIAL_03 < 0.5 ) { \/\/ MATERIAL : cockpit\n            color = vec3( 0.08 );\n            vec3 cpl = vec3( 0.0, -1.0, -0.5 ); \/\/ cockpit light\n            float dif2 = clamp( dot( nor, cpl ), 0.0, 1.0 );\n            float occ = calcAO( pos, nor );\n            #ifdef SHADOWS\n            dif *= calcSoftShadow( pos, lightDir, 0.02, 1.0, 8 );\n            #endif\n            \n            brdf += 1.9 * dif * lightColor; \/\/ lambert\n    \t\tbrdf += 1.5 * spe * ambientColor * dif; \/\/ blinn phong\n    \t\tbrdf += 0.2 * amb * ambientColor * occ; \/\/ ambient\n    \t\tbrdf += 0.3 * fre * ambientColor * occ; \/\/ fresnel schlick\n            brdf += 0.6 * dif2 * ambientColor; \/\/ lambert\n            \n            color *= brdf;\n        }\n        \n        else if( material - MATERIAL_04 < 0.5 ) { \/\/ MATERIAL : cockpit \/ buttons \/ yellow\n            color = vec3( 1.0, 0.9, 0.16 );\n            vec3 cpl = vec3( 0.0, -1.0, -0.5 ); \/\/ cockpit light direction\n            float dif2 = clamp( dot( nor, cpl ), 0.0, 1.0 );\n            \n            brdf += 0.2 * dif2 * lightColor; \/\/ lambert\n    \t\tbrdf += 1.0 * amb * ambientColor; \/\/ ambient\n            brdf += 0.15; \/\/ emission\n            \n            color *= brdf;\n        }\n        \n        else if( material - MATERIAL_05 < 0.5 ) { \/\/ MATERIAL : cockpit \/ monitors \/ orange\n            color = vec3( 0.5, 0.184, 0.184 );\n            vec3 cpl = vec3( 0.0, -1.0, -0.5 ); \/\/ cockpit light direction\n            float dif2 = clamp( dot( nor, cpl ), 0.0, 1.0 );\n            \n            brdf += 0.4 * dif2 * lightColor; \/\/ lambert\n    \t\tbrdf += 0.8 * amb * ambientColor; \/\/ ambient\n            brdf += 0.05; \/\/ emission\n            \n            color *= brdf;\n        }\n        \n        else if( material - MATERIAL_06 < 0.5 ) { \/\/ MATERIAL : cockpit \/ monitors \/ black\n            return vec3( 0.0 );\n        }\n        \n        else if( material - MATERIAL_07 < 0.5 ) { \/\/ MATERIAL : dark \/ metallic\n            color = vec3( 0.07, 0.07, 0.09 );\n            float sss = calcSSS( pos, lightDir );\n            \n            brdf += 1.3 * dif * lightColor; \/\/ lambert\n    \t\tbrdf += 1.3 * spe * ambientColor * dif; \/\/ blinn phong\n    \t\tbrdf += 0.5 * amb * ambientColor; \/\/ ambient\n    \t\tbrdf += 1.2 * fre * ambientColor; \/\/ fresnel schlick\n            brdf += 1.1 * sss * lightColor; \n            \n            color *= brdf;\n        }\n        \n        else { \/\/ DEFAULT MATERIAL\n            return vec3( 1.0, 0.0, 1.0 );\n        }\n    }\n    \n    \n    return color;\n}\n\n\/\/ ________\n\/\/ |||||||| camera\nmat3 getCameraMatrix( vec3 camFow ) {\n    vec3 forward = normalize( camFow );\n    vec3 up = normalize( vec3( 0.0, 1.0, 0.0 ) );\n    vec3 right = normalize( cross( up, forward ) );\n    \n    mat3 mat = mat3( right, up, forward );\n    \n    \/\/ shaky cam effect \/ mouse animation\n    mat = rotate(\n        mat,\n        vec3(\n            \/\/0.005 * PI * sin( iGlobalTime * 4.0 ) - ( iMouse.xy \/ iResolution.xy ).y * PI * 0.3,\n            0.002 * PI * sin( iGlobalTime * 2.0 ),\n            0.001 * PI * ( cos( iGlobalTime * 1.0 ) + sin( iGlobalTime * 1.0 ) ) - 0.2 * ( 2.0 * mouse.x - 1.0 ) * mouse.y,\n            0.0 * PI * cos( iGlobalTime*2.0 ) ) );\n    \n    return mat;\n}\n\nvoid mainImage( out vec4 o, in vec2 i ) {\n\tvec2 uv = i.xy \/ iResolution.xy;\n    vec2 pixel = uv * 2.0 - 1.0;\n    float viewRatio = iResolution.x \/ iResolution.y;\n    pixel.x *= viewRatio;\n    \n    float deltaRot = mouse.x * PI * 2.0;\n\n    \/\/vec3 camPos = vec3( -7.0 * cos( deltaRot ) - 2.0 * mouse.y, 0.0 + mouse.y * 6.0, -7.0 * sin( deltaRot ) - 2.0 * mouse.y );\n    \/\/vec3 camFow = vec3( 1.0 * cos( deltaRot ), 0.0, 1.0 * sin( deltaRot ) );\n    vec3 camPos = vec3( 0.0, 0.125, -1.0 );\n    vec3 camFow = vec3( 0.0, 0.0, 1.0 );\n    mat3 camMat = getCameraMatrix( camFow );\n    \n    vec3 rayDir = camMat * normalize( vec3( pixel, viewRatio + ( 0.5 * mouse.y - 0.1 ) ) );\n    \n    \/\/ scene\n    vec3 color = render( camPos, rayDir );\n    \n    \/\/ vignette\n    vec2 q = uv, c = q - 0.5;\n    q += length( c ) * c * 2.0;\n    float vig = 0.0 + 0.92 * clamp(\n        pow( 1.0 - 0.4 * length( ( q - vec2( 0.5, 0.25 ) ) * vec2( viewRatio * 0.5, 1.5 ) ), 1.1 ),\n        0.0, 1.0 );\n    vig *= 0.4 + pow( uv.x * uv.y * ( 1.0 - uv.x ) * ( 1.0 - uv.y ), 0.1 );\n    \n    color *= vig;\n    color *= vec3( 1.17, 0.51, 0.53 );\n    \n    o = vec4( toGamma( color ), 1.0 );\n}\n","name":"","description":"","type":"image"}]}}