{"Shader":{"ver":"0.1","info":{"id":"lsf3WH","date":"1368568313","viewed":3057,"name":"Noise - value - 2D","username":"iq","description":"Value Noise . It's cheap and produces blocky patterns (left), but it's good enough to generate fractal noise in most cases (right).","likes":34,"published":3,"flags":0,"tags":["procedural","2d","noise","perlin"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Value Noise (http:\/\/en.wikipedia.org\/wiki\/Value_noise), not to be confused with Perlin's\n\/\/ Noise, is probably the simplest way to generate noise (a random smooth signal with \n\/\/ mostly all its energy in the low frequencies) suitable for procedural texturing\/shading,\n\/\/ modeling and animation.\n\/\/\n\/\/ It produces lowe quality noise than Gradient Noise (https:\/\/www.shadertoy.com\/view\/XdXGW8)\n\/\/ but it is slightly faster to compute. When used in a fractal construction, the blockyness\n\/\/ of Value Noise gets qcuikly hidden, making it a very popular alternative to Gradient Noise.\n\/\/\n\/\/ The princpiple is to create a virtual grid\/latice all over the plane, and assign one\n\/\/ random value to every vertex in the grid. When querying\/requesting a noise value at\n\/\/ an arbitrary point in the plane, the grid cell in which the query is performed is\n\/\/ determined (line 30), the four vertices of the grid are determined and their random\n\/\/ value fetched (lines 35 to 38) and then bilinearly interpolated (lines 35 to 38 again)\n\/\/ with a smooth interpolant (line 31 and 33).\n\n\nfloat hash( vec2 p )\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\n\t\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\/\/ -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy \/ iResolution.xy;\n\n\tvec2 uv = p*vec2(iResolution.x\/iResolution.y,1.0);\n\t\n\tfloat f = 0.0;\n\n    \/\/ left: value noise\t\n\tif( p.x<0.6 )\n\t{\n\t\tf = noise( 16.0*uv );\n\t}\n    \/\/ right: fractal noise (4 octaves)\n    else\t\n\t{\n\t\tuv *= 5.0;\n        mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\t\tf  = 0.5000*noise( uv ); uv = m*uv;\n\t\tf += 0.2500*noise( uv ); uv = m*uv;\n\t\tf += 0.1250*noise( uv ); uv = m*uv;\n\t\tf += 0.0625*noise( uv ); uv = m*uv;\n\t}\n\n\tf = 0.5 + 0.5*f;\n\t\n    f *= smoothstep( 0.0, 0.005, abs(p.x-0.6) );\t\n\t\n\tfragColor = vec4( f, f, f, 1.0 );\n}","name":"","description":"","type":"image"}]}}