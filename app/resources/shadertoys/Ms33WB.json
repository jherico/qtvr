{"Shader":{"ver":"0.1","info":{"id":"Ms33WB","date":"1452023671","viewed":324,"name":"Post process - SSAO","username":"reinder","description":"Demonstrating post process Screen Space Ambient Occlusion applied to a depth and normal map with the geometry of my shader <a href=\"https:\/\/www.shadertoy.com\/view\/MtsXzf\"  class=\"regular\" target=\"_blank\">[SIG15] Matrix Lobby Scene'<\/a>.","likes":11,"published":3,"flags":32,"tags":["screen","post","space","occlusion","ambient","ssaa","process"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Reinder Nijhoff 2016\n\/\/ @reindernijhoff\n\/\/\n\/\/ https:\/\/www.shadertoy.com\/view\/ls3GWS\n\/\/\n\/\/\n\/\/ demonstrating post process Screen Space Ambient Occlusion applied to a depth and normal map\n\/\/ with the geometry of my shader '[SIG15] Matrix Lobby Scene': \n\/\/\n\/\/ https:\/\/www.shadertoy.com\/view\/MtsXzf\n\/\/\n\n\n#define SAMPLES 16\n#define INTENSITY 1.\n#define SCALE 2.5\n#define BIAS 0.05\n#define SAMPLE_RAD 0.02\n#define MAX_DISTANCE 0.07\n\n#define MOD3 vec3(.1031,.11369,.13787)\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\nvec3 getPosition(vec2 uv) {\n    float fl = texture2D(iChannel0, vec2(0.)).x; \n    float d = texture2D(iChannel0, uv).w;\n       \n    vec2 p = uv*2.-1.;\n    mat3 ca = mat3(1.,0.,0.,0.,1.,0.,0.,0.,-1.\/1.5);\n    vec3 rd = normalize( ca * vec3(p,fl) );\n    \n\tvec3 pos = rd * d;\n    return pos;\n}\n\nvec3 getNormal(vec2 uv) {\n    return texture2D(iChannel0, uv).xyz;\n}\n\nvec2 getRandom(vec2 uv) {\n    return normalize(hash22(uv*126.1231) * 2. - 1.);\n}\n\n\nfloat doAmbientOcclusion(in vec2 tcoord,in vec2 uv, in vec3 p, in vec3 cnorm)\n{\n    vec3 diff = getPosition(tcoord + uv) - p;\n    float l = length(diff);\n    vec3 v = diff\/l;\n    float d = l*SCALE;\n    float ao = max(0.0,dot(cnorm,v)-BIAS)*(1.0\/(1.0+d));\n    ao *= smoothstep(MAX_DISTANCE,MAX_DISTANCE * 0.5, l);\n    return ao;\n\n}\n\nfloat spiralAO(vec2 uv, vec3 p, vec3 n, float rad)\n{\n    float goldenAngle = 2.4;\n    float ao = 0.;\n    float inv = 1. \/ float(SAMPLES);\n    float radius = 0.;\n\n    float rotatePhase = hash12( uv*100. ) * 6.28;\n    float rStep = inv * rad;\n    vec2 spiralUV;\n\n    for (int i = 0; i < SAMPLES; i++) {\n        spiralUV.x = sin(rotatePhase);\n        spiralUV.y = cos(rotatePhase);\n        radius += rStep;\n        ao += doAmbientOcclusion(uv, spiralUV * radius, p, n);\n        rotatePhase += goldenAngle;\n    }\n    ao *= inv;\n    return ao;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ letterbox\n    if( abs(2.*fragCoord.y-iResolution.y) > iResolution.x * 0.42 ) {\n        fragColor = vec4( 0., 0., 0., 1. );\n        return;\n    }\n    \n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n        \n    vec3 p = getPosition(uv);\n    vec3 n = getNormal(uv);\n\n    float ao = 0.;\n    float rad = SAMPLE_RAD\/p.z;\n\n    ao = spiralAO(uv, p, n, rad);\n\n    ao = 1. - ao * INTENSITY;\n    \n\tfragColor = vec4(ao,ao,ao,1.);\n}","name":"","description":"","type":"image"},{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Reinder Nijhoff 2016\n\/\/ @reindernijhoff\n\/\/\n\/\/ https:\/\/www.shadertoy.com\/view\/ls3GWS\n\/\/\n\/\/\n\/\/ demonstrating post process Screen Space Ambient Occlusion applied to a depth and normal map\n\/\/ with the geometry of my shader '[SIG15] Matrix Lobby Scene': \n\/\/\n\/\/ https:\/\/www.shadertoy.com\/view\/MtsXzf\n\/\/\n\n\n#define HIGHQUALITY 1\n\n#define MARCHSTEPS 120\n\n#define BPM             (140.0)\n#define STEP            (4.0 * BPM \/ 60.0)\n#define ISTEP           (1.\/STEP)\n#define STT(t)\t\t\t(t*(60.0\/BPM))\n\nfloat damageMod;\n\n\/\/-----------------------------------------------------\n\/\/ noise functions\n\n#define MOD2 vec2(.16632,.17369)\nfloat hash(float p) { \/\/ by Dave Hoskins\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);\n}\n\nfloat noise( const in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D( iChannel0, (uv+ 0.5)\/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat noise( const in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn texture2D( iChannel0, (uv+118.4)\/256.0, -100.0 ).x;\n}\n\n\/\/-----------------------------------------------------\n\/\/ intersection functions\n\nvec3 nSphere( in vec3 pos, in vec4 sph ) {\n    return (pos-sph.xyz)\/sph.w;\n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.;\n\treturn -b - sqrt( h );\n}\n\n\/\/----------------------------------------------------------------------\n\/\/ distance primitives\n\nfloat sdBox( const in vec3 p, const in vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdColumn( const in vec3 p, const in vec2 b ) {\n    vec2 d = abs(p.xz) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\/\/----------------------------------------------------------------------\n\/\/ distance operators\n\nfloat opU( float d2, float d1 ) { return min( d1,d2); }\nfloat opS( float d2, float d1 ) { return max(-d1,d2); }\n    \n\/\/--------------------------------------------\n\/\/ map\n\nfloat tileId( const in vec3 p, const in vec3 nor ) { \n    if( abs(nor.y) > .9 ) return 0.;\n    \n    float x, y;\n    if( abs(nor.z) < abs(nor.x)) {\n        x = p.z-6.;\n    } else {\n        x = abs(p.x)-16.;\n    }\n    if( p.y < 2.5 ) {\n    \treturn floor( x \/ 3.6 ) * sign(p.x);\n    }\n    return floor( x \/ 1.8 ) * sign(p.x) * (floor( (p.y+7.5) \/ 5. ));\n}\n\n\nvec3 bumpMapNormal( const in vec3 pos, in vec3 nor ) {\n    float i = tileId( pos, nor );\n    if( i > 0. ) {\n        nor+= 0.0125 * vec3( hash(i), hash(i+5.), hash(i+13.) );\n        nor = normalize( nor );\n    }\n    return nor;\n}\n\nfloat map( const in vec3 p ) {\n    float d = -sdBox( p, vec3( 28., 14., 63. ) );\n\n    vec3 pm = vec3( abs( p.x ) - 17.8, p.y, mod( p.z, 12.6 ) - 6.);    \n    vec3 pm2 = abs(p) - vec3( 14., 25.25, 0. );\n    vec3 pm3 = abs(p) - vec3( 6.8, 0., 56.4 );      \n\n    d = opU( d, sdColumn( pm, vec2( 1.8, 1.8 ) ) );        \n    d = opS( d, sdBox( p,  vec3( 2.5, 9.5, 74. ) ) );    \n    d = opS( d, sdBox( p,  vec3( 5., 18., 73. ) ) );\n    d = opS( d, sdBox( p,  vec3( 13.8, 14.88, 63. ) ) );\n    d = opS( d, sdBox( p,  vec3( 13.2, 25., 63. ) ) );\n    d = opS( d, sdColumn( p,  vec2( 9.5, 63. ) ) ); \n    d = opU( d, sdColumn( pm3, vec2( 1.8, 1.8 ) ) );\n    d = opU( d, sdBox( pm2, vec3( 5., .45, 200. ) ) );\n    \n    return d;\n}\n\nfloat mapDamage( vec3 p ) {\n    float d = map( p );\n\n    float n = max( max( 1.-abs(p.z*.01), 0. )*\n                   max( 1.-abs(p.y*.2-1.2), 0. ) *\n                   noise( p*.3 )* (noise( p*2.3 ) +.2 )-.2 - damageMod, 0.);\n   \n\treturn d + n;\n}\n\nfloat mapDamageHigh( vec3 p ) {\n    float d = map( p );\n    \n    float p1 = noise( p*2.3 );\n    float p2 = noise( p*5.3 );\n    \n    float n = max( max( 1.-abs(p.z*.01), 0. )*\n                   max( 1.-abs(p.y*.2-1.2), 0. ) *\n                   noise( p*.3 )* (p1 +.2 )-.2 - damageMod, 0.);\n    \n    if( p.y < .1 ) {\n        n += max(.1*(1.-abs(d)+7.*noise( p*.7 )+.9*p1+.5*p2)-4.5*damageMod,0.);\n    }\n    \n    if( abs(n) > 0.0 ) {\n        n += noise( p*11.) * .05;\n        n += noise( p*23.) * .03;\n    }\n    \n\treturn d + n;\n}\n\n\nvec3 calcNormalDamage( in vec3 pos, in float eps ) {\n    if( pos.y < 0.001 && (mapDamageHigh(pos)-map(pos)) < eps ) {   \t\t\n\t        return vec3( 0., 1., 0. );\n    }\n    \n    vec2 e = vec2(1.0,-1.0)*(0.5773*eps);\n    vec3 n =  normalize( e.xyy*mapDamageHigh( pos + e.xyy ) + \n\t\t\t     \t\t e.yyx*mapDamageHigh( pos + e.yyx ) + \n\t\t\t\t\t  \t e.yxy*mapDamageHigh( pos + e.yxy ) + \n\t\t\t\t\t  \t e.xxx*mapDamageHigh( pos + e.xxx ) );\n    n = bumpMapNormal( pos, n );\n    return n;    \n}\n\n\/\/----------------------------------------------------------------------\n\/\/ intersection code\n\nfloat intersect( in vec3 ro, in vec3 rd ) {\n\tconst float precis = 0.00125;\n    float h = precis*2.0;\n    float t = 0.1;\n        \n    float d = -(ro.y)\/rd.y;\n    float maxdist = d>0.?d:500.;\n    \n\tfor( int i=0; i < MARCHSTEPS; i++ ) {\n#if HIGHQUALITY\n        h = .8*mapDamage( ro+rd*t );\n#else\n        h = map( ro+rd*t );\n#endif\n        if( h < precis ) {\n            return t;\n        } \n        t += h+0.00005*t;\n        if( t > maxdist ) {\n            return maxdist;\n        }\n    }\n    return -1.;\n}\n\n\nvec4 render( const in vec3 ro, const in vec3 rd, in float time, const in float fog, const in vec3 grd ) {\n    const float eps = 0.01;\n    vec2 col = vec2(0.);\n    \n    float t = intersect( ro, rd );\n    if( time > STT(98.) ) {\n        time = STT(95.5)+.4*(time-STT(95.5)); \/\/ slow motion\n    }\n    time += .03*hash( rd.x + rd.y*5341.1231 ); \/\/ motionblur\n    \n    vec3 nor;\n    \n    if( t > 0. ) {\n        float m = 0.;\n   \n        vec3 pos = ro + t*rd;\n        if( m < .5 ) {\n\t        nor = calcNormalDamage( pos, eps );\n        }\n    } else {\n        t = 60.;\n    }        \n    return vec4(nor, max(t\/60.,0.));\n}\n\n\/\/----------------------------------------------------------------------\n\/\/ camera\n\nmat3 setCamera( const in vec3 ro, const in vec3 rt, const in float cr, const in float fl ) {\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -fl*cw );\n}\n\n#define SCAM(a,j,h,i,f,g,b,c,d,e) if(time >= t ){damageMod=j;sro=b;ero=c;sta=d;eta=e;st=t;dt=a;sfog=h;efog=i;}t+=a;\n#define CCAM(a,j,h,i,f,g,b,c,d,e) if(time >= t ){sro=ero;ero=c;sta=eta;eta=e;st=t;dt=a;sfog=efog;efog=i;}t+=a;\n\nvoid getCamPath( const in float time, inout vec3 ro, inout vec3 ta, inout float fl, inout float fog ) {\n    vec3 sro, sta, ero, eta;\n    float st = 0., dt, t = 0., sfog, efog;\n    \n    SCAM(STT(12.), 0., 0.,    0., 1.5, 1.5, vec3( 0., 5., 22.5 ), vec3( 0., 5.,  18.5 ), vec3( 0., 5., 0. ), vec3( 0., 5., 0. ) ); \n    SCAM(STT(7.5), 0., 0.,    0., 1.5, 1.5, vec3( -14., 5.,  18.5 ), vec3( 18., 4., 11. ), vec3( 10., 5., -50. ), vec3( 0., 5., -50. ) ); \n    CCAM(STT(7.5), 0., 0.,  0.05, 1.5, 1.5, vec3( 18., 4., 11. ), vec3( 21.5, 4., 11.5 ),  vec3( 0., 5., -50. ), vec3( -4., 7., 0. ) ); \n    CCAM(STT(2.5), 0., 0.05, 0.1, 1.5, 1.5, vec3( 21.5, 4., 11.5 ), vec3( 21.5, 4., 11.5 ),  vec3( -4., 7., 0. ), vec3( -16., 7., 8. ) ); \n    CCAM(STT(4.), 0.,  0.1, 0.15, 1.5, 4.5, vec3( 21.5, 4., 11.5 ), vec3( 10., 4.25, 11.35 ),  vec3( -16., 7., 8. ), vec3( -16., 6., 8. ) ); \n    \n    SCAM(STT(7.5),  0., 0.1,  0.3, 1.5, 1.5, vec3( -11., 5.25, 7.05 ), vec3( -13., 5., 9. ),  vec3( -19., 5.2, 7. ), vec3( -16.5, 5., 5.3 ) );     \n    SCAM(STT(13.), .4, 0.1,  0.5, 1.5, 1.5, vec3( -18., 5., 4.05 ), vec3( -10., 5.25, -6. ),  vec3( -17., 5.5, 0. ), vec3( -15.5, 5.25, -7.3 ) );     \n\tCCAM(STT(4.), .45, 0.5,  0.65, 1.5, 1.2, vec3( -10., 5.25, -6. ), vec3( -12., 5.25, -9. ),  vec3( -15.5, 5.25, -7.3 ), vec3( -13.5, 6.25, 2.3 ) );     \n\n    SCAM(STT(7.5), .95, 0.4,  1.9, 1.5, 1.5, vec3( 18., 4., 11. ), vec3( 25.5, 4., 11.5 ),  vec3( 0., 5., -50. ), vec3( -4., 7., 0. ) ); \n\n    SCAM(STT(12.2), .95, 0.8,  1.3, 1.5, 1.5, vec3( 10., 4.7, 4. ), vec3( 10., 5., -7.5 ),  vec3( 50., 5., 2. ), vec3( 40., 5., -20. ) ); \n    \n    SCAM(STT(16.25), 1., 0.4,  0.8, 1.5, 1.5, vec3( -18., 4.5, 4.05 ), vec3( -26., 3.25, -6. ),  vec3( -17., 5.5, 0. ), vec3( -15.5, 6.25, -7.3 ) );     \n    CCAM(STT(4.),  1., 0.8,  0.6, 1.5, 1.5, vec3( -26., 3.25, -6. ), vec3( -26., 3.25, -6. ),  vec3( -15.5, 6.25, -7.3 ), vec3( -15.5, 6.25, -7.3 ) );     \n\n    SCAM(STT(16.), 1.1, 0.4, 0.05, 1.5, 1.5, vec3( 0., 5.,  18.5 ), vec3( 0., 5.,  18.5 ), vec3( 0., 5., 0. ), vec3( 0., 5., 0. ) ); \n  \n    dt = clamp( (time-st)\/dt, 0., 1. );\n\n    if(  time > STT(65.5) && time < STT(77.75)  ) {\n\t    ro = mix( sro, ero, dt);\n    \tta = mix( sta, eta, dt);\n    } else {\n\t    ro = mix( sro, ero, smoothstep(0.,1., dt));\n    \tta = mix( sta, eta, smoothstep(0.,1., dt));\n    }\n\t\n    fl = 1.5;    \n    if( time > STT(29.5) && time < STT(33.5) ) {\n        fl = mix( 1.5, 4.5, smoothstep( STT(29.5), STT(33.5), time ) );\n    }\n    \n   \tfog = mix( sfog, efog, dt);\n    damageMod = .4-.4*damageMod;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = mod(iGlobalTime, 60.);\n\n    vec2 q = fragCoord.xy\/iResolution.xy;\n\t \n    vec3 ro, ta;\n    float fl, fog;\n      \n    getCamPath( time, ro, ta, fl, fog );\n    \n    if( dot(fragCoord.xy, fragCoord.xy) < 10. ) {\n\t   fragColor = vec4( fl );\n       return;\n    }\n        \n    mat3 ca = setCamera( ro, ta, 0.0, (1.\/1.5) );    \n    vec2 p = (-iResolution.xy+2.*(fragCoord.xy))\/iResolution.x;\n    vec3 rd = normalize( ca * vec3(p,-fl) );\n\n    vec4 r = render( ro, rd, time, fog, normalize( ta-ro ) ); \n    fragColor = vec4( ((r.xyz * ca)).xyz,  r.w );\n}\n","name":"","description":"","type":"buffer"}]}}