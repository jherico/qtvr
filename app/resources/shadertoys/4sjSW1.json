{"Shader":{"ver":"0.1","info":{"id":"4sjSW1","date":"1411505248","viewed":7232,"name":"Remnant X","username":"Dave_Hoskins","description":"Binary subdivision finds the surface really well with this fractal. Two light sources with shadows, and near surface glows.<br\/>MOUSE X TO TIME WARP<br\/><a href=\"https:\/\/www.youtube.com\/watch?v=BjkK9fLXXo0\" class=\"regular\" target=\"_blank\">https:\/\/www.youtube.com\/watch?v=BjkK9fLXXo0<\/a>","likes":106,"published":3,"flags":8,"tags":["3d","raymarching","fractal","sound","music","remnantx"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Remnant X\n\/\/ by David Hoskins.\n\/\/ Thanks to boxplorer and the folks at 'Fractalforums.com'\n\/\/ HD Video:- https:\/\/www.youtube.com\/watch?v=BjkK9fLXXo0\n\n\/\/ #define STEREO\n\nvec3 sunDir  = normalize( vec3(  0.35, 0.1,  0.3 ) );\nconst vec3 sunColour = vec3(1.0, .95, .8);\n\n\n#define SCALE 2.8\n#define MINRAD2 .25\nfloat minRad2 = clamp(MINRAD2, 1.0e-9, 1.0);\nvec4 scale = vec4(SCALE, SCALE, SCALE, abs(SCALE)) \/ minRad2;\nfloat absScalem1 = abs(SCALE - 1.0);\nfloat AbsScaleRaisedTo1mIters = pow(abs(SCALE), float(1-10));\nvec3 surfaceColour1 = vec3(.8, .0, 0.);\nvec3 surfaceColour2 = vec3(.4, .4, 0.5);\nvec3 surfaceColour3 = vec3(.5, 0.3, 0.00);\nvec3 fogCol = vec3(0.4, 0.4, 0.4);\nfloat gTime;\n\n\n\/\/----------------------------------------------------------------------------------------\nfloat Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D( iChannel0, (uv+ 0.5)\/256.0, -99.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat Map(vec3 pos) \n{\n\t\/\/return (length(pos)-4.0);\n\n\tvec4 p = vec4(pos,1);\n\tvec4 p0 = p;  \/\/ p.w is the distance estimate\n\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tp.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;\n\n\t\t\/\/ sphere folding: if (r2 < minRad2) p \/= minRad2; else if (r2 < 1.0) p \/= r2;\n\t\tfloat r2 = dot(p.xyz, p.xyz);\n\t\tp *= clamp(max(minRad2\/r2, minRad2), 0.0, 1.0);\n\n\t\t\/\/ scale, translate\n\t\tp = p*scale + p0;\n\t}\n\treturn ((length(p.xyz) - absScalem1) \/ p.w - AbsScaleRaisedTo1mIters);\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 Colour(vec3 pos, float sphereR) \n{\n\t\/\/scale.z = 0.0;\n\tvec3 p = pos;\n\tvec3 p0 = p;\n\tfloat trap = 1.0;\n    \n\tfor (int i = 0; i < 6; i++)\n\t{\n        \n\t\tp.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;\n\t\tfloat r2 = dot(p.xyz, p.xyz);\n\t\tp *= clamp(max(minRad2\/r2, minRad2), 0.0, 1.0);\n\n\t\tp = p*scale.xyz + p0.xyz;\n\t\ttrap = min(trap, r2);\n\t}\n\t\/\/ |c.x|: log final distance (fractional iteration count)\n\t\/\/ |c.y|: spherical orbit trap at (0,0,0)\n\tvec2 c = clamp(vec2( 0.3333*log(dot(p,p))-1.0, sqrt(trap) ), 0.0, 1.0);\n\n    float t = mod(length(pos) - gTime*150., 16.0);\n    surfaceColour1 = mix( surfaceColour1, vec3(.4, 3.0, 5.), pow(smoothstep(0.0, .3, t) * smoothstep(0.6, .3, t), 10.0));\n\treturn mix(mix(surfaceColour1, surfaceColour2, c.y), surfaceColour3, c.x);\n}\n\n\n\/\/----------------------------------------------------------------------------------------\nvec3 GetNormal(vec3 pos, float distance)\n{\n\tvec2 eps = vec2(distance, 0.0);\n\tvec3 nor = vec3(\n\t    Map(pos+eps.xyy) - Map(pos-eps.xyy),\n\t    Map(pos+eps.yxy) - Map(pos-eps.yxy),\n\t    Map(pos+eps.yyx) - Map(pos-eps.yyx));\n\treturn normalize(nor);\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat GetSky(vec3 pos)\n{\n    pos *= 2.3;\n\tfloat t = Noise(pos);\n    t += Noise(pos * 2.1) * .5;\n    t += Noise(pos * 4.3) * .25;\n    t += Noise(pos * 7.9) * .125;\n\treturn t;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat BinarySubdivision(in vec3 rO, in vec3 rD, vec2 t)\n{\n    for (int i = 0; i < 4; i++)\n    {\n     \tfloat halfwayT = (t.y + t.x ) * .5;\n\t\tMap(rO + halfwayT*rD) < .001 ? t.x = halfwayT : t.y = halfwayT;\n    }\n\t\t\n\/\/\tMap(rO + halfwayT*rD) < .001 ?  t.x = halfwayT : t.y = halfwayT;\n\/\/\thalfwayT = (t.y + t.x ) * .5;\n\/\/\tMap(rO + halfwayT*rD) < .001 ?  t.x = halfwayT : t.y = halfwayT;\n\/\/\/\thalfwayT = (t.y + t.x ) * .5;\n\/\/\tMap(rO + halfwayT*rD) < .001 ?  t.x = halfwayT : t.y = halfwayT;\n\treturn (t.y + t.x) * .5;;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec2 Scene(in vec3 rO, in vec3 rD, in vec2 fragCoord)\n{\n\tfloat t = .05 + 0.05 * texture2D(iChannel0, fragCoord.xy \/ iChannelResolution[0].xy).y;\n\tvec3 p = vec3(0.0);\n    float oldT = 0.0;\n    bool hit = false;\n    float glow = 0.0;\n    vec2 dist;\n\tfor( int j=0; j < 70; j++ )\n\t{\n\t\tif (t > 12.0) break;\n        p = rO + t*rD;\n       \n\t\tfloat h = Map(p);\n        \n\t\tif( h <0.001)\n\t\t{\n            dist = vec2(t, oldT);\n            hit = true;\n            break;\n        }\n        else\n        {\n        \tglow += clamp(.05-h, 0.0, .4);\n        \tt +=  h + t*0.001;\n\t        oldT = t;\n        }\n \t}\n    if (!hit)\n        t = 1000.0;\n    else\n        t = BinarySubdivision(rO, rD, dist);\n    return vec2(t, clamp(glow*.25, 0.0, 1.0));\n\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat Hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 33758.5453)-.5;\n} \n\n\/\/----------------------------------------------------------------------------------------\nvec3 PostEffects(vec3 rgb, vec2 xy)\n{\n\t\/\/ Gamma first...\n\trgb = pow(rgb, vec3(0.47));\n\n\t\/\/ Then...\n\t#define CONTRAST 1.4\n\t#define SATURATION 1.4\n\t#define BRIGHTNESS 1.2\n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\n\t\/\/ Noise...\n\t\/\/rgb = clamp(rgb+Hash(xy*iGlobalTime)*.1, 0.0, 1.0);\n\t\/\/ Vignette...\n\trgb *= .5 + 0.5*pow(20.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.2);\t\n\n\treturn rgb;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat Shadow( in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 0.05;\n\tfloat h;\n\t\n    for (int i = 0; i < 8; i++)\n\t{\n\t\th = Map( ro + rd*t );\n\t\tres = min(6.0*h \/ t, res);\n\t\tt += h;\n\t}\n    return max(res, 0.0);\n}\n\n\/\/----------------------------------------------------------------------------------------\nmat3 RotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 LightSource(vec3 spotLight, vec3 dir, float dis)\n{\n    float g = 0.0;\n    if (length(spotLight) < dis)\n    {\n\t\tg = pow(max(dot(normalize(spotLight), dir), 0.0), 600.0) * 1.5;\n    }\n   \n    return vec3(1.0) * g;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 CameraPath( float t )\n{\n    vec3 p = vec3(-.81 + 3. * sin(2.14*t),.05+2.5 * sin(.942*t+1.3),.05 + 3.5 * cos(3.594*t) );\n\treturn p;\n} \n    \n\/\/----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat m = (iMouse.x\/iResolution.x)*300.0;\n\tgTime = (iGlobalTime+m)*.01 + 15.00;\n    vec2 xy = fragCoord.xy \/ iResolution.xy;\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x\/iResolution.y, 1.0);\n\t\n\t\n\t#ifdef STEREO\n\tfloat isRed = mod(fragCoord.x + mod(fragCoord.y, 2.0),2.0);\n\t#endif\n\n\tvec3 cameraPos\t= CameraPath(gTime);\n    vec3 camTar\t\t= CameraPath(gTime + .01);\n\n\tfloat roll = 3.0*gTime;\n\tvec3 cw = normalize(camTar-cameraPos);\n\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\n\tvec3 cv = normalize(cross(cu,cw));\n    cw = RotationMatrix(cv, sin(-gTime*20.0)*.7) * cw;\n\tvec3 dir = normalize(uv.x*cu + uv.y*cv + 1.3*cw);\n\tmat3 camMat = mat3(cu, cv, cw);\n\n\t#ifdef STEREO\n\tcameraPos += .008*cu*isRed; \/\/ move camera to the right\n\t#endif\n\n    vec3 spotLight = CameraPath(gTime + .03) + vec3(sin(gTime*18.4), cos(gTime*17.98), sin(gTime * 22.53))*.2;\n\tvec3 col = vec3(0.0);\n    vec3 sky = vec3(0.03, .04, .05) * GetSky(dir);\n\tvec2 ret = Scene(cameraPos, dir,fragCoord);\n    \n    if (ret.x < 900.0)\n    {\n\t\tvec3 p = cameraPos + ret.x*dir; \n\t\tvec3 nor = GetNormal(p, ret.x*ret.x*.002+.0005);\n        \n       \tvec3 spot = spotLight - p;\n\t\tfloat atten = length(spot);\n\n        spot \/= atten;\n        \n        float shaSpot = Shadow(p, spot);\n        float shaSun = Shadow(p, sunDir);\n        \n       \tfloat bri = max(dot(spot, nor), 0.0) \/ pow(atten, 1.5) * .15;\n        float briSun = max(dot(sunDir, nor), 0.0) * .3;\n        \n       col = Colour(p, ret.x);\n       col = (col * bri * shaSpot) + (col * briSun* shaSun);\n        \n       vec3 ref = reflect(dir, nor);\n       col += pow(max(dot(spot,  ref), 0.0), 10.0) * 2.0 * shaSpot * bri;\n       col += pow(max(dot(sunDir, ref), 0.0), 10.0) * 2.0 * shaSun  * bri;\n    }\n    col += vec3(pow(abs(ret.y), 2.)) * vec3(.1, .15, .25);\n    col = mix(sky, col, min(exp(-ret.x+1.5), 1.0));\n \n\tcol = PostEffects(col, xy);\t\n    col += LightSource(spotLight-cameraPos, dir, ret.x);\n\t\n\t#ifdef STEREO\t\n\tcol *= vec3( isRed, 1.0-isRed, 1.0-isRed );\t\n\t#endif\n\t\n\tfragColor=vec4(col,1.0);\n}\n\n\/\/--------------------------------------------------------------------------","name":"","description":"","type":"image"},{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Remnant X\n\/\/ by David Hoskins.\n\n#define TAU  6.28318530718\n\nfloat n1 = 0.0;\nfloat n2 = 0.0;\nfloat n3 = 0.0;\nfloat n4 = 0.0;\nfloat fb_lp = 0.0;\nfloat fb_hp = 0.0;\nfloat hp = 0.0;\nfloat p4=1.0e-24;\n\nfloat gTime;\nfloat beat;\n\n\n#define N(a, b) if(t > a){x = a; n = b;}\n#define K(a) if(t > a) x = a;\n#define BRING_IN\n\nfloat sample = 1.0 \/ iSampleRate;\n\n\/\/ Low pass resonant filter...\nfloat Filter(float inp, float cut_lp, float res_lp)\n{\n\tfb_lp \t= res_lp+res_lp\/(1.0-cut_lp + 1e-20);\n\tn1 \t\t= n1+cut_lp*(inp-n1+fb_lp*(n1-n2))+p4;\n\tn2\t\t= n2+cut_lp*(n1-n2);\n    return n2;\n}\n\n\/\/----------------------------------------------------------------------------------\nfloat Tract(float x, float f, float bandwidth)\n{\n    float ret = sin(TAU * f * x) * exp(-bandwidth * 2.14159265359 * x);\n    return ret;\n}\n\n\/\/----------------------------------------------------------------------------------\nfloat Hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 3.4337) * .5;\n}\n\n\/\/----------------------------------------------------------------------------------\nfloat Noise(float time, float pitch)\n{\n    float ret = Hash(floor(time * pitch));\n\treturn ret;\n}\n\n\/\/----------------------------------------------------------------------------------\nfloat noteMIDI(float n)\n{\n\treturn 440.0 * pow(2.0, (n - 69.0) \/ 12.0);\n}\n\n\/\/----------------------------------------------------------------------------------\nfloat Saw(float time, float pitch)\n{\n    float f1 = fract(time * pitch);\n    float f2 = fract(time * pitch * .99);\n    float f3 = fract(time * pitch * 2.01);\n    return (f1+f2+f3) \/ 1.5 - 1.0;\n}\n\n\n\/\/----------------------------------------------------------------------------------\nfloat Kick()\n{\n    #ifdef BRING_IN\n    if (beat < 24.0) return 0.0;\n    #endif\n    float x = 0.0;\n    float t = mod(beat, 8.0);\n    \n    K(0.0);\n    K(0.5);\n    K(4.0);\n    K(6.0);\n    K(7.5);\n    \n    t = t-x;\n    float vol = exp(-t*.5);\n    \n    float kick = sin(t*220.0* exp(-t* .75));\n    \n    kick = (1.5 * kick - 0.5 * kick * kick * kick);\n    \n    \n    return kick * vol * .4;\/\/ * smoothstep(0.0, .3, t);\n}\n\n\/\/----------------------------------------------------------------------------------\nvec2 Cymbals()\n{\n\t#ifdef BRING_IN\n    if (beat < 31.0) return vec2(0.0);\n    #endif\n    \n    float x = 0.0;\n    float n = 0.0;\n    float t = mod(beat+.2, 8.0);\n\n    N(0.0, .2);\n    N(0.5, .5);\n    N(2.5, .75);\n    N(3.0, 1.0);\n    N(4.0, .2);\n    N(4.5, .7);\n    N(6.5, 1.0);\n    N(7.0, .6);\n    N(7.75, .8);\n    t = t-x;\n    \n    float vol = exp(-pow(abs(t), .4)*1.3) * .4 * n * smoothstep(0.0, .3, t);\n\tvec2 cym = vec2(Noise(t, 8000.0), Noise(t, 10000.0));\n   \n    return cym * vol;\n}\n\n\/\/----------------------------------------------------------------------------------\nfloat Snare()\n{\n    float x = 0.0;\n    float n = 0.0;\n    #ifdef BRING_IN\n    if (beat < 40.0) return 0.0;\n    #endif\n    float t = mod(beat, 16.0);\n    \n    N(1.0, 1.0);\n    N(3.0, 1.0);\n    N(3.25, .5);\n    N(5.0, 1.0);\n    N(5.25, .5);\n    N(7.0, 1.0);\n    N(7.25, .5);\n    N(7.5, 1.0);\n    \n    N(9.0, 1.0);\n    N(11.0, 1.0);\n    N(11.25, .5);\n    N(13.0, 1.0);\n    \n    N(13.5, .25);\n    N(13.75, .3);\n    N(14.0, .35);\n    N(14.25, .4);\n    N(14.5, .5);\n    N(14.75, .45);\n    N(15.0,  .7);\n    N(15.25, .6);\n    N(15.5,  1.0);\n    N(15.75, .8);\n\n    t = t-x;\n    \n    float vol = exp(-pow(abs(t), .7) * 1.5) * n * .3;\n    \n    float sna = sin(t * 487.0 * exp(-t*.2)) * .65;\n\tsna += Noise(t+mod(gTime, .521), 1400.0 * exp(-t*.2));    \n    \n    return sna * vol;\n}\n\n\/\/----------------------------------------------------------------------------------\nfloat Bass()\n{\n    float n;\n    float x = 0.0;\n    float t = mod(beat, 16.0);\n    \n    N(0.0, 36.0);\n    N(4.0, 35.0);\n    N(6.0, 34.0);\n    N(8.0, 33.0);\n\n    float p = noteMIDI(float(n));\n    t = t-x;\n    float vol = exp(-t*.25) * smoothstep(0.0, .05, t) * .5;\n    float saw = 0.0;\n    float low = (cos(beat*.15)+1.0) *.45 + .05;\n    float res = .7-(cos(t*2.)) *.2;\n\n    for (int i = 0; i < 80; i++)\n    {\n        float s = Saw(gTime-(float(i)* sample), p) * .7;\n        s += Noise(gTime-(float(i) * sample), p*16.0) *.3;\n        saw = Filter(s, low, res);\n    }\n    return saw*vol;\n}\n\n\/\/----------------------------------------------------------------------------------\nfloat Lead()\n{\n    float n;\n    float x = 0.0;\n    \n    #ifdef BRING_IN\n\tif (beat < 16.0) return 0.0;\n    #endif\n\n    float t = mod(beat+.15, 32.0);\n    \n    N(0.0, 58.0);\n    N(.5, 60.0);\n    N(2.0, 48.0);\n    N(4.0, 59.0);\n    N(6.0, 58.0);\n    N(8.0, 57.0);\n    \n    N(16.0, 58.0);\n    N(16.5, 60.0);\n    N(18.0, 48.0);\n    N(20.0, 59.0);\n    N(22.0, 60.0);\n    N(24.0, 64.0);\n\n    N(31.0, 54.0);\n    N(31.5, 56.0);\n\n    float p = noteMIDI(float(n));\n    t = t-x;\n    float vib = sin(TAU*5.0*gTime) * smoothstep(0.3, 2.0, t) * .001;\n    float vol = exp(-t*.3) * smoothstep(0.0, .4, t) * .05;\n    float t1 = 500.0  + sin(gTime*TAU*.312)*400.0;\n    float t2 = 1200.0 + sin(gTime*TAU*.13)*400.0;\n    \n    \/\/ Vocal tract simulating varying vowel sounds...\n\tfloat s = Tract(mod(gTime+vib, 1.0 \/ p), t1, 90.0);\n   \ts += Tract(mod(gTime+vib, 1.0 \/ p), t2, 120.0);\n   \ts += Tract(mod(gTime+vib, 1.0 \/ p), 2500.0, 160.0);\n    \/\/ Octave down harmony...\n  \ts += Tract(mod(gTime+vib, 2.0 \/ p), t1, 90.0);\n   \ts += Tract(mod(gTime+vib, 2.0 \/ p), t2, 120.0);\n   \ts += Tract(mod(gTime+vib, 2.0 \/ p), 2500.0, 160.0);\n\n    s+= (Noise(t, t1)+ Noise(t, t2))*.75;\n\n    return s * vol;\n}\n\n\/\/----------------------------------------------------------------------------------\nvec2 mainSound(float time)\n{\n\tgTime = time;\n\tbeat = time * 1.5;\n    \n   \tvec2 audio = vec2(0.0, 0.0);\n    \n    float b1 = Bass();\n    float b2 = -b1;\n    float kick = Kick();\n    float snare = Snare();\n    vec2 cymb = Cymbals();\n    float lead = Lead();\n    \n    audio = vec2(b1, b2);\n    audio += vec2(kick);\n    audio += vec2(snare);\n    audio += cymb;\n    audio += vec2(lead);\n    \n    return clamp(audio * 2. * smoothstep(60.0, 52.0, time) * smoothstep(0.0, 1.0, time), -1.0, 1.0);\n    \n    \/\/return vec2(0.0); \/\/ Disabled.\n}","name":"","description":"","type":"sound"}]}}