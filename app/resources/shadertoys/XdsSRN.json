{"Shader":{"ver":"0.1","info":{"id":"XdsSRN","date":"1397597044","viewed":1079,"name":"glsl bug ?","username":"FabriceNeyret2","description":"mouse to explore the field.<br\/><br\/>mod(x,y) is not always correct: sometimes it gives y !!! <br\/>Here is a small test code. none-grey pixels are abnormals. tiles=32x32","likes":2,"published":3,"flags":0,"tags":["bug"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ the hearth of the test is:\n\/\/\n\/\/\t  vec2  uv = fragCoord.xy;\n\/\/\t  float v  = mod(uv.x,uv.y);\n\/\/    if (v==uv.y)    fragColor = vec4(1.,0.,0.,1.) ;\n\/\/    else  \t\t  fragColor = .5*vec4(v\/uv.y); \nvec4 FragColor;\n\n\/\/ the safe mod function:\nfloat trueMod(float x, float y)  { \n\tfloat s; if (y>=0.) s=1.; else { x=-x; y=-y; s=-1.; } \n    float v = x - y*float(int(x)\/int(y)); \n    return (v>=0.) ? s*v : s*(v+y); \n}\n\n\/\/ --- key toggles -----------------------------------------------------\n\nbool keyToggle(int ascii) {\n\treturn (texture2D(iChannel2,vec2((.5+float(ascii))\/256.,0.75)).x > 0.);\n}\n\n\n\/\/ --- Digit display ----------------------------------------------------\n\n\/\/ all functions return true or seg number if something was drawn -> caller can then exit the shader.\n\n\/\/     ... adapted from Andre in https:\/\/www.shadertoy.com\/view\/MdfGzf\n\nfloat segment(vec2 uv, bool On) {\n\treturn (On) ?  (1.-smoothstep(0.08,0.09+float(On)*0.02,abs(uv.x)))*\n\t\t\t       (1.-smoothstep(0.46,0.47+float(On)*0.02,abs(uv.y)+abs(uv.x)))\n\t\t        : 0.;\n}\n\nfloat digit(vec2 uv,int num) {\n\tfloat seg= 0.;\n    seg += segment(uv.yx+vec2(-1., 0.),num!=-1 && num!=1 && num!=4                    );\n\tseg += segment(uv.xy+vec2(-.5,-.5),num!=-1 && num!=1 && num!=2 && num!=3 && num!=7);\n\tseg += segment(uv.xy+vec2( .5,-.5),num!=-1 && num!=5 && num!=6                    );\n   \tseg += segment(uv.yx+vec2( 0., 0.),num!=-1 && num!=0 && num!=1 && num!=7          );\n\tseg += segment(uv.xy+vec2(-.5, .5),num==0 || num==2 || num==6 || num==8           );\n\tseg += segment(uv.xy+vec2( .5, .5),num!=-1 && num!=2                              );\n    seg += segment(uv.yx+vec2( 1., 0.),num!=-1 && num!=1 && num!=4 && num!=7          );\t\n\treturn seg;\n}\n\nfloat showNum(vec2 uv,int nr, bool zeroTrim) { \/\/ nr: 2 digits + sgn . zeroTrim: trim leading \"0\"\n\tif (abs(uv.x)>2.*1.5 || abs(uv.y)>1.2) return 0.;\n\n\tif (nr<0) {\n\t\tnr = -nr;\n\t\tif (uv.x>1.5) {\n\t\t\tuv.x -= 2.;\n\t\t\treturn segment(uv.yx,true); \/\/ minus sign.\n\t\t}\n\t}\n\t\n\tif (uv.x>0.) {\n\t\tnr \/= 10; if (nr==0 && zeroTrim) nr = -1;\n\t\tuv -= vec2(.75,0.);\n\t} else {\n\t\tuv += vec2(.75,0.); \n\t\tnr = int(mod(float(nr),10.));\n\t}\n\n\treturn digit(uv,nr);\n}\n\/\/    ... end of digits adapted from Andre\n\n#define STEPX .875\n#define STEPY 1.5\nfloat _offset=0.; \/\/ auto-increment useful for successive \"display\" call\n\n\/\/ 2digit int + sign\nbool display(vec2 pos, vec2 uv, float scale, float offset, int number) {\n\/\/\tvec2 uv = fragCoord.xy\/iResolution.y;\n\tuv = (uv-pos)\/scale*2.; \n    uv.x = .5-uv.x + STEPX*offset;\n\tuv.y -= 1.;\n\t\n\tfloat seg = showNum(uv,number,false);\n\toffset += 2.;\n\t\n\tFragColor += vec4(0.,0.,seg,1.);  \/\/ change color here\n\t_offset = offset;\n\treturn (seg>0.);\n}\n\n\nbool isNan(float val)\n{  return (val <= 0.0 || 0.0 <= val) ? false : true; }\n\nbool isInf(float val)\n{  return (val+1. !=  val) ? false : true; }\n\nint myint(float x) { return int(x)-((x<0.)?1:0); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 mouse = 2.*iMouse.xy-iResolution.xy;\n\tif (iMouse.z <=0.) mouse = vec2(0.);\n\tvec2  uv   = floor(.5*fragCoord.xy)-5.*mouse.xy;\n\tfloat v;\n\tif (isInf((uv.x-uv.x)\/(uv.x-uv.x))) {FragColor = vec4(0.,1.,0.,1.) ; return; }\n#if 1\n\tv = mod(uv.x,uv.y);\n#else\n\/\/  v = mod(uv.x,uv.y-1e-4);               \/\/ correct up to 2048 , for x>0\n\/\/  v = uv.x - uv.y*floor(uv.x\/uv.y);      \/\/ same as mod(uv.x,uv.y)\n\/\/  v = uv.y*fract(uv.x\/uv.y);             \/\/ same as mod(uv.x,uv.y) - epsilon\n\/\/  v = uv.x - uv.y*float(int(uv.x\/uv.y)); \/\/ same as mod(uv.x,uv.y) \n\/\/  v = uv.x - uv.y*floor(uv.x\/uv.y+1e-6); \/\/ seems ~ok but for |x,y| < 740,32 \n\/\/\tif (uv.y<0.) uv = -uv;  v = uv.x - uv.y*float(int(uv.x)\/int(uv.y)); if (v<0.) v+=uv.y; \/\/ seems ok\n\tv = trueMod(uv.x, uv.y);\n\n#endif\n\tif      (isNan(v))   FragColor = vec4(0.,1.,0.,1.) ;\n\telse if (isInf(v))   FragColor = vec4(0.,.3,1.,1.) ;\n\telse if (v==uv.y)    FragColor = vec4(1.,0.,0.,1.) ;\n\telse if (abs(v)>abs(uv.y-.1))  FragColor = vec4(1.,.8,0.,1.) ;\n\telse  \t\t         FragColor = .5*vec4(v\/uv.y); \n\t\t\n    if ((mod(uv.x,32.)==0.) || (mod(uv.y,32.)==0.) )  FragColor.b = 1.;   \/\/ frame\n    display( 32.*floor(uv\/32.)+vec2(6.,10.), uv, 6., 0., int(floor(uv.x\/32.)));\t\t\n    display( 32.*floor(uv\/32.)+vec2(12.,2.), uv, 6., 0., int(floor(uv.y\/32.)));\t\n    fragColor = FragColor;\n}","name":"","description":"","type":"image"}]}}