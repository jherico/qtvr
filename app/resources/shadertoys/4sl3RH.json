{"Shader":{"ver":"0.1","info":{"id":"4sl3RH","date":"1362757685","viewed":1771,"name":"Ray*Bert","username":"Dave_Hoskins","description":"Q*Bert board simulation with ray-tracing.<br\/>Traces into voxels for the playing area, and distance estimation fields for the balls.<br\/>Time based random positioning for the ball landing square, and unique direction choices.<br\/>","likes":39,"published":3,"flags":0,"tags":["raytracing","voxels","qbert","raybert"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/\t\t\t\t\t  --------\n\/\/ Ray*Bert!!!       ( @!#?@! ) \n\/\/\t\t\t\t\t  --| |---\n\/\/\t\t\t\t\t\t|\/\n\/\/ By       Dave Hoskins\n\/\/ Finished for now... may come back later to put the other characters in.\n\/\/ V. 0.8  - Added colour changes and a fixed path for Q*Bert.\n\/\/ V. 0.7  - Better fur and ambient lighting.\n\/\/ V. 0.64 - Moving Q*bert.Behaves differently on different machines! :(\n\/\/ V. 0.63 - Pupil watching.\n\/\/ V. 0.62 - Asynchronous bounces.\n\/\/ V. 0.61 - Fur.\n\/\/ V. 0.60 - In the middle of getting old Q to move about.\n \n#define REFLECTIONS_ON\n\t\t\t\t\t\t\t\n#define PI  3.1415926535\n\nvec3 areaPlane = normalize(vec3(-1.0, 1.0, 1.0));\nvec3 lightDir = normalize(vec3(-1437.0, 1743.0, 430.0));\n\nvec3 QbertPos;\nfloat QbertRotation;\nvec3 balls[3];\nfloat squish[4];\nfloat radius[3];\n\nconst vec3 ballStart1 = vec3(-.0, 2.6, -1.);\nconst vec3 ballStart2 = vec3( 1.0, 2.6, 0.);\n\n\nconst vec3 addLeft  = vec3(-1.0, -1.0, 0.0);\nconst vec3 addRight = vec3(.0, -1.0, 1.0);\n\nconst vec3  QbertStart = vec3(-3.0, -1.3, .00);\n\n\nfloat time = iGlobalTime*1.8878;\n\nfloat rand( float n )\n{\n    return fract(sin(n*1233.23)*43758.5453);\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n\nvec2 rotate2D(vec2 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    vec2 r;\n    r.x = ca*p.x + sa*p.y;\n    r.y = -sa*p.x + ca*p.y;\n    return r;\n}\n\n\/\/ Finding the movement location at a set time. Loopy IF-tastic!!...\nvoid GetLocation(int i, float s, out vec3 outPos1, out vec3 outPos2)\n{\n\tint end = int(mod(s, 8.0))-1;\n\tfloat r = floor(s\/8.0) + float(i*547);\n\tvec3 pos;\n\tif (rand(float(r)) > .5)\n\t{\n\t\tpos = ballStart1;\n\t}else\n\t{\n\t\tpos = ballStart2;\n\t}\n\n\tfor (int t = 0; t < 9; t++)\n\t{\n\t\tif (t == 0)\n\t\t{\n\t\t\toutPos1 = pos + vec3(0.0, 3.5, 0.0);\n\t\t}\n\t\tif (t == end)\n\t\t{\n\t\t\toutPos1 = pos;\n\t\t}\n\t\tif (t == end+1)\n\t\t{\n\t\t\toutPos2 = pos;\n\t\t\tif (t == 7)\n\t\t\t{\n\t\t\t\toutPos2 = outPos1 + vec3(0.0, -8.5, 0.0);\n\t\t\t}\n\t\t}\n\n\t\tif (rand(float(t)+r) > .5)\n\t\t{\n\t\t\tpos += addLeft;\n\t\t}else\n\t\t{\n\t\t\tpos += addRight;\n\t\t}\n\t}\n}\n\n\/\/--------------------------------------------------------------------------------------------\nvec3 MoveQbert(int n, in vec3 pos, out float dir)\n{\n\tif (n == 0)\n\t{\n\t\tpos -= addLeft;\n\t\tdir = -90.0;\n\t}else\n\tif (n == 1)\n\t{\n\t\tpos -= addRight;\n\t\tdir = 180.0;\n\t}else\n\tif (n == 3)\n\t{\n\t\tpos += addLeft;\n\t\tdir = 90.0;\n\t}else\n\t{\n\t\tpos += addRight;\n\t\tdir = 0.0;\n\t}\n\treturn pos;\n}\n\n\n\/\/--------------------------------------------------------------------------------------------\nint DirTable[19];\nfloat GetQbertLocation(float s, out vec3 out1, out vec3 out2)\n{\n\tint end = int(mod(s, 18.0));\n\tfloat r = floor(s\/18.0);\n\tvec3 pos = QbertStart;\n\tfloat dir = 0.0;\n\tfloat outDir;\n\tvec3 newPos;\n\n\tfor (int t = 0; t < 19; t++)\n\t{\n\t\tif (t == end)\n\t\t{\n\t\t\tout1 = pos;\n\t\t}\n\t\tif (t == end+1)\n\t\t{\n\t\t\tout2 = pos;\n\t\t\toutDir = dir \/ 180.0 * PI;\n\t\t}\n\t\tint val = DirTable[t];\n\t\tpos = MoveQbert(val, pos, dir);\n\t}\n\treturn outDir;\n\n}\n\n\/\/----------------------- Distance Estimation fields -------------------\nfloat deTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\nfloat deQBertEyes(vec3 p)\n{\n\tfloat t = squish[3];\/\/clamp(fra*.25, 0.0, 0.2)-.2;\n\tp.y -= t;\n\tp.xz = rotate2D(p.xz, QbertRotation);\n\tvec3 pos = p + vec3(-.08, -.17, -.18);\n\t\n    float d = length(pos)-.12;\n\tpos = p + vec3(.08, -.17, -.18);\n    d = min(d, length(pos)-.12);\n\treturn d;\t\n}\n\nfloat deQBert(vec3 pos)\n{\n\tpos.xz = rotate2D(pos.xz, QbertRotation);\n\tvec3 p = pos;\n\t\n\t\/\/ Torso...\n\tfloat t = squish[3];\/\/clamp(fra*.25, 0.0, 0.2)-.2;\n\tp.y -=t;\n\tp.y *= .9;\n\tfloat d = length(p)-.32;\n\tp = pos * vec3(1.0, 1.0, .3);\n\tp.z -= .1;\n\tp.y -= t;\n\td = min(d, deTorus(p, vec2(.07, .06)));\n\n\t\/\/ Vertical legs...\n\tp = (pos * vec3(1.0, .4, 1.0))- vec3(-.13, -.2, -.1);\n\td = min(d, length(p)-.06);\n\tp = (pos * vec3(1.0, .4, 1.0))- vec3(.13, -.2, -.1);\n\td = min(d, length(p)-.06);\n\t\/\/ Feet...\n\tp = (pos * vec3(.4, .8, .3))- vec3(-.05, -.5, .01);\n\td = min(d, length(p)-.03);\n\tp = (pos * vec3(.4, .8, .3))- vec3(.05, -.5, .01);\n\td = min(d, length(p)-.03);\n\treturn d;\t\n}\n\nfloat deBall(vec3 p, float s)\n{\n    return length(p)-s;\n}\n\nfloat dePlane(vec3 p, vec3 planeN)\n{\n    return dot(p, planeN);\n}\n\nfloat PlayArea(vec3 p)\n{\t\n    float d;\n    d = dePlane(p, areaPlane);\n    return d;\n}\n\n\/\/--------------------------------------------------------------------------------------------\nfloat Scene(in vec3 p, out int which)\n{\t\n    float d = 1000.0, f;\n\t\n\tfor (int i =0; i < 3; i++)\n\t{\n\t\tvec3 pos = p-balls[i];\n\n\t\t\/\/ Squish it...\n\t\tpos.xz \/= squish[i];\n\t\tpos.y *= squish[i];\n\t\tf = deBall(pos, radius[i]);\n\t\tif (f < d)\n\t\t{\n\t\t\td = f;\n\t\t\twhich = i;\n\t\t}\n\t}\n\t\n\tf = deQBert(p - QbertPos);\n\tif (f < d)\n\t{\n\t\td = f;\n\t\twhich = 4;\n\t}\n\n\tf = deQBertEyes(p - QbertPos);\n\tif (f < d)\n\t{\n\t\td = f;\n\t\twhich = 5;\n\t}\n\n    return d;\n}\n\n\/\/------------------------------ Lighting ------------------------------------\n\/\/ Calculate scene normal\nvec3 SceneNormal(vec3 pos )\n{\n    float eps = 0.001;\n    vec3 n;\n\tint m;\n    float d = Scene(pos, m);\n    n.x = Scene( vec3(pos.x+eps, pos.y, pos.z), m ) - d;\n    n.y = Scene( vec3(pos.x, pos.y+eps, pos.z),m ) - d;\n    n.z = Scene( vec3(pos.x, pos.y, pos.z+eps),m ) - d;\n    return normalize(n);\n}\n\nvec3 HueGradient(float t)\n{\n\tt += .4;\n    vec3 p = abs(fract(t + vec3(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0)) * 6.0 - 3.0);\n\treturn (clamp(p - 1.0, 0.0, 1.0));\n}\n\/\/ Colouring in the fragments...\nvec3 LightCubes(vec3 pos, vec3 n)\n{\n\tvec3 qpos = QbertStart;\n\tfloat dir;\n\tivec3 ipos = ivec3(floor(pos+.5));\n\tfloat foundHit = 0.0;\n\tint end = int(mod(time*.8, 18.0));\n\t\n\tvec3 areaColour = vec3(.53, .7, .85);\n\tfor (int t = 0; t < 18; t++)\n\t{\n\t\tqpos = MoveQbert(DirTable[t], qpos, dir);\n\t\tivec3 ip = ivec3(floor(qpos+.5));\n\t\tif (ip == ipos && n.y >= .8)\n\t\t{\n\t\t\tif (t >= end) \n\t\t\tfoundHit = .5;\t\n\t\t\telse\n\t\t\tfoundHit = 1.5;\n\t\t}\n\t}\n\tif (foundHit > 0.0) areaColour = HueGradient((floor((time*.8\/18.0))+foundHit)\/4.23);\n\t\n    float diff = dot(n, lightDir);\n    diff = max(diff, 0.0);\n    return diff * areaColour;\t\n}\n\nvec3 LightCharacters(vec3 pos, vec3 norm, vec3 dir, int m)\n{\n\tfloat specular = 0.0;\n\tvec3 ballColour;\n\tfloat specSize = 8.0;\n\tvec3 specColour = vec3(1.0, 1.0, 1.0);\n\tif (m == 7)\n\t{\n\t\tballColour = vec3(1.0, 1.0, 1.0);\n\t\tspecColour = vec3(0.0, 0.0, 0.0);\n\t\tspecSize = 2.0;\n\t}\n\t\n\tif (m == 6)\n\t{\n\t\tnorm += (noise((pos-QbertPos)*42.0)*.5)-.5;\n\t\tballColour = vec3(1.2, 0.42, 0.);\n\t}\n\telse \n\t{\n\t\tvec3 reflect = ((-2.0*(dot(dir, norm))*norm)+dir);\n\t\tspecular = pow(max(dot(reflect, lightDir), 0.0), specSize);\n\t\t\n\t\tif (m == 2)\n\t\t{\n\t\t\tballColour = vec3(1.0, 0.0, 1.0);\n\t\t}else\n\t\tif (m == 3)\n\t\t{\n\t\t\tballColour = vec3(1.0, 0.0, 0.0);\n\t\t}else\n\t\tif (m == 4)\n\t\t{\n\t\t\tballColour = vec3(0.0, 1.0, 0.0);\n\t\t}\n\t}\n\n\tfloat diff = dot(norm, lightDir);\n    diff = max(diff, 0.3);\n\n\treturn mix(diff * ballColour, specColour, specular);\t\n}\n\n\/\/--------------------------------------------------------------------------------------------\nfloat DistanceFields(vec3 ro, vec3 rd, out int hit, out vec3 pos)\n{\n\tfloat len = .0;\n\tfloat d;\n\thit = 0;\n\tint m = 0;\n\tfor (int st = 0; st < 22; st++)\n\t{\n\t\tpos = ro + rd * len;\n\t\td = Scene(pos, m);\n\t\tif (d < 0.01)\n\t\t{\n\t\t\thit = m+1;\n\t\t\tbreak;\n\t\t}\n\t\t\tlen += d;\n\t}\n\treturn len;\n}\n \n\/\/--------------------------------------------------------------------------------------------\n\/\/ Voxel grid search that I found in 1994 in Graphics Gems IV - \"Voxel Traversal along a 3D Line\"!\n\/\/ This (Amanatides & Woo) varient is from another shader on here, but with some calculations removed,\n\/\/ and the distance value fixed.\n\/\/ I had to use voxels as standard distance fields don't work for perfectly aligned cubes.\n\nfloat VoxelTrace(vec3 ro, vec3 rd, out bool hit, out vec3 hitNormal, out vec3 pos)\n{\n    const int maxSteps = 41;\n    vec3 voxel = floor(ro)+.5001;\n    vec3 step = sign(rd);\n\t\/\/voxel = voxel - vec3(rd.x > 0.0, rd.y > 0.0, rd.z > 0.0);\n    vec3 tMax = (voxel - ro) \/ rd;\n    vec3 tDelta = 1.0 \/ abs(rd);\n    vec3 hitVoxel = voxel;\n    \n\t\n    hit = false;\n\t\n    float hitT = 0.0;\n    for(int i=0; i < maxSteps; i++)\n\t{\n\t\tif (!hit)\n\t\t{\n\t\t\tfloat d = PlayArea(voxel);        \n\t\t\tif (d <= 0.0 && !hit)\n\t\t\t{\n\t\t\t\thit = true;\n\t\t\t\thitVoxel = voxel;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbool c1 = tMax.x < tMax.y;\n\t\t\tbool c2 = tMax.x < tMax.z;\n\t\t\tbool c3 = tMax.y < tMax.z;\n\t\t\tif (c1 && c2) \n\t\t\t{ \n\t\t\t\tvoxel.x += step.x;\n\t\t\t\ttMax.x += tDelta.x;\n\t\t\t\tif (!hit) \n\t\t\t\t{\n\t\t\t\t\thitNormal = vec3(-step.x, 0.0, 0.0);\n\t\t\t\t\thitT = tMax.x-tDelta.x;\n                    \n\t\t\t\t}\n\t\t\t} else if (c3 && !c1) \n\t\t\t{\n\t\t\t\tvoxel.y += step.y;\n\t\t\t\ttMax.y += tDelta.y;\n\t\t\t\tif (!hit) \n\t\t\t\t{\n\t\t\t\t\thitNormal = vec3(0.0, -step.y, 0.0);\t\n\t\t\t\t\thitT = tMax.y-tDelta.y;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t{\n\t\t\t\tvoxel.z += step.z;\n\t\t\t\ttMax.z += tDelta.z;\n\t\t\t\tif (!hit) \n\t\t\t\t{\n\t\t\t\t\thitNormal = vec3(0.0, 0.0, -step.z);\t\t\n\t\t\t\t\thitT = tMax.z-tDelta.z;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    }\n\t\n\tif (hit)\n\t{\n\t\tif (hitVoxel.x > 1.75 || hitVoxel.z < -1.75 || hitVoxel.y < -3.5)\n\t\t{\n\t\t\thit = false;\n\t\t\thitT = 1000.0;\n\t\t}\n\t}\n\tpos = ro + hitT * rd;\n\treturn hitT;\n}\n\n\/\/--------------------------------------------------------------------------------------------\n\/\/ Do all the ray casting for voxels and normal distance fields...\nfloat TraceEverything(vec3 ro,vec3 rd, out int material, out vec3 hitNormal, out vec3 pos)\n{\n\tbool hit1;\n\tint hit2;\n\tvec3 pos2;\n    float dist = VoxelTrace(ro, rd, hit1, hitNormal, pos);\n\tfloat dist2 = DistanceFields(ro, rd, hit2, pos2);\n\tif (hit2 > 0 && dist2 < dist)\n\t{\n\t\thitNormal = SceneNormal(pos2);\n\t\tpos = pos2;\n\t\tmaterial = hit2+1;\n\t}else\n\tif (hit1)\n\t{\n\t\tmaterial = 1;\n\t}else\n\t{\n\t\tmaterial = 0;\n\t}\n\treturn dist;\n}\n\n\/\/--------------------------------------------------------------------------------------------\nint TraceShadow(vec3 ro, vec3 rd)\n{\n\tint hit;\n\tvec3 pos;\n\tfloat dist2 = DistanceFields(ro, rd, hit, pos);\n\treturn hit;\n}\n\n\/\/--------------------------------------------------------------------------------------------\nvec3 DoMaterialRGB(int m, vec3 pos, vec3 norm, vec3 rd)\n{\n\tvec3 rgb;\n\tif (m == 1)\n\t{\n\t\trgb = LightCubes(pos, norm);\n\t}else\n\tif (m >= 2)\n\t{\n\t\trgb = LightCharacters(pos, norm, rd, m);\n\t}else\n\t{\n\t\trgb = mix(vec3(.0, .05, .1), vec3(0.4, 0.6, .8), abs(rd.y*1.));\n    }\n\treturn rgb;\n}\n\n\/\/--------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\/\/ For Q*Bert's movement to loop properly they needed a direction table...\n\t\/\/\t1\t0\n\t\/\/\t \\ \/\n\t\/\/\t  @\n\t\/\/\t \/ \\\n\t\/\/\t3\t2\n\t\n\tDirTable[0] = 0; DirTable[1] = 2; DirTable[2] = 0; DirTable[3] = 2;\n\tDirTable[4] = 0; DirTable[5] = 2; DirTable[6] = 0; DirTable[7] = 1;  DirTable[8] = 1; DirTable[9] = 3;  DirTable[10] = 1;\n\tDirTable[11] = 1; DirTable[12] = 3; DirTable[13] = 3; DirTable[14] = 3;\n\tDirTable[15] = 3; DirTable[16] = 2; DirTable[17] = 0; DirTable[18] = 0;\n\t\n\tvec2 pixel = (fragCoord.xy \/ iResolution.xy)*2.0-1.0;\n    float asp = iResolution.x \/ iResolution.y;\n    vec3 rd = normalize(vec3(asp*pixel.x, pixel.y-1.23, -3.5));\n    vec3 ro = vec3(-14.0, 6.3, 14.0);\n\t\/\/ Rotate it to look at the plane\n\trd.xz = rotate2D(rd.xz, -(PI\/4.0));\n\n\tfloat sec, fra;\n\tvec3 rgb;\n    vec3 norm, pos;\n\tint material; \n\tvec3 pos1, pos2;\n\tradius[0] = .4;\n\tradius[1] = .33;\n\tradius[2] = .25;\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tsec = time * float(i+3) * .2;\n\t\tfra = fract(sec);\n\t\tsec = floor(sec);\n\t\n\t\tGetLocation(i, sec, pos1, pos2);\n\t\tballs[i] = mix(pos1, pos2, fra);\n\t\tballs[i].y += sin(fra*PI);\n\t\tif (balls[i].y > -2.5)\n\t\t{\n\t\t\tfloat t = clamp(-fra*.75+1.3, 1.0, 1.3);\n\t\t\tsquish[i] = t;\n\t\t}else\n\t\t{\n\t\t\tsquish[i] = 1.0;\n\t\t}\n\t}\n\t\n\t\t\n\tfra = fract(time*.8);\n\tsec = floor(time*.8);\n\tQbertRotation = GetQbertLocation(sec, pos1, pos2);\n\t\n\tfloat t = clamp(fra*.5, 0.0, 0.2)-.3;\n\tsquish[3] = t;\n\tQbertPos = mix(pos1, pos2, fra); \n\tQbertPos.y += sin(fra*PI)+.5;\n\n\n\tTraceEverything(ro, rd, material, norm, pos);\n\trgb = DoMaterialRGB(material, pos, norm, rd);\n\t\n\t\/\/ Do the shadow casting of the balls...\n\tif (dot(norm, lightDir) > 0.1 && material > 0 && TraceShadow(pos+lightDir*.04, lightDir) != 0)\n\t{\n\t\trgb *= .4;\n\t}\n\t\n\t\n#ifdef REFLECTIONS_ON\n\tif (material > 0 && material != 6)\n\t{\n\t\tro = pos;\n\t\trd = ((-2.0*(dot(rd, norm))*norm)+rd);\n\t\tTraceEverything(ro+rd*0.04, rd, material, norm, pos);\n\t\trgb = mix(rgb, DoMaterialRGB(material, pos, norm, rd), .13);\n\t}\n#endif\t\n\t\n\t\/\/ Curve the brightness a little...\n\trgb = pow(rgb, vec3(.8, .8, .8));\n\n    fragColor=vec4(rgb, 1.0);\n}\n","name":"","description":"","type":"image"}]}}