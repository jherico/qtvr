{"Shader":{"ver":"0.1","info":{"id":"MtsSDs","date":"1440777472","viewed":908,"name":"Ray Marching Experiment n\u00b032","username":"aiekick","description":"A Paint Ball ^^<br\/>mouse control the cam","likes":6,"published":3,"flags":0,"tags":["ray","experiment","marching","32"],"hasliked":0},"renderpass":[{"inputs":[{"id":23,"src":"\/presets\/cube01_0.png","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Stephane Cuillerdier - Aiekick\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/#define INV_MODE\n\n#define shape(p) length(p)-2.8\n\n\nfloat dstepf = 0.0;\n    \nconst vec2 RMPrec = vec2(.5, 0.001); \nconst vec3 DPrec = vec3(0.005, 12., 1e-6); \n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n#define pattern sin(1.5)\n#define t iGlobalTime\nvec3 magicSplat(vec2 uv)\n{\n\tfloat a = 0.;\n\tif (uv.x >= 0.) a = atan(uv.x, uv.y) * .275;\n    if (uv.x < 0.) a =  3.14159 - atan(-uv.x, -uv.y) * 1.66;\n    \n\tfloat t = mod(t, 10.)*5.;\n\t\n    vec3 p = vec3(uv,a);\n    \n    \/\/ from dgreensp => https:\/\/www.shadertoy.com\/view\/4ljGDd\n    p = 1. - abs(1. - mod(p, 2.));\n    float lL = length(p), nL = lL, tot = 0., c = pattern;\n    for (int i=0; i < 12; i++) \n\t{\n\t\tp = abs(p)\/(lL*lL) - c;\n\t\tnL = length(p);\n\t\ttot += abs(nL-lL);\n\t\tlL = nL;\n    }\n    \n\tfloat fc = tot + 1.;\n\tfc = 1.-smoothstep(fc, fc+0.001, t\/dot(uv,uv));\n\n\tvec3 col;\n    vec3 tex = vec3(1.); \n\tvec3 splash = vec3(1.-fc)*vec3(.42, .02, .03);\n   \n#ifdef INV_MODE\n    col = mix(splash, tex, (splash.r==0.?0.:1.));\n#else\n    col = mix(splash, tex, (splash.r==0.?1.:0.));   \n#endif\n    \n    return col;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nfloat sphereThick = 0.02; \/\/ thick of sphere plates\nvec4 map(vec3 p)\n{\n    vec2 uv = p.xz;\n    \n    vec3 col = magicSplat(uv);\n    \n    dstepf += 0.005;\n\n    float disp = dot(col,vec3(.05));     \n    \n    float sphereOut = shape(p);\n    float sphereIn = sphereOut + sphereThick;\n    float sphere = max(-sphereIn, sphereOut);\n    \n   \tfloat dist = max(sphere, sphereOut + disp);\n                                    \n    return vec4(dist, col.rgb);\n}\n\nvec3 nor( vec3 pos, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n    map(pos+e.xyy).x - map(pos-e.xyy).x,\n    map(pos+e.yxy).x - map(pos-e.yxy).x,\n    map(pos+e.yyx).x - map(pos-e.yyx).x );\n    return normalize(n);\n}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cu, vec3 cv)\n{\n\tvec3 rov = normalize(cv-ro);\n    vec3 u =  normalize(cross(cu, rov));\n    vec3 v =  normalize(cross(rov, u));\n    vec3 rd = normalize(rov + u*uv.x + v*uv.y);\n    return rd;\n}\n\nvoid mainImage( out vec4 f, in vec2 g )\n{\n    vec2 si = iResolution.xy;\n   \tfloat t = iGlobalTime;\n    f = vec4(0.);\n    float ca = t*.2; \/\/ angle z\n    float ce = 2.; \/\/ elevation\n    float cd = 3.; \/\/ distance to origin axis\n   \tif ( iMouse.z>0.) cd = iMouse.x\/iResolution.x * 10. - 5.; \/\/ mouse x axis \n    if ( iMouse.z>0.) ce = iMouse.y\/iResolution.y * 10. - 5.; \/\/ mouse y axis \n    vec3 cu=vec3(0,1,0);\/\/Change camere up vector here\n    vec3 cv=vec3(0,0,0); \/\/Change camere view here\n    float refl_i = .6; \/\/ reflexion intensity\n    float refr_a = 1.2; \/\/ refraction angle\n    float refr_i = .8; \/\/ refraction intensity\n    float bii = 0.6; \/\/ bright init intensity\n    vec2 uv = (g+g-si)\/min(si.x, si.y);\n    vec3 ro = vec3(sin(ca)*cd, ce+1., cos(ca)*cd); \/\/\n    vec3 rd = cam(uv, ro, cu, cv);\n    float b = bii;\n    vec3 d = vec3(0.);\n    vec3 p = ro+rd*d.x;\n    float s = DPrec.y;\n    for(int i=0;i<200;i++)\n    {      \n\t\tif(s<DPrec.x||s>DPrec.y) break;\n        s = map(p).x*(s>DPrec.x?RMPrec.x:RMPrec.y);\n        d.y = d.x;\n        d.x += s;\n        p = ro+rd*d.x;\n   \t}\n\n    f += pow(b,15.);\n    \n    if (d.x<DPrec.y)\n    {\n    \tfloat nPrec = 0.001;\n        vec3 n = nor(p, nPrec);\n        vec3 ray = reflect(rd, n);\n        f += textureCube(iChannel0, ray) * refl_i; \n        f.rgb = mix( f.rgb, map(p).yzw,0.5);  \n   \t}\n    else\n    {\n    \tf = textureCube(iChannel0, rd);\n    }\n    \n    f += dstepf;\n}\n\n","name":"","description":"","type":"image"}]}}