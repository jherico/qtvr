{"Shader":{"ver":"0.1","info":{"id":"MtS3Dy","date":"1432087629","viewed":833,"name":"2D Quadratic Bezier","username":"demofox","description":"Use mouse to control the green control point.<br\/>Using distance from each pixel to the quadratic bezier curve to render the curve.","likes":2,"published":3,"flags":0,"tags":["2d","bezier"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/*\nInfo on curves:\nhttp:\/\/research.microsoft.com\/en-us\/um\/people\/hoppe\/ravg.pdf\nhttp:\/\/research.microsoft.com\/en-us\/um\/people\/cloop\/LoopBlinn05.pdf\nhttp:\/\/www.pouet.net\/topic.php?which=9119&page=1\nhttp:\/\/blog.gludion.com\/2009\/08\/distance-to-quadratic-bezier-curve.html\n\nThe top link is where the get_distance_vector comes from.\n\nThanks also to other bezier curve shadertoys:\nhttps:\/\/www.shadertoy.com\/view\/XsX3zf\nhttps:\/\/www.shadertoy.com\/view\/lts3Df\n*\/\n\n#define EDGE   0.005\n#define SMOOTH 0.0025\n\n\/\/ signed distance function for Circle, for control points\nfloat SDFCircle( in vec2 coords, in vec2 offset )\n{\n    coords -= offset;\n    float v = coords.x * coords.x + coords.y * coords.y - EDGE*EDGE;\n    vec2  g = vec2(2.0 * coords.x, 2.0 * coords.y);\n    return v\/length(g); \n}\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\nvec2 get_distance_vector(vec2 b0, vec2 b1, vec2 b2) {\n  float a=det(b0,b2), b=2.0*det(b1,b0), d=2.0*det(b2,b1); \/\/ \ud835\udefc,\ud835\udefd,\ud835\udeff(\ud835\udc5d)\n  float f=b*d-a*a; \/\/ \ud835\udc53(\ud835\udc5d)\n  vec2 d21=b2-b1, d10=b1-b0, d20=b2-b0;\n  vec2 gf=2.0*(b*d21+d*d10+a*d20);\n  gf=vec2(gf.y,-gf.x); \/\/ \u2207\ud835\udc53(\ud835\udc5d)\n  vec2 pp=-f*gf\/dot(gf,gf); \/\/ \ud835\udc5d\u2032\n  vec2 d0p=b0-pp; \/\/ \ud835\udc5d\u2032 to origin\n  float ap=det(d0p,d20), bp=2.0*det(d10,d0p); \/\/ \ud835\udefc,\ud835\udefd(\ud835\udc5d\u2032)\n  \/\/ (note that 2*ap+bp+dp=2*a+b+d=4*area(b0,b1,b2))\n  float t=clamp((ap+bp)\/(2.0*a+b+d), 0.0, 1.0); \/\/ \ud835\udc61\u0305\n  return mix(mix(b0,b1,t),mix(b1,b2,t),t); \/\/ \ud835\udc63\ud835\udc56 = \ud835\udc4f(\ud835\udc61\u0305)\n}\n\nfloat approx_distance(vec2 p, vec2 b0, vec2 b1, vec2 b2) {\n  return length(get_distance_vector(b0-p, b1-p, b2-p));\n}\n\n\/\/-----------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    float aspectRatio = iResolution.x \/ iResolution.y;\n    vec2 percent = ((fragCoord.xy \/ iResolution.xy) - vec2(0.25,0.5));\n    percent.x *= aspectRatio;\n    \n    vec2 mouse = (iMouse.xy \/ iResolution.xy) - vec2(0.25,0.5);\n    mouse.x *= aspectRatio;\n    vec2 A = vec2(0.0,0.0);\n    vec2 B = length(iMouse.xy) > 0.0 ? mouse : vec2(-0.3,0.2);\n    vec2 C = vec2(1.0,0.0);\n\n    vec3 color = vec3(1.0,1.0,1.0);\n    float dist = SDFCircle(percent, A);\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(1.0,0.0,0.0),vec3(1.0,1.0,1.0),dist);\n    }\n    \n    dist = SDFCircle(percent, B);\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(0.0,1.0,0.0),vec3(1.0,1.0,1.0),dist);\n    }    \n    \n    dist = SDFCircle(percent, C);\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(0.0,0.0,1.0),vec3(1.0,1.0,1.0),dist);\n    }    \n\n    dist = approx_distance(percent, A, B, C);\n    if (dist < EDGE + SMOOTH)\n    {\n        dist = smoothstep(EDGE - SMOOTH,EDGE + SMOOTH,dist);\n        color *= vec3(dist);\n    }\n       \n\tfragColor = vec4(color,1.0);\n}\n\n","name":"","description":"","type":"image"}]}}