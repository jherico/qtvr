{"Shader":{"ver":"0.1","info":{"id":"Mst3Wr","date":"1449111699","viewed":1861,"name":"La calanque","username":"XT95","description":"Something like \"Les calanques\" a beautiful place near Marseille, France!","likes":27,"published":3,"flags":0,"tags":["massilia","777seas"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by anatole duprat - XT95\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat map( in vec3 p);\nvec3 shade( in vec3 p, in vec3 n, in vec3 ro, in vec3 rd);\n\nvec2 rotate( vec2 v, float a);\nvec3 seaHit( in vec3 ro, in vec3 rd, float h, out float t );\nvec3 raymarch( in vec3 ro, in vec3 rd, in vec2 clip);\nvec3 raymarchSmall( in vec3 ro, in vec3 rd, in vec2 clip);\n\nvec3 normal( in vec3 p, in float e );\nfloat ambiantOcclusion(vec3 p, vec3 n, vec2 a);\n\nfloat noise( in vec3 x );\nfloat displacement( vec3 p );\nvec3 skyColor( in vec3 rd);\n\n\n\n\n\n\n\/\/Distance field maps\nfloat rock( in vec3 p)\n{\n\tfloat d = length(abs(p.xy)+vec2(-220.,50.))-200.; \/\/ 2 cylinders \n\td = max(d, -p.z-250.);\n    \n\td = d*.2  + noise(p*.04-.75)*7. + displacement(p*.25)*2.;\n    \n\treturn d;\n}\nfloat ground( in vec3 p )\n{\n\treturn p.y-clamp(p.z*.08-5.5,-20., 0.);\n}\nfloat map( in vec3 p )\n{\n\treturn min(ground(p), rock(p));\n}\n\n\n\/\/Shading\nvec3 shade( in vec3 p, in vec3 n, in vec3 ro, in vec3 rd)\n{\n\t\/\/Sky ?\n\tconst vec3 sunDir = vec3(-0.128,0.946, -0.189);\n\tvec3 sky = skyColor(rd);\n\tfloat d = length(p-ro);\n\tif(d>500. )\n\t\treturn sky;\n\n    vec3 nn = normal(p,5.);\n    \n   \t\/\/Materials\n\tvec3 col;\n\tif(rock(p.xyz) < p.y ) \/\/Rock\n\t{\n\t\tcol = mix(vec3(1.), vec3(.2,.3\/*+noise(p*0.4)*.5*\/,.1)*.4, pow(clamp(nn.y*1.1,0.,1.),4.));\n\t\tcol = mix(mix(vec3(.3,.2,.1), vec3(.3,.28,.22)*1.9, clamp(p.z-70.,0.,1.)), col, clamp(p.y*.3,0.,1.));\n\t}\n\telse \/\/Sand\n\t{\n\t\tcol = vec3(.3,.28,.22)*1.9*(noise(p*10.)*noise(p*vec3(.8,0.,3.))*.1+.8);\n\t}\n\n\n    \/\/BRDF \n    float shad = ambiantOcclusion(p.xyz, sunDir, vec2(7.,12.));\n    float ao = ambiantOcclusion(p.xyz, n, vec2(1.,1.5)) * ambiantOcclusion(p.xyz, n, vec2(5.,8.));\n    \n    vec3 amb = vec3(.9,.97,1.)*ao;\n    vec3 diff = vec3(1.,.8,.5) * min( max(dot(n,sunDir),0.)*max(dot(nn,sunDir)*1.2,0.1)*shad*6., 1.);\n    \n    col *=  amb*.3 + diff*.7;\n    \n    \n    \n    \/\/Underwater blue\n    float a = clamp(-p.y*.4,0.,1.);\n    float b = pow(clamp(2.5-displacement(p*vec3(.5,1.,.3)*.05+1.)*6.*a, 0.8, 1.),4.);\n    float c = pow(clamp(2.5-displacement(p*vec3(.5,1.,.4)*.08+10.)*5.*a, 0.8, 1.),4.);\n\tcol = mix(col, vec3(.2,1.,.8)*.2*(b-c+1.), a);\n    \n    \/\/A little fog\n\tcol = mix( col, vec3(1.,.98,.9), clamp( (d-25.)*.0007,0.,1.) );\n\n\treturn col;\n}\n\n\nvec3 shadeWater( in vec3 p, in vec3 n, in vec3 ro, in vec3 rd) \/\/Simplified shading because instructions limit..\n{\n\t\/\/Sky ?\n\tconst vec3 sunDir = vec3(-0.0828,0.946, -0.189);\n\tvec3 sky = skyColor(rd);\n\tif( map(p)>1.)\n\t\treturn sky;\n    \n    \/\/BRDF\n\tfloat d = length(p-ro);\n\tvec3 col = vec3(.9,.97,1.)*.1 +  vec3(1.,.9,.6)*max(dot(n,sunDir),0.)*.3;\n    \n    \/\/A little fog\n\tcol = mix( col, vec3(1.,.98,.9), clamp( (d-25.)*.0007,0.,1.) );\n    return col;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/Screen coords\n\tvec2 q = fragCoord.xy\/iResolution.xy;\n\tvec2 v = -1.0+2.0*q;\n\tv.x *= iResolution.x\/iResolution.y;\n    \n\t\/\/Camera\n\tfloat ct = cos(iGlobalTime*.1);\n    vec3 ro = vec3(20.*ct,10.,75.+20.*ct);\n\tvec3 rd = normalize( vec3(v.x, v.y, -1.5+length(v)*.5) );\n\trd.xz = rotate(rd.xz, -.5*ct+1.57);\n    \n    \n    \/\/Compute pixel\n    vec3 p = raymarch(ro, rd, vec2(.1,1800.));\n\tvec3 n = normal(p.xyz, 0.01);\n    vec3 col = shade(p,n, ro,rd);\n    \n    \/\/Water hit ?\n\tfloat t;\n\tvec3 pWater = seaHit(ro,rd,.1, t);\n    float d = length(p-ro);\n\tif( t>0. && (length(pWater-ro) < d || d>800.) )\n\t{\n\t\tfloat depth =  map(pWater);\n\t\tro = pWater.xyz;\n\t\tn = normalize( vec3(0.,1.,0.) + (noise(pWater+vec3(0.,0.,iGlobalTime))*2.-1.)*.025);\n\t\tfloat fre = (1.-max(dot(rd,n),0.));\n\t\tvec3 refd = reflect(rd, n);\n    \tp = raymarchSmall(pWater+n, refd, vec2(.1,800.));\n    \tn = normal(p.xyz, 5.);\n    \tvec3 col2= shadeWater(p,n, ro,refd);\n\t\tcol = mix(col, col2, min(depth,1.)*.5*fre);\n\t\tcol = mix( col, skyColor(rd), min( d*0.001,1.) );\n\t}\n    \n    \/\/Little lens flare\n    vec3 sundir = normalize( vec3(.5, .0, -1.) );\n    col += pow( max(dot(rd, sundir),0.), 2.0) *.05;\n    \n    \n    \/\/Gamma correction & vignetting :)\n    col = pow( col, vec3(1.\/1.42) );\n    col = clamp(col,0.,1.) * (.5 + .5*pow( q.x*q.y*(1.-q.x)*(1.-q.y)*50., .5));\n    \n    fragColor = vec4(col*min(iGlobalTime*.25,1.), 1.);\n}\n\n\n\n\n\n\n\n\nvec2 rotate( vec2 v, float a)\n{\n  return vec2( v.y*cos(a) - v.x*sin(a), v.x*cos(a) + v.y*sin(a));\n}\n\n\nvec3 seaHit( in vec3 ro, in vec3 rd, float h, out float t )\n{\n        vec4 pl = vec4(0.0,1.0,0.0,h);\n         t = -(dot(pl.xyz,ro)+pl.w)\/dot(pl.xyz,rd);\n        return ro+rd*t;\n}\n\n\nvec3 raymarch( in vec3 ro, in vec3 rd, in vec2 clip)\n{\n    float accD=2.;\n    for(int i=0; i<128; i++)\n    {\n\t\tfloat d = map( ro+rd*accD);\n        if(  accD > clip.y) break;\n        accD += d*2.5;\n        \n    }\n    return ro+rd*accD;\n}\n\nvec3 raymarchSmall( in vec3 ro, in vec3 rd, in vec2 clip)\n{\n    float accD=5.;\n    for(int i=0; i<64; i++)\n    {\n\t\tfloat d = map( ro+rd*accD);\n        if( d < .01 || accD > clip.y) break;\n        accD += d*2.5;\n        \n    }\n    return ro+rd*accD;\n}\n\nvec3 normal( in vec3 p, in float e )\n{\n    vec3 eps = vec3(e,0.0,0.0);\n    return normalize(vec3(\n        map(p+eps.xyy)-map(p-eps.xyy),\n        map(p+eps.yxy)-map(p-eps.yxy),\n        map(p+eps.yyx)-map(p-eps.yyx)\n    ));\n}\n\n\nfloat ambiantOcclusion(vec3 p, vec3 n, vec2 a)\n{\n\tfloat dlt = a.x;\n\tfloat oc = 0.0, d = a.y;\n\tfor(int i = 0; i<5; i++)\n\t{\n\t\toc += (float(i) * dlt - map(p + n * float(i) * dlt)) \/ d;\n\t\td *= 2.0;\n\t}\n\treturn clamp(1.0 - oc, 0.0, 1.0);\n}\n\n\n\n\n\nvec3 skyColor( in vec3 rd )\n{\n    vec3 sundir = normalize( vec3(-.5, .2, -1.) );\n    \n    float yd = min(rd.y+0.05, 0.);\n    rd.y = max(rd.y+0.05, 0.05);\n    \n    vec3 col = vec3(0.);\n    \n    col += vec3(.4, .4 - exp( -rd.y*20. )*.3, .0) * exp(-rd.y*9.); \/\/ Red \/ Green \n    col += vec3(.3, .5, .6) * (1. - exp(-rd.y*8.) ) * exp(-rd.y*.9) ; \/\/ Blue\n    \n    col = mix(col*1.2, vec3(.3),  1.-exp(yd*100.)); \/\/ Fog\n    \n    col += vec3(1.0, .5, .0) * (pow( max(dot(rd,sundir),0.), 15. ) + pow( max(dot(rd, sundir),0.), 150.0)*.5)*.3; \/\/ Sun\n    \n    \n    col -= vec3(.6)*displacement( vec3(rd.xz*1.5\/(.001+rd.y),0.)-vec3(.0,.1,.05)*iGlobalTime )*rd.y-.2; \/\/Clouds\n    \n    return max(col, vec3(0.))*.9;\n}\n\n\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat displacement( vec3 p ) \/\/Thx to Inigo Quilez\n{\t\n    p *= vec3(1.,.8,1.);\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.01;\n    f += 0.2500*noise( p); p = m*p*3.5;\n    f += 0.0425*noise( p ); \/*p = m*p*2.01;\n    f += 0.0625*noise( p ); *\/\n\t\n    return f;\n}\n\nfloat noise(vec3 p) \/\/Thx to Las^Mercury\n{\n\tvec3 i = floor(p);\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n\tvec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\n\ta = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n\ta.xy = mix(a.xz, a.yw, f.y);\n\treturn mix(a.x, a.y, f.z)*.5+.5;\n}","name":"","description":"","type":"image"}]}}