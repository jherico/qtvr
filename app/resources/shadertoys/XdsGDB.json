{"Shader":{"ver":"0.1","info":{"id":"XdsGDB","date":"1378762363","viewed":33565,"name":"Buoy","username":"TekF","description":"A ray-traced sphere floating in a ray-marched ocean. Refraction & reflection effects.<br\/>It looks particularly nice when you pause it and move the camera.","likes":167,"published":3,"flags":0,"tags":["raytracing","raymarching","noise","reflection","refraction"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nconst float tau = 6.28318530717958647692;\r\n\r\n\/\/ Gamma correction\r\n#define GAMMA (2.2)\r\n\r\nvec3 ToLinear( in vec3 col )\r\n{\r\n\t\/\/ simulate a monitor, converting colour values into light values\r\n\treturn pow( col, vec3(GAMMA) );\r\n}\r\n\r\nvec3 ToGamma( in vec3 col )\r\n{\r\n\t\/\/ convert back into colour values, so the correct light will come out of the monitor\r\n\treturn pow( col, vec3(1.0\/GAMMA) );\r\n}\r\n\r\nvec3 localRay;\r\n\r\n\/\/ Set up a camera looking at the scene.\r\n\/\/ origin - camera is positioned relative to, and looking at, this point\r\n\/\/ distance - how far camera is from origin\r\n\/\/ rotation - about x & y axes, by left-hand screw rule, relative to camera looking along +z\r\n\/\/ zoom - the relative length of the lens\r\nvoid CamPolar( out vec3 pos, out vec3 ray, in vec3 origin, in vec2 rotation, in float distance, in float zoom, in vec2 fragCoord )\r\n{\r\n\t\/\/ get rotation coefficients\r\n\tvec2 c = vec2(cos(rotation.x),cos(rotation.y));\r\n\tvec4 s;\r\n\ts.xy = vec2(sin(rotation.x),sin(rotation.y)); \/\/ worth testing if this is faster as sin or sqrt(1.0-cos);\r\n\ts.zw = -s.xy;\r\n\r\n\t\/\/ ray in view space\r\n\tray.xy = fragCoord.xy - iResolution.xy*.5;\r\n\tray.z = iResolution.y*zoom;\r\n\tray = normalize(ray);\r\n\tlocalRay = ray;\r\n\t\r\n\t\/\/ rotate ray\r\n\tray.yz = ray.yz*c.xx + ray.zy*s.zx;\r\n\tray.xz = ray.xz*c.yy + ray.zx*s.yw;\r\n\t\r\n\t\/\/ position camera\r\n\tpos = origin - distance*vec3(c.x*s.y,s.z,c.x*c.y);\r\n}\r\n\r\n\r\n\/\/ Noise functions, distinguished by variable types\r\n\r\nvec2 Noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\/\/\tvec3 f2 = f*f; f = f*f2*(10.0-15.0*f+6.0*f2);\r\n\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n\r\n\/\/ hardware interpolation lacks precision\r\n\/\/\tvec4 rg = texture2D( iChannel0, (uv+0.5)\/256.0, -100.0 );\r\n\tvec4 rg = mix( mix(\r\n\t\t\t\ttexture2D( iChannel0, (floor(uv)+0.5)\/256.0, -100.0 ),\r\n\t\t\t\ttexture2D( iChannel0, (floor(uv)+vec2(1,0)+0.5)\/256.0, -100.0 ),\r\n\t\t\t\tfract(uv.x) ),\r\n\t\t\t\t  mix(\r\n\t\t\t\ttexture2D( iChannel0, (floor(uv)+vec2(0,1)+0.5)\/256.0, -100.0 ),\r\n\t\t\t\ttexture2D( iChannel0, (floor(uv)+1.5)\/256.0, -100.0 ),\r\n\t\t\t\tfract(uv.x) ),\r\n\t\t\t\tfract(uv.y) );\r\n\t\t\t\t  \r\n\r\n\treturn mix( rg.yw, rg.xz, f.z );\r\n}\r\n\r\nvec4 Noise( in vec2 x )\r\n{\r\n    vec2 p = floor(x.xy);\r\n    vec2 f = fract(x.xy);\r\n\tf = f*f*(3.0-2.0*f);\r\n\/\/\tvec3 f2 = f*f; f = f*f2*(10.0-15.0*f+6.0*f2);\r\n\r\n\tvec2 uv = p.xy + f.xy;\r\n\treturn texture2D( iChannel0, (uv+0.5)\/256.0, -100.0 );\r\n}\r\n\r\nvec4 Noise( in ivec2 x )\r\n{\r\n\treturn texture2D( iChannel0, (vec2(x)+0.5)\/256.0, -100.0 );\r\n}\r\n\r\nvec2 Noise( in ivec3 x )\r\n{\r\n\tvec2 uv = vec2(x.xy)+vec2(37.0,17.0)*float(x.z);\r\n\treturn texture2D( iChannel0, (uv+0.5)\/256.0, -100.0 ).xz;\r\n}\r\n\r\n\r\nfloat Waves( vec3 pos )\r\n{\r\n\tpos *= .2*vec3(1,1,1);\r\n\t\r\n\tconst int octaves = 6;\r\n\tfloat f = 0.0;\r\n\r\n\t\/\/ need to do the octaves from large to small, otherwise things don't line up\r\n\t\/\/ (because I rotate by 45 degrees on each octave)\r\n\t\tpos += iGlobalTime*vec3(0,.1,.1);\r\n\tfor ( int i=0; i < octaves; i++ )\r\n\t{\r\n\t\tpos = (pos.yzx + pos.zyx*vec3(1,-1,1))\/sqrt(2.0);\r\n\t\tf  = f*2.0+abs(Noise(pos).x-.5)*2.0;\r\n\t\tpos *= 2.0;\r\n\t}\r\n\tf \/= exp2(float(octaves));\r\n\t\r\n\treturn (.5-f)*1.0;\r\n}\r\n\r\nfloat WavesDetail( vec3 pos )\r\n{\r\n\tpos *= .2*vec3(1,1,1);\r\n\t\r\n\tconst int octaves = 8;\r\n\tfloat f = 0.0;\r\n\r\n\t\/\/ need to do the octaves from large to small, otherwise things don't line up\r\n\t\/\/ (because I rotate by 45 degrees on each octave)\r\n\t\tpos += iGlobalTime*vec3(0,.1,.1);\r\n\tfor ( int i=0; i < octaves; i++ )\r\n\t{\r\n\t\tpos = (pos.yzx + pos.zyx*vec3(1,-1,1))\/sqrt(2.0);\r\n\t\tf  = f*2.0+abs(Noise(pos).x-.5)*2.0;\r\n\t\tpos *= 2.0;\r\n\t}\r\n\tf \/= exp2(float(octaves));\r\n\t\r\n\treturn (.5-f)*1.0;\r\n}\r\n\r\nfloat WavesSmooth( vec3 pos )\r\n{\r\n\tpos *= .2*vec3(1,1,1);\r\n\t\r\n\tconst int octaves = 2;\r\n\tfloat f = 0.0;\r\n\r\n\t\/\/ need to do the octaves from large to small, otherwise things don't line up\r\n\t\/\/ (because I rotate by 45 degrees on each octave)\r\n\t\tpos += iGlobalTime*vec3(0,.1,.1);\r\n\tfor ( int i=0; i < octaves; i++ )\r\n\t{\r\n\t\tpos = (pos.yzx + pos.zyx*vec3(1,-1,1))\/sqrt(2.0);\r\n\t\t\/\/f  = f*2.0+abs(Noise(pos).x-.5)*2.0;\r\n\t\tf  = f*2.0+sqrt(pow(Noise(pos).x-.5,2.0)+.01)*2.0;\r\n\t\tpos *= 2.0;\r\n\t}\r\n\tf \/= exp2(float(octaves));\r\n\t\r\n\treturn (.5-f)*1.0;\r\n}\r\n\r\nfloat WaveCrests( vec3 ipos, in vec2 fragCoord )\r\n{\r\n\tvec3 pos = ipos;\r\n\tpos *= .2*vec3(1,1,1);\r\n\t\r\n\tconst int octaves1 = 6;\r\n\tconst int octaves2 = 16;\r\n\tfloat f = 0.0;\r\n\r\n\t\/\/ need to do the octaves from large to small, otherwise things don't line up\r\n\t\/\/ (because I rotate by 45 degrees on each octave)\r\n\tpos += iGlobalTime*vec3(0,.1,.1);\r\n\tvec3 pos2 = pos;\r\n\tfor ( int i=0; i < octaves1; i++ )\r\n\t{\r\n\t\tpos = (pos.yzx + pos.zyx*vec3(1,-1,1))\/sqrt(2.0);\r\n\t\tf  = f*1.5+abs(Noise(pos).x-.5)*2.0;\r\n\t\tpos *= 2.0;\r\n\t}\r\n\tpos = pos2 * exp2(float(octaves1));\r\n\tpos.y = -.05*iGlobalTime;\r\n\tfor ( int i=octaves1; i < octaves2; i++ )\r\n\t{\r\n\t\tpos = (pos.yzx + pos.zyx*vec3(1,-1,1))\/sqrt(2.0);\r\n\t\tf  = f*1.5+pow(abs(Noise(pos).x-.5)*2.0,1.0);\r\n\t\tpos *= 2.0;\r\n\t}\r\n\tf \/= 1500.0;\r\n\t\r\n\tf -= Noise(ivec2(fragCoord.xy)).x*.01;\r\n\t\r\n\treturn pow(smoothstep(.4,-.1,f),6.0);\r\n}\r\n\r\n\r\nvec3 Sky( vec3 ray )\r\n{\r\n\treturn vec3(.4,.45,.5);\r\n}\r\n\r\n\r\nvec3 boatRight, boatUp, boatForward;\r\nvec3 boatPosition;\r\n\r\nvoid ComputeBoatTransform( void )\r\n{\r\n\tvec3 samples[5];\r\n\t\r\n\tsamples[0] = vec3(0,0, 0);\r\n\tsamples[1] = vec3(0,0, .5);\r\n\tsamples[2] = vec3(0,0,-.5);\r\n\tsamples[3] = vec3( .5,0,0);\r\n\tsamples[4] = vec3(-.5,0,0);\r\n\t\r\n\tsamples[0].y = WavesSmooth(samples[0]);\r\n\tsamples[1].y = WavesSmooth(samples[1]);\r\n\tsamples[2].y = WavesSmooth(samples[2]);\r\n\tsamples[3].y = WavesSmooth(samples[3]);\r\n\tsamples[4].y = WavesSmooth(samples[4]);\r\n\r\n\tboatPosition = (samples[0]+samples[1]+samples[2]+samples[3]+samples[4])\/5.0;\r\n\t\r\n\tboatRight = samples[3]-samples[4];\r\n\tboatForward = samples[1]-samples[2];\r\n\tboatUp = normalize(cross(boatForward,boatRight));\r\n\tboatRight = normalize(cross(boatUp,boatForward));\r\n\tboatForward = normalize(boatForward);\r\n\t\r\n\tboatPosition += .0*boatUp;\r\n}\r\n\r\nvec3 BoatToWorld( vec3 dir )\r\n{\r\n\treturn dir.x*boatRight+dir.x*boatUp+dir.x*boatForward;\r\n}\r\n\r\nvec3 WorldToBoat( vec3 dir )\r\n{\r\n\treturn vec3( dot(dir,boatRight), dot(dir,boatUp), dot(dir,boatForward) );\r\n}\r\n\r\nfloat TraceBoat( vec3 pos, vec3 ray )\r\n{\r\n\tvec3 c = boatPosition;\r\n\tfloat r = 1.0;\r\n\t\r\n\tc -= pos;\r\n\t\r\n\tfloat t = dot(c,ray);\r\n\t\r\n\tfloat p = length(c-t*ray);\r\n\tif ( p > r )\r\n\t\treturn 0.0;\r\n\t\r\n\treturn t-sqrt(r*r-p*p);\r\n}\r\n\r\n\r\nvec3 ShadeBoat( vec3 pos, vec3 ray )\r\n{\r\n\tpos -= boatPosition;\r\n\tvec3 norm = normalize(pos);\r\n\tpos = WorldToBoat(pos);\r\n\t\r\n\tvec3 lightDir = normalize(vec3(-2,3,1));\r\n\tfloat ndotl = dot(norm,lightDir);\r\n\t\r\n\t\/\/ allow some light bleed, as if it's subsurface scattering through plastic\r\n\tvec3 light = smoothstep(-.1,1.0,ndotl)*vec3(1.0,.9,.8)+vec3(.06,.1,.1);\r\n\r\n\t\/\/ anti-alias the albedo\r\n\tfloat aa = 4.0\/iResolution.x;\r\n\t\r\n\t\/\/vec3 albedo = ((fract(pos.x)-.5)*(fract(pos.y)-.5)*(fract(pos.z)-.5) < 0.0) ? vec3(0) : vec3(1);\r\n\tvec3 albedo = vec3(1,.01,0);\r\n\talbedo = mix( vec3(.04), albedo, smoothstep( .25-aa, .25, abs(pos.y) ) );\r\n\talbedo = mix( mix( vec3(1), vec3(.04), smoothstep(-aa*4.0,aa*4.0,cos(atan(pos.x,pos.z)*6.0)) ), albedo, smoothstep( .2-aa*1.5, .2, abs(pos.y) ) );\r\n\talbedo = mix( vec3(.04), albedo, smoothstep( .05-aa*1.0, .05, abs(abs(pos.y)-.6) ) );\r\n\talbedo = mix( vec3(1,.8,.08), albedo, smoothstep( .05-aa*1.0, .05, abs(abs(pos.y)-.65) ) );\r\n\t\r\n\tvec3 col = albedo*light;\r\n\t\r\n\t\/\/ specular\r\n\tvec3 h = normalize(lightDir-ray);\r\n\tfloat s = pow(max(0.0,dot(norm,h)),100.0)*100.0\/32.0;\r\n\t\r\n\tvec3 specular = s*vec3(1,1,1);\r\n\r\n\tvec3 rr = reflect(ray,norm);\r\n\tspecular += mix( vec3(0,.04,.04), Sky(rr), smoothstep( -.1, .1, rr.y ) );\r\n\t\r\n\tfloat ndotr = dot(norm,ray);\r\n\tfloat fresnel = pow(1.0-abs(ndotr),5.0);\r\n\tfresnel = mix( .001, 1.0, fresnel );\r\n\r\n\tcol = mix( col, specular, fresnel );\r\n\t\r\n\treturn col;\r\n}\r\n\r\n\r\nfloat OceanDistanceField( vec3 pos )\r\n{\r\n\treturn pos.y - Waves(pos);\r\n}\r\n\r\nfloat OceanDistanceFieldDetail( vec3 pos )\r\n{\r\n\treturn pos.y - WavesDetail(pos);\r\n}\r\n\r\nvec3 OceanNormal( vec3 pos )\r\n{\r\n\tvec3 norm;\r\n\tvec2 d = vec2(.01*length(pos),0);\r\n\t\r\n\tnorm.x = OceanDistanceFieldDetail( pos+d.xyy )-OceanDistanceFieldDetail( pos-d.xyy );\r\n\tnorm.y = OceanDistanceFieldDetail( pos+d.yxy )-OceanDistanceFieldDetail( pos-d.yxy );\r\n\tnorm.z = OceanDistanceFieldDetail( pos+d.yyx )-OceanDistanceFieldDetail( pos-d.yyx );\r\n\r\n\treturn normalize(norm);\r\n}\r\n\r\nfloat TraceOcean( vec3 pos, vec3 ray )\r\n{\r\n\tfloat h = 1.0;\r\n\tfloat t = 0.0;\r\n\tfor ( int i=0; i < 100; i++ )\r\n\t{\r\n\t\tif ( h < .01 || t > 100.0 )\r\n\t\t\tbreak;\r\n\t\th = OceanDistanceField( pos+t*ray );\r\n\t\tt += h;\r\n\t}\r\n\t\r\n\tif ( h > .1 )\r\n\t\treturn 0.0;\r\n\t\r\n\treturn t;\r\n}\r\n\r\n\r\nvec3 ShadeOcean( vec3 pos, vec3 ray, in vec2 fragCoord )\r\n{\r\n\tvec3 norm = OceanNormal(pos);\r\n\tfloat ndotr = dot(ray,norm);\r\n\r\n\tfloat fresnel = pow(1.0-abs(ndotr),5.0);\r\n\t\r\n\tvec3 reflectedRay = ray-2.0*norm*ndotr;\r\n\tvec3 refractedRay = ray+(-cos(1.33*acos(-ndotr))-ndotr)*norm;\t\r\n\trefractedRay = normalize(refractedRay);\r\n\r\n\tconst float crackFudge = .0;\r\n\t\r\n\t\/\/ reflection\r\n\tvec3 reflection = Sky(reflectedRay);\r\n\tfloat t=TraceBoat( pos-crackFudge*reflectedRay, reflectedRay );\r\n\t\r\n\tif ( t > 0.0 )\r\n\t{\r\n\t\treflection = ShadeBoat( pos+(t-crackFudge)*reflectedRay, reflectedRay );\r\n\t}\r\n\r\n\t\r\n\t\/\/ refraction\r\n\tt=TraceBoat( pos-crackFudge*refractedRay, refractedRay );\r\n\t\r\n\tvec3 col = vec3(0,.04,.04); \/\/ under-sea colour\r\n\tif ( t > 0.0 )\r\n\t{\r\n\t\tcol = mix( col, ShadeBoat( pos+(t-crackFudge)*refractedRay, refractedRay ), exp(-t) );\r\n\t}\r\n\t\r\n\tcol = mix( col, reflection, fresnel );\r\n\t\r\n\t\/\/ foam\r\n\tcol = mix( col, vec3(1), WaveCrests(pos,fragCoord) );\r\n\t\r\n\treturn col;\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tComputeBoatTransform();\r\n\t\r\n\tvec2 camRot = vec2(.5,.5)+vec2(-.35,4.5)*(iMouse.yx\/iResolution.yx);\r\n\tvec3 pos, ray;\r\n\tCamPolar( pos, ray, vec3(0), camRot, 3.0, 1.0, fragCoord );\r\n\t\r\n\tfloat to = TraceOcean( pos, ray );\r\n\tfloat tb = TraceBoat( pos, ray );\r\n\t\r\n\tvec3 result;\r\n\tif ( to > 0.0 && ( to < tb || tb == 0.0 ) )\r\n\t\tresult = ShadeOcean( pos+ray*to, ray, fragCoord );\r\n\telse if ( tb > 0.0 )\r\n\t\tresult = ShadeBoat( pos+ray*tb, ray );\r\n\telse\r\n\t\tresult = Sky( ray );\r\n\t\r\n\t\/\/ vignette effect\r\n\tresult *= 1.1*smoothstep( .35, 1.0, localRay.z );\r\n\t\r\n\tfragColor = vec4(ToGamma(result),1.0);\r\n}\r\n","name":"","description":"","type":"image"}]}}