{"Shader":{"ver":"0.1","info":{"id":"ltjSzW","date":"1444138657","viewed":632,"name":"Eye of the Abyss","username":"tsherif","description":"Playing around with the space inversion function from here: https:\/\/www.shadertoy.com\/view\/4dsGD7","likes":0,"published":3,"flags":0,"tags":["3d","raymarching","inversion"],"hasliked":0},"renderpass":[{"inputs":[{"id":24,"src":"\/presets\/cube02_0.jpg","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"float time;\n\nfloat mapSphere(in vec3 pos) {\n    float r = 1.7;\n   \n   \tfloat a = sin(time * 0.1);\n    float cosa = cos(a);\n    float sina = sin(a);\n    mat3 rotz = mat3(\n        cosa, -sina, 0.0,\n        sina, cosa, 0.0,\n        0.0, 0.0, 1.0\n    );\n    \n    pos = rotz * pos;\n    float d = length(pos) - r;\n\n    d += 0.1 * (sin(pos.x * 10.0 + time) + cos(pos.y * 10.0 + time)  + sin(pos.z * 10.0 + time));\n    d = d \/ (dot(pos, pos) * 2.0);\n    \n    return d;\n}\n\nfloat map(in vec3 pos) {\n    return mapSphere(pos);\n}\n\nvec3 calcNormal(in vec3 pos) {\n    vec3 nor;\n    vec2 e = vec2(0.01, 0.0);\n    \n    nor.x = map(pos + e.xyy) - map(pos - e.xyy);\n    nor.y = map(pos + e.yxy) - map(pos - e.yxy);\n    nor.z = map(pos + e.yyx) - map(pos - e.yyx);\n    \n    return normalize(nor);\n}\n\nvec3 getColor(in vec3 pos, in vec3 rd) {\n    vec3 light = normalize(vec3(1.0,1.0,0.5));\n    \n    float ri = length(pos.xy * vec2(12.0, 2.2));\n    float ro = length(pos);\n    float a = atan(pos.y, pos.x);\n    \n    vec3 nor = calcNormal(pos);\n    vec3 refl = textureCube(iChannel0, reflect(rd, nor)).rgb;\n    vec3 mat = mix(vec3(0.0), vec3(0.5, 0.0, 0.0), smoothstep(0.4, 1.2, ri  + sin(a * 40.0) * 0.15));\n    mat = mix(mat, vec3(0.8), smoothstep(1.8, 3.0, ri  + sin((a + time * 0.1) * 10.0) * 0.2));\n    mat = mix(mat, vec3(0.05), smoothstep(3.0, 3.5, ro));\n    vec3 spec = vec3(1.0) * pow(max(dot(-rd, reflect(-light, nor)), 0.0), 100.0);\n    vec3 diff = max(0.0, dot(light, nor)) * vec3(1.0);\n    vec3 color = mat * (refl * diff + spec + 0.4);\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = fragCoord.xy \/ iResolution.xy;\n    vec2 pos = p * 2.0 - 1.0;\n    pos.x *= iResolution.x \/ iResolution.y;\n    time = mod(iGlobalTime, 3000.0);\n    \n    float r = length(pos);\n    float a = atan(pos.y, pos.x);\n            \n    vec3 ro = vec3(0.0, 0.0, 3.0);\n    vec3 rd = vec3(pos, -1.0);\n    \n    rd = normalize(rd);\n    \n    vec3 color = textureCube(iChannel0, rd).rgb;\n    \n    float tmax = 240.0;\n    float t = 0.0;\n    for (int i = 0; i < 256; i++) {\n      \tvec3 pos = ro + rd * t;\n        \n        float h = map(pos);\n        if (h < 0.001 || t > tmax) break;\n        t += h * 0.5;\n    }\n    \n    \n    \n    if (t < tmax) {\n        vec3 pos = ro + rd * t;\n        color = getColor(pos, rd);\n    }\n    \n    color = sqrt(color);\n    fragColor = vec4(color, 1.0);\n}","name":"","description":"","type":"image"}]}}