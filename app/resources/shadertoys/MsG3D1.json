{"Shader":{"ver":"0.1","info":{"id":"MsG3D1","date":"1454236240","viewed":44,"name":"Rolling shutter propellor","username":"JamesGriffin","description":"A propellor is defined using the implicit equation r < cos^2K(n\/2*theta) + H (set the delayCoeff to 0.0 to see it).<br\/>This is rotated (rotationRate) and a time-shift is applied with the delay set by delayCoeff * y-coord (the rolling shutter effect).","likes":1,"published":3,"flags":0,"tags":["implicitequation","rollingshutter"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ Constants\n    float delayCoeff = 0.9;\n    float rotationRate = 2.0;\n    float hubSize = 0.1;\n    float bladeThinness = 5.0; \/\/ Higher is thinner\n    int numBlades = 4; \/\/ Can only be 2, 3, 4, 5, 6 (otherwise defaults to 6)\n    \/\/ Transform coordinate system\n    vec2 xy = 4.0*(fragCoord.xy-0.5*iResolution.xy) \/ max(iResolution.x,iResolution.y);\n\t\n    \/\/ Work out the angle\n    float theta = rotationRate * (iGlobalTime - delayCoeff * xy.y);\n    \/\/ Rotation matrix\n    mat2 M = mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n    xy = M * xy;\n    float r = length(xy);\n    float a = 0.0;\n    float x = xy.x \/ r;\n    float y = xy.y \/ r;\n    if (r > hubSize + 1.0) { \/\/ Don't bother with calculations if out of bounds\n        a = -1.0;\n    } else {\n        float p = 0.0;\n        float q = 0.0;\n\n        if(numBlades == 2) {\n            \/\/ 2 bladed version\n            \/\/ p = cos(3t) and q = sin(3t)\n            p = (x*x - y*y);\n            \/\/ q = (2.0*x*y); (not used)\n        } else if(numBlades == 3) {\n            \/\/ 3 bladed version\n            \/\/ p = cos(3t) and q = sin(3t)\n            p = (x*x*x - 3.0*x*y*y);\n            \/\/ q = (3.0*x*x*y - y*y*y); (not used)\n        } else if (numBlades == 4) {    \n            \/\/ 4 bladed version\n            \/\/ p = cos(4t) and q = sin(4t)\n            p = (x*x*x*x - 6.0*x*x*y*y + y*y*y*y);\n            \/\/ q = (4.0*x*x*x*y - 4.0*x*y*y*y); (not used)\n        } else if (numBlades == 5) {    \n            \/\/ 5 bladed version\n            \/\/ This is p = cos(5t) and q = sin(5t)\n            p = (x*x*x*x*x - 10.0*x*x*x*y*y + 5.0*x*y*y*y*y);\n            \/\/ q = (5.0*x*x*x*x*y - 10.0*x*x*y*y*y + y*y*y*y*y); (not used)\n        } else {\n            \/\/ 6 bladed version\n            \/\/ This is p = cos(6t) and q = sin(6t)\n            p = (x*x*x*x*x*x - 15.0*x*x*x*x*y*y + 15.0*x*x*y*y*y*y - y*y*y*y*y*y);\n            \/\/ q = (6.0*x*x*x*x*x*y - 20.0*x*x*x*y*y*y + 6*x*y*y*y*y*y); (not used)\n        }\n\n        \/\/ RHS of the implicit equation\n        a = pow(0.5*(1.0 - p), bladeThinness) + hubSize;\n\n        \/\/ Rather than plot LHS < RHS, use this to smooth edges (AA for free)\n        a = min(a\/r - 1.0, 0.1) \/ 0.1;\n    }\n    \n    \n    if(a < 0.0) {\n        \/\/ White background\n        fragColor = vec4(1.0,1.0,1.0,1.0);\n    } else {\n        \/\/ Compute a colour for the propellor\n    \tvec3 colour = vec3(0.5, 0.5, 0.5) + x*vec3(0.5,-0.5,0.0)\/sqrt(2.0) + y*vec3(0.5,0.5,-1.0)\/sqrt(6.0);\n    \tcolour = colour \/ max(max(colour.r, colour.g), colour.b);\n\t\tfragColor = vec4(a*colour + (1.0 - a), 1.0);\n    }\n}","name":"","description":"","type":"image"}]}}