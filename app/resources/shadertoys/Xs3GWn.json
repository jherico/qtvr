{"Shader":{"ver":"0.1","info":{"id":"Xs3GWN","date":"1449554389","viewed":245,"name":"ellipse on 3D patch","username":"FabriceNeyret2","description":"Solves perspective projection of ellipse on a 3D bilinear patch. red dot = 2D ellipse centroid.<br\/>This also corresponds to a pixel footprint on surface or texture parameterization.","likes":3,"published":3,"flags":0,"tags":["perspective"],"hasliked":0},"renderpass":[{"inputs":[{"id":1,"src":"\/presets\/tex00.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define CENTROID 1 \/\/ set 0 if too costly ( red dot 2D ellips center: is the costliest part !)\n#define STRIP true \/\/ alternate flat at strippy projected ellipse\n#define Z 1.       \/\/ Zoffset. 1 : high perspective.  10 or 100: orthographic (far view)\n#define eps 1e-5\n\nvoid mainImage( out vec4 o,  vec2 p )\n{\n\tvec2 R = iResolution.xy, uv, uv2;\n    p = 1.1\/Z * (p+p-R) \/ R.y; \n    \/\/vec2 m = (2.*iMouse.xy-R)\/R.y;\n    \n    bool deg, swap, lin;\n    float t = iGlobalTime, d, W=1.,H=1., Y=0.,\n        \n    \/\/ --- quadrilateral bilinear patch  \n        \n         za=0., zb=2.+2.5*cos(t),      zc=0., zd=2.+2.5*sin(t);   \/\/ full bilinear case \n      \/\/ za=0., zb=2.+2.5*sin(t),      zc=0., zd=2.+2.5*sin(t);   \/\/ linear case\n      \/\/ za=0., zb=2.+s2.5*in(t)+1e-4, zc=0., zd=2.+2.5*sin(t);   \/\/ strangely, hard case = close to linear\n      \/\/ za=0., zb=3.+2.*cos(t),       zc=0., zd=zc;  W=sin(t);   \/\/ rotation\n\tza += Z; zb += Z; zc += Z; zd += Z; \n    \/\/ p *= 4.; p.y += Y = 1.; Y*=Z;        \/\/ offset in height \n    vec3 A = vec3(-W,-H+Y, za),\n         B = vec3( W,-H+Y, zb),\n         C = vec3(-W, H+Y, zc),\n         D = vec3( W, H+Y, zd);\n    \n    \/\/ --- solve sys3x3: bilin(uv) = (xe,ye,1)*Z  ( equivalent to intersec ray - patch ) \n    \n    \/\/ eliminates Z, sys2x2: L12 -= (xe,ye).L3 \n    A.xy -= p*A.z; \n    B.xy -= p*B.z; \n    C.xy -= p*C.z; \n    D.xy -= p*D.z; \n    vec3 AB = B-A, AC = C-A, CD = D-C, ABCD = CD-AB; \/\/ bilin = A + u.AB + v.AC +uv.ABCD = 0\n\t\n    if (lin = length(ABCD.xy) < eps) { \/\/ no uv: the system is indeed linear !\n\t    A.z  = cross(A ,AC).z; \/\/ eliminates v -> gives u\n    \tAB.z = cross(AB,AC).z;\n        uv.x = -A.z\/AB.z;\n        uv.y = -A.y\/AC.y -AB.y\/AC.y*uv.x; \/\/ inject u in L2 -> gives v\n        uv2 = uv;        \n    }\n    else {   \/\/ full bilinear system.  eliminates uv -> sys1: Az + u.ABz + v.ACz = 0  \n    \tA.z  = cross(A ,ABCD).z;\n    \tAB.z = cross(AB,ABCD).z;\n    \tAC.z = cross(AC,ABCD).z;\n\n    \tif (deg = abs(AC.z)<eps) { \/\/ v eliminated as well ! -> gives u\n    \t    o-=o++; return; \/\/ <><><> does this case exist ?\n    \t    \/\/uv.x = -A.z\/AB.z;\n    \t    \/\/uv.y = -A.y\/AC.y -AB.y\/AC.y*uv.x; \/\/ inject u in L2 -> gives v\n    \t    \/\/uv2 = uv;\n    \t    \/\/if (abs(AC.y)<eps) d=-1.; \/\/ really unlucky\n    \t}\n    \telse { \/\/ full normal bilinear system.\n    \t\tfloat e = -A.z\/AC.z, f = -AB.z\/AC.z, \/\/ ->  v = e + u.f\n    \t\t\/\/ inject v in L2 -> P2(u): a.u^2 + b.u + c = 0    -> solve P2(u) then v\n    \t\t    a = ABCD.y*f, b = ABCD.y*e + AC.y*f + AB.y, c = AC.y*e + A.y;\n    \t\t    d = b*b-4.*a*c;\n    \t\tif (lin = abs(a)<eps)  \/\/ <><><> better to use bigger eps: near-lin is unstable\n                uv2.x = uv.x  = -c\/b; \/\/ no parabolic term\n            else {\n\t\t\t    uv.x  = (-b+sqrt(d))\/a\/2.;\n    \t\t\tuv2.x = (-b-sqrt(d))\/a\/2.;\n    \t\t}\n    \t\tuv.y  = e + f*uv.x;\n    \t\tuv2.y = e + f*uv2.x;\n    \t}\n    }\n    \n    \/\/ --- select valid solution and display\n    \n    uv  = 2.*uv -1.;\n    uv2 = 2.*uv2-1.;\n    if ( swap = abs(uv.x)>1. || abs(uv.y)>1.) uv = uv2;\n    float l = length(uv);\n\n    \/\/ o = texture2D(iChannel0,.5+.5*uv); return;\n    \n    if  (d<0.) o = vec4(.2,0,0,1); \/\/ red: ray didn't intersect the support twisted surface\n    else if ( abs(uv.x)>1. || abs(uv.y)>1.) o = vec4(.5,.5,1,1); \/\/ out of patch bounds\n    else {\n\t     o = vec4(step(l,1.));                        \/\/ circles in patch coords\n\t     if (STRIP&& fract(t\/11.)<.5) o *= .5+.5*cos(60.*l);  \/\/ striped circles in patch coords\n         o.b += smoothstep(.95,1.,max(cos(63.*uv.x),cos(63.*uv.y)));  \/\/ grid in patch coords\n         if ( deg )  o.r += .5*(1.-o.r);  \/\/ red tint if degenerate solution\n         if ( swap ) o.g += .3*(1.-o.g);  \/\/ green tint if second root was chosen\n         if ( lin )  o.b += .5*(1.-o.b);  \/\/ blue tint if one on linear solutions\n    }\n    \n    \/\/ --- draw the 2D vs 3D ellipse centerd\n    \n    A = vec3(-W,-H+Y, za), B = vec3( W,-H+Y, zb), C = vec3(-W, H+Y, zc), D = vec3( W, H+Y, zd);\n    AB = B-A, AC = C-A, CD = D-C, ABCD = CD-AB; \/\/ bilin = A + u.AB + v.AC +uv.ABCD\n#define bilin(u,v) ( A + (u)*AB + (v)*AC +(u)*(v)*ABCD )\n    \n    \/\/ draw a blue dot at the middle of the grid\n    vec3 P1 = bilin(.5,.5);\n    l = smoothstep (.05, .04, Z*length(P1.xy\/P1.z - p));\n    o = mix(o,vec4(0,0,1,1), l);\n    \n#if CENTROID   \n    \/\/ I don't want to solve eigenvectors of a 5x5 system in GLSL-ES !\n    \/\/ Let's try other methods. Here, iteratively find the long axis.\n    vec3 P0 = A+.5*AB;   \/\/ initial A point\n    float a0=0., a1=0., da=.1, u,v,  lM=0.; int j=0;\n    for (int i=0; i<400; i++) { \/\/ dichotomy would do faster\n        a1 += da;\n        u = .5+.5*sin(a1), v = .5-.5*cos(a1); \/\/ turn B point as long as farther\n        P1 = bilin(u,v);\n        l = length(P1.xy\/P1.z - P0.xy\/P0.z); \/\/ projected distance \n        if (l<lM) \/\/ decreasing !\n            if (j==0) { a1 -= da; da=-da; j++; continue; } \/\/ if first step: wrong direction\n            else {      \/\/  not first step: we just passed the locally maximal length\n            \ta1 -= da;   \/\/   backtrack to the maximum\n            \tu = .5+.5*sin(a1), v = .5-.5*cos(a1);\n                P1 = bilin(u,v);\n            \tvec3 P=P0; P0=P1; P1=P;\/\/ now optimize A side (indeed, swap A and B)\n            \tfloat aa=a0; a0=a1;  a1=aa; \n                da *= .9; \/\/ allowed to decrease the loop from 2000. step was 0.005 , then\n                j=0; \/\/ restart iterations\n            }\n        else { lM=l; j++; } \/\/ the distance still increases\n    }\n    \/\/ draw a red dot at the middle\n    l = smoothstep (.05, .04, Z*length( (P0.xy\/P0.z+P1.xy\/P1.z)\/2. - p));\n    o = mix(o,vec4(1,0,0,1), l);\n    \/\/ draw diameter\n#define line(a,b) 1e-3\/Z \/ length( clamp( dot(p-a,r=b-a)\/dot(r,r), 0.,1.) *r - p+a )\n    vec2 a=P0.xy\/P0.z,b=P1.xy\/P1.z,r; o.bg-= line(a,b) ;\n#endif\n\n#if 0 \/\/ bug inside\n    \/\/ exact solution from http:\/\/math.stackexchange.com\/questions\/1566904\/partial-solving-of-ellipse-from-5-points\n    vec3 E = mix(A,B,.2929), F = mix(A,C,.2929); \/\/ 1-1\/sqrt(2)\n    A\/=A.z, B\/=B.z, C\/=C.z, D\/=D.z, E\/=E.z, F\/=F.z; \n#define tan3(A,B) vec3( -(B-A).y, (B-A).x, -cross(A,B).z )\n    vec3 TA = tan3(A,B), TB = tan3(B,C), TC = tan3(C,D), TD = tan3(D,A), TE = tan3(E,F);\n    float m1 = dot(cross(TA,TC),TE)*dot(cross(TB,TD),TE),\n          m2 = dot(cross(TA,TD),TE)*dot(cross(TB,TC),TE);\n    vec3 V11 = cross(TA,TD), V12 = cross(TB,TC),\n         V21 = cross(TA,TC), V22 = cross(TB,TD),\n         O = m1* (V11*V12.z + V11.z*V12 )\n            -m2* (V21*V22.z + V21.z*V22 ); \n    l = smoothstep (.05, .04, Z*length( O.xy\/O.z - p));\n    o = mix(o,vec4(0,1,0,1), l);\n#endif    \n}","name":"","description":"","type":"image"}]}}