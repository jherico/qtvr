{"Shader":{"ver":"0.1","info":{"id":"XtsSWH","date":"1436405888","viewed":684,"name":"raytracer with blackjack and...","username":"yaro_b","description":"My first raytracer.<br\/><br\/>NOTE: Click&drag mouse to change camera position.","likes":1,"published":3,"flags":0,"tags":["raytracing","brdf"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ My first raytracer.\n\n#define MAX_BOUNCE_COUNT 16\n\n\/\/ NxN anti-aliasing.\n#define AA_COUNT 4\n\n#define ENABLE_SHADOWS 1\n\n#define PI 3.14159265359\n\n\/\/ Index of refraction.\nfloat eta_air = 1.00029;\nfloat eta_glass = 1.5;\n\nfloat camera_orbit_radius = 2.5;\nfloat camera_elevation = PI \/ 4.0; \/\/ radians\nfloat camera_azimuth = 0.0; \/\/ radians;\nvec3 camera_pos;\nvec3 camera_dir;\nvec3 camera_up;\n\nfloat camera_aspect_ratio = iResolution.x \/ iResolution.y;\nfloat camera_fov_y = PI \/ 3.0; \/\/ radians\nfloat camera_near = 0.1;\nfloat camera_far = 10.0;\nfloat camera_far_half_height = tan(0.5 * camera_fov_y) * camera_far;\nfloat camera_far_half_width = camera_far_half_height * camera_aspect_ratio;\n\n\/\/ vec3 light_pos = vec3(1.0, 1.0, -1.0);\n\/\/ vec3 light_pos = vec3(cos(2.0 * PI * iGlobalTime), sin(2.0 * PI * iGlobalTime), -1.0);\nvec3 light_pos = 2.0 * vec3(cos(2.0 * PI * iGlobalTime \/ 8.0), 1.0, sin(2.0 * PI * iGlobalTime \/ 8.0));\nvec3 light_radiance = vec3(1.0, 1.0, 1.0);\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nstruct Material\n{\n    vec3 specular;\n    vec3 diffuse;\n    float alpha; \/\/ width parameter aka roughness\n    float eta;   \/\/ index of refraction\n    int scatter_mask;\n};\n\nstruct Sphere\n{\n    vec3 origin;\n    float radius;\n};\n\nstruct Plane\n{\n    \/\/ dot(normal, X) = d\n    vec3 normal;\n    float d;\n};\n\nfloat spacing_angle = 2.0 \/ 3.0 * PI; \/\/ radians\nfloat spacing_radius = 1.0;\n\n\/\/ Scene objects:\nSphere diffuse_ball = Sphere(spacing_radius * vec3(cos(0.0 * spacing_angle), 0.5, sin(0.0 * spacing_angle)), 0.5);\nSphere specular_ball = Sphere(spacing_radius * vec3(cos(1.0 * spacing_angle), 0.5, sin(1.0 * spacing_angle)), 0.5);\nSphere glass_ball = Sphere(spacing_radius * vec3(cos(2.0 * spacing_angle), 0.5, sin(2.0 * spacing_angle)), 0.5);\nPlane checker_floor = Plane(vec3(0.0, 1.0, 0.0), 0.0);\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define SCENE_GLASS_BALL 1\n#define SCENE_PLASTIC_BALL 2\n#define SCENE_GOLDEN_BALL 3\n#define SCENE_FLOOR 4\n\n#define SCATTER_DIFFUSE 1\n#define SCATTER_SPECULAR 2\n#define SCATTER_TRANSPARENT 4\n\nvoid get_material(vec3 pos, int id, inout Material mtl)\n{\n    if (id == SCENE_GLASS_BALL)\n    {\n        mtl.specular = vec3(0.04, 0.04, 0.04);\n        mtl.diffuse = vec3(1.0, 1.0, 1.0) - mtl.specular;\n        mtl.alpha = 0.05;\n        mtl.eta = 1.5;\n        mtl.scatter_mask = SCATTER_TRANSPARENT;\n    }\n    else if (id == SCENE_PLASTIC_BALL)\n    {\n        mtl.specular = vec3(0.04, 0.04, 0.04);\n        mtl.diffuse = vec3(1.0, 0.0, 0.0) - mtl.specular;\n        mtl.alpha = 0.25;\n        mtl.eta = 1.46; \/\/ PLA (pure); TODO: Pick something better for colored plastic.\n        mtl.scatter_mask = SCATTER_DIFFUSE;\n    }\n    else if (id == SCENE_GOLDEN_BALL)\n    {\n        mtl.specular = vec3(1.022, 0.782, 0.344);\n        mtl.diffuse = vec3(0.0, 0.0, 0.0);\n        mtl.alpha = 0.35;\n        mtl.eta = 1.47;\n        mtl.scatter_mask = SCATTER_SPECULAR;\n    }\n    else if (id == SCENE_FLOOR)\n    {\n        float checker_size = 0.5;\n        float alpha = floor(pos.x \/ checker_size) + floor(pos.z \/ checker_size);\n        alpha = abs(alpha);\n        alpha -= 2.0 * floor(alpha \/ 2.0);\n\n        mtl.specular = vec3(0.04, 0.04, 0.04);\n        \/* mtl.diffuse = mix(vec3(0.95, 0.95, 0.95), vec3(0.25, 0.25, 0.25), alpha); *\/\n        mtl.diffuse = mix(vec3(0.25, 0.25, 0.95), vec3(0.95, 0.95, 0.25), alpha);\n        mtl.alpha = 0.25;\n        mtl.eta = 1.46; \/\/ PLA (pure); TODO: Pick something better for colored plastic.\n        mtl.scatter_mask = SCATTER_DIFFUSE;\n    }\n    else\n    {\n        mtl.specular = vec3(0.05, 0.05, 0.05);\n        mtl.diffuse = vec3(1.0, 0.0, 1.0) - mtl.specular;\n        mtl.alpha = 1.0;\n        mtl.eta = 1.46; \/\/ PLA (pure); TODO: Pick something better for colored plastic.\n    }\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ Schlick's approximation\nvec3 fresnel(vec3 f0, float i_dot_n)\n{\n    return f0 + (1.0 - f0) * pow(1.0 - max(0.0, i_dot_n), 5.0);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#if 0\n\/\/ BSDF = BRDF + BTDF\n\n\/\/ BRDF (reflection):\nf_r(i, o, n) = F(i, h) * G(i, o, h) * D(h) \/ (4 * |i.n| * |o.n|)\nh = h_r\n\/\/ with Smith G\nf_r(i, o, n) = F(i, h) * G1(i, h) * G1(o, h) * D(h) \/ (4 * |i.n| * |o.n|)\n\n\n\n\/\/ BTDF (refraction):\nf_t(i, o, n) = (|i.h| * |o.h|) \/ (|i.n| * |o.n|) * eta_o^2 * (1 - F(i, h)) * G(i, o, h) * D(h) \/ (eta_i * i.h + eta_o * o.h)^2\nh = h_t\n\/\/ with Smith G\nf_t(i, o, n) = (|i.h| * |o.h|) \/ (|i.n| * |o.n|) * eta_o^2 * (1 - F(i, h)) * G1(i, h) * G1(o, h) * D(h) \/ (eta_i * i.h + eta_o * o.h)^2\n\n\n\n\/\/ GGX distribution:\nD(m) = a_g^2 * chi_plus(m.n) \/ (PI * cos^4(theta_m) * (a_g^2 + tan^2(theta_m))^2)\nG1(v, m) = chi_plus(v.m \/ v.n) * 2.0 \/ (1.0 + sqrt(1.0 + a_g^2 * tan^2(theta_v)))\n\ntheta_m = arccos(m.n)\ntheta_v = arccos(v.n)\nchi_plus(a) = step(0.0, a)\n\n\n\np_m(m) = D(m) * |m.n|\n#endif\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat D_ggx(float m_dot_n, Material mtl)\n{\n    float theta_m = acos(m_dot_n);\n    float result = pow(mtl.alpha, 2.0) * step(0.0, m_dot_n) \/ (PI * pow(m_dot_n, 4.0) * pow(pow(mtl.alpha, 2.0) + pow(tan(theta_m), 2.0), 2.0));\n    \/* float result = pow(mtl.alpha, 2.0) \/ (PI * pow(pow(m_dot_n, 2.0) * (pow(mtl.alpha, 2.0) - 1.0) + 1.0, 2.0)); *\/\n    return result;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ Using Smith G approximation scheme:\n\/\/ G(i, o, n) = G1(i, n) * G1(o, n)\nfloat G1_ggx(float v_dot_m, float v_dot_n, Material mtl)\n{\n    float theta_v = acos(v_dot_n);\n    float result = step(0.0, v_dot_m \/ v_dot_n) * 2.0 \/ (1.0 + sqrt(1.0 + pow(mtl.alpha, 2.0) * pow(tan(theta_v), 2.0)));\n    \/* float result = 2.0 * v_dot_n \/ (v_dot_n + sqrt(pow(mtl.alpha, 2.0) + (1.0 - pow(mtl.alpha, 2.0)) * pow(v_dot_n, 2.0))); *\/\n    return result;\n}\n\n\/\/ Lambertian diffure BRDF.\nvec3 diffuse_brdf(vec3 i, vec3 o, vec3 n, Material mtl)\n{\n    vec3 f_r = mtl.diffuse \/ PI;\n    return f_r;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ Microfacet BRDF with GGX distribution.\nvec3 specular_brdf(vec3 i, vec3 o, vec3 n, Material mtl)\n{\n    float i_dot_n = dot(i, n);\n    float o_dot_n = dot(o, n);\n\n    vec3 h_r = sign(i_dot_n) * normalize(i + o);\n\n    float i_dot_h = dot(i, h_r);\n    float o_dot_h = dot(o, h_r);\n    float h_dot_n = dot(h_r, n);\n\n    vec3 F = fresnel(mtl.specular, i_dot_h);\n    float G1_i = G1_ggx(i_dot_h, i_dot_n, mtl);\n    float G1_o = G1_ggx(o_dot_h, o_dot_n, mtl);\n    float D = D_ggx(h_dot_n, mtl);\n\n    vec3 f_r = F * G1_i * G1_o * D \/ (4.0 * max(0.0, i_dot_n) * max(0.0, o_dot_n));\n    return clamp(f_r, 0.0, 1.0);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec3 btdf(vec3 i, vec3 o, vec3 n, float eta_i, float eta_o, Material mtl)\n{\n    float i_dot_n = dot(i, n);\n    float o_dot_n = dot(o, n);\n\n    vec3 h_t = -normalize(eta_i * i + eta_o * o);\n\n    float i_dot_h = dot(i, h_t);\n    float o_dot_h = dot(o, h_t);\n    float h_dot_n = dot(h_t, n);\n\n    vec3 F = fresnel(mtl.specular, i_dot_h);\n    float G1_i = G1_ggx(i_dot_h, i_dot_n, mtl);\n    float G1_o = G1_ggx(o_dot_h, o_dot_n, mtl);\n    float D = D_ggx(h_dot_n, mtl);\n\n    vec3 f_t = (max(0.0, i_dot_h) * max(0.0, o_dot_h)) \/ (max(0.0, i_dot_n) * max(0.0, o_dot_n)) *\n        pow(eta_o \/ eta_i, 2.0) * (1.0 - F) * G1_i * G1_o * D \/ pow(eta_i * i_dot_h + eta_o * o_dot_h, 2.0);\n    return clamp(f_t, 0.0, 1.0);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvoid setup_camera_orbit(\n        float radius,\n        float azimuth,\n        float elevation,\n        out vec3 cam_pos,\n        out vec3 cam_dir,\n        out vec3 cam_up)\n{\n    float cos_az = cos(azimuth);\n    float sin_az = sin(azimuth);\n\n    float cos_el = cos(elevation);\n    float sin_el = sin(elevation);\n\n    cam_pos = radius * vec3(\n            cos_az * cos_el,\n            sin_el,\n            sin_az * cos_el);\n    cam_dir = -normalize(cam_pos);\n    \/\/ up = vec3(\n    \/\/          cos(az) * cos(el + PI),\n    \/\/          sin(el + PI),\n    \/\/          sin(az) * cos(el + PI)),\n    \/\/ where\n    \/\/          cos(el + PI) == -sin(el)\n    \/\/          sin(el + PI) == cos(el)\n    cam_up = vec3(\n            cos_az * -sin_el,\n            cos_el,\n            sin_az * -sin_el);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ ray-plane intersection:\n\/* r = ray_pos + t * ray_dir *\/\n\/* dot(n, r) = d *\/\n\/* dot(n, r.pos + t * r.dir) = d *\/\n\/* dot(n, r.pos) + t * dot(n, r.dir) = d *\/\n\/* => t = (d - dot(n, r.pos)) \/ dot(n, r.dir) *\/\nbool intersect_ray_plane(vec3 ray_pos, vec3 ray_dir, Plane p, out float t)\n{\n    bool result = false;\n\n    float n_dot_dir = dot(p.normal, ray_dir);\n    if (abs(n_dot_dir) > 0.000001)\n    {\n        float n_dot_pos = dot(p.normal, ray_pos);\n        float t1 = (p.d - n_dot_pos) \/ n_dot_dir;\n        if (t1 >= 0.0)\n        {\n            t = t1;\n            result = true;\n        }\n    }\n\n    return result;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ ray-sphere intersection:\n\/* r = ray_pos + t * ray_dir *\/\n\/* ||r - origin|| == radius^2 *\/\n\/* v = r - origin = r.pos + t * r.dir - origin = (r.pos - origin) + t * r.dir = a + t * b *\/\n\/* dot(v, v) = R^2 *\/\n\/* dot(a + t * b, a + t * b) = dot(a,a) + 2*t*dot(a,b) + t*t*dot(b,b) = R^2 *\/\n\/* A = dot(b,b) *\/\n\/* B = 2*dot(a,b) *\/\n\/* C = dot(a,a)-R^2 *\/\n\/* => t = (-B +- sqrt(B*B - 4*A*C)) \/ (2*A) *\/\nbool intersect_ray_sphere(vec3 ray_pos, vec3 ray_dir, Sphere s, out float t)\n{\n    bool result = false;\n\n    float A = dot(ray_dir, ray_dir);\n    float B = 2.0 * dot(ray_pos - s.origin, ray_dir);\n    float C = dot(ray_pos - s.origin, ray_pos - s.origin) - s.radius * s.radius;\n    float det = B * B - 4.0 * A * C;\n    if (abs(A) > 0.0 && det >= 0.0)\n    {\n        float t1 = (-B - sqrt(det)) \/ (2.0 * A);\n        float t2 = (-B + sqrt(det)) \/ (2.0 * A);\n\n        if (t1 >= 0.0 && t2 >= 0.0)\n        {\n            t = min(t1, t2);\n            result = true;\n        }\n        else if (t1 >= 0.0)\n        {\n            t = t1;\n            result = true;\n        }\n        else if (t2 >= 0.0)\n        {\n            t = t2;\n            result = true;\n        }\n    }\n\n    return result;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ NOTE: We use prev_id to identify an object the ray collided with on the previous trace step.\n\/\/ In general this approach is wrong, because objects should be allowed to cast shadows on themselves,\n\/\/ but in our scene all objects are either convex (spheres) and flat (plane). So, self-shadowing is\n\/\/ not possible anyway.\nint raytrace(int prev_id, vec3 ray_pos, vec3 ray_dir, out vec3 pos, out vec3 normal)\n{\n    int id = 0;\n    float t_min = 1000.0;\/\/ camera_far;\n    float t;\n\n    if (prev_id != SCENE_PLASTIC_BALL && intersect_ray_sphere(ray_pos, ray_dir, diffuse_ball, t))\n    {\n        t_min = t;\n        pos = ray_pos + t * ray_dir;\n        normal = normalize(pos - diffuse_ball.origin);\n        id = SCENE_PLASTIC_BALL;\n    }\n    if (prev_id != SCENE_GOLDEN_BALL && intersect_ray_sphere(ray_pos, ray_dir, specular_ball, t) && t < t_min)\n    {\n        t_min = t;\n        pos = ray_pos + t * ray_dir;\n        normal = normalize(pos - specular_ball.origin);\n        id = SCENE_GOLDEN_BALL;\n    }\n    if (prev_id != SCENE_GLASS_BALL && intersect_ray_sphere(ray_pos, ray_dir, glass_ball, t) && t < t_min)\n    {\n        t_min = t;\n        pos = ray_pos + t * ray_dir;\n        normal = normalize(pos - glass_ball.origin);\n        id = SCENE_GLASS_BALL;\n    }\n    if (prev_id != SCENE_FLOOR && intersect_ray_plane(ray_pos, ray_dir, checker_floor, t) && t < t_min)\n    {\n        t_min = t;\n        pos = ray_pos + t * ray_dir;\n        normal = checker_floor.normal;\n        id = SCENE_FLOOR;\n    }\n\n    return id;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    camera_azimuth = 2.0 * PI * (0.5 + iMouse.x \/ iResolution.x);\n    camera_elevation = 0.5 * PI * (0.25 + iMouse.y \/ iResolution.y);\n\n    setup_camera_orbit(\n        camera_orbit_radius,\n        camera_azimuth,\n        camera_elevation,\n        camera_pos,\n        camera_dir,\n        camera_up);\n    vec3 camera_right = cross(camera_up, camera_dir);\n\n    \/\/ NxN anti-aliasing.\n    vec3 pixel_radiance = vec3(0.0, 0.0, 0.0);\n    for (int aa_x = 0; aa_x < AA_COUNT; ++aa_x)\n    {\n        for (int aa_y = 0; aa_y < AA_COUNT; ++aa_y)\n        {\n            vec2 aa_sample_offset = vec2(aa_x, aa_y) \/ float(AA_COUNT);\n            vec2 uv = (fragCoord.xy + aa_sample_offset) \/ iResolution.xy;\n            \/\/ uv = 2.0 * uv - 1.0;\n            \/\/ uv.x *= camera_aspect_ratio;\n\n            vec3 ray_pos = camera_pos;\n            vec3 ray_far = camera_pos +\n                camera_far * camera_dir +\n                camera_far_half_width * (-1.0 + 2.0 * uv.x) * camera_right +\n                camera_far_half_height * (-1.0 + 2.0 * uv.y) * camera_up;\n            vec3 ray_dir = normalize(ray_far - ray_pos);\n\n            vec3 radiance = vec3(0.0, 0.0, 0.0);\n            vec3 L_i = light_radiance;\n\n            int id = 0;\n            for (int bounce = 0; bounce < MAX_BOUNCE_COUNT; ++bounce)\n            {\n                vec3 pos, n;\n                id = raytrace(id, ray_pos, ray_dir, pos, n);\n\n                if (id > 0)\n                {\n                    Material mtl;\n                    get_material(pos, id, mtl);\n\n                    vec3 l = normalize(light_pos - pos);\n                    \/* vec3 v = normalize(camera_pos - pos); *\/\n                    vec3 i = -ray_dir;\n\n                    \/\/ TODO\n#if ENABLE_SHADOWS\n                    vec3 dummy_pos, dummy_normal;\n                    int shadow_id = raytrace(id, pos, l, dummy_pos, dummy_normal);\n                    float shadow = (shadow_id == 0) ? 1.0 : 0.0;\n#else\n                    float shadow = 1.0;\n#endif\n\n                    if (mtl.scatter_mask == SCATTER_DIFFUSE)\n                    {\n                        radiance += L_i * shadow * PI * max(0.0, dot(l, n)) * diffuse_brdf(i, l, n, mtl);\n                        L_i = vec3(0.0, 0.0, 0.0);\n\n                        break;\n                    }\n                    else if (mtl.scatter_mask == SCATTER_SPECULAR)\n                    {\n                        radiance += L_i * shadow * PI * max(0.0, dot(l, n)) * specular_brdf(i, l, n, mtl);\n\n                        vec3 m = n;\n                        vec3 R_theta = fresnel(mtl.specular, dot(i, m));\n                        R_theta = clamp(R_theta, 0.0, 1.0);\n\n                        bvec3 flags = greaterThan(R_theta, vec3(0.0, 0.0, 0.0));\n                        if (any(flags))\n                        {\n                            vec3 o_r = 2.0 * max(0.0, dot(i, m)) * m - i;\n                            vec3 f_r = specular_brdf(i, o_r, m, mtl);\n\n                            L_i *= R_theta;\/\/f_r;\n                            ray_pos = pos;\n                            ray_dir = o_r;\n                        }\n                    }\n                    else if (mtl.scatter_mask == SCATTER_TRANSPARENT)\n                    {\n                        float eta_i = eta_air;\n                        float eta_o = mtl.eta;\n                        if (dot(i, n) <= 0.0) \/\/ Ray exiting the object?\n                        {\n                            float eta_i = mtl.eta;\n                            float eta_o = eta_air;\n                            n = -n;\n                        }\n\n                        radiance += L_i * shadow * PI * max(0.0, dot(l, n)) * btdf(i, l, n, eta_i, eta_o, mtl);\n                        id = 0;\n\n                        vec3 m = n;\n                        vec3 R_theta = fresnel(mtl.specular, dot(i, m));\n                        R_theta = clamp(R_theta, 0.0, 1.0);\n\n                        bvec3 flags = greaterThan(vec3(1.0, 1.0, 1.0) - R_theta, vec3(0.0, 0.0, 0.0));\n                        if (any(flags))\n                        {\n                            float c = dot(i, m);\n                            float eta = eta_i \/ eta_o;\n\n                            vec3 o_t = (eta * c - sign(dot(i, n)) * sqrt(1.0 + eta * (c * c - 1.0))) * m - eta * i;\n                            vec3 f_t = btdf(i, o_t, m, eta_i, eta_o, mtl);\n\n                            L_i *= vec3(1.0, 1.0, 1.0) - R_theta;\/\/f_t;\n                            ray_pos = pos + 0.000001 * o_t;\n                            ray_dir = o_t;\n                            id = 0;\n                        }\n                    }\n                }\n                else\n                {\n                    break;\n                }\n            }\n\n            pixel_radiance += radiance;\n        }\n    }\n\n    fragColor.rgb = pixel_radiance \/ float(AA_COUNT * AA_COUNT);\n\n    \/\/ TODO: Tonemapping.\n\n    \/\/ Linear to gamma (sRGB) color space conversion (approximated).\n    float inv_gamma = 1.0 \/ 2.2;\n    fragColor.rgb = pow(fragColor.rgb, vec3(inv_gamma, inv_gamma, inv_gamma));\n}\n","name":"","description":"","type":"image"}]}}