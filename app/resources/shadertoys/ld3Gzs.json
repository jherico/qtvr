{"Shader":{"ver":"0.1","info":{"id":"ld3Gzs","date":"1451699625","viewed":124,"name":"Radiolarian #2 shaded","username":"tdhooper","description":"Sources:<br\/>* https:\/\/www.shadertoy.com\/view\/Mdt3RX<br\/>* https:\/\/www.shadertoy.com\/view\/XljGDz<br\/>* https:\/\/www.shadertoy.com\/view\/Xt2XDt","likes":7,"published":3,"flags":0,"tags":["reflection","sdf","lighting","modgeometry"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define PHI (sqrt(5.)*0.5 + 0.5)\n#define PI 3.14159265\n\n#define t iGlobalTime\n\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n    float m = max(a, b);\n    if ((-a < r) && (-b < r)) {\n        return max(m, -(r - sqrt((r+a)*(r+a) + (r+b)*(r+b))));\n    } else {\n        return m;\n    }\n}\n\n\n\/\/ Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n    vec2 q = vec2(length(p.xz), p.y);\n    vec2 tip = q - vec2(0, height);\n    vec2 mantleDir = normalize(vec2(height, radius));\n    float mantle = dot(tip, mantleDir);\n    float d = max(mantle, -q.y);\n    float projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n    \n    \/\/ distance to tip\n    if ((q.y > height) && (projected < 0.)) {\n        d = max(d, length(tip));\n    }\n    \n    \/\/ distance to base ring\n    if ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n        d = max(d, length(q - vec2(radius, 0)));\n    }\n    return d;\n}\n\n\/\/ Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n    float t = dot(p, planeNormal)+offset;\n    if (t < 0.) {\n        p = p - (2.*t)*planeNormal;\n    }\n    return sign(t);\n}\n\n\/\/ Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n\/\/ Read like this: R(p.xz, a) rotates \"x towards z\".\n\/\/ This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n\/\/ The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n    float m = min(a, b);\n    if ((a < r) && (b < r) ) {\n        return min(m, r - sqrt((r-a)*(r-a) + (r-b)*(r-b)));\n    } else {\n     return m;\n    }\n}\n\n\/\/ Repeat around the origin by a fixed angle.\n\/\/ For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = 2.*PI\/repetitions;\n    float a = atan(p.y, p.x) + angle\/2.;\n    float r = length(p);\n    float c = floor(a\/angle);\n    a = mod(a,angle) - angle\/2.;\n    p = vec2(cos(a), sin(a))*r;\n    \/\/ For an odd number of repetitions, fix cell index of the cell in -x direction\n    \/\/ (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if (abs(c) >= (repetitions\/2.)) c = abs(c);\n    return c;\n}\n\n\nvec3 pModDodecahedron(inout vec3 p) {\n    vec3 v1 = normalize(vec3(0., PHI, 1.));\n    vec3 v2 = normalize(vec3(PHI, 1., 0.));\n\n    float sides = 5.;\n    float dihedral = acos(dot(v1, v2));\n    float halfDdihedral = dihedral \/ 2.;\n    float faceAngle = 2. * PI \/ sides;\n    \n    p.z = abs(p.z);\n    \n    pR(p.xz, -halfDdihedral);\n    pR(p.xy, faceAngle \/ 4.);\n    \n    p.x = -abs(p.x);\n    \n    pR(p.zy, halfDdihedral);\n    p.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    pR(p.xy, faceAngle);\n    \n    pR(p.zy, halfDdihedral);\n    p.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    pR(p.xy, faceAngle);\n    \n    pR(p.zy, halfDdihedral);\n    p.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    pR(p.xy, faceAngle);\n    \n    pR(p.zy, halfDdihedral);\n    p.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    p.z = -p.z;\n    pModPolar(p.yx, sides);\n    pReflect(p, vec3(-1, 0, 0), 0.);\n    \n    return p;\n}\n\nvec3 pModIcosahedron(inout vec3 p) {\n\n    vec3 v1 = normalize(vec3(1, 1, 1 ));\n    vec3 v2 = normalize(vec3(0, 1, PHI+1.));\n\n    float sides = 3.;\n    float dihedral = acos(dot(v1, v2));\n    float halfDdihedral = dihedral \/ 2.;\n    float faceAngle = 2. * PI \/ sides;\n    \n\n    p.z = abs(p.z);    \n    pR(p.yz, halfDdihedral);\n    \n    p.x = -abs(p.x);\n    \n    pR(p.zy, halfDdihedral);\n    p.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    pR(p.xy, faceAngle);\n    \n    pR(p.zy, halfDdihedral);\n    p.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    pR(p.xy, faceAngle);\n     \n    pR(p.zy, halfDdihedral);\n    p.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    pR(p.xy, faceAngle);\n  \n    pR(p.zy, halfDdihedral);\n    p.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    p.z = -p.z;\n    pModPolar(p.yx, sides);\n    pReflect(p, vec3(-1, 0, 0), 0.);\n\n    return p;\n}\n\nfloat spikeModel(vec3 p) {\n    pR(p.zy, PI\/2.);\n    return fCone(p, 0.25, 3.);\n}\n\nfloat spikesModel(vec3 p) {\n    float smooth = 0.6;\n    \n    pModDodecahedron(p);\n    \n    vec3 v1 = normalize(vec3(0., PHI, 1.));\n    vec3 v2 = normalize(vec3(PHI, 1., 0.));\n\n    float sides = 5.;\n    float dihedral = acos(dot(v1, v2));\n    float halfDdihedral = dihedral \/ 2.;\n    float faceAngle = 2. * PI \/ sides;\n    \n    float spikeA = spikeModel(p);\n    \n    pR(p.zy, -dihedral);\n\n    float spikeB = spikeModel(p);\n\n    pR(p.xy, -faceAngle);\n    pR(p.zy, dihedral);\n    \n    float spikeC = spikeModel(p);\n    \n    return fOpUnionRound(\n        spikeC,\n        fOpUnionRound(\n            spikeA,\n            spikeB,\n            smooth\n        ),\n        smooth\n    );\n}\n\nfloat coreModel(vec3 p) {\n    float outer = length(p) - .9;\n    float spikes = spikesModel(p);\n    outer = fOpUnionRound(outer, spikes, 0.4);\n    return outer;\n}\n\nfloat exoSpikeModel(vec3 p) {\n    pR(p.zy, PI\/2.);\n    p.y -= 1.;\n    return fCone(p, 0.5, 1.);\n}\n\nfloat exoSpikesModel(vec3 p) {\n    pModIcosahedron(p);\n\n    vec3 v1 = normalize(vec3(1, 1, 1 ));\n    vec3 v2 = normalize(vec3(0, 1, PHI+1.));\n\n    float dihedral = acos(dot(v1, v2));\n\n    float spikeA = exoSpikeModel(p);\n    \n    pR(p.zy, -dihedral);\n\n    float spikeB = exoSpikeModel(p);\n\n    return fOpUnionRound(spikeA, spikeB, 0.5);\n}\n\nfloat exoHolesModel(vec3 p) {\n    float len = 3.;\n    pModDodecahedron(p);\n    p.z += 1.5;\n    return length(p) - .65;\n}\n\nfloat exoModel(vec3 p) {    \n    float thickness = 0.18;\n    float outer = length(p) - 1.5;\n    float inner = outer + thickness;\n\n    float spikes = exoSpikesModel(p);\n    outer = fOpUnionRound(outer, spikes, 0.3);\n    \n    float shell = max(-inner, outer);\n\n    float holes = exoHolesModel(p);\n    shell = fOpIntersectionRound(-holes, shell, thickness\/2.);\n    \n    return shell;\n}\n\nvec3 pRoll(inout vec3 p) {\n    \/\/return p;\n    float s = 5.;\n    float d = 0.01;\n    float a = sin(t * s) * d;\n    float b = cos(t * s) * d;\n    pR(p.xy, a);\n    pR(p.xz, a + b);\n    pR(p.yz, b);\n    return p;\n}\n\nfloat doExo(vec3 p) {\n\t\/\/return length(p + vec3(0,0,-2)) - 3.;\n\tpRoll(p);\n    \/\/float disp = (sin(length(p) * 5. - t * 8.)) * 0.03;\n    return exoModel(p);\n}\n\nfloat doCore(vec3 p) {\n\t\/\/return length(p + vec3(0,0,2)) - 3.;\n\tpRoll(p);\n    return coreModel(p);\n}\n\nfloat lerp(float a, float b, float s) {\n\treturn a + (b - a) * s;\n}\n\nvec3 lerp(vec3 a, vec3 b, float s) {\n\treturn a + (b - a) * s;\n}\n\nvec3 envLight(vec3 col, vec3 rayDir, float blur) {\n\tfloat shiny = 0.;\n\tfloat blurry = 0.;\n    \n    \/\/rayDir.x = mod(rayDir.x + t, 1.);\n\n    if (\n        (rayDir.y > abs(rayDir.x) * 3.5)\n        &&\n        (rayDir.y > abs(rayDir.z * 0.))\n    ) {\n        shiny += rayDir.y;\n    }\n    \n\tshiny += max(rayDir.y, 0.);\n    blurry += acos(dot(normalize(vec3(0,-1,0)), normalize(rayDir))) \/ PI;\n    blurry *= 0.3;\n    blurry += pow(max(rayDir.y, 0.), 2.) * 0.5;\n    return col * lerp(shiny, blurry, blur);\n}\n\n\/\/ from https:\/\/www.shadertoy.com\/view\/XljGDz\nvec3 GetEnvColor2(vec3 rayDir, float blur) {\n\t\/\/pR(rayDir.zy, sin(-t * 1.));\n\tpR(rayDir.xz, PI * 0.5);\n    rayDir = normalize(rayDir);\n    vec3 light1 = envLight(vec3(0,1.2,1.4) * .8, rayDir, blur);\n\tpR(rayDir.xy, PI);\n    rayDir = normalize(rayDir);\n    vec3 light2 = envLight(vec3(.15), rayDir, blur);\n\treturn light1 + light2;\n}\n\n\nvec3 doBackground(vec3 rayVec) {\n    \/\/return GetEnvColor2(rayVec, 0.5);\n    return vec3(.13);\n}\n\nvec3 doMaterial(in vec3 p, in vec3 nor, vec3 ref, float blur) {\n    return GetEnvColor2(ref, blur);\n}\n\nvec3 doExoMaterial(vec3 pos, vec3 nor, vec3 ref) {\n    return doMaterial(pos, nor, ref, .0);\n}\n\nvec3 doCoreMaterial(vec3 pos, vec3 nor, vec3 ref) {\n    vec3 mat = doMaterial(pos, nor, ref, 1.);\n    float light = max(3. - length(pos), 0.);\n    \n    float r = 0.2;\n    float stripe = mod(light, r * 2.);\n    if (stripe > r) {\n    \tmat = vec3(length(mat)) * 0.1;\n    }\n\treturn mat;\n}\n\n\n\/\/ The MINIMIZED version of https:\/\/www.shadertoy.com\/view\/Xl2XWt\n\n\nconst float MAX_TRACE_DISTANCE = 20.0;           \/\/ max trace distance\nconst float INTERSECTION_PRECISION = 0.001;        \/\/ precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\n\n\n\/\/ checks to see which intersection is closer\n\/\/ and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n\n\/\/--------------------------------\n\/\/ Modelling \n\/\/--------------------------------\nvec2 map( vec3 p ){  \n    \n \tvec2 res = vec2(doExo(p) ,1.); \n    res = opU(res, vec2(doCore(p) ,2.));\n    \n    return res;\n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n\n\/\/----\n\/\/ Camera Stuffs\n\/\/----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera(out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse) {\n    \n  \tfloat x = .366 + (mouse.x * 0.5);\n    float y = .7 + (mouse.y * 0.33);\n    \n    float an = 10.0 * x + PI \/ 2.;\n    \/\/an = 10.;\n\n    \/\/float d = 2. + sin(an) * 1.6;\n    float d = 2. + (1. - y) * 10.;\n    camPos = vec3(\n        sin(an),\n        sin(y * PI \/ 2.),\n        cos(an)\n    ) * d;\n\n    camTar = vec3(0);\n}\n\n\n\/\/ Calculates the normal by taking a very small distance,\n\/\/ remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\n\n\nvec3 render( vec2 res , vec3 ro , vec3 rd ){\n   \n\n  vec3 color = doBackground(rd);\n    \n  if( res.y > -.5 ){\n      \n    vec3 pos = ro + rd * res.x;\n    vec3 norm = calcNormal( pos );\n    vec3 ref = reflect(rd, norm);\n      \n    \/\/ Exo\n    if( res.y == 1. ){\n\n        color = doExoMaterial(pos, norm, ref);\n    \n    \/\/ Core\n    }else if(res.y == 2. ){\n        \n\t\tcolor = doCoreMaterial(pos, norm, ref);\n        \n    }\n        \n        \n  }\n   \n  return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)\/iResolution.y;\n    vec2 m = iMouse.xy \/ iResolution.xy;\n\n    vec3 ro = vec3( 0., 0., 2.);\n    vec3 ta = vec3( 0. , 0. , 0. );\n    \n    \/\/ camera movement\n    doCamera(ro, ta, iGlobalTime, m);\n    \n    \/\/ camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  \/\/ 0.0 is the camera roll\n    \n\t\/\/ create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); \/\/ 2.0 is the lens length\n    \n    vec2 res = calcIntersection( ro , rd  );\n\n\t\n    vec3 color = render( res , ro , rd );\n    \n\tfragColor = vec4(color,1.0);\n\n    \n    \n}","name":"","description":"","type":"image"}]}}