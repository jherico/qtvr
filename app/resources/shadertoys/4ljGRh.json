{"Shader":{"ver":"0.1","info":{"id":"4ljGRh","date":"1426847425","viewed":1875,"name":"[NV15] Tiny Cutting Planet","username":"aiekick","description":"Tiny Planet","likes":16,"published":3,"flags":0,"tags":["space","planet","tiny","nv15"],"hasliked":0},"renderpass":[{"inputs":[{"id":10,"src":"\/presets\/tex09.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":23,"src":"\/presets\/cube01_0.png","ctype":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"id":26,"src":"\/presets\/cube04_0.png","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Stephane Cuillerdier - Aiekick\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/Uni\nvec2 screen = iResolution.xy;\nfloat time = iGlobalTime;\n\nfloat PI = 3.14159;\n\n\/\/ Ground Vars\nvec2 NoiseVar = vec2(950.,800.);\n\n\/\/ Time Speed +> Morphing, PlanetRotate, Sky\nvec3 tSpeed = vec3(0.8, 0.3, 1.5);\n\n\/\/ Offset +> planetSectionoffset, GroundThickness, Displace Range\nvec3 Offset = vec3(2.1, .05, 1.);\n\n\/\/Radius +> Water, Planet, Kernel, CutterRoundBoxCorner\nvec4 Radius = vec4(3.02, 3., 2.25, 0.1);\n\n\/\/Range Stratum +> STONE, SNOW, SAND_WATER_OFFSET\nvec3 Range = vec3(.2, .4, .015);\n\n\/\/ temperature +> KERNEL, MANTLE0, MANTLE1\nvec3 Temp = vec3(2200.,2200.,400.);\n\n\/\/ COLORS\nvec3 WATER_COLOR = vec3(0., 0., 1.);\nvec3 GROUND_COLOR = vec3(0., .7, 0.);\nvec3 STONE_COLOR = vec3(.5, .46, .4);\nvec3 SNOW_COLOR = vec3(1., 1., 1.);\nvec3 SAND_COLOR = vec3(1., .9, .45);\n\nvec3 MASK_GROUND_COLOR = vec3(0.5, 0., 0.);\nvec3 MASK_MANTLE_COLOR = vec3(0., 0.5, 0.);\nvec3 MASK_KERNEL_COLOR = vec3(0., 0., 0.5);\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nfloat dstepf = 0.;\n\nvec2 pRot = vec2(0.); \/\/ Planet Rotation\n\n\/\/ rxy = rot xy for planet, kernel and water\n\/\/ rcxy = rot xy for cutter\nmat3 rxy, rcxy;\n\nfloat random(float p) {return fract(sin(p)*NoiseVar.x);}\nfloat noise(vec2 p) {return random(p.x + p.y*NoiseVar.y);}\nvec2 sw(vec2 p) {return vec2( floor(p.x) , floor(p.y) );}\nvec2 se(vec2 p) {return vec2( ceil(p.x)  , floor(p.y) );}\nvec2 nw(vec2 p) {return vec2( floor(p.x) , ceil(p.y)  );}\nvec2 ne(vec2 p) {return vec2( ceil(p.x)  , ceil(p.y)  );}\nfloat snoise(vec2 p) {\n  \tvec2 inter = smoothstep(0., 1., fract(p));\n  \tfloat s = mix(noise(sw(p)), noise(se(p)), inter.x);\n  \tfloat n = mix(noise(nw(p)), noise(ne(p)), inter.x);\n  \treturn mix(s, n, inter.y);\n}\n\nvec3 blackbody(float Temp){\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. \/ 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. \/ 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)\/255.;\n    if (Temp < 1000.) col *= Temp\/1000.;\n   \treturn col;\n}\n\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5+0.5*(b-a)\/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);}\n\nfloat owater(vec3 p){\n    return length(p)-Radius.x;\n}\nfloat oplanet( vec3 p ){\n   \tp *= rxy;\n  \tfloat d1 = length(p)-Radius.y;\n  \tfloat d2 = snoise(p.yx)*snoise(p.zy)*snoise(p.zx)*Offset.z; \/\/ displacement\n    float ud = d1-d2;\n    return ud<=Radius.x?ud+0.05:ud-0.05;\/\/ on creuse pour marquer la flotte\n}\nfloat okernel( vec3 p ){\n    return length(p*rxy)-Radius.z;\n}\nfloat ocutter( vec3 p ){\n    vec3 q = p*rcxy+Offset.x;\n    float dB = length(max(abs(q+1.35)-2.5,0.0))-Radius.w;\n    float dS = length(q+.5)-2.5;\n    return mix(dB, dS, sin(time*tSpeed.x)\/2.+.5);\n}\nfloat map(vec3 p){   \n    dstepf += 0.005;\n    return smin(max(-ocutter(p), min(owater(p), oplanet(p))), okernel(p), 0.05);\n}\n\n\/\/ normal calc based on nimitz shader https:\/\/www.shadertoy.com\/view\/4sSSW3\nvec3 getNormal(const in vec3 p, float rmPrec){  \n    vec2 e = vec2(-1., 1.)*rmPrec;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );\n}\n\n\/\/ sky from iapafoto shader => https:\/\/www.shadertoy.com\/view\/Xtl3zM\nvec3 getSky(float offTime, vec3 size, sampler2D cloudTex, vec2 uv){\n    \/\/stereo dir\n    float t = 3.+offTime*.08;\n    float ct = cos(t);\n    float st = sin(t);\n\tfloat m = .55;\n    uv = (uv * 2. * m - m)*3.;\n    uv.x *= size.x\/size.y;\n    uv *= mat2(ct,st,-st,ct);\n\tvec3 rd = normalize(vec3(2.*uv.x,dot(uv,uv)-1.,2.*uv.y));\n\tvec3 col = 2.5*vec3(0.18,0.33,0.45) - rd.y*1.5;\n    col *= 0.9;\n\tvec2 cuv = rd.xz*(1000.0)\/rd.y;\n    float cc = 1.;\n    float cc0 = texture2D( cloudTex, 0.00015*cuv +0.1+ 0.0043*offTime ).x;\n    float cc1 = 0.35*texture2D( cloudTex, 0.00015*2.0*cuv + 0.0043*.5*offTime ).x;\n    cc = 0.65*cc1 + cc0;\n    cc = smoothstep( 0.3, 1.0, cc0 );\n  \tcol = mix( col, vec3(0.95), 0.9*cc );\n    col = .35+.65*col;  \/\/ less background sky => higlight the Ball\n   \treturn col;}\n\nmat3 getRotXMat(float a){return mat3(1.,0.,0.,0.,cos(a),-sin(a),0.,sin(a),cos(a));}\nmat3 getRotYMat(float a){return mat3(cos(a),0.,sin(a),0.,1.,0.,-sin(a),0.,cos(a));}\nmat3 getRotZMat(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cu, vec3 cv)\n{\n\tvec3 rov = normalize(cv-ro);\n    vec3 u =  normalize(cross(cu, rov));\n    vec3 v =  normalize(cross(rov, u));\n    vec3 rd = normalize(rov + u*uv.x + v*uv.y);\n    return rd;\n}\n\nvoid mainImage( out vec4 fr, in vec2 g )\n{\n   \tvec2 si = iResolution.xy;\n   \t\n    vec3 col = vec3(0.);\n    float b = 0.1;\n       \n    float a = 1.; \/\/ alpha\n    \n    float rmPrec = 5e-4; \/\/ RM Precision\n\tfloat Zero = 1e-6;\n   \n    pRot -= time*tSpeed.y;\n\trxy = getRotXMat(pRot.x)*getRotYMat(pRot.y);\n  \trcxy = getRotZMat(PI)*getRotXMat(-PI\/5.)*getRotYMat(PI\/4.);\n    \n    \/\/Camera init\n    float ca = PI; \/\/ angle z\n    float ce = 0.; \/\/ elevation\n    float cd = 5.; \/\/ distance to origin axis\n    vec3 cu=vec3(0,1,0);\/\/Change camere up vector here\n    vec3 cv=vec3(0,0,0); \/\/Change camere view here\n    vec2 uv = (g+g-si)\/min(si.x, si.y);\n    vec3 ro = vec3(-sin(ca)*cd, ce, cos(ca)*cd); \/\/\n    vec3 rd = cam(uv, ro, cu, cv);\n    \n  \t\/\/Raymarching\n    vec2 RMPrec = vec2(1., .7); \n    vec2 DPrec = vec2(.0001, 10.); \n\tvec3 p = vec3(0.);\n  \tfloat s=DPrec.x;\n    float f=0.;\n    float iterUsed = 0.;\n    for(int i=0;i<40;i++) \n  \t{\n        iterUsed++;\n    \tif (abs(s)<DPrec.x||f>DPrec.y) break;\n    \tp = ro + rd * f;\n        s = map(p)*(s>DPrec.x?RMPrec.x:RMPrec.y);\n        f+=s;\n  \t}\n    \n\tvec3 c = vec3(0.);\n\t\n    if (f<DPrec.y)\n    {\n     \tvec3 n = getNormal(p,1.\/iterUsed);\n     \tvec3 np = normalize(p);\n\n      \tb += dot(n,np)*0.8;\n   \n      \tfloat d = length(p);\n       \tfloat range_ratio = (d-Radius.y);\n       \tfloat planet = oplanet(p);\n       \tfloat water = owater(p);\n\n      \t\/\/ CUTTER\n      \tfloat kernel = okernel(p);\n      \tfloat cutter = ocutter(p); \n\n        c = GROUND_COLOR;\n        if ( cutter <= Zero) \/\/ cut coloring\n        { \n         \tif ( water <= Zero && planet >= Zero ) c = WATER_COLOR;\n           \tif ( planet <= Zero && planet >= -Offset.y ) c = GROUND_COLOR;\n         \telse\n          \t{\n      \t\t\tc = blackbody(Temp.z); \/\/ limit between volumes\n     \t\t\tif ( d <= Radius.y ) \/\/ mantle\n        \t\t{\n           \t\t\tfloat ratio = (d-Radius.z)\/(Radius.y - Radius.z);\n             \t\tc = blackbody(mix(Temp.y, Temp.z, ratio));\n          \t\t}\n        \t}   \n        \tif ( kernel <= 1e-4) { c = blackbody(Temp.x);  } \/\/ kernel\n\t\t}    \n\n       \tif ( water <= rmPrec && planet > Zero ) c = WATER_COLOR;\n       \telse if ( water <= Range.z && water > Zero && planet > Zero ) c = SAND_COLOR;\n        else if ( planet >= Zero ) c = GROUND_COLOR;\n\n      \tif ( range_ratio >= Range.x && planet >= -Offset.y*(1.-Range.x\/range_ratio)*8. ) c = STONE_COLOR;\n        if ( range_ratio >= Range.y && planet >= -Offset.y*(1.-Range.y\/range_ratio)*5. ) c = SNOW_COLOR;\n            \n      \tif (cutter>Zero) \n      \t{\n       \t\tvec3 rayReflect = reflect(ro, n);\n      \t\tvec3 cube = textureCube(iChannel1, rayReflect).rgb;  \n        \tcol = mix(col, b*c+cube\/b+pow(b,15.0)*(1.-f*.01), 0.5);\n      \t}\n       \telse \n      \t{\n       \t\tb += 0.1;\n       \t\tcol = mix(col, (b*c+pow(b,8.0))*(1.0-f*.01), 1.0);\n     \t}\n    }\n    else \/\/ draw sky and weird light ray\n    { \n        vec3 sky = getSky(time*tSpeed.z, iResolution, iChannel2, g.xy \/ screen);\n        \/\/ weird light\n        float t1 = 0.5*sin(time*tSpeed.z)+0.5;\n        vec3 uvv = vec3(uv,t1*uv.y)*-1.;\n        vec3 cube = textureCube(iChannel0, uvv).rgb; \n        vec3 envt = mix(sky,cube,0.3);\n        col = mix(col, envt, 1.25); \n    }    \n\n    col += dstepf;\n    \n    fr = vec4(col, 1.);\n}","name":"","description":"","type":"image"}]}}