{"Shader":{"ver":"0.1","info":{"id":"lts3WX","date":"1425843066","viewed":678,"name":"Geometric Antialiasing","username":"CloneDeath","description":"calculating a realtime antialiasing stencil buffer based on the input geometry.<br\/><br\/>Set APPLY_ANTIALIASING to false at the top to disable antialiasing, as a comparison.","likes":1,"published":3,"flags":0,"tags":["antialiasing","realtime","geometric"],"hasliked":0},"renderpass":[{"inputs":[{"id":1,"src":"\/presets\/tex00.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":28,"src":"\/presets\/tex15.png","ctype":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define APPLY_ANTIALIASING true\n\n\/\/ We move the edge over time, to show motion alias artefacts\nfloat time = (iGlobalTime + 5.0) \/ 100.0;\n\n\/\/ The vertex shader is responsible for computing the three edge line equations based\n\/\/ on the 3 vertex coordinates. It is just a simple cross product of the points.\nvec3 edgeLine1 = vec3(0.0, -1.0, time);\nvec3 edgeLine2 = vec3(0.9, 0.1, -time);\nvec3 edgeLine3 = vec3(-0.7, 0.3, time);\n\n\nfloat mult(in vec3 v1, in vec3 v2){\n \treturn (v1.x * v2.x) + (v1.y * v2.y) + (v1.z * v2.z);\n}\n\nfloat getOverlap(vec3 dist, float maxdist){\n \tvec3 overlap = 1.0-smoothstep(0.0, maxdist, dist);\n    overlap = overlap * overlap;\n    return overlap.x * overlap.y * overlap.z;\n}\n\nfloat getOverlapAlias(vec3 dist, float maxdist){\n\tvec3 overlap = 1.0 - step(maxdist, dist);   \n    return overlap.x * overlap.y * overlap.z;\n}\n\nvec3 getPoint(vec3 edge1, vec3 edge2){\n\tvec3 point = cross(edge1, edge2);\n    point.xyz \/= point.z;\n    return point;\n}\n\nvec3 skewPoint(vec3 point){\n \treturn point;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 backCoord = vec3(fragCoord \/ iResolution.xy, 1.0);\n    \n    vec3 texCoord = vec3(backCoord);\n    vec3 texTL = getPoint(edgeLine1, edgeLine2);\n    texCoord = texCoord - texTL;\n    \n    texCoord = skewPoint(texCoord);\n    \n    \n    \n    float coverage = 0.0;\n    \n    vec3 dist = vec3(-mult(edgeLine1, backCoord),\n                \t -mult(edgeLine2, backCoord),\n            \t\t -mult(edgeLine3, backCoord));\n    \n    float tolerance = 1.0\/sqrt((iResolution.x * iResolution.x) + (iResolution.y * iResolution.y));\n    \n    float overlay;\n    if (APPLY_ANTIALIASING){\n    \toverlay = getOverlap(dist, tolerance);\n    } else {\n    \toverlay = getOverlapAlias(dist, tolerance);\n    }\n    \n    vec4 texColor = texture2D(iChannel0, texCoord.xy);\n    vec4 backColor = texture2D(iChannel1, backCoord.xy);\n    fragColor = mix(backColor, texColor, overlay);\n}","name":"","description":"","type":"image"}]}}