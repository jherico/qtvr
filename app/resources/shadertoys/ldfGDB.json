{"Shader":{"ver":"0.1","info":{"id":"ldfGDB","date":"1378265618","viewed":979,"name":"IntersectCoordSys","username":"iq","description":"intersectRect(): intersects arbitrarily oriented 2D rectangles (or any other planar shape) in 3D. The rectangle\/domain is defined by its center position and two orthogonal axes. The 2D intersection coordinates are computed by the function.","likes":5,"published":3,"flags":0,"tags":["3d","raytracing","rectangle"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/================================================================================================\n\/\/ (from http:\/\/www.iquilezles.org\/blog\/?p=2315)\n\/\/\n\/\/ Say you want to intersect a ray with a planar coordinate system (a regular plane \n\/\/ with a center point and two perpendicular vectors defining a 2D coordinate system). \n\/\/ You are interesting in getting the distance to the intersection point along the ray (t), \n\/\/ and the 2D coordinates of the intersection point in the coordinates system of the \n\/\/ plane (s,t). So, given you ray with origin o and direction d, and your plane with \n\/\/ center c and generating vectors u and v, you can proceed in two ways:\n\/\/\n\/\/ [1] The traditional way: computing the intersection with the plane (t), then project \n\/\/     its relative position with respect to the center of the plane into the two \n\/\/      coordinates axes (s,t).\n\/\/\n\/\/ [2] The elegant way: solving the 3\u00d73 linear system of equations for (r,s,t) all at once,\n\/\/     at a single step. You can do this by using Cramer\u2019s law.\n\/\/\n\/\/ The second solution, despite more expensive, turns out a lot more elegant (more symmetric \n\/\/ and regular, that is)\n\/\/================================================================================================\n\n#if 1\n\/\/\n\/\/ Elegant way to intersect a planar coordinate system (3x3 linear system)\n\/\/\nvec3 intersectCoordSys( in vec3 o, in vec3 d, vec3 c, vec3 u, vec3 v )\n{\n\tvec3 q = o - c;\n\treturn vec3(\n        dot( cross(u,v), q ),\n\t\tdot( cross(q,u), d ),\n\t\tdot( cross(v,q), d ) ) \/ \n        dot( cross(v,u), d );\n}\n\n#else\n\/\/\n\/\/ Ugly (but faster) way to intersect a planar coordinate system: plane + projection\n\/\/\nvec3 intersectCoordSys( in vec3 o, in vec3 d, vec3 c, vec3 u, vec3 v )\n{\n\tvec3  q = o - c;\n\tvec3  n = cross(u,v);\n    float t = -dot(n,q)\/dot(d,n);\n    float r =  dot(u,q + d*t);\n    float s =  dot(v,q + d*t);\n    return vec3(t,s,r);\n}\n\n#endif\t\n\n\/\/================================================================================================\n\nvec3 hash( in float x )\n{\n    return fract(sin(x+vec3(0.0,1.0,2.0))*vec3(43758.5453123,12578.1459123,19642.3490423));\n}\n\nfloat morph = smoothstep( 0.0, 0.4, sin(1.0*iGlobalTime) );\n\nvec4 intersect( in vec3 ro, in vec3 rd )\n{\n\tvec4 res = vec4(1e20, 0.0, 0.0, 0.0 );\n\t\n\t\n\tfor( int i=0; i<64; i++ )\n\t{\n\t\t\/\/ position disk\n\t\tvec3 h = hash( float(i) );\n\t    vec3 r = 4.0*(-1.0 + 2.0*h);\n\t\t\n        \/\/ orientate disk\n\t\tvec3 u = normalize( -1.0+2.0* hash( float(i)*13.1 ) );\n        vec3 v = normalize( cross( u, vec3(0.0,1.0,0.0 ) ) );\t\t\t\t\t\t   \n\t\t\n        \/\/ intersect plane\n        vec3 tmp = intersectCoordSys( ro, rd, r, u, v );\n\t\n        \/\/ define shape\t\t\n\t\t\n\t\t\n\t    float a = atan(tmp.y,tmp.z);\n\t\tfloat f1 = dot(tmp.yz*tmp.yz,tmp.yz*tmp.yz) - 1.0;\n\t\tfloat f2 = dot(tmp.yz,tmp.yz) - sqrt(0.5 + 0.5*sin(3.0*a));\n\t\tfloat f = mix( f1, f2, morph );\n\t\t\t\n        \/\/ determine if closest intersection\t\t\n\t    if( f<0.0 && tmp.x>0.0 && tmp.x<res.x ) \n\t    {\n\t\t\tres = vec4( tmp.x, tmp.yz, float(i) );\n\t    }\n\t}\n\n\treturn res;\n}\n\n\nvec3 shade( in vec3 pos, in vec4 res )\n{\n    vec3 col = 0.5 + 0.5*sin( 1.5*res.w\/64.0 + vec3(0.0,1.0,3.0) );\n\n    float a = atan(res.y,res.z);\n\t\n\tfloat ra1 = length(res.yz*res.yz);\n\tfloat ra2 = length(res.yz)\/sqrt(0.5 + 0.5*sin(3.0*a));\n\tfloat ra  = mix( ra1, ra2, morph );\n    col *= 1.0 - smoothstep( 0.8, 0.9, ra );\n    col *= 1.3 - 0.3*ra;\n\t\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x\/iResolution.y;\n\n    \/\/-----------------------------------------------------\n    \/\/ camera\n    \/\/-----------------------------------------------------\n\tvec3 ro = 3.0*vec3(cos(0.25*iGlobalTime*1.1),0.0,sin(0.25*iGlobalTime*1.1));\n    vec3 ta = vec3(0.0,0.0,0.0);\n    \/\/ camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t\/\/ create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    \/\/-----------------------------------------------------\n\t\/\/ background\n    \/\/-----------------------------------------------------\n\tvec3 bgc = vec3(0.3) + 0.2*rd.y;\n\t\n\tvec3 col = bgc;\n\n    \/\/-----------------------------------------------------\n\t\/\/ raytrace\n    \/\/-----------------------------------------------------\n    vec4 res = intersect( ro, rd );\n\tif( res.x<100.0 ) \n\t{\n\t\tvec3 pos = ro + rd*res.x;\n\t\tcol = shade( pos, res );\n\t\tcol = mix( col, bgc, 1.0-exp(-0.01*res.x*res.x) );\n\t}\n\n    fragColor = vec4( col, 1.0 );\n}\n","name":"","description":"","type":"image"}]}}