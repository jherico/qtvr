{"Shader":{"ver":"0.1","info":{"id":"XtsXWX","date":"1440170567","viewed":932,"name":"Ray Marching Experiment n\u00b031","username":"aiekick","description":"iq shader https:\/\/www.shadertoy.com\/view\/Ml2GWy displaced on ball","likes":9,"published":3,"flags":0,"tags":["ray","experiment","marching","n31"],"hasliked":0},"renderpass":[{"inputs":[{"id":27,"src":"\/presets\/cube05_0.png","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Stephane Cuillerdier - Aiekick\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/*\niq shader https:\/\/www.shadertoy.com\/view\/Ml2GWy displaced on ball\n*\/\n\nfloat dstepf = 0.0;\n    \nconst vec2 RMPrec = vec2(.8, 0.01); \nconst vec3 DPrec = vec3(0.01, 12., 1e-8); \n\nvec2 Params; \/\/ y => Elevation\n\nvec4 map(vec3 p)\n{\n    vec2 uv = p.xz*10.;\n    \n\t\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ pattern : iq shader https:\/\/www.shadertoy.com\/view\/Ml2GWy\n    uv += iGlobalTime*5.;\n\n    vec3 col = vec3(0.0);\n    for( int i=0; i<3; i++ ) \n    {\n        vec2 a = floor(uv);\n        vec2 b = fract(uv);\n        \n        vec4 w = fract((sin(a.x*7.0+31.0*a.y + 0.01*iGlobalTime)+vec4(0.035,0.01,0.0,0.7))*13.545317); \/\/ randoms\n                \n        col += w.xyz *                                   \/\/ color\n               smoothstep(0.45,0.55,w.w) *               \/\/ intensity\n               sqrt( 16.0*b.x*b.y*(1.0-b.x)*(1.0-b.y) ); \/\/ pattern\n        \n        uv \/= 2.0; \/\/ lacunarity\n        col \/= 2.0; \/\/ attenuate high frequencies\n    }\n    \n    col = pow( 2.5*col, vec3(0.9,1.2,0.7) );    \/\/ contrast and color shape\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \n    dstepf += 0.005;\n\n    float disp = dot(col,vec3(Params.y));                            \n    float dist = length(p) -2.8 - smoothstep(0., 1., disp);\n    return vec4(dist, col.rgb);\n}\n\nvec3 nor( vec3 pos, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n    map(pos+e.xyy).x - map(pos-e.xyy).x,\n    map(pos+e.yxy).x - map(pos-e.yxy).x,\n    map(pos+e.yyx).x - map(pos-e.yyx).x );\n    return normalize(n);\n}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cu, vec3 cv)\n{\n\tvec3 rov = normalize(cv-ro);\n    vec3 u =  normalize(cross(cu, rov));\n    vec3 v =  normalize(cross(rov, u));\n    vec3 rd = normalize(rov + u*uv.x + v*uv.y);\n    return rd;\n}\n\nvoid mainImage( out vec4 f, in vec2 g )\n{\n    vec2 si = iResolution.xy;\n   \tfloat t = iGlobalTime;\n    Params.y = (sin(t*.5)*.5+.5)*.08;\n    f = vec4(0.);\n    float ca = t*.2; \/\/ angle z\n    float ce = 3.5; \/\/ elevation\n    float cd = 0.5; \/\/ distance to origin axis\n    vec3 cu=vec3(0,1,0);\/\/Change camere up vector here\n    vec3 cv=vec3(0,0,0); \/\/Change camere view here\n    float refl_i = .6; \/\/ reflexion intensity\n    float refr_a = 1.2; \/\/ refraction angle\n    float refr_i = .8; \/\/ refraction intensity\n    float bii = 0.6; \/\/ bright init intensity\n    vec2 uv = (g+g-si)\/min(si.x, si.y);\n    vec3 ro = vec3(sin(ca)*cd, ce+1., cos(ca)*cd); \/\/\n    vec3 rd = cam(uv, ro, cu, cv);\n    float b = bii;\n    vec3 d = vec3(0.);\n    vec3 p = ro+rd*d.x;\n    float s = DPrec.y;\n    float rmd = sign(map(p).x);\n    float iterUsed = 0.;\n    for(int i=0;i<200;i++)\n    {      \n        iterUsed++;\n\t\tif(s<DPrec.x||s>DPrec.y) break;\n        s = map(p).x*(s>DPrec.x?RMPrec.x:RMPrec.y);\n        if (sign(s) != rmd) break;\n        d.y = d.x;\n        d.x += s;\n        p = ro+rd*d.x;\n   \t}\n\n    f += pow(b,15.);\n    \n    if (d.x<DPrec.y)\n    {\n    \tfloat nPrec = 10.\/iterUsed;\n        vec3 n = nor(p, nPrec);\n        vec3 ray = reflect(rd, n);\n        f += textureCube(iChannel0, ray) * refl_i; \n        f.rgb = mix( f.rgb, map(p).yzw,0.5);  \n   \t}\n    else\n    {\n    \tf = textureCube(iChannel0, rd);\n    }\n    \n    f += dstepf;\n}\n\n","name":"","description":"","type":"image"}]}}