{"Shader":{"ver":"0.1","info":{"id":"MtfSWr","date":"1435847976","viewed":791,"name":"crowded Lego","username":"FabriceNeyret2","description":"Here, I fix a limitation of the ultra-compact Trisomie21 ray-marcher:<br\/>If sphere-marching only takes into account the dist to geom in the current 3D tile, then passed an object we might enter to deep in the next tile. Thus the artifacts in my other demos.","likes":5,"published":3,"flags":0,"tags":["3d","raymarching"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\n\n#define T iGlobalTime\n#define r(v,t) { float a = (t)*T, c=cos(a),s=sin(a); v*=mat2(c,s,-s,c); }\n#define SQRT3_2  1.26\n#define SQRT2_3  1.732\n\n\/\/ --- using the base ray-marcher of Trisomie21: https:\/\/www.shadertoy.com\/view\/4tfGRB#\n\nvec4 bg = vec4(0); \/\/ vec4(0,0,.3,0); \/\/ vec4(0,0,.4,0);\n\nvoid mainImage( out vec4 f, vec2 w ) {\n    vec4 p = vec4(w,0,1)\/iResolution.yyxy-.5, d,c; p.x-=.4; \/\/ init ray\n     r(p.xz,.13); r(p.yz,.2); r(p.xy,.1);   \/\/ camera rotations\n    d = p;                                 \/\/ ray dir = ray0-vec3(0)\n    p = vec4(.3,.5,5,0)*T+d;\n    vec2 mouse = iMouse.xy\/iResolution.xy;\n    float closest = 999.0;\n    f = bg;\n    float x1,x2,x3,l,x=1e9, R=4.;\n   \n    for (float i=1.; i>0.; i-=.01)  {\n       \n         vec4 u = floor(p\/8.), t = mod(p, 8.)-4., ta; \/\/ objects id + local frame\n      \n        \/\/ r(t.xy,u.x); r(t.xz,u.y); \/\/ r(t.yz,.1);    \/\/ objects rotations\n        u = sin(78.17*(u+u.yzxw));                     \/\/ randomize ids\n        \/\/ t -= 4.*u;                                  \/\/ jitter positions\n        \n        c = p\/p*1.2;\n        ta = abs(t);\n        \/\/ x = max(ta.x,max(ta.y,ta.z))  -3.8*(sin(17.*(u.x+u.y+u.z))>.95 ? 1. : -1. );\n        x=1e9; \n        if (sin(17.*(u.x+u.y+u.z))>.95) { \/\/ 10% of big blocks\n            x = max(ta.x,max(ta.y,ta.z))  -3.8; \n            u = floor(p\/2.), ta = abs(mod(p, 2.)-2.\/2.);  u = sin(78.17*(u+u.yzxw));\n            if (sin(17.*(u.x+u.y+u.z+floor(.3*T+u.x)))>.0)  \/\/ 50% of small blocks\n               \tx = max(x,-(max(ta.x,max(ta.y,ta.z))  -1.1));\n         }\n        \n        \/\/ artifacts: passed a object, we might be fooled about dist to next (hidden in next modulo-tile)\n#if 0        \/\/ if dist augment with depth, skip to end of modulo-box.\n        ta = abs(t+.01*d);x1 = max(ta.x,max(ta.y,ta.z))  -2.8*(sin(17.*(u.x+u.y+u.z))>.9?1.:0.1);\n        if (x1>x) { l = -(max(ta.x,max(ta.y,ta.z))  -4.); p+= 2.*d*(l+0.01); _i+=.0; continue; }\n#endif\n#if 1        \/\/ if dist to box border is closest to object, go there.  <<< the working solution ! (at mod8 scale)\n\t\t\/\/ l = -(max(ta.x,max(ta.y,ta.z))  -4.);\n        vec4 k, k1 = (R-t)\/d ,k2 = (-R-t)\/d, dd; \n        k = min (k1-1e5*sign(k1),k2-1e5*sign(k2))+1e5; \/\/ ugly trick to get the min only if positive.\n        \/\/ 2 less ugly\/costly formulations, but less robust close to \/0 :\n        \/\/ k = mix(k1,k2, .5+.5*sign(k2));\n        \/\/ dd = d+.001*clamp(1.-d*d,.999,1.); k = (R*sign(dd)-t)\/dd;\n        l = min(k.x,min(k.y,k.z));\n\n        if (l<x) { p+= 1.*d*(l+0.01); continue; }\n#endif\n#if 0        \/\/ if falling inside object, backtrack to box entry.\n        if (x<0.) {  \n            \/\/ if (x<0.) { f=f-f; return; }\n            vec4 k, k1 = -(4.-t)\/d ,k2 = -(-4.-t)\/d; \n            k = min (k1-999.*sign(k1),k2-999.*sign(k2))+999.;\n            x = min(k.x,min(k.y,k.z))-.01;\n            \n            p -= 2.*d*x;  continue; \n        }\n#endif\n        \/\/ if (x<.01) c = mix(c,u,.5);\n        \/\/ if (x<.01) c = mix(c,u,.5)*(sin(15.*T)*sin(2.7*T)*sin(1.2*T)>.5 ? 3. : 1.);\n        if (x<.01) c = mix(c,u,.5)*(1.+.1\/(.6+.5*sin(1.*(.01*p.x-3.*T)))*clamp(cos(T\/8.),0.,1.));\n      \n        if(x<.01) \/\/ hit !\n            { f = mix(bg,c,i*i); break;  }  \/\/ color texture + black fog\n       \n        p += d*x;       \/\/ march ray\n     }\n}\n","name":"","description":"","type":"image"}]}}