{"Shader":{"ver":"0.1","info":{"id":"4tlSWS","date":"1439382515","viewed":791,"name":"P6M symmetry space warp - howto","username":"Xender","description":"Howdoi p6m symmetry without involving cyclometric functions.<br\/>Please share any remarks about possible optimizations, numerical stability or just if there is any way to do it better.","likes":1,"published":3,"flags":0,"tags":["kaleidoscope","educational","symmetry","nocyclometry"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Helpers\n\nfloat smooth_in_range_by_params(float middle, float wing, float x, float AA_epsilon)\n{\n\treturn smoothstep(0.0, AA_epsilon, wing - abs(x - middle));\n}\n\nfloat smooth_in_range_by_ends(float a, float b, float x, float AA_epsilon)\n{\n\tfloat middle =    (a + b) \/ 2.0;\n\tfloat wing   = abs(b - a) \/ 2.0;\n\n\treturn smooth_in_range_by_params(middle, wing, x, AA_epsilon);\n}\n\n\n\/\/ Primitives for plotting\n\nfloat circle(vec2 uv, float radius, float contour_thickness, float AA_epsilon)\n{\n\tfloat distance_from_circumference = length(uv) - radius;\n\tfloat border = abs(distance_from_circumference) - contour_thickness\/2.0;\n\n\treturn smoothstep(AA_epsilon, 0.0, border);\n}\n\nfloat line(vec2 uv, vec2 normal, float thickness, float AA_epsilon)\n{\n\tfloat distance_from_line = abs(dot(uv, normal));\n\tfloat border = abs(distance_from_line) - thickness\/2.0;\n\n\treturn smoothstep(AA_epsilon, 0.0, border);\n}\n\n\n\/\/ Color map for [-1, 1] range\n\nvec3 sincos_colormap(float val)\n{\n\tif(val < 0.0)  return vec3(0.0, -val, 0.0);\n\telse           return vec3(val,  0.0, 0.0);\n}\n\nvec3 in_range_colormap(float val)\n{\n\tif(val < 0.0)  return vec3(0.0, -val, 0.0);\n\telse           return vec3(val,  0.0, 0.0);\n}\n\n\n\/\/ Circular plot (well, kinda...)\n\nvec3 sincos_circle_plot(vec2 uv, float val, float radius, float contour_thickness, float AA_epsilon)\n{\n\tfloat mask = circle(uv, radius, contour_thickness, AA_epsilon);\n\n\treturn mask * sincos_colormap(val);\n}\n\nvec3 in_30deg_circle_plot(vec2 uv, vec2 versor, float radius, float contour_thickness, float AA_epsilon)\n{\n\t\/\/ A function for cross-check by comparing with result of cyclometric function (atan2).\n\n\tfloat mask = circle(uv, radius, contour_thickness, AA_epsilon);\n\tfloat angle_deg = atan(versor.y, versor.x) * 180.0 \/ 3.141592653589793;\n\n\tvec3 col_deg_0  = vec3(0.0, 0.0, 1.0);\n\tvec3 col_deg_30 = vec3(0.0, 1.0, 0.0);\n\n\treturn mask * smooth_in_range_by_ends(0.0, 30.0, angle_deg, AA_epsilon) * mix(col_deg_0, col_deg_30, angle_deg\/30.0);\n}\n\n\n\/\/ Domain (space) warp\n\n\/\/ http:\/\/wiki.inkscape.org\/wiki\/index.php\/Tiled-Clones\n\/\/ https:\/\/en.wikipedia.org\/wiki\/Wallpaper_group\n\nvec2 p2mm_symmetry(vec2 uv)\n{\n\treturn abs(uv);\n}\n\nvec2 p6m_symmetry(vec2 uv)\n{\n\tfloat s = 0.5;\n\tfloat c = sqrt(3.0) \/ 2.0;\n\n\tmat2 rot_60deg = mat2(c, -s, s, c);\n\n\tuv = p2mm_symmetry(uv);\n\tuv = p2mm_symmetry(rot_60deg*uv);\n\tuv = p2mm_symmetry(rot_60deg*uv);\n\n\treturn uv;\n}\n\n\n\/\/ Entry point\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\t\/\/ Assuming that pixels are square (pixel aspect ratio = iResolution.z == 1.0\n\n\tfloat uv_divisor = min(iResolution.x, iResolution.y);\n\tfloat pixel_size = 1.0 \/ uv_divisor;\n\n\tvec2 uv = (fragCoord.xy - iResolution.xy \/ 2.0) * 2.0 \/ uv_divisor;\n\n\tfloat scale = 1.7;\n\tuv                                 *= scale;\n\tfloat AA_epsilon = 2.0 * pixel_size * scale;\n\n\tvec3 color = vec3(0.0);\n\n\t\/\/ Plots\n\n\tvec2 uv_versor = normalize(uv);\n\n\tcolor += sincos_circle_plot  (uv, uv_versor.x, 0.7,  (0.1  - 2.*AA_epsilon), AA_epsilon);\n\tcolor += sincos_circle_plot  (uv, uv_versor.y, 0.8,  (0.1  - 2.*AA_epsilon), AA_epsilon);\n\tcolor += in_30deg_circle_plot(uv, uv_versor,   0.88, (0.05 - 2.*AA_epsilon), AA_epsilon);\n\n\tvec2 p6m_warped_uv_versor = p6m_symmetry(uv_versor);\n\n\tcolor += sincos_circle_plot  (uv, p6m_warped_uv_versor.x, 1.4,  (0.1  - 2.*AA_epsilon), AA_epsilon);\n\tcolor += sincos_circle_plot  (uv, p6m_warped_uv_versor.y, 1.5,  (0.1  - 2.*AA_epsilon), AA_epsilon);\n\tcolor += in_30deg_circle_plot(uv, p6m_warped_uv_versor,   1.58, (0.05 - 2.*AA_epsilon), AA_epsilon);\n\n\t\/\/ Axes\n\tvec3 axis_col_1 = vec3(1.0, 0.5, 0.0);\n\tvec3 axis_col_2 = vec3(0.7, 0.2, 0.0);\n\n\tvec2 norm_deg_0   = vec2( 1.0, 0.0);\n\tvec2 norm_deg_60  = vec2(-0.5, sqrt(3.0)\/2.0);\n\tvec2 norm_deg_120 = vec2( 0.5, sqrt(3.0)\/2.0);\n\n\tvec2 norm_deg_30  = vec2(sqrt(3.0)\/2.0, -0.5);\n\tvec2 norm_deg_90  = vec2(0.0,            1.0);\n\tvec2 norm_deg_150 = vec2(sqrt(3.0)\/2.0,  0.5);\n\n\tcolor += axis_col_1 * line(uv, norm_deg_0,   pixel_size, AA_epsilon);\n\tcolor += axis_col_1 * line(uv, norm_deg_60,  pixel_size, AA_epsilon);\n\tcolor += axis_col_1 * line(uv, norm_deg_120, pixel_size, AA_epsilon);\n\n\tcolor += axis_col_2 * line(uv, norm_deg_30,  pixel_size, AA_epsilon);\n\tcolor += axis_col_2 * line(uv, norm_deg_90,  pixel_size, AA_epsilon);\n\tcolor += axis_col_2 * line(uv, norm_deg_150, pixel_size, AA_epsilon);\n\n\tfragColor = vec4(color, 1.0);\n}\n","name":"","description":"","type":"image"}]}}