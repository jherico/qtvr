{"Shader":{"ver":"0.1","info":{"id":"4djSRW","date":"1409577464","viewed":2617,"name":"Hash without Sine","username":"Dave_Hoskins","description":"A Hash function that is the same on all systems and doesn't rely on trig functions. <br\/>New hash on the left, sine hash function on the right.<br\/>It appears to be the same efficiency, but I suppose that depends on the hardware.<br\/>","likes":66,"published":3,"flags":8,"tags":["noise","fbm","perlin","random","hash"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Hash without Sine\n\/\/ Creative Commons Attribution-ShareAlike 4.0 International Public License\n\/\/ Created by David Hoskins.\n\n\/\/ https:\/\/www.shadertoy.com\/view\/4djSRW\n\/\/ Trying to find a Hash function that is the same on ALL systens\n\/\/ and doesn't rely on trigonometry functions that lose accuracy \n\/\/ with different GPUs. \n\/\/ New one on the left, sine function on the right.\n\/\/ It appears to be the same speed, but I suppose that depends.\n\n\/\/ * Note. It still goes wrong eventually!\n\/\/ * Try full-screen paused to see details.\n\n\n#define ITERATIONS 4\n\n\n\/\/ *** Change these to suit your range of random numbers..\n\n\/\/ *** Use this for integer stepped ranges, ie Value-Noise\/Perlin noise functions.\n#define HASHSCALE .1031\n\n\/\/ For smaller input values like audio tick or 0-1 UVs use this...\n\/\/#define HASHSCALE 443.8975\n\n\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  1 out, 1 in...\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/\/  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/\/  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE);\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n\n\/\/----------------------------------------------------------------------------------------\n\/\/\/  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/\/  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * HASHSCALE);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n    \n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE);\n    p4 += dot(p4, p4.wzxy+19.19);\n\treturn fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx) * HASHSCALE);\n    p4 += dot(p4, p4.wzxy+19.19);\n\treturn fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4 * HASHSCALE);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n}\n\n\/\/###############################################################################\n\n\/\/----------------------------------------------------------------------------------------\nfloat hashOld12(vec2 p)\n{\n    \/\/ Two typical hashes...\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n    \n    \/\/ This one is better, but it still stretches out quite quickly...\n    \/\/ But it's really quite bad on my Mac(!)\n    \/\/return fract(sin(dot(p, vec2(1.0,113.0)))*43758.5453123);\n\n}\n\nvec3 hashOld33( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(p)*43758.5453123);\n}\n\n\/\/----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 position = fragCoord.xy;\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n#if 1\n\tfloat a = 0.0, b = a;\n    for (int t = 0; t < ITERATIONS; t++)\n    {\n        float v = float(t+1)*.152;\n        vec2 pos = (position * v + iGlobalTime * 500. + 50.0);\n        a += hash12(pos);\n    \tb += hashOld12(pos);\n    }\n    vec3 col = vec3(mix(b, a, step(uv.x, .5))) \/ float(ITERATIONS);\n#else\n\tvec3 a = vec3(0.0), b = a;\n    for (int t = 0; t < ITERATIONS; t++)\n    {\n        float v = float(t+1)*.132;\n        vec3 pos = vec3(position, iGlobalTime*.3) + iGlobalTime * 500. + 50.0;\n        a += hash33(pos);\n        b += hashOld33(pos);\n    }\n    vec3 col = vec3(mix(b, a, step(uv.x, .5))) \/ float(ITERATIONS);\n#endif\n\n    col = mix(vec3(.4, 0.0, 0.0), col, smoothstep(.5, .495, uv.x) + smoothstep(.5, .505, uv.x));\n\tfragColor = vec4(col, 1.0);\n}","name":"","description":"","type":"image"},{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Hash without Sine\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ Created by David Hoskins.\n\n\/\/ https:\/\/www.shadertoy.com\/view\/4djSRW\n\/\/ Trying to find a Hash function that is the same on all systems\n\/\/ and doesn't rely on trigonometry functions that lose accuracy with high values. \n\/\/ New one on the left, sine function on the right.\n\/\/ It appears to be the same speed, but I suppose that depends.\n\n\/\/ * Note. It still goes wrong eventually!\n\n#define ITERATIONS 8\n\n\n\/\/ *** Use this for integer stepped ranges, ie Value-Noise\/Perlin noise functions.\n\/\/#define HASHSCALE .1031\n\n\/\/ For smaller input values like audio tick or UVs use this...\n#define HASHSCALE 443.8975\n\n\/\/----------------------------------------------------------------------------------------\n\/\/----------------------------------------------------------------------------------------\n\/\/\/  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE);\n    p3 += dot(p3.zxy, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\/\/----------------------------------------------------------------------------------------\nvec2 mainSound(float time)\n{\n    vec2 audio = vec2(0.0);\n    for (int t = 0; t < ITERATIONS; t++)\n    {\n        float v = float(t)*3.21239;\n\t\taudio += hash22(vec2(time + v, time*1.423 + v)) * 2.0 - 1.0;\n    }\n    audio \/= float(ITERATIONS);\n\n    return audio*.2 * smoothstep(0.0, 2.0, time) * smoothstep(60.0, 50.0, time);\n}","name":"","description":"","type":"sound"}]}}