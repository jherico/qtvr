{"Shader":{"ver":"0.1","info":{"id":"Mst3DB","date":"1452073123","viewed":305,"name":"The simplest path tracer","username":"marty1885","description":"Click and move you mouse to move the triangle and see what happens!","likes":0,"published":3,"flags":32,"tags":["raytrace","pathtracing"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/TODO: Apply FXAA to decrease noise.\n\n#define M_PI           3.14159265358979323846  \/* pi *\/\n#define SAMPLE_NUM 86\n#define MAX_BOUNCE_DEPTH 8\n#define LIGHT_EMIT_STRENGTH 20.0\n#define GAMMA 2.2\n\n\/\/NOTE : NEVER make this over 3. It crashes my AMD HD 7850 GPU.\n#define TRIANGLE_NUM 3\n\nstruct Camera\n{\n    vec3 position;\n    vec3 direction;\n    vec3 up;\n};\n    \nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n    \nstruct Triangle\n{\n    vec3 vertex[3];\n    vec3 reflectColor;\n    vec3 emitColor;\n};\n\nTriangle sceneTriangle[TRIANGLE_NUM];\n\nCamera lookAt(vec3 position, vec3 direction, vec3 up)\n{\n    Camera cam;\n    cam.position = position;\n    cam.direction = normalize(direction - position);\n    cam.up = normalize(up);\n    return cam;\n}\n\nRay createRay(vec3 origin, vec3 direction)\n{\n\tRay ray;\n    ray.origin = origin;\n    ray.direction = direction;\n    return ray;\n}\n\nRay createCameraRay(Camera cam, vec2 uv)\n{\n    vec3 right = normalize(cross(cam.direction,cam.up));\n    vec3 direction = cam.direction\n        + cam.up * 2.0 * (uv.y - 0.5)\n        + right * 2.0 * (0.5 - uv.x);\n    Ray ray;\n    ray = createRay(cam.position, direction);\n    return ray;\n}\n\n\/\/return val => mat4 [0] = vec4(u,v,distance,0)\n\/\/\t\t\t\t\t\t \t\t   [1] = vec4(normal,0)\n\/\/\t\t\t\t\t\t \t\t   [2] = vec4(reflectColor,1)\n\/\/\t\t\t\t\t\t \t\t   [3] = vec4(emitColor,1)\nmat4 findIntersection(Ray ray, Triangle triangle)\n{\n    vec2 uv;\n\tvec3 rayCone[3];\n\tvec3 cameraConeNormal[3];\n\trayCone[0] = triangle.vertex[0] - ray.origin;\n\trayCone[1] = triangle.vertex[1] - ray.origin;\n\trayCone[2] = triangle.vertex[2] - ray.origin;\n\tcameraConeNormal[0] = cross(rayCone[1], rayCone[2]);\n\tcameraConeNormal[1] = cross(rayCone[2], rayCone[0]);\n\tcameraConeNormal[2] = cross(rayCone[0], rayCone[1]);\n\tfloat orientation = dot(rayCone[0], cameraConeNormal[0]) < 0.0 ? 1.0 : -1.0;\n\tvec3 baryocentric = orientation * vec3(\n\t\tdot(ray.direction, cameraConeNormal[0]),\n\t\tdot(ray.direction, cameraConeNormal[1]),\n\t\tdot(ray.direction, cameraConeNormal[2])\n\t);\n\tif (baryocentric.x <= 0.0 && baryocentric.y <= 0.0 && baryocentric.z <= 0.0)\n\t{\n\t\tbaryocentric \/= (baryocentric.x + baryocentric.y + baryocentric.z);\n\n\t\tvec3 intersec = (baryocentric.x*triangle.vertex[0] +\n\t\t\tbaryocentric.y*triangle.vertex[1] +\n\t\t\tbaryocentric.z*triangle.vertex[2]);\n\t\t\tuv = baryocentric.yz;\n        \n        vec3 normal = cross(triangle.vertex[1] - triangle.vertex[0],triangle.vertex[2]-triangle.vertex[0]);\n        \n        mat4 result;\n        result[0] = vec4(uv,length(intersec - ray.origin),0);\n        result[1] = vec4(normal,0);\n        result[2] = vec4(triangle.reflectColor,1);\n        result[3] = vec4(triangle.emitColor,1);\n\n\t\treturn result;\n\t}\n\telse\n\t\treturn mat4(-1);\n}\n\nmat4 findIntersectionScene(Ray ray)\n{\n    mat4 hit;\n    hit[0].z = -1.0;\n    \n    for(int i=0;i<TRIANGLE_NUM;i++)\n    {\n        mat4 hitProp = findIntersection(ray,sceneTriangle[i]);\n        if((hitProp[0].z < hit[0].z || hit[0].z < 0.0) && hitProp[0].z > 0.0)\n        {\n            hit = hitProp;\n        }\n    }\n    return hit;\n}\n\nvec2 randSeed;\nhighp float rand()\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(randSeed.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    highp float val = fract(sin(sn) * c);\n    randSeed = texture2D(iChannel0,vec2(randSeed)).xy;\n    return val;\n}\n\nRay createRandomReflect(Ray ray, mat4 hit)\n{\n\tvec3 normal = hit[1].xyz;\n\tif(dot(normal,ray.direction) > 0.0)\n    \tnormal = -normal;\n\n    vec3 worldUp = vec3(1,1,0);\n\tvec3 e0 = normalize(normal);\n\tvec3 e1 = normalize(cross(e0,worldUp));\n\tvec3 e2 = normalize(cross(e0,e1));\n\n\t\/\/Create evenly distributed ray\n\t\/\/reference: http:\/\/mathworld.wolfram.com\/SpherePointPicking.html\n\n    float phi = rand()*M_PI*2.0;\n\tfloat x = rand();\n\tfloat theta = abs(acos(x));\/\/NOTE : sometimes acos will give a small negiative number.\n\tvec3 direction = normalize(sin(theta)*cos(phi)*e1 +\n\t\tsin(theta)*sin(phi)*e2 +\n\t\tabs(cos(theta))*e0);\n\n    vec3 intersection = normalize(ray.direction)*hit[0].z + ray.origin;\n\tvec3 origin = intersection\n\t\t+direction*0.0001; \/\/workaround float point accuracy issue\n    \n\tRay reflect = createRay(origin, direction);\n\treturn reflect;\n}\n\nvec3 trace(Ray ray)\n{\n    Ray currentRay = ray;\n    vec3 renderedColor = vec3(0,0,0);\n    vec3 factor = vec3(1,1,1);\n    \n    for(int i=0;i<MAX_BOUNCE_DEPTH;i++)\n    {\n        mat4 hit = findIntersectionScene(currentRay);\n        if(hit[0].z > 0.0)\n        {\n            renderedColor += hit[3].xyz*factor;\n            factor *= hit[2].xyz;\n            currentRay = createRandomReflect(ray,hit);\/\/Ideal Deffuse BRDF\n        }\n        else\n            break;\n    }\n    \n    return renderedColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/create a Camera\n    Camera camera = lookAt(vec3(0,4.0,7.0),vec3(0,0.0,0.0),vec3(0,1,0));\n    \n    \/\/Initlaze rand() using uv coord\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    randSeed = uv;\n    \n    Ray ray = createCameraRay(camera,uv);\n    \n    \/\/TODO : Move the scene initlization to a  buffer so we onlt need to init it once.\n    vec2 mouseUV = iMouse.xy\/iResolution.xy - vec2(0.5);\n    mouseUV *= M_PI * 2.0;\n    vec3 offset = vec3(mouseUV.x,mouseUV.y,0);\n    if(offset.y < -2.3)\n        offset.y = -2.29999;\n    if(iMouse.x == 0.0)\n        offset = vec3(0,0,0);\n    \n    \/\/Big Plain\n    sceneTriangle[0].vertex[0] = vec3(100,-2,-5);\n    sceneTriangle[0].vertex[1] = vec3(-100,-2,-100);\n    sceneTriangle[0].vertex[2] = vec3(-5,-2,100);\n    sceneTriangle[0].reflectColor = vec3(1,1,1);\n    sceneTriangle[0].emitColor = vec3(0,0,0);\n   \n    \/\/Light Source\n    sceneTriangle[1].vertex[0] = vec3(-1.7,1,1.7);\n    sceneTriangle[1].vertex[1] = vec3(-1.7,1,0);\n    sceneTriangle[1].vertex[2] = vec3(0,1,0);\n    sceneTriangle[1].reflectColor = vec3(1,1,1);\n    sceneTriangle[1].emitColor = vec3(0.8,0.7,0.65)*LIGHT_EMIT_STRENGTH;\n\n    \/\/Small triangle\n    sceneTriangle[2].vertex[0] = vec3(-2.0,0.3,2.0) + offset;\n    sceneTriangle[2].vertex[1] = vec3(-2.0,0.3,0) + offset;\n    sceneTriangle[2].vertex[2] = vec3(0,0.3,0) + offset;\n    sceneTriangle[2].reflectColor = vec3(1,1,1);\n    sceneTriangle[2].emitColor = vec3(0,0,0);\n    \n    vec3 renderColor = vec3(0,0,0);\n    for(int i=0;i<SAMPLE_NUM;i++)\n    \trenderColor += trace(ray);\/\/Recursize Path tracing\n    renderColor \/= float(SAMPLE_NUM);\n    \n    \/\/Gamma correction\n    renderColor = pow(renderColor,vec3(1.0\/GAMMA));\n    \n    fragColor = vec4(renderColor,0.0);\n}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t","name":"","description":"","type":"image"},{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/Generate a random texture\nvec2 randSeed;\nhighp float rand()\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(randSeed.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    highp float val = fract(sin(sn) * c);\n    randSeed.x = val;\n    return val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    randSeed = uv;\n    fragColor = vec4(rand(),rand(),0.0,1.0);\n}","name":"","description":"","type":"buffer"}]}}