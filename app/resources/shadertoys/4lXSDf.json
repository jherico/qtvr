{"Shader":{"ver":"0.1","info":{"id":"4lXSDf","date":"1440097520","viewed":883,"name":"J-E-L-L-O","username":"demofox","description":"Trying to use beer's law to make a cube of jello.  Anyone have any tips for improving it's look??","likes":8,"published":3,"flags":0,"tags":["3d","jello"],"hasliked":0},"renderpass":[{"inputs":[{"id":24,"src":"\/presets\/cube02_0.jpg","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define FLT_MAX 3.402823466e+38\n\nconst vec3 c_absorb = vec3(0.3,1.8,1.8);\nconst float c_refraction = 0.99;\nconst vec3 c_reflect = vec3(0.0);\n\nvec3 c_lightDirection = normalize(vec3(1.0,-2.0,-1.0));\nconst vec3 c_lightColorDiffuse = vec3(0.3);\nconst vec3 c_lightColorSpecular = vec3(0.3);\n\n\/\/=======================================================================================\nvec3 NormalAtPos (vec3 pos)\n{\n    vec3 normal = pos - vec3(0.5);\n    vec3 absNormal = abs(normal);\n    if (absNormal.x > absNormal.y)\n    {\n        if (absNormal.x > absNormal.z)\n        {\n            normal.x = sign(normal.x);\n            normal.y = 0.0;\n            normal.z = 0.0;\n        }\n        else\n        {\n            normal.x = 0.0;\n            normal.y = 0.0;\n            normal.z = sign(normal.z);            \n        }\n    }\n    else\n    {\n        if (absNormal.y > absNormal.z)\n        {\n            normal.x = 0.0;\n            normal.y = sign(normal.y);\n            normal.z = 0.0;\n        }\n        else\n        {\n            normal.x = 0.0;\n            normal.y = 0.0;\n            normal.z = sign(normal.z);            \n        }\n    }\n    return normal;\n}\n\n\/\/=======================================================================================\nbool RayIntersectAABox (vec3 boxMin, vec3 boxMax, in vec3 rayPos, in vec3 rayDir, out vec2 time)\n{\n\tvec3 roo = rayPos - (boxMin+boxMax)*0.5;\n    vec3 rad = (boxMax - boxMin)*0.5;\n\n    vec3 m = 1.0\/rayDir;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    time = vec2( max( max( t1.x, t1.y ), t1.z ),\n                 min( min( t2.x, t2.y ), t2.z ) );\n\t\n    return time.y>time.x && time.y>0.0;\n}\n\n\/\/=======================================================================================\nvec3 HandleRay (in vec3 rayPos, in vec3 rayDir, in vec3 pixelColor, out float hitTime)\n{\n\tfloat time = 0.0;\n\tfloat lastHeight = 0.0;\n\tfloat lastY = 0.0;\n\tfloat height;\n\tbool hitFound = false;\n    hitTime = FLT_MAX;\n    bool fromUnderneath = false;\n    \n    vec2 timeMinMax = vec2(0.0);\n    if (!RayIntersectAABox(vec3(0.0,0.0,0.0), vec3(1.0,1.0,1.0), rayPos, rayDir, timeMinMax))\n        return pixelColor;\n    \n    \/\/ calculate surface normal\n    vec3 frontCollisionPos = rayPos + rayDir * timeMinMax.x;\n    vec3 frontNormal = NormalAtPos(frontCollisionPos);\n    vec3 frontRefractedRayDir = refract(rayDir, frontNormal, c_refraction \/ 1.0);\n    \n    \/\/ shouldn't ever miss!!\n    vec2 refractTimeMinMax = vec2(0.0);\n    if (!RayIntersectAABox(vec3(0.0,0.0,0.0), vec3(1.0,1.0,1.0), frontCollisionPos, frontRefractedRayDir, refractTimeMinMax))\n        return vec3(0.0,1.0,0.0);\n    \n    vec3 backCollisionPos = frontCollisionPos + frontRefractedRayDir * refractTimeMinMax.y;\n    vec3 backNormal = -NormalAtPos(backCollisionPos);\n    \n    \/\/ refraction\n    vec3 refractRayDir = refract(frontRefractedRayDir, backNormal, 1.0 \/ c_refraction);\n    pixelColor = textureCube(iChannel0, refractRayDir).rgb;\n    \n    \/\/ reflection\n    vec3 reflectColor = textureCube(iChannel0, reflect(rayDir, frontNormal)).rgb * c_reflect;\n    \n    \/\/ calculate and apply absorption\n    vec3 absorb = exp(-c_absorb * (refractTimeMinMax.y - refractTimeMinMax.x));    \n    pixelColor *= absorb;\n    \n    \/\/ diffuse\n    float diffuseColorDP = clamp(dot(-c_lightDirection, frontNormal), 0.0, 1.0);\n    vec3 diffuseColor = c_lightColorDiffuse * diffuseColorDP;\n    \n    \/\/ specular\n    vec3 specularColorDir = reflect(-c_lightDirection, frontNormal);\n    float specularColorDP = clamp(dot(specularColorDir, rayDir), 0.0, 1.0);\n    vec3 specularColor = c_lightColorSpecular * specularColorDP;\n    \n    \n    \/\/ return the color we calculated\n\treturn pixelColor + diffuseColor + specularColor + reflectColor;\n}\n\n\/\/=======================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n    \/\/----- camera\n    vec2 mouse = iMouse.xy \/ iResolution.xy;\n\n    vec3 cameraAt \t= vec3(0.5,0.5,0.5);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14 + iGlobalTime * 0.25;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.5;\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * (2.0 + 2.0 * (sin(iGlobalTime)*0.5+0.5));\n    cameraPos += vec3(0.5,0.5,0.5);\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y \/ iResolution.x;\n    float cameraDistance\t= 6.0;  \/\/ intuitively backwards!\n\t\n\t\t\n\t\/\/ Objects\n\tvec2 rawPercent = (fragCoord.xy \/ iResolution.xy);\n\tvec2 percent = rawPercent - vec2(0.5,0.5);\n\t\n\tvec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n\t\t\t\t   - (cameraLeft * percent.x * cameraViewWidth)\n\t\t           + (cameraUp * percent.y * cameraViewHeight);\n\tvec3 rayDir = normalize(rayTarget);\n\t\n\t\n    float hitTime = FLT_MAX;\n\tvec3 pixelColor = textureCube(iChannel0, rayDir).rgb;\n    pixelColor = HandleRay(cameraPos, rayDir, pixelColor, hitTime);\n    \n    fragColor = vec4(clamp(pixelColor,0.0,1.0), 1.0);\n}\n\/*\nTODO:\n* modify rays to make it look wiggly?\n* have a define for sphere instead of cube?\n* try adding bump mapping?\n? Where does the black in the refraction come from?\n*\/","name":"","description":"","type":"image"}]}}