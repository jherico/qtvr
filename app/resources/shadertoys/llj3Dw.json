{"Shader":{"ver":"0.1","info":{"id":"llj3Dw","date":"1429798611","viewed":777,"name":"4-Rook Anti Aliasing","username":"demofox","description":"Anti Aliasing on left, no antialiasing on right.","likes":6,"published":3,"flags":0,"tags":["antialiasing","nrook"],"hasliked":0},"renderpass":[{"inputs":[{"id":1,"src":"\/presets\/tex00.jpg","ctype":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":4,"src":"\/presets\/tex03.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":6,"src":"\/presets\/tex05.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":7,"src":"\/presets\/tex06.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/*\n  Written by Alan Wolfe\n  http:\/\/demofox.org\/\n  http:\/\/blog.demofox.org\/\n\n\n4-Rook anti aliasing works by using 4 samples per pixel in the following configuration:\n\n\n  +-----------+\n  |  |  |A |  |\n  |--|--|--|--|\n  |D |  |  |  |\n  |--|--|--|--|\n  |  |  |  |B |\n  |--|--|--|--|\n  |  |C |  |  |\n  +-----------+\n\n\nA,B,C,D have a weight of 0.25.\n\nThis makes for AA that is not quite as blurry looking as quincunx, but unlike\nquincunx you can't share samples between pixels.  This is straight up 4x SSAA!\n\nMore info here:\nhttp:\/\/blog.demofox.org\/2015\/04\/23\/4-rook-antialiasing-rgss\/\n*\/\n\n\n#define MINSCALE 1.0\n#define MAXSCALE 8.0\n#define TIMEMULTIPLIER 0.5\n\n\/\/ camera wander: sin(time) controls magnitude, time controls angle\nfloat cameraAngle = iGlobalTime * 0.32;\nfloat cameraMag = sin(iGlobalTime*0.89) * 0.25 +1.0;\n\nvec2 cameraOffset = vec2(cameraMag * cos(cameraAngle), cameraMag * sin(cameraAngle));\n\n\/\/ aspect ratio correction\nvec2 resolution = vec2 (iResolution.x \/ 2.0, iResolution.x);\nfloat g_arcorrection = resolution.x \/ resolution.y;\n\n\/\/ image zoom, defined by time\nfloat g_scale = (sin(iGlobalTime * TIMEMULTIPLIER + 1.57) * 0.5 + 0.5) * (MAXSCALE - MINSCALE) + MINSCALE;\n\n\n#define DRAW_CIRCLE(_x,_y,_radius,_color) if (length(pos-vec2(_x,_y)) < _radius) return _color;\n\n#define DRAW_RECT(_x,_y,_w,_h,_color) if ((abs(pos.x-(_x)) < _w\/2.0)&&(abs(pos.y-(_y)) < _h\/2.0)) return _color;\n\n#define DRAW_OBB(_x,_y,_w,_h,_r,_color) {vec2 rel = vec2(pos.x-(_x), pos.y-(_y)); rel = vec2(cos(_r)*rel.x-sin(_r)*rel.y,sin(_r)*rel.x+cos(_r)*rel.y); if ((abs(rel.x) < _w\/2.0)&&(abs(rel.y-_y) < _h\/2.0)) return _color;}\n\nvec3 GetPixelColor(vec2 pos)\n{\n    \/\/ thin white grill\n    DRAW_RECT(-0.0,0.50,1.0,0.005,vec3(1,1,1));\n    DRAW_RECT(-0.0,0.52,1.0,0.005,vec3(1,1,1));\n    DRAW_RECT(-0.0,0.54,1.0,0.005,vec3(1,1,1));\n    DRAW_RECT(-0.0,0.56,1.0,0.005,vec3(1,1,1));\n    DRAW_RECT(-0.0,0.58,1.0,0.005,vec3(1,1,1));\n    DRAW_RECT(-0.0,0.60,1.0,0.005,vec3(1,1,1));\n    \n    \/\/ textured circles\n    DRAW_CIRCLE(-0.7, 0.7,0.25,texture2D(iChannel0, pos).xyz);\n    DRAW_CIRCLE(-0.7,-0.7,0.25,texture2D(iChannel1, pos).xyz);\n    DRAW_CIRCLE( 0.7,-0.7,0.25,texture2D(iChannel2, pos).xyz);\n    DRAW_CIRCLE( 0.7, 0.7,0.25,texture2D(iChannel3, pos).xyz);\n    \n    \/\/ spinning red and blue box\n    DRAW_OBB(-0.5, 0.0, 0.3, 0.1,  iGlobalTime, vec3(1.0, 0.0, 0.0));\n    DRAW_OBB(-0.5, 0.0, 0.1, 0.3, -iGlobalTime, vec3(0.0, 0.0, 1.0));\n    \n    \/\/ concentric spiral boxes\n    DRAW_OBB( 0.5, 0.0, 0.1, 0.1, 0.4, vec3(0.0));\n    DRAW_OBB( 0.5, 0.0, 0.2, 0.2, 0.3, vec3(1.0));\n    DRAW_OBB( 0.5, 0.0, 0.3, 0.3, 0.2, vec3(0.0));\n    DRAW_OBB( 0.5, 0.0, 0.4, 0.4, 0.1, vec3(1.0));\n    DRAW_OBB( 0.5, 0.0, 0.5, 0.5, 0.0, vec3(0.0));\n       \n    \/\/ untextured circles\n    DRAW_CIRCLE(0.0,0.0,0.1,vec3(0.9,0.1,0.9));\n    DRAW_CIRCLE(0.0,0.0,1.0,vec3(0.1,0.9,0.1));\n    \n    \/\/ grid background\n    float gridColor = mod(floor(pos.x*20.0),2.0) == mod(floor(pos.y*20.0),2.0) ? 0.8 : 0.0;  \n    return vec3(gridColor);\n}\n\nvec2 PixelToWorld (in vec2 coord)\n{\n    vec2 ret = ((coord \/ resolution) - vec2(0.5,0.5*g_arcorrection)) * g_scale;\n    ret *= vec2(g_arcorrection, -1.0);\n    return ret + cameraOffset;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t   \n    vec3 pixelColor;\n    \n    \/\/ draw middle line\n    if (abs(fragCoord.x - resolution.x) < 2.0)\n    {\n        pixelColor = vec3(1.0,1.0,1.0);\n    }\n    \/\/ right side = no AA\n\telse if( fragCoord.x > resolution.x)\n\t{\n        fragCoord.x -= resolution.x;\n        pixelColor = GetPixelColor(PixelToWorld(fragCoord.xy));\n\t}\n\t\/\/ left side = AA\n\telse\n    {\n        const float S = 1.0\/8.0;\n        const float L  = 3.0\/8.0;\n        pixelColor  = GetPixelColor(PixelToWorld(fragCoord.xy + vec2( S, -L ))) \/ 4.0;\n        pixelColor += GetPixelColor(PixelToWorld(fragCoord.xy + vec2( L , S))) \/ 4.0;\n        pixelColor += GetPixelColor(PixelToWorld(fragCoord.xy + vec2(-S, -L ))) \/ 4.0;\n        pixelColor += GetPixelColor(PixelToWorld(fragCoord.xy + vec2(-L ,-S))) \/ 4.0;\n\t}\t\t\n\t\n    \/\/ write pixel\n\tfragColor = vec4(pixelColor, 1.0);\n}","name":"","description":"","type":"image"}]}}