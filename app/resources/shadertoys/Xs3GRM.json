{"Shader":{"ver":"0.1","info":{"id":"Xs3GRM","date":"1448510823","viewed":318,"name":"SDF basics (Work In Progress)","username":"sagarpatel","description":"Building on basic concepts and helper functions","likes":2,"published":3,"flags":0,"tags":["sdf"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ CC0 1.0\n\/\/ @sagzorz\n \nconst bool isPseudoAA = false;\n\n\/\/ Building on basics and creating helper functions\n\/\/ POUET toolbox\n\/\/ http:\/\/www.pouet.net\/topic.php?which=7931&page=1&x=3&y=14\n\n\/\/ NOTE: if you are new to SDFs, do @cabbibo's tutorial first!!!\n\/\/ \n\/\/ @cabbibo's original SDF tutorial --> https:\/\/www.shadertoy.com\/view\/Xl2XWt\n\/\/ my original hacked up shader --> https:\/\/www.shadertoy.com\/view\/4d33z4\n\n\/\/ this is a clean\/from scratch re-implementation of my first shdaer\/sdf,\n\/\/ which was based on @cabbibo's awesome SDF tutorial\n\/\/ also used functions from iq's super handy page about distance functions\n\/\/ http:\/\/iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\n\/\/ resstructured to be closer to iq's Raymarching Primitives example\n\/\/ https:\/\/www.shadertoy.com\/view\/Xds3zN\n\n\/\/ NOW PROPERLY MARCHING THE RAY!\n\/\/ (was using silly hack in original version to compensate for twist artifacts)\n\/\/ Performs much better than old version\n\n\/\/ the sd functions below are the same as from iq's page (link above)\n\/\/ though when I wrote this version I derived from scratch as much as I could on my own \n\/\/ by thinking\/sketching on paper etc. \n\/\/ The comments explain my interpretation of the funcs\n\n\/\/ for all signed distance functions sd*() below,\n\/\/ input p --> is ray position, where the object is at the origin (0,0,0)\n\/\/ output float is distance from ray position to surface of sphere\n\/\/  positive means outside of sphere\n\/\/  negative means ray is inside\n\/\/  0 means its exactly on the surface\n\n\n\/\/ ~~~~~~~ silly function to access array memeber \n\/\/ because webgl needs const index for array acess\n\/\/ TODO :  FIX THIS, disgusting branching etc\n\/\/ THIS IS DEPRECATED,  NO LONGER NEED AN ARRAY SINCE DIRECT COL MIX NOW\nvec3 accessColors(float id)\n{    \n    vec3 bkgColor = vec3(0.5,0.6,0.7);\/\/vec3(0.75);    \n    vec3 objectColor_1 = vec3(1.0, 0.0, 0.0);\n    vec3 objectColor_2 = vec3( 0.25 , 0.95 , 0.25 );\n    vec3 objectColor_3 = vec3(0.12, 0.12, 0.9);\n    vec3 objectColor_4 = vec3(0.65);\n    vec3 objectColor_5 = vec3(1.0,1.0,1.0);\n    \n    vec3 colorsArray[6];\n    colorsArray[0] = bkgColor;\n    colorsArray[1] = objectColor_1;\n    colorsArray[2] = objectColor_2;\n    colorsArray[3] = objectColor_3;\n    colorsArray[4] = objectColor_4;\n    colorsArray[5] = objectColor_5;\n    \n    \n    if(id == -1.0)    \n        return bkgColor;\n    else if(id == 1.0)\n        return colorsArray[1];\n    else if(id == 2.0)\n        return colorsArray[2];\n    else if(id == 3.0)\n        return colorsArray[3];\n    else if(id == 4.0)\n        return colorsArray[4];\n    else if(id == 5.0)\n        return colorsArray[5];\n    else \n        return vec3(1.0,0.0,1.0);\n}\n\n\n\/\/ ~~~~~~~ signed fistance fuction for sphere\n\/\/ input r --> is sphere radius\n\/\/ pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n\/\/ ~~~~~~~ signed distance function for box\n\/\/ input s -- > is box size vector (all postive values)\n\/\/\n\/\/ the key to simply calcualting distance to surface to box is to first \n\/\/ force the ray position into the first octant (all positive values)\n\/\/ this massively simplifies the math and is ok since distance to surf\n\/\/ on a box is the same in the - or + direction on a given axis\n\/\/ simple to figure by once you sketch out 2D equivalent problem on papaer\n\/\/ 2D ex: distance to box of size (2,1) \n\/\/ for p of (-3,-2) == (-3, 2) == (3, -2) == (3, 2)\n\/\/\n\/\/ now that all the coordinates are \"normalized\"\/positive, its much easier,\n\/\/ the next part is to figure out the diff between the box surface the and p\n\/\/ a bit like the sphere function were you do p - \"shape size\", but\n\/\/ you clamp the result to >0, done below by using max() with 0\n\/\/ i'm having trouble putting this into words corretcly, but it was really easy\n\/\/ to understand once I sketched out a rect and points on paper, \n\/\/ that was enough for me to be able to derive the 3D version \n\/\/\n\/\/ the last part is to account for is p is insde the box, \n\/\/ in which case we need to return a negative value\n\/\/ for that value, its a simple check of which side is the closest\nfloat sdBox(vec3 p, vec3 s)\n{\n    vec3 diffVec = abs(p) - s;\n    float surfDiff_Outter = length(max(diffVec,0.0));\n    float surfDiff_Inner = min( max(diffVec.z,max(diffVec.x,diffVec.y)),0.0);\n    return surfDiff_Outter + surfDiff_Inner;              \n}\n\/*\n\/\/ Minimial IQ version\nfloat sdBox( vec3 p, vec3 s )\n{\n  vec3 d = abs(p) - s;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n*\/\n\n\/\/ ~~~~~~~ signed distance function for torus\n\/\/ input t --> torus specs where:\n\/\/  t.x = torus circumference\n\/\/  t.y = torus thickness\n\/\/  \n\/\/ think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n\/\/ first flatten the y axis of p (by using p.xz) and get the distance to \n\/\/ the torus circumference\/core\/radius which is flat on the y axis\n\/\/ then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{\n    float distPtoTorusCircumference = length(vec2( length(p.xz)-t.x , p.y));\n    return distPtoTorusCircumference - t.y;\n}\n\/*\n\/\/ IQ version\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n*\/\n\n\/\/ ~~~~~~~ signed distance function for plane\n\/\/  input ps --> specs of plane\n\/\/        ps.x --> size x\n\/\/        ps.y --> size z\n\/\/ plane extends indefinately in x and z, \n\/\/ so just return height from floor (y)\nfloat sdPlane(vec3 p)\n{\n    return p.y;\n}\n\n\/\/ ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n\/\/ http:\/\/iquilezles.org\/www\/articles\/smin\/smin.htm\n\/\/ input d1 --> distance value of object a\n\/\/ input d1 --> distance value of object b\n\/\/ input k --> blend factor\n\/\/ output --> smoothed\/blended output\nfloat smin( float d1, float d2, float k)\n{    \n    float h = clamp( 0.5+0.5*(d2-d1)\/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n\/\/ ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n\/\/ input o1 --> object 1 (dist and material color)\n\/\/ input 02 --> object 2 (dist and material color)\n\/\/ input bf --> blend factor\n\/\/ output --> blended dist, blended material color\n\/\/ TODO: FIX\/IMPROVE COLOR BLENDING LOGIC\nvec4 opBlend( vec4 o1, vec4 o2, float bf)\n{    \n    float distBlend = smin( o1.x, o2.x, bf);\n    \n    \/\/ blend color based on prozimity to surface\n    float dr1 = 1.0 - clamp(o1.x,0.0,1.0);\n    float dr2 = 1.0 - clamp(o2.x,0.0,1.0);\n    vec3 dc1 = dr1 * o1.yzw;\n    vec3 dc2 = dr2 * o2.yzw;\n    \n    return vec4(distBlend, dc1+dc2);\n}\n\n\/\/ ~~~~~~~ domain deformation, twists the shape\n\/\/ input p --> original ray position\n\/\/ input t --> twist scale factor\n\/\/ output --> twisted ray position\n\/\/ \n\/\/ need more max itterations on ray march for stronger\/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw )\n{\n    float  c = cos(t * p.y + yaw);\n    float  s = sin(t * p.y + yaw);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n\/\/ ~~~~~~~ do Union \/ combine 2 sd objects\n\/\/ input vec2 --> .x is the distance, .y is the object ID\n\/\/ returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    if(o1.x < o2.x)\n        return o1;\n    else \n        return o2;\n}\n\n\/\/ ~~~~~~~ do shape subtract, cuts d2 out of d1\n\/\/ by using  the negative of d2, were effectively comparing wrt to internal d\n\/\/ input d1 --> object\/distance 1\n\/\/ input d2 --> object\/distance 2\n\/\/ output --> cut out distance\nfloat opSub(float d1,float d2)\n{\n    return max(d1,-d2);   \n}\n\n\n\/\/ ~~~~~~~~ generates world position of point light\n\/\/ output --> wolrd pos of point light\nvec3 generateLightPos()\n{\n    float lOR_X = 1.20;\n    float lOR_Y = 2.40;\n    float lOR_Z = 3.0;\n    float lORS = 0.65;\n    float lpX = lOR_X*cos(lORS*iGlobalTime);\n    float lpY = lOR_Y*sin(lORS*iGlobalTime);\n    float lpZ = lOR_Z*cos(lORS*iGlobalTime);\n    \n    return vec3(lpX,abs(lpY),lpZ);\n}\n\n\/\/ ~~~~~~~ map out the world\n\/\/ input p --> is ray position\n\/\/ basically find the object\/point closest to the ray by\n\/\/ checking all the objects with respect to p\n\/\/ move objects\/shapes by messing with p\n\/\/ outputs closest distance and blended colors for that surface as a vec4\nvec4 map(vec3 p)\n{\n    \/\/ results container\n    vec4 res;    \n    \n    \/\/ define objects\n        \/\/ sphere 1\n        \/\/ sphere: radius, orbit radius, orbit speed, orbit offset, position\n    float sR = 1.359997;\n    float sOR = 2.666662;\n    float sOS = 0.85;\n    vec3 sOO = vec3(2.66662,0.0,0.0);\n    vec3 sOP = (sOO + vec3(sOR*cos(sOS*iGlobalTime),sOR*sin(sOS*iGlobalTime),0.0));\n    vec3 sP = p - sOP;\n    vec4 sphere_1 = vec4( sdSphere(sP,sR), accessColors(1.0) );\n    \n    vec3 sP2 = p - 1.0515*sOP.xzy;\n    vec4 sphere_2 = vec4( sdSphere(sP2,1.1750*sR), accessColors(5.0) );\n    \n    vec3 lightSP = p - generateLightPos();\n    vec4 lightSphere = vec4( sdSphere(lightSP,0.24), accessColors(5.0));\n    \n        \/\/  torus 1    \n    vec2 torusSpecs = vec2(1.76, 0.413333);\n    float twistSpeed = 0.35;\n    float twistPower = 3.0*sin(twistSpeed * iGlobalTime);\n        \/\/ to twist the torus (or any object), we actually distort p\/space (domain) itself,\n        \/\/ this then gives us a distorted view of the object\n    vec3 torusPos = vec3(0.0);\n    vec3 distortedP = opTwist(p - torusPos, twistPower, 0.0) ;\n        \/\/  domain distortion correction:\n        \/\/  needed to find this by hand, inversely proportional to domain deformation\n    float ddc = 0.25;\n    vec4 torus_1 = vec4(ddc*sdTorus(distortedP,torusSpecs),accessColors(2.0));\n    \n    vec3 boxPos = p - vec3(4.0, -0.800,1.0);\n    vec4 box_1 = vec4(sdBox(boxPos,vec3(0.50,1.0,1.5)),accessColors(3.0));\n    \n    vec3 planePos = p - vec3(0.0, -3.0, 0.0);\n    vec4 plane_1 = vec4(sdPlane(planePos), accessColors(4.0));\n    \n    \/\/ blend objects    \n    res = opBlend( sphere_1, torus_1, 0.7 );     \n    \n    res = opBlend( res, box_1, 0.6 );\n    res = opBlend( res, plane_1, 0.5);\n    \n    \/\/res = opBlend( res, sphere_2, 0.87);\n    res.x = opSub(res.x,sphere_2.x);\n    \n    \/\/ visualize light pos, but blocks light :\/\n    \/\/res = opBlend( res, lightSphere, 0.1);\n    \n    return res;\n}\n\n\/\/ ~~~~~~~ cast\/march ray through the word and see what it hits\n\/\/ input ro --> ray origin point\/position\n\/\/ input rd --> ray direction\n\/\/ in\/out --> itterationRatio (used for AA),in\/out cuz no more room in vec\n\/\/ output is vec3 where\n\/\/  .x = distance travelled by ray\n\/\/  .y = hit object's ID\n\/\/  .z = itteration ratio\nvec4 castRay( vec3 ro, vec3 rd, inout float itterRatio)\n{\n    \/\/ variables used to control the marching process\n    const float maxMarchCount = 200.0;\n    float maxRayDistance = 50.0;\n    \/\/ making this more precise can also help with AA detection\n    \/\/ value lower than 0.000001 causes noise\n    float minPrecisionCheck = 0.000001;\n    \n    float t = 0.0; \/\/ travelled distance by ray\n    vec3 oc = vec3(1.0,0.0,1.0); \/\/ object color\n    itterRatio = 0.0;\n    \n    for(float i = 0.0; i < maxMarchCount; i++)\n    {\n        \/\/ get closest object to current ray position\n        vec4 res = map(ro + rd*t);\n        \n        \/\/ stop itterating\/marching once either we've past max ray length \n        \/\/ or\n        \/\/ once we're close enough to an object (defined by the precision check variable)\n        if(t > maxRayDistance || res.x < minPrecisionCheck)\n           break;\n        \n        \/\/ move ray forward by distance to closet object, see\n        \/\/ http:\/\/http.developer.nvidia.com\/GPUGems2\/elementLinks\/08_displacement_05.jpg\n        t += res.x; \n        oc = res.yzw;\n        itterRatio = i\/maxMarchCount;\n    }\n    \n    \/\/ if ray goes beyond max distance, force ID back to background one\n    if(t > maxRayDistance)\n        oc = accessColors(-1.0);\n    \n    return vec4(t,oc.xyz);\n}\n\n\n\/\/ ~~~~~~~ hardShadow, raymarches from shading point to light\n\/\/  input sp --> position of surface we are shading\n\/\/  input lp --> light position\n\/\/  output float --> 0.0 means shadow, 1.0 means no shadow\nfloat castRay_HardShadow(vec3 sp, vec3 lp)\n{\n    const int hsMaxMarchCount = 100;\n    const float hsPrecision = 0.0001;\n    \n    \/\/ direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    \/\/ max travel distance of hard shadow ray\n    float hsMaxT = length(lp - sp);\n    \/\/ travelled distance by hard shadow ray\n    float hsT = 0.02; \/\/2.10 * hsPrecision;\n    for(int i = 0; i < hsMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*hsT).x;\n        \/\/ if object hit on way to light, return hard shadow\n        if(dist < hsPrecision)\n            return 0.0;\n        hsT += dist;\n    }\n    \/\/ no object hit on the way to light source\n    return 1.0;\n}\n\n\/\/ ~~~~~~~ softShadow, took pointers from iq's\n\/\/ http:\/\/www.iquilezles.org\/www\/articles\/rmshadows\/rmshadows.htm\n\/\/ and\n\/\/ https:\/\/www.shadertoy.com\/view\/Xds3zN\n\/\/  input sp --> position of surface we are shading\n\/\/  input lp --> light position\n\/\/  output float --> amount of shadow\nfloat castRay_SoftShadow(vec3 sp, vec3 lp)\n{\n    const int ssMaxMarchCount = 90;\n    const float ssPrecision = 0.001;\n    \n    \/\/ direction of ray, from shaded surface point to light pos\n    vec3 rd = normalize(lp - sp);\n    \/\/ max travel distance of hard shadow ray\n    float ssMaxT = length(lp - sp);\n    \/\/ travelled distance by hard shadow ray\n    float ssT = 0.02;\n    \/\/ softShadow value\n    float ssV = 1.0;\n    for(int i = 0; i < ssMaxMarchCount; i++)\n    {\n        float dist = map(sp + rd*ssT).x;\n        \/\/ if object hit on way to light, return hard shadow\n        if(dist < ssPrecision)\n            return 0.0;\n        \n        ssV = min(ssV, 16.0*dist\/ssT);\n        ssT += dist;\n        if(ssT > ssMaxT)\n            break;\n    }\n    return ssV;\n}\n\n\/\/ ~~~~~~~ ambientOcclusion\n\/\/ just cast from surface point in direction of normal to see if any hit\n\/\/ basic concept from:\n\/\/ http:\/\/9bitscience.blogspot.com\/2013\/07\/raymarching-distance-fields_14.html\nfloat castRay_AmbientOcclusion(vec3 sp, vec3 nor)\n{\n    const int aoMaxMarchCount = 20;\n    const float aoPrecision = 0.001;\n    \/\/ range of ambient occlusion\n    float aoMaxT = 1.0;\n    float aoT = 0.01;\n    float aoV = 1.0;\n    for(int i = 0; i < aoMaxMarchCount; i++)\n    {\n       float dist = map(sp + nor*aoT).x;\n       aoV = aoT\/aoMaxT;\n       if(dist < aoPrecision)\n           break;              \n       if(aoT > aoMaxT)\n           break;\n       aoT += dist;\n    }\n    \n    return clamp(aoV, 0.0,1.0);\n}\n\n\/\/ ~~~~~~ calculate normal of closest objects surface given a ray position\n\/\/ input p --> ray position (calculated previously from ray cast position, no iteration now\n\/\/ output --> surface normal vector\n\/\/\n\/\/ gets the surface normal by sampling neaby points and getting direction of diffs\n\nvec3 calculateNormal(vec3 p)\n{\n    float normalEpsilon = 0.0001;\n    vec3 eps = vec3(normalEpsilon,0,0);\n    vec3 normal = vec3( map(p + eps.xyy).x - map(p - eps.xyy).x,\n                        map(p + eps.yxy).x - map(p - eps.yxy).x,\n                        map(p + eps.yyx).x - map(p - eps.yyx).x\n                       );\n    return normalize(normal);\n}\n\n\/\/ ~~~~~~~ calculates the normals near point p in world space\n\/\/ input p --> ray position world coordinates\n\/\/ input oN --> normal vector at point p\n\/\/ output --> averaged? out norals diffs of nearby points  \nvec3 nearbyNormalsDiff(vec3 p, vec3 oN)\n{\n    \/\/ world pos diff\n    float wPD = 0.0;\n    wPD = 0.057;\n    \/\/wPD = abs(0.05*sin(0.25*iGlobalTime)) + 0.1;\n    \n    vec3 n1 = calculateNormal(p+vec3(wPD,wPD,wPD));\n    \/\/vec3 n2 = calculateNormal(p+vec3(wPD,wPD,-wPD));\n    \/\/vec3 n3 = calculateNormal(p+vec3(wPD,-wPD,wPD));\n    \/\/vec3 n4 = calculateNormal(p+vec3(wPD,-wPD,-wPD));\n    \n    \/\/ doing full on 8 points version seems to crash it\n\n    vec3 diffVec = vec3(0.0);\n    diffVec += oN - n1;\n    \/\/diffVec += oN - n2;\n    \/\/diffVec += oN - n3;\n    \/\/diffVec += oN - n4;\n        \n    return diffVec;    \n}\n\n\/\/ ~~~~~~~ do gamma correction\n\/\/ from iq's pageon outdoor lighting:\n\/\/ http:\/\/www.iquilezles.org\/www\/articles\/outdoorslighting\/outdoorslighting.htm\n\/\/ input c --> original color\n\/\/ output --> gamma corrected output\nvec3 applyGammaCorrection(vec3 c)\n{\n    return pow( c, vec3(1.0\/2.2) );\n}\n\n\/\/ ~~~~~~~ do fog\n\/\/ from iq's pageon fog:\n\/\/ http:\/\/www.iquilezles.org\/www\/articles\/fog\/fog.htm\n\/\/ input c --> original color\n\/\/ input d --> pixel world distance\n\/\/ input fc1 --> fog color 1\n\/\/ input fc2 --> fog color 2\n\/\/ input fs -- fog specs>\n\/\/       fs.x --> fog density\n\/\/       fs.y --> fog color lerp exponent (iq's default is 8.0)\n\/\/ input cRD --> camera ray direction\n\/\/ input lRD --> light ray direction\n\/\/ output --> color with fog applied\nvec3 applyFog(vec3 c,float d,vec3 fc1,vec3 fc2,vec2 fs,vec3 cRD,vec3 lRD)\n{\n    float fogAmount = 1.0 - exp(-d*fs.x);\n    float lightAmount = max( dot( cRD, lRD ), 0.0 );\n    vec3 fogColor = mix(fc1,fc2,pow(lightAmount,fs.y));\n    return mix(c,fogColor,fogAmount);\n}\n\n\n\n\/\/ ~~~~~~~ calculates attenuation factor for light for a given distance and parameters\n\/\/ input cF --> constant factor\n\/\/ input lF --> linear factor\n\/\/ input qF --> quadratic factor\n\/\/ the factors above should range between 0 and 1\n\/\/ pure realistic would follow inverse square law, i.e. pure quadtratic, so cF=0,lF=0,qF=1\nfloat calculateLightAttn(float cF, float lF, float qF, float d)\n{\n    float falloff = 1.0\/(cF + lF*d + qF*d*d);\n    return falloff;\n}\n\n\/\/ ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n\/\/ input ro --> pixel's ray original position\n\/\/ input rd --> pixel's ray direction\n\/\/ in\/out aaF --> antialiasing factor\n\/\/ output --> pixel color\nvec4 render(vec3 ro, vec3 rd, inout float aaF)\n{        \n    vec3 ambientLightColor = vec3( 0.001 , 0.001, 0.001 );\n        \n    vec3 lightPos = generateLightPos();\n    float iR = 0.0;\n    vec4 res = castRay(ro, rd, iR);\n    float t = res.x;\n    vec3 objectColor = vec3(1.0,0.0,1.0);\n    objectColor = res.yzw;\n    \n    \/\/ hard set pixel value if its a background one\n    if(objectColor == accessColors(-1.0))\n        return vec4(objectColor.xyz,iR);\n    else\n    {\n        \/\/objectColor = normalize(objectColor);\n        \/\/ calculate pixel normal\n        vec3 pos = ro + t*rd;\n        vec3 normal = calculateNormal(pos);\n        \n        \n        float dist = length(pos);\n        vec3 lightDir = normalize(lightPos-pos);\n        float lightFalloff = calculateLightAttn(0.0,0.0,1.0,dist);\n        float lightIntensity = 6.0;\n        float lightFactor = lightFalloff * lightIntensity;\n        \n        \/\/ treating light as a point light (calculating normal based on pos)\n        float surf = lightFactor * clamp(dot(normal,lightDir), 0.0, 1.0);\n        vec3 pixelColor = objectColor * surf;\n        \n        pixelColor *= castRay_SoftShadow(pos,lightPos);\n        pixelColor *= castRay_AmbientOcclusion(pos,normal);\n        pixelColor += ambientLightColor;\n        \n        vec3 fc_1 = vec3(0.5,0.6,0.7);\n        vec3 fc_2 = vec3(1.0,0.9,0.7);\n        vec2 fS = vec2(0.020,2.0);                    \n        pixelColor = applyFog(pixelColor,dist,fc_1,fc_2,fS,rd,lightDir);        \n        pixelColor = applyGammaCorrection(pixelColor);\n        \n        float aaFactor = 0.0;\n        if(isPseudoAA == true)\n        {\n            \/\/ AA RELATED STUFF\n            \/\/ visualize itteration count of pixels\n            \/\/pixelColor = vec3(res.z);\n            vec3 nnDiff = nearbyNormalsDiff(pos,normal);\n            \/\/ pseudo edge\/tangent detect? wrt ray, approx grazing ray \n            float sEdge = clamp(1.0 + dot(rd,normal),0.0,1.0);\n            \/\/sEdge *= 1.0 - (t\/200.0);\n\n            \/\/ TODO : better weighing for the 2 factors to narrow down on AA p\n            \/\/ gets affected by castRay precision variable\n            \n            \/\/aaFactor = 0.75*pow(sEdge,10.0)+ 0.5*iR;\n            aaFactor += 0.75*pow(sEdge,10.0);\n            \/\/ visualizes march count, looks cool!\n            aaFactor += 0.5*iR;\n            aaFactor += 0.5 *length(nnDiff);\n\n            \/\/ visualize AA needing pizel\n            pixelColor = vec3(aaFactor);\n            \/\/pixelColor = nnDiff;\n            aaF = aaFactor;\n        }\n\n        \/\/ pixelColor in xyz, w is itteration count, used for AA\n        vec4 pixelData = vec4(pixelColor.xyz,aaFactor);\n        \n        return pixelData; \n    }    \n}\n\n\n\/\/ ~~~~~~~ generate camera ray direction, different for each frag\/pixel\n\/\/ input fCoord --> pixel coordinate\n\/\/ input cMatric --> camera matrix\n\/\/ output --> ray direction\nvec3 calculateRayDir(vec2 fCoord, mat3 cMatrix)\n{        \n    vec2 p = ( -iResolution.xy + 2.0 * fCoord.xy ) \/ iResolution.y;\n        \n    \/\/ determines ray direction based on camera matrix\n    \/\/ \"lens length\" seems to be related to field of view \/ ray divergence\n    float lensLen0gth = 2.0;\n    vec3 rD = cMatrix * normalize( vec3(p.xy,2.0) );\n    return rD;\n}\n\n\n\/\/ ~~~~~~~ render anti aliased, based on pixel's itteration\/march count\n\/\/          only effective for shape edges, doesn't fix surface col patterns\n\/\/ input fCoord --> pixel coordinate\n\/\/ input cPos --> camera position\n\/\/ input cMat --> camera matrix\n\/\/ output vec3 --> pixel antialaised color\nvec3 render_AA(vec2 fCoord,vec3 cPos,mat3 cMat)\n{\n    vec3 rd = calculateRayDir(fCoord,cMat);\n    float aaF = 0.0;\n    vec4 pData = render(cPos,rd,aaF);    \n    vec3 col = pData.xyz;\n    float aaThreashold = 0.845;\n    \/\/ controls blur amount\/sample distance\n    float aaPD = 0.500;\n    \/\/ if requires AA, get color from nearby pixels and average out\n    \/\/col = vec3(0.0);\n    if(aaF > aaThreashold)\n    {\n        float dummy = 0.0;\n        vec3 rd_U = calculateRayDir(fCoord + vec2(0,aaPD),cMat);\n        vec3 pc_U = render(cPos,rd_U,dummy).xyz;\n        \n        vec3 rd_D = calculateRayDir(fCoord + vec2(0,-aaPD),cMat);\n        vec3 pc_D = render(cPos,rd_D,dummy).xyz;\n        \n        vec3 rd_R = calculateRayDir(fCoord + vec2(aaPD,0),cMat);\n        vec3 pc_R = render(cPos,rd_R,dummy).xyz;\n        \n        vec3 rd_L = calculateRayDir(fCoord + vec2(-aaPD,0),cMat);\n        vec3 pc_L = render(cPos,rd_L,dummy).xyz;\n                \n        \/*\n        vec3 rd_UR = calculateRayDir(fCoord + vec2(aaPD,aaPD),cMat);\n        vec3 pc_UR = render(cPos,rd_UR,dummy).xyz;\n        \n        vec3 rd_UL = calculateRayDir(fCoord + vec2(-aaPD,aaPD),cMat);\n        vec3 pc_UL = render(cPos,rd_UL,dummy).xyz;\n        \n        vec3 rd_DR = calculateRayDir(fCoord + vec2(aaPD,-aaPD),cMat);\n        vec3 pc_DR = render(cPos,rd_DR,dummy).xyz;\n        \n        vec3 rd_DL = calculateRayDir(fCoord + vec2(-aaPD,-aaPD),cMat);\n        vec3 pc_DL = render(cPos,rd_DL,dummy).xyz;\n        col = pc_U+pc_D+pc_R+pc_L+pc_UR+pc_UL+pc_DR+pc_DL;        \n        col *= 1.0\/8.0;     \n        *\/\n        \n        col = 0.25*(pc_U+pc_D+pc_R+pc_L);\n        \/\/ used to visualize pixels that are getting AA\n        \/\/col = vec3(1.0,0.0,1.0) + 0.001*(pc_U+pc_D+pc_R+pc_L);        \n    }        \n    return col;\n}\n\n\/\/ ~~~~~~~ creates camera matrix used to transform ray point\/direction\n\/\/ input camPos --> camera position\n\/\/ input targetPos --> look at target position\n\/\/ input roll --> how much camera roll\n\/\/ output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, float roll )\n{\n    vec3 cw = normalize(targetPos - camPos);\n    vec3 cp = vec3(sin(roll), cos(roll),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    \/\/ camera stuff, the same for all pixel in a frame\n    float camOrbitSpeed = 0.10;\n    float camOrbitRadius = 7.3333;\n    float camPosX = camOrbitRadius * cos( camOrbitSpeed * iGlobalTime);\n    float camPosZ = camOrbitRadius * sin( camOrbitSpeed * iGlobalTime);\n    vec3 camPos = vec3(camPosX, 0.5, camPosZ);\n    vec3 lookAtTarget = vec3(0.0);\n    mat3 camMatrix = setCamera(camPos, lookAtTarget, 0.0);\n    \n    \/\/ ordinary, no AA render\n    vec3 rd = calculateRayDir(fragCoord,camMatrix);        \n    vec3 col;\n    \n    if(isPseudoAA == false)\n    {\n    \tfloat dum = 0.0; col = render(camPos,rd,dum).xyz;\n    }\n   \telse\n    \tcol = render_AA(fragCoord,camPos,camMatrix);\n    \n    fragColor = vec4(col,1.0);\n    \/\/fragColor = vec4(fragCoord.xy\/iResolution.y,0,0);\n}\n\n\n","name":"","description":"","type":"image"}]}}