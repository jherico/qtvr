{"Shader":{"ver":"0.1","info":{"id":"4dVGRW","date":"1454231232","viewed":62,"name":"Post-Processing: Cel Shading","username":"hughsk","description":"Cel shading \u2014 outlines achieved using edge detection on normals\/depth in post. The raymarching buffer stores normals in RGB, and depth in A.","likes":14,"published":3,"flags":32,"tags":["shading","edge","outline","toon","cel"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"mat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nvec3 getRay(vec3 origin, vec3 target, vec2 screenPos, float lensLength) {\n  mat3 camMat = calcLookAtMatrix(origin, target, 0.0);\n  return normalize(camMat * vec3(screenPos, lensLength));\n}\n\nvec2 squareFrame(vec2 screenSize, vec2 coord) {\n  vec2 position = 2.0 * (coord.xy \/ screenSize.xy) - 1.0;\n  position.x *= screenSize.x \/ screenSize.y;\n  return position;\n}\n\nvec2 getDeltas(sampler2D buffer, vec2 uv) {\n  vec2 pixel = vec2(1. \/ iResolution.xy);\n  vec3 pole = vec3(-1, 0, +1);\n  float dpos = 0.0;\n  float dnor = 0.0;\n    \n  vec4 s0 = texture2D(iChannel0, uv + pixel.xy * pole.xx); \/\/ x1, y1\n  vec4 s1 = texture2D(iChannel0, uv + pixel.xy * pole.yx); \/\/ x2, y1\n  vec4 s2 = texture2D(iChannel0, uv + pixel.xy * pole.zx); \/\/ x3, y1\n  vec4 s3 = texture2D(iChannel0, uv + pixel.xy * pole.xy); \/\/ x1, y2\n  vec4 s4 = texture2D(iChannel0, uv + pixel.xy * pole.yy); \/\/ x2, y2\n  vec4 s5 = texture2D(iChannel0, uv + pixel.xy * pole.zy); \/\/ x3, y2\n  vec4 s6 = texture2D(iChannel0, uv + pixel.xy * pole.xz); \/\/ x1, y3\n  vec4 s7 = texture2D(iChannel0, uv + pixel.xy * pole.yz); \/\/ x2, y3\n  vec4 s8 = texture2D(iChannel0, uv + pixel.xy * pole.zz); \/\/ x3, y3\n\n  dpos = (\n    abs(s1.a - s7.a) +\n    abs(s5.a - s3.a) +\n    abs(s0.a - s8.a) +\n    abs(s2.a - s6.a)\n  ) * 0.5;\n  dpos += (\n    max(0.0, 1.0 - dot(s1.rgb, s7.rgb)) +\n    max(0.0, 1.0 - dot(s5.rgb, s3.rgb)) +\n    max(0.0, 1.0 - dot(s0.rgb, s8.rgb)) +\n    max(0.0, 1.0 - dot(s2.rgb, s6.rgb))\n  );\n  \n  dpos = pow(max(dpos - 0.5, 0.0), 5.0);\n    \n  return vec2(dpos, dnor);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec3 ro = vec3(sin(iGlobalTime * 0.2), 1.5, cos(iGlobalTime * 0.2)) * 5.;\n  vec3 ta = vec3(0, 0, 0);\n  vec3 rd = getRay(ro, ta, squareFrame(iResolution.xy, fragCoord.xy), 2.0);\n  vec2 uv = fragCoord.xy \/ iResolution.xy;\n    \n  vec4 buf = texture2D(iChannel0, fragCoord.xy \/ iResolution.xy);\n  float t = buf.a;\n  vec3 nor = buf.rgb;\n  vec3 pos = ro + rd * t;\n    \n  vec3 col = vec3(0.5, 0.8, 1);\n  vec2 deltas = getDeltas(iChannel0, uv);\n  if (t > -0.5) {\n    col = vec3(1.0);\n    col *= max(0.3, 0.3 + dot(nor, normalize(vec3(0, 1, 0.5))));\n    col *= vec3(1, 0.8, 0.35);\n  }\n  col.r = smoothstep(0.1, 1.0, col.r);\n  col.g = smoothstep(0.1, 1.1, col.g);\n  col.b = smoothstep(-0.1, 1.0, col.b);\n  col = pow(col, vec3(1.1));\n  col -= deltas.x - deltas.y;\n  \n    \n  fragColor = vec4(col, 1);\n}","name":"","description":"","type":"image"},{"inputs":[],"outputs":[{"channel":"0"}],"code":"float sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nvec2 mirror(vec2 p, float v) {\n  float hv = v * 0.5;\n  vec2  fl = mod(floor(p \/ v + 0.5), 2.0) * 2.0 - 1.0;\n  vec2  mp = mod(p + hv, v) - hv;\n    \n  return fl * mp;\n}\n\nvec2 rotate2D(vec2 p, float a) {\n  return p * mat2(cos(a), -sin(a), sin(a),  cos(a));\n}\n\nfloat map(vec3 p) {\n  float r = iMouse.z > 0.0 ? iMouse.x \/ 100.0 : iGlobalTime * 0.9;\n  p.xz = mirror(p.xz, 4.);\n  p.xz = rotate2D(p.xz, r);\n  float d = sdBox(p, vec3(1));\n  d = min(d, sdBox(p, vec3(0.1, 0.1, 3)));\n  d = min(d, sdBox(p, vec3(3, 0.1, 0.1)));\n  return d;\n}\n\nmat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nvec3 getRay(vec3 origin, vec3 target, vec2 screenPos, float lensLength) {\n  mat3 camMat = calcLookAtMatrix(origin, target, 0.0);\n  return normalize(camMat * vec3(screenPos, lensLength));\n}\n\nfloat calcRayIntersection(vec3 rayOrigin, vec3 rayDir, float maxd, float precis) {\n  float latest = precis * 2.0;\n  float dist   = +0.0;\n  float type   = -1.0;\n  float res    = -1.0;\n\n  for (int i = 0; i < 30; i++) {\n    if (latest < precis || dist > maxd) break;\n\n    float result = map(rayOrigin + rayDir * dist);\n\n    latest = result;\n    dist  += latest;\n  }\n\n  if (dist < maxd) {\n    res = dist;\n  }\n\n  return res;\n}\n\nvec2 squareFrame(vec2 screenSize, vec2 coord) {\n  vec2 position = 2.0 * (coord.xy \/ screenSize.xy) - 1.0;\n  position.x *= screenSize.x \/ screenSize.y;\n  return position;\n}\n\nvec3 calcNormal(vec3 pos, float eps) {\n  const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n  const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n  const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n  const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n  return normalize( v1 * map( pos + v1*eps ) +\n                    v2 * map( pos + v2*eps ) +\n                    v3 * map( pos + v3*eps ) +\n                    v4 * map( pos + v4*eps ) );\n}\n\nvec3 calcNormal(vec3 pos) {\n  return calcNormal(pos, 0.002);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = squareFrame(iResolution.xy, fragCoord.xy);\n  vec3 ro = vec3(sin(iGlobalTime * 0.2), 1.5, cos(iGlobalTime * 0.2)) * 5.;\n  vec3 ta = vec3(0, 0, 0);\n  vec3 rd = getRay(ro, ta, uv, 2.0);\n    \n  float t = calcRayIntersection(ro, rd, 20.0, 0.001);\n  vec3 pos = ro + rd * t;\n  vec3 nor = calcNormal(pos);\n    \n  fragColor = vec4(nor, t);\n}","name":"","description":"","type":"buffer"}]}}