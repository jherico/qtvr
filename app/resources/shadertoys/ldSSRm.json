{"Shader":{"ver":"0.1","info":{"id":"ldSSRm","date":"1410188124","viewed":814,"name":"Grass close-up","username":"Dave_Hoskins","description":"Another attempt at rendering grass.","likes":9,"published":3,"flags":0,"tags":["3d","raymarching","grass"],"hasliked":0},"renderpass":[{"inputs":[{"id":4,"src":"\/presets\/tex03.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":8,"src":"\/presets\/tex07.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":9,"src":"\/presets\/tex08.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Grass close-up\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ Created by David Hoskins.\n\n#define PRECISION 0.05\n#define MOD2 vec2(.16632,.17369)\n#define MOD3 vec3(.16532,.17369,.15787)\nvec3 sunDir = normalize(vec3(.2, 0.6, -1.3));\n\n\/\/--------------------------------------------------------------------------------------------------\nvec3 TexCube(in vec3 p, in vec3 n )\n{\n    p *= vec3(.5, .1, .5);\n\tvec3 x = texture2D( iChannel0, p.yz, -100.0 ).xyz;\n\tvec3 y = texture2D( iChannel1, p.zx, -100.0 ).xyz;\n\tvec3 z = texture2D( iChannel2, p.xy, -100.0 ).xyz;\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\n\/\/--------------------------------------------------------------------------------------------------\nvec2 Hash2(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n\n\/\/--------------------------------------------------------------------------------------------------\nvec2 Noise( in vec2 x )\n{\n    return mix(Hash2(floor(x)), Hash2(floor(x+1.0)), fract(x));\n}\n\n\/\/--------------------------------------------------------------------------------------------------\nvec4 HashMove2(vec2 p)\n{\n    return vec4(Noise(p), Noise(p + iGlobalTime*.08));\n}\n\n\/\/--------------------------------------------------------------------------------------------------\nvec4 Voronoi( vec3 p, out float which)\n{\n    \n    vec2 f = fract(p.xz);\n    p.xz = floor(p.xz);\n\tfloat d = 1.0e10;\n    vec3 id = vec3(0.0);\n    \n\tfor (int xo = -1; xo <= 1; xo++)\n\t{\n\t\tfor (int yo = -1; yo <= 1; yo++)\n\t\t{\n            vec2 g = vec2(xo, yo);\n            vec4 n = HashMove2(p.xz + g);\n\t\t\tvec2 tp = g + .5 + sin(p.y + 6.2831 * n.zw) - f;\n            float d2 = dot(tp, tp);\n\t\t\tif (d2 < d)\n            {\n                \/\/ 'which' is the colour code for each stem...\n                d = d2;\n                which = n.x*7.0+n.y*7.0;\n                id = vec3(tp.x, p.y, tp.y);\n            }\n\t\t}\n\t}\n    return vec4(id, 1.35-pow(d, .17));\n}\n\n\n\/\/--------------------------------------------------------------------------------------------------\nfloat MapGrass( in vec3 pos)\n{\n    float which = 0.0;\n    vec4 ret = Voronoi(pos, which);\n    ret.w \/= clamp(pos.y*.2, 0.0, 1.2);\n\treturn  .9-fract(which*382.321)*.15 + pos.y * .2 * smoothstep(6.5, 10.0, pos.y)-ret.w;\n}\n\n\/\/--------------------------------------------------------------------------------------------------\nvec4 MapGrassID( in vec3 pos, out float which)\n{\n    vec4 ret = Voronoi(pos, which);\n    ret.w \/= clamp(pos.y*.2, 0.0, 1.);\n\treturn vec4(ret.xyz, .9-fract(which*2.321)*.15 + pos.y * .2 * smoothstep(6.5, 10.0, pos.y) - ret.w);\/\/+sin(floor(which)*5431.3)*1.2);\n}\n\n\/\/--------------------------------------------------------------------------------------------------\nfloat Hash12(vec2 p)\n{\n\tp  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4337);\n}\n\n\n\/\/--------------------------------------------------------------------------------------------------\nvec4 Raymarch( in vec3 ro, in vec3 rd, in vec2 uv, out float which)\n{\n    const float grassTop = 7.5;\n\tfloat maxd = 400.0;\n\t\n    vec4 h = vec4(1.0);\n    float t = Hash12(uv*1.15231)*.2;\n    \/\/ Cast the ray down to the top of the grass\n    \/\/ Because we're not interested in anything else...\n    if (ro.y > grassTop && rd.y < 0.0)\n    {\n        float d = (ro.y-grassTop)\/ -rd.y;\n        t += d;\n    }\n    vec3 po = vec3(20.0);\n    bool hit = false;\n    for (int i = 0; i < 65; i++)\n    {\n        po = ro + rd * t;    \n        h = MapGrassID(po, which);\t \n        if(h.w < PRECISION || t > maxd) break;\n        t += h.w + clamp(t * .001, 0.005, 50.0);\n    }\n\n    if (t > maxd || po.y > grassTop)t = -1.0;\n    \n    return vec4(h.xyz, t);\n}\n\n\/\/--------------------------------------------------------------------------------------------------\nvec3 Normal( in vec3 pos, in float which)\n{\n    which *= 20.0;\n    vec2 eps = vec2(PRECISION, 0.0);\n\tvec3 norm = normalize( vec3(\n           MapGrass(pos+eps.xyy) - MapGrass(pos-eps.xyy),\n           MapGrass(pos+eps.yxy) - MapGrass(pos-eps.yxy),\n           MapGrass(pos+eps.yyx) - MapGrass(pos-eps.yyx) ) );\n    \n    \/\/ This squashes the Normal on a random x\/z plane.\n\t\/\/ It fakes a flattened grass stem...\n\tmat2 angle = mat2(cos(which), sin(which), -sin(which), cos(which));\n\tnorm.xz *= angle * vec2(1.0, .01);\n\treturn normalize(norm);\n}\n\n\/\/--------------------------------------------------------------------------\nfloat FractalNoise(in vec2 xy)\n{\n\tfloat w = 1.5;\n\tfloat f = 0.0;\n    xy *= .01;\n\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tf += texture2D(iChannel2, xy \/ w, -99.0).x * w;\n\t\tw *= 0.5;\n\t}\n\treturn f;\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 GetSky(in vec3 rd)\n{\n\tvec3 col = vec3(.65, .85, 1.0);\n\tcol \t\t= mix(col, vec3(.5), pow(abs(rd.y), .5));\n    return col;\n}\n\/\/--------------------------------------------------------------------------\nvec3 GetClouds(in vec3 sky, in vec3 cameraPos, in vec3 rd)\n{\n\t\/\/if (rd.y < 0.0) return sky;\n\t\/\/ Uses the ray's y component for horizon fade of fixed colour clouds...\n\tfloat v = (370.0-cameraPos.y)\/rd.y;\n\trd.xz = (rd.xz * v + cameraPos.xz+vec2(0.0,0.0)) * 0.004;\n\tfloat f = (FractalNoise(rd.xz) -.5);\n\tvec3 cloud = mix(sky, vec3(1.0), max(f, 0.0));\n\treturn cloud;\n}\n\n\/\/--------------------------------------------------------------------------------------------------\nvec3 Path( float time )\n{\n\treturn vec3(1.0+ 28.6*cos(0.2-0.5*.33*time*.75), 4.7, 5.7 - 27.0*sin(0.5*0.11*time*.75) );\n}\n\n\/\/--------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 q = fragCoord.xy \/ iResolution.xy;\n\tvec2 p = (-1.0 + 2.0*q)*vec2(iResolution.x \/ iResolution.y, 1.0);\n\t\n    \/\/ Camera...\n\tfloat off = iMouse.x*1.0*iMouse.x\/iResolution.x;\n\tfloat time = 113.5+iGlobalTime + off;\n\tvec3 ro = Path( time+0.0 );\n    ro.y += 21.0-cos(time*.25+.54)*19.0;\n\tvec3 ta = Path( time+37.0 );\n\tta.y *= 1.0+sin(3.0+0.12*time) * .5;\n\tfloat roll = 0.3*sin(0.07*time);\n\t\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(roll), cos(roll), 0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = cross(cu,cw);\n\t\n\tfloat r2 = p.x*p.x*0.32 + p.y*p.y;\n    p *= (7.0-sqrt(37.5-11.5*r2))\/(r2+1.0);\n\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.1*cw );\n\tvec3 col;\n\n    vec3 background = GetSky(rd);\n    col \t\t= mix(vec3(.65, .85, 1.0), GetClouds(vec3(.5), ro, rd),\tpow(abs(rd.y), .5));\n\n\tfloat sun = clamp( dot(rd, sunDir), 0.0, 1.0 );\n\tfloat which;\n\tvec4 ret = Raymarch(ro, rd, q, which);\n    \n    if(ret.w > 0.0)\n\t{\n\t\tvec3 pos = ro + ret.w * rd;\n\t\tvec3 nor = Normal(pos, which);\n\t\tvec3 ref = reflect(rd, nor);\n\t\t\n\t\tfloat sun = clamp( dot( nor, sunDir ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, -sunDir ), 0.0, 1.0 );\n\t    float sha = clamp((pos.y*.85)-4.0, 0.0, 1.0);\n        \n\t\tvec3 lin = sun*vec3(.6) * sha;\n\t\tlin += vec3(bac*1.1, bac*.1, bac*3.7);\n        lin += vec3(clamp(pos.y - 5.0, 0.2, 1.0)) * .4;\n\n\t\tcol = TexCube(ret.xyz, nor);\n        vec3 grassCol =  vec3(.1+sin(which*2.2392)*.1, .7+abs(sin(which*2.2392)*.3), .0);\n        grassCol= mix(grassCol, vec3(.3, .3, .0), min(FractalNoise(pos.xz)*.7, 1.0)); \n        \n        \n\t\tcol = lin * col * grassCol * .9;\n        col += vec3(.7, 1.0, .5)*pow(clamp( dot( ref, sunDir ), 0.0, 1.0 ), .25) * .15 * sha;\n\t\t\n\t\tcol = mix(background, col, exp(-0.00002*max(ret.w*ret.w-1240.0, 0.0)) );\n\t}\n\n    col += vec3(.4, .4, .2)*pow( sun, 15.0 )*2.0*clamp( (rd.y+0.4) \/ .2,0.0,1.0);\n\n\tcol = clamp(sqrt(col), 0.0, 1.0);\n    col *= 0.5 + 0.5*pow( 60.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.3 );\n\n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}