{"Shader":{"ver":"0.1","info":{"id":"ltXSWf","date":"1440104950","viewed":780,"name":"Morphick","username":"vizionary","description":"Inspiration from following iq's articles and shaders for years and most recently, after watching the Revision 2015 Live Coding event videos ... AMAZING coding guys !!           click-n-drag to slide time","likes":6,"published":3,"flags":0,"tags":["3d","distancefield","logo"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/#version 430 core\n\/*\n  Morphick Logo - created by vizionary - Aug 2015\n  License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n  Huge thank you and greetz to: iq ,mu6k, XT95, Kali, otaviogood, TekF, reinder, \n                                Dave_Hoskins, gargaj, frankenburgh, Kabuto !!!\n\n  This was inspired by reading iq's articles for years and most recently, by watching \n  the Revision 2015 Live Coding event videos ... AMAZING !!\n\n  This is the first public sample of my gfx tinkering in many, many years\n  ...quite shy, i am...hope you enjoy !\n  -viz\n*\/\n\nfloat time = iGlobalTime + 300.0 + iMouse.x * 0.3;\n\n\/\/#define ANIMATE_LAYER_DEPTH  \/\/ thought this would look cool, but aesthetically, ruins the distinct layering effect :\/\n\/\/#define MOAR_LAYERS          \/\/ medium detail\n\/\/#define EVEN_MOAR_LAYERS     \/\/ high detail (only more layers added for now)\n\/\/#define SOFT_SHADOW          \/\/ disabled at the moment, need to debug :\/\n\n\/\/ tweak if you want :)\nconst float camSpeed = 0.11;\nconst float camRad = 3.5;\nconst float sunRad = 20.0;\nconst float sunSpeed = 0.42;\nconst float piOver2 = 1.5708;\nconst vec3  columnSpacing = vec3( 0.5, 0.0, 0.0 );\nconst float latticeLineWidth = 0.12;\nconst float latticeLayerSpacing = 0.075;\nconst float latticeLayersAngle = 9.4248;\nconst float latticeLayersSpeed = 0.0125;\nconst float latticeMergeThreshold = 0.5;\nconst float latticeLayersMergeThreshold = 0.025;\n\n\/\/ smooth minimum distance ftw - thanks iq!\nfloat smin_poly( in float a, in float b, in float k)\n{\n  float h = clamp( 0.5+0.5*(b-a)\/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k * h * (1.0-h);\n}\n\nvec3 rotateX( in vec3 v, float rad )\n{\n  float cs = cos(rad);\n  float ss = sin(rad);\n  return vec3(v.x, cs * v.y + ss * v.z, -ss * v.y + cs * v.z);\n}\n\nvec3 rotateY( in vec3 v, float rad )\n{\n  float cs = cos(rad);\n  float ss = sin(rad);\n  return vec3(cs * v.x - ss * v.z, v.y, ss * v.x + cs * v.z);\n}\n\nfloat boxShape( in vec3 pos, float b)\n{\n  vec3 d = abs(pos) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 morphickLogoColumn( in vec3 pos, in float materialOffset)\n{\n   \/\/ inspired by otaviogood's Disc model in Gimbal Mechanics\n   \/\/ let's start with a unit box \n   \/\/ also using the vec2 return technique to return material id's from within distance calc  - thanks iq!\n  vec2  d  = vec2(boxShape( pos, 1.0), 503.0);\n  \n  vec3 trans = vec3(0.5, -1.7, 1.0);\n  float angle = 0.959931;\n  \n  \/\/ cut off the top\n  vec2  dm = vec2( -boxShape( rotateX( rotateY( pos+trans, 0.7853 ), angle ), 2.0 ), 501.0 );\n  if( dm.x > d.x ) d = dm;\n\n  \/\/ and the bottom\n  trans = vec3(-1.0, 1.5, -1.0);\n  dm =       vec2( -boxShape( rotateX( rotateY( pos+trans, 0.7853 ), angle ), 1.0), 501.0 );\n  if (dm.x > d.x ) d = dm;\n\n  \/\/ trim the back and front\n  trans = vec3(0.5, 0.0, 0.0);\n  dm =       vec2( -boxShape( pos+trans, 1.1 ), 501.0 );\n  if( dm.x > d.x ) d = dm;\n\n  trans = vec3(0.0, 0.0, 0.5);\n  dm =       vec2( -boxShape( pos+trans, 1.1 ), 501.0 + materialOffset );  \/\/ tweak material for front of left column in logo\n  if( dm.x > d.x ) d = dm;\n\n  return d;\n}\n\nvec2 morphickLogoShape( in vec3 pos )\n{\n  \/\/ composite the colums together - and specify a unique material id for the left most column\n  vec2 d  = morphickLogoColumn( pos, 0.0 );\n  vec2 d1 = morphickLogoColumn( pos+columnSpacing+vec3( 0.0, 0.25, 0.0 ), 0.0 );\n  if( d1.x<d.x ) d = d1;\n  d1 = morphickLogoColumn( pos+columnSpacing*2.0, 2.0 );\n  if( d1.x<d.x ) d = d1;\n  return d;\n}\n\nfloat latticeLineX( in vec3 pos )\n{\n  float d = abs( pos.x ) - latticeLineWidth; \n  return d; \n}\n\n\nvec2 morphickLatticeShape( in vec3 pos, in float angle )\n{\n  \/\/ ahh, this was the most fun part of all :)\n  \/\/ using translation and rotation on .xz plain, along with smin to blend each layer of lattice work\n  angle += 0.2; \/\/ reduce linear alignments in the patterns a bit\n  float dx = cos(time*0.03);  dx += sin(dx*angle*0.078);\n  float dy = sin(time*0.025); dy += cos(dy*angle*0.167);\n  float d =         latticeLineX( rotateY( pos+vec3(  2.0*dx, 0.0,  5.0*dy ),  angle ) );\n  d = smin_poly( d, latticeLineX( rotateY( pos+vec3(  20.0*dx, 0.0, -4.0*dy ), -angle * 1.0000 ) ), latticeMergeThreshold );\n\n  d = smin_poly( d, latticeLineX( rotateY( pos+vec3( -3.0*dx, 0.0,  4.0*dy ),  angle * 0.8400 ) ), latticeMergeThreshold );\n\n  d = smin_poly( d, latticeLineX( rotateY( pos+vec3( -4.0*dx, 0.0,  10.0*dy ), -angle * 0.3300 ) ), latticeMergeThreshold );\n  d = smin_poly( d, latticeLineX( rotateY( pos+vec3(  5.0*dx, 0.0,  3.0*dy ),  angle * 0.5000 ) ), latticeMergeThreshold );\n\n  d = -smin_poly( -d, -( abs(pos.y)-latticeLayersMergeThreshold*latticeMergeThreshold ), latticeLayersMergeThreshold );\n  return vec2(d, 10.0);\n}\n\nvec3 planeMaterial( in vec3 pos, in vec3 nor )\n{\n  \/\/ this was going to be something more complex\n  \/\/ but simple won :)\n  return vec3( 0.02 );\n}\n\nvec3 latticeMaterial( in vec3 pos, in vec3 nor )\n{ \n  \/\/ more of the same - black shiny works good for this\n  vec3 col = vec3(0.021, .020, .023) * 4.0;\n  return col;\n}\n\nvec3 morphickLogoMaterial( in vec3 pos, in vec3 nor, in float id )\n{\n  float ao = sin( pos.y );  \/\/super fakey ao :)\n  vec3 col = vec3( 0.3, 0.7, 0.9 );\n  if (id > 502.0)\n  {\n    col = vec3( 0.7, 0.2, 0.2 ); \n  }\n  return col * ao;\n}\n\nfloat plane( in vec3 pos, in float height)\n{\n  return pos.y + height;\n}\n\nvec2 df( in vec3 pos )\n{\n  \/\/ render the back plane\n  vec2 d = vec2(plane( rotateY( rotateX( -pos+vec3( 0.0, 0.0, 0.4 ), piOver2 ), piOver2 ), 0.4 ), 1.0);\n\n  \/\/ render the logo\n  vec2 d1 = morphickLogoShape( pos+vec3( 0.25, -1.1, 1.0 ) );\n  if (d1.x<d.x) d = d1;\n\n  float t = time*latticeLayersSpeed;\n  float t1 = t *  1.0;  \/\/ is any of this pre-calc saving cycles in the end??  :P\n  float sst1 = sin(t1) * latticeLayersAngle;\n  float t2 = t *  0.75;\n  float t3 = t *  0.50;\n  float t4 = t *  0.25;\n  float t5 = t *  0.125;\n\n  \/\/ render the lattice layers\n  \/\/ each layer is rendered with a different translation and angle offset \n  \/\/ which gives rise to nice oscillations in the lattice over time\n  \/\/ change latticeLayersSpeed to adjust the overall speed of the animation\n  pos = rotateX( pos, piOver2 );\n  float dz = 1.0;\n#ifdef ANIMATE_LAYER_DEPTH\n  dz = sin(time*0.06);  dz += cos(dz*0.232);    \n#endif\n  d1 = morphickLatticeShape( pos+vec3( -3.0, -latticeLayerSpacing*2.0*dz, -4.0), sst1 + latticeLayersAngle * sin(t2) );\n  if (d1.x<d.x) d = d1;\n\n  d1 = morphickLatticeShape( pos+vec3(  3.0, -latticeLayerSpacing*8.0*dz, -2.0), sst1 - latticeLayersAngle * cos(t3) );\n  if (d1.x<d.x) d = d1;\n\n  d1 = morphickLatticeShape( pos+vec3( -6.0, -latticeLayerSpacing*3.0*dz,  1.0), sst1 + latticeLayersAngle * sin(t4) );\n  if (d1.x<d.x) d = d1;\n\n  d1 = morphickLatticeShape( pos+vec3(  6.0, -latticeLayerSpacing*6.0*dz,  3.0), sst1 - latticeLayersAngle * cos(t5) );\n  if (d1.x<d.x) d = d1;\n\n  d1 = morphickLatticeShape( pos+vec3( -1.0, -latticeLayerSpacing*5.0*dz,  1.0), sst1 + latticeLayersAngle * sin(t5) );\n  if (d1.x<d.x) d = d1;\n\n#ifdef MOAR_LAYERS\n  d1 = morphickLatticeShape( pos+vec3(  9.0, -latticeLayerSpacing*4.0*dz, -4.0), sst1 - latticeLayersAngle * cos(t2) );\n  if (d1.x<d.x) d = d1;\n\n  d1 = morphickLatticeShape( pos+vec3(-15.0, -latticeLayerSpacing*9.9*dz,  4.0), sst1 + latticeLayersAngle * sin(t4) );\n  if (d1.x<d.x) d = d1;\n#endif     \n#ifdef EVEN_MOAR_LAYERS\n \/\/ if you have the horsepower, toss a few more layers in for good measure :)    \n  d1 = morphickLatticeShape( pos+vec3( 15.0, -latticeLayerSpacing*7.0, -4.0), sst1 + latticeLayersAngle * cos(t1) );\n  if (d1.x<d.x) d = d1;\n    \n  d1 = morphickLatticeShape( pos+vec3(  7.5, -latticeLayerSpacing*9.0,  7.5), sst1 - latticeLayersAngle * sin(t3) );\n  if (d1.x<d.x) d = d1;\n#endif\n  return d;\n}\n\nvec3 nf( in vec3 pos )\n{\n  vec2 e = vec2( 0.0, 0.001 );\n  return normalize(\n    vec3(\n      df( pos+e.yxx ).x - df( pos-e.yxx ).x,\n      df( pos+e.xyx ).x - df( pos-e.xyx ).x,\n      df( pos+e.xxy ).x - df( pos-e.xxy ).x\n    )\n  );\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n  \/\/ thanks iq - love your video tutorials - please make more :)\n  float t = 0.0;\n  for( float steps=0.0; steps<8.0; steps+=1.0\/8.0 )\n  {\n    vec2 d = df( ro + rd * t );\n    if ( d.x < 0.001 ) return vec3(t, d.y, steps);\n    t += d.x;\n  }\n  return vec3( 0.0, 0.0, 0.0 );\n}\n\n\/\/ thanks iq - (apple tut - yay!)\nfloat shadow( in vec3 ro, in vec3 rd )\n{\n  float res = 1.0;\n  float t = 0.002;\n    \n  \/\/ was going for soft shadow, but when set k down to say 16 or 32,\n  \/\/ then artifacts that look like shadow hits from the negative boxes\n  \/\/ used to carve up the logo\n  #ifdef SOFT_SHADOW\n  float k = 16.0;\n  for( float steps=0.0; steps<10.0; steps+=1.0\/10.0 )   \n  #else\n  float k = 64.0;      \n  for( float steps=0.0; steps<4.0; steps+=1.0\/4.0 )\n  #endif\n  {\n    float h = df( ro+t*rd ).x;\n    if( h<0.001) return 0.0;\n    res = min( res, k*h\/t);\n    t += h;\n  }\n  return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x \/ iResolution.x, fragCoord.y \/ iResolution.y);\n  uv -= 0.5;\n  uv \/= vec2(iResolution.y \/ iResolution.x, 1);\n\n  \/\/ following iq's model here in terms of the rt\/maths\n  \/\/ just using a simple auto orbiting cam tweaked to give some nice perspectives\n  vec3 ro = vec3(0.0, 0.0, -8.0 );\n  ro += vec3(sin(time*camSpeed)*camRad, 0.0+sin(time*camSpeed*0.5)*1.5, -cos(time*camSpeed)*camRad);\n  vec3 target = vec3(0.0, 1.5, 0.0);\n  vec3 ww = normalize( target - ro );\n  vec3 up = normalize( vec3( 0.0, 1.0, 0.0) );\n  vec3 uu = normalize( cross( up, ww ) );\n  vec3 vv = normalize( cross( ww, uu ) );\n  vec3 rd = normalize( uv.x*uu + uv.y*vv + 1.0*ww );  \n\n  \/\/ still not quite happy with the lighting...but this will do for now\n  vec3 sunPos = vec3(0.0, 0.0, -100) + vec3(-sunRad+sin(time*sunSpeed)*sunRad, sunRad+sin(time*sunSpeed*0.5)*sunRad*0.5, -sunRad+cos(time*sunSpeed)*sunRad);\n  vec3 sunlight  = -normalize( target - sunPos );\n\n  vec3 col = vec3( .0 );\n  vec3 t = intersect( ro, rd);\n\n  \/\/ only process materials if we have an intersection    \n  if (t.x > 0.0)\n  {\n    vec3 pos = ro + rd * t.x;\n    vec3 nor = nf( pos );\n\tvec3 ref = reflect( rd, nor );\n\n    \/\/ lighting coeffs\n    float dif = max( 0.0, dot( nor, sunlight ) );\n    float spe = pow( clamp( dot( sunlight, ref ), 0.0, 1.0 ), 2.0 );\n    float sha = clamp( shadow( pos, sunlight ), 0.0, 1.0 );\n    float rim = pow( clamp( 1.0+dot( nor, rd ), 0.0, 1.0 ), 2.0 );\n\n    float con = 0.5;\n    float amb = 0.5;\n\n    col  = con * vec3(0.1, 0.1, 0.1);\n    col += amb * vec3(0.1, 0.1, 0.1);\n\n    col = col*0.3 + 0.7*sqrt(col);\n    col *= 0.5;\n\n    col += dif * vec3( 1.00, 0.98, 0.86 ) * sha;\n\n    \/\/ using t.y for material \"id\"\n    if (t.y > 0.0 && t.y < 2.0) \n    {\n      col *= planeMaterial( pos, nor );\n    }\n\n    if (t.y > 9.0 && t.y < 11.0)\n    {\n      col *= latticeMaterial( pos, nor );\n    }\n\n    if (t.y > 500.0)\n    {\n      col *= morphickLogoMaterial( pos, nor, t.y );\n    }\n\n    col += 0.25*rim*amb;\n    col += 0.55*spe*amb*sha;\n    col = pow(col, vec3(1.35));\n}\n\n  fragColor = vec4(col, 1.0);\n}","name":"","description":"","type":"image"}]}}