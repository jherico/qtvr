{"Shader":{"ver":"0.1","info":{"id":"Xsl3D8","date":"1369492424","viewed":1703,"name":"Pacman","username":"tsone","description":"It's Pacman!","likes":10,"published":3,"flags":0,"tags":["pacman"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define PI 3.14159265359\n#define TWOPI (2.0 * PI)\n#define MOUTHCLOSE_FREQ 2.82\n#define R 8.0\n#define ORIG_Z\t2.0*R\n#define GRID_Z\tORIG_Z-2.0\n#define TIMESCALE 1.0\n\n#define SMOOTHERSTEP01(x_) dot(vec3(10.0,-15.0,6.0), pow(vec3(x_), vec3(3.0,4.0,5.0)))\n\nstruct Ray {\n\tvec3 p;\n\tvec3 d;\n};\n\nfloat time = TIMESCALE * iGlobalTime;\n\n\/\/\tx: pan amount\n\/\/\ty: perspective amount\n\/\/ \tz: mouth close amount\nvec3 prp = vec3(\n\tvec2(SMOOTHERSTEP01(0.5 - 0.5 * cos(0.51 * time - 0.125 * PI))),\n\t0.5 - 0.5 * sin(TWOPI * MOUTHCLOSE_FREQ * time)\n);\n\nbool coll_pacman(in vec3 q) {\n\tq.z *= 2.5; \/\/ bit thinner pacman\n\treturn (dot(q, q) < R * R)\n\t\t&& (prp.z <= (abs(q.y) + 1.05) \/ max(1.0, q.x + 5.0));\n}\n\nbool coll_pill(in vec3 q) {\n\tvec3 pill = q;\n\tpill.x = floor(2.0 * R * fract(pill.x * (0.5 \/ R) + time * MOUTHCLOSE_FREQ) - R + 2.0);\n\tpill += 0.5;\n\treturn (dot(pill, pill) <= 1.0) && (2.0 <= q.x);\n}\n\nbool coll_level(in vec3 q) {\n\treturn (abs(abs(q.y) - 1.50 * R) <= 0.8);\n}\n\nbool coll(in vec3 p) {\n\tvec3 q = floor(p + vec3(0.0,0.0,-ORIG_Z));\n\treturn coll_pacman(q) || coll_level(q) || coll_pill(q);\n}\n\nbool traverse_step(inout vec3 t, inout float fact, in vec3 div, in Ray ray) {\n\t\/\/ min of components gets the projection factor for the ray to reach cell border\n\tfact = min(t.x, min(t.y, t.z));\n\t\/\/ calculate next projection to intersection as min of xyz\n\tt += step(t.xyz, t.yxy) * step(t.xyz, t.zzx) * div;\n\t\/\/ check for collision and get color\n\treturn (coll(ray.p + fact * ray.d));\n}\n\n#define STEP() if (traverse_step(t, fact, div, ray)) return fact\n#define STEP2() STEP(); STEP()\n#define STEP4() STEP2(); STEP2()\n\nfloat traverse(in Ray ray) {\n\tvec3 t;\n\tfloat fact;\n\tvec3 div = vec3(1.0) \/ ray.d; \/\/ for projection\n\n\tif (coll(ray.p)) return 0.0;\n\n\t\/\/ calculate initial projection to intersection as difference from ray.p to\n\t\/\/ an intersection, which is based from floor(ray.p) and offseted with\n\t\/\/ ceil(ray.d) (which always yields xyz={0,1} when -1<=xyz<=1)\n\tt = ((floor(ray.p) + ceil(ray.d)) - ray.p) * div;\n\tray.p += 1e-4 * ray.d; \/\/ slight adjust to get inside cell\n\tdiv = abs(div); \/\/ following steps are unsigned\n\t\n\tSTEP4();\n\tSTEP4();\n\tSTEP4();\n\t\n\treturn R;\n}\n\nmat3 lookat_lh(in Ray cam, in vec3 up) {\n\tvec3 uz = normalize(cam.d - cam.p);\n\tvec3 ux = normalize(cross(up, uz));\n\tvec3 uy = cross(uz, ux);\n\treturn mat3(ux,uy,uz);\n}\n\nvec3 n_from_d(in vec3 d) {\n\tvec3 ad = abs(d);\n\t\/\/ get normal as max of xyz and apply sign\n\treturn (sign(d)\t\t\t\t\t\/\/ not normalized\n\t\t\t* step(ad.yxy, ad.xyz)\n\t\t\t* step(ad.zzx, ad.xyz)\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = 2.0 * (fragCoord.xy \/ iResolution.xy) - 1.0;\n\tuv.x *= iResolution.x \/ iResolution.y;\n\t\n\t\/\/ manual inspection\n\tif (iMouse.z > 0.5) {\n\t\tprp.xy = iMouse.xy \/ iResolution.xy;\n\t}\n\t\n\t\/\/ setup ray\/camera and rotate\n\tRay ray = Ray(\n\t\tR * mix(vec3(1.0,0.1,0.0), vec3(4.45,0.5,0.0), prp.x),\n\t\tR * mix(vec3(1.0,0.1,1.0), vec3(4.00,0.4,1.1), prp.x)\n\t);\n\tmat3 rot = lookat_lh(ray, vec3(0.0,1.0,0.0));\n\tray.d = normalize(vec3(uv * (1e-4 + 0.4 * prp.y),0.5));\n\tray.p += 2.0 * R * (1.0 - prp.y) * vec3(uv,0.0);\t\n\tray.d = rot * ray.d;\n\t\n\t\/\/ project ray to grid wall\n\tfloat t = (GRID_Z - ray.p.z) \/ ray.d.z;\n\tray.p += t * ray.d;\n\t\n\tt = traverse(ray);\n\t\n\t\/\/ calc shading\n\tray.p += (t + 1e-5) * ray.d;\t\t\/\/ move slighty inside cell\n\tvec3 n = n_from_d(fract(ray.p) - 0.5);\n\tfloat ldiff = 0.66 - 0.46 * min(dot(n, ray.d), 0.0);\n\tfloat lfade = max(0.0, 1.0 - (t \/ (0.93*R)));\n\t\n\t\/\/ determine color\n\tvec3 c = vec3(\n\t\tvec2(step(abs(ray.p.y), R)),\n\t\tfloat(coll_pill(floor(ray.p + vec3(0.0,0.0,-ORIG_Z))))\n\t);\n\tc.b += 1.0 - c.r;\n\n\tc *= lfade * ldiff;\t\t\t\t\t\/\/ shade\n\tc += 0.0121 + 0.0004 * abs(uv.x);\t\/\/ add greyish bg\n\tc *= (1.39 - 0.24 * dot(uv,uv));\t\/\/ darken\n\t\n    c = pow(c, vec3(1.0\/2.2)); \/\/ gamma\n\tfragColor = vec4(c,1.0);\n}\n","name":"","description":"","type":"image"}]}}