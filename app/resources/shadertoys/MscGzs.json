{"Shader":{"ver":"0.1","info":{"id":"MscGzs","date":"1451702798","viewed":212,"name":"2016\/01\/02","username":"hughsk","description":"\u2728","likes":10,"published":3,"flags":0,"tags":["sdf","warp","spin","environmentmap"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"vec2 doModel(vec3 p);\n\nvec2 calcRayIntersection(vec3 rayOrigin, vec3 rayDir, float maxd, float precis) {\n  float latest = precis * 2.0;\n  float dist   = +0.0;\n  float type   = -1.0;\n  vec2  res    = vec2(-1.0, -1.0);\n\n  for (int i = 0; i < 70; i++) {\n    if (latest < precis || dist > maxd) break;\n\n    vec2 result = doModel(rayOrigin + rayDir * dist);\n\n    latest = result.x;\n    type   = result.y;\n    dist  += latest;\n  }\n\n  if (dist < maxd) {\n    res = vec2(dist, type);\n  }\n\n  return res;\n}\n\nvec2 calcRayIntersection(vec3 rayOrigin, vec3 rayDir) {\n  return calcRayIntersection(rayOrigin, rayDir, 20.0, 0.001);\n}\n\nvec3 calcNormal(vec3 pos, float eps) {\n  const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n  const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n  const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n  const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n  return normalize( v1 * doModel( pos + v1*eps ).x +\n                    v2 * doModel( pos + v2*eps ).x +\n                    v3 * doModel( pos + v3*eps ).x +\n                    v4 * doModel( pos + v4*eps ).x );\n}\n\nvec3 calcNormal(vec3 pos) {\n  return calcNormal(pos, 0.002);\n}\n\nvec2 squareFrame(vec2 screenSize, vec2 coord) {\n  vec2 position = 2.0 * (coord.xy \/ screenSize.xy) - 1.0;\n  position.x *= screenSize.x \/ screenSize.y;\n  return position;\n}\n\nmat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nvec3 getRay(mat3 camMat, vec2 screenPos, float lensLength) {\n  return normalize(camMat * vec3(screenPos, lensLength));\n}\n\nvec3 getRay(vec3 origin, vec3 target, vec2 screenPos, float lensLength) {\n  mat3 camMat = calcLookAtMatrix(origin, target, 0.0);\n  return getRay(camMat, screenPos, lensLength);\n}\n\nvoid orbitCamera(\n  in float camAngle,\n  in float camHeight,\n  in float camDistance,\n  in vec2 screenResolution,\n  out vec3 rayOrigin,\n  out vec3 rayDirection,\n  in vec2 coord\n) {\n  vec2 screenPos = squareFrame(screenResolution, coord);\n  vec3 rayTarget = vec3(0.0);\n\n  rayOrigin = vec3(\n    camDistance * sin(camAngle),\n    camHeight,\n    camDistance * cos(camAngle)\n  );\n\n  rayDirection = getRay(rayOrigin, rayTarget, screenPos, 2.0);\n}\n\nfloat sdBox(vec3 position, vec3 dimensions) {\n  vec3 d = abs(position) - dimensions;\n\n  return min(max(d.x, max(d.y,d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat gaussianSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float shininess) {\n  vec3 H = normalize(lightDirection + viewDirection);\n  float theta = acos(dot(H, surfaceNormal));\n  float w = theta \/ shininess;\n  return exp(-w*w);\n}\n\nconst float PI = 3.14159265359;\n\nvec2 rotate2D(vec2 p, float a) {\n return p * mat2(cos(a), -sin(a), sin(a),  cos(a));\n}\n\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n  return a + b * cos(6.28318 * (c * t + d));\n}\n\nvec3 gradient(float t) {\n  return palette(t,\n    vec3(0.5),\n    vec3(0.5),\n    vec3(0.5, 0.25, 0.39),\n    vec3(0.35, 0.25, 0.15)\n  );\n}\n\nfloat modAngle(inout vec2 p, float a) {\n  float a1 = atan(p.y, p.x);\n  float a2 = mod(a1 + a * 0.5, a) - a * 0.5;\n\n  p = vec2(cos(a2), sin(a2)) * length(p);\n\n  return mod(floor(a1 \/ a + 0.5), 2.0 * PI \/ a);\n}\n\nfloat modRot(inout vec2 p, float i) {\n  return modAngle(p, 2.0 * PI \/ i);\n}\n \nvec2 doModel(vec3 p) {\n  float off2 = iGlobalTime * -0.5 + sin(iGlobalTime * 2.) * 0.4;\n  float off1 = 1.7 + sin(-iGlobalTime * 3.) * .25;\n  float bsize = 0.1 - pow(abs(p.y \/ off1), 20.05) * 0.15;\n  float d = length(p) - 1.;\n  \n  d += sin((p.x * p.y * p.z) * 10. - iGlobalTime * 5.) * 0.025;\n  d = min(d, length(abs(p) - vec3(0, off1, 0)) - 0.3);\n  \n  modRot(p.xz, 8.0);\n  p.yx = rotate2D(p.yx, off2);\n  modRot(p.yx, 6.0);\n  \n  p.xz = rotate2D(p.xz, iGlobalTime * 2. + sin(iGlobalTime * 2.) * 2.);\n  float d2 = sdBox(p - vec3(0, off1, 0), vec3(bsize)) - 0.02;\n    \n  d = min(d, d2);\n  \n  return vec2(d, 0.0);\n}\n\nvec3 bg(vec3 ro, vec3 rd) {\n  return gradient(rd.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec3 ro, rd;\n\n  vec2  uv       = squareFrame(iResolution.xy, fragCoord.xy);\n  float rotation = iGlobalTime * 0.85;\n  float height   = 0.1;\n  float dist     = 4.5;\n  \n  orbitCamera(rotation, height, dist, iResolution.xy, ro, rd, fragCoord.xy);\n\n  vec3 color = mix(bg(ro, rd) * 1.5, vec3(1), 0.125);\n  vec2 t = calcRayIntersection(ro, rd, 8., 0.005);\n  if (t.x > -0.5) {\n    vec3 pos = ro + rd * t.x;\n    vec3 nor = calcNormal(pos);\n    color = bg(pos, reflect(rd, nor));\n    color += gaussianSpecular(vec3(0, 1, 0), -rd, nor, 0.415) * 1.0;\n  }\n  \n  color = mix(color, vec3(1), 0.5);\n  color -= dot(uv, uv * 0.155) * vec3(0.5, 1, 0.7) * 0.9;\n  color.r = smoothstep(0.1, 0.9, color.r);\n  color.g = smoothstep(0.0, 1.1, color.g);\n  color.b = smoothstep(0.05, 1.0, color.b);\n\n  fragColor.rgb = color;\n  fragColor.a   = 1.0;\n}","name":"","description":"","type":"image"}]}}