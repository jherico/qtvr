{"Shader":{"ver":"0.1","info":{"id":"Xs3Gzf","date":"1451236084","viewed":315,"name":"endless spheres","username":"trapcode","description":"flying through endless spheres","likes":6,"published":3,"flags":1,"tags":["spheres","raytrace"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ eternal spheres\n\/\/ by Peder Norrby \/ Trapcode in 2015\n\/\/ camera code by iq\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nvec3 mhash3( float n )\n{\n\treturn -1.0+2.0*fract(sin(n+vec3(0.0,15.2,27.3))*158.3453123);\n}\n\n\nfloat mhash( float n )\n{\n\treturn -1.0+2.0*fract(sin(n)*158.3453123);\n}\n\n\n\nvec3 getColor(vec3 p)\n{\n\t\/\/float3 col = mhash3(V.x+50*V.y+2500*V.z+12121);\n\tfloat jitter = mhash(p.x+50.0*p.y+2500.0*p.z+12121.0);\n\n\tfloat f = p.y + 4.0*jitter;\n\n\tvec3 col;\n\t\t\n\tif (f > 4.0) col = vec3(0.2, 0.7, 1.0);\n\telse if (f > 0.0) col = vec3(0.2, 0.9, 1.0);\n\telse if (f > -4.0) col = vec3(1.0, 0.2, 1.0); \n\telse col = vec3(0.6, 0.0, 1.0);\n\n\treturn col;\n}\n\n\nvec4 trace_spheres( in vec3 rayo, in vec3 rayd )\n{\n \tvec3 p = rayo;\/\/ + rayd;\n\tconst vec3 voxelSize = vec3(1.0,1.0,1.0);\n\n\t\/\/ find current voxel\n\n\tvec3 V = floor(p);\n\tvec3 V0 = V;\n\tvec3 step = sign(rayd); \/\/ step length for each dimension +1 or -1 (what about zero?? - zero is fine)\n\n\tvec3 lp = p - V; \/\/ local coords inside voxel\n\n\tvec3 tmax;\/\/ = abs((voxelSize - lp) \/ rayd);\n\n\tif (step.x > 0.0) tmax.x = voxelSize.x - lp.x; else tmax.x = lp.x;\n\tif (step.y > 0.0) tmax.y = voxelSize.y - lp.y; else tmax.y = lp.y;\n\tif (step.z > 0.0) tmax.z = voxelSize.z - lp.z; else tmax.z = lp.z;\n\n\ttmax \/= abs(rayd);\n\n\tvec3 tdelta = abs(voxelSize \/ rayd);\n    \n    \/\/ voxel traversal algorithm by Andrew Woo (http:\/\/www.cse.chalmers.se\/edu\/year\/2010\/course\/TDA361\/grid.pdf)\n\n\tfor(int i=0; i<60; i++) {\n\t\tif (tmax.x < tmax.y) {\n\t\t\tif (tmax.x < tmax.z) {\n\t\t\t\tV.x += step.x;\n\t\t\t\ttmax.x += tdelta.x;\n\t\t\t} else {\n\t\t\t\tV.z += step.z;\n\t\t\t\ttmax.z += tdelta.z;\n\t\t\t}\n\t\t} else {\n\t\t\tif (tmax.y < tmax.z) {\n\t\t\t\tV.y += step.y;\n\t\t\t\ttmax.y += tdelta.y;\n\t\t\t} else {\n\t\t\t\tV.z += step.z;\n\t\t\t\ttmax.z += tdelta.z;\n\t\t\t}\n\t\t}\n\n\t\t\/\/if (dot(V-V0,V-V0) < 8.0) continue; \/\/ cull sphere around viewer\n\t\tif (V.x > -1.0 && V.x < 1.0 && V.y > -1.0 && V.y < 1.0) continue; \/\/ cull a pillar (box-shaped) along the z-axis\n\n\t\t\/\/ now we have the voxel, check for intersections with sphere\n\t\tvec3 c = V + voxelSize*0.5 + 0.4*mhash3(V.x+50.0*V.y+2500.0*V.z); \/\/ sphere at center of voxel + rnd displacement\n\n\t\tfloat r = voxelSize.x*0.10; \/\/ sphere is 20% of voxel size\n\t\tfloat r2 = r*r;\n\n\t\tvec3 p_minus_c = p - c;\n\t\tfloat p_minus_c2 = dot(p_minus_c, p_minus_c);\n\t\tfloat d = dot(rayd, p_minus_c);\n\t\tfloat d2 = d*d;\n\t\tfloat root = d2 - p_minus_c2 + r2;\n\t\tfloat dist;\n\n\t\tconst float divFogRange = 1.0\/30.0; \/\/ 50-20\n\t\tconst vec3 fogCol = vec3(0.3, 0.3, 0.6);\n\t\tconst vec3 sunDir = vec3(-0.707106, 0.707106, 0.0);\n\n\t\tif (root >= 0.0) {\n\t\t\tdist = -d - sqrt(root);\n\t\t\tfloat z = max(0.0, 2.5*(dist-20.0)*divFogRange);\n\t\t\tfloat fog = clamp(exp(-z*z), 0.0, 1.0);\n\n\t\t\t\/\/float3 col = mhash3(V.x+50*V.y+2500*V.z+12121);\n\t\t\tvec3 col = getColor(V);\n\n\t\t\t\/\/float3 col = float3(dist\/50.0, -dist, dist*dist\/(50*50));\n\n\t\t\tvec3 normal = normalize(p + rayd*dist - c);\n\t\t\tfloat light = 0.7 + 1.0 * clamp(dot(normal, sunDir), 0.0, 1.0);\n\n\t\t\tcol = clamp(light*col, 0.0, 1.0);\n\n\t\t\tcol = mix(fogCol, col, fog);\n\n\t\n            return vec4( col, 1.0);\n\t\t}\n\n\t\tif ( dot(V-V0,V-V0) > 2500.0) break; \/\/ outside voxel grid\n\t}\n\n\treturn vec4(0.3, 0.3, 0.6, 1.0);\n} \n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) \/\/ by iq\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)\/ iResolution.y;\n\n    vec2 m = vec2(0.0, -0.5);\/\/ iMouse.xy\/iResolution.xy;\n    \n    \/\/ camera\n    vec3 ro = 4.0*normalize(vec3(sin(3.0*m.x), 0.4*m.y, cos(3.0*m.x)));\n\tvec3 ta = vec3(-3.0*cos(iGlobalTime*0.1), -1.0, 0.0);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \/\/ ray\n    vec3 rd = ca * normalize( vec3(p.xy,2.0));\n    \n    ro.z -= iGlobalTime;\n    \n    fragColor = trace_spheres( ro + vec3(0.5, 1.5, 0.0), rd );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    fragColor = trace_spheres( fragRayOri, fragRayDir );\n}","name":"","description":"","type":"image"}]}}