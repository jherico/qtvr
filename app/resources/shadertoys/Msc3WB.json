{"Shader":{"ver":"0.1","info":{"id":"Msc3WB","date":"1452154694","viewed":128,"name":"Raymarched Yin Yang","username":"KnightPista","description":"Simple raymarched yin yang","likes":4,"published":3,"flags":0,"tags":["3d","raymarching","yang","yin","yinyang"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"const float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI \/ 180.0;\n\nfloat sdCylinderZ( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorusZ( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xy)-t.x,p.z) )-t.y;\n}\n\nvec4 uni(vec4 a, vec4 b)\n{\n  return a.x < b.x ? a : b;\n}\n\nvec4 yin_yang(vec3 p)\n{\n    const float discRadius = 1.0;\n\tconst float discOutline = 0.02;\n\tconst float discHeight = 0.1;\n    \n    vec4 d = vec4(sdCylinderZ(p, vec2(discRadius + discOutline, discHeight)), vec3(0.4));\n    \n    d = uni(d, vec4(sdTorusZ(p, vec2(discRadius + discOutline, discHeight)), vec3(1.0)));\n    \n    d = uni(d, vec4(sdCylinderZ(p, vec2(discRadius, discHeight)), vec3(step(p.x, 0.0))));\n    \n    d = uni(d, vec4(sdCylinderZ(p + vec3(0.0, discRadius*0.5, 0.0), vec2(discRadius*0.5, discHeight)), vec3(1.0)));\n    d = uni(d, vec4(sdCylinderZ(p + vec3(0.0, -discRadius*0.5, 0.0), vec2(discRadius*0.5, discHeight)), vec3(0.0)));\n    \n    d = uni(d, vec4(sdCylinderZ(p + vec3(0.0, discRadius*0.5, 0.0), vec2(discRadius*0.125, discHeight)), vec3(0.0)));\n    d = uni(d, vec4(sdCylinderZ(p + vec3(0.0, -discRadius*0.5, 0.0), vec2(discRadius*0.125, discHeight)), vec3(1.0)));\n    \n    return d;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    yin_yang(pos+eps.xyy).x - yin_yang(pos-eps.xyy).x,\n\t    yin_yang(pos+eps.yxy).x - yin_yang(pos-eps.yxy).x,\n\t    yin_yang(pos+eps.yyx).x - yin_yang(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec3 rayDir( float fov, vec2 size, vec2 pos )\n{\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, z ) );\n}\n\nvec4 trace(vec3 origin, vec3 ray, vec2 bounds)\n{\n    float t = 0.0;\n    vec3 color = vec3(0.0);\n    \n    for (int i = 0; i < 64; ++i)\n    {\n        vec3 p = origin + ray * t;\n        vec4 ret = yin_yang(p);\n        \n        float distance = ret.x;\n        color = ret.yzw;\n        \n        t += distance;\n        \n        if(t < bounds.x || t > bounds.y)\n            break;\n    }\n    \n    return vec4(t, color);\t\t\t\t\t\t\t\n}\n\nmat3 setCamera( in vec3 eye, in vec3 target, float rotation )\n{\n\tvec3 cw = normalize(target-eye);\n\tvec3 cp = vec3(sin(rotation), cos(rotation),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 shade(vec3 eye, vec3 dir, float t, vec3 col)\n{\n    vec3 lightDir = normalize(vec3(0.0, -0.5, 1.0));\n    \n    vec3 pos = eye + dir*t;\n    vec3 nrm = calcNormal(pos);\n    vec3 ref = reflect( dir, nrm );\n    \n    float diff = clamp(dot(nrm, lightDir), 0.0, 1.0);\n    float spec = pow(clamp( dot( ref, lightDir ), 0.0, 1.0 ), 32.0);\n    float fre = pow( clamp(1.0+dot(nrm,dir),0.0,1.0), 2.0 );\n    \n    vec3 ret = vec3(0.3);\n   \tret += 1.4 * vec3(0.9) * diff;\n    ret += 1.2 * vec3(0.8) * spec;\n    ret += 0.4 * vec3(1.0) * fre;\n    ret = ret * col;\n\n    vec3 back = mix(vec3(0.4), 1.5 * vec3(0.7, 0.8, 0.9), clamp((dir.y*1.5+1.0)\/2.0, 0.0, 1.0));\n    \n    ret = mix( ret, back, 1.0-exp( -0.002*t*t ) );\n        \n    return clamp(ret, 0.0, 1.0);\n}\n\nvec3 render(vec3 eye, vec3 dir)\n{\n\tvec4 rayMarch = trace(eye, dir, vec2(0.01, 100.0));\n    \n    return shade(eye, dir, rayMarch.x, rayMarch.yzw);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float mouseSpeed = 5.0;\n    vec2 mouseRel = iMouse.xy\/iResolution.xy;\n    \n    float time = 2.5 + iGlobalTime * 0.5;\n    float camDist = 3.0 - (1.0 * mouseRel.y);\n    \n\tvec3 camPos = vec3( sin(-time + mouseSpeed*mouseRel.x) * camDist, -sin(-time+5.0) * 1.4, cos(-time + mouseSpeed*mouseRel.x) * camDist );\n    mat3 cam = setCamera( camPos, vec3(0.0), 0.0 );\n    \n    vec3 rd = cam * rayDir( 45.0, iResolution.xy, fragCoord.xy );\n \n    vec3 col = render(camPos, rd);\n    \n    col = pow( col, vec3(1.0\/2.2) );\n    \n    fragColor = vec4(col, 1.0);\n}","name":"","description":"","type":"image"}]}}