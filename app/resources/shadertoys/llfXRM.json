{"Shader":{"ver":"0.1","info":{"id":"llfXRM","date":"1450445008","viewed":165,"name":"Only Red study","username":"ManuManu","description":"Try to have the sincity effect.<br\/>To really expose the problem, I apply it on a created image with all the possible colors.<br\/>And check that red and only red is kept.<br\/><br\/>But the same algo on webcam doesn't work anymore, because of how we interpret colors.","likes":0,"published":3,"flags":2,"tags":["red","webcam","sincity"],"hasliked":0},"renderpass":[{"inputs":[{"id":31,"src":"\/presets\/webcam.png","ctype":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Actually, it doesn't really works because of psycho optic effect :\n\/\/ On the palette it works ok : \n\/\/  for only red moment, you only see red \n\/\/  for only non red moment, you don't really see red.\n\n\/\/ But on the webcam it does not work anymore...\n\/\/ because, based on the global image contexte, with lighting, and nearby pixels, \n\/\/ We interpret some colors are red though they are not really red, and vice versa.\n\n\/\/ it's the same as this illusion :\n\/\/ http:\/\/grandstoursdemagie.blogspot.fr\/2009\/07\/illusion-doptique-une-jolie-spirale.html\n\/\/\n\/\/ where the green and the blue are really the same color...\n\n\/\/ conclusion :\n\/\/\n\/\/     :(\n\/\/\n\n\n\/\/ Source : \n\/\/ Define NO_WEBCAM to have the palette\n\/\/ Define ONLYWEBCAM to have the webcam\n\/\/ no define cycle between palette and webcam\n\n\/\/ Output : \n\/\/ Define ONLY_RED to have the sincity effect ( so only red regions )\n\/\/ Define ONLY_NON_RED to have the sincity effect ( so red regions are greyed)\n\/\/ No define will cycle between source image, red regions greyed, sin city effect...\n\n\/\/ Orign :\n\/\/#define NO_WEBCAM\n\/\/#define ONLYWEBCAM\n\n\/\/ Output :\n\/\/#define ONLY_RED\n\/\/#define ONLY_NON_RED\n\/\/#define ONLY_SOURCE\n\n\n\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 \/ 3.0, 2.0 \/ 3.0, -1.0);\n    vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n    vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) \/ (6.0 * d + e)), d \/ (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat isRedColorRGB( vec3 color )\n{\n    vec3 wantedColor=  vec3( 1.0, .0, .0 );\n    float distToColor = distance( color.rgb, wantedColor ) ;\n    return distToColor;\n}\nfloat isRedColorHSV( vec3 color )\n{\n    vec3 wantedColor=  vec3( 1.0, .0, .0 );\n    vec3 HSVColor = rgb2hsv( color );\n    float WantedHue = .0;\n    float dist = .3;\n    float val =  smoothstep( .0, dist,mod( HSVColor.r - WantedHue,1. ));\n    return val;\n}\n\nfloat isRedColor( vec3 color )\n{\n    return isRedColorRGB(color);\n    \/\/return isRedColorHSV(color);\n}\n\n\n\n\/\/ create a image with the full palette\nvec3 getColorImage(vec2 uv)\n{\n    const float NB_DIV = 8.;\n    const float NB_DIV2 = NB_DIV*NB_DIV;\n    vec2 uv8 = uv*NB_DIV;\n    float posX = floor( uv8.x);\n    float posY = floor( uv8.y);\n    \n    float r = ( posX + posY * NB_DIV ) \/ NB_DIV2;\n    float g = uv8.x - posX;\n    float b = uv8.y - posY;\n    return vec3( r, g, b);\n}\n\nconst float threshold = .6;\nvec3 onlyRedImage( vec3 color, float grey, float isRed )\n{\n    vec3 resColor = vec3(grey);\n    if ( isRed  < threshold )\n        resColor = color;\n    return resColor;\n}\nvec3 onlyNonRedImage( vec3 color, float grey, float isRed )\n{\n    vec3 resColor = vec3(grey);\n    if ( isRed  > threshold )\n        resColor = color;\n    return resColor;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    float CycleSource = fract( iGlobalTime \/ 6. );  \/\/ 6 seconds cycle\n    vec3 origColor = getColorImage(uv);\n    if ( CycleSource > .5 )\t\t\t\t\t\t\t\/\/ change every 3 seconds\n        origColor = vec3( texture2D(iChannel0, uv));\n    \n#ifdef NO_WEBCAM\n    origColor = getColorImage(uv);\n#endif \/\/ NO_WEBCAM\n#ifdef ONLYWEBCAM\n    origColor = vec3( texture2D(iChannel0, uv));\n#endif \n    float grey = dot(vec3(origColor), vec3(0.299, 0.587, 0.114) );\n    \n    float isRed = isRedColor( origColor );\n    \n    vec3 color = origColor;\n    \n    float cycleTime = fract( iGlobalTime \/ 3. );  \/\/ 3 seconds cycle \n    if ( cycleTime > .66 )\t\t\t\t\t\t\t\/\/ change - 3 positions- every second\n        color = onlyRedImage( origColor, grey, isRed );\n    else if ( cycleTime > .33 )\n        color = onlyNonRedImage( origColor, grey, isRed );\n        \n#ifdef ONLY_SOURCE\n    color = origColor;\n#endif \/\/ ONLY_SOURCE\n        \n#ifdef ONLY_RED\n\tcolor = onlyRedImage( origColor, grey, isRed );\n#endif \/\/ ONLY_RED\n    \n#ifdef ONLY_NON_RED\n    color = onlyNonRedImage( origColor, grey, isRed );\n#endif \/\/ONLY_NON_RED\n        \n    \n\tfragColor = vec4(color, .1);\n}\n\n#if 0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec3 origColor = vec3( texture2D(iChannel0, uv));\n    fragColor = vec4(origColor, .1);\n}\n#endif\n","name":"","description":"","type":"image"}]}}