{"Shader":{"ver":"0.1","info":{"id":"lt2Gzt","date":"1431533117","viewed":314,"name":"Stairway to the Stars","username":"dr2","description":"A long climb; use the mouse to look around.","likes":10,"published":3,"flags":0,"tags":["raymarching","replication"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ \"Stairway to the Stars\" by dr2 - 2015\n\/\/ License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float s = 0.;\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return s;\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\n#define REFBALL\n\nint idObj;\nfloat tCur, stPitch, rotAng, rOut, rIn, rWid;\nvec3 qHit, ltPos[2];\nint doLt;\nconst float dstFar = 20.;\n\nvec3 BrickCol (vec2 p)\n{\n  vec2 i = floor (p);\n  if (2. * floor (i.y \/ 2.) != i.y) {\n    p.x += 0.5;\n    i = floor (p);\n  }\n  p = smoothstep (0.02, 0.08, abs (fract (p + 0.5) - 0.5));\n  return (0.5 + 0.5 * p.x * p.y) * vec3 (0.5, 0.4, 0.3);\n}\n\nvec3 WoodCol (vec2 p)\n{\n  float f = Fbm2 (p * vec2 (1., 0.1));\n  return mix (vec3 (0.8, 0.4, 0.2), vec3 (0.45, 0.25, 0.1), f);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, pp;\n  float d, dr, da, dy, dMin, r, ns, nh, sh, sw, rw, ca, sa;\n  const int ins = 12;\n  const int inh = 6;\n  dMin = dstFar;\n  ns = float (ins);\n  nh = float (inh);\n  sh = 0.2 * stPitch \/ ns;\n  sw = 1.1 * pi * rOut \/ ns;\n  rw = 0.09;\n  pp = p;\n  pp.xz = Rot2D (pp.xz, rotAng);\n  pp.y += stPitch * rotAng \/ (2. * pi);\n  r = length (pp.xz);\n  dr = max (r - rOut, rIn - r);\n  q = pp;\n  d = dMin;\n  dy = stPitch \/ ns;\n  q.y -= dy;\n  da = 2. * pi \/ ns;\n  ca = cos (da);  sa = sin (da);\n  for (int j = 0; j < ins; j ++) {\n    q.y = mod (q.y + dy + 0.5 * stPitch, stPitch) - 0.5 * stPitch;\n    d = min (d, max (max (max (dr, abs (q.z) - sw), q.x), abs (q.y) - sh));\n    if (d < dMin) { dMin = d;  idObj = 1;  qHit = q; }\n    q.xz = q.xz * ca + q.zx * vec2 (- sa, sa);\n  }\n  d = min (min (d, max (r - rIn, - (r - rIn + rWid))),\n     max (r - rOut - rWid, - (r - rOut)));\n  q = pp;\n  dy = stPitch \/ nh;\n  q.y -= 0.25 * stPitch + dy;\n  da = 2. * pi \/ nh;\n  ca = cos (da);  sa = sin (da);\n  for (int j = 0; j < inh; j ++) {\n    q.y = mod (q.y + dy + 0.5 * stPitch, stPitch) - 0.5 * stPitch;\n    d = max (d, - length (q.xy) + rw);\n    q.xz = q.xz * ca + q.zx * vec2 (- sa, sa);\n  }\n  if (d < dMin) { dMin = d;  idObj = 2;  qHit = q; }\n  if (doLt != 0) {\n    d = PrSphDf (p - ltPos[0], 0.07 * rIn);\n    if (d < dMin) { dMin = d;  idObj = 5; }\n   }\n  if (doLt != 1) {\n    d = PrSphDf (p - ltPos[1], 0.07 * rIn);\n    if (d < dMin) { dMin = d;  idObj = 6; }\n  }\n#ifdef REFBALL\n  d = min (d, max (r - 0.006 * rIn, 0.));\n  if (d < dMin) { dMin = d;  idObj = 3; }\n  pp = p;\n  pp.y = mod (pp.y + stPitch * rotAng \/ (2. * pi) + 0.5 * stPitch, stPitch) -\n     0.5 * stPitch;\n  d = PrSphDf (pp, 0.3 * rIn);\n  if (d < dMin) { dMin = d;  idObj = 4; }\n#endif\n  return dMin;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjCol (vec3 ro, vec3 rd, vec3 vn)\n{\n  vec3 ltDir, acDif, col; \n  float ltDist, ltDistSq, dif, atten, acSpe, sh, d, h;\n  col = vec3 (0.);\n  if (idObj == 1) {\n    col = WoodCol (120. * qHit.zx);\n  } else if (idObj == 2) {\n    if (abs (vn.y) > 0.005) col = 0.4 * vec3 (0.5, 0.4, 0.3);\n    else col = BrickCol (vec2 (20. * (atan (qHit.z, qHit.x) \/ pi + 1.),\n       40. * qHit.y));\n  } else if (idObj == 3) {\n    col = vec3 (0.4, 0.4, 0.2);\n  } else if (idObj == 5) {\n    col = vec3 (1., 1., 0.5) * (0.75 + 0.25 * dot (rd, normalize (ltPos[0] - ro)));\n  } else if (idObj == 6) {\n    col = vec3 (1., 1., 0.5) * (0.75 + 0.25 * dot (rd, normalize (ltPos[1] - ro)));\n  }\n  if (idObj < 5) {\n    acDif = vec3 (0.);\n    acSpe = 0.;\n    for (int j = 0; j < 2; j ++) {\n      doLt = j;\n      ltDir = ltPos[j] - ro;\n      ltDistSq = dot (ltDir, ltDir);\n      ltDist = sqrt (ltDistSq);\n      ltDir \/= ltDist;\n      dif = clamp (dot (vn, ltDir), 0., 1.);\n      sh = 0.;\n      if (dif > 0.) {\n\tsh = 1.;\n\td = 0.01;\n\tfor (int i = 0; i < 60; i ++) {\n\t  h = ObjDf (ro + ltDir * d);\n\t  sh = min (sh, 50. * h \/ d);\n\t  d += h;\n\t  if (d > ltDist) break;\n\t}\n\tdif *= sh;\n      }\n      atten = 1. \/ (0.1 + ltDistSq);\n      acDif += atten * dif;\n      acSpe += atten * sh * pow (clamp (dot (reflect (rd, vn), ltDir), 0., 1.), 16.);\n    }\n    col = (0.4 + 0.2 * acDif) * col + 0.03 * acSpe * vec3 (1.);\n  }\n  return col;\n}\n\nfloat GlowCol (vec3 ro, vec3 rd, float dstHit)\n{\n  vec3 ltDir;\n  float ltDist, wGlow;\n  wGlow = 0.;\n  for (int j = 0; j < 2; j ++) {\n    ltDir = ltPos[j] - ro;\n    ltDist = length (ltDir);\n    ltDir \/= ltDist;\n    if (ltDist < dstHit) wGlow += pow (max (dot (rd, ltDir), 0.), 1024.) \/ ltDist;\n  }\n  return clamp (0.5 * wGlow, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, roo, rds;\n  float dstHit, rLt, aLt;\n  int idObjT;\n  rotAng = 0.3 * tCur;\n  stPitch = 0.4;\n  rWid = 0.006;\n  rLt = 0.6 * rOut;\n  aLt = 0.1 * pi;\n  ltPos[0] = vec3 (rLt * cos (aLt), stPitch * (0.1 - 0.14 * cos (tCur)),\n     rLt * sin (aLt));\n  aLt = - 0.95 * pi;\n  ltPos[1] = vec3 (rLt * cos (aLt), stPitch * (-0.4 + 0.14 * sin (tCur)),\n     rLt * sin (aLt));\n  roo = ro;\n  idObj = -1;\n  doLt = -1;\n  dstHit = ObjRay (ro, rd);\n  if (idObj < 0) dstHit = dstFar;\n#ifdef REFBALL\n  if (idObj == 4 && dstHit < dstFar) {\n    ro += rd * dstHit;\n    rd = reflect (rd, ObjNf (ro));\n    ro += 0.01 * rd;\n    roo = ro;\n    idObj = -1;\n    dstHit = ObjRay (ro, rd);\n  }\n#endif\n  if (dstHit >= dstFar) {\n    col = vec3 (0., 0., 0.1);\n    rds = rd;\n    rds.xz = Rot2D (rds.xz, rotAng);\n    rds = (rds + vec3 (1.));\n    for (int j = 0; j < 10; j ++)\n       rds = 11. * abs (rds) \/ dot (rds, rds) - 3.;\n    col += min (1., 1.5e-6 * pow (min (16., length (rds)), 5.)) *\n       vec3 (0.7, 0.6, 0.6);\n  } else {\n    ro += rd * dstHit;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    col = ObjCol (ro, rd, vn);\n  }\n  col = mix (col, vec3 (1., 1., 0.5), GlowCol (roo, rd, dstHit));\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 canvas = iResolution.xy;\n  vec2 uv = 2. * fragCoord.xy \/ canvas - 1.;\n  uv.x *= canvas.x \/ canvas.y;\n  tCur = iGlobalTime;\n  vec4 mPtr = iMouse;\n  mPtr.xy = mPtr.xy \/ canvas - 0.5;\n  mat3 vuMat;\n  vec3 ro, rd;\n  vec2 vEl, vAz;\n  float az, el;\n  rOut = 0.5;\n  rIn = 0.2;\n  ro = - vec3 (0., 0.1, 0.9) * rOut;\n  az = 0.2;\n  el = 0.1;\n  if (mPtr.z > 0.) {\n    ro.z = clamp (ro.z + 0.8 * mPtr.x, - 0.99 * rOut, - 0.4 * rIn);\n    el = clamp (el + 3. * mPtr.y, -1.5, 1.5);\n  }\n  vEl = vec2 (cos (el), sin (el));\n  vAz = vec2 (cos (az), sin (az));\n  vuMat = mat3 (1., 0., 0., 0., vEl.x, - vEl.y, 0., vEl.y, vEl.x) *\n     mat3 (vAz.x, 0., vAz.y, 0., 1., 0., - vAz.y, 0., vAz.x);\n  rd = normalize (vec3 (uv, 1.5)) * vuMat;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n","name":"","description":"","type":"image"}]}}