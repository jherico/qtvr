{"Shader":{"ver":"0.1","info":{"id":"MlfSWX","date":"1440081148","viewed":332,"name":"Mandelbox tunnel","username":"dr2","description":"Tunneling through a Mandelbox","likes":7,"published":3,"flags":0,"tags":["raymarching","fractal","mandelbox"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ \"Mandelbox tunnel\" by dr2 - 2015\n\/\/ License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z \/ h, -1., 1.))) - r;\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p = abs (fract (c.xxx + vec3 (1., 2.\/3., 1.\/3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nfloat tCur, qStep;\nvec3 vuPos;\nconst float mScale = 2.8;\nconst float dstFar = 30.;\n\nfloat MBoxDf (vec3 p)\n{\n  vec4 q, q0;\n  const int nIter = 30;\n  q0 = vec4 (p, 1.);\n  q = q0;\n  for (int n = 0; n < nIter; n ++) {\n    q.xyz = clamp (q.xyz, -1., 1.) * 2. - q.xyz;\n    q *= mScale \/ clamp (dot (q.xyz, q.xyz), 0.5, 1.);\n    q += q0;\n  }\n  return length (q.xyz) \/ abs (q.w);\n}\n\nfloat ObjDf (vec3 p)\n{\n  return max (MBoxDf (p), - PrCapsDf (p - vuPos, 0.2, 0.5));\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  const int nStep = 50;\n  float d, h, s;\n  d = 0.;\n  s = 0.;\n  for (int j = 0; j < nStep; j ++) {\n    h = ObjDf (ro + d * rd);\n    d += h;\n    ++ s;\n    if (h < 0.0003 || d > dstFar) break;\n  }\n  qStep = s \/ float (nStep);\n  return d;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 ltDir, col, vn;\n  float dstHit;\n  dstHit = ObjRay (ro, rd);\n  ltDir = normalize (vec3 (0.2, 1., -0.2));\n  col = vec3 (clamp (0.5 + 1.5 * rd.y, 0., 1.));\n  if (dstHit < dstFar) {\n    ro += dstHit * rd;\n    vn = ObjNf (ro);\n    col = HsvToRgb (vec3 (min (length (ro) \/ 5., 1.), 1.,\n       max (0., 1. - 0.5 * qStep * qStep)));\n    col = col * (0.3 +\n       0.7 * max (dot (vn, ltDir), 0.)) +\n       0.3 * pow (max (0., dot (ltDir, reflect (rd, vn))), 16.);\n    col = clamp (col, 0., 1.);\n  }\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = 2. * fragCoord.xy \/ iResolution.xy - 1.;\n  uv.x *= iResolution.x \/ iResolution.y;\n  tCur = iGlobalTime;\n  vuPos = vec3 (0., 0., -5.5 + mod (0.05 * tCur + 1., 9.5));\n  fragColor = vec4 (ShowScene (vuPos, normalize (vec3 (uv, 1.))), 1.);\n}\n","name":"","description":"","type":"image"}]}}