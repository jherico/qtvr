{"Shader":{"ver":"0.1","info":{"id":"MsfGRr","date":"1360474315","viewed":2287,"name":"Quaternion Julia","username":"iq","description":"The normal is computed analytically from the gradient of the Green function instead of estimating it numerically. The ambient occlusion is faked from the orbit traps algorithm. I made this one in 2007: https:\/\/www.youtube.com\/watch?v=9AX8gNyrSWc","likes":35,"published":3,"flags":0,"tags":["procedural","3d","raymarching","julia","distancefield","quaterion","kindernoiser"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ A port of my 2007 demo Kindernoiser: https:\/\/www.youtube.com\/watch?v=9AX8gNyrSWc (http:\/\/www.pouet.net\/prod.php?which=32549)\n\/\/\n\/\/ More info here:  http:\/\/iquilezles.org\/www\/articles\/juliasets3d\/juliasets3d.htm\n\n\n\n\/\/ antialais level (1, 2, 3...)\n#define AA 1\n\n\nvec4 c;\n\nfloat map( in vec3 p, out vec4 oTrap )\n{\n    vec4 z = vec4(p,0.0);\n    float md2 = 1.0;\n    float mz2 = dot(z,z);\n    vec4 nz;\n\n    vec4 trap = vec4(abs(z.xyz),dot(z,z));\n\n    for(int i=0;i<11;i++)\n    {\n        \/\/ |dz|^2 -> 4*|dz|^2\n        md2*=4.0*mz2;\n        \/\/ z -> z2 + c\n        nz.x=z.x*z.x-dot(z.yzw,z.yzw);\n        nz.yzw=2.0*z.x*z.yzw;\n        z=nz+c;\n\n        trap = min( trap, vec4(abs(z.xyz),dot(z,z)) );\n\n        mz2 = dot(z,z);\n        if(mz2>4.0)\n        {\n            break;\n        }\n    }\n    \n    oTrap = trap;\n\n    return 0.25*sqrt(mz2\/md2)*log(mz2);\n}\n\n\/\/ analytical normal for quadratic formula\nvec3 calcNormal( in vec3 p )\n{\n    vec4 nz, ndz;\n\n    vec4 z = vec4(p,0.0);\n\n\tvec4 dz0 = vec4(1.0,0.0,0.0,0.0);\n\tvec4 dz1 = vec4(0.0,1.0,0.0,0.0);\n\tvec4 dz2 = vec4(0.0,0.0,1.0,0.0);\n    vec4 dz3 = vec4(0.0,0.0,0.0,1.0);\n\n  \tfor(int i=0;i<11;i++)\n    {\n        vec4 mz = vec4(z.x,-z.y,-z.z,-z.w);\n\n\t\t\/\/ derivative\n\t\tdz0=vec4(dot(mz,dz0),z.x*dz0.yzw+dz0.x*z.yzw);\n\t\tdz1=vec4(dot(mz,dz1),z.x*dz1.yzw+dz1.x*z.yzw);\n\t\tdz2=vec4(dot(mz,dz2),z.x*dz2.yzw+dz2.x*z.yzw);\n        dz3=vec4(dot(mz,dz3),z.x*dz3.yzw+dz3.x*z.yzw);\n\n        \/\/ z = z2 + c\n\t\tnz.x=dot(z, mz);\n\t\tnz.yzw=2.0*z.x*z.yzw;\n        z=nz+c;\n\n\t    if(dot(z,z)>4.0)\n            break;\n    }\n\n\treturn normalize(vec3(dot(z,dz0),\n\t                      dot(z,dz1),\n\t                      dot(z,dz2)));\n}\n\nfloat intersect( in vec3 ro, in vec3 rd, out vec4 res )\n{\n    vec4 tmp;\n    float resT = -1.0;\n\tfloat maxd = 10.0;\n    float h = 1.0;\n    float t = 0.0;\n    for( int i=0; i<150; i++ )\n    {\n        if( h<0.002||t>maxd ) break;\n\t    h = map( ro+rd*t, tmp );\n        t += h;\n    }\n    if( t<maxd ) { resT=t; res = tmp; }\n\n\treturn resT;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<64; i++ )\n    {\n        vec4 kk;\n        float h = map(ro + rd*t, kk);\n        res = min( res, k*h\/t );\n        if( res<0.001 ) break;\n        t += clamp( h, 0.01, 0.5 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 light1 = vec3(  0.577, 0.577,  0.577 );\n\tvec3 light2 = vec3( -0.707, 0.000, -0.707 );\n\n\tvec4 tra;\n\tvec3 col;\n    float t = intersect( ro, rd, tra );\n    if( t < 0.0 )\n    {\n     \tcol = vec3(0.8,0.9,1.0)*(0.7+0.3*rd.y);\n\t\tcol += vec3(0.8,0.7,0.5)*pow( clamp(dot(rd,light1),0.0,1.0), 48.0 );\n\t}\n\telse\n\t{\n\t\tvec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n\n\t\tfloat dif1 = clamp( dot( light1, nor ), 0.0, 1.0 );\n\t\tfloat dif2 = clamp( 0.5 + 0.5*dot( light2, nor ), 0.0, 1.0 );\n\t\tfloat ao = clamp(2.5*tra.w-0.15,0.0,1.0);\n\n        float sha = softshadow( pos, light1, 0.001, 64.0 );\n        \n        float fre = pow( clamp( 1.+dot(rd,nor), 0.0, 1.0 ), 2.0 );\n        \n        float pa = 0.0;\/\/smoothstep(0.1,0.2,length(tra.xyz));\n\t\tcol = vec3(1.0,0.8,0.7)*0.3;\n        col = mix( col, vec3(0.0), pa );\n        \n\t\tvec3 lin  = 1.5*vec3(0.15,0.20,0.25)*(0.6+0.4*nor.y)*(0.1+0.9*ao);\n\t\t     lin += 3.5*vec3(1.00,0.90,0.70)*dif1*sha;\n\t\t     lin += 1.5*vec3(0.14,0.14,0.14)*dif2*ao;\n             lin += 0.3*vec3(1.00,0.80,0.60)*fre;\n\t\tcol *= lin;\n        col += pow( clamp( dot( ref, light1 ), 0.0, 1.0 ), 32.0 )*dif1*sha;\n        col += (1.0-pa)*0.1*vec3(0.8,0.9,1.0)*smoothstep( 0.0, 0.1, ref.y )*ao*(0.5+0.5*nor.y);\n\t}\n\n\treturn sqrt( col );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ anim\n    float time = iGlobalTime*.15;\n    c = 0.4*cos( vec4(0.5,3.9,1.4,1.1) + time*vec4(1.2,1.7,1.3,2.5) ) - vec4(0.3,0.0,0.0,0.0);\n\n    \/\/ camera\n\tfloat r = 1.4+0.15*cos(0.0+0.29*time);\n\tvec3 ro = vec3(           r*cos(0.3+0.37*time), \n\t\t\t\t\t0.3 + 0.8*r*cos(1.0+0.33*time), \n\t\t\t\t\t          r*cos(2.2+0.31*time) );\n\tvec3 ta = vec3(0.0,0.0,0.0);\n    float cr = 0.1*cos(0.1*time);\n    \n    \n    \/\/ render\n    vec3 col = vec3(0.0);\n    for( int j=0; j<AA; j++ )\n    for( int i=0; i<AA; i++ )\n    {\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord.xy + vec2(float(i),float(j))\/float(AA))) \/ iResolution.y;\n\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(sin(cr), cos(cr),0.0);\n        vec3 cu = normalize(cross(cw,cp));\n        vec3 cv = normalize(cross(cu,cw));\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        col += render( ro, rd );\n    }\n    col \/= float(AA*AA);\n    \n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n\tcol *= 0.7 + 0.3*pow(16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y),0.25);\n    \n\tfragColor = vec4( col, 1.0 );\n}\n","name":"","description":"","type":"image"}]}}