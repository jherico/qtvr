{"Shader":{"ver":"0.1","info":{"id":"MsjXRd","date":"1415141222","viewed":1042,"name":"Taylor","username":"iq","description":"Degree 6 Taylor expansion of cosine (and sine). There's a yellow true sin\/circle graph rendered behind it, but the approximation is accurate to the pixel for this magnification level! Made after demofox' shader https:\/\/www.shadertoy.com\/view\/MdBSRt","likes":7,"published":3,"flags":0,"tags":["2d","taylor","trigonometry"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\/\/ Degree 6 taylor sin and cosine, based on cosine:\n\/\/\n\/\/ cos(x) = 1 - x^2\/2 + x^4\/24 - x^6\/720 + ...\n\/\/\n\/\/ The maximum error happens at x=1\/2 (PI, in radians) (where the graph crosses the \n\/\/ x axis), and it is mySincos(1\/2) = \u22120.000894546 instead of 0.0. This discontinuity\n\/\/ could be fixed easily by offseting the result with that value as we approach the\n\/\/ point x=1\/2. The error term in the Taylos series is therefore\n\/\/\n\/\/ e = -184320\/(PI^8) + 23040\/(PI^6) - 480\/(PI^4) + 4\/(PI^2) = 0.017377, which is of\n\/\/ course clorse to 1\/(8*7), the next term in the Taylor series (or order 8). An order \n\/\/ 8 approximation would bring the error from -0.000894546 down to +0.000024737\n\n\nconst float PI = 3.1415926536;\nconst float E6 = 0.017377;      \/\/ -184320\/(PI^8) + 23040\/(PI^6) - 480\/(PI^4) + 4\/(PI^2)\n\nvec2 mySinCos( float a )\n{\n    vec2 y = a + vec2(0.0,0.25);\n    \n    vec2 s = (fract(1.0*y) - 0.5)*PI;\n    vec2 x = (fract(2.0*y) - 0.5)*PI;\n    vec2 z = x*x;\n    \n    \/\/ show and hide Taylor truncation compensation\n    float errorFix = E6 * step(fract(iGlobalTime),0.5);\n\n    return -sign(s)*(1.0-(1.0-(1.0-(1.0-(\n                     z*errorFix))*\n                     z\/(6.0*5.0))*\n                     z\/(4.0*3.0))*\n                     z\/(2.0*1.0));\n}\n\n\/*\n\/\/ use this if you want to call sincos with radians insteaf of turns.\n\nvec2 mySinCos( float a )\n{\n    vec2 y = a + vec2(0.0,0.5*PI);\n    \n    vec2 s = mod(0.5*y,PI) - 0.5*PI;\n    vec2 x = mod(1.0*y,PI) - 0.5*PI;\n    vec2 z = x*x;\n    \n    return -sign(s) * (1.0-(1.0-(1.0-(1.0-(\n                       z*E6))*\n                       z\/(6.0*5.0))*\n                       z\/(4.0*3.0))*\n                       z\/(2.0*1.0));\n}\n*\/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    float e = 1.0\/iResolution.x;\n    vec2  p = fragCoord.xy \/ iResolution.x;\n    float m = 0.5*iResolution.y\/iResolution.x;\n    \n    \/\/ show discontinuity, by zooming in 500 times \n    \/\/ 000894546*500 = 0.44 graph units -- approx halg screeen gap\n    float zo = 1.0+500.0*pow(clamp(fract(0.34 + iGlobalTime\/6.0)*3.0-1.0,0.0,1.0),4.0);p=vec2(0.5,m)+(p-vec2(0.5,m))\/zo;e\/=zo;\n    \n    vec3 col = vec3( 0.25 );\n    \n    \/\/ axis    \n    float d = abs( p.y - m );\n    col = mix( col, vec3(0.0,0.0,0.0), 1.0 - smoothstep( 0.0, e, d ) );\n\n    \/\/ sine\n    float y = m + m*sin( 6.2831*p.x );\n    d = abs( p.y - y );\n    col = mix( col, vec3(1.0,1.0,0.0), 1.0 - smoothstep( 0.0, 2.0*e, d ) );\n        \n    \/\/ approx sine\n    y = m + m*mySinCos( p.x ).x;\n    d = abs( p.y - y );\n    col = mix( col, vec3(1.0,0.0,0.0), 1.0 - smoothstep( 0.0, 2.0*e, d ) );\n    \n    \/\/ circle, and approx circle\n    float d1 = 1.0;\n    float d2 = 1.0;\n    for( int i=0; i<256; i++ )\n    {\n        float h = float(i)\/256.0;\n        vec2 x1 = vec2(0.5,m) + 0.5*m*mySinCos( h );\n        d1 = min( d1, dot(x1-p,x1-p) );\n        vec2 x2 = vec2(0.5,m) + 0.5*m*vec2( sin(6.2831*h), cos(6.2831*h) );\n        d2 = min( d2, dot(x2-p,x2-p) );\n    }\n    col = mix( col, vec3(1.0,1.0,0.0), 1.0 - smoothstep( 0.0, 2.0*e, sqrt(d2) ) );\n    col = mix( col, vec3(1.0,0.0,0.0), 1.0 - smoothstep( 0.0, 2.0*e, sqrt(d1) ) );\n\n    fragColor = vec4( col, 1.0 );\n}\n","name":"","description":"","type":"image"}]}}