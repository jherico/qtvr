{"Shader":{"ver":"0.1","info":{"id":"ll2GRR","date":"1426777462","viewed":802,"name":"[NV15]Sun Rebirth","username":"EvilRyu","description":"This is how we recharge the sun.","likes":5,"published":3,"flags":0,"tags":["raymarching","space","nv15"],"hasliked":0},"renderpass":[{"inputs":[{"id":4,"src":"\/presets\/tex03.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by EvilRyu 2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ NVScene 2015 Shadertoy Hackathon\n\n\n\n#define SPACE_SHIP 0.0\n#define SUN 1.0\n\n\nfloat type;  \/\/ space ship or sun\nfloat mindist;\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5+0.5*(b-a)\/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nvoid rotate_x(inout vec3 p, float a) \n{ \n    float c,s;vec3 q=p; \n    c = cos(a); s = sin(a);\n    p.y = c * q.y - s * q.z; \n     p.z = s * q.y + c * q.z; \n} \n\nvoid rotate_z(inout vec3 p, float a) \n{ \n    float c,s;vec3 q=p; \n    c = cos(a); s = sin(a); \n    p.x = c * q.x - s * q.y; \n    p.y = s * q.x + c * q.y;\n} \n void rotate_y(inout vec3 p, float a)\n{ \n    float c,s;vec3 q=p; \n    c = cos(a); s = sin(a); \n    p.x = c * q.x + s * q.z; \n    p.z = -s * q.x + c * q.z;\n} \n\nfloat cylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz) ,p.y)) - vec2(h.x, h.y);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sphere(vec3 p, float r) \n{\n    return length(p)-r;\n}\n\nfloat propeller(vec3 p)\n{\n    rotate_y(p,0.7853);\n    float d1=cylinder(vec3(p.x-0.15,p.y+0.15,p.z),vec2(0.03,0.08));\n    p.xy=p.yx;\n    float d2=cylinder(vec3(p.x+0.15,p.y+0.1,p.z),vec2(0.01,0.25));\n    float d3=cylinder(vec3(p.x+0.15,p.y+0.12,p.z),vec2(0.02,0.15));\n    return min(d1,min(d3,d2));\n}\n\nfloat propellers(vec3 p)\n{\n    vec3 z=p;\n    z.xz=abs(z.xz);\n    z.x-=0.25;\n    z.y+=0.08;\n    z.z-=0.25;\n    \n    float d=1e10;\n    d=propeller(z);\n    return d;\n}\n\nfloat gun(vec3 p)\n{\n    p.y-=0.12;\n    return cylinder(p, vec2(0.007,0.35));\n}\n\nfloat spaceship(vec3 p)\n{\n    rotate_z(p,1.5708);\n    rotate_y(p,iGlobalTime*0.2);\n    p.y+=1.0;\n    float d=1e10;\n    float d1=cylinder(vec3(p.x,p.y,p.z),vec2(0.04,0.29));\n    float d2=cylinder(vec3(p.x,p.y,p.z)+vec3(0.0,-0.1,0.0),vec2(0.07,0.09));\n   \n    \n    float d3=propellers(p);\n    float d4=gun(p);\n    if(d>d1){d=d1;}\n    if(d>d2){d=smin(d,d2,0.1);}\n    if(d>d3){d=min(d,d3);}\n    if(d>d4){d=smin(d,d4,0.1);}\n    return d;\n}\n\nfloat dist_to_beam=1e10;\nfloat beam(vec3 p)\n{\n    p.xy=p.yx;\n   \t\n    return cylinder(p, vec2(0.01, 0.45));\n}\n\nfloat f(vec3 p)\n{\n    type=SUN;\n    float d1=sphere(p-vec3(1.0,0.0,0.0), 0.8);\n    float d2=spaceship(p+vec3(0.5,0.0,0.0));\n    float d=1e10;\n    if(d>d1){d=d1;type=SUN;}\n    if(d>d2){d=d2;type=SPACE_SHIP;}\n    \n    float db=beam(p+vec3(0.24,0.0,0.0)); \n    if(dist_to_beam>db){dist_to_beam=db;}  \n    \n    return d;\n}\n\n\nvec3 calcnormal(vec3 p)\n{ \n    vec3 e=vec3(0.001,0.0,0.0); \n    return normalize(vec3(f(p+e.xyy)-f(p-e.xyy), \n                      f(p+e.yxy)-f(p-e.yxy), \n                      f(p+e.yyx)-f(p-e.yyx))); \n}\n\n\nfloat intersect( in vec3 ro, in vec3 rd)\n{\n    float t = 0.0;\n    float h = 1.0;\n    \n    mindist=1e10;\n   \n    for( int i=0; i<48; i++ )\n    {\n        if( h<0.001 || t>20.0 ) continue;\n        h = f(ro + rd*t);\n        mindist=min(h,mindist);\n        t += h;\n    }\n    \n    if(t>20.0) t=-1.0;\n    return t;\n}\n\nvec3 lighting(vec3 p,vec3 rd)\n{\n    vec3 n=calcnormal(p);\n    vec3 col=vec3(0.0);\n    vec3 l1_dir=normalize(vec3(1.0,0.0,0.0));\n    vec3 l2_dir=normalize(vec3(0.0,0.0,1.0));\n     \n    if(type<SUN)   \/\/ space ship\n    {\n        float diff=max(0.0,dot(n,l1_dir));\n        float diff2=max(0.0,dot(n,l2_dir));\n        float spec = max(0.0, pow(clamp(dot(l1_dir, reflect(rd, n)), 0.0, 1.0), 8.0));\n            \n        col=0.8*(0.2*(3.0*diff+diff2+5.0*spec)*vec3(0.3,0.5,0.9))+0.2*3.0*diff*\n             vec3(1.7, 0.62,0.0)*max(0.0,sin(iGlobalTime));\n    }\n    else    \/\/ sun\n    {\n        float diff=max(0.0,dot(n,l2_dir));\n        col=diff*texture2D(iChannel0, vec2(p.x,p.y)*0.9+iGlobalTime*0.05).xxx*vec3(1.3, 0.6,0.2);\n    }\n    return col;\n}\n\nvec3 getbackground(vec3 p)\n{\n    vec3 col=texture2D(iChannel0, p.xy*0.5).xxx;\n    col=pow(col,vec3(2.0));\n    return col;\n}\n\nvec3 scene(vec3 ro, vec3 rd)\n{\n    float hit=intersect(ro,rd);\n    vec3 pos;\n    vec3 col=vec3(0.0);\n    \n    pos=ro+hit*rd;\n    \n    \n    \/\/col+=pow(max(1.0-dist_to_beam,0.0),100.0)*vec3(1.7,0.247, 0.0)*max(0.0,cos(iGlobalTime));\n   \n    \/\/ the fake beam\n    col = mix(col, vec3(1.7, 0.2, 0.0), \n              pow((smoothstep(0.0, 0.05, pos.y+0.05) - smoothstep(0.05, 0.1, pos.y+0.05)) *\n                  (smoothstep(-1.0,0.0,pos.x) - smoothstep(0.0, 1.0, pos.x)), 40.0)) *\n          max(0.0, sin(iGlobalTime+1.0));\n                                                                                          \n    \n    if(type>SPACE_SHIP)  \/\/ sun\n    {\n      col += pow(max(1.0 - mindist,0.0), 10.0)*\n             (vec3(1.7, 0.6470, 0.0))*sin(iGlobalTime-0.5); \/\/ nagative color to dim the sun\n      \n    }\n    \n    if(hit>0.0)\n    {\n        col+=lighting(pos,rd);\n        float t=mod(pos.x-iGlobalTime, 6.283185307); \/\/ match the cycle of sin\n \n      \tcol += vec3(1.7, 0.2, 0.0)*\n              pow(smoothstep(0.0, .3, t) * smoothstep(0.5, .3, t), 20.0)\n             ;\n    }\n    else\n    {\n        col+=(0.3+2.7*max(0.0,sin(iGlobalTime)))*vec3(0.01,0.025,0.05)*getbackground(pos);\n    }\n    \n    return max(col,vec3(0.0));\n}\n\n\nvec3 tracer(vec2 fragCoord) {\n    float fov=3.0;\n    vec3 col = vec3(0.0);\n    vec2 p = 2.0*(fragCoord.xy)\/iResolution.xy-1.0;\n    p.x*=iResolution.x\/iResolution.y;\n    vec2 m = iMouse.xy \/ iResolution.xy;\n    if (iMouse.x == 0.0 && iMouse.y == 0.0) {\n        m = vec2(iGlobalTime * 0.06 + 0.14,0.5);    \n    }\n    m = -1.0 + 2.0 * m;\n    m *= vec2(4.0,-1.5);\n    \n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 ro=vec3(0.0,0.0,4.5);\n\n    vec3 cf = normalize(ta-ro); \n    vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n    vec3 cu = normalize(cross(cs,cf)); \n    vec3 rd = normalize(p.x*cs + p.y*cu + fov*cf);\n        \n    col=scene(ro,rd);\n    return  col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy \/ iResolution.xy;\n    vec3 col = tracer(fragCoord);\n    \/\/ post\n    col=pow(clamp(col,0.0,1.0),vec3(0.45)); \n    col=col*0.6+0.4*col*col*(3.0-2.0*col);\n    col=mix(col, vec3(dot(col, vec3(0.33))), -0.7); \n    col*=pow(20.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7); \n    fragColor = vec4( col, 1.0 );\n}\n","name":"","description":"","type":"image"}]}}