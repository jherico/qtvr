{"Shader":{"ver":"0.1","info":{"id":"XlsXRn","date":"1434063008","viewed":719,"name":"squid - Planets","username":"squid","description":"Strange colored planets in space. Best in Fullscreen, also less dense ","likes":3,"published":3,"flags":0,"tags":["3d","raymarch","dde"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define GRADIENT_DELTA 0.5\n#define FUDGE_FACTOR 0.5\n#define COMPARE_FUDGE_FACTOR 0.2\n\n\n#define time iGlobalTime\n#define size iResolution\n\n\/\/code here is from iq(Distance Functions + shading), effie(DDE), Dave_Hoskins(hash), dgreensp(fbm)\n\/\/also very simular to \"Spinning Rings\"\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nmat3 rotateY(float r)\n{\n    vec2 cs = vec2(cos(r), sin(r));\n    return mat3(cs.x, 0, cs.y, 0, 1, 0, -cs.y, 0, cs.x);\n}\n\nmat3 rotateZ(float r)\n{\n    vec2 cs = vec2(cos(r), sin(r));\n    return mat3(cs.x, cs.y, 0., -cs.y, cs.x, 0., 0., 0., 1.);\n}\n\n#define MOD2 vec2(443.8975,397.2973)\n#define MOD3 vec3(443.8975,397.2973, 491.1871)\n#define MOD4 vec4(443.8975,397.2973, 491.1871, 470.7827)\nfloat hash13(vec3 p)\n{\n\tp  = fract(p * MOD3);\n    p += dot(p.xyz, p.yzx + 19.19);\n    return fract(p.x * p.y * p.z);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3.zxy, p3.yxz+19.19);\n    return fract(vec3(p3.x * p3.y, p3.x*p3.z, p3.y*p3.z));\n}\nvec3 hash33(vec3 p)\n{\n\tp = fract(p * MOD3);\n    p += dot(p.zxy, p+19.19);\n    return fract(vec3(p.x * p.y, p.x*p.z, p.y*p.z));\n}\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx) * MOD4);\n    p4 += dot(p4.wzxy, p4+19.19);\n    return fract(vec4(p4.x * p4.y, p4.x*p4.z, p4.y*p4.w, p4.x*p4.w));\n}\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nvec2 map( in vec3 pos )\n{\n    vec3 c = vec3(16.);\n    vec3 q = opRep(pos, c);\n    vec4 h = hash43( floor(pos\/c-(.5*c)) )*2. - 1.;\n    float rad = h.y*.5 + .5;\n    vec3 ctr = q-vec3(sin(h.z)*cos(h.w),cos(h.z)*sin(h.w),sin(h.z))*(6.5);\n    vec2 res = vec2(\n        sdSphere(ctr , rad), h.x);\n    if(h.y > 0.8)  {\n    \tmat3 r = rotateY(iGlobalTime*h.z*.2)*rotateZ(iGlobalTime*h.w*.2);\n        res = opU(res, vec2(sdTorus(ctr*r, vec2(rad*3., 0.01)), 20.));\n    }\n    return res;\n}\n\n\nfloat DE(vec3 p0)\n{\n    return map(p0).x;\n}\n\nvec2 DDE(vec3 p, vec3 rd){\n\tfloat d1=DE(p);\n  \t\/\/return vec2(d1,d1*COMPARE_FUDGE_FACTOR);\n\tfloat dt=GRADIENT_DELTA*log(d1+1.0);\n\tfloat d2=DE(p+rd*dt);\n\tdt\/=max(dt,d1-d2);\n\treturn vec2(d1,FUDGE_FACTOR*log(d1*dt+1.0));\n}\n\nfloat rndStart(vec2 co){return fract(sin(dot(co,vec2(123.42,117.853)))*412.453);}\n\nmat3 lookat(vec3 fw,vec3 up){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,up));return mat3(rt,cross(rt,fw),fw);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 eps = vec2(.001, 0.);\n    return normalize(vec3(\n        DE(p+eps.xyy) - DE(p-eps.xyy),\n        DE(p+eps.yxy) - DE(p-eps.yxy),\n        DE(p+eps.yyx) - DE(p-eps.yyx)));\n}\n\nfloat noise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.-2.*f);\n\t\n    float n = p.x + p.y*157. + 113.*p.z;\n    \n    vec4 v1 = fract(753.5453123*sin(n + vec4(0., 1., 157., 158.)));\n    vec4 v2 = fract(753.5453123*sin(n + vec4(113., 114., 270., 271.)));\n    vec4 v3 = mix(v1, v2, f.z);\n    vec2 v4 = mix(v3.xy, v3.zw, f.y);\n    return mix(v4.x, v4.y, f.x);\n}\n\nfloat fnoise(vec3 p) {\n  \/\/ random rotation reduces artifacts\n  p = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n           0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n           -0.9548821651308448, 0.26025457467376617, 0.14306504491456504)*p;\n  return dot(vec4(noise(p), noise(p*2.), noise(p*4.), noise(p*8.)),\n             vec4(0.5, 0.25, 0.125, 0.06));\n}\nvec3 compute_color(vec3 ro, vec3 rd, float t)\n{\n    vec3 p = ro+rd*t;\n    vec3 l = normalize(vec3(0., .7, .2));\n    vec3 nor = normal(p);\n    vec3 ref = reflect(rd, nor);\n    \n    float m = map(p).y;\n    vec3 c = vec3(0.);\n    if(m == 20.) {\n        c = vec3(pow(fnoise(p*vec3(2.,1.,1.)),1.4)*.3);\n    } else {\n\t\tc = mix(vec3(1., .2, 0.), vec3(.1, .3, .8), m+.05)*(pow(fnoise(p),2.6)*2.+.3); \/\/hsv2rgb(vec3(.1+m*.2, 1.3, .9));\n    }\n     \n    \n    \n    float dif = clamp( dot( nor, l ), 0.0, 1.0 );\n   \tfloat fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    \n    \n    vec3 v = vec3(0.);\n    v += .6*vec3(dif);\n    v += .3*fre*vec3(.6, .7, .8);\n \treturn c*v;\n}\n\nvec4 pixel(vec2 pxx)\n{\n    float pxl=4.0\/size.y;\/\/find the pixel size\n\tfloat tim=time*0.08+(iMouse.x\/size.x)*5.;\n\t\n\t\/\/position camera\n\tvec3 ro=vec3(cos(tim),0.5+(iMouse.y\/size.y)*2.-1.,sin(tim))*50.4;\n\tvec3 rd=normalize(vec3((2.0*pxx-size.xy)\/size.y,2.0));\n\trd=lookat(-ro,vec3(0.0,1.0,0.0))*rd;\n\t\/\/ro=eye;rd=normalize(dir);\n\tvec3 bcol=vec3(1.0);\n\t\/\/march\n\t\n\tfloat t=DDE(ro,rd).y*rndStart(pxx),d,od=1.0;\n    bool hit = false;\n\tfor(int i=0;i<240;i++){\n\t\tvec2 v=DDE(ro+rd*t,rd);\n\t\td=v.x;\n\t\tfloat px=pxl*(1.0+t);\n\t\tif(d<px){\n            hit = true;\n            break;\n\t\t}\n\t\tod=d;\n\t\tt+=v.y;\/\/d;\n\t\tif(t>150.0)break;\n\t}\n    return hit ? vec4(compute_color(ro, rd, t), 1.) : \n    \t\t\t vec4(vec3(.01 + pow(hash13(rd), 3000.)), 1.) ;\/\/hsv2rgb(vec3(.45, 1., rd.y*.7 + .5)).xyzz*.2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 xy = (fragCoord.xy\/size.xy);\n\tfloat v = .6 + 0.4*pow(20.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.5);\n\tfragColor=pow(pixel(fragCoord.xy)*v, vec4(1.\/2.2));\n\n} ","name":"","description":"","type":"image"}]}}