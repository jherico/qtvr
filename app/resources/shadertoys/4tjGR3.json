{"Shader":{"ver":"0.1","info":{"id":"4tjGR3","date":"1430933546","viewed":790,"name":"VR blobject","username":"RavenWorks","description":"Saving performance in high-res VR by only raymarching on the pixels that can actually see the raymarched object.<br\/>Poly-bg version here: <a href=\"http:\/\/raven.works\/projects\/raymarchObject\/\" class=\"regular\" target=\"_blank\">http:\/\/raven.works\/projects\/raymarchObject\/<\/a><br\/>I could watch this blob all day :P","likes":2,"published":3,"flags":1,"tags":["raymarch","blob","vr"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/#define SHOW_RAYMARCHED_BOUNDS\n\n\nconst float PI =3.141592;\nconst float PI2=6.2831853;\n\n\nconst vec3 objCenter = vec3(0.0,1.35,-0.75);\n\n\n\nfloat smoothBlend( float a, float b, float k ){\n    float h = clamp(0.5+0.5*(b-a)\/k,0.0,1.0);\n    return mix(b,a,h) - k*h*(1.0-h);\n}\n\nvoid hardAdd(inout float curD, float newD){\n    if (newD < curD) {\n        curD = newD;\n    }\n}\nvoid smoothAdd(inout float curD, float newD, float blendPower){\/\/blend colors too?\n    curD = smoothBlend( newD, curD, blendPower );\n}\n\n\nfloat obj_ball(vec3 p, vec3 center, float radius){\n    return length(p-center)-radius;\n}\n\n\n\n\nbool testAABB(vec3 rayPt, vec3 rayDir, vec3 boxMid, vec3 boxSizeHalf, out float dist){\n    \n    \/\/ thank you http:\/\/gamedev.stackexchange.com\/a\/18459\n    \n    vec3 lbGap = (boxMid-boxSizeHalf-rayPt)\/rayDir;\n    vec3 rtGap = (boxMid+boxSizeHalf-rayPt)\/rayDir;\n    \n    float tmin = max(max(min(lbGap.x,rtGap.x),min(lbGap.y,rtGap.y)),min(lbGap.z,rtGap.z));\n    float tmax = min(min(max(lbGap.x,rtGap.x),max(lbGap.y,rtGap.y)),max(lbGap.z,rtGap.z));\n    if (tmax < 0.0) return false;\n    if (tmin > tmax) return false;\n\t\n\tdist = tmin;\n\t\n    return true;\n    \n}\n\n\nconst vec3 e=vec3(0.001,0,0);\nconst float maxd=256.0; \/\/Max depth\nfloat nearestD = maxd;\nvec3 color = vec3(0.0,0.0,1.0);\nvec3 normal = vec3(0.0);\nconst vec3 lightPt = vec3(0.0,1.9,0.0);\n\nvoid renderAABB(vec3 rayPt, vec3 rayDir, vec3 boxMid, vec3 boxSizeHalf, vec3 boxColor, out float dist){\n    float curDist;\n    if (testAABB(rayPt, rayDir, boxMid, boxSizeHalf, curDist)) {\n        if (curDist < dist) {\n            \n            vec3 intersectPt = rayPt + rayDir*curDist;\n            vec3 norm = (intersectPt - boxMid) \/ boxSizeHalf;\n            \n            \/\/ I'm sure this is very silly but whatever\n            if (abs(norm.x) > abs(norm.y)) {\n                norm.y = 0.0;\n                if (abs(norm.x) > abs(norm.z)) {\n                    norm.z = 0.0;\n                    norm.x = (norm.x>0.0)?1.0:-1.0;\n                } else {\n                    norm.x = 0.0;\n                    norm.z = (norm.z>0.0)?1.0:-1.0;\n                }\n            } else {\n                norm.x = 0.0;\n                if (abs(norm.y) > abs(norm.z)) {\n                    norm.z = 0.0;\n                    norm.y = (norm.y>0.0)?1.0:-1.0;\n                } else {\n                    norm.y = 0.0;\n                    norm.z = (norm.z>0.0)?1.0:-1.0;\n                }\n            }\n            \n            normal = norm;\n            color = boxColor;\n            dist = curDist;\n            \n        }\n    }\n}\n\n\n\n\n\nvec3 blobBallPos(float i){\n    \n    float v = iGlobalTime*2.0 + i*100.0;\n    return vec3(\n        sin( v + sin(v*0.8) + sin(v*0.2)*sin(v*2.1) )*0.1,\n    \tsin( v + sin(v*0.6) + sin(v*0.4)*sin(v*2.2) )*0.1,\n    \tsin( v + sin(v*0.4) + sin(v*0.6)*sin(v*2.3) )*0.1\n    );\n    \n}\n\nfloat blobDistance(vec3 p){\n    \n    float distance = 9999.9;\n    const float blobRad = 0.09;\n    \n    hardAdd(distance, obj_ball(p, objCenter+blobBallPos(0.0), blobRad) );\n    for(float i=1.0; i<8.0; i+=1.0){\n    \tsmoothAdd(distance, obj_ball(p, objCenter+blobBallPos(i), blobRad) , 0.08);\n    }\n    \n    \n    \n    \n    \n    \n    return distance;\n    \n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ) {\n    \n    \n    \n    vec3 scrCoord = fragRayOri;\n    vec3 curCameraRayUnit = fragRayDir;\n    \n    \n    color = vec3(0.0);\n    normal = vec3(0.0);\n    \n    \n    scrCoord.y += 1.5;\n    \n    \n    \n    vec3 wallColor = vec3(0.75,0.75,1.0);\n    vec3 standColor = vec3(0.625,0.625,1.0);\n    vec3 standAccentColor = vec3(0.5625,0.5625,1.0);\n    vec3 floorTileColor = vec3(0.6875,0.6875,1.0);\n    \n    renderAABB(scrCoord,curCameraRayUnit,vec3(0.0,1.0,2.1),vec3(2.0,1.0,0.1),wallColor,nearestD);\n    renderAABB(scrCoord,curCameraRayUnit,vec3(0.0,1.0,-2.1),vec3(2.0,1.0,0.1),wallColor,nearestD);\n    renderAABB(scrCoord,curCameraRayUnit,vec3(0.0,-0.1,0.0),vec3(2.0,0.1,2.0),wallColor,nearestD);\n    renderAABB(scrCoord,curCameraRayUnit,vec3(0.0,2.1,0.0),vec3(2.0,0.1,2.0),wallColor,nearestD);\n    renderAABB(scrCoord,curCameraRayUnit,vec3(2.1,1.0,0.0),vec3(0.1,1.0,2.0),wallColor,nearestD);\n    renderAABB(scrCoord,curCameraRayUnit,vec3(-2.1,1.0,0.0),vec3(0.1,1.0,2.0),wallColor,nearestD);\n    \n    renderAABB(scrCoord,curCameraRayUnit,vec3(0.0,0.9,-0.75),vec3(0.25,0.025,0.25),standAccentColor,nearestD);\n    renderAABB(scrCoord,curCameraRayUnit,vec3(0.0,0.5,-0.75),vec3(0.2,0.5,0.2),standColor,nearestD);\n    \n    const float roomW = 4.0;\n    const float roomL = 4.0;\n    for(float tileX=0.0; tileX<roomW; tileX+=1.0){\n        for(float tileY=0.0; tileY<roomL; tileY+=1.0){\n            renderAABB(scrCoord,curCameraRayUnit,\n                       vec3(tileX-(roomW-1.0)\/2.0,0.0,tileY-(roomL-1.0)\/2.0),\n                       vec3(0.485,0.025,0.485),floorTileColor,nearestD);\n        }\n    }\n    \n    \n    float diffuseCheat = 0.0;\n    float specP = 1.0;\n    float specA = 0.0;\n    \n    \n    float dummyD = 9999.9;\n    if (testAABB(scrCoord,curCameraRayUnit,objCenter,vec3(0.21),dummyD)) {\n        \n        #ifdef SHOW_RAYMARCHED_BOUNDS\n        color += vec3(0.1,0.0,0.0);\n        #endif\n        \n        vec3 p = scrCoord;\n        \n        float f=0.0;\n        float d=0.01;\n        for(int i=0;i<64;i++){\n            if ((abs(d) < .001) || (f > maxd)) break;\n            f+=d;\n            p=scrCoord + curCameraRayUnit*f;\n            d = blobDistance(p);\n        }\n\n        if (f < nearestD) {\n\n            nearestD = f;\n\n            normal = normalize(vec3(d-blobDistance(p-e.xyy),\n                                    d-blobDistance(p-e.yxy),\n                                    d-blobDistance(p-e.yyx)));\n            \n            color = vec3(1.0,0.0,1.0);\n            diffuseCheat = 0.2;\n            specP = 8.0;\n            specA = 1.0;\n            \n        }\n        \n    }\n    \n    \n    \n    vec3 intersectPt = scrCoord + curCameraRayUnit * nearestD;\n    \n    vec3 lightGap = lightPt-intersectPt;\n    vec3 lightGapNorm = normalize(lightGap);\n    float litAmt = dot(normal,lightGapNorm);\n    litAmt = litAmt*(1.0-diffuseCheat)+diffuseCheat;\n\n    float lightDist = length(lightGap);\n    lightDist \/= 16.0;\n    lightDist = max(lightDist,0.0);\n    lightDist = min(lightDist,1.0);\n    lightDist = pow(1.0-lightDist,2.0);\n    \n    float specular = max(0.0,dot(normalize(lightGapNorm-curCameraRayUnit),normal));\n    \n    color = color*litAmt*lightDist + pow(specular,specP)*specA;\n    \n    \n    \n    \n    fragColor = vec4(color,1.0);\n    \n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    \n    float camLookX, camLookY;\n    \n    vec2 mouseFrac = iMouse.xy\/iResolution.xy;\n    mouseFrac -= 0.5;\n    mouseFrac *= 2.0;\n    \n    if (iMouse.z != 0.0) {\n        \n        camLookX = PI + mouseFrac.x * PI;\n        \n    \tcamLookY = -mouseFrac.y;\n        camLookY *= PI*0.35;\n        \n    } else {\n        camLookX = PI;\n        camLookY = -0.25;\n    }\n    \n    \n    \n    \n    \/\/ all this stuff with working from FOVs is for the sake of WebVR compatibility,\n    \/\/ which is redundant for shadertoy, but handy for my personal site\n    \n    float vertFov = 50.0;\n    float horizFov = 2.0*atan(tan((vertFov\/180.0*PI)\/2.0)*(iResolution.x\/iResolution.y))*180.0\/PI;\n    vec4 fovAngsMono = vec4(horizFov\/2.0, horizFov\/2.0, vertFov\/2.0, vertFov\/2.0);\n    \n    \n    \n    vec2 fragFrac = fragCoord.xy\/iResolution.xy;\n\n    vec2 eyeRes = iResolution.xy;\n    vec4 fovAngs = fovAngsMono;\n    \n    vec3 cameraRight = vec3(cos(camLookX),0.0,sin(camLookX));\n    vec3 cameraFwd = vec3(cos(camLookX+PI*0.5)*cos(camLookY),sin(camLookY),sin(camLookX+PI*0.5)*cos(camLookY));\n    vec3 cameraUp = -cross(cameraRight,cameraFwd);\n    \n    \n    \n    \/\/ position\n\n    vec3 cameraPos = vec3(0.0);\n    \n    \n    \n    float fovL = -fovAngs.x\/180.0*PI;\n    float fovR =  fovAngs.y\/180.0*PI;\n    float fovU = -fovAngs.z\/180.0*PI;\n    float fovD =  fovAngs.w\/180.0*PI;\n\n    float fovMiddleX = (fovR + fovL) * 0.5;\n    float fovMiddleY = (fovU + fovD) * 0.5;\n    float fovHalfX = (fovR - fovL) * 0.5;\n    float fovHalfY = (fovD - fovU) * 0.5;\n\n\n\n    float scrWorldHalfX = sin(fovHalfX)\/sin(PI*0.5 - fovHalfX);\n    float scrWorldHalfY = sin(fovHalfY)\/sin(PI*0.5 - fovHalfY);\n\n\n    \/\/ determine screen plane size from FOV values, then interpolate to find current pixel's world coord\n\n    vec2 vPos = fragFrac;\/\/0 to 1\n    vPos.x -= (-fovL\/(fovHalfX*2.0));\n    vPos.y -= (-fovU\/(fovHalfY*2.0));\n\n    vec3 screenPlaneCenter = cameraPos+cameraFwd;\n    vec3 scrCoord = screenPlaneCenter + vPos.x*cameraRight*scrWorldHalfX*2.0 + vPos.y*cameraUp*scrWorldHalfY*2.0;\n    vec3 curCameraRayUnit = normalize(scrCoord-cameraPos);\n    \n    \n    \n    mainVR(fragColor,fragCoord,cameraPos,curCameraRayUnit);\n    \n    \n}","name":"","description":"","type":"image"}]}}