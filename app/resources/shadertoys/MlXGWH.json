{"Shader":{"ver":"0.1","info":{"id":"MlXGWH","date":"1421511030","viewed":814,"name":"smooth kali pattern","username":"bergi","description":"A hand selected 1\u00b3 block in the kali set that looks a bit like voronoi cells and doesn't exhibit 'noise' - up to an iteration count of about 30.<br\/>mouse y = slice \/ x = surface selector","likes":3,"published":3,"flags":0,"tags":["kaliset","generative"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/* (c) stefan berke - common shadertoy.com license\n\n   A hand selected 1\u00b3 block in the kali set \n   that looks a bit like voronoi cells \n   and doesn't exhibit 'noise' \n     - up to a certain iteration count.\n\n   Playing with the iteration count is very nice though ;)\n\n   It's a relatively small area but with a higher iteration\n   this could be a huge generative map i presume. \n\n   Any help of raymarching the kali set efficiently is really appreciated.\n   I mean, getting a real distance to some choosen surface value. \n   Is saw iq's dual-number mandelbrot. Is there a similiar trick for doing\n   non-complex-numbered fractals?\n\n*\/   \n\n#define NUM_ITERS 26\n\n\/\/ for lights - not enabled by default\n#define NORM_EPS 0.0002\n\n\n\/\/ a voronoi like pattern for [0,1]\n\/\/ max iterations before cosmos: ~31\nfloat smoothpattern(in vec3 pos)\n{\n    \/\/ squeeze into the smooth region\n    vec3 p = pos;\n    p.x -= 0.2*p.y; \/\/ unstretch a bit\n    p *= 0.06;\n    p += vec3(0.32, 0.61, 0.48);\n    \/\/ magic param is a function of input pos\n    vec3 param = vec3(p.x); \n\n    \/\/ kali set\n\tfloat mag, ac = 0.;\n\tfor (int i=0; i<NUM_ITERS; ++i)\n    {\n\t\tmag = dot(p, p);\n        p = abs(p) \/ mag - param;\n        ac += mag;\n    }\n    \n    return ac \/ float(NUM_ITERS)\n        \/\/ keep the intensity roughly the same\n        \/\/ for all points\n        \t* 0.9 * (0.75 + 0.25 * pos.x) \n        \/\/ and push the surface in the [0,1] range\n        - 1.5;\n}\n\n\nvec3 smoothpattern_norm(in vec3 pos)\n{\n    const vec3 e = vec3(NORM_EPS, 0., 0.);\n    return normalize(vec3(\tsmoothpattern(pos+e.xyy) - smoothpattern(pos-e.xyy),\n                          \tsmoothpattern(pos+e.yxy) - smoothpattern(pos-e.yxy),\n                          \tsmoothpattern(pos+e.yyx) - smoothpattern(pos-e.yyx) ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\n    \/\/ z position\n    float Z = iMouse.y \/ iResolution.y;\n    \/\/ surface value\n    float S = iMouse.x \/ iResolution.x;\n\n    float V = min(1., smoothpattern(vec3(uv, Z)));\n    vec3  N = smoothpattern_norm(vec3(uv, Z));\n    \n    \/\/black\/white\n    vec3 col = vec3(smoothstep(S-0.01, S+0.01, V));\n    \n    \/\/ mix in a bit of the actual value\n    col += 0.3*(vec3(V*V,V,V*V*V)-col);;\n    \n    \/\/ no - does not actuall look so nice\n    \/\/float light = max(0., dot(N, normalize(vec3(1,1,.5))));\n    \/\/col += 0.4 * light * vec3(1.,0.8,0.2);\n    \n    fragColor = vec4(col,1.0);\n}","name":"","description":"","type":"image"}]}}