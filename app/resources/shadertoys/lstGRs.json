{"Shader":{"ver":"0.1","info":{"id":"lstGRs","date":"1451870196","viewed":304,"name":"Window Space Implicit Surfaces","username":"paniq","description":"Demos how to use bisection using interval arithmetic to interrogate an implicit surface in window\/frustum space. Features implicit frustum culling, backfacing gradient culling and detecting fully occluded cells (for filling a hierarchical z-buffer).","likes":8,"published":3,"flags":0,"tags":["implicit","frustum","window","bisection","arithmetic","quadtree","interval"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ originally written in Nonelang and auto-translated to GLSL, \n\/\/ sorry for the mess ;-)\n\nvec2 u_resolution;\nfloat u_time;\n\nvec2 _2986 (float near, float far) {\n    return vec2(far + near, (-2.000000 * far) * near) \/ (far - near);\n}\nfloat outline (float d) {\n    return 1.000000 - smoothstep(0.000000, 3.000000 \/ u_resolution . y, abs(d));\n}\nfloat crossline (vec2 p) {\n    p = abs(p);\n    float minp;\n    minp = min(p . x, p . y);\n    float maxp;\n    maxp = (p . x + p . y) - minp;\n    return max(maxp - 1.000000, minp);\n}\nvec2 ia_div (vec2 a, vec2 b) {\n    vec4 q;\n    q = vec4(a . x \/ b, a . y \/ b);\n    return vec2(min(min(min(q . x, q . y), q . z), q . w), max(max(max(q . x, q . y), q . z), q . w));\n}\nvec2 _44 (vec2 a, float b) {\n    return a - vec2(b);\n}\nvec2 _51 (vec2 a, vec2 b) {\n    vec4 q;\n    q = a . xxyy * b . xyxy;\n    return vec2(min(min(min(q . x, q . y), q . z), q . w), max(max(max(q . x, q . y), q . z), q . w));\n}\nvec2 _32 (vec2 a, float b) {\n    return a + b;\n}\nvec2 _29 (vec2 a, vec2 b) {\n    return a + b;\n}\nvec2 _57 (float a, vec2 b) {\n    vec2 q;\n    q = a * b . xy;\n    return vec2(min(q . x, q . y), max(q . x, q . y));\n}\nvoid _69 (mat2 m, vec2 x, vec2 y, inout vec2 ox, inout vec2 oy) {\n    ox = _29(_57(m[0][0], x), _57(m[1][0], y));\n    oy = _29(_57(m[0][1], x), _57(m[1][1], y));\n}\nvec2 _11 (vec2 a, vec2 b) {\n    return vec2(min(a . x, b . x), min(a . y, b . y));\n}\nvec2 _20 (vec2 a, vec2 b) {\n    return vec2(max(a . x, b . x), max(a . y, b . y));\n}\nvec2 ia_unm (vec2 a) {\n    return-a . yx;\n}\nvec2 ia_abs (vec2 a) {\n    if (a . x >= 0.000000)\n        return a;\n    else if (a . y < 0.000000)\n        return ia_unm(a);\n    else\n        return vec2(0.000000, max(-a . x, a . y));\n}\nvec2 ia_sqrt (vec2 a) {\n    return sqrt(a);\n}\nvec2 ia_pow2 (vec2 a) {\n    vec2 q;\n    q = a * a;\n    if (a . x >= 0.000000)\n        return q;\n    else if (a . y < 0.000000)\n        return q . yx;\n    else\n        return vec2(0.000000, max(q . x, q . y));\n}\nvec2 circle_ia (vec2 x, vec2 y, vec2 r) {\n    return _44(ia_sqrt(_29(ia_pow2(x), ia_pow2(y))), r . x);\n}\nvec2 surface (mat2 mtx, vec2 x, vec2 y) {\n    y = _44(y, 0.500000);\n    y = _32(y, mix(0.500000, -3.000000, (cos(u_time) * 0.500000) + 0.500000));\n    x = _32(x, sin(u_time));\n    _69(mtx, x, y, x, y);\n    return _11(_44(_20(ia_abs(x), ia_abs(y)), 0.600000 * 0.400000), _20(circle_ia(x, y, vec2(0.600000)), ia_unm(circle_ia(x, y, vec2(0.600000 * 0.500000)))));\n}\nbool ia_contains (vec2 a, float t) {\n    return(t >= a . x) && (t <= a . y);\n}\nvec2 _63 (vec2 a, float b) {\n    vec2 q;\n    q = b * a . xy;\n    return vec2(min(q . x, q . y), max(q . x, q . y));\n}\nvec2 _38 (vec2 a, vec2 b) {\n    return a - b . yx;\n}\nvec2 gradient_limit (mat2 mtx, vec2 x, vec2 y, vec2 d, float eps) {\n    vec2 dx;\n    dx = _63(_38(surface(mtx, _32(x, eps), y), surface(mtx, _44(x, eps), y)), 1.000000 \/ (2.000000 * eps));\n    vec2 dy;\n    dy = _63(_38(surface(mtx, x, _32(y, eps)), surface(mtx, x, _44(y, eps))), 1.000000 \/ (2.000000 * eps));\n    return _29(_63(dx, d . x), _63(dy, d . y));\n}\nvec4 trace_tree_ia (mat2 mtx, vec2 p) {\n    float near;\n    near = 0.500000;\n    vec2 coeffs;\n    coeffs = _2986(near, 100.000000);\n    float b;\n    b = 0.000000;\n    float s;\n    s = 1.000000;\n    p . y = p . y + 1.000000;\n    \/\/ scaling factor\n    p = p * 2.0;\n    p . y = p . y + near;\n    vec2 q;\n    q = vec2(p . x \/ p . y, ((p . y * coeffs . x) + coeffs . y) \/ p . y);\n    vec2 c;\n    c = vec2(0.000000);\n    float L;\n    L = 0.000000;\n    float cf;\n    cf = mtx[0][0];\n    float sf;\n    sf = mtx[0][1];\n    vec2 iax;\n    iax = vec2(0.000000);\n    vec2 iay;\n    iay = vec2(0.000000);\n    vec2 vpos;\n    vpos = vec2(0.000000);\n    vec4 vcol;\n    vcol = vec4(0.000000);\n    if (max(abs(q . x), abs(q . y)) < 1.000000) {\n        {\n            for (int i = 0; i < 11; ++i) {\n                {\n                    b = b + outline(crossline(q) * s);\n                }\n                {\n                    s = s * 0.500000;\n                }\n                vec2 o;\n                o = (step(vec2(0.000000), q) * 2.000000) - 1.000000;\n                q = (q * 2.000000) - o;\n                c = c + (o * s);\n                iax = vec2(c . x - s, c . x + s);\n                iay = vec2(c . y - s, c . y + s);\n                vec2 w;\n                w = ia_div(vec2(coeffs . y), _44(iay, coeffs . x));\n                iax = _51(iax, w);\n                iay = _51(iay, w);\n                vec2 va;\n                va = vec2(c . x, -1.000000) * (coeffs . y \/ (-1.000000 - coeffs . x));\n                vec2 vb;\n                vb = vec2(c . x, 1.000000) * (coeffs . y \/ (1.000000 - coeffs . x));\n                vec2 vq;\n                vq = c * (coeffs . y \/ (c - coeffs . x));\n                vpos = normalize(va - vb);\n                vec2 d2;\n                d2 = surface(mtx, iax, iay);\n                if (d2 . y <= 0.000000) {\n                    vcol = vcol + vec4(0.000000, 1.000000, 0.000000, 1.000000);\n                }\n                if (ia_contains(d2, 0.000000)) {\n                    vec2 g2;\n                    g2 = gradient_limit(mtx, iax, iay, vpos, 0.050000);\n                    float gc;\n                    gc = (g2 . x + g2 . y) * 0.500000;\n                    if (g2 . y > 0.000000) L = L + 1.0;\n                    else {\n                        break;\n                    }\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n    return vcol + ((L \/ 11.000000) * vec4(1.000000));\n}\nfloat circle_l2 (vec2 p, vec2 r) {\n    return(length(p \/ r) - 1.000000) * min(r . x, r . y);\n}\nvec4 frag () {\n    vec2 p;\n    p = ((2.000000 * gl_FragCoord . xy) - u_resolution) \/ u_resolution . y;\n    float L;\n    L = 0.000000;\n    vec4 M;\n    M = vec4(0.000000);\n    float N;\n    N = 0.000000;\n    float a;\n    a = u_time * 0.300000;\n    float cf;\n    cf = cos(a);\n    float sf;\n    sf = sin(a);\n    mat2 mtx;\n    mtx = mat2(cf, sf, -sf, cf);\n    M = trace_tree_ia(mtx, p);\n    float od;\n    od = circle_l2(p, vec2(0.600000));\n    return 0.000000 + M;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    u_resolution = iResolution.xy;\n    u_time = iGlobalTime;\n\tfragColor = frag();\n}","name":"","description":"","type":"image"}]}}