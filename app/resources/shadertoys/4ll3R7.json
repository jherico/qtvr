{"Shader":{"ver":"0.1","info":{"id":"4ll3R7","date":"1420921872","viewed":1048,"name":"Refraction blobs","username":"LeWiZ","description":"Playing with reflection & refraction.<br\/><br\/>Update 1 : better refraction (2 sided)<br\/>Update 2 : speed optimization (nearly 3x faster now)","likes":9,"published":3,"flags":0,"tags":["reflection","metaballs","refraction","transparent","blob"],"hasliked":0},"renderpass":[{"inputs":[{"id":24,"src":"\/presets\/cube02_0.jpg","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"id":25,"src":"\/presets\/cube03_0.png","ctype":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"float sphere(vec3 pos)\n{\n\treturn length(pos)-1.0;   \n}\n\nfloat blob5(float d1, float d2, float d3, float d4, float d5)\n{\n    float k = 2.0;\n\treturn -log(exp(-k*d1)+exp(-k*d2)+exp(-k*d3)+exp(-k*d4)+exp(-k*d5))\/k;\n}\n\nfloat scene(vec3 pos)\n{\n    float t = iGlobalTime;\n    \n    float ec = 1.5;\n\tfloat s1 = sphere(pos - ec * vec3(cos(t*1.1),cos(t*1.3),cos(t*1.7)));\n    float s2 = sphere(pos + ec * vec3(cos(t*0.7),cos(t*1.9),cos(t*2.3)));\n    float s3 = sphere(pos + ec * vec3(cos(t*0.3),cos(t*2.9),sin(t*1.1)));\n    float s4 = sphere(pos + ec * vec3(sin(t*1.3),sin(t*1.7),sin(t*0.7)));\n    float s5 = sphere(pos + ec * vec3(sin(t*2.3),sin(t*1.9),sin(t*2.9)));\n    \n    return blob5(s1, s2, s3, s4, s5);\n}\n\nfloat intersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 20.0;\n\tconst float precis = 0.001;\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<90; i++ )\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = scene( ro+rd*t );\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*scene( pos + v1*eps ) + \n\t\t\t\t\t  v2*scene( pos + v2*eps ) + \n\t\t\t\t\t  v3*scene( pos + v3*eps ) + \n\t\t\t\t\t  v4*scene( pos + v4*eps ) );\n}\n\nvec3 background( vec3 rd )\n{\n\treturn textureCube(iChannel0, rd).rgb;\n}\n\nvec3 calcLight( in vec3 pos , in vec3 camdir, in vec3 lightp, in vec3 lightc, in vec3 normal , in vec3 texture)\n{\n    vec3 lightdir = normalize(pos - lightp);\n    float cosa = pow(0.5+0.5*dot(normal, -lightdir),2.5);\n    float cosr = max(dot(-camdir, reflect(lightdir, normal)),0.0);\n    \n    vec3 diffuse = 1.0 * cosa * texture;\n    vec3 phong = vec3(1.0 * pow(cosr, 64.0));\n    \n    return lightc * (diffuse + phong);\n}\n\nvec3 illuminate( in vec3 pos , in vec3 camdir)\n{\n    vec3 normal = calcNormal(pos);\n    \n    const float ETA = 0.9;\n    vec3 refrd = -refract(camdir,normal,ETA);\n    vec3 refro = pos + 10.0 * refrd;\n    float refdist = intersection(refro, refrd);\n    vec3 refpos = refro + refdist * refrd;\n    vec3 refnormal = calcNormal(refpos);\n    \n    vec3 tex0 = textureCube(iChannel0, refract(-refrd,-refnormal,1.0\/ETA)).rgb;\n    vec3 tex1 = textureCube(iChannel1, refract(-refrd,-refnormal,1.0\/ETA)).rgb;\n    if (refdist < -0.5) {\n        tex0 = background(-refrd);\n        tex1 = tex0;\n    }\n    vec3 tex2 = textureCube(iChannel0, reflect(camdir,normal)).rgb;\n    vec3 tex3 = textureCube(iChannel1, reflect(camdir,normal)).rgb;\n    vec3 texture = vec3(1.0,0.9,0.9)* (0.4 * tex0 + 0.4 * tex1 + 0.03 * tex2 + 0.1 * tex3);\n    \n\tvec3 l1 = calcLight(pos, camdir, vec3(0.0,10.0,-20.0), vec3(1.0,1.0,1.0), normal, texture);\n    vec3 l2 = calcLight(pos, camdir, vec3(-20,10.0,0.0), vec3(1.0,1.0,1.0), normal, texture);\n    vec3 l3 = calcLight(pos, camdir, vec3(20.0,10.0,0.0), vec3(1.0,1.0,1.0), normal, texture);\n    vec3 l4 = calcLight(pos, camdir, vec3(0.0,-10.0,20.0), vec3(0.6,0.6,0.6), normal, texture);\n    return l1+l2+l3+l4;\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = (fragCoord.xy - iResolution.xy\/2.0) \/ min(iResolution.xy.x, iResolution.xy.y);\n    vec2 mouse = (iMouse.xy - iResolution.xy\/2.0) \/ min(iResolution.xy.x, iResolution.xy.y);\n    \n    float t = iGlobalTime;\n    vec3 campos = vec3(8.0*sin(0.3*t+3.0*mouse.x),0.0,-8.0*cos(0.3*t+3.0*mouse.x));\n    vec3 camtar = vec3(0.0,0.0,0.0);\n    \n    mat3 camMat = calcLookAtMatrix( campos, camtar, 0.0 );  \/\/ 0.0 is the camera roll\n\tvec3 camdir = normalize( camMat * vec3(xy,1.0) ); \/\/ 2.0 is the lens length\n    \n    vec3 col = vec3(0.0,0.0,0.0);\n    \n    float dist = intersection(campos, camdir);\n    \n    if (dist < -0.5) col = background(camdir);\n    else\n    {\n    \tvec3 inters = campos + dist * camdir;\n    \tcol = illuminate(inters, camdir);\n    }\n    \n\tfragColor = vec4(col,1.0);\n}","name":"","description":"","type":"image"}]}}