{"Shader":{"ver":"0.1","info":{"id":"XsdGDM","date":"1450086340","viewed":124,"name":"Volumetric Light","username":"jackdavenport","description":"My first attempt at volumetric lighting! Built upon this amazing shader: https:\/\/www.shadertoy.com\/view\/4dsGRn","likes":2,"published":3,"flags":0,"tags":["raymarch","lighting","volumetric","fog","realtime"],"hasliked":0},"renderpass":[{"inputs":[{"id":22,"src":"\/presets\/cube00_0.jpg","ctype":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define MAX_ITERATIONS 64\n#define MIN_DISTANCE .001\n#define SAMPLES 5\n#define AMBIENT .2\n\nstruct Ray {\n  vec3 ori;\n  vec3 dir;\n};\nstruct Dist {\n  float dst;\n  int id;\n};\nstruct Hit {\n  vec3 p;\n  float dst;\n  int id;\n};\nstruct Light {\n  vec3 p;\n  float r;\n};\n   \n\/\/ Source: http:\/\/stackoverflow.com\/questions\/4200224\/random-noise-functions-for-glsl\nfloat rand(vec2 co) {\n    \n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n\n}\n    \nfloat distSphere(vec3 p, vec3 pos, float radius) {\n\n    return length(pos - p) - radius;\n    \n}\n\nDist distScene(vec3 p) {\n \n    float dSphere = distSphere(p, vec3(0.,0.,0.), 1.);\n    return Dist(dSphere, 0);\n    \n}\n\nHit raymarch(Ray ray) {\n \n    vec3 p  = ray.ori;\n    float d = 0.;\n    int  id = -1;\n    \n    for(int i = 0; i < MAX_ITERATIONS; i++) {\n        \n   \t\tp = ray.ori + ray.dir * d;\n    \tDist dst = distScene(p);\n        d += dst.dst;\n        \n        if(dst.dst < MIN_DISTANCE) {\n         \n            p  = ray.ori + ray.dir * d;\n            id = dst.id;\n            break;\n            \n        }\n        \n    }\n    \n    return Hit(p,d,id);\n    \n}\n\nLight getLight() {\n \n    float t = iGlobalTime;\n    if(iMouse.z > 0.) t = ((iMouse.x * iMouse.y) \/ (iResolution.x * iResolution.y)) * 2. - 1.;\n    return Light(vec3(-3. * cos(t),2. * sin(t), 2. * sin(t)), 40.);\n    \n}\n\nvec3 calcIrradiance(Light l, vec3 p) {\n \n    return vec3(1. - clamp(length(l.p - p) \/ l.r, 0., 1.));\n    \n}\n\nvec3 calcNormal(vec3 p) {\n \n    vec2 eps = vec2(MIN_DISTANCE, 0.);\n    vec3 n = vec3(distScene(p + eps.xyy).dst - distScene(p - eps.xyy).dst,\n                  distScene(p + eps.yxy).dst - distScene(p - eps.yxy).dst,\n                  distScene(p + eps.yyx).dst - distScene(p - eps.yyx).dst);\n    return normalize(n);\n    \n}\n\nvec3 calcLighting(Ray ray, Hit hit, vec3 n) {\n \n    Light l = getLight();\n    vec3  i = calcIrradiance(l, hit.p);\n    \n    if(i == vec3(0.)) {\n     \n        return vec3(AMBIENT);\n        \n    }\n    \n    vec3 ld = normalize(l.p - hit.p);\n    float d = max(dot(ld,n), 0.);\n    \n    return clamp(AMBIENT + vec3(d) * i, 0., 1.);\n    \n}\n\nvec3 calcVolumetric(Ray ray, float maxDist) {\n \n    vec3 col = vec3(0.);\n    \n    Light l   = getLight();\n    float is  = maxDist \/ 50.;\n    float vrs = maxDist \/ float(SAMPLES - 1);\n    float rs  = rand(gl_FragCoord.xy) + vrs;\n    \n    Ray volRay = Ray(ray.ori + ray.dir * rs, vec3(0.));\n    \n    for(int v = 0; v < SAMPLES; v++) {\n     \n        vec3 lv    = l.p - volRay.ori;\n        float ld   = length(lv);\n        volRay.dir = lv \/ ld;\n        Hit i      = raymarch(volRay);\n        \n        if(i.dst > ld) {\n         \n            col += calcIrradiance(l, volRay.ori) * is;\n            \n        }\n        \n        volRay.ori += ray.dir * vrs;\n        \n    }\n    \n    return col;\n    \n}\n\nvec3 clearColor(vec3 dir) {\n \n    return textureCube(iChannel0, dir).xyz * .1;\n    \n}\n\nvec3 shade(Ray ray) {\n \n    Hit scene = raymarch(ray);\n    vec3 col = vec3(0.);\n    \n    if(scene.id == 0) {\n     \n        vec3 n = calcNormal(scene.p);\n        col = calcLighting(ray, scene, n);\n        \n    } else {\n     \n        col = clearColor(ray.dir);\n        \n    }\n    \n    vec3 vl = calcVolumetric(ray, min(scene.dst, 3.));\n    col -= vl * .5;\n    col += vl;\n    \n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy \/ 2.) \/ iResolution.y;\n    \n    vec3 ori = vec3(0., 0., -4.);\n    vec3 dir = vec3(uv, 1.);\n    \n    Ray  ray = Ray(ori,dir);\n    vec4 col = vec4(clamp(shade(ray),0.,1.),1.0);\n    \n\tfragColor = col;\n}","name":"","description":"","type":"image"}]}}