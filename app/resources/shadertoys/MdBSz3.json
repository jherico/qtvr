{"Shader":{"ver":"0.1","info":{"id":"MdBSz3","date":"1414250370","viewed":866,"name":"VR test scene","username":"RavenWorks","description":"Here's my first WebVR raymarching test scene, now ported to ShaderToy's VR mode!<br\/>Standalone version here: <a href=\"http:\/\/raven.works\/projects\/raymarchFull\/\" class=\"regular\" target=\"_blank\">http:\/\/raven.works\/projects\/raymarchFull\/<\/a>","likes":2,"published":3,"flags":1,"tags":["procedural","wood","oculus","marble","rift","vr","pillars","webvr"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\n\nconst float PI =3.14159265;\nconst float PI2=6.28318531;\n\nfloat obj_ball(vec3 p, vec3 center, float radius){\n    return length(p-center)-radius;\n}\nfloat obj_box(vec3 p, vec3 center, vec3 size, float roundness){\n    vec3 d = abs(p-center)-size;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - roundness;\n}\nfloat obj_cylinder(vec3 p, vec3 center, vec2 size, float roundness){\n    vec3 tp = p-center;\n    vec2 d = abs(vec2(length(tp.xz),tp.y)) - size;\n    return min(max(d.x,d.y)+roundness,0.0) + length(max(d,0.0))-roundness;\n}\nfloat obj_planeX(vec3 p, float planeX){\n    return p.x-planeX;\n}\nfloat obj_planeY(vec3 p, float planeY){\n    return p.y-planeY;\n}\nfloat obj_planeZ(vec3 p, float planeZ){\n    return p.z-planeZ;\n}\n\nfloat obj_cylForeverZ(vec2 p, float middleY, float radius){\n    return abs(length(vec2(p.x,p.y-middleY))) - radius;\n}\n\nfloat smooth( float a, float b, float k ){\n    float h = clamp(0.5+0.5*(b-a)\/k,0.0,1.0);\n    return mix(b,a,h) - k*h*(1.0-h);\n}\n\nvoid hardAdd(inout float curD, inout int curMaterial, float newD, int newMaterial){\n    if (newD < curD) {\n        curD = newD;\n        curMaterial = newMaterial;\n    }\n}\nvoid hardSubtract(inout float curD, float newD) {\n    curD = max( -newD, curD );\n}\nvoid smoothAdd(inout float curD, float newD, float blendPower){\/\/blend colors too?\n    curD = smooth( newD, curD, blendPower );\n}\nvoid smoothSubtract(inout float curD, float newD, float blendPower){\n    curD = -smooth( newD , -curD , blendPower );\n}\n\nconst float cylMidZ = -1.5;\n\nvec3 rotMod(vec3 p, vec2 middle, float modFrac){\n    vec2 cylRel = vec2(p.x-middle.x,p.z-middle.y);\n    float cylAng = atan(cylRel.y,cylRel.x);\n    float cylDist = length(cylRel);\n    float modSlice = PI2\/modFrac;\n    float newAng = (mod((cylAng+modSlice*0.5),(modSlice)))-(modSlice*0.5);\n    return vec3(cos(newAng)*cylDist,p.y,sin(newAng)*cylDist);\n\n}\n\nfloat middleMod(float val,float modDist){\n    return mod(val+modDist*0.5,modDist)-modDist*0.5;\n}\n\nfloat room(vec3 p, out int material){\n\n\n\n\n\n\n    float distance = 9999.9;\n    material = 0;\n\n    const float pillarGapX = 2.5;\n    const float pillarGapZ = 0.5;\n\n    const float floorTileGap = 0.5;\n    const float floorTileGrout = 0.07;\n\n    const float ceilY = 9.0;\n\n    const float mirrorY = 0.5;\n\n    vec3 pillarP = vec3(mod(p.x,pillarGapX*2.0),-abs(p.y-mirrorY)+mirrorY,mod(p.z,pillarGapZ*2.0));\n\n    \/\/ ceiling flat\n    hardAdd(distance,material,\n            -obj_planeY(p ,ceilY),\n            3);\n\n    \/\/ ceiling groove\n    hardSubtract(distance,\n                 obj_cylForeverZ(vec2(middleMod(p.x,5.0),p.y),ceilY,2.3));\n\n    \/\/ base\n    hardAdd(distance,material,\n            obj_box(pillarP,vec3(pillarGapX,-1.4,pillarGapZ),vec3(0.4,0.15,0.4),0.0),\n            1);\n\n    \/\/ base blend\n    smoothAdd(distance,\n              obj_cylinder(pillarP,vec3(pillarGapX,-1.15,pillarGapZ),vec2(0.3,0.1),0.0),\n              0.11);\n\n    \/\/ floor\n    hardAdd(distance,material,\n            obj_box(vec3(mod(p.x,floorTileGap*2.0),p.y,mod(p.z,floorTileGap*2.0)),vec3(floorTileGap,-1.5-floorTileGap,floorTileGap),vec3(floorTileGap-floorTileGrout),floorTileGrout),\n            2);\n\n    \/\/column\n    hardAdd(distance,material,\n            obj_cylinder(pillarP,vec3(pillarGapX,mirrorY,pillarGapZ),vec2(0.25,2.0),0.0),\n            1);\n\n\n\n\n\n\n\n    return distance;\n\n}\n\n\n\n\n\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ) {\n    \n    \n    vec3 cameraPos = fragRayOri;\n    vec3 curCameraRayUnit = fragRayDir;\n    \n    \n    \n    \/\/scene movement\n    float fwdDist = iGlobalTime*0.2;\n    cameraPos.z -= fwdDist;\n    \n    \n    \n    \/\/ Raymarching.\n    const vec3 e=vec3(0.00007,0,0);\n    const float maxd=40.0; \/\/Max depth\n    vec3 p;\n\n    float f=0.0;\n    float d=0.01;\n    int surfaceMaterial = 0;\n    for(int i=0;i<96;i++){\n        if ((abs(d) < .001) || (f > maxd)) break;\n        f+=d;\n        p=cameraPos+curCameraRayUnit*f;\n        d = room(p,surfaceMaterial);\n    }\n\n\n    vec3 color;\n    int dummyMaterial;\n\n    if (f < maxd){\n\n        vec3 surfaceColor;\n        float specA, specP;\n        float difP = 1.0;\n        vec3 normalCheat = vec3(0.0,0.0,0.0);\/\/generally not advisable in stereo, but it's used very shallowly here\n\n        if (surfaceMaterial == 1){\n\n            vec3 marbleP = p;\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))\/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))\/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\n            surfaceColor = mix(vec3(0.0,0.8,0.5),vec3(0.70),marbleAmt);\n            specA = mix(1.0,0.8,marbleAmt);\n            specP = mix(16.0,28.0,marbleAmt);\n\n        }\n        if (surfaceMaterial == 2) {\n\n            vec3 marbleP = p;\n            vec3 intensityP = p;\n\n            float tileSize = 1.0;\n            if ( ceil(mod(p.x,tileSize*2.0)\/tileSize) == ceil(mod(p.z,tileSize*2.0)\/tileSize) ) {\n                surfaceColor = vec3(0.45,0.0,0.0);\n                marbleP.x *= -1.0;\n                intensityP.x *= -1.0;\n                marbleP.z += 1.0;\n                intensityP.z += 1.0;\n            } else {\n                surfaceColor = vec3(0.75,0.75,0.6);\n            }\n            specA = 1.0;\n            specP = 16.0;\n\n\n\n\n            marbleP.x += marbleP.z*0.5;\n            marbleP.z += marbleP.x*0.4;\n\n            marbleP.x += sin(marbleP.x*  3.8)*0.125;\n            marbleP.z += sin(marbleP.z*  3.6)*0.135;\n\n            marbleP.x += sin(marbleP.z* 20.0)*0.025;\n            marbleP.z += sin(marbleP.x* 25.0)*0.025;\n\n            marbleP.x += sin(marbleP.z* 40.0)*0.025;\n            marbleP.z += sin(marbleP.x* 45.0)*0.025;\n\n            marbleP.x += sin(marbleP.z*150.0)*0.01;\n            marbleP.z += sin(marbleP.x*160.0)*0.011;\n\n            marbleP *= 36.0;\n\n\n\n\n            intensityP.z -= 10000.0;\n\n            intensityP.x += intensityP.z*0.3;\n            intensityP.z += intensityP.x*0.1;\n\n            intensityP.x += sin(intensityP.x*1.2)*0.36;\n            intensityP.z += sin(intensityP.z*1.3)*0.21;\n\n            intensityP.x += sin(intensityP.z*2.2)*0.8;\n            intensityP.z += sin(intensityP.x*2.3)*0.9;\n\n            intensityP *= 6.0;\n\n\n            float intensityAmt = (sin(intensityP.x)*sin(intensityP.z))*0.5+0.5;\n            intensityAmt = 1.0-pow(1.0-intensityAmt,0.5);\n\n            float marbleAmt = (sin(marbleP.x)*sin(marbleP.z))*0.5+0.5;\n\n\n            float marbleGrainAmt = marbleAmt;\n            marbleGrainAmt = 1.0-((1.0-pow(marbleGrainAmt,1.5))*(1.0-intensityAmt)*1.125);\n            marbleGrainAmt = 1.0-pow(1.0-marbleGrainAmt,5.0);\n\n            surfaceColor *= marbleGrainAmt;\n            specA *= marbleGrainAmt;\n\n\n\n            float marbleGashAmt = marbleAmt;\n            marbleGashAmt *= 0.5 + 18.0*intensityAmt;\n            marbleGashAmt += pow(intensityAmt,2.5)*18.0;\n            marbleGashAmt = clamp(marbleGashAmt,0.0,1.0);\n\n            float marbleGoldAmt = pow(marbleGashAmt,1.0);\n            float marbleShadeAmt = pow(marbleGashAmt,16.0);\n\n            surfaceColor *= marbleShadeAmt;\n            specA *= marbleShadeAmt;\n\n            vec3 myNormalCheat = vec3(\n                sin( p.x*200.0 + sin(p.z*100.0)*0.5 + sin(p.z*17.0)*(5.0+sin(p.x*20.0)*4.0) )*0.000015,\n                0.0,\n                0.0\n            );\n\n            surfaceColor = mix(vec3(1.0,0.9,0.0),surfaceColor,marbleGoldAmt);\n            specP = mix(256.0,specP,marbleGoldAmt);\n            specA = mix(1.0,specA,marbleGoldAmt);\n            difP = mix(6.0,difP,marbleGoldAmt);\n            normalCheat = mix(myNormalCheat,normalCheat,marbleGoldAmt);\n\n        }\n        if (surfaceMaterial == 3){\n\n            float splinters =\n                pow(abs( ( sin(p.x*100.0)*0.5 + sin(p.y*100.0)*0.5 ) ), 0.1)\n                *\n                (sin(p.z*2.0+sin(p.x*10.0)*4.0+sin(p.x*27.0)*3.0)*0.5+0.5);\n\n            float waves = sin(\n                p.z*10.0 +\n                sin(p.z*3.0 + sin(p.x*11.0)*0.5 )*1.0 +\n                sin((p.z + sin(p.z*0.5)*5.5)*0.15 + sin(p.x*0.8)*2.0) * 14.0 +\n                pow(abs(sin((p.x*1.0 + sin(p.x*3.0)*0.5)*25.0)),0.5) * 0.5\n            );\n\n            float grain = splinters * 0.3 + waves * 0.7;\n            grain = pow(grain*0.5+0.5,0.25);\n\n            surfaceColor = mix(vec3(0.2,0.1,0.1),vec3(0.4,0.2,0.05),grain);\n            specP = mix(30.0,20.0,grain);\n            specA = grain;\n\n        }\n\n        vec3 n = vec3(d-room(p-e.xyy,dummyMaterial),\n                      d-room(p-e.yxy,dummyMaterial),\n                      d-room(p-e.yyx,dummyMaterial));\n        n += normalCheat;\n        vec3 N = normalize(n);\n\n        vec3 pointLightPos = vec3(0.0,2.0,-4.5-fwdDist);\n        vec3 L = normalize(pointLightPos-p);\n\n        float diffuse=max(dot(N,L),0.0);\n        vec3 H = normalize(L-curCameraRayUnit);\n        float specular = max(dot(H,N),0.0);\n        color = pow(diffuse,difP)*surfaceColor + pow(specular,specP)*specA;\n\n        float lightDist = (length(pointLightPos-p)) * 0.04;\n        lightDist = max(0.0,min(1.0,lightDist));\n        color *= pow(1.0-lightDist, 2.0);\n\n    } else {\n\n        color = vec3(0.0,0.0,0.0);\n\n    }\n\n\n\n    fragColor = vec4(color,1.0);\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n    \n    float vertFov = 50.0;\n    float horizFov = 2.0*atan(tan((vertFov\/180.0*PI)\/2.0)*(iResolution.x\/iResolution.y))*180.0\/PI;\n    vec4 fovAngsMono = vec4(horizFov\/2.0, horizFov\/2.0, vertFov\/2.0, vertFov\/2.0);\n    \n\n\n    \n\n\n\n    vec2 fragFrac = fragCoord.xy\/iResolution.xy;\n\n    vec2 eyeRes = iResolution.xy;\n    vec4 fovAngs = fovAngsMono;\n\n\n\/*\n    vec3 cameraRight,cameraUp,cameraFwd;\n    quatToAxes(headOrientation,cameraRight,cameraUp,cameraFwd);\n\tcameraFwd *= -1.0;\n*\/\n    float camLookY = sin(PI*0.5+iGlobalTime*-0.2)*0.5 - 0.25;\n    vec3 cameraRight = vec3(1.0,0.0,0.0);\n    vec3 cameraFwd = -vec3(0.0,sin(camLookY),cos(camLookY));\n    vec3 cameraUp = cross(cameraRight,cameraFwd);\n\n    \n\n\n\n\n    \/\/ position\n\n    vec3 cameraPos = vec3(0.0);\n\n\n\n\n    \n\n\n\n    float fovL = -fovAngs.x\/180.0*PI;\n    float fovR =  fovAngs.y\/180.0*PI;\n    float fovU = -fovAngs.z\/180.0*PI;\n    float fovD =  fovAngs.w\/180.0*PI;\n\n    float fovMiddleX = (fovR + fovL) * 0.5;\n    float fovMiddleY = (fovU + fovD) * 0.5;\n    float fovHalfX = (fovR - fovL) * 0.5;\n    float fovHalfY = (fovD - fovU) * 0.5;\n\n\n\n    float scrWorldHalfX = sin(fovHalfX)\/sin(PI*0.5 - fovHalfX);\n    float scrWorldHalfY = sin(fovHalfY)\/sin(PI*0.5 - fovHalfY);\n\n\n    \/\/ determine screen plane size from FOV values, then interpolate to find current pixel's world coord\n\n    vec2 vPos = fragFrac;\/\/0 to 1\n    vPos.x -= (-fovL\/(fovHalfX*2.0));\n    vPos.y -= (-fovU\/(fovHalfY*2.0));\n\n    vec3 screenPlaneCenter = cameraPos+cameraFwd;\n    vec3 scrCoord = screenPlaneCenter + vPos.x*cameraRight*scrWorldHalfX*2.0 + vPos.y*cameraUp*scrWorldHalfY*2.0;\n    vec3 curCameraRayUnit = normalize(scrCoord-cameraPos);\n\n\n    mainVR(fragColor,fragCoord,cameraPos,curCameraRayUnit);\n\n}","name":"","description":"","type":"image"}]}}