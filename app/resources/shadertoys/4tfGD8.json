{"Shader":{"ver":"0.1","info":{"id":"4tfGD8","date":"1421280553","viewed":849,"name":"underwater love","username":"bergi","description":"Humans tend to like watching these things in the winter sometimes.<br\/>Dedicated to Katta <img src=\"\/img\/emoticonLaugh.png\"\/>","likes":7,"published":3,"flags":0,"tags":["raymarching","fractal","kaliset","duckball","findingnemo"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/*  No there is no actual love going on,\n    except the love for numbers.\n\n    Another nice island in the absdot world\n    https:\/\/www.shadertoy.com\/view\/4tX3W8\n\t(lengthy fractal forums url ommitted for style)\n\n    Liked the feeling of the scene, so here it is (aGPL3).\n    Does the usual ray marching, while using the surface normal\n    to shade the pixels regardless of a hit or not.\n    Together with the right fog this makes all the \n    low precission almost realtime rendering glitches\n    fit the holiday atmosphere perfectly well.\n\n    Path generation is the tricky part here.\n    Anyone? \n\n    bergi \n*\/\n\n\/\/ PATH 1 and 2 are two short predefined paths \n\/\/ they are near to a spot where i really would like to take my girlfriend once..\n\/\/ 3 is 'through the whole thing' - unchecked and unbounded\n\/\/ and noise and artefacts and all but some really cool parts in between\n\/\/ trust me! already at 8458 seconds ;)\n\/\/ it's helpful to reduce NUM_ITER then because many parts are impossible to\n\/\/ raytrace adequately for higher iterations\n\/\/ especially these blue dots are quite frequent at places (just had them at ~8730)\n\/\/ they appear more frequent with higher iterations and make a good star texture otherwise \n\/\/ but here they are impossible objects with very high distance although just next to the camera..\n\/\/ amazing..\n#define PATH 1\t\t\t\t\/\/ 1-3\n#define NUM_ITER 32\t\t\t\/\/ very depended value\n#define NORM_EPS 0.002\t\n#define NUM_TRACE 50\n#define PRECISSION 0.2\n#define FOG_DIST 0.1\n\/\/ 3 coordinates to navigate through the sets\n\/\/ be careful! this is probably where arthur dent lost fenchurch.\n#define MAGIC_PARAM vec3(-.5, -.4, -1.5)\n\n\/\/ shader-local global animation time\n#define sec (iGlobalTime \/ 10.)\n\n\/\/ kali set\n\/\/ position range depending on parameters\n\/\/ but usually at least +\/- 0.01 to 2.0 or even (even much) larger\n\/\/ check the camera path's in main(), it's tiny!\nfloat duckball_s(in vec3 p) \n{\n\tfloat mag;\n\tfor (int i = 0; i < NUM_ITER; ++i) \n\t{\n\t\tmag = dot(p, p);\n\t\tp = abs(p) \/ mag + MAGIC_PARAM;\n\t}\n\treturn mag;\n}\n\n\n\/\/ ---- canonical shader magic ----\n\n\/\/ well, what is the set?\n\/\/ divide inside from outside\nfloat scene_d(in vec3 p)\n{\n\t\/\/ numbers might look a bit off\n\t\/\/ but work for the renderer below\n\treturn duckball_s(p)*0.01-0.004;\n}\n\nvec3 scene_n(in vec3 p)\n{\n\tconst vec3 e = vec3(NORM_EPS, 0., 0.);\n\treturn normalize(vec3(\n\t\t\tscene_d(p + e.xyy) - scene_d(p - e.xyy),\n\t\t\tscene_d(p + e.yxy) - scene_d(p - e.yxy),\n\t\t\tscene_d(p + e.yyx) - scene_d(p - e.yyx) ));\n}\n\nvec3 scene_color(in vec3 p)\n{\n\tvec3 ambcol = vec3(0.9,0.5,0.1);\n    \t\/\/ lighting\n\tfloat dull = max(0., dot(vec3(1.), scene_n(p)));\n\treturn ambcol * (0.3+0.7*dull);\n}\n\nvec3 sky_color(in vec3 dir)\n{\n\tvec3 c1 = vec3(0.3,0.4,0.7),\n\t\t c2 = vec3(0.2,0.6,0.9),\n\t\t c3 = vec3(0.0,0.3,0.5);\n    \t\/\/ some fade across y [-1,1]\n\treturn mix(mix(c1, c2, smoothstep(-1., .5, dir.y)),\n\t\t\t\tc3, smoothstep(.5, .1, dir.y));\n}\n\nvec3 traceRay(in vec3 pos, in vec3 dir)\n{\n\tvec3 p;\n\tfloat t = 0.;\n\tfor (int i=0; i<NUM_TRACE; ++i)\n\t{\n\t\tp = pos + t * dir;\n\t\tfloat d = scene_d(p);\n\n#if PATH == 3\n        \/\/ increase distance for too close surfaces\n        d += 0.01*(1. - smoothstep(0.01, 0.011, t));\n#endif\n\n\t\/\/\tif (d < 0.001)\n\t\/\/\t\tbreak;\n\n\t\tt += d * PRECISSION;\n\t}\n\t\n\treturn mix(scene_color(p), sky_color(dir), t\/FOG_DIST);\n}\n\n\n\n\n\/\/ ---------- helper --------\n\n\/\/ cubic interpolation from a to b using the respective derivatives ad and bd\nvec3 spline_d(float t, in vec3 a, in vec3 ad, in vec3 b, in vec3 bd)\n{\n    float tq2 = t * t,\n          tq3 = tq2 * t,\n          tr1 = 2. * tq3 - 3. * tq2 + 1.,\n          tr2 = tq3 - 2.*tq2 + t;\n    return tr1 * a + tr2 * ad + (tq3-tq2) * bd + (1. - tr1) * b;\n}\n\n\/\/ attempt to smoothly connect 4 points\nvec3 spline(float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    return spline_d(t, a, normalize(c-a), d, normalize(d-b));\n}\n\nvec2 rotate(in vec2 v, float r)\n{\n\tfloat s = sin(r), c = cos(r);\n    \treturn vec2(v.x * c - v.y * s, v.x * s + v.y * c);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy \/ iResolution.xy * 2. - 1.;\n    \tuv.x *= float(iResolution.x) \/ float(iResolution.y);\n    \n\t\/\/ ray direction (cheap sphere section)\n\tvec3 dir = normalize(vec3(uv, 1.5));\n\n\t\/\/ position & look-at\n#if PATH == 1\n\tvec3 pos = vec3(\n\t\t\t2.48   + 0.01*cos(sec*2.),\n        \t-0.56  + 0.07*sin(sec-.05),\/\/ + 0.02*sin(sec*2.+2.),\n        \t-1.5   + 0.1*sin(sec)\n    \t\t);\n    \n\tdir.xz = rotate(dir.xz, sec * 0.3);\n\tdir.xy = rotate(dir.xy, 1.);\n    \n#elif PATH == 2\n    \/\/ 4 predefined points\n    vec3 p_0 = vec3(2.47  , -0.56, -1.62);\n    vec3 p_1 = vec3(2.474 , -0.56, -1.6);\n    vec3 p_2 = vec3(2.49 ,  -0.55, -1.5);\n    vec3 p_3 = vec3(2.473 , -0.51, -1.38);\n\n    float t = .5 + .5 * sin(sec);\n    vec3 pos = spline(t, p_0, p_1, p_2, p_3);\n\n    dir.xy = rotate(dir.xy, sec);\n    dir.xz = rotate(dir.xz, sec*0.7);\n\n#else PATH == 3\n\n    vec3 pos = vec3(1., 1. + sin(sec\/21.), sin(sec\/20.));\n    dir.xy = rotate(dir.xy, sec*0.7 + sin(sec*0.41));\n    dir.xz = rotate(dir.xz, sec*0.6);\n\n#endif\n    \n    \t\/\/ run\n\tvec3 col = traceRay(pos, dir);\n  \n   \tfragColor = vec4(traceRay(pos, dir),1.0);\n}","name":"","description":"","type":"image"}]}}