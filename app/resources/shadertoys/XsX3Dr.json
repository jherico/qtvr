{"Shader":{"ver":"0.1","info":{"id":"XsX3Dr","date":"1366977990","viewed":3395,"name":"Palindrome","username":"P_Malin","description":"My attempt at a demo like sequence in a shader.<br\/>The code is a bit messy. I was just having fun.<br\/>The framerate is low. I may try to optimize some bits and pieces.","likes":49,"published":3,"flags":0,"tags":["demo","shader"],"hasliked":0},"renderpass":[{"inputs":[{"id":15,"src":"\/presets\/tex10.png","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":21,"src":"\/presets\/mzk04.mp3","ctype":"music","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"id":26,"src":"\/presets\/cube04_0.png","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define kRaymarchMaxIter 96\r\n\r\n\/\/#define LOW_QUALITY\r\n\r\n\/\/#define OVERRIDE_TIME\r\n\r\nconst vec3 cSkyColourTop = vec3(0.2, 0.05, 0.15) * 0.5;\r\nconst vec3 cSkyColourHorizon = vec3(0.4, 0.1, 0.01) * 2.0;\r\nconst vec3 cSunScatteringColour = vec3(1.0, 0.01, 0.005) * 1.0;\r\n\r\nconst vec3 cFogColour = vec3(0.4, 0.05, 0.01) * 2.0;\r\n\r\nconst vec3 cSunColour = vec3(1.0, 0.01, 0.005) * 5.0;\r\nvec3 vSunDirection = normalize(vec3(-0.3, 0.2, -0.7));\r\n\r\nconst vec3 cSunLightColour = vec3(1.0, 0.15, 0.025) * 1.0;\r\nconst vec3 cAmbientLight = vec3(0.4, 0.1, 0.01) * 0.2;\r\n\r\nconst vec3 vPortalPos = vec3(0.0, 2.7, 20.0);\r\n\r\nconst float fSequenceLength = 18.0;\r\n\r\nmat3 g_mPortalRotation;\r\nfloat g_fTime = 0.0;\r\nfloat g_fSceneTime = 0.0;\r\nfloat g_ReverseEffectEnabled= 0.0;\r\n\r\nstruct C_Ray\r\n{\r\n    vec3 vOrigin;\r\n    vec3 vDir;\r\n    float fStartDistance;\r\n    float fLength;\r\n};\r\n\r\nstruct C_HitInfo\r\n{\r\n    vec3 vPos;\r\n    float fDistance;\r\n    float fObjectId;\r\n};\r\n    \r\nstruct C_Surface\r\n{\r\n    vec3 vNormal; \r\n};\r\n\r\nstruct C_Material\r\n{\r\n    vec3 cAlbedo;\r\n};\r\n\t\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\/\/ Distance Field CSG\r\n\/\/ These carry with them the material parameters in y\r\n\r\nvec2 DistCombineUnion( const in vec2 v1, const in vec2 v2 )\r\n{\r\n    \/\/if(v1.x < v2.x) return v1; else return v2;\r\n    return mix(v1, v2, step(v2.x, v1.x));\r\n}\r\n\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\/\/ Scene Description \r\n\r\nfloat GetRayFirstStep( const in C_Ray ray )\r\n{\r\n\treturn ray.fStartDistance;\r\n}\r\n\r\nfloat hash( const in float n ) {\r\n\treturn fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat smoothnoise(const in float o) \r\n{\r\n\tfloat p = floor(o);\r\n\tfloat f = fract(o);\r\n\t\t\r\n\tfloat n = p;\r\n\r\n\tfloat a = hash(n+  0.0);\r\n\tfloat b = hash(n+  1.0);\r\n\t\r\n\tfloat f2 = f * f;\r\n\tfloat f3 = f2 * f;\r\n\t\r\n\tfloat t = 3.0 * f2 - 2.0 * f3;\r\n\t\r\n\treturn mix(a, b, t);\r\n}\r\n\r\nfloat smoothnoise(in vec2 o) \r\n{\r\n\tvec2 p = floor(o);\r\n\tvec2 f = fract(o);\r\n\t\t\r\n\tfloat n = p.x + p.y*57.0;\r\n\r\n\tfloat a = hash(n+  0.0);\r\n\tfloat b = hash(n+  1.0);\r\n\tfloat c = hash(n+ 57.0);\r\n\tfloat d = hash(n+ 58.0);\r\n\t\r\n\tvec2 f2 = f * f;\r\n\tvec2 f3 = f2 * f;\r\n\t\r\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\r\n\tvec2 dt = 6.0 * f - 6.0 * f2;\r\n\t\r\n\tfloat u = t.x;\r\n\tfloat du = dt.x;\t\r\n\tfloat v = t.y;\r\n\tfloat dv = dt.y;\t\r\n\r\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\r\n\t\r\n\t\/\/float dx = (b-a)*du + (a-b+d-c)*du*v;\r\n\t\/\/float dy = (c-a)*dv + (a-b+d-c)*u*dv;\r\n\t\r\n\treturn res;\r\n}\r\n\r\nfloat smoothnoise(const in vec3 o) \r\n{\r\n\tvec3 p = floor(o);\r\n\tvec3 fr = fract(o);\r\n\t\t\r\n\tfloat n = p.x + p.y*101.0 + p.z * 4001.0;\r\n\r\n\tfloat a = hash(n+   0.0);\r\n\tfloat b = hash(n+   1.0);\r\n\tfloat c = hash(n+ 101.0);\r\n\tfloat d = hash(n+ 102.0);\r\n\tfloat e = hash(n+4001.0);\r\n\tfloat f = hash(n+4002.0);\r\n\tfloat g = hash(n+4102.0);\r\n\tfloat h = hash(n+4103.0);\r\n\t\r\n\tvec3 fr2 = fr * fr;\r\n\tvec3 fr3 = fr2 * fr;\r\n\t\r\n\tvec3 t = 3.0 * fr2 - 2.0 * fr3;\r\n\t\t\r\n\treturn mix(\r\n\t\t\t    mix( mix(a,b, t.x),\r\n\t\t             mix(c,d, t.x), t.y),\r\n\t\t\t    mix( mix(e,f, t.x),\r\n\t\t             mix(g,h, t.x), t.y),\r\n\t\t\tt.z);\r\n}\r\n\r\nfloat GetDistanceGround( const in vec3 vPos )\r\n{\r\n\tfloat fResult = vPos.y;\r\n\t\r\n\tfloat h = smoothnoise(vPos.xz * 0.1);\t\t\r\n\tfloat fRidgePos = vPos.x + h * 10.0;\r\n\t\r\n\tfloat s = sin(fRidgePos);\r\n\ts *= sin(vPos.z * 0.1 + vPos.x * 0.2);\r\n\ts = s * 0.5 + 0.5;\t\r\n\ts = sqrt(s);\r\n\t\r\n\tvec2 vFlattenPos = abs(vPos.xz);\r\n\tfloat fFlattenDist = max(vFlattenPos.x, vFlattenPos.y);\r\n\tfloat fFlatten = smoothstep(50.0, 65.0, fFlattenDist);\r\n\tfResult += mix(0.0, s, fFlatten);\r\n\r\n\t#ifndef LOW_QUALITY\r\n\tfloat s2= sin(fRidgePos * 40.0);\r\n\ts2 = s2 * 0.5 + 0.5;\t\r\n\tfResult += s2 * s * 0.01;\r\n\t#endif\r\n\r\n\treturn fResult;\r\n}\r\n\r\nvec2 GetDistancePyramid(const in vec3 vPos, const in float fWorldNoise)\r\n{\r\n\tvec2 vResult;\r\n\tvResult.y = 2.0; \/\/ object id\r\n\r\n\tfloat fPyramidSize = 50.0;\r\n\t\r\n\tvec3 vStepPos = vPos;\r\n\tvStepPos.y -= fPyramidSize;\r\n\tvStepPos.xz = abs(vStepPos.xz) - 0.5;\r\n\tvec2 vStepOffset = floor((vStepPos.y - vStepPos.xz) * 0.5 + 0.5);\r\n\tfloat fStepOffset = min(vStepOffset.x, vStepOffset.y);\r\n\t\r\n\tvStepPos.x += fStepOffset;\t\r\n\tvStepPos.y -= fStepOffset;\r\n\tvStepPos.z += fStepOffset;\r\n\r\n\tvec3 vClosest = min(vStepPos.xyz, vec3(0.0));\t\r\n\t\r\n\tvResult.x = length(vStepPos - vClosest);\t\r\n\t\r\n\tfloat fFlatSide = (vPos.y + max(abs(vPos.x), abs(vPos.z))) - 50.0;\r\n\tvResult.x = mix(vResult.x, fFlatSide, 0.3);\r\n\t\t\r\n\tconst float fTunnelHeight = 4.0;\r\n\tconst float fTunnelWidth = 1.0;\r\n\tfloat fTunnelInner = min(min(fTunnelWidth - abs(vPos.x), fTunnelHeight - vPos.y), 35.0-vPos.z);\r\n\r\n\tconst float fTunnelThickness = 1.5;\r\n\tconst float fTunnelExtent = 2.0;\r\n\tfloat fTunnelOuter = max(abs(vPos.x) - (fTunnelWidth + fTunnelThickness), vPos.y - (fTunnelHeight + fTunnelThickness));\r\n\tfTunnelOuter = max(fTunnelOuter, vPos.y + abs(vPos.z + fTunnelExtent) - (fPyramidSize));\r\n\t\r\n\tvResult.x = min(vResult.x, fTunnelOuter);\r\n\tvResult.x = max(vResult.x, fTunnelInner);\r\n\t\r\n\tfloat fRoomWallDist = (vPos.y + max(abs(vPos.x), abs(vPos.z - 20.0)));\r\n\tfloat fInnerRoom = 20.0 - fRoomWallDist;\r\n\tvResult.x = max(vResult.x, fInnerRoom);\r\n\t\r\n\tvResult.x -= 0.1 - clamp(fWorldNoise, 0.0, 1.0) * 0.1;\t\r\n\t\r\n\treturn vResult;\r\n}\r\n\r\nvec2 GetDistancePyramids( const in vec3 vPos )\r\n{\r\n\t#ifdef LOW_QUALITY\r\n\tfloat fWorldNoise = 0.0;\r\n\t#else\r\n\tfloat fWorldNoise = smoothnoise(vPos * 2.0);\r\n\t#endif\r\n\t\t\r\n\tfloat fHeight = 0.0;\r\n\tvec3 vPyramidPos = vPos;\r\n\tif(vPyramidPos.x > 50.0)\r\n\t{\r\n\t\tvPyramidPos.x -= 100.0;\r\n\t\tvPyramidPos.z += 100.0;\r\n\t\tfHeight = 10.0;\r\n\t}\r\n\r\n\tif(vPyramidPos.x < -70.0)\r\n\t{\r\n\t\tvPyramidPos.x += 100.0;\r\n\t\tvPyramidPos.z += 200.0;\r\n\t\tfHeight = 20.0;\r\n\t}\r\n\t\r\n\tvPyramidPos.y = max(vPyramidPos.y + fHeight, fHeight);\r\n\t\r\n\tvec2 vPyramidDistance = GetDistancePyramid( vPyramidPos, fWorldNoise );\t\r\n\t\r\n\treturn vPyramidDistance;\r\n}\r\n\r\n\/\/ result is x=scene distance y=material or object id; zw are material specific parameters (maybe uv co-ordinates)\r\nvec2 GetDistanceScene( const in vec3 vPos, const in float fShadow )\r\n{          \r\n    vec2 vResult = vec2(10000.0, -1.0);\r\n    \r\n\tfloat fScale = 1.0;\r\n\tvec3 vPyramidPos = vPos;\r\n\tvec3 vSmallPyramidPos = vPyramidPos - vec3(0.0, 0.0, 20.0);\r\n\tvec3 vAbsPos = abs(vSmallPyramidPos);\t\r\n\tif( max(vAbsPos.x, vAbsPos.z) + vSmallPyramidPos.y < 15.0 )\r\n\t{\r\n\t\tvSmallPyramidPos.y -= 0.5;\r\n\t\tfScale = 30.0;\r\n\t\tvPyramidPos = vSmallPyramidPos * fScale;\r\n\t}\t\r\n\t\r\n\tvec2 vPyramidDistance = GetDistancePyramids( vPyramidPos );\t\r\n\tvPyramidDistance.x \/= fScale;\r\n\t\r\n\tfloat fRoomWallDist = (vPos.y + max(abs(vPos.x), abs(vPos.z - 17.0)));\r\n\tfloat fPedistalDist = max(fRoomWallDist - 7.0, vPos.y - 0.5);\r\n\tvPyramidDistance.x = min(vPyramidDistance.x, fPedistalDist);\r\n\t\r\n\tvec2 vFloorDistance = vec2(GetDistanceGround( vPos ), 1.0);\r\n\tvResult = vFloorDistance;\r\n\r\n\tvResult = DistCombineUnion(vResult, vPyramidDistance);\r\n\t\r\n\tif(fShadow > 0.5)\r\n\t{\r\n\t\tvec2 vPortalDistance = vec2( (length(vPos - vPortalPos) - 0.1), 3.0);\r\n\t\tvResult = DistCombineUnion(vResult, vPortalDistance);\r\n\t}\r\n\t\r\n    return vResult;\r\n}\r\n\r\nC_Material GetObjectMaterial( const in C_HitInfo hitInfo )\r\n{\r\n    C_Material mat;  \r\n        \r\n\tmat.cAlbedo = vec3(0.8, 0.5, 0.3);\r\n\t\r\n\tif(hitInfo.fObjectId > 1.0)\r\n\t{\r\n    \tmat.cAlbedo = vec3(1.0, 0.8, 0.5);\r\n\t}\r\n\telse if(hitInfo.fObjectId > 2.0)\r\n\t{\r\n\t\tmat.cAlbedo = vec3(1.0, 1.0, 1.0);\r\n\t}\r\n\r\n    return mat;\r\n}\r\n\r\nvec3 GetSkyColour( const in vec3 vDir )\r\n{\r\n\r\n    float fBlend = clamp(vDir.y, 0.0, 1.0);\r\n\tfBlend = 1.0 - fBlend;\r\n\t\r\n\t\r\n    vec3 vResult =  mix(cSkyColourHorizon, cSkyColourTop, 1.0 - fBlend * fBlend * fBlend);\r\n\t\t\r\n\tfloat fSunDot = max(dot(vDir, vSunDirection), 0.0);\r\n\tvResult += (pow(fSunDot, 500.0) + fSunDot * fSunDot) * cSunScatteringColour;\r\n\t\r\n\tfloat fSun = clamp(5000.0 * (fSunDot - 0.999), 0.0, 1.0);\t\r\n\tvResult = vResult + cSunColour * fSun;\r\n\t\r\n\treturn vResult;\r\n}\r\n\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\/\/ Raymarching \r\n\r\nvec3 GetSceneNormal( const in vec3 vPos )\r\n{\r\n    \/\/ tetrahedron normal\r\n    const float fDelta = 0.025;\r\n\r\n    vec3 vOffset1 = vec3( fDelta, -fDelta, -fDelta);\r\n    vec3 vOffset2 = vec3(-fDelta, -fDelta,  fDelta);\r\n    vec3 vOffset3 = vec3(-fDelta,  fDelta, -fDelta);\r\n    vec3 vOffset4 = vec3( fDelta,  fDelta,  fDelta);\r\n\r\n    float f1 = GetDistanceScene( vPos + vOffset1, 1.0 ).x;\r\n    float f2 = GetDistanceScene( vPos + vOffset2, 1.0 ).x;\r\n    float f3 = GetDistanceScene( vPos + vOffset3, 1.0 ).x;\r\n    float f4 = GetDistanceScene( vPos + vOffset4, 1.0 ).x;\r\n\r\n    vec3 vNormal = vOffset1 * f1 + vOffset2 * f2 + vOffset3 * f3 + vOffset4 * f4;\r\n\r\n    return normalize( vNormal );\r\n}\r\n\r\n#define kRaymarchEpsilon 0.001\r\n\r\n\/\/ This is an excellent resource on ray marching -> http:\/\/www.iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\r\nvoid Raymarch( const in C_Ray ray, out C_HitInfo result, const int maxIter, const in float fShadow )\r\n{        \r\n    result.fDistance = GetRayFirstStep( ray );\r\n    result.fObjectId = 0.0;\r\n        \r\n    for(int i=0;i<=kRaymarchMaxIter;i++)              \r\n    {\r\n        result.vPos = ray.vOrigin + ray.vDir * result.fDistance;\r\n        vec2 vSceneDist = GetDistanceScene( result.vPos, fShadow );\r\n        result.fObjectId = vSceneDist.y;\r\n        \r\n        \/\/ abs allows backward stepping - should only be necessary for non uniform distance functions\r\n        if((abs(vSceneDist.x) <= kRaymarchEpsilon) || (result.fDistance >= ray.fLength) || (i > maxIter))\r\n        {\r\n            break;\r\n        }                        \r\n\r\n        result.fDistance = result.fDistance + vSceneDist.x; \r\n    }\r\n\r\n\r\n    if(result.fDistance >= ray.fLength)\r\n    {\r\n        result.fDistance = 1000.0;\r\n        result.vPos = ray.vOrigin + ray.vDir * result.fDistance;\r\n        result.fObjectId = 0.0;\r\n    }\r\n}\r\n\r\nfloat calcAO( in vec3 pos, in vec3 nor )\r\n{\r\n\tfloat totao = 0.0;\r\n    float sca = 1.0;\r\n    for( int aoi=0; aoi<8; aoi++ )\r\n    {\r\n        float hr = 0.01 + 1.2*pow(float(aoi)\/8.0,1.5);\r\n        vec3 aopos =  nor * hr + pos;\r\n        float dd = GetDistanceScene( aopos, 0.0 ).x;\r\n        totao += -(dd-hr)*sca;\r\n        sca *= 0.85;\r\n    }\r\n    return clamp( 1.0 - 1.0*totao, 0.0, 1.0 );\r\n}\r\n\r\nvec3 ShadeSurface(const in C_Ray ray, const in C_HitInfo hitInfo, const in C_Surface surface, const in C_Material material, float fInsideDist)\r\n{\r\n    vec3 cScene;\r\n    \r\n    vec3 vAmbientLight;\r\n\t\t\t\r\n\tvec3 vDiffuseLight = vec3(0.0);\r\n\r\n\tvec3 vToLight;\r\n\tvec3 cLightColour;\r\n\t\r\n\tfloat fPortalOn = smoothstep(9.0, 9.5, g_fTime);\r\n\t\r\n\tif(fInsideDist > 0.0)\r\n\t{\r\n\t\tvToLight = vSunDirection * 100.0;\r\n\t\tcLightColour = cSunLightColour;\r\n\t\tvAmbientLight = cAmbientLight;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tvec3 vLightPos;\t\t\r\n\t\t\r\n\t\t\/\/ apply point light\r\n\t\t{\r\n\t\t\t\r\n\t\t\tif((hitInfo.vPos.z - hitInfo.vPos.y) < 0.01)\r\n\t\t\t{\r\n\t\t\t\tfloat fLightId = floor(min(max(hitInfo.vPos.z, -50.0), 0.0) * 0.1 + 0.5);\r\n\t\t\t\tvLightPos = vec3(0.5 * sign(hitInfo.vPos.x), 2.5, 10.0 * fLightId - 0.5);\t\t\r\n\t\t\t\t\r\n\t\t\t\tfloat fFlicker = (smoothnoise(fLightId + iGlobalTime * 500.0) * 0.5 + 0.5);\r\n\t\t\t\tcLightColour = vec3(1.0, 0.5, 0.1) * fFlicker * 0.01;\r\n\t\t\t\tvAmbientLight = cAmbientLight * 0.01;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tvLightPos = vPortalPos;\r\n\t\t\t\tvec3 vToLight = vLightPos - hitInfo.vPos;\r\n\t\t\t\t\r\n\t\t\t\tcLightColour = textureCube(iChannel0, vToLight * g_mPortalRotation).rgb;\r\n\t\t\t\tcLightColour = cLightColour * cLightColour * 10.0 * vec3(0.0, 1.0, 0.0);\r\n\r\n\t\t\t\tfloat fFft = smoothstep(0.7, 0.9, texture2D(iChannel3, vec2(0.018, 0.0)).r);\r\n\t\t\t\tfFft = fFft * fFft;\r\n\t\t\t\tcLightColour = vec3(1.0, 0.2, 0.1) * fFft + cLightColour * fPortalOn;\r\n\t\t\t\tvAmbientLight = vec3(1.0, 0.2, 0.1) * 0.001;\t\t\t\t\t\t\t\t\r\n\t\t\t}\t\t\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tvToLight = vLightPos - hitInfo.vPos;\r\n\t\tfloat fDist2 = dot(vToLight, vToLight);\r\n\t\tcLightColour \/= fDist2;\r\n\t}\r\n\r\n\tC_Ray shadowRay;\r\n\tshadowRay.vOrigin = hitInfo.vPos;\r\n\tshadowRay.fLength = length(vToLight);\r\n\tshadowRay.vDir = normalize(vToLight);\r\n\tshadowRay.fStartDistance = dot(shadowRay.vDir, surface.vNormal);\r\n\tC_HitInfo shadowHitInfo;\r\n\tRaymarch(shadowRay, shadowHitInfo, 64, 0.0);\r\n\t\r\n\tfloat fShadow = 1.0;\r\n\tif(shadowHitInfo.fDistance < 90.0)\r\n\t{\r\n\t\tfShadow = 0.0;\r\n\t}\r\n\t\r\n\tvec3 vLightDir = normalize(vToLight);\r\n\tfloat fDiffuseLight = clamp(dot(surface.vNormal, vLightDir), 0.0, 1.0) * fShadow;\r\n\t\r\n\tvDiffuseLight += fDiffuseLight * cLightColour;\r\n\t\r\n\tfloat fAmbientOcclusion = calcAO(hitInfo.vPos, surface.vNormal);\r\n\t\r\n    vDiffuseLight += vAmbientLight * fAmbientOcclusion;\r\n              \r\n    vec3 vDiffuseReflection = vDiffuseLight * material.cAlbedo;              \r\n\r\n    cScene = vDiffuseReflection;\r\n    \r\n    return cScene;\r\n}\r\n\r\nvec3 GetSceneColour( const in C_Ray ray )\r\n{                                                          \r\n    C_HitInfo intersection;\r\n    Raymarch(ray, intersection, 256, 1.0);\r\n                \r\n    vec3 cScene;\r\n\r\n    if(intersection.fObjectId < 0.5)\r\n    {\r\n\t\tcScene = GetSkyColour(ray.vDir);\r\n    }\r\n    else\r\n    {\r\n        C_Surface surface;\r\n        \r\n        surface.vNormal = GetSceneNormal(intersection.vPos);\r\n\r\n\t\tif(intersection.fObjectId > 2.5)\r\n\t\t{\r\n\t\t\t\/\/ flip portal light source surface\r\n\t\t\tsurface.vNormal = -surface.vNormal;\r\n\t\t}\r\n\r\n        C_Material material = GetObjectMaterial(intersection);\r\n\r\n\t\tvec3 vAbsPos = abs(intersection.vPos);\r\n\t\tfloat fInsideDist = (max(vAbsPos.x, vAbsPos.z) + vAbsPos.y) - 46.0;\r\n\r\n        \/\/ apply lighting\r\n        cScene = ShadeSurface(ray, intersection, surface, material, fInsideDist);\t\t\t\t\t\r\n\t\t\r\n\t\tif( fInsideDist > 0.0 )\r\n\t\t{\r\n\t\t\t\/\/ apply fog\t\r\n\t\t\tfloat fNoise = smoothnoise((intersection.vPos.xz) * 0.1 + g_fSceneTime * 10.0);\r\n\t\t\tfloat fDensity= 0.04;\r\n\t\t\tfloat fHeightFalloff = 0.5;\r\n\t\t\t\r\n\t\t\tfloat fogAmount = fDensity * exp(-ray.vOrigin.y*fHeightFalloff) * (1.0-exp(-intersection.fDistance*ray.vDir.y*fHeightFalloff ))\/ray.vDir.y;\r\n\t\t\tfogAmount *= (0.5 + fNoise * 0.5);\r\n\t\t\tcScene = mix(cScene, cFogColour, fogAmount);\r\n\t\t}\r\n    }\r\n\t\r\n    return cScene;\r\n}\r\n\r\nfloat kFarClip = 1000.0;\r\n\r\nvoid GetCameraRay( const in vec3 vPos, const in vec3 vForwards, const in vec3 vWorldUp, in vec2 fragCoord, out C_Ray ray)\r\n{\r\n    vec2 vUV = ( fragCoord.xy \/ iResolution.xy );\r\n    vec2 vViewCoord = vUV * 2.0 - 1.0;\r\n\t\r\n    float fRatio = iResolution.x \/ iResolution.y;\r\n    vViewCoord.y \/= fRatio;                          \r\n\r\n\tvViewCoord *= 0.75;\r\n\t\r\n    ray.vOrigin = vPos;\r\n\t\r\n    vec3 vRight = normalize(cross(vForwards, vWorldUp));\r\n    vec3 vUp = cross(vRight, vForwards);\r\n        \r\n    ray.vDir = normalize( vRight * vViewCoord.x + vUp * vViewCoord.y + vForwards); \r\n    ray.fStartDistance = 0.0;\r\n    ray.fLength = kFarClip;      \r\n}\r\n\r\nvoid GetCameraRayLookat( const in vec3 vPos, const in vec3 vInterest, in vec2 fragCoord, out C_Ray ray)\r\n{\r\n    vec3 vForwards = normalize(vInterest - vPos);\r\n    vec3 vUp = vec3(0.0, 1.0, 0.0);\r\n\r\n    GetCameraRay(vPos, vForwards, vUp, fragCoord, ray);\t\r\n}\r\n\r\n\r\nvoid GetCameraPosAndTarget( float fCameraIndex, out vec3 vCameraPos, out vec3 vCameraTarget )\r\n{\r\n\tfloat fCameraCount = 14.0;\r\n\tfloat fCameraIndexModCount = max(min(fCameraIndex, fCameraCount), 0.0);\r\n\r\n\tif(fCameraIndexModCount < 0.5)\r\n\t{\r\n\t\tvCameraPos = vec3(2000.0, 3.0, 500.0);\r\n\t\tvCameraTarget = vCameraPos + vec3(-10.0, -3.0, -10.0);\r\n\t}\r\n\telse if(fCameraIndexModCount < 1.5)\r\n\t{\r\n\t\tvCameraPos = vec3(2000.0, 4.0, 500.0);\r\n\t\tvCameraTarget = vCameraPos + vec3(-10.0, -3.0, -10.0);\r\n\t}\r\n\telse if(fCameraIndexModCount < 2.5)\r\n\t{\r\n\t\tvCameraPos = vec3(2000.0, 3.0, 500.0);\r\n\t\tvCameraTarget = vCameraPos + vec3(15.0, -4.0, -10.0);\r\n\t}\r\n\telse if(fCameraIndexModCount < 3.5)\r\n\t{\r\n\t\tvCameraPos = vec3(2000.0, 20.0, 500.0);\r\n\t\tvCameraTarget = vCameraPos + vec3(15.0, -8.0, -10.0);\r\n\t}\r\n\telse if(fCameraIndexModCount < 4.5)\r\n\t{\r\n\t\tvCameraPos = vec3(500.0, 20.0, 500.0);\r\n\t\tvCameraTarget = vCameraPos + vec3(15.0, -3.0, -10.0);\r\n\t}\r\n\telse if(fCameraIndexModCount < 5.5)\r\n\t{\r\n\t\tvCameraPos = vec3(500.0, 3.0, 500.0) + vec3(100.0, 0.0, 0.0);\r\n\t\tvCameraTarget = vCameraPos + vec3(10.0, -3.0, -10.0);\r\n\t}\r\n\telse if(fCameraIndexModCount < 6.5)\r\n\t{\r\n\t\tvCameraPos = vec3(500.0, 5.0, 500.0) + vec3(100.0, 0.0, 0.0);\r\n\t\tvCameraTarget = vec3(0.0, 10.0, 0.0);\r\n\t}\r\n\telse if(fCameraIndexModCount < 7.5)\r\n\t{\r\n\t\tvCameraPos = vec3(-30.0, 20.0, -200.0);\r\n\t\tvCameraTarget = vec3(0.0, 10.0, 0.0);\r\n\t}\r\n\telse if(fCameraIndexModCount < 8.5)\r\n\t{\r\n\t\tvCameraPos = vec3(0.0, 5.0, -100.0);\r\n\t\tvCameraTarget = vec3(0.0, 0.0, 0.0);\r\n\t}\r\n\telse if(fCameraIndexModCount < 9.5)\r\n\t{\r\n\t\tvCameraPos = vec3(0.0, 1.0, 5.0);\r\n\t\tvCameraTarget = vec3(0.0, 1.0, 20.0);\r\n\t}\r\n\telse if(fCameraIndexModCount < 10.5)\r\n\t{\r\n\t\tvCameraPos = vec3(0.0, 2.0, 5.0);\r\n\t\tvCameraTarget = vec3(0.0, 1.0, 20.0);\r\n\t}\r\n\telse if(fCameraIndexModCount < 11.5)\r\n\t{\r\n\t\tvCameraPos = vec3(10.0, 5.0, 30.0);\r\n\t\tvCameraTarget = vec3(0.0, 1.0, 20.0);\r\n\t}\r\n\telse if(fCameraIndexModCount < 12.5)\r\n\t{\r\n\t\tvCameraPos = vec3(10.0, 6.0, 30.0);\r\n\t\tvCameraTarget = vec3(0.0, 1.0, 20.0);\r\n\t}\r\n\telse if(fCameraIndexModCount < 13.5)\r\n\t{\r\n\t\tvCameraPos = vec3(0.0, 6.0, 20.0);\r\n\t\tvCameraTarget = vec3(0.0, -1.0, 19.0);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tvCameraPos = vec3(0.0, 2.0, 20.0);\r\n\t\tvCameraTarget = vec3(0.0, -10.0, 19.0);\r\n\t}\r\n}\r\n\r\nvec3 BSpline( const in vec3 a, const in vec3 b, const in vec3 c, const in vec3 d, const in float t)\r\n{\r\n\tconst mat4 mSplineBasis = mat4( -1.0,  3.0, -3.0, 1.0,\r\n\t\t\t\t\t\t\t         3.0, -6.0,  0.0, 4.0,\r\n\t\t\t\t\t\t\t        -3.0,  3.0,  3.0, 1.0,\r\n\t\t\t\t\t\t\t         1.0,  0.0,  0.0, 0.0) \/ 6.0;\t\r\n\t\r\n\tfloat t2 = t * t;\r\n\tvec4 T = vec4(t2 * t, t2, t, 1.0);\r\n\t\t\r\n\tvec4 vWeights = T * mSplineBasis;\r\n\t\r\n\tvec3 vResult;\r\n\r\n\tvec4 vCoeffsX = vec4(a.x, b.x, c.x, d.x);\r\n\tvec4 vCoeffsY = vec4(a.y, b.y, c.y, d.y);\r\n\tvec4 vCoeffsZ = vec4(a.z, b.z, c.z, d.z);\r\n\t\r\n\tvResult.x = dot(vWeights, vCoeffsX);\r\n\tvResult.y = dot(vWeights, vCoeffsY);\r\n\tvResult.z = dot(vWeights, vCoeffsZ);\r\n\t\r\n\treturn vResult;\r\n}\r\n\r\nvoid GetCamera(out vec3 vCameraPos, out vec3 vCameraTarget)\r\n{\r\n\tfloat fCameraGlobalTime = g_fSceneTime;\t\t\r\n\t\r\n\tfloat fCameraTime = fract(fCameraGlobalTime);\r\n\tfloat fCameraIndex = floor(fCameraGlobalTime);\r\n\t\r\n\tvec3 vCameraPosA;\r\n\tvec3 vCameraTargetA;\r\n\tGetCameraPosAndTarget(fCameraIndex, vCameraPosA, vCameraTargetA);\r\n\t\r\n\tvec3 vCameraPosB;\r\n\tvec3 vCameraTargetB;\r\n\tGetCameraPosAndTarget(fCameraIndex + 1.0, vCameraPosB, vCameraTargetB);\r\n\t\r\n\tvec3 vCameraPosC;\r\n\tvec3 vCameraTargetC;\r\n\tGetCameraPosAndTarget(fCameraIndex + 2.0, vCameraPosC, vCameraTargetC);\r\n\t\r\n\tvec3 vCameraPosD;\r\n\tvec3 vCameraTargetD;\r\n\tGetCameraPosAndTarget(fCameraIndex + 3.0, vCameraPosD, vCameraTargetD);\r\n\t\r\n\tvCameraPos = BSpline(vCameraPosA, vCameraPosB, vCameraPosC, vCameraPosD, fCameraTime);\r\n\tvCameraTarget = BSpline(vCameraTargetA, vCameraTargetB, vCameraTargetC, vCameraTargetD, fCameraTime);\r\n}\r\n\r\n\r\nvec3 Tonemap( const in vec3 cCol )\r\n{\r\n    return sqrt(1.0 - exp(-cCol));\r\n}\r\n\r\nfloat GetTime()\r\n{\r\n\tfloat fTime = iChannelTime[3] \/ 8.0;\r\n\t#ifdef OVERRIDE_TIME\r\n\tfTime = iMouse.x * fSequenceLength \/ iResolution.x;\r\n\t#endif\r\n\t\r\n\t\/\/ hack the preview image\r\n\tif(iGlobalTime == 10.0)\r\n\t{\r\n\t\tfTime = 30.0 \/ 8.0;\r\n\t}\r\n\t\r\n\treturn mod(fTime, fSequenceLength);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 vUV = (fragCoord.xy \/ iResolution.xy) * 2.0 - 1.0;\r\n\r\n\tg_fTime = GetTime();\r\n\r\n\t\/\/ (noisy) motion blur by dithering time per pixel!\r\n\tg_fTime += (texture2D(iChannel1, (fragCoord.xy \/ 64.0) + 0.5).r - 0.5) * 0.005;\t\r\n\t\r\n\tfloat fTimeWarp = 0.0;\r\n\t\r\n\tg_ReverseEffectEnabled = smoothstep(13.0, 14.0, g_fTime);\r\n\t\r\n\t\/\/ During the reverse sequence time is further backward at the edge of the screen\r\n\tg_fSceneTime = g_fTime;\r\n\tif(g_fSceneTime > 13.0)\r\n\t{\r\n\t\tfloat t = (g_fSceneTime - 13.0);\r\n\t\t\r\n\t\tfloat l = length(vUV);\r\n\t\tfTimeWarp = l * l * g_ReverseEffectEnabled;\r\n\t\tt += fTimeWarp * 0.2;\r\n\t\t\r\n\t\tg_fSceneTime = 13.0 - t * t;\r\n\r\n\t}\t\r\n\r\n\tg_fSceneTime = max(g_fSceneTime, 0.0);\r\n\t\r\n\tfloat a = (g_fSceneTime - 8.0);\r\n\ta = a * a * a;\r\n\tg_mPortalRotation = mat3(sin(a), 0.0, cos(a), \r\n\t\t\t\t\t  0.0, 1.0, 0.0,\r\n\t\t\t\t\t  cos(a), 0.0, -sin(a));\r\n \r\n    vec3 vCameraPos;\r\n    vec3 vCameraInterest;\r\n\tGetCamera(vCameraPos, vCameraInterest);\r\n\t\r\n\tC_Ray ray;\r\n    GetCameraRayLookat( vCameraPos, vCameraInterest, fragCoord, ray);\r\n\r\n    vec3 cScene = GetSceneColour( ray );  \r\n    \r\n\tfloat fExposure = 1.5;    \r\n\t\r\n\tfExposure = mix(fExposure, 0.3, smoothstep(3.45, 3.6, g_fTime));\r\n\tfExposure = mix(fExposure, 1.0, smoothstep(5.35, 5.5, g_fTime));\r\n\tfExposure = mix(fExposure, 20.0, smoothstep(7.6, 7.8, g_fTime));\r\n\r\n\tfExposure = mix(fExposure, 1.5, smoothstep(15.0, 17.0, g_fTime));\r\n\t\r\n\t\/\/ vignette\r\n\tfloat fDist = dot(vUV, vUV);\r\n\tfDist = fDist * fDist;\r\n\tfloat fAmount = 1.0 \/ (fDist + 1.0);\r\n\tcScene = cScene * fAmount;\t\r\n\t\r\n\tvec3 cColour = Tonemap(cScene * fExposure);\r\n\r\n    fragColor = vec4(cColour, 1.0 );\r\n}\r\n","name":"","description":"","type":"image"}]}}