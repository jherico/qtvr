{"Shader":{"ver":"0.1","info":{"id":"lslGDB","date":"1378971661","viewed":2033,"name":"Water world","username":"reinder","description":"A living, surrealistic, water world showing reflections and distance field rendering.<br\/>As usual, almost al code is copy-paste from shaders by inigo quilez.<br\/>Lens flare by musk! (https:\/\/www.shadertoy.com\/view\/4sX3Rs).","likes":22,"published":3,"flags":0,"tags":["distancefield","reflection","water","flare"],"hasliked":0},"renderpass":[{"inputs":[{"id":6,"src":"\/presets\/tex05.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":16,"src":"\/presets\/tex11.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Water world. Created by Reinder Nijhoff 2013\n\/\/ @reindernijhoff\n\/\/\n\/\/ https:\/\/www.shadertoy.com\/view\/lslGDB\n\/\/\n\/\/ As usual, almost al code is copy-paste from shaders by inigo quilez \n\/\/ Lens flare by musk! (https:\/\/www.shadertoy.com\/view\/4sX3Rs)\n\/\/ \n\n#define BUMPFACTOR 0.1\n#define EPSILON 0.1\n#define BUMPDISTANCE 36.\n#define MAXDISTANCE 150.\n\nvec3 lig = normalize(vec3(-0.8,0.6,-0.2));\nfloat time = iGlobalTime + 350.;\n\nfloat noise(float t) {\n\treturn texture2D(iChannel0,vec2(t,.0)\/iChannelResolution[0].xy).x;\n}\n\nfloat noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\n\treturn -1.0 + 2.0*texture2D( iChannel0, (uv+0.5)\/256.0, -100.0 ).x;\n}\n\nfloat noise( in vec3 x )\n{\n\tfloat  z = x.z*64.0;\n\tvec2 offz = vec2(0.317,0.123);\n\tvec2 uv1 = x.xy + offz*floor(z); \n\tvec2 uv2 = uv1  + offz;\n\treturn mix(texture2D( iChannel0, uv1 ,-100.0).x,texture2D( iChannel0, uv2 ,-100.0).x,fract(z))-0.5;\n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nconst mat3 m3 = mat3( 0.00,  0.80,  0.60,\n                     -0.80,  0.36, -0.48,\n                     -0.60, -0.48,  0.64 );\n\nfloat fbm( vec3 p ) {\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m3*p*2.02;\n    f += 0.2500*noise( p ); p = m3*p*2.03;\n    f += 0.1250*noise( p ); p = m3*p*2.01;\n    f += 0.0625*noise( p );\n    return f\/0.9375;\n}\n\nfloat base( in vec3 p){\n\treturn noise(p*0.005)*20.0;\n}\n\nvec3 terrainOffset =  0.5*vec3( 0., -0.4, 0. )*(time+0.12*sin(time*4.));\nfloat terrainYFactor = (1.1+sin(time*0.125));\n\nfloat mapTerrain( in vec3 p ) {\n\tvec3 c = p  + terrainOffset;\n\treturn base(c)+7.0+0.03*base(c*10.)+2.0*p.y*terrainYFactor;\n}\n\n\/\/ intersection functions\n\nbool intersectPlane(vec3 ro, vec3 rd, float height, out float dist) {\t\n\tif (rd.y==0.0) {\n\t\treturn false;\n\t}\n\t\t\n\tfloat d = -(ro.y - height)\/rd.y;\n\td = min(100000.0, d);\n\tif( d > 0. ) {\n\t\tdist = d;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd, in float maxd ) {\n\tfloat precis = 0.0005;\n    float h=precis*2.0;\n    float t = 0.0;\n\tfloat d = 0.0;\n    float m = 1.0;\n    for( int i=0; i<150; i++ ) {\n\t\tif( abs(h) < precis || t > maxd ) break; {\n\t        t += h;\n\t\t    h = 0.15*mapTerrain( ro+rd*t );\n\t\t}\n    }\n\n    if( t>maxd ) m=-1.0;\n    return vec3( t, d, m );\n}\n\nvec3 calcNormal( vec3 pos ) {\n    vec3 eps = vec3(0.1,0.0,0.0);\n\n\treturn normalize( vec3(\n           mapTerrain(pos+eps.xyy) - mapTerrain(pos-eps.xyy),\n           mapTerrain(pos+eps.yxy) - mapTerrain(pos-eps.yxy),\n           mapTerrain(pos+eps.yyx) - mapTerrain(pos-eps.yyx) ) );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    for( int i=0; i<32; i++ ) {\n        h = 0.15*mapTerrain(ro + rd*t);\n        res = min( res, k*h\/t );\n\t\tt += clamp( h, 0.02, 2.0 );\n\t\t\n\t\tif( h<0.0001 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n ) {\n\tvec4 x = texture2D( sam, p.yz );\n\tvec4 y = texture2D( sam, p.zx );\n\tvec4 z = texture2D( sam, p.xy );\n\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\nfloat waterHeightMap( vec2 pos ) {\n\tvec2 posm = 0.01*pos * m2;\n\tposm.x += 0.001*time;\n\tfloat f = fbm( vec3( posm*1.9, time*0.01 ));\n\tfloat height = 0.5+0.1*f;\n\theight += 0.05*sin( posm.x*6.0 + 10.0*f );\n\t\n\tfloat h1 = 1.*mapTerrain( vec3(pos.x, -2.0, pos.y ) );\n\tfloat h2 = 1.*mapTerrain( vec3(pos.x, -1.5, pos.y ) );\n\tfloat h = min(h1,h2);\n\theight += 0.25*sin( 4.*h-(time+0.8*noise( pos.xy*2. ))*6. )\/(1.5*h1+1.0);\n\t\n\treturn  height;\n}\n\n\/\/-----------------------------------------------------\n\/\/ Lens flare\n\/\/\n\/\/ by musk License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/\n\/\/ Trying to get some interesting looking lens flares.\n\/\/ \n\/\/  13\/08\/13: \n\/\/ \tpublished\n\/\/ \n\/\/ muuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuusk!\n\/\/-----------------------------------------------------\n\nvec3 lensflare(vec2 uv,vec2 pos) {\n\tvec2 main = uv-pos;\n\tvec2 uvd = uv*(length(uv));\n\t\n\tfloat ang = atan(main.x,main.y);\n\tfloat dist=length(main); dist = pow(dist,.1);\n\tfloat n = noise(vec2(ang*16.0,dist*32.0));\n\t\n\tfloat f0 = 1.0\/(length(uv-pos)*16.0+1.0);\n\t\n\tf0 = f0+f0*(sin(noise((pos.x+pos.y)*2.2+ang*4.0+5.954)*16.0)*.1+dist*.1+.8);\n\t\n\tfloat f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;\n\n\tfloat f2 = max(1.0\/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;\n\tfloat f22 = max(1.0\/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;\n\tfloat f23 = max(1.0\/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;\n\t\n\tvec2 uvx = mix(uv,uvd,-0.5);\n\t\n\tfloat f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\n\tfloat f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\n\tfloat f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\n\t\n\tuvx = mix(uv,uvd,-.4);\n\t\n\tfloat f5 = max(0.01-pow(length(uvx+0.2*pos),5.5),.0)*2.0;\n\tfloat f52 = max(0.01-pow(length(uvx+0.4*pos),5.5),.0)*2.0;\n\tfloat f53 = max(0.01-pow(length(uvx+0.6*pos),5.5),.0)*2.0;\n\t\n\tuvx = mix(uv,uvd,-0.5);\n\t\n\tfloat f6 = max(0.01-pow(length(uvx-0.3*pos),1.6),.0)*6.0;\n\tfloat f62 = max(0.01-pow(length(uvx-0.325*pos),1.6),.0)*3.0;\n\tfloat f63 = max(0.01-pow(length(uvx-0.35*pos),1.6),.0)*5.0;\n\t\n\tvec3 c = vec3(.0);\n\t\n\tc.r+=f2+f4+f5+f6; c.g+=f22+f42+f52+f62; c.b+=f23+f43+f53+f63;\n\tc = c*1.3 - vec3(length(uvd)*.05);\n\tc+=vec3(f0);\n\t\n\treturn c;\n}\n\n\/\/-----------------------------------------------------\n\t\n\nvec3 path( float time ) {\n\treturn vec3( 26.0*cos(0.2+0.35*.1*time*1.5), 1.5, 26.0*sin(0.1+0.5*0.099*time*1.5) );\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy \/ iResolution.xy;\n\tvec2 p = -1.0 + 2.0*q;\n\tp.x *= iResolution.x \/ iResolution.y;\n\t\n\t\n    \/\/ camera\t\n\tfloat off = step( 0.001, iMouse.z )*6.0*iMouse.x\/iResolution.x;\n\ttime += off;\n\tvec3 ro = path( time+0.0 );\n\tvec3 ta = path( time+1.6 );\n\t\n\tro.y += clamp(0.4-mapTerrain(ro), 0., 1.);\n\t\n\tta.y *= 0.8 + 0.25*sin(0.09*time);\n\tfloat roll = 0.3*sin(1.0+0.07*time);\n\t\n\t\/\/ camera tx\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n\t\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.1*cw );\n\n\tfloat flare = dot( lig, normalize(ta-ro) );\n\t\n    \/\/-----------------------------------------------------\n\t\/\/ render\n    \/\/-----------------------------------------------------\n\t\n\t\/\/ raymarch\n\tbool reflection = false;\t\n\tfloat dist, totaldist = 0., depth = 0.;\n\tvec3 normal;\n\tbool planeIntersect = intersectPlane( ro, rd, -2., dist );\n\t\t\n    vec3 tmat = intersect(ro,rd, planeIntersect?dist:MAXDISTANCE );\n\t\n\tif( planeIntersect && dist < tmat.x ) {\t\t\t\n\t\tro = ro+rd*dist;\n\t\ttotaldist = dist;\n\t\t\n\t\tdepth = mapTerrain(ro);\n\t\t\n\t\tvec2 coord = ro.xz;\n\t\tvec2 dx = vec2( EPSILON, 0. );\n\t\tvec2 dz = vec2( 0., EPSILON );\n\t\t\n\t\tfloat bumpfactor = BUMPFACTOR * (1. - smoothstep( 0., BUMPDISTANCE, dist) );\n\t\t\n\t\tnormal = vec3( 0., 1., 0. );\n\t\tnormal.x = -bumpfactor * (waterHeightMap(coord + dx) - waterHeightMap(coord-dx) ) \/ (2. * EPSILON);\n\t\tnormal.z = -bumpfactor * (waterHeightMap(coord + dz) - waterHeightMap(coord-dz) ) \/ (2. * EPSILON);\n\t\tnormal = normalize( normal );\n\t\t\n\t\trd = reflect( rd, normal );\n\t\t\n\t\ttmat = intersect(ro,rd, MAXDISTANCE);\n\t\treflection = true;\n\t} \n\t\t\n\ttotaldist += tmat.x;\n\t\n\t\/\/ sky\t \n\tvec3 col = 2.0*vec3(0.32,0.36,0.4) - rd.y*0.6;\n    float sun = clamp( dot(rd,lig), 0.0, 1.0 );\n\tcol += vec3(1.0,0.8,0.4)*0.2*pow( sun, 6.0 );\n\t\t\n\tcol += 0.1*vec3( fbm( rd*0.2 ) );\n\t\n    vec3 bgcol = col;\n\t\t\t\n    if( tmat.z>-0.5 && totaldist < MAXDISTANCE)\n    {\n        \/\/ geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormal(pos);\n\t\tvec3 ref = reflect( rd, nor );\n\t\t\t\t\n        \/\/ material\n\t\tvec4 mate = vec4(0.0);\n\t\tvec3 matpos = pos+terrainOffset;\n\t\t\n\t\tmate.w = 0.0;\n\t\tmate.xyz = texcube( iChannel1, 0.1*matpos*vec3(1.0,2.2,1.0), nor ).xyz;\n\t\tmate.xyz *= vec3(0.4,0.4,0.4);\n\t\t\n\t\tmate.xyz *= 3.0*vec3(0.32,0.36,0.4) - nor.y*0.6;\n\n\t\t\/\/ lighting\n\t\tfloat occ = 1.0;\/\/(0.5 + 0.5*nor.y);\/\/*mate2.y;\n        float amb = clamp(0.5 + 0.5*nor.y,0.0,1.0);\n\t\tfloat bou = clamp(-nor.y,0.0,1.0)*clamp(1.0-pos.y\/10.0,0.0,1.0);\n\t\tfloat dif = max(dot(nor,lig),0.0);\n        float bac = max(0.2 + 0.8*dot(nor,normalize(vec3(-lig.x,0.0,-lig.z))),0.0);\n\t\tfloat sha = 0.0; if( dif>0.01 ) sha=softshadow( pos+0.05*nor, lig, 0.0005, 32.0 );\n        float fre = mate.w;\/\/pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 2.0 );\n        float spe = max( 0.0, pow( clamp( dot(lig,reflect(rd,nor)), 0.0, 1.0), 100.0 ) );\n\t\t\n\t\t\/\/ lights\n\t\tvec3 brdf = vec3(0.0);\n        brdf += 3.0*dif*vec3(1.10,0.90,0.80)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n\t\tbrdf += 1.0*amb*vec3(0.10,0.15,0.30)*occ;\n\t\tbrdf += 1.0*bac*vec3(0.09,0.06,0.04)*occ;\n\t\tbrdf += 2.5*bou*vec3(0.02,0.06,0.09)*occ;\n\t\t\n\t\tbrdf += 50.0*spe*vec3(1.0)*occ*dif*sha*clamp( (4.-pos.y)\/6., 0., 1.)*clamp( 0.5+fbm(matpos), 0., 1.);\n\n\t\t\/\/ surface-light interacion\n\t\tcol = mate.xyz* brdf + 0.7*sha*vec3(0.3,0.5,0.6)*fre*mate.w + mate.w*vec3(1.0,0.9,0.8)*spe*sha;\t\t\t\n\t} \n\n\tif( reflection ) {\n\t\tcol = mix( bgcol, col, exp(-0.000001*pow(totaldist-dist,3.0)) );\n\t\t\n\t\tcol *= 0.9*vec3( 0.8, 0.9, 1. )*(0.5+clamp( depth*2., 0.0, 0.5));\n\n        float spe = max( 0.0, pow( clamp( dot(lig,rd), 0.0, 1.0), 100.0 ) )*softshadow( ro, lig, 0.0005, 32.0 );\n\t\t\n\t\tcol += 2.0*spe*vec3(1.0);\n\t\t\n\t\tif( dist != totaldist ) totaldist = dist;\n\t} \n\tcol = mix( bgcol, col, exp(-0.000001*pow(totaldist,3.0)) );\n\t\n\t\/\/ sun glow\n    col += vec3(1.0,0.6,0.2)*0.2*pow( sun, 2.0 )*clamp( (rd.y+0.4)\/(0.0+0.4),0.0,1.0);\n\n\t\n\tvec2 sunuv =  2.7*vec2( dot( lig, cu ), dot( lig, cv ) );\n\t\n\tcol += vec3(1.4,1.2,1.0)*lensflare(p, sunuv)\n\t\t*clamp( 3.*flare, 0., 1.);\t\n\t\n\t\/\/-----------------------------------------------------\n\t\/\/ postprocessing\n    \/\/-----------------------------------------------------\n    \/\/ gamma\n\tcol = clamp( col, 0.0, 1.0 );\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\t\n    \/\/ contrast, desat, tint and vignetting\t\n\tcol = col*0.7 + 0.3*col*col*(3.0-2.0*col);\n\tcol = mix( col, vec3(col.x+col.y+col.z)*0.33, 0.1 );\n\tcol *= vec3(1.03,1.02,1.0);\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n    fragColor = vec4( col, 1.0 );\n}\n","name":"","description":"","type":"image"}]}}