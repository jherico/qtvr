{"Shader":{"ver":"0.1","info":{"id":"XsX3RB","date":"1372830991","viewed":67302,"name":"Volcanic","username":"iq","description":"An alien volcanic landscape. It started as an experiment on 2d-texture based 3d noise. But then I played with the noise shape, the added some shading, put lighting in it, etc..., until I got this.  I can't wait for Shadertoy to have multipass rendering...","likes":254,"published":3,"flags":0,"tags":["procedural","3d","raymarching","noise","distancefield"],"hasliked":0},"renderpass":[{"inputs":[{"id":7,"src":"\/presets\/tex06.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":10,"src":"\/presets\/tex09.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\/\/#define HIGH_QUALITY_NOISE\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n#ifndef HIGH_QUALITY_NOISE\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D( iChannel0, (uv+ 0.5)\/256.0, -100.0 ).yx;\n#else\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\n\tvec2 rg1 = texture2D( iChannel0, (uv+ vec2(0.5,0.5))\/256.0, -100.0 ).yx;\n\tvec2 rg2 = texture2D( iChannel0, (uv+ vec2(1.5,0.5))\/256.0, -100.0 ).yx;\n\tvec2 rg3 = texture2D( iChannel0, (uv+ vec2(0.5,1.5))\/256.0, -100.0 ).yx;\n\tvec2 rg4 = texture2D( iChannel0, (uv+ vec2(1.5,1.5))\/256.0, -100.0 ).yx;\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\n#endif\t\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn texture2D( iChannel0, (uv+118.4)\/256.0, -100.0 ).x;\n}\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec4 x = texture2D( sam, p.yz );\n\tvec4 y = texture2D( sam, p.zx );\n\tvec4 z = texture2D( sam, p.xy );\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\n\/\/=====================================================================\n\nfloat lava( vec2 p )\n{\n\tp += vec2(2.0,4.0);\n    float f;\n    f  = 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat displacement( vec3 p )\n{\n\tp += vec3(1.0,0.0,0.8);\n\t\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p ); \n\t\n\tfloat n = noise( p*3.5 );\n    f += 0.03*n*n;\n\t\n    return f;\n}\n\nfloat mapTerrain( in vec3 pos )\n{\n\treturn pos.y*0.1 + (displacement(pos*vec3(0.8,1.0,0.8)) - 0.4)*(1.0-smoothstep(1.0,3.0,pos.y));\n}\n\nfloat raymarchTerrain( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 30.0;\n    float t = 0.1;\n    for( int i=0; i<160; i++ )\n    {\n\t    float h = mapTerrain( ro+rd*t );\n        if( h<(0.001*t) || t>maxd ) break;\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    vec3 eps = vec3( max(0.02,0.001*t),0.0,0.0);\n\treturn normalize( vec3(\n           mapTerrain(pos+eps.xyy) - mapTerrain(pos-eps.xyy),\n           mapTerrain(pos+eps.yxy) - mapTerrain(pos-eps.yxy),\n           mapTerrain(pos+eps.yyx) - mapTerrain(pos-eps.yyx) ) );\n\n}\n\nvec3 lig = normalize( vec3(-0.3,0.4,0.7) );\n\t\nvec4 mapClouds( in vec3 pos )\n{\n\tvec3 q = pos*0.5 + vec3(0.0,-iGlobalTime,0.0);\n\t\n\tfloat d;\n    d  = 0.5000*noise( q ); q = q*2.02;\n    d += 0.2500*noise( q ); q = q*2.03;\n    d += 0.1250*noise( q ); q = q*2.01;\n    d += 0.0625*noise( q );\n\t\t\n\td = d - 0.55;\n\td *= smoothstep( 0.5, 0.55, lava(0.1*pos.xz)+0.01 );\n\n\td = clamp( d, 0.0, 1.0 );\n\t\n\tvec4 res = vec4( d );\n\n\tres.xyz = mix( vec3(1.0,0.8,0.7), 0.2*vec3(0.4,0.4,0.4), res.x );\n\tres.xyz *= 0.25;\n\tres.xyz *= 0.5 + 0.5*smoothstep( -2.0, 1.0, pos.y );\n\t\n\treturn res;\n}\n\nvec4 raymarchClouds( in vec3 ro, in vec3 rd, in vec3 bcol, float tmax )\n{\n\tvec4 sum = vec4( 0.0 );\n\n\tfloat sun = pow( clamp( dot(rd,lig), 0.0, 1.0 ),6.0 );\n\tfloat t = 0.0;\n\tfor( int i=0; i<60; i++ )\n\t{\n\t\tif( t>tmax || sum.w>0.95 ) break;\/\/continue;\n\t\tvec3 pos = ro + t*rd;\n\t\tvec4 col = mapClouds( pos );\n\t\t\n        col.xyz += vec3(1.0,0.7,0.4)*0.4*sun*(1.0-col.w);\n\t\tcol.xyz = mix( col.xyz, bcol, 1.0-exp(-0.00006*t*t*t) );\n\t\t\n\t\tcol.rgb *= col.a;\n\n\t\tsum = sum + col*(1.0 - sum.a);\t\n\n\t\tt += max(0.1,0.05*t);\n\t}\n\n\tsum.xyz \/= (0.001+sum.w);\n\n\treturn clamp( sum, 0.0, 1.0 );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<48; i++ )\n    {\n        float h = mapTerrain(ro + rd*t);\n\t\th = max( h, 0.0 );\n        res = min( res, k*h\/t );\n        t += clamp( h, 0.02, 0.5 );\n\t\tif( h<0.0001 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 path( float time )\n{\n\treturn vec3( 16.0*cos(0.2+0.5*.1*time*1.5), 1.5, 16.0*sin(0.1+0.5*0.11*time*1.5) );\n\t\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy \/ iResolution.xy;\n\tvec2 p = -1.0 + 2.0*q;\n\tp.x *= iResolution.x \/ iResolution.y;\n\t\n\t\n    \/\/ camera\t\n\tfloat off = step( 0.001, iMouse.z )*6.0*iMouse.x\/iResolution.x;\n\tfloat time = 2.7+iGlobalTime + off;\n\/\/time =35.0;\n\tvec3 ro = path( time+0.0 );\n\tvec3 ta = path( time+1.6 );\n\t\/\/ta.y *= 0.3 + 0.25*cos(0.11*time);\n\tta.y *= 0.35 + 0.25*sin(0.09*time);\n\tfloat roll = 0.3*sin(1.0+0.07*time);\n\t\/\/ camera2world transform\n    mat3 cam = setCamera( ro, ta, roll );\n\n    \/\/ ray    \n\tfloat r2 = p.x*p.x*0.32 + p.y*p.y;\n    p *= (7.0-sqrt(37.5-11.5*r2))\/(r2+1.0);\n    vec3 rd = cam * normalize(vec3(p.xy,2.1));\n\n    \/\/ sky\t \n\tvec3 col = vec3(0.32,0.36,0.4) - rd.y*0.4;\n    float sun = clamp( dot(rd,lig), 0.0, 1.0 );\n\tcol += vec3(1.0,0.8,0.4)*0.2*pow( sun, 6.0 );\n    col *= 0.9;\n\n\tvec3 bcol = col;\n    \n    \/\/ terrain\t\n\tfloat t = raymarchTerrain(ro, rd);\n    if( t>0.0 )\n\t{\n\t\tvec3 pos = ro + t*rd;\n\t\tvec3 nor = calcNormal( pos, t );\n\t\tvec3 ref = reflect( rd, nor );\n\n\t\tvec3 bn = -1.0 + 2.0*texcube( iChannel0, 3.0*pos\/4.0, nor ).xyz;\n\t\tnor = normalize( nor + 0.6*bn );\n\t\t\n\t\tfloat hh = 1.0 - smoothstep( -2.0, 1.0, pos.y );\n\n        \/\/ lighting\n\t\tfloat sun = clamp( dot( nor, lig ), 0.0, 1.0 );\n\t\tfloat sha = 0.0; if( sun>0.01) sha=softshadow(pos,lig,0.01,32.0);\n\t\tfloat bac = clamp( dot( nor, normalize(lig*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\n\t\tfloat sky = 0.5 + 0.5*nor.y;\n        float lav = smoothstep( 0.5, 0.55, lava(0.1*pos.xz) )*hh*clamp(0.5-0.5*nor.y,0.0,1.0);\n\t\tfloat occ = pow( (1.0-displacement(pos*vec3(0.8,1.0,0.8)))*1.6-0.5, 2.0 );\n\n\t\tfloat amb = 1.0;\n\n\t\tcol = vec3(0.8);\n\n\t\tvec3 lin = vec3(0.0);\n\t\tlin += sun*vec3(1.80,1.27,0.99)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n\t\tlin += sky*vec3(0.16,0.20,0.40)*occ;\n\t\tlin += bac*vec3(0.40,0.28,0.20)*occ;\n\t\tlin += amb*vec3(0.15,0.17,0.20)*occ;\n\t\tlin += lav*vec3(3.00,0.61,0.00);\n\n\n        \/\/ surface shading\/material\t\t\n\t\tcol = texcube( iChannel1, 0.5*pos, nor ).xyz;\n\t\tcol = col*(0.2+0.8*texcube( iChannel2, 4.0*vec3(2.0,8.0,2.0)*pos, nor ).x);\n\t\tvec3 verde = vec3(1.0,0.9,0.2);\n\t\tverde *= texture2D( iChannel2, pos.xz ).xyz;\n\t\tcol = mix( col, 0.8*verde, hh );\n\t\t\n\t\tfloat vv = smoothstep( 0.0, 0.8, nor.y )*smoothstep(0.0, 0.1, pos.y-0.8 );\n\t\tverde = vec3(0.2,0.45,0.1);\n\t\tverde *= texture2D( iChannel2, 30.0*pos.xz ).xyz;\n\t\tverde += 0.2*texture2D( iChannel2, 1.0*pos.xz ).xyz;\n\t\tvv *= smoothstep( 0.0, 0.5, texture2D( iChannel2, 0.1*pos.xz + 0.01*nor.x ).x );\n\t\tcol = mix( col, verde*1.1, vv );\n\t\t\n        \/\/ light\/surface interaction\t\t\n\t\tcol = lin * col;\n\t\t\n\t\t\/\/ atmospheric\n\t\tcol = mix( col, (1.0-0.7*hh)*bcol, 1.0-exp(-0.00006*t*t*t) );\n\t}\n\n\t\/\/ sun glow\n    col += vec3(1.0,0.6,0.2)*0.2*pow( sun, 2.0 )*clamp( (rd.y+0.4)\/(0.0+0.4),0.0,1.0);\n\t\n    \/\/ smoke\t\n\t{\n\tif( t<0.0 ) t=600.0;\n    vec4 res = raymarchClouds( ro, rd, bcol, t );\n\tcol = mix( col, res.xyz, res.w );\n\t}\n\n    \/\/ gamma\t\n\tcol = pow( clamp( col, 0.0, 1.0 ), vec3(0.45) );\n\n    \/\/ contrast, desat, tint and vignetting\t\n\tcol = col*0.3 + 0.7*col*col*(3.0-2.0*col);\n\tcol = mix( col, vec3(col.x+col.y+col.z)*0.33, 0.2 );\n\tcol *= 1.3*vec3(1.06,1.1,1.0);\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}