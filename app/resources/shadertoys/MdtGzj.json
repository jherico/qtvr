{"Shader":{"ver":"0.1","info":{"id":"MdtGzj","date":"1451026555","viewed":156,"name":"iPhone Shader Test","username":"jackdavenport","description":"Just got a new phone, so now that my phone can load basic shaders without slowing to 15fps, I'm just writing this shader to test out different kinds of raymarchers on it.","likes":1,"published":3,"flags":0,"tags":["raymarcher","iphone"],"hasliked":0},"renderpass":[{"inputs":[{"id":22,"src":"\/presets\/cube00_0.jpg","ctype":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define MAX_ITERATIONS 256\n#define MAX_ITERATIONS_S 128\n#define MIN_DISTANCE .01\n\nstruct Ray { vec3 ori; vec3 dir; };\nstruct Dst { float dst; int id;  };\nstruct Hit { vec3 p; int id;     };\n\nfloat dSphere(vec3 p, vec3 pos, float radius) {\n\n    return length(pos - p) - radius;\n    \n}\n\nfloat dFloor(vec3 p, float y) {\n \n    return p.y - y;\n    \n}\n\nDst distScene(vec3 p) {\n \n    float flor = dFloor(p, -1.);\n    float sph1 = dSphere(p, vec3(sin(iGlobalTime), 0., 0.), 1.);\n    \n    float dst = min(flor,sph1);\n    return Dst(dst, dst == sph1 ? 0 : 1);\n    \n}\n\nHit raymarch(Ray ray, bool secondary) {\n\n    vec3 p = ray.ori;\n    int id = -1;\n    \n    for(int i = 0; i < MAX_ITERATIONS_S; i++) {\n     \n        Dst scn = distScene(p);\n        p += ray.dir * scn.dst;\n        \n        if(scn.dst < MIN_DISTANCE) {\n         \n            id = scn.id;\n            break;\n            \n        }\n        \n    }\n    \n    return Hit(p,id);\n    \n}\n    \nvec3 clearColor(vec3 dir) {\n \n    return textureCube(iChannel0, dir).xyz;\n    \n}\n\nvec3 getLightDirection(vec3 p) {\n \n    return vec3(1.,1.5,-1.) - p;\n    \n}\n\nvec3 calcNormal(vec3 p) {\n \n    vec2 eps = vec2(.001, .0);\n    vec3 n = vec3(distScene(p + eps.xyy).dst - distScene(p - eps.xyy).dst,\n                  distScene(p + eps.yxy).dst - distScene(p - eps.yxy).dst,\n                  distScene(p + eps.yyx).dst - distScene(p - eps.yyx).dst);\n    return normalize(n);\n    \n}\n\nvec3 getDiffuse(Hit hit, vec3 n) {\n \n    const float a = .2;\n    vec3 ld = getLightDirection(hit.p);\n    float d = a + max(dot(normalize(ld),n), 0.);\n    d *= 1. - clamp(length(ld) \/ 20., 0., 1.);\n    \n    ld = normalize(ld);\n    Ray sr = Ray(hit.p + (ld * MIN_DISTANCE), ld);\n    Hit sh = raymarch(sr, true);\n    \n    if(sh.id != -1) d = a;\n    return vec3(d);\n    \n}\n\nvec3 shadePlane(Hit scn, Ray ray) {\n    \n    vec3 n = calcNormal(scn.p);\n    vec3 d = getDiffuse(scn, n);\n        \n    return vec3(1.) * d;\n    \n}\n\nvec3 shade(Ray ray) {\n \n    Hit scn = raymarch(ray, false);\n    \n    if(scn.id == 0) {\n     \n        vec3 n = calcNormal(scn.p);\n\t\tvec3 rd = reflect(ray.dir, n);\n        Ray rr = Ray(scn.p + (rd * MIN_DISTANCE), rd);\n        Hit rh = raymarch(rr, true);\n        \n        if(rh.id == 1) {\n         \n            return shadePlane(rh,rr);\n            \n        }\n        \n        return clearColor(rd);\n        \n    } else if(scn.id == 1) {\n     \n        return shadePlane(scn, ray);\n        \n    }\n    \n    return clearColor(ray.dir);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy \/ 2.) \/ iResolution.y;\n    \n    vec3 ori = vec3(0.,0.,-3.);\n    vec3 dir = vec3(uv, 1.);\n    \n    vec3 col = shade(Ray(ori,dir));\n\tfragColor = vec4(col,1.0);\n}","name":"","description":"","type":"image"}]}}