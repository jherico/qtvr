{"Shader":{"ver":"0.1","info":{"id":"MsG3zD","date":"1453462823","viewed":98,"name":"AA Artwork","username":"joeedh","description":"A failed neighborhood function for AA Patterns.  Click and drag to (slightly) change seed.","likes":5,"published":3,"flags":0,"tags":["aapatternsfractalartworkcolorpointsetneighborhoodmoirediffraction"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/*\n\thttps:\/\/www.shadertoy.com\/view\/MsG3zD\n\t\n\tThis little shader is the result of a mathematical breakthrough I made last week.\n    This was a side effect.  The idea is simple.  AA patterns work by calculating a thresholding\n    for each pixel, using a function f (here is my slightly modified version):\n\n    dx = fract(x*seed - y*0.5);\n    dy = fract(y*seed + x*0.5);\n\n    f(x, y) -> length(dx, dy) \/ sqrt(2) \/\/return value from 0...1\n\nThere are other patterns too.  I was deriving a neighborhood filter (think of it as a blur filter) \nfor anther pattern analytically.  It tells you which neighborhood a point in that particular pattern\nis in.  No matter what width of filter I used, I kept arriving at the same basic equation:\n\n    neighborhood_id = fract( (f(x, y) + C1) * C2 )\n\nWhere C1 and C2 are constants.  I thought to myself, why not see what the same equation will do \nto AA Patterns?  The result was an approxmation of the neighborhood function.  It's imperfect,\nbut can produce very pretty looking patterns.\n\n(For those interested, the reason it's hard to derive a neighborhood filter for AA patterns is that \n fract(fract(x)*fract(y)) can't be factored).\n\n*\/\n\n\/\/#define NO_COLOR;\n#define ZOOM 2.0\n\/\/#define HEXAGON; \/\/offset grid pixels in hexagon pattern. useful when zoomed in.\n\/\/#define SMOOTHSTEP_SHARPEN; \/\/provides some sharpening, but at cost of suppressing some details\n\nfloat tent(float f) {\n    return 1.0 - abs(fract(f)-0.5)*2.0;\n}\n\nvec3 sample(vec2 uv, float time) {\n\tfloat c;\n    float seed = 8.13295 \/* - tent(time*0.00541)*0.00*\/ + iMouse.x*0.0000225;\n    float seed2 = 0.5;\n    \n    \/\/align to power of 2\n    seed = floor(seed*2048.0)\/2048.0;\n    seed2 = floor(seed2*2048.0)\/2048.0;\n    \n    float dx = fract(uv[0]*seed - uv[1]*seed2)*2.0-1.0;\n    float dy = fract(uv[1]*seed + uv[0]*seed2)*2.0-1.0;\n    \n    \/\/c = 1.0- sqrt((dx*dx + dy*dy))\/1.414;\n    c = sqrt(dx*dx+dy*dy)\/sqrt(2.0);\n    \n    \/\/c = min(abs(dx), abs(dy));\n    float mtime = 1.0 - tent(3.5*0.025+time*0.025);\n    float m = 1.0 + mtime*5.0;\n    \n    c = cos(-1.15+(c+0.0)*m)*0.5 + 0.5;\n    float f = (tent(c*1.35+1.205));\n    \n    c = pow(c, 2.0);\n    \n    f = f*0.85 + 0.15;\n    f *= 1.05;\n    f *= f*f*f*f*f*f;\n    \n    #ifdef SMOOTHSTEP_SHARPEN\n    for (int i=0; i<1; i++) {\n    \tf = f*f*(3.0-2.0*f);\n    }\n    #endif\n\t\n    float steps = 5.0;\n    \n    c = floor(c*steps+0.5)\/steps;\n    c *= 2.324324;\n    \n    return vec3(f, c, mtime);\n}\n\nvec3 pow(vec3 v, float f) {\n    return vec3(\n        pow(v[0], f),\n        pow(v[1], f),\n        pow(v[2], f)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv2 = fragCoord.xy \/ iResolution.xy;\n    vec2 uv = fragCoord.xy;\n    float sz = 1.0 \/ ZOOM;\n    uv *= sz;\n    \n    \n#ifdef HEXAGON\n    vec2 hexoff = vec2(0.0, 0.5*floor(mod(uv[0], 2.0)));\n    hexoff *= floor(mod(floor(uv[0]\/2.0), 2.0))*2.0-1.0;\n\n    vec2 px = fract(uv + hexoff)-0.5;\n    uv = floor(uv+hexoff);\n#else\n    vec2 px = fract(uv)-0.5;\n    uv = floor(uv);\n#endif\n    \n    vec3 ret = sample(uv, iGlobalTime);\n    float f = ret[0];\n    float c = ret[1];\n    \n    c *= 100.0;\n    \n    \/\/color offset\n    float off = 0.9;\/\/ + tent(iGlobalTime*0.05)*0.5;\n    \n    float r = tent(1.0 \/ ((sin(c*3.0)+0.25)*0.0000123432+0.00000001));\n    float g = tent(1.0 \/ ((sin(c*c*c*2.0+3.32)+0.5)*0.00002234+0.00000001));\n    float b = tent(1.0 \/ ((sin(c*c*5.0+4.43))*0.0000123432+0.0000000001));\n    float w = (r+g+b)\/3.0;\n    \n    r = cos((r + off)*3.141)*0.5+0.5;\n    g = cos((g + off)*3.141)*0.5+0.5;\n    b = cos((b + off)*3.141)*0.5+0.5;\n    \n    r *= 1.2;\n    b *= 0.8;\n    g *= 0.9;\n    \n    \n    float fac = f*9.0-9.5;\n    fac = pow(abs(fac), 1.0)*sign(fac);\n    \n\tvec3 clr = vec3(r, g, b)*f*f;\n    clr = clr*10.0 - 11.0;\n    \n    fac = clamp(0.0,1.0,fac);\n    clr = min(max(clr, 0.0), 1.0);\n    clr = clr*0.5 + 0.5;\n    \n\tfragColor = vec4(r, g, b, 1.0);\n    fragColor.xyz = normalize(fragColor.xyz)*f; \/\/(uv2[0] > 0.5 ? clr : 1.0);\n    \/\/ if (uv2[0] < 0.5)\n    \tfragColor.xyz = mix(fragColor.xyz, fragColor.xyz * clr * 2.75, ret[2]);\n    \n    if (sz < 0.5) {\n        float pfac = dot(px, px);\n    \tfragColor.xyz = mix(fragColor.xyz, vec3(0.5, 0.5, 0.5), 1.0-smoothstep(0.4, 0.1, pfac));\n    }\n    \n#ifdef NO_COLOR    \n    fragColor = vec4(f, f, f, 1.0);\n#endif\n    \n}","name":"","description":"","type":"image"}]}}