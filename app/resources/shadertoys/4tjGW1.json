{"Shader":{"ver":"0.1","info":{"id":"4tjGW1","date":"1428603639","viewed":1378,"name":"Simple 360 degree fov","username":"Madsy","description":"Mapping from spherical coordinates to cartesian 3D coordinates, which is then used as normals\/tcoords for a cube map. Use the mouse to move around (hold LMB)","likes":5,"published":3,"flags":0,"tags":["camera","fov","fieldofview"],"hasliked":0},"renderpass":[{"inputs":[{"id":22,"src":"\/presets\/cube00_0.jpg","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/Licence: Public domain. Attribution\/credit is a nice gesture,\n\/\/but not required\n\/\/define if you want to visualize the cubemap faces\n\/\/#define SHOW_FACE_GROUPS\n\/\/define if you want to see the normal as colors\n\/\/#define SHOW_NORMALS\n\n\/\/Try changing these for a different FOV.\n\/\/For example 180 deg horisontal and 90 degree vertical\nfloat FOVX = 360.0; \/\/Max 360 deg\nfloat FOVY = 180.0; \/\/Max 180 deg\n\nconst float PI = 3.1415926;\n\nmat3 rotX(float theta){\n    float s = sin(theta);\n    float c = cos(theta);\n    \n\tmat3 m =\n        mat3( 1, 0,  0,\n              0, c,  -s,\n              0, s,  c);\n    return m;\n}\n\nmat3 rotY(float theta){\n    float s = sin(theta);\n    float c = cos(theta);\n    \n\tmat3 m =\n        mat3( c, 0, -s,\n              0, 1,  0,\n              s, 0,  c);\n    return m;\n}\n\nmat3 rotZ(float theta){\n    float s = sin(theta);\n    float c = cos(theta);\n    \n\tmat3 m =\n        mat3( c, -s, 0,\n              s, c,  0,\n              0, 0,  1);\n    return m;\n}\n\nfloat deg2rad(float deg){\n    return deg*PI \/ 180.0;\n}\n\nvec4 faceColors[6];\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    faceColors[0] = vec4(1.0, 0.0, 0.0, 1.0); \/\/left\n\tfaceColors[1] = vec4(0.0, 1.0, 0.0, 1.0); \/\/right\n\tfaceColors[2] = vec4(0.0, 0.0, 1.0, 1.0); \/\/bottom\n    faceColors[3] = vec4(1.0, 1.0, 0.0, 1.0); \/\/top\n    faceColors[4] = vec4(1.0, 0.0, 1.0, 1.0); \/\/front\n    faceColors[5] = vec4(0.0, 1.0, 1.0, 1.0); \/\/back\n\n\tvec2 interp = fragCoord.xy \/ iResolution.xy;\n    \/\/Mouse coordinates in [-1, 1] range\n    vec2 mp = iMouse.xy \/ iResolution.xy * vec2(2.0) + vec2(1.0);    \n    \n    interp.y = 1.0 - interp.y;\n    mp.y = 1.0 - mp.y;\n    \n    \/\/360 degrees around the x-axis, 180 degrees on the y-axis\n    \/\/The frustum can be split into several parts:\n    \/\/The very top is +y, the north pole, and the very bottom\n    \/\/is -y, i.e the south pole.\n    \/\/The middle consists of +z, -z, +x and -x, where -z\n    \/\/is the center of the frustum, and the left and right\n    \/\/frustum edges show +z, i.e what is behind you\n    \n    float fovX = deg2rad(FOVX);\n    float fovY = deg2rad(FOVY);\n    float hOffset = (2.0*PI - fovX)*0.5;\n    float vOffset = (PI - fovY)*0.5;\n    float hAngle = hOffset + interp.x * fovX;\n    float vAngle = vOffset + interp.y * fovY;\n    vec3 n;    \n    n.x = sin(vAngle) * sin(hAngle);\n    n.y = cos(vAngle);\n    n.z = sin(vAngle) * cos(hAngle);\n    \n    \/\/Normal pitch-yaw camera controlled with the mouse\n    n = rotY(mp.x * 2.0 * PI) * rotX(mp.y * 2.0 * PI) * n;\n    \n    vec4 color;\n    \n    #ifdef SHOW_NORMALS\n    color.a = 1.0;\n    n = normalize(n);\n    color.rgb = ((n + vec3(1.0)) * vec3(0.5));\n    #else\n    color = textureCube(iChannel0, n);    \n    #ifdef SHOW_FACE_GROUPS\n    \tfloat ax = abs(n.x);\n    \tfloat ay = abs(n.y);\n    \tfloat az = abs(n.z);\n    \tif(ax > ay && ax > az){\n    \t\t\/\/x-major\n            color *= (n.x < 0.0 ? faceColors[0] : faceColors[1]);\n        } else if(ay > ax && ay > az){\n            \/\/y-major\n            color *= (n.y < 0.0 ? faceColors[2] : faceColors[3]);\n        } else {\n            \/\/z-major\n            color *= (n.z < 0.0 ? faceColors[4] : faceColors[5]);\n        }\n    #endif    \n    #endif\n\tfragColor = color;\n}\n","name":"","description":"","type":"image"}]}}