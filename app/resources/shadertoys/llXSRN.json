{"Shader":{"ver":"0.1","info":{"id":"llXSRN","date":"1434818929","viewed":663,"name":"1D Quadratic Uniform B-Spline","username":"demofox","description":"1D Quadratic B-Spline.  Mouse controls the yellow control point.<br\/>There are 4 control points A,B,C,D and implicitly 7 knots: [0,1,2,3,4,5,6]. Only time 2.0 through 4.0 are valid due to how bsplines work.<br\/>Signed distance used for rendering curve.","likes":0,"published":3,"flags":0,"tags":["2d","bspline"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/*\n\nMore info on b-splines and other curves here:\nhttp:\/\/www.ibiblio.org\/e-notes\/Splines\/Intro.htm\n\n*\/\n\n#define A  0.25\n#define B  (sin(iGlobalTime*1.5) * 0.5)\n#define C  (iMouse.z <= 0.0 ? 0.25 : iMouse.y \/ iResolution.y - 0.5)\n#define D  -0.1\n\n#define EDGE   0.005\n#define SMOOTH 0.0025\n\nfloat N_i_1 (in float t, in float i)\n{\n    \/\/ return 1 if i < t < i+1, else return 0\n    return step(i, t) * step(t,i+1.0);\n}\n\nfloat N_i_2 (in float t, in float i)\n{\n    return\n        N_i_1(t, i)       * (t - i) +\n        N_i_1(t, i + 1.0) * (i + 2.0 - t);\n}\n\nfloat N_i_3 (in float t, in float i)\n{\n    return\n        N_i_2(t, i)       * (t - i) \/ 2.0 +\n        N_i_2(t, i + 1.0) * (i + 3.0 - t) \/ 2.0;\n}\n\nfloat SplineValue(in float t)\n{\n    return\n        A * N_i_3(t, 0.0) +\n        B * N_i_3(t, 1.0) +\n        C * N_i_3(t, 2.0) +\n        D * N_i_3(t, 3.0);\n}\n\n\/\/ F(x,y) = F(x) - y\nfloat F ( in vec2 coords )\n{\n    \/\/ time in this curve goes from 0.0 to 6.0 but values\n    \/\/ are only valid between 2.0 and 4.0\n    float T = coords.x*2.0 + 2.0;\n    return SplineValue(T) - coords.y;\n}\n\n\/\/ signed distance function for F(x,y)\nfloat SDF( in vec2 coords )\n{\n    float v = F(coords);\n    float slope = dFdx(v) \/ dFdx(coords.x);\n    return abs(v)\/length(vec2(slope, -1.0));\n}\n\n\/\/ signed distance function for Circle, for control points\nfloat SDFCircle( in vec2 coords, in vec2 offset )\n{\n    coords -= offset;\n    float v = coords.x * coords.x + coords.y * coords.y - EDGE*EDGE;\n    vec2  g = vec2(2.0 * coords.x, 2.0 * coords.y);\n    return v\/length(g); \n}\n\n\/\/-----------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    float aspectRatio = iResolution.x \/ iResolution.y;\n    vec2 percent = ((fragCoord.xy \/ iResolution.xy) - vec2(0.25,0.5));\n    percent.x *= aspectRatio;\n\n    vec3 color = vec3(1.0,1.0,1.0);\n    float dist = SDFCircle(percent, vec2(0.0,A));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(1.0,0.0,0.0),vec3(1.0,1.0,1.0),dist);\n    }\n    \n    dist = SDFCircle(percent, vec2(0.33,B));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(0.0,1.0,0.0),vec3(1.0,1.0,1.0),dist);\n    }    \n    \n    dist = SDFCircle(percent, vec2(0.66,C));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(1.0,1.0,0.0),vec3(1.0,1.0,1.0),dist);\n    }    \n    \n    dist = SDFCircle(percent, vec2(1.0,D));\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(0.0,0.0,1.0),vec3(1.0,1.0,1.0),dist);\n    }      \n    \n    if (percent.x >= 0.0 && percent.x <= 1.0)\n    {\n    \tdist = SDF(percent);\n    \tif (dist < EDGE + SMOOTH)\n    \t{\n        \tdist = smoothstep(EDGE - SMOOTH,EDGE + SMOOTH,dist);\n        \tcolor *= vec3(dist);\n    \t}\n    }\n    \n\tfragColor = vec4(color,1.0);\n}\n","name":"","description":"","type":"image"}]}}