{"Shader":{"ver":"0.1","info":{"id":"MtlGRs","date":"1424495718","viewed":704,"name":"Efficiency Dots?","username":"Glyph","description":"I was playing around with the Android app version of Shadertoy and I found that my initial attempts at creating this effect were extremely slow. This is my attempt to make it as optimized as possible. Please tell me if you have tips. ","likes":0,"published":3,"flags":0,"tags":["optimization","dot","efficiency"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"vec4 finalcol;\nvec2 manres = vec2(1080.0,1920.0);\nuniform vec2 resolution;\nconst float dotw = 400.0;\nconst float dotwdmax = 30.0;\nconst float dotsep = 20.0;\nfloat pi = 3.14159265;\n\nfloat circle(vec2 origin,float radius,bool smooth){\n    if(!smooth){\n    return(step(length(origin),radius));\n    }else{\n        return(smoothstep(radius,0.0,length(origin)));\n    }\n}\n\nbool square(vec2 origin,float width){\n        return(origin.x < width && origin.x > -width && origin.y < width && origin.y > -width);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 mpoint = fragCoord.xy - iMouse.xy;\n\tfloat col = 0.0;\n    \n\tfor(float j=0.0;j < dotw;j+=dotsep){\n\t\tfor(float i = 0.0; i< dotw; i+=dotsep){\n        if(!square(mpoint,dotw\/2.0 + dotwdmax\/2.0)){\n            break;\n        }\n\t\tcol =+ circle(vec2(mpoint.x +-(dotw)\/2.0 +dotwdmax\/4.0 + i,mpoint.y +(dotw)\/2.0 -dotwdmax\/4.0 -j),8.0*abs(sin(iGlobalTime))+2.0,sign(sin(iGlobalTime)) > 0.0);\n    \tif(col != 0.0){\n     \t\tbreak;   \n    \t}\n\t}\n\t\tif(col != 0.0 || !square(mpoint,240.0)){\n     \tbreak;\n    \t}\n\t}\n    float sqc = 0.0;\n    if(square(mpoint,dotw\/2.0 + dotwdmax\/2.0)){\n      sqc = 1.0;   \n    }\n    \n\tfinalcol = vec4(col*abs(sin(iGlobalTime)) + sqc*0.0,col * abs(cos(iGlobalTime)),abs(sin(iGlobalTime + pi\/4.0)) * col,1.0);\n    fragColor=finalcol;\n}\n    ","name":"","description":"","type":"image"}]}}