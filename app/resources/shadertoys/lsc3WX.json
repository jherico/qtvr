{"Shader":{"ver":"0.1","info":{"id":"lsc3WX","date":"1452431928","viewed":131,"name":"Everyday010 - Gallery","username":"Makio64","description":"Shader gallery in shader on shadertoy ^.^","likes":2,"published":3,"flags":0,"tags":["simple","fbm","gallery","everyday"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Everyday010 - Gallery\n\/\/ By David Ronai \/ @Makio64\n\n\/\/------------------------------------------------------------------ VISUAL QUALITY\n#define POSTPROCESS\n#define RAYMARCHING_STEP 30\n#define RAYMARCHING_JUMP 1.\n\/\/------------------------------------------------------------------ DEBUG\n\/\/#define RENDER_DEPTH\n\/\/#define RENDER_NORMAL\n\/\/#define RENDER_AO\n\nconst float PI = 3.14159265359;\n\n\/\/------------------------------------------------------------------  OPERATIONS \/ PRIMITIVES\n\/\/http:\/\/mercury.sexy\/hg_sdf\/\nfloat vmax(vec2 v) { return max(v.x, v.y); }\nfloat vmax(vec3 v) { return max(max(v.x, v.y), v.z); }\nfloat fBox2Cheap(vec2 p, vec2 b) {return vmax(abs(p)-b);}\nfloat fBoxCheap(vec3 p, vec3 b) { return vmax(abs(p) - b);}\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)\/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n\/\/------------------------------------------------------------------ NOISE\n\nfloat hash(vec2 p){ return fract(21654.65155 * sin(35.51 * p.x + 45.51 * p.y));}\nfloat noise(vec2 p){\n\tvec2 fl = floor(p);\n\tvec2 fr = fract(p);\n\tfr.x = smoothstep(0.0,1.0,fr.x);\n\tfr.y = smoothstep(0.0,1.0,fr.y);\n\tfloat a = mix(hash(fl + vec2(0.0,0.0)), hash(fl + vec2(1.0,0.0)),fr.x);\n\tfloat b = mix(hash(fl + vec2(0.0,1.0)), hash(fl + vec2(1.0,1.0)),fr.x);\n\treturn mix(a,b,fr.y);\n}\nfloat fbm(vec2 x) {\n    float v = 0.0, a = 0.5;\n    vec2 shift = vec2(100);\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < 5; ++i) {\n        v += a * noise(x);\n        x = rot * x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nvec3 hsv2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb);\t\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\n\/\/------------------------------------------------------------------ MAP\nfloat map( in vec3 pos ) {\n    pMod1(pos.x,70.);\n    float d = fBoxCheap(pos,vec3(30.,20.,1.));\n    \t  d = min(fBoxCheap(pos+vec3(0.,0.,10.),vec3(10000.,10000.,2.)),d);\n    return d;\n}\n\n\/\/------------------------------------------------------------------ RAYMARCHING\n#ifdef RENDER_DEPTH\nfloat castRay( in vec3 ro, in vec3 rd, inout float depth )\n#else\nfloat castRay( in vec3 ro, in vec3 rd )\n#endif\n{\n\tfloat t = 0.0;\n\tfloat res;\n\tfor( int i=0; i<RAYMARCHING_STEP; i++ )\n\t{\n\t\tvec3 pos = ro+rd*t;\n\t\tres = map( pos );\n\t\tif( res < 0.01 || t > 200. ) break;\n\t\tt += res*RAYMARCHING_JUMP;\n\t\t#ifdef RENDER_DEPTH\n\t\tdepth += 1.\/float(RAYMARCHING_STEP);\n\t\t#endif\n\t}\n\treturn t;\n}\n\nvec3 calcNormal(vec3 p) {\n\tfloat eps = 0.01;\n\tconst vec3 v1 = vec3( 1.0,-1.0,-1.0);\n\tconst vec3 v2 = vec3(-1.0,-1.0, 1.0);\n\tconst vec3 v3 = vec3(-1.0, 1.0,-1.0);\n\tconst vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\treturn normalize( v1 * map( p + v1*eps ) +\n\t\t\t\t\t  v2 * map( p + v2*eps ) +\n\t\t\t\t\t  v3 * map( p + v3*eps ) +\n\t\t\t\t\t  v4 * map( p + v4*eps ) );\n}\n\nfloat hash( float n ){\n\treturn fract(sin(n)*3538.5453);\n}\n\nfloat calcAO( in vec3 p, in vec3 n, float maxDist, float falloff ){\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = n*l;\n\t\tao += (l - map( p + rd )) \/ pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao\/float(nbIte), 0., 1.);\n}\n\n\/\/ calculate local thickness\n\/\/ base on AO but : inverse the normale & inverse the color\nfloat thickness( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = -n*l;\n\t\tao += (l + map( p + rd )) \/ pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao\/float(nbIte), 0., 1.);\n}\n\n\/\/------------------------------------------------------------------ POSTEFFECTS\n\n#ifdef POSTPROCESS\nvec3 postEffects( in vec3 col, in vec2 uv, in float time )\n{\n\t\/\/ vigneting\n\tcol *= 0.5+0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.5 );\n\treturn col;\n}\n#endif\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv )\n{\n\tvec3 col = vec3(.0,.0,1.2);\n\n\t#ifdef RENDER_DEPTH\n\tfloat depth = 0.;\n\tfloat t = castRay(ro,rd,depth);\n\t#else\n\tfloat t = castRay(ro,rd);\n\t#endif\n\n\t#ifdef RENDER_DEPTH\n\treturn vec3(depth\/10.,depth\/5.,depth);\n\t#endif\n\n\tvec3 pos = ro + t * rd;\n\tvec3 nor = calcNormal(pos);\n\n\t#ifdef RENDER_NORMAL\n\treturn nor;\n\t#endif\n\n\tfloat ao = calcAO(pos,nor,15.,1.4);\n\t#ifdef RENDER_AO\n\treturn vec3(ao);\n\t#endif\n\n\tcol = vec3(1.)*max(0.,dot(nor,vec3(.0,.0,1.)));\n    uv.x += iGlobalTime\/3.;\n    uv *= 10.;\n    if(pos.z>1.){\n\t\tcol *= .2*vec3(fbm(vec2(noise(uv+sin(iGlobalTime))+iGlobalTime)));\n    \tuv *= 1.5;\n\t\tcol += .35*vec3(fbm(vec2(noise(uv+vec2(0.,iGlobalTime\/2.))+iGlobalTime\/2.+20.)));\n\t    uv *= 1.2;\n\t\tcol += .45*vec3(fbm(vec2(noise(uv+vec2(0.,iGlobalTime\/4.))+iGlobalTime\/3.+100.)));\n    \tcol*=col*1.9;\n    \tcol*= hsv2rgb(vec3(.6+.2*cos(uv.y\/10.+iGlobalTime*1.2),.1+.4*sin(uv.x\/5.+iGlobalTime*.2),1.));\n    \tcol*= 1.5;\n    }\n\tcol *= ao;\n\n\treturn col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\treturn mat3( cu, cv, cw );\n}\n\nvec3 orbit(float phi, float theta, float radius)\n{\n\treturn vec3(\n\t\tradius * sin( phi ) * cos( theta ),\n\t\tradius * cos( phi ),\n\t\tradius * sin( phi ) * sin( theta )\n\t);\n}\n\n\/\/------------------------------------------------------------------ MAIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec2 p = -1. + 2. * uv;\n    p.x *= iResolution.x \/ iResolution.y;\n    \n    \/\/Camera\n\tfloat radius = 80.;\n\tvec3 ro = orbit(PI\/2.-.2*sin(iGlobalTime),PI\/2.,radius);\n    ro.x += iGlobalTime*40.;\n\tvec3 ta  = vec3(iGlobalTime*40.,0.,0.);\n\tmat3 ca = setCamera( ro, ta, 0. );\n\tvec3 rd = ca * normalize( vec3(p.xy,1.5) );\n\n\t\/\/ Raymarching\n\tvec3 color = render( ro, rd, uv );\n\t#ifdef POSTPROCESS\n\tcolor = postEffects( color, uv, iGlobalTime );\n\t#endif\n\tfragColor = vec4(color,1.0);\n}","name":"","description":"","type":"image"}]}}