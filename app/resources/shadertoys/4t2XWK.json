{"Shader":{"ver":"0.1","info":{"id":"4t2XWK","date":"1446535518","viewed":1143,"name":"Normals Compression","username":"iq","description":"Compressing normals by using Spherical Fibonacci points, as described by this paper <a href=\"http:\/\/lgdv.cs.fau.de\/uploads\/publications\/spherical_fibonacci_mapping_opt.pdf\"  class=\"regular\" target=\"_blank\">http:\/\/lgdv.cs.fau.de\/uploads\/publications\/spherical_fibonacci_mapping_opt.pdf<\/a>","likes":23,"published":3,"flags":0,"tags":["3d","normals","compression"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\/\/ Compressing normals by using Spherical Fibonacci points, as described by this paper\n\/\/ by Benjamin Keinert, Matthias Innmann, Michael Sanger and Marc Stamminger\n\n\/\/ The digits indicate the number of bits used to encode the normal. At 16 bits the  normals \n\/\/ look pretty good for this model and view distance (I added some specular to the shading so\n\/\/ that normal compression artifacts would be more obvious). That means that the compression\n\/\/ ratio would be of 6x (for a regular vec3 normal). With 12 bits the quality is pretty decent,\n\/\/ and the compression would be 8x.\n\n\/\/ The lack of 2D coherency makes it less efficient for compression of normals for disk-storage \n\/\/ of meshes or normalmaps though, where the current normal could be predicted from the previous \n\/\/ or neighboring normals. But for bast indexing \/ constant bitrate kind of compression scenarios\n\/\/ (compact vertex format for rendering) it's perfec!\n\n\/\/ Can somebody investigate a 2D hilbert curve maybe? That would be killer.\n\n\/\/ Check https:\/\/www.shadertoy.com\/view\/lllXz4 for a simpler version of the code below.\n\n\n\/\/=================================================================================================\n\/\/ http:\/\/lgdv.cs.fau.de\/uploads\/publications\/spherical_fibonacci_mapping_opt.pdf\n\/\/=================================================================================================\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float PHI = 1.6180339887498948482045868343656;\n\nfloat round( float x ) { return floor(x+0.5); }\nfloat madfrac( float a,float b) { return a*b -floor(a*b); }\nvec2  madfrac( vec2 a, float b) { return a*b -floor(a*b); }\n\nfloat sf2id(vec3 p, float n) \n{\n    float phi = min(atan(p.y, p.x), PI), cosTheta = p.z;\n    \n    float k  = max(2.0, floor( log(n * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))\/ log(PHI*PHI)));\n    float Fk = pow(PHI, k)\/sqrt(5.0);\n    \n    vec2 F = vec2( round(Fk), round(Fk * PHI) );\n\n    vec2 ka = -2.0*F\/n;\n    vec2 kb = 2.0*PI*madfrac(F+1.0, PHI-1.0) - 2.0*PI*(PHI-1.0);    \n    mat2 iB = mat2( ka.y, -ka.x, -kb.y, kb.x ) \/ (ka.y*kb.x - ka.x*kb.y);\n\n    vec2 c = floor( iB * vec2(phi, cosTheta - (1.0-1.0\/n)));\n    float d = 8.0;\n    float j = 0.0;\n    for( int s=0; s<4; s++ ) \n    {\n        vec2 uv = vec2( float(s-2*(s\/2)), float(s\/2) );\n        \n        float cosTheta = dot(ka, uv + c) + (1.0-1.0\/n);\n        \n        cosTheta = clamp(cosTheta, -1.0, 1.0)*2.0 - cosTheta;\n        float i = floor(n*0.5 - cosTheta*n*0.5);\n        float phi = 2.0*PI*madfrac(i, PHI-1.0);\n        cosTheta = 1.0 - (2.0*i + 1.0)\/n;\n        float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n        \n        vec3 q = vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta);\n        float squaredDistance = dot(q-p, q-p);\n        if (squaredDistance < d) \n        {\n            d = squaredDistance;\n            j = i;\n        }\n    }\n    return j;\n}\n\nvec3 id2sf( float i, float n) \n{\n    float phi = 2.0*PI*madfrac(i,PHI);\n    float zi = 1.0 - (2.0*i+1.0)\/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\n\n\/\/=================================================================================================\n\/\/ digit drawing function by P_Malin (https:\/\/www.shadertoy.com\/view\/4sf3RN)\n\/\/=================================================================================================\nfloat SampleDigit(const in float n, const in vec2 vUV)\n{\t\t\n\tif(vUV.x  < 0.0) return 0.0;\n\tif(vUV.y  < 0.0) return 0.0;\n\tif(vUV.x >= 1.0) return 0.0;\n\tif(vUV.y >= 1.0) return 0.0;\n\t\n\tfloat data = 0.0;\n\t\n\t     if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n\telse if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n\telse if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\t\n\tvec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n\tfloat fIndex = vPixel.x + (vPixel.y * 4.0);\n\t\n\treturn mod(floor(data \/ pow(2.0, fIndex)), 2.0);\n}\n\nfloat PrintInt( in vec2 uv, in float value )\n{\n\tfloat res = 0.0;\n\tfloat maxDigits = 1.0+ceil(.01+log2(value)\/log2(10.0));\n\tfloat digitID = floor(uv.x);\n\tif( digitID>0.0 && digitID<maxDigits )\n\t{\n        float digitVa = mod( floor( value\/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n        res = SampleDigit( digitVa, vec2(fract(uv.x), uv.y) );\n\t}\n\n\treturn res;\t\n}\n\n\/\/=================================================================================================\n\/\/ all iq code below\n\/\/=================================================================================================\n\nfloat map( vec3 p )\n{\n    p.xz *= 0.8;\n    p.xyz += 1.000*sin(  2.0*p.yzx );\n    p.xyz -= 0.500*sin(  4.0*p.yzx );\n    float d = length( p.xyz ) - 1.5;\n\treturn d * 0.25;\n}\n\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 7.0;\n\n\tfloat precis = 0.001;\n    float h = 1.0;\n    float t = 1.0;\n    for( int i=0; i<256; i++ )\n    {\n        if( (h<precis) || (t>maxd) ) break;\n\t    h = map( ro+rd*t );\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n\treturn t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    \/\/ from Paul Malin (4 samples only in a tetrahedron\t\n    vec2 e = vec2(1.0,-1.0)*0.002;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in vec2 pix )\n{\n\tfloat ao = 0.0;\n    for( int i=0; i<128; i++ )\n    {\n        vec3 ap = id2sf( float(i), 128.0 );\n\t\tap *= sign( dot(ap,nor) ) * hash1(float(i));\n        ao += clamp( map( pos + nor*0.05 + ap*1.0 )*32.0, 0.0, 1.0 );\n    }\n\tao \/= 128.0;\n\t\n    return clamp( ao*ao, 0.0, 1.0 );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy+2.0*fragCoord.xy)\/iResolution.y;\n\tvec2 q = fragCoord\/iResolution.xy;\n\t\n    \/\/-----------------------------------------------------\n\n\n    float ti = mod( 0.25*iGlobalTime, 8.0 );\n    float am = clamp( ti\/3.0, 0.0, 1.0 ) - clamp( (ti-4.0)\/3.0, 0.0, 1.0 );\n    float bits = 1.0 + floor(15.0*am);\n    float precis = pow(2.0,bits);\n    \n    \/\/-----------------------------------------------------\n\t\n\tfloat an = 4.0 + 0.1*iGlobalTime;\n    \n\tvec3 ro = vec3(4.5*sin(an),2.0,4.5*cos(an));\n    vec3 ta = vec3(0.0,0.0,0.0);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = normalize( ca * vec3(p,-1.5) );\n\n    \/\/-----------------------------------------------------\n    \n\tvec3 col = vec3(0.07)*clamp(1.0-length(q-0.5),0.0,1.0);\n\n    float t = intersect(ro,rd);\n    if( t>0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\t\tvec3 ref = reflect( rd, nor );\n        vec3 sor = nor;\n        \n        \/\/ compress normal\n        float id = sf2id( nor, precis );\n        \n        \/\/ decompress normal\n        nor = id2sf( id, precis);\n        \n        nor = (p.x>0.0) ? nor : sor;\n\n        \/\/ material\n\t\tcol = vec3(0.2);\n        col *= 1.0 + 0.5*nor;\n\n        \n\t\t\/\/ lighting\n\t\tfloat occ = calcAO( pos, nor, fragCoord ); occ = occ*occ;\n        float sky = 0.5 + 0.5*nor.y;\n        float fre = clamp( 1.0 + dot(nor,rd), 0.0, 1.0 );\n        float spe = pow(max( dot(-rd,nor),0.0),32.0);\n\t\t\/\/ lights\n\t\tvec3 lin  = vec3(0.0);\n\t\t     lin += 3.0*vec3(0.7,0.80,1.00)*sky*occ;\n        \t lin += 8.0*vec3(0.7,0.8,1.00)*smoothstep(0.0,0.2,ref.y)*(0.1+0.9*pow(fre,5.0))*sky*occ;\n             lin += 1.0*fre*vec3(1.0,0.90,0.80)*(0.1+0.9*occ);\n        col = col * lin;\n        col += 0.50*spe*occ;\n        col += 0.15*spe*spe*spe*occ;\n\t}\n\n\t\n\tcol = sqrt(col);\n    \n    col += PrintInt( (q-vec2(0.7,0.75))*12.0*vec2(1.0,iResolution.y\/iResolution.x), bits );\n\n    col *= smoothstep( 0.003,0.004,abs(q.x-0.5) );\n\n    fragColor = vec4( col, 1.0 );\n}\n","name":"","description":"","type":"image"}]}}