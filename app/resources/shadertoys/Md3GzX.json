{"Shader":{"ver":"0.1","info":{"id":"Md3GzX","date":"1454041170","viewed":130,"name":"Photoshop Blends Branchless ","username":"poljere","description":"Photoshop blending modes branchless. <br\/>Keys A-Z: screen, mult, overlay, hardlight, softlight, color(Dodge\/Burn), linear(Dodge\/Burn), vividLight, linearLight, pinLight, hardMix, subs, div, add, diff, darken, lighten, inv, invRGB, hue, sat, col, lum, blend.","likes":7,"published":3,"flags":48,"tags":["2d","rgb","blending","branchless","ui","photoshop","hsl","colorspace","multipass","modes"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":260,"src":"\/presets\/previz\/buffer03.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Pol Jeremias - poljere\/2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\/\/\n\/\/ Implementation of the most common Photoshop blending modes in a branchless way,\n\/\/ which means, no ifs in the BLENDING code, very friendly for the gpus!\n\/\/ Currently, this shader supports 26 blending methods. Check the\n\/\/ list below to find out what key to press to enable what mode.\n\/\/\n\/\/\n\/\/ Here is the mapping :\n\/\/\n\/\/\n\/\/   q : Screen        a : Linear Light  z : Invert\n\/\/   w : Multiply      s : Pin Light     x : InvertRGB\n\/\/   e : Overlay       d : Hard Mix      c : Hue *\n\/\/   r : Hard Light    f : Subtract      v : Saturation *\n\/\/   t : Soft Light    g : Divide        b : Color *\n\/\/   y : Color Dodge   h : Additive      n : Luminosity *\n\/\/   u : Color Burn    j : Difference    m : Exclusion\n\/\/   i : Linear Dodge  k : Darker\n\/\/   o : Linear Burn   l : Lighten\n\/\/   p : Vivid Light \n\/\/\n\/\/\n\/\/ SOURCES :\n\/\/\n\/\/ Photoshop help   : https:\/\/helpx.adobe.com\/photoshop\/using\/blending-modes.html\n\/\/ Wikipedia!       : https:\/\/en.wikipedia.org\/wiki\/Blend_modes\n\/\/ NVIDIA           : https:\/\/www.opengl.org\/registry\/specs\/NV\/blend_equation_advanced.txt\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ UI PASS\n\/\/ This pass will render the frame already blended with UI on top.\n\/\/ Thanks Flyguy for the font rendering(https:\/\/www.shadertoy.com\/view\/XtsGRl)\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\n#define CHAR_SIZE vec2(3, 7)\n#define CHAR_SPACING vec2(4, 8)\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\n\/*\nTop left pixel is the most significant bit.\nBottom right pixel is the least significant bit.\n\n \u2588     010    \n\u2588 \u2588    101    \n\u2588 \u2588    101    \n\u2588\u2588\u2588 -> 111 -> 010 101 101 111 101 101 101 -> 712557\n\u2588 \u2588    101    \n\u2588 \u2588    101    \n\u2588 \u2588    101    \n*\/\n\n\/\/Automatically generated from a sprite sheet.\nconst float ch_sp = 0.0;\nconst float ch_a = 712557.0;\nconst float ch_b = 1760622.0;\nconst float ch_c = 706858.0;\nconst float ch_d = 1760110.0;\nconst float ch_e = 2018607.0;\nconst float ch_f = 2018596.0;\nconst float ch_g = 706922.0;\nconst float ch_h = 1498989.0;\nconst float ch_i = 1909911.0;\nconst float ch_j = 1872746.0;\nconst float ch_k = 1498477.0;\nconst float ch_l = 1198375.0;\nconst float ch_m = 1571693.0;\nconst float ch_n = 1760109.0;\nconst float ch_o = 711530.0;\nconst float ch_p = 711972.0;\nconst float ch_q = 711675.0;\nconst float ch_r = 1760621.0;\nconst float ch_s = 2018927.0;\nconst float ch_t = 1909906.0;\nconst float ch_u = 1497963.0;\nconst float ch_v = 1497938.0;\nconst float ch_w = 1498109.0;\nconst float ch_x = 1496429.0;\nconst float ch_y = 1496210.0;\nconst float ch_z = 2004271.0;\nconst float ch_1 = 730263.0;\nconst float ch_2 = 693543.0;\nconst float ch_3 = 693354.0;\nconst float ch_4 = 1496649.0;\nconst float ch_5 = 1985614.0;\nconst float ch_6 = 707946.0;\nconst float ch_7 = 1873042.0;\nconst float ch_8 = 709994.0;\nconst float ch_9 = 710250.0;\nconst float ch_0 = 711530.0;\nconst float ch_per = 2.0;\nconst float ch_que = 693378.0;\nconst float ch_exc = 599170.0;\nconst float ch_com = 10.0;\nconst float ch_scl = 65556.0;\nconst float ch_col = 65552.0;\nconst float ch_usc = 7.0;\nconst float ch_crs = 11904.0;\nconst float ch_dsh = 3584.0;\nconst float ch_ast = 21824.0;\nconst float ch_fsl = 304292.0;\nconst float ch_bsl = 1189001.0;\nconst float ch_lpr = 346385.0;\nconst float ch_rpr = 1118804.0;\nconst float ch_lba = 862355.0;\nconst float ch_rpa = 1647254.0;\nvec2 print_pos = vec2(0,0);\n\n\/\/ Memory locations\nvec2 memLocMode = vec2(0.0, 0.0);\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Memory Management\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nvec4 load(in vec2 fragCoordRead)\n{\n    return texture2D(iChannel0, (0.5 + fragCoordRead) \/ iChannelResolution[0].xy, -100.0 );\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Char drawing\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/Extracts bit b from the given number.\nfloat extract_bit(float n, float b)\n{\n\treturn floor(mod(floor(n \/ pow(2.0,floor(b))),2.0));   \n}\n\n\/\/Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(float spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    \/\/Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    \/\/Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0)));\n    bounds = bounds && all(lessThan(uv,size));\n    \n    return bounds ? extract_bit(spr, bit) : 0.0;\n}\n\n\/\/Prints a character and moves the print position forward by 1 character width.\nfloat char(float ch, vec2 uv)\n{\n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\nvoid draw(inout vec4 c, vec2 fragCoord, int mode) \n{   \n\tvec2 uv = floor(fragCoord.xy \/ 2.0);\n    print_pos = vec2(75, 2.0);\n    c += vec4(0.3) * (char(ch_c, uv) + char(ch_h, uv) + char(ch_a, uv) + char(ch_n, uv) +\n         char(ch_g, uv) + char(ch_e, uv) + char(ch_sp, uv) + char(ch_m, uv)+\n         char(ch_o, uv) + char(ch_d, uv) + char(ch_e, uv) + char(ch_sp, uv)+ \n         char(ch_k, uv) + char(ch_e, uv) + char(ch_y, uv) + char(ch_s, uv) + \n         char(ch_sp, uv)+ char(ch_a, uv) + char(ch_dsh, uv) + char(ch_z, uv));\n    \n    uv = floor(fragCoord.xy \/ 2.0);\n    print_pos = vec2(2.0, 2.0);\n    c += char(ch_m,  uv) + char(ch_o,  uv) + char(ch_d,  uv) + char(ch_e,  uv) + char(ch_sp, uv);\n    \n    \/\/if(mode==0){\n    \/\/    c += char(ch_s,  uv) + char(ch_r,  uv) + char(ch_c,  uv);        \n    \/\/} else if(mode==1) {\n    \/\/    c += char(ch_d,  uv) + char(ch_s,  uv) + char(ch_t,  uv);\n    \/\/} else \n    if(mode==0) {             \/\/ SCREEN\n        c += char(ch_s,  uv) + char(ch_c,  uv) + char(ch_r,  uv) + \n             char(ch_e,  uv) + char(ch_e,  uv) + char(ch_n,  uv);\n    }\n    if(mode==1) {       \/\/ MULTIPLY\n        c += char(ch_m,  uv) + char(ch_u,  uv) + char(ch_l,  uv) + \n             char(ch_t,  uv);\n    }\n    if(mode==2) {       \/\/ OVERLAY\n        c += char(ch_o,  uv) + char(ch_v,  uv) + char(ch_e,  uv) +\n             char(ch_r,  uv) + char(ch_l,  uv) + char(ch_a,  uv) +\n             char(ch_y,  uv);\n    }\n    if(mode==3) {       \/\/ HARDLIGHT\n        c += char(ch_h,  uv) + char(ch_a,  uv) + char(ch_r,  uv) + \n             char(ch_d,  uv) + char(ch_l,  uv) + char(ch_i,  uv) + \n             char(ch_g,  uv) + char(ch_h,  uv) + char(ch_t,  uv);\n    }\n    if(mode==4) {       \/\/ SOFTLIGHT\n        c += char(ch_s,  uv) + char(ch_o,  uv) + char(ch_f,  uv) + \n             char(ch_t,  uv) + char(ch_l,  uv) + char(ch_i,  uv) + \n             char(ch_g,  uv) + char(ch_h,  uv) + char(ch_t,  uv);\n    }\n    if(mode==5) {       \/\/ COLORDODGE\n        c += char(ch_c,  uv) + char(ch_o,  uv) + char(ch_l,  uv) + \n             char(ch_o,  uv) + char(ch_r,  uv) + char(ch_d,  uv) + \n             char(ch_o,  uv) + char(ch_d,  uv) + char(ch_g,  uv) +\n             char(ch_e,  uv);        \n    } \n    if(mode==6) {       \/\/ COLORBURN\n        c += char(ch_c,  uv) + char(ch_o,  uv) + char(ch_l,  uv) + \n             char(ch_o,  uv) + char(ch_r,  uv) + char(ch_b,  uv) + \n             char(ch_u,  uv) + char(ch_r,  uv) + char(ch_n,  uv);\n    } \n    if(mode==7) {       \/\/ LINEARDODGE\n        c += char(ch_l,  uv) + char(ch_i,  uv) + char(ch_n,  uv) + \n             char(ch_e,  uv) + char(ch_a,  uv) + char(ch_r,  uv) + \n             char(ch_d,  uv) + char(ch_o,  uv) + char(ch_d,  uv) + \n             char(ch_g,  uv) + char(ch_e,  uv);        \n    } \n    if(mode==8) {       \/\/ LINEARBURN\n        c += char(ch_l,  uv) + char(ch_i,  uv) + char(ch_n,  uv) + \n             char(ch_e,  uv) + char(ch_a,  uv) + char(ch_r,  uv) + \n             char(ch_b,  uv) + char(ch_u,  uv) + char(ch_t,  uv) + \n             char(ch_n,  uv); \n    } \n    if(mode==9) {       \/\/ VIVIDLIGHT\n        c += char(ch_v,  uv) + char(ch_i,  uv) + char(ch_v,  uv) + \n             char(ch_i,  uv) + char(ch_d,  uv) + char(ch_l,  uv) + \n             char(ch_i,  uv) + char(ch_g,  uv) + char(ch_h,  uv) + \n             char(ch_t,  uv); \n    } \n    if(mode==10) {      \/\/ LINEARLIGHT\n        c += char(ch_l,  uv) + char(ch_i,  uv) + char(ch_n,  uv) + \n             char(ch_e,  uv) + char(ch_a,  uv) + char(ch_r,  uv) + \n             char(ch_l,  uv) + char(ch_i,  uv) + char(ch_g,  uv) + \n             char(ch_h,  uv) + char(ch_t,  uv);        \n    } \n    if(mode==11) {      \/\/ PINLIGHT\n        c += char(ch_p,  uv) + char(ch_i,  uv) + char(ch_n,  uv) +\n             char(ch_l,  uv) + char(ch_i,  uv) + char(ch_g,  uv) +\n             char(ch_h,  uv) + char(ch_t,  uv);  \n    } \n    if(mode==12) {      \/\/ HARDMIX\n        c += char(ch_h,  uv) + char(ch_a,  uv) + char(ch_r,  uv) + \n             char(ch_d,  uv) + char(ch_m,  uv) + char(ch_i,  uv) + \n             char(ch_x,  uv);        \n    } \n    if(mode==13) {      \/\/ SUBTRACT\n        c += char(ch_s,  uv) + char(ch_u,  uv) + char(ch_b,  uv) +\n             char(ch_t,  uv) + char(ch_r,  uv) + char(ch_a,  uv) +\n             char(ch_c,  uv) + char(ch_t,  uv);\n    } \n    if(mode==14) {     \/\/ DIVIDE\n        c += char(ch_d,  uv) + char(ch_i,  uv) + char(ch_v,  uv) + \n             char(ch_i,  uv) + char(ch_d,  uv) + char(ch_e,  uv);\n    } \n    if(mode==15) {     \/\/ ADDITION\n        c += char(ch_a,  uv) + char(ch_d,  uv) + char(ch_d,  uv);\n    } \n    if(mode==16) {     \/\/ DIFFERENCE\n        c += char(ch_d,  uv) + char(ch_i,  uv) + char(ch_f,  uv) +\n             char(ch_f,  uv);\n    } \n    if(mode==17) {     \/\/ DARKEN\n        c += char(ch_d,  uv) + char(ch_a,  uv) + char(ch_r,  uv) + \n             char(ch_k,  uv) + char(ch_e,  uv) + char(ch_n,  uv);\n    } \n    if(mode==18) {     \/\/ LIGHTEN\n        c += char(ch_l,  uv) + char(ch_i,  uv) + char(ch_g,  uv) + \n             char(ch_h,  uv) + char(ch_t,  uv) + char(ch_e,  uv) + \n             char(ch_n,  uv);\n    } \n    if(mode==19) {     \/\/ INVERT\n        c += char(ch_i,  uv) + char(ch_n,  uv) + char(ch_v,  uv) + \n             char(ch_e,  uv) + char(ch_r,  uv) + char(ch_t,  uv);\n    } \n    if(mode==20) {     \/\/ INVERTRGB\n        c += char(ch_i,  uv) + char(ch_n,  uv) + char(ch_v,  uv) + \n             char(ch_e,  uv) + char(ch_r,  uv) + char(ch_t,  uv) + \n             char(ch_r,  uv) + char(ch_g,  uv) + char(ch_b,  uv);\n    } \n    if(mode==21) {     \/\/ HUE\n        c += char(ch_h,  uv) + char(ch_u,  uv) + char(ch_e,  uv);\n    } \n    if(mode==22) {     \/\/ SATURATION\n        c += char(ch_s,  uv) + char(ch_a,  uv) + char(ch_t,  uv) + \n             char(ch_u,  uv) + char(ch_r,  uv) + char(ch_a,  uv) + \n             char(ch_t,  uv) + char(ch_i,  uv) + char(ch_o,  uv) + \n             char(ch_n,  uv);\n    } \n    if(mode==23) {     \/\/ COLOR\n        c += char(ch_c,  uv) + char(ch_o,  uv) + char(ch_l,  uv) + \n             char(ch_o,  uv) + char(ch_r,  uv);\n    } \n    if(mode==24) {     \/\/ LUMINOSITY\n        c += char(ch_l,  uv) + char(ch_u,  uv) + char(ch_m,  uv) + \n             char(ch_i,  uv) + char(ch_n,  uv) + char(ch_o,  uv) + \n             char(ch_s,  uv) + char(ch_i,  uv) + char(ch_t,  uv) +\n             char(ch_y,  uv);\n    }\n    if(mode==25) {     \/\/ EXCLUSION\n        c += char(ch_e,  uv) + char(ch_x,  uv) + char(ch_c,  uv) + \n             char(ch_l,  uv) + char(ch_u,  uv) + char(ch_s,  uv) + \n             char(ch_i,  uv) + char(ch_o,  uv) + char(ch_n,  uv);\n    }\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ MAIN\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    \n    \/\/ Read final frame\n\tvec4 c = vec4(texture2D(iChannel1, uv).xyz,1.0);\n\n    \/\/ Read the current mode\n    int mode = int( load(memLocMode).x );    \n    \n    \/\/ Draw the banner\n    float b = 1.0 - step( 320.0, fragCoord.x);\n    b *= 1.0 - step(25.0, fragCoord.y);\n    c = mix( c, c *0.5, b);\n    \n    \/\/ Draw text\n    draw(c, fragCoord, mode);\n    \n    fragColor = c;\n}\n","name":"","description":"","type":"image"},{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Pol Jeremias - 2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ KEYBOARD PASS\n\/\/ This pass will read from the keyboard which of the passes\n\/\/ is the current active one and store that information \n\/\/ in the buffer\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\n\/\/ Keyboard constants definition\nconst float KEY_A     = 65.5\/256.0;\nconst float KEY_B     = 66.5\/256.0;\nconst float KEY_C     = 67.5\/256.0;\nconst float KEY_D     = 68.5\/256.0;\nconst float KEY_E     = 69.5\/256.0;\nconst float KEY_F     = 70.5\/256.0;\nconst float KEY_G     = 71.5\/256.0;\nconst float KEY_H     = 72.5\/256.0;\nconst float KEY_I     = 73.5\/256.0;\nconst float KEY_J     = 74.5\/256.0;\nconst float KEY_K     = 75.5\/256.0;\nconst float KEY_L     = 76.5\/256.0;\nconst float KEY_M     = 77.5\/256.0;\nconst float KEY_N     = 78.5\/256.0;\nconst float KEY_O     = 79.5\/256.0;\nconst float KEY_P     = 80.5\/256.0;\nconst float KEY_Q     = 81.5\/256.0;\nconst float KEY_R     = 82.5\/256.0;\nconst float KEY_S     = 83.5\/256.0;\nconst float KEY_T     = 84.5\/256.0;\nconst float KEY_U     = 85.5\/256.0;\nconst float KEY_V     = 86.5\/256.0;\nconst float KEY_W     = 87.5\/256.0;\nconst float KEY_X     = 88.5\/256.0;\nconst float KEY_Y     = 89.5\/256.0;\nconst float KEY_Z     = 90.5\/256.0;\n\n\/\/ Memory locations\nvec2 memLocMode = vec2(0.0, 0.0);\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Memory Management\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec4 load(in vec2 fragCoordRead)\n{\n    return texture2D(iChannel0, (0.5 + fragCoordRead) \/ iChannelResolution[0].xy, -100.0 );\n}\n\nfloat isInside( vec2 p, vec2 c ) \n{ \n    vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); \n}\n\nvoid store( in vec2 fragCoordWrite, in vec4 value, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = (isInside(fragCoord, fragCoordWrite) > 0.0) ? value : fragColor;\n}\n\nfloat isKeyPressed(float key)\n{\n\treturn texture2D( iChannel1, vec2(key, 0.5) ).x;\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Keyboard reads and stores\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ Read the last mode selected\n    float mode = load(memLocMode).x;\n    \n    \/\/ Initialize variables\n    if (iFrame == 0)\n    {\n        mode = 0.0;\n    }\n    \n    \/\/ Check if the user has changed selection\n    if(isKeyPressed(KEY_Q) > 0.0) mode = 0.0;\n    if(isKeyPressed(KEY_W) > 0.0) mode = 1.0;\n\tif(isKeyPressed(KEY_E) > 0.0) mode = 2.0;\n\tif(isKeyPressed(KEY_R) > 0.0) mode = 3.0;\n    if(isKeyPressed(KEY_T) > 0.0) mode = 4.0;\n    if(isKeyPressed(KEY_Y) > 0.0) mode = 5.0;\n    if(isKeyPressed(KEY_U) > 0.0) mode = 6.0;\n    if(isKeyPressed(KEY_I) > 0.0) mode = 7.0;\n    if(isKeyPressed(KEY_O) > 0.0) mode = 8.0;\n    if(isKeyPressed(KEY_P) > 0.0) mode = 9.0;\n    if(isKeyPressed(KEY_A) > 0.0) mode = 10.0;\n    if(isKeyPressed(KEY_S) > 0.0) mode = 11.0;\n    if(isKeyPressed(KEY_D) > 0.0) mode = 12.0;\n    if(isKeyPressed(KEY_F) > 0.0) mode = 13.0;\n    if(isKeyPressed(KEY_G) > 0.0) mode = 14.0;\n    if(isKeyPressed(KEY_H) > 0.0) mode = 15.0;\n    if(isKeyPressed(KEY_J) > 0.0) mode = 16.0;\n    if(isKeyPressed(KEY_K) > 0.0) mode = 17.0;\n    if(isKeyPressed(KEY_L) > 0.0) mode = 18.0;\n    if(isKeyPressed(KEY_Z) > 0.0) mode = 19.0;\n    if(isKeyPressed(KEY_X) > 0.0) mode = 20.0;\n    if(isKeyPressed(KEY_C) > 0.0) mode = 21.0;\n    if(isKeyPressed(KEY_V) > 0.0) mode = 22.0;\n    if(isKeyPressed(KEY_B) > 0.0) mode = 23.0;\n    if(isKeyPressed(KEY_N) > 0.0) mode = 24.0;\n    if(isKeyPressed(KEY_M) > 0.0) mode = 25.0;\n    \n    \/\/ Store key press in the texture\n\tstore(memLocMode, vec4(mode), fragColor, fragCoord);\n}","name":"","description":"","type":"buffer"},{"inputs":[{"id":5,"src":"\/presets\/tex04.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Pol Jeremias - 2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ SOURCE PASS\n\/\/ This pass will output the frame to be blended as the SOURCE\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n\tfragColor = vec4(texture2D(iChannel0, uv).xyz, 1.0);\n}\n","name":"","description":"","type":"buffer"},{"inputs":[{"id":1,"src":"\/presets\/tex00.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Pol Jeremias - 2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ DST PASS\n\/\/ This pass will output the frame to be blended as DST\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n\tfragColor = vec4(texture2D(iChannel0, uv).xyz, 1.0);\n}","name":"","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":259,"src":"\/presets\/previz\/buffer02.png","ctype":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Pol Jeremias - 2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ BLENDING PASS\n\/\/ Blending code is here! \n\/\/ This pass will blend between pass B and pass C.\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\nvec3 multiply(in vec3 src, in vec3 dst)\n{\n\treturn src * dst;\n}\n\nvec3 screen(in vec3 src, in vec3 dst)\n{\n    return src + dst - src * dst;\n}\n\nvec3 exclusion(in vec3 src, in vec3 dst)\n{\n    return dst + src - (2.0*dst*src);;\n}\n\nvec3 overlay(in vec3 src, in vec3 dst)\n{\n    return mix(2.0 * src * dst, 1.0 - 2.0 * (1.0 - src) * (1.0-dst), step(0.5, dst));\n}\n\nvec3 hardlight(in vec3 src, in vec3 dst)\n{\n    return mix(2.0 * src * dst,  1.0 - 2.0 * (1.0 - src) * (1.0-dst), step(0.5, src));\n}\n\nvec3 softlight(in vec3 src, in vec3 dst)\n{\n    return mix(dst - (1.0 - 2.0 * src) * dst * (1.0 - dst), \n               mix(dst + ( 2.0 * src - 1.0 ) * (sqrt(dst) - dst),\n                   dst + (2.0 * src - 1.0) * dst * ((16.0 * dst - 12.0) * dst + 3.0),\n                   step(0.5, src) * (1.0 - step(0.25, dst))),\n               step(0.5, src));\n}\n\nvec3 colorDodge(in vec3 src, in vec3 dst)\n{\n    return step(0.0, dst) * mix(min(vec3(1.0), dst\/ (1.0 - src)), vec3(1.0), step(1.0, src)); \n}\n\nvec3 colorBurn(in vec3 src, in vec3 dst)\n{\n    return mix(step(0.0, src) * (1.0 - min(vec3(1.0), (1.0 - dst) \/ src)),\n        vec3(1.0), step(1.0, dst));\n}\n\nvec3 linearDodge(in vec3 src, in vec3 dst)\n{\n    return clamp(src.xyz + dst.xyz, 0.0, 1.0);\n}\n\nvec3 linearBurn(in vec3 src, in vec3 dst)\n{\n    return clamp(src.xyz + dst.xyz - 1.0, 0.0, 1.0);\n}\n\nvec3 vividLight(in vec3 src, in vec3 dst)\n{\n    return mix(max(vec3(0.0), 1.0 - min(vec3(1.0), (1.0 - dst) \/ (2.0 * src))),\n               min(vec3(1.0), dst \/ (2.0 * (1.0 - src))),\n               step(0.5, src));\n}\n\nvec3 linearLight(in vec3 src, in vec3 dst)\n{\n    return clamp(2.0 * src + dst - 1.0, 0.0, 1.0);;\n}\n\nvec3 pinLight(in vec3 src, in vec3 dst)\n{\n    return mix(mix(2.0 * src, dst, step(0.5 * dst, src)),\n        max(vec3(0.0), 2.0 * src - 1.0), \n        step(dst, (2.0 * src - 1.0))\n    );\n}\n\nvec3 hardMix(in vec3 src, in vec3 dst)\n{\n    return step(1.0, src + dst);\n}\n\nvec3 subtract(in vec3 src, in vec3 dst)\n{\n    return dst - src;\n}\n\nvec3 divide(in vec3 src, in vec3 dst)\n{\n    return dst \/ src;\n}\n\nvec3 addition(vec3 src, vec3 dst)\n{\n    return src + dst;\n}\n\nvec3 difference(in vec3 src, in vec3 dst )\n{\n    return abs(dst - src);   \n}\n\nvec3 darken(in vec3 src, in vec3 dst)\n{\n    return min(src, dst);\n}\n\nvec3 lighten(in vec3 src, in vec3 dst)\n{\n    return max(src, dst);\n}\n\nvec3 invert(in vec3 src, in vec3 dst)\n{\n    return 1.0 - dst;\n}\n\nvec3 invertRGB(in vec3 src, in vec3 dst)\n{\n    return src * (1.0 - dst);\n}\n\nvec3 source(in vec3 src, in vec3 dst)\n{\n\treturn src;\n}\n\nvec3 dest(in vec3 src, in vec3 dst)\n{\n\treturn dst;\n}\n\n\/\/ Branchless RGB2HSL implementation from : https:\/\/www.shadertoy.com\/view\/MsKGRW\nvec3 rgb2hsl( in vec3 c )\n{\n    const float epsilon = 0.00000001;\n    float cmin = min( c.r, min( c.g, c.b ) );\n    float cmax = max( c.r, max( c.g, c.b ) );\n\tfloat cd   = cmax - cmin;\n    vec3 hsl = vec3(0.0);\n    hsl.z = (cmax + cmin) \/ 2.0;\n    hsl.y = mix(cd \/ (cmax + cmin + epsilon), cd \/ (epsilon + 2.0 - (cmax + cmin)), step(0.5, hsl.z));\n\n    vec3 a = vec3(1.0 - step(epsilon, abs(cmax - c)));\n    a = mix(vec3(a.x, 0.0, a.z), a, step(0.5, 2.0 - a.x - a.y));\n    a = mix(vec3(a.x, a.y, 0.0), a, step(0.5, 2.0 - a.x - a.z));\n    a = mix(vec3(a.x, a.y, 0.0), a, step(0.5, 2.0 - a.y - a.z));\n    \n    hsl.x = dot( vec3(0.0, 2.0, 4.0) + ((c.gbr - c.brg) \/ (epsilon + cd)), a );\n    hsl.x = (hsl.x + (1.0 - step(0.0, hsl.x) ) * 6.0 ) \/ 6.0;\n    return hsl;\n}\n\n\/\/ HSL2RGB thanks to IQ : https:\/\/www.shadertoy.com\/view\/lsS3Wc\nvec3 hsl2rgb(in vec3 c)\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 hue(in vec3 src, in vec3 dst)\n{\n    vec3 dstHSL = rgb2hsl(dst);\n    vec3 srcHSL = rgb2hsl(src);\n    return hsl2rgb(vec3(srcHSL.r, dstHSL.gb));\n}\n\nvec3 saturation(in vec3 src, in vec3 dst)\n{\n    vec3 dstHSL = rgb2hsl(dst);\n    vec3 srcHSL = rgb2hsl(src);\n    return hsl2rgb(vec3(dstHSL.r, srcHSL.g, dstHSL.b));\n}\n\nvec3 color(in vec3 src, in vec3 dst)\n{\n    vec3 dstHSL = rgb2hsl(dst);\n    vec3 srcHSL = rgb2hsl(src);\n    return hsl2rgb(vec3(srcHSL.rg, dstHSL.b));\n}\n\nvec3 luminosity(in vec3 src, in vec3 dst)\n{\n    vec3 dstHSL = rgb2hsl(dst);\n    vec3 srcHSL = rgb2hsl(src);\n    return hsl2rgb(vec3(dstHSL.rg, srcHSL.b));\n}\n\nvec3 blend(in vec3 src, in vec3 dst, in int mode)\n{\n    \/\/if (mode == )  return source(src, dst);\n    \/\/if (mode == )  return dest(src, dst);\n    if (mode == 0)  return screen(src, dst);\n    if (mode == 1)  return multiply(src, dst);\n    if (mode == 2)  return overlay(src, dst);\n    if (mode == 3)  return hardlight(src, dst);\n    if (mode == 4)  return softlight(src, dst);\n    if (mode == 5)  return colorDodge(src, dst);\n    if (mode == 6)  return colorBurn(src, dst);\n    if (mode == 7)  return linearDodge(src, dst);\n    if (mode == 8)  return linearBurn(src, dst);\n    if (mode == 9)  return vividLight(src, dst);\n    if (mode == 10) return linearLight(src, dst);\n    if (mode == 11) return pinLight(src, dst);\n    if (mode == 12) return hardMix(src, dst);\n    if (mode == 13) return subtract(src, dst);\n    if (mode == 14) return divide(src, dst);\n    if (mode == 15) return addition(src, dst);\n    if (mode == 16) return difference(src, dst);\n    if (mode == 17) return darken(src, dst);\n    if (mode == 18) return lighten(src, dst);\n    if (mode == 19) return invert(src, dst);\n    if (mode == 20) return invertRGB(src, dst);\n    if (mode == 21) return hue(src, dst);\n    if (mode == 22) return saturation(src, dst);\n    if (mode == 23) return color(src, dst);\n    if (mode == 24) return luminosity(src, dst);\n    if (mode == 25) return exclusion(src, dst);\n    return vec3(0.0,0.0,0.0);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ MAIN\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    \n    \/\/ Blending\n\tint mode = int( texture2D(iChannel0, vec2(0.0, 0.0)).x);\n    vec3 src = texture2D(iChannel1, uv).xyz; \/\/ Top layer\n    vec3 dst = texture2D(iChannel2, uv).xyz; \/\/ Bottom layer\n    \n    fragColor.xyz = blend(src, dst, mode);\n}","name":"","description":"","type":"buffer"}]}}