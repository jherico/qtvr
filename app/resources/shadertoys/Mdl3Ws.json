{"Shader":{"ver":"0.1","info":{"id":"Mdl3Ws","date":"1382745508","viewed":1687,"name":"Dual Real Numbers","username":"iq","description":"Raymarching an implicit 3D surface with distance estimation (distance field). Used to compare traditional central-difference based gradients, vs analytical dual-number based techniques. It works great <img src=\"\/img\/emoticonHappy.png\"\/>","likes":20,"published":3,"flags":0,"tags":["3d","raymarching","distancefield"],"hasliked":0},"renderpass":[{"inputs":[{"id":17,"src":"\/presets\/tex12.png","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":26,"src":"\/presets\/cube04_0.png","ctype":"cubemap","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"id":27,"src":"\/presets\/cube05_0.png","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Computing the distance field for the implicit function\n\/\/\n\/\/ f(x,y,z) = z\u00b2 - (y\u00b2-3x\u00b2)\u00b7(3y\u00b2-x\u00b2)\u00b7(1-x)\n\/\/\n\/\/ which uses the f\/|grad(f)| approximation (for more info on this, see this article:\n\/\/ http:\/\/www.iquilezles.org\/www\/articles\/distance\/distance.htm). \n\/\/\n\/\/ The shader compares two techniques of computing gradients. The traditional way of using \n\/\/ central differences and evaluating the function multiple times per point, and the use of \n\/\/ dual-numbers to compute analytical derivatives automatically from the funcion definition \n\/\/ (see  http:\/\/jliszka.github.io\/2013\/10\/24\/exact-numeric-nth-derivatives.html),\n\/\/ which requieres far less evaluations (faster!) and no epsilon tweaking whatsoever.\n\n\/\/#define DONT_USE_DUALS\n\nconst float precis = 0.001;\n\n\/\/==================================================================================\n\/\/ some dual real numbers functions, for f : R3 -> R1\n\nstruct dualR3\n{\n    float x, y, z;\n\tfloat dx, dy, dz;\n};\n\nvec4 dSet( float a ) { return vec4( a, 0.0, 0.0, 0.0 ); }\nvec4 getX( dualR3 n ) {\treturn vec4(n.x, n.dx, 0.0, 0.0 ); }\nvec4 getY( dualR3 n ) {\treturn vec4(n.y, 0.0, n.dy, 0.0 ); }\nvec4 getZ( dualR3 n ) {\treturn vec4(n.z, 0.0, 0.0, n.dz ); }\n\nvec4 dSqrX( dualR3 a ) { return vec4( a.x*a.x, 2.0*a.x*a.dx, 0.0, 0.0 ); }\nvec4 dSqrY( dualR3 a ) { return vec4( a.y*a.y, 0.0, 2.0*a.y*a.dy, 0.0 ); }\nvec4 dSqrZ( dualR3 a ) { return vec4( a.z*a.z, 0.0, 0.0, 2.0*a.z*a.dz ); }\n\nvec4 dMul( vec4 a, vec4 b ) { return vec4( a.x*b.x, a.y*b.x + a.x*b.y, a.z*b.x + a.x*b.z, a.w*b.x + a.x*b.w );\n\t\t\t\t\n}\n\n\n#ifdef DONT_USE_DUALS\n\n\n\/\/===========================================================================================\n\/\/ traditional way: compute gradients (and distance estimation) by central differences\n\/\/===========================================================================================\nfloat func( vec3 p )\n{\n    \/\/ f(x,y,z) = z\u00b2 - (y\u00b2-3x\u00b2)\u00b7(3y\u00b2-x\u00b2)\u00b7(1-x)\n\treturn p.z*p.z - (p.y*p.y-3.0*p.x*p.x)*(3.0*p.y*p.y - p.x*p.x)*(1.0-p.x);\n}\n\nvec3 grad( in vec3 pos )\n{\n    vec3 eps = vec3(precis,0.0,0.0);\n\treturn vec3(\n           func(pos+eps.xyz) - func(pos-eps.xyz),\n           func(pos+eps.zxy) - func(pos-eps.zxy),\n           func(pos+eps.yzx) - func(pos-eps.yzx) ) \/ (2.0*precis);\n}\n\nfloat dist( vec3 p )\n{\n\treturn func(p) \/ length(grad(p));\n}\n\nfloat map( vec3 p )\n{\n    return func( p );\n}\n\n#else\n\n\/\/===========================================================================================\n\/\/ dual-numbers way: compute gradients (and distance estimation) analytically\n\/\/===========================================================================================\n\nvec4 func( dualR3 p )\n{\n    \/\/ f(x,y,z) = z\u00b2 - (y\u00b2-3x\u00b2)\u00b7(3y\u00b2-x\u00b2)\u00b7(1-x)\n    return dSqrZ(p) - dMul( dMul( dSqrY(p) - 3.0*dSqrX(p), 3.0*dSqrY(p) - dSqrX(p)), dSet(1.0) - getX(p) );\n}\t\n\t\nvec3 grad( in vec3 p )\n{\n\treturn func( dualR3(p.x,p.y,p.z,1.0,1.0,1.0) ).yzw;\n}\n\nfloat dist( vec3 p )\n{\n    vec4 f = func( dualR3(p.x,p.y,p.z,1.0,1.0,1.0) );\t\n\treturn f.x \/ length(f.yzw);\n}\t\n\nfloat map( vec3 p )\n{\n\treturn func( dualR3(p.x,p.y,p.z,0.0,0.0,0.0) ).x;\n}\n\n#endif\n\n\/\/==================================================================================\n\n\nvec2 intersect( in vec3 ro, in vec3 rd )\n{\n\tfloat mind = precis*2.0;\n\tfloat maxd = 15.0;\n\t\n\t\n\t{\n\tfloat b = dot(ro,rd);\n\tfloat c = dot(ro,ro) - 1.5*1.5;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0,0.0);\n\th = sqrt(h);\n\tmind = max( mind, -b - h );\n\tmaxd = min( maxd, -b + h );\n    }\n\n    float h = 1.0;\n\tfloat t = mind;\n    for( int i=0; i<150; i++ )\n\t{\n        if( abs(h)<precis||t>maxd ) continue;\n\t    h = dist( ro+rd*t );\n        t += 0.25*abs(h);\n    }\n\n    if( t>maxd ) t=-1.0;\n    return vec2(t,sign(h));\n}\n\nvec3 calcNormal( in vec3 p )\n{\n\treturn normalize( grad(p) );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float k )\n{\n\tfloat mind = precis*2.0;\n\tfloat maxd = 15.0;\n\t\n\t{\n\tfloat b = dot(ro,rd);\n\tfloat c = dot(ro,ro) - 1.5*1.5;\n\tfloat h = b*b - c;\n\th = sqrt(h);\n\tmaxd = min( maxd, -b + h );\n\tmind = max( mind, -b - h );\n    }\n\t\n    float res = 1.0;\n    float t = mind;\n    for( int i=0; i<32; i++ )\n    {\n        if( t>maxd ) continue;\n        float h = map( ro + rd*t );\n\t\th = abs(h);\n        res = min( res, k*h\/t );\n        t += 0.1;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec2 hash2( float n )\n{\n    return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123));\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 m = vec2(0.5);\n\tif( iMouse.z>0.0 ) m = iMouse.xy\/iResolution.xy;\n\n    \/\/ animation\t\n\tfloat time = iGlobalTime;\n\t\n\tvec3 tot = vec3(0.0);\n\tfor( int a=0; a<10; a++ )\n\t{\n\t\tvec2 pof = texture2D( iChannel1, (0.5+13.0*float(a))\/iChannelResolution[1].xy  ).xz;\n\t\t\t\t  \n\t\n    vec2 p = -1.0 + 2.0 * (fragCoord.xy + pof)\/iResolution.xy;\n    p.x *= iResolution.x\/iResolution.y;\n\t\t\n    \/\/ camera\n\tfloat an = 0.3*time - 6.2*m.x;\n\tfloat cr = 0.15*sin(0.2*time);\n    vec3 ro = 2.5*vec3(sin(an),0.0,cos(an));\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(cr),cos(cr),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n\t\/\/ raymarch\n    vec2 t = intersect(ro,rd);\n\t\n\t\/\/ shade\n    vec3 col = vec3(0.0);\n    if( t.x>0.0 )\n    {\n        \/\/ geometry\n        vec3 pos = ro + t.x*rd;\n        vec3 nor = calcNormal(pos);\n\n\t\t\/\/ diffuse\n\t\tcol = vec3(0.0);\n\t\tfloat off = 1.0*texture2D( iChannel1, fragCoord.xy\/iChannelResolution[1].xy, -100.0 ).x;\n\t\tvec3  uu  = normalize( cross( nor, vec3(0.0,1.0,1.0) ) );\n\t\tvec3  vv  = normalize( cross( uu, nor ) );\n\t\tfor( int i=0; i<10; i++ )\n\t\t{\n#if 0\t\n\t\t\tvec3 rr = normalize(-1.0 + 2.0*hash3(off+float(i)*123.5463));\n\t\t\trr = normalize( nor + 7.0*rr );\n\t\t\trr = rr * sign(dot(nor,rr));\t\t\t\t\t\t\t  \n#else\n\t\t\tvec2  aa = hash2( off + float(i)*203.1 + float(a)*13.7 );\n\t\t\t\/\/vec2 aa = texture2D( iChannel1, (vec2(37.0,31.0)*float(i)+fragCoord.xy)\/iChannelResolution[1].xy, -100.0 ).xz;\n\t\t\tfloat ra = sqrt(aa.y);\n\t\t\tfloat rx = ra*cos(6.2831*aa.x); \n\t\t\tfloat ry = ra*sin(6.2831*aa.x);\n\t\t\tfloat rz = sqrt( 1.0-aa.y );\n\t\t\tvec3  rr = vec3( rx*uu + ry*vv + rz*nor );\n#endif\t\t\t\n\t\t\tfloat ds = 1.0;\/\/softshadow( pos, rr, 64.0 );\n\t\t\t\n            col += ds*mix( 0.5*vec3(0.2,0.1,0.0), vec3(0.8,0.9,1.0), smoothstep(-0.1,0.1,rr.y) );\n\t\t\t\t\t\t  \/\/vec3(0.1)*pow( textureCube( iChannel0, rr ).xyz, vec3(2.2) );\n\t\t}\n        col \/= 10.0;\n\t\t\n\t\tfloat ii = 0.5+0.5*t.y;\n\t\t\n        \/\/ specular\t\t\n\t\tfloat fre = pow( clamp(1.0+dot(rd,nor),0.0,1.0), 5.0 );\n\t\tvec3 ref = reflect( rd, nor );\n\t\tfloat rs = 1.0;\/\/softshadow( pos, ref, 32.0 );\n        col += ii * 1.0* (0.04 + 1.0*fre) * pow( textureCube( iChannel2, ref ).xyz, vec3(2.0) ) * rs;\n\n        \/\/ color\n\t\tcol *= mix( vec3(1.0,0.5,0.2), vec3(1.0,1.0,1.0), ii );\n\t\t\/\/col *= 1.5;\n    }\n\telse\n\t{\n        \/\/ background\t\t\n\t\tcol =0.9* pow( textureCube( iChannel2, rd ).xyz, vec3(2.2) );\n\t}\n\t\n\t\ttot += col;\n\t}\n\n\ttot \/= 10.0;\n\t\n\t\/\/ gamma\n\ttot = pow( clamp( tot, 0.0, 1.0 ), vec3(0.45) );\n\t\n    fragColor = vec4( tot, 1.0 );\n}","name":"","description":"","type":"image"}]}}