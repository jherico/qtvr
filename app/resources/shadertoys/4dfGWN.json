{"Shader":{"ver":"0.1","info":{"id":"4dfGWN","date":"1370411859","viewed":500,"name":"Twister Thingy","username":"tsone","description":"Shadertoy remake of a classic demoscene effect.","likes":2,"published":3,"flags":0,"tags":["demoscene","oldskool","twister"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define OLDSKOOL\n#define ADDBASE\n#define ADDNOISE\n#define PI 3.14159265359\n#define STEPS 16.0\n#define STEPSTART 0.777\n#define RES 30.0\n#define NOISESCALE 2.0\n\nfloat time = 1.0 * iGlobalTime;\n\n\n\/\/ Based on iq's 'Noise - value noise' shader:\n\/\/ https:\/\/www.shadertoy.com\/view\/lsf3WH\nfloat hash(in vec2 p) {\n\tfloat h = dot(p, vec2(127.1,311.7));\n    return fract(sin(h) * 43758.5453123);\n}\n\nfloat vnoiseh2(in vec2 p) {\n\tvec2 i = floor(p);\n\tvec2 f = fract(p);\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\tfloat a = hash(i + vec2(0.0,0.0));\n\tfloat b = hash(i + vec2(1.0,0.0));\n\tfloat c = hash(i + vec2(0.0,1.0));\n\tfloat d = hash(i + vec2(1.0,1.0));\n\treturn mix(mix(a, b, u.x),\n\t\t\t   mix(c, d, u.x), u.y);\n}\n\n\/\/ Normal calculation separated from height to reduce loop complexity.\n\/\/ If both height and normal are needed in same place, then it would make\n\/\/ sense to combine the calculations.\n\/\/ Noise derivates\/normal based on iq's article:\n\/\/ http:\/\/www.iquilezles.org\/www\/articles\/morenoise\/morenoise.htm\n\/\/ NOTE: Result is unnormalized.\nvec3 vnoisen2(in vec2 p) {\n\tvec2 i = floor(p);\n\tvec2 f = fract(p);\n\tvec2 dl = 6.0 * f * (1.0 - f);\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\tfloat a = hash(i + vec2(0.0,0.0));\n\tfloat b = hash(i + vec2(1.0,0.0));\n\tfloat c = hash(i + vec2(0.0,1.0));\n\tfloat d = hash(i + vec2(1.0,1.0));\n\treturn vec3(\n\t\tdl.x * mix((b - a), (d - c), u.y),\n\t\tdl.y * mix((c - a), (d - b), u.x),\n\t\t-1.0\n\t);\n}\n\nfloat baseh(in vec2 a) {\n\tvec2 s = sin(a);\n\tvec2 s2 = s * s;\n\treturn (s2.y * s2.x);\n}\n\n\/\/ Height map normal calculation explained:\n\/\/ http:\/\/http.developer.nvidia.com\/GPUGems\/gpugems_ch01.html\nvec3 basen(in vec2 a) {\n\tvec2 s = sin(a);\n\tvec2 c = cos(a);\n\tvec2 s2 = s * s;\n\treturn normalize(vec3(\n\t\t2.0 * c.x * s.x * s2.y,\n\t\t2.0 * c.y * s.y * s2.x,\n\t\t-1.0\n\t));\n}\n\nfloat height(in vec2 a) {\n\tfloat h = 0.74;\n#ifdef ADDBASE\n\th += 0.2 * baseh(a);\n#endif\n#ifdef ADDNOISE\n\th += 0.06 * vnoiseh2(NOISESCALE * a);\n#endif\n\treturn h;\n}\n\nvec3 normal(in vec2 a) {\n\tvec3 n = vec3(0.0);\n#ifdef ADDBASE\n\tn += basen(a);\n#endif\n#ifdef ADDNOISE\n\tn += 0.25 * vnoisen2(NOISESCALE * a);\n#endif\n\treturn normalize(n);\n}\n\nvoid run(out float _a, inout vec2 _p, in vec2 uv) {\n\tuv *= 1.333;\n\t\n\t_a = -PI;\n\n\tfloat dz = -STEPSTART \/ STEPS;\n\tvec3 v = vec3(uv.x, uv.y * RES * 0.25 * PI, STEPSTART);\n#ifdef OLDSKOOL\n\tv.y = floor(v.y + 0.5);\n#endif\n\t\n\tvec2 offs = vec2(RES * (0.5 * PI\n\t\t\t* (0.8 + 0.2 * cos(time)) * sin(2.0 * time + 0.5 * v.y \/ RES)),\n\t\t\tv.y\n\t);\n#ifdef OLDSKOOL\n\toffs = floor(offs + 0.5);\n#endif\n\t\n\tfor (int i = 0; i < int(STEPS); i++) {\n\t\tv.z += dz;\n\t\tfloat a = atan(v.x, v.z) * RES;\n#ifdef OLDSKOOL\n\t\ta = floor(a + 0.5);\n#endif\n\t\tvec2 p = offs + vec2(a, 0.0);\n\t\tp *= 4.0 \/ RES;\n\t\tfloat r = length(v.xz);\n\t\tfloat h = height(p);\n\t\tif (r < h) {\n\t\t\t_a = a \/ RES;\n\t\t\t_p = p;\n\t\t\tv.x = 1e10;\n\t\t}\n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 uv = 2.0 * fragCoord.xy \/ iResolution.xy - 1.0;\n\tfloat a;\n\tvec2 p;\n\trun(a, p, uv);\n\tvec3 n = normal(p);\n\tvec3 c;\n\ta = -a;\n\tfloat tx = n.x;\n\tn.x = n.x * cos(a) - n.z * sin(a);\n\tn.z = n.z * cos(a) + tx * sin(a);\n\tvec3 l = -normalize(vec3(cos(time),sin(time),1.0));\n\tfloat ndotl = max(0.0, dot(n, l));\n\tc = vec3(0.50,0.35,0.20)\n\t\t+ vec3(0.60,0.70,0.80) * ndotl*ndotl;\n\tc *= c * step(a, 0.5 * PI);\n\tfragColor = vec4(c,1.0);\n}","name":"","description":"","type":"image"}]}}