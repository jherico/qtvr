{"Shader":{"ver":"0.1","info":{"id":"MtXGRs","date":"1424255698","viewed":228,"name":"Gyrating Gyroscope","username":"dr2","description":"Gyroscope; see source for more details.","likes":3,"published":3,"flags":0,"tags":["gyroscope"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ \"Gyrating Gyroscope\" by dr2 - 2015\n\/\/ License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n\/*\n  Simulation of a simulated gyroscope. A \"real\" simulated gyroscope\n  requires solving differential equations; since this cannot be done\n  without \"historical\" information, trajectories here are approximated\n  by cycloids. The parameters change every 20s to show different\n  combinations of precession and nutation; the red dots trace the\n  trajectory.\n*\/\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float s = 0.;\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return s;\n}\n\nvec3 WoodCol (vec3 p, vec3 n)\n{\n  p *= 4.;\n  float f = dot (vec3 (Fbm2 (p.yz * vec2 (1., 0.1)),\n     Fbm2 (p.zx * vec2 (1., 0.1)), Fbm2 (p.yx * vec2 (1., 0.1))), abs (n));\n  return mix (vec3 (0.8, 0.4, 0.2), vec3 (0.45, 0.25, 0.1), f);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z \/ h, -1., 1.))) - r;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nint idObj;\nvec3 qHit, ltDir;\nfloat tCur, tSeq, tGap, pnRel, avSpin, amNut, frNut, tha0, phi0;\nbool isShadw;\nconst float dstFar = 100.;\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  const float bLen = 6., bRad = 0.6, axLen = 10., wlRad = 6.;\n  float dMin, d, a, psi, tha, phi, t, ti;\n  q = p;\n  dMin = dstFar;\n  d = PrCapsDf (q.xzy, bRad * (1.1 - 0.3 * q.y \/ bLen), 0.9 * bLen);\n  if (d < dMin) { dMin = d;  qHit = q;  idObj = 2; }\n  q.y -= bLen;\n  d = PrSphDf (q, 0.07 * wlRad);\n  if (d < dMin) { dMin = d;  qHit = q;  idObj = 5; }\n  q.y -= -2.05 * bLen;\n  d = PrCylDf (q.xzy, 10. * bRad, 0.08 * bLen);\n  if (d < dMin) { dMin = d;  qHit = q;  idObj = 3; }\n  q = p;  q.y -= bLen;\n  t = frNut * tSeq;\n  tha = tha0 + amNut * (pnRel * t - sin (t));\n  phi = phi0 + amNut * (pnRel - cos (t));\n  psi = - avSpin * tSeq;\n  q.xz = Rot2D (q.xz, tha);  q.xy = Rot2D (q.xy, phi);\n  q.x -= axLen;\n  d = PrTorusDf (q.zyx, 0.05 * wlRad, wlRad);\n  d = min (d, PrCylDf (q.zyx, 0.07 * wlRad, 0.05 * wlRad));\n  if (d < dMin) { dMin = d;  idObj = 5; }\n  q.x += 0.5 * axLen;\n  d = min (d, PrCylDf (q.zyx, 0.03 * wlRad, 0.5 * axLen));\n  if (d < dMin) { dMin = d;  idObj = 4; }\n  q.x -= 0.5 * axLen;\n  q.yz = Rot2D (q.yz, psi);  \n  q.yz = Rot2D (q.yz, 0.25 * pi *\n     floor ((atan (q.y, q.z) + pi) * 4. \/ pi + 0.5));\n  q.z += 0.5 * wlRad;\n  d = PrCylDf (q, 0.03 * wlRad, 0.5 * wlRad);\n  if (d < dMin) { dMin = d;  idObj = 5; }\n  if (! isShadw) {\n    p.y -= bLen;\n    ti = tGap * floor (tSeq \/ tGap);\n    d = dstFar;\n    for (int j = 0; j < 40; j ++) {\n      t = frNut * ti;\n      tha = tha0 + amNut * (pnRel * t - sin (t));\n      phi = phi0 + amNut * (pnRel - cos (t));\n      q = p;  \n      q.xz = Rot2D (q.xz, tha);  q.xy = Rot2D (q.xy, phi);\n      q.x -= 0.8 * axLen;\n      d = min (d, PrSphDf (q, 0.03 * wlRad));\n      ti -= tGap;\n      if (ti < 0.) break;\n    }\n  }\n  if (d < dMin) { dMin = d;  idObj = 1; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float d, h, sh;\n  sh = 1.;\n  d = 0.1;\n  for (int i = 0; i < 60; i++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, 20. * h \/ d);\n    d += 0.4;\n    if (h < 0.001) break;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nvec3 ObjCol (vec3 n, float dstHit)\n{\n  vec3 col;\n  if (idObj == 1) col = vec3 (0.9, 0., 0.) *\n     (1. - 0.5 * (dstHit - 40.) \/ (dstFar - 40.));\n  else if (idObj == 2) col = WoodCol (3. * qHit.xzy, n);\n  else if (idObj == 3) col = WoodCol (qHit, n);\n  else if (idObj == 4) col = vec3 (0.6, 0.6, 0.7);\n  else if (idObj == 5) col = vec3 (0.8, 0.8, 0.1);\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, objCol, col;\n  float dstHit, sh;\n  int idObjT;\n  idObj = -1;\n  isShadw = false;\n  dstHit = ObjRay (ro, rd);\n  if (idObj < 0) dstHit = dstFar;\n  idObjT = idObj;\n  if (dstHit >= dstFar)\n     col = (1. - 2. * dot (rd.xy, rd.xy)) * vec3 (0.2, 0.25, 0.3);\n  else {\n    ro += rd * dstHit;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    objCol = ObjCol (vn, dstHit);\n    isShadw = true;\n    sh = (idObj != 1) ? ObjSShadow (ro, ltDir) : 1.;\n    col = objCol * (0.4 + 0.6 * sh * max (dot (vn, ltDir), 0.)) +\n       sh * pow (max (0., dot (ltDir, reflect (rd, vn))), 128.);\n  }\n  col = sqrt (clamp (col, 0., 1.));\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy \/ iResolution.xy - 1.;\n  uv.x *= iResolution.x \/ iResolution.y;\n  tCur = iGlobalTime;\n  float tCyc = 20.;\n  float nSeq = floor (tCur \/ tCyc);\n  tSeq = tCur - nSeq * tCyc;\n  pnRel = 0.2 + 0.4 * mod (nSeq, 5.);\n  amNut = 0.12 * pi * (1. - 0.5 * (pnRel - 1.));\n  frNut = 1.1 * pi;\n  avSpin = 1.2 * pi;\n  phi0 = -0.12 * pi - amNut * (pnRel - 0.2);\n  tha0 = 0.1 * pi;\n  tGap = 0.08;\n  float dist = 50.;\n  vec3 rd = normalize (vec3 (uv, 3.2));\n  vec3 ro = vec3 (0., 0.12, -1.) * dist;\n  ltDir = normalize (vec3 (-0.5, 0.8, -0.4));\n  vec3 col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n","name":"","description":"","type":"image"}]}}