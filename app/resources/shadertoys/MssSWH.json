{"Shader":{"ver":"0.1","info":{"id":"MssSWH","date":"1400495071","viewed":416,"name":"Interval Arithmetic: Quadtree","username":"paniq","description":"Traversing an implicit function octree-style using interval arithmetic","likes":9,"published":3,"flags":0,"tags":["mattdamon"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ IA quadtree visualization\n\/\/ -- @paniq\n\n\/\/ undefine if you are running on glslsandbox.com\n\/\/ #define GLSLSANDBOX\n\n#ifdef GLSLSANDBOX\n#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define iGlobalTime time\n#define iResolution resolution\n#endif\n\n\/\/ interface\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ set color source for stroke \/ fill \/ clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source(sampler2D image);\n\n\/\/ set line width in normalized units for stroke\nvoid set_line_width(float w);\n\/\/ set line width in pixels for stroke\nvoid set_line_width_px(float w);\n\/\/ set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n\/\/ add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n\/\/ add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n\n\/\/ set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n\/\/ draw straight line from starting point to P,\n\/\/ and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n\/\/ draw quadratic bezier curve from starting point\n\/\/ over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n\/\/ connect current starting point with first\n\/\/ drawing point.\nvoid close_path();\n\n\/\/ clear screen in the current source color\nvoid clear();\n\/\/ fill paths and clear the path buffer\nvoid fill();\n\/\/ fill paths and preserve them for additional ops\nvoid fill_preserve();\n\/\/ stroke paths and clear the path buffer\nvoid stroke_preserve();\n\/\/ stroke paths and preserve them for additional ops\nvoid stroke();\n\/\/ clears the path buffer\nvoid new_path();\n\n\/\/ return rgb color for given hue (0..1)\nvec3 hue(float hue);\n\/\/ return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n\/\/ rotate the context by A in radians\nvoid rotate(float a);\n\/\/ uniformly scale the context by S\nvoid scale(float s);\n\/\/ translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n\/\/ clear all transformations for the active context\nvoid identity_matrix();\n\/\/ transform the active context by the given matrix\nvoid transform(mat3 mtx);\n\/\/ set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n\/\/ represents the current drawing context\n\/\/ you usually don't need to change anything here\nstruct Context {\n    vec2 position;\n    float scale;\n    float shape;\n    float line_width;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n};\n    \n\/\/ save current source color, stroke width and starting\n\/\/ point from active context.\nContext save();\n\/\/ restore source color, stroke width and starting point\n\/\/ to a context previously returned by save()\nvoid restore(Context ctx);\n\n\/\/ draws a half-transparent debug gradient for the\n\/\/ active path\nvoid debug_gradient();\n\nvoid paint();\n\n\/\/ implementation\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec2 aspect = vec2(iResolution.x \/ iResolution.y, 1.0);\nvec2 uv;\nvec2 position;\nfloat ScreenH = min(iResolution.x,iResolution.y);\nfloat AA = ScreenH*0.4;\nfloat AAINV = 1.0 \/ AA;\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec3 hue(float hue) {\n    return clamp( \n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, \n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define DEFAULT_SHAPE_V 1e+20\n    \nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    uv = fragCoord.xy \/ iResolution.xy;\n    \n     position = (uv*2.0-1.0)*aspect;\n    _stack = Context(\n        position, 1.0,\n        DEFAULT_SHAPE_V,\n        1.0,\n        vec2(AA,0.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0)\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nContext save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    \/\/ preserve shape\n    float shape = _stack.shape;\n    _stack = ctx;\n    _stack.shape = shape;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 \/ d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = position;\n    _stack.scale = 1.0;\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position = (mtx * vec3(position,1.0)).xy;\n    _stack.scale = length(vec2(mtx[0].x,mtx[1].y));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position = (mtx * vec3(_stack.position,1.0)).xy;\n    vec2 u = vec2(mtx[0].x, mtx[1].x);\n    _stack.scale *= length(u);\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(float s) {\n    transform(mat3(s,0.0,0.0,0.0,s,0.0,0.0,0.0,1.0));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid add(float d) {\n    _stack.shape = min(_stack.shape, d \/ _stack.scale);\n}\n\nvoid new_path() {\n    _stack.shape = DEFAULT_SHAPE_V;\n}\n\nvoid debug_gradient() {\n    _color = mix(_color, \n        hsl(_stack.shape * 6.0, \n            1.0, (_stack.shape>=0.0)?0.5:0.3), \n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(AA, 0.0);\n        return;\n    }\n    float a = 1.0 \/ max(AAINV, b);\n    _stack.blur = vec2(\n        a,\n        0.0); \/\/ 0 = blur ends at outline, 1 = blur starts at outline\n}\n\nvoid fill_preserve() {\n    float w = clamp(-_stack.shape*AA, 0.0, 1.0);\n    _color = mix(_color, _stack.source.rgb, w * _stack.source.a);\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*_stack.scale\/AA;\n}\n\nvoid stroke_preserve() {\n    float w = abs(_stack.shape)- _stack.line_width\/_stack.scale;\n    vec2 blur = _stack.blur;\/\/ \/ _stack.scale;\n    w = clamp(-w*blur.x + blur.y, 0.0, 1.0);\n    _color = mix(_color, _stack.source.rgb, w * _stack.source.a);\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nvoid set_source_rgba(vec4 c) {\n    _stack.source = c;\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) { \n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture2D(image, _stack.position));\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    s*=0.5;\n    o = o - _stack.position + s;\n    vec2 d = abs(o) - s;\n    add(min(max(d.x,d.y),0.0) + length(max(d,0.0)));\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rectangle(vec2(ox,oy), vec2(sx,sy));\n}\n\nvoid circle(vec2 p, float r) {\n    add(length(_stack.position - p) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n\/\/ stroke only\nvoid line_to(vec2 p) {\n    vec2 pa = _stack.position - _stack.last_pt;\n    vec2 ba = p - _stack.last_pt;\n    float h = clamp(dot(pa, ba)\/dot(ba,ba), 0.0, 1.0);\n    add(length(pa - ba*h));\n    \n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n\/\/ from \"Random-access rendering of general vector graphics\"\n\/\/ by Nehab and Hoppe\n\/\/ only quadratic, not cubic\nvoid curve_to(vec2 b1, vec2 b2)\n{\n    vec2 b0 = _stack.last_pt - _stack.position;\n\t_stack.last_pt = b2;\n    b1 -= _stack.position;\n    b2 -= _stack.position;\n    float a=det(b0,b2), b=2.0*det(b1,b0), d=2.0*det(b2,b1);\n    float f=b*d-a*a;\n    vec2 d21=b2-b1, d10=b1-b0, d20=b2-b0;\n    vec2 gf=2.0*(b*d21+d*d10+a*d20);\n    gf=vec2(gf.y,-gf.x);\n    vec2 pp=-f*gf\/dot(gf,gf);\n    vec2 d0p=b0-pp;\n    float ap=det(d0p,d20), bp=2.0*det(d10,d0p);\n    float t=clamp((ap+bp)\/(2.0*a+b+d), 0.0, 1.0);\n    add(length(mix(mix(b0,b1,t),mix(b1,b2,t),t)));\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init(fragCoord);\n    \n    paint();\n    \n    fragColor = vec4(_color.xyz, 1.0);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define iafloat vec2\n#define iavec3 mat3 \/\/ in glsl: mat3x2\n\niavec3 iavec3_new(iafloat x, iafloat y, iafloat z) {\n\treturn iavec3(x, 0.0, y, 0.0, z, 0.0);\n}\n\niavec3 iavec3_new(float x, float y, float z) {\n\treturn iavec3(x, x, 0.0, y, y, 0.0, z, z, 0.0);\n}\n\niavec3 iavec3_new(vec3 p) {\n\treturn iavec3(p.xx, 0.0, p.yy, 0.0, p.zz, 0.0);\n}\n\niavec3 iavec3_new(vec3 p0, vec3 p1) {\n\treturn iavec3(p0.x, p1.x, 0.0, p0.y, p1.y, 0.0, p0.z, p1.z, 0.0);\n}\n\niafloat imin(iafloat a, iafloat b) {\n\treturn iafloat(min(a.x,b.x),min(a.y,b.y));\n}\n\niafloat imax(iafloat a, iafloat b) {\n\treturn iafloat(max(a.x,b.x),max(a.y,b.y));\n}\n\niafloat iadd(iafloat a, iafloat b) {\n\treturn a + b;\n}\n\niavec3 iadd(iavec3 a, iavec3 b) {\n\treturn iavec3_new(\n\t\ta[0].xy + b[0].xy,\n\t\ta[1].xy + b[1].xy,\n\t\ta[2].xy + b[2].xy);\n}\n\niavec3 iadd(vec3 a, iavec3 b) {\n\treturn iavec3_new(\n\t\ta.xx + b[0].xy,\n\t\ta.yy + b[1].xy,\n\t\ta.zz + b[2].xy);\n}\n\niafloat isub(iafloat a, iafloat b) {\n\treturn a - b.yx;\n}\n\niavec3 isub(iavec3 a, iavec3 b) {\n\treturn iavec3_new(\n\t\ta[0].xy - b[0].yx,\n\t\ta[1].xy - b[1].yx,\n\t\ta[2].xy - b[2].yx);\n}\n\niavec3 isub(iavec3 a, vec3 b) {\n\treturn iavec3_new(\n\t\ta[0].xy - b.xx,\n\t\ta[1].xy - b.yy,\n\t\ta[2].xy - b.zz);\n}\n\niafloat imul(iafloat a, iafloat b) {\n\tvec4 f = vec4(\n\t\ta.xxyy * b.xyxy\n\t);\t\n\treturn iafloat(\n\t\tmin(min(f[0],f[1]),min(f[2],f[3])),\n\t\tmax(max(f[0],f[1]),max(f[2],f[3])));\n}\n\niafloat imul(float a, iafloat b) {\n\tvec2 f = vec2(a*b);\t\n\treturn iafloat(\n\t\tmin(f[0],f[1]),\n\t\tmax(f[0],f[1]));\n}\n\niavec3 imul(iavec3 a, iavec3 b) {\n\treturn iavec3_new(\n\t\timul(a[0].xy, b[0].xy),\n\t\timul(a[1].xy, b[1].xy),\n\t\timul(a[2].xy, b[2].xy)\n\t);\n}\n\niavec3 imul(float a, iavec3 b) {\n\treturn iavec3_new(\n\t\timul(a, b[0].xy),\n\t\timul(a, b[1].xy),\n\t\timul(a, b[2].xy)\n\t);\n}\n\niavec3 imul(vec3 a, iavec3 b) {\n\treturn iavec3_new(\n\t\timul(a.xx, b[0].xy),\n\t\timul(a.yy, b[1].xy),\n\t\timul(a.zz, b[2].xy)\n\t);\n}\n\niavec3 imul(vec3 a, iafloat b) {\n\treturn iavec3_new(\n\t\timul(a.x, b),\n\t\timul(a.y, b),\n\t\timul(a.z, b)\n\t);\n}\n\n\niafloat idiv(iafloat a, iafloat b) {\n\tvec4 f = vec4(\n\t\ta.x\/b, a.y\/b\n\t);\n\treturn iafloat(\n\t\tmin(min(f[0],f[1]),min(f[2],f[3])),\n\t\tmax(max(f[0],f[1]),max(f[2],f[3])));\n}\n\niavec3 idiv(iavec3 a, iavec3 b) {\n\treturn iavec3_new(\n\t\tidiv(a[0].xy, b[0].xy),\n\t\tidiv(a[1].xy, b[1].xy),\n\t\tidiv(a[2].xy, b[2].xy)\n\t);\n}\n\niafloat isqrt(iafloat a) {\n\treturn iafloat(sqrt(a.x),sqrt(a.y));\n}\n\n\/\/ for even powers in general,\n\/\/ for odd powers, it's just iafloat(a*a)\niafloat ipow2(iafloat a) {\t\n\treturn (a.x>=0.0)?iafloat(a*a):(a.y<0.0)?iafloat((a*a).yx):iafloat(0.0,max(a.x*a.x,a.y*a.y));\n}\n\niavec3 ipow2(iavec3 v) {\n\treturn iavec3_new(\n\t\tipow2(v[0].xy),\n\t\tipow2(v[1].xy),\n\t\tipow2(v[2].xy));\n}\n\niafloat ilensq(iavec3 a) {\n\tiavec3 c = ipow2(a);\n\treturn c[0].xy + c[1].xy + c[2].xy;\n}\n\niafloat ilength(iavec3 a) {\n\tiavec3 c = ipow2(a);\n\treturn isqrt(c[0].xy + c[1].xy + c[2].xy);\n}\n\niafloat idot(iavec3 a, iavec3 b) {\n\tiavec3 c = imul(a,b);\n\treturn c[0].xy + c[1].xy + c[2].xy;\n}\n\nbool icontains(iafloat a, float v) {\n\treturn ((v >= a.x) && (v < a.y));\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\niafloat sphere(iavec3 p, float r) {\n\t\/\/ x^2 + y^2 + z^2 - r^2\n\treturn isub(ilensq(p),iafloat(r*r));\n}\n\niafloat teardrop(iavec3 p) {\n\t\/\/ -0.5x^5 - 0.5x^4 + y^2 + z^2\n\t\n\tiafloat x2 = ipow2(p[2].xy);\n\tiafloat y2 = ipow2(p[1].xy);\n\tiafloat z2 = ipow2(p[0].xy);\n\t\n\tiafloat x4 = ipow2(x2);\n\tiafloat x5 = imul(p[2].xy,x4);\n\t\n\treturn iadd(iadd(isub(imul(-0.5,x5), imul(0.5,x4)), y2), z2);\t\n}\n\nfloat as = sin(iGlobalTime)*0.5+0.5;\n\niafloat map(iavec3 p) {\n\t\/\/ scaling needs no distance fix\n\tiafloat drop = teardrop(imul(2.0,isub(p, vec3(1.0,0.0,0.0))));\n\tiafloat sph1 = sphere(isub(p, vec3(1.0,0.0,0.0)), 0.8);\n\t\/\/ anisotropic scaling is no problem\n\tiafloat sph2 = sphere(imul(\n\t\tvec3(3.0,1.0,1.0),\n\t\tisub(p, vec3(0.0,0.0,-0.9+0.2*as))), 0.5);\n\t\n\treturn imin(imax(drop,sph1), sph2);\n}\n\nvec2 grad2d(vec3 p) {\n\tvec2 d = vec2(0.0, 1e-3);\n\t\n\t\/\/ could do this with only two queries if only the sign\n\t\/\/ could be recovered.\n\tvec2 hx = map(iavec3_new(p + d.yxx)) - map(iavec3_new(p - d.yxx));\n\tvec2 hy = map(iavec3_new(p + d.xxy)) - map(iavec3_new(p - d.xxy));\n\t\n\treturn normalize(vec2(\n\t\thx.x, hy.x));\n}\n\nvoid arrow(vec2 u, vec2 n) {\n\tvec2 o = vec2(n.y, -n.x);\n\tmove_to(u);\n\tu += n;\n\tline_to(u);\n\tmove_to(u - o*0.2);\n\tline_to(u + o*0.2);\n\tline_to(u + n*0.4);\n\tclose_path();\n}\n\niafloat trace_paint(vec3 ro, vec3 rd, iafloat t) {\n\tiavec3 r = iadd(ro, imul(rd, t));\n\t\n\tiafloat h = map(r);\n\tif (icontains(h, 0.0))\n\t\tset_source_rgba(vec4(0.0,1.0,0.0,0.5));\n\telse\n\t\tset_source_rgba(vec4(1.0,0.0,0.0,0.5));\n\t\n\tmove_to(ro.xz+rd.xz*t.x);\n\tline_to(ro.xz+rd.xz*t.y);\n\tstroke();\n\t\n\trectangle(r[0].x, r[2].x, r[0].y - r[0].x, r[2].y - r[2].x);\n\tstroke();\n\t\n\treturn h;\n}\n\nvoid paint() {\n\tvec2 ms = ((iMouse.xy\/iResolution.xy)*2.0-1.0) * aspect;\n\t\n\t\/\/ clear screen\n\t\n\tiafloat d = map(iavec3_new(\n\t\tvec3(position.x,0.0,position.y)));\n\t\n\t\n\tset_source_rgb(\n\t\t(d.x<=0.0)?hsl(0.6, 1.0, 0.7):vec3(0.0,0.0,0.5));\n\tclear();\n\n\tset_source_rgba(hsl(0.6, 1.0, 0.7, 0.3));\n\tset_line_width_px(3.0);\n\tfor (int i = 0; i < 8; ++i) {\n\t\t_stack.shape = d.x-float(i)*0.2;\n\t\tstroke();\n\t}\n\n\tset_source_rgb(vec3(1.0));\n\tset_line_width_px(1.0);\n\tnew_path();\n\n\tfloat D = 2.0;\n\tvec3 p0 = vec3(-D,0.0,-D);\n\tvec3 p1 = vec3(D,0.0,D);\n\t\n\t#define MAX_STEP 12\n\tfor (int i = 0; i < MAX_STEP; ++i) {\n\t\tiafloat t = map(iavec3_new(p0,p1));\n\t\tif (icontains(t,0.0)) {\n\t\t\tif (i == MAX_STEP-1) {\n\t\t\t\tset_source_rgb(vec3(0.0,1.0,0.0));\n\t\t\t} else {\n\t\t\t\tset_source_rgb(vec3(1.0,0.0,0.0));\n\t\t\t}\n\t\t\t\n\t\t\trectangle(p0.xz, (p1 - p0).xz);\n\t\t\tstroke();\n\t\t\t\n\t\t\tvec3 pc = (p0+p1)*0.5;\n\t\t\tif (position.x > pc.x)\n\t\t\t\tp0.x = pc.x;\n\t\t\telse\n\t\t\t\tp1.x = pc.x;\n\t\t\tif (position.y > pc.z)\n\t\t\t\tp0.z = pc.z;\n\t\t\telse\n\t\t\t\tp1.z = pc.z;\n\t\t} else if (max(t.x,t.y) <= 0.0) {\n\t\t\tset_source_rgb(vec3(1.0,1.0,1.0));\n\t\t\trectangle(p0.xz, (p1 - p0).xz);\n\t\t\tstroke();\n\t\t\tbreak;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\t\n\n\t}\n\n\n}\n\n","name":"","description":"","type":"image"}]}}