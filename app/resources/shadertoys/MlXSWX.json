{"Shader":{"ver":"0.1","info":{"id":"MlXSWX","date":"1440598386","viewed":1478,"name":"Abstract Corridor","username":"Shane","description":"Using Nimitz's triangle noise idea and his curvature function to fake an abstract, flat-shaded, point-lit, mesh look.","likes":54,"published":3,"flags":0,"tags":["noise","tunnel","triangle","abstract"],"hasliked":0},"renderpass":[{"inputs":[{"id":6,"src":"\/presets\/tex05.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":9,"src":"\/presets\/tex08.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/*\n    Abstract Corridor\n    -------------------\n    \n    Using Shadertoy user Nimitz's triangle noise idea and his curvature function to fake an abstract, \n\tflat-shaded, point-lit, mesh look.\n\n\tIt's a slightly trimmed back, and hopefully, much quicker version my previous tunnel example... \n\twhich is not interesting enough to link to. :)\n\n*\/\n\n#define PI 3.1415926535898\n#define FH 1.0 \/\/ Floor height. Set it to 2.0 to get rid of the floor.\n\n\/\/ Grey scale.\nfloat getGrey(vec3 p){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\n\n\/\/ Non-standard vec3-to-vec3 hash function.\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n\/\/ 2x2 matrix rotation.\nmat2 rot2(float a){\n    \n    float c = cos(a); float s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n\/\/ Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); \/\/ max(abs(n), 0.001), etc.\n    n \/= (n.x + n.y + n.z );  \n    \n\treturn (texture2D(tex, p.yz)*n.x + texture2D(tex, p.zx)*n.y + texture2D(tex, p.xy)*n.z).xyz;\n}\n\n\/\/ The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n\/\/ See Xyptonjtroz - Very cool. Anyway, it's not really being used to its full potential here.\nvec3 tri(in vec3 x){return abs(x-floor(x)-.5);} \/\/ Triangle function.\n\n\/\/ The function used to perturb the walls of the cavern: There are infinite possibities, but this one is \n\/\/ just a cheap...ish routine - based on the triangle function - to give a subtle jaggedness. Not very fancy, \n\/\/ but it does a surprizingly good job at laying the foundations for a sharpish rock face. Obviously, more \n\/\/ layers would be more convincing. However, this is a GPU-draining distance function, so the finer details \n\/\/ are bump mapped.\nfloat surfFunc(in vec3 p){\n    \n\treturn dot(tri(p*0.5 + tri(p*0.25).yzx), vec3(0.666));\n}\n\n\n\/\/ The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ float s = sin(z\/24.)*cos(z\/12.); return vec2(s*12., 0.); }\n\n\/\/ Standard tunnel distance function with some perturbation thrown into the mix. A floor has been \n\/\/ worked in also. A tunnel is just a tube with a smoothly shifting center as you traverse lengthwise. \n\/\/ The walls of the tube are perturbed by a pretty cheap 3D surface function.\nfloat map(vec3 p){\n\n    \/\/ Square tunnel.\n    \/\/ For a square tunnel, use the Chebyshev(?) distance: max(abs(tun.x), abs(tun.y))\n    vec2 tun = abs(p.xy - path(p.z))*vec2(0.5, 0.7071);\n    float n = 1.- max(tun.x, tun.y) + (0.5-surfFunc(p));\n    return min(n, p.y + FH);\n\n\/*    \n    \/\/ Round tunnel.\n    \/\/ For a round tunnel, use the Euclidean distance: length(tun.y)\n    vec2 tun = (p.xy - path(p.z))*vec2(0.5, 0.7071);\n    float n = 1.- length(tun) + (0.5-surfFunc(p));\n    return min(n, p.y + FH);  \n*\/\n    \n\/*\n    \/\/ Rounded square tunnel using Minkowski distance: pow(pow(abs(tun.x), n), pow(abs(tun.y), n), 1\/n)\n    vec2 tun = abs(p.xy - path(p.z))*vec2(0.5, 0.7071);\n    tun = pow(tun, vec2(4.));\n    float n =1.-pow(tun.x + tun.y, 1.0\/4.) + (0.5-surfFunc(p));\n    return min(n, p.y + FH);\n*\/\n \n}\n\n\/\/ Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\n   \n    const float eps = 0.001;\n    float ref = getGrey(tex3D(tex,  p , nor));                 \n    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x-eps, p.y, p.z), nor))-ref,\n                      getGrey(tex3D(tex, vec3(p.x, p.y-eps, p.z), nor))-ref,\n                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z-eps), nor))-ref )\/eps;\n             \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n\/\/ Surface normal.\nvec3 getNormal(in vec3 p) {\n\t\n\tconst float eps = 0.001;\n\treturn normalize(vec3(\n\t\tmap(vec3(p.x+eps,p.y,p.z))-map(vec3(p.x-eps,p.y,p.z)),\n\t\tmap(vec3(p.x,p.y+eps,p.z))-map(vec3(p.x,p.y-eps,p.z)),\n\t\tmap(vec3(p.x,p.y,p.z+eps))-map(vec3(p.x,p.y,p.z-eps))\n\t));\n\n}\n\n\/\/ Based on original by IQ.\nfloat calculateAO(vec3 p, vec3 n){\n\n    const float AO_SAMPLES = 5.0;\n    float r = 0.0, w = 1.0, d;\n    \n    for (float i=1.0; i<AO_SAMPLES+1.1; i++){\n        d = i\/AO_SAMPLES;\n        r += w*(d - map(p + n*d));\n        w *= 0.5;\n    }\n    \n    return 1.0-clamp(r,0.0,1.0);\n}\n\n\/\/ Cool curve function, by Shadertoy user, Nimitz.\n\/\/\n\/\/ I wonder if it relates to the discrete finite difference approximation to the \n\/\/ continuous Laplace differential operator? Either way, it gives you a scalar \n\/\/ curvature value for an object's signed distance function, which is pretty handy.\n\/\/\n\/\/ From an intuitive sense, the function returns a weighted difference between a surface \n\/\/ value and some surrounding values. Almost common sense... almost. :) If anyone \n\/\/ could provide links to some useful articles on the function, I'd be greatful.\n\/\/\n\/\/ Original usage (I think?) - Cheap curvature: https:\/\/www.shadertoy.com\/view\/Xts3WM\n\/\/ Other usage: Xyptonjtroz: https:\/\/www.shadertoy.com\/view\/4ts3z2\nfloat curve(in vec3 p, in float w){\n\n    vec2 e = vec2(-1., 1.)*w;\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return 0.125\/(w*w) *(t1 + t2 + t3 + t4 - 4.*map(p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\t\/\/ Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)\/iResolution.y;\n\t\n\t\/\/ Camera Setup.\n\tvec3 lookAt = vec3(0.0, 0.0, iGlobalTime*5.);  \/\/ \"Look At\" position.\n\tvec3 camPos = lookAt + vec3(0.0, 0.1, -0.5); \/\/ Camera position, doubling as the ray origin.\n \n    \/\/ Light positioning. One is a little behind the camera, and the other is further down the tunnel.\n \tvec3 light_pos = camPos + vec3(0.0, 0.125, -0.125);\/\/ Put it a bit in front of the camera.\n\tvec3 light_pos2 = camPos + vec3(0.0, 0.0, 6.0);\/\/ Put it a bit in front of the camera.\n\n\t\/\/ Using the Z-value to perturb the XY-plane.\n\t\/\/ Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" function is \n\t\/\/ synchronized with the distance function. Change to \"path2\" to traverse the other tunnel.\n\tlookAt.xy += path(lookAt.z);\n\tcamPos.xy += path(camPos.z);\n\tlight_pos.xy += path(light_pos.z);\n\tlight_pos2.xy += path(light_pos2.z);\n\n    \/\/ Using the above to produce the unit ray-direction vector.\n    float FOV = PI\/3.; \/\/ FOV - Field of view.\n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    \/\/ rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    \/\/ Swiveling the camera from left to right when turning corners.\n    rd.xy = rot2( path(lookAt.z).x\/32. )*rd.xy;\n\t\t\n    \/\/ Standard ray marching routine. I find that some system setups don't like anything other than\n    \/\/ a \"break\" statement (by itself) to exit. \n\tfloat t = 0.0, dt;\n\tfor(int i=0; i<128; i++){\n\t\tdt = map(camPos + rd*t);\n\t\tif(dt<0.005 || t>150.){ break; } \n\t\tt += dt*0.75;\n\t}\n\t\n    \/\/ The final scene color. Initated to black.\n\tvec3 sceneCol = vec3(0.);\n\t\n\t\/\/ The ray has effectively hit the surface, so light it up.\n\tif(dt<0.005){\n\t\n\t    \/\/ The ray marching loop (above) exits when \"dt\" is less than a certain threshold, which in this \n        \/\/ case, is hardcoded to \"0.005.\" However, the distance is still \"dt\" from the surface? By my logic, \n\t    \/\/ adding the extra \"dt\" after breaking would gain a little more accuracy and effectively reduce \n\t    \/\/ surface popping? Would that be correct? I tend to do this, but could be completely wrong, so if \n\t    \/\/ someone could set me straight, it'd be appreciated. \n\t    t += dt;\n    \t\n    \t\/\/ Surface position and surface normal.\n\t    vec3 sp = t * rd+camPos;\n\t    vec3 sn = getNormal(sp);\n        \n        \/\/ Texture scale factor.\n        const float tSize0 = 1.\/1.; \n        const float tSize1 = 1.\/4.;\n    \t\n    \t\/\/ Texture-based bump mapping.\n\t    if (sp.y<-(FH-0.005)) sn = doBumpMap(iChannel1, sp*tSize1, sn, 0.025); \/\/ Floor.\n\t    else sn = doBumpMap(iChannel0, sp*tSize0, sn, 0.025); \/\/ Walls.\n\t    \n\t    \/\/ Ambient occlusion.\n\t    float ao = calculateAO(sp, sn);\n    \t\n    \t\/\/ Light direction vectors.\n\t    vec3 ld = light_pos-sp;\n\t    vec3 ld2 = light_pos2-sp;\n\n        \/\/ Distance from respective lights to the surface point.\n\t    float distlpsp = max(length(ld), 0.001);\n\t    float distlpsp2 = max(length(ld2), 0.001);\n    \t\n    \t\/\/ Normalize the light direction vectors.\n\t    ld \/= distlpsp;\n\t    ld2 \/= distlpsp2;\n\t    \n\t    \/\/ Light attenuation, based on the distances above.\n\t    float atten = min(1.\/(distlpsp) + 1.\/(distlpsp2), 1.);\n    \t\n    \t\/\/ Ambient light.\n\t    float ambience = 0.25;\n    \t\n    \t\/\/ Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n\t    float diff2 = max( dot(sn, ld2), 0.0);\n    \t\n    \t\/\/ Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 8.);\n\t    float spec2 = pow(max( dot( reflect(-ld2, sn), -rd ), 0.0 ), 8.);\n    \t\n    \t\/\/ Curvature.\n\t    float crv = clamp(curve(sp, 0.125)*0.5+0.5, .0, 1.);\n\t    \n\t    \/\/ Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 1.);\n        \n        \/\/ Obtaining the texel color. If the surface point is above the floor\n        \/\/ height use the wall texture, otherwise use the floor texture.\n        vec3 texCol;\n        if (sp.y<-(FH-0.005)) texCol = tex3D(iChannel1, sp*tSize1, sn); \/\/ Floor.\n \t    else texCol = tex3D(iChannel0, sp*tSize0, sn); \/\/ Walls.\n       \n        \/\/ Shadertoy doesn't appear to have anisotropic filtering turned on... although,\n        \/\/ I could be wrong. Texture-bumped objects don't appear to look as crisp. Anyway, \n        \/\/ this is just a very lame, and not particularly well though out, way to sparkle \n        \/\/ up the blurry bits. It's not really that necessary.\n        \/\/vec3 aniso = (0.5-hash33(sp))*fre*0.35;\n\t    \/\/texCol = clamp(texCol + aniso, 0., 1.);\n    \t\n    \t\/\/ Darkening the crevices. Otherwise known as cheap, scientifically-incorrect shadowing.\t\n\t    float shading =  crv*0.5+0.5; \n    \t\n    \t\/\/ Combining the above terms to produce the final color. It was based more on acheiving a\n        \/\/ certain aesthetic than science.\n        \/\/\n        \/\/ Glow.\n        sceneCol = getGrey(texCol)*((diff+diff2)*0.75 + ambience*0.25) + (spec+spec2)*texCol*2. + fre*crv*texCol.zyx*2.;\n        \/\/\n        \/\/ Other combinations:\n        \/\/\n        \/\/ Shiny.\n        \/\/sceneCol = texCol*((diff+diff2)*vec3(1.0, 0.95, 0.9) + ambience + fre*fre*texCol) + (spec+spec2);\n        \/\/ Abstract pen and ink?\n        \/\/float c = getGrey(texCol)*((diff+diff2)*1.75 + ambience + fre*fre) + (spec+spec2)*0.75;\n        \/\/sceneCol = vec3(c*c*c, c*c, c);\n\n\t    \n        \/\/ Shading.\n        sceneCol *= atten*shading*ao;\n        \n        \/\/ Drawing the lines on the walls. Comment this out and change the first texture to\n        \/\/ granite for a granite corridor effect.\n        sceneCol *= clamp(1.-abs(curve(sp, 0.0125)), .0, 1.);        \n\t   \n\t\n\t}\n\t\n\tfragColor = vec4(clamp(sceneCol, 0., 1.), 1.0);\n\t\n}","name":"","description":"","type":"image"}]}}