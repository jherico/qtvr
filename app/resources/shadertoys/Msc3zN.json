{"Shader":{"ver":"0.1","info":{"id":"Msc3zN","date":"1448450817","viewed":312,"name":"(CLEAN) first shader\/sdf ","username":"sagarpatel","description":"This is a clean\/from scratch re-implementation of my first shdaer\/sdf, which was based on @cabbibo's awesome SDF tutorial and iq's Raymarching Primitives.<br\/>Tons of comments explaining how I derived stuff.","likes":2,"published":3,"flags":0,"tags":["procedural","3d","raymarching","distancefields","sdf","tutorial"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ CC0 1.0\n\/\/ @sagzorz\n\n\/\/ NOTE: if you are new to SDFs, do @cabbibo's tutorial first!!!\n\/\/ \n\/\/ @cabbibo's original SDF tutorial --> https:\/\/www.shadertoy.com\/view\/Xl2XWt\n\/\/ my original hacked up shader --> https:\/\/www.shadertoy.com\/view\/4d33z4\n\n\/\/ this is a clean\/from scratch re-implementation of my first shdaer\/sdf,\n\/\/ which was based on @cabbibo's awesome SDF tutorial\n\/\/ also used functions from iq's super handy page about distance functions\n\/\/ http:\/\/iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\n\/\/ resstructured to be closer to iq's Raymarching Primitives example\n\/\/ https:\/\/www.shadertoy.com\/view\/Xds3zN\n\n\/\/ NOW PROPERLY MARCHING THE RAY!\n\/\/ (was using silly hack in original version to compensate for twist artifacts)\n\/\/ Performs much better than old version\n\n\/\/ the sd functions below are the same as from iq's page (link above)\n\/\/ though when I wrote this version I derived from scratch as much as I could on my own \n\/\/ by thinking\/sketching on paper etc. \n\/\/ The comments explain my interpretation of the funcs\n\n\/\/ for all signed distance functions sd*() below,\n\/\/ input p --> is ray position, where the object is at the origin (0,0,0)\n\/\/ output float is distance from ray position to surface of sphere\n\/\/ \tpositive means outside of sphere\n\/\/ \tnegative means ray is inside\n\/\/ \t0 means its exactly on the surface\n\n\n\/\/ ~~~~~~~ signed fistance fuction for sphere\n\/\/ input r --> is sphere radius\n\/\/ pretty simple, just compare point to radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n\/\/ ~~~~~~~ signed distance function for box\n\/\/ input s -- > is box size vector (all postive values)\n\/\/\n\/\/ the key to simply calcualting distance to surface to box is to first \n\/\/ force the ray position into the first octant (all positive values)\n\/\/ this massively simplifies the math and is ok since distance to surf\n\/\/ on a box is the same in the - or + direction on a given axis\n\/\/ simple to figure by once you sketch out 2D equivalent problem on papaer\n\/\/ 2D ex: distance to box of size (2,1) \n\/\/ for p of (-3,-2) == (-3, 2) == (3, -2) == (3, 2)\n\/\/\n\/\/ now that all the coordinates are \"normalized\"\/positive, its much easier,\n\/\/ the next part is to figure out the diff between the box surface the and p\n\/\/ a bit like the sphere function were you do p - \"shape size\", but\n\/\/ you clamp the result to >0, done below by using max() with 0\n\/\/ i'm having trouble putting this into words corretcly, but it was really easy\n\/\/ to understand once I sketched out a rect and points on paper, \n\/\/ that was enough for me to be able to derive the 3D version \n\/\/\n\/\/ the last part is to account for is p is insde the box, \n\/\/ in which case we need to return a negative value\n\/\/ for that value, its a simple check of which side is the closest\nfloat sdBox(vec3 p, vec3 s)\n{\n    vec3 diffVec = abs(p) - s;\n    float surfDiff_Outter = length(max(diffVec,0.0));\n    float surfDiff_Inner = min( max(diffVec.z,max(diffVec.x,diffVec.y)),0.0);\n    return surfDiff_Outter + surfDiff_Inner;              \n}\n\/*\n\/\/ Minimial IQ version\nfloat sdBox( vec3 p, vec3 s )\n{\n  vec3 d = abs(p) - s;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n*\/\n\n\/\/ ~~~~~~~ signed distance function for torus\n\/\/ input t --> torus specs where:\n\/\/ \tt.x = torus circumference\n\/\/\tt.y = torus thickness\n\/\/  \n\/\/ think of the torus as circles wrappeed around 1 large cicle (perpendicular)\n\/\/ first flatten the y axis of p (by using p.xz) and get the distance to \n\/\/ the torus circumference\/core\/radius which is flat on the y axis\n\/\/ then simply subtract the torus thickenss from that \nfloat sdTorus(vec3 p, vec2 t)\n{\n    float distPtoTorusCircumference = length(vec2( length(p.xz)-t.x , p.y));\n    return distPtoTorusCircumference - t.y;\n}\n\/*\n\/\/ IQ version\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n*\/\n\n\/\/ ~~~~~~~ smooth minimum function (polynomial version) from iq's page\n\/\/ http:\/\/iquilezles.org\/www\/articles\/smin\/smin.htm\n\/\/ input d1 --> distance value of object a\n\/\/ input d1 --> distance value of object b\n\/\/ output --> smoothed\/blended output\nfloat smin( float d1, float d2)\n{\n    float k = 0.6521;\n    float h = clamp( 0.5+0.5*(d2-d1)\/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n\/\/ ~~~~~~~ distance deformation, blends 2 shapes based on their distances\n\/\/ input d1 --> distance of object 1\n\/\/ input d2 --> distance of object 2\n\/\/ output --> blended object\nfloat opBlend( float d1, float d2)\n{    \n    return smin( d1, d2 );\n}\n\n\/\/ ~~~~~~~ domain deformation, twists the shape\n\/\/ input p --> original ray position\n\/\/ input t --> twist scale factor\n\/\/ output --> twisted ray position\n\/\/ \n\/\/ need more max itterations on ray march for stronger\/bigger domain deformation\nvec3 opTwist( vec3 p, float t, float yaw )\n{\n    float  c = cos(t * p.y + yaw);\n    float  s = sin(t * p.y + yaw);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n\/\/ ~~~~~~~ do Union \/ combine 2 sd objects\n\/\/ input vec2 --> .x is the distance, .y is the object ID\n\/\/ returns the closest object (basically does a min() but we use if() \nvec2 opU(vec2 o1, vec2 o2)\n{\n    if(o1.x < o2.x)\n        return o1;\n    else \n        return o2;\n}\n\n\/\/ ~~~~~~~ map out the world\n\/\/ input p --> is ray position\n\/\/ basically find the object\/point closest to the ray by\n\/\/ checking all the objects with respect to p\n\/\/ move objects\/shapes by messing with p\nvec2 map(vec3 p)\n{\n    \/\/ results container\n    vec2 res;    \n    \n    \/\/ define objects\n    \t\/\/ sphere 1\n    \t\/\/ sphere: radius, orbit radius, orbit speed, orbit offset, position\n    float sR = 1.359997;\n    float sOR = 2.666662;\n    float sOS = 0.85;\n    vec3 sOO = vec3(2.66662,0.0,0.0);\n    vec3 sP = p - (sOO + vec3(sOR*cos(sOS*iGlobalTime),sOR*sin(sOS*iGlobalTime),0.0));\n    vec2 sphere_1 = vec2( sdSphere(sP,sR), 1.0 );\n\t\t\n    \t\/\/\ttorus 1    \n    vec2 torusSpecs = vec2(1.6, 0.613333);\n    float twistSpeed = 0.35;\n    float twistPower = 5.0*sin(twistSpeed * iGlobalTime);\n    \t\/\/ to twist the torus (or any object), we actually distort p\/space (domain) itself,\n    \t\/\/ this then gives us a distorted view of the object\n    vec3 torusPos = vec3(0.0);\n    vec3 distortedP = opTwist(p - torusPos, twistPower, 0.0) ;\n        \/\/ \tdomain distortion correction:\n        \/\/ \tneeded to find this by hand, inversely proportional to domain deformation\n    float ddc = 0.25;\n    vec2 torus_1 = vec2(ddc * sdTorus(distortedP, torusSpecs), 2.0);\n    \n    \/\/ combine and blend objects\n    res = opU( sphere_1, torus_1 );\n    res.x = opBlend( sphere_1.x, torus_1.x );    \n    \/\/res.x = torus_1.x;\n    \n    return res;\n}\n\n\/\/ ~~~~~~~ cast\/march ray through the word and see what it hits\n\/\/ input ro --> ray origin point\/position\n\/\/ input rd --> ray direction\n\/\/ output is vec2 where\n\/\/ \t.x = distance travelled by ray\n\/\/ .y = hit object's ID\n\/\/\nvec2 castRay( vec3 ro, vec3 rd)\n{\n\t\/\/ variables used to control the marching process\n    const int maxMarchCount = 300;\n    float maxRayDistance = 20.0;\n    float minPrecisionCheck = 0.001;\n    \n    float t = 0.0; \/\/ travelled distance by ray\n    float id = -1.0; \/\/ object ID, default of -1 means background\n    \n    for(int i = 0; i < maxMarchCount; i++)\n    {\n        \/\/ get closest object to current ray position\n        vec2 res = map(ro + rd*t);\n        \n        \/\/ stop itterating\/marching once either we've past max ray length \n        \/\/ or\n        \/\/ once we're close enough to an object (defined by the precision check variable)\n       \tif(t > maxRayDistance || res.x < minPrecisionCheck)\n           break;\n        \n        \/\/ move ray forward by distance to closet object, see\n        \/\/ http:\/\/http.developer.nvidia.com\/GPUGems2\/elementLinks\/08_displacement_05.jpg\n        t += res.x; \n        id = res.y;\n    }\n    \n    \/\/ if ray goes beyond max distance, force ID back to background one\n    if(t > maxRayDistance)\n        id = -1.0;\n    \n    return vec2(t, id);\n}\n\n\/\/ ~~~~~~ calculate normal of closest objects surface given a ray position\n\/\/ input p --> ray position (calculated previously from ray cast position, no iteration now\n\/\/ output --> surface normal vector\n\/\/\n\/\/ gets the surface normal by sampling neaby points and getting direction of diffs\n\nvec3 calculateNormal(vec3 p)\n{\n    float normalEpsilon = 0.0001;\n    vec3 eps = vec3(normalEpsilon,0,0);\n    vec3 normal = vec3( map(p + eps.xyy).x - map(p - eps.xyy).x,\n                       \tmap(p + eps.yxy).x - map(p - eps.yxy).x,\n                       \tmap(p + eps.yyx).x - map(p - eps.yyx).x\n                       );\n    return normalize(normal);\n}\n\n\/\/ ~~~~~~~ render pixel --> find closest surface and apply color accordingly\n\/\/ input ro --> pixel's ray original position\n\/\/ input rd --> pixel's ray direction\n\/\/ output --> pixel color\nvec3 render(vec3 ro, vec3 rd)\n{\n    vec3 bkgColor = vec3(0.75);\n    vec3 light = normalize( vec3(1.0, 4.0, 3.0) );\n    vec3 objectColor_1 = vec3(1.0, 0.0, 0.0);\n    vec3 objectColor_2 = vec3( 0.25 , 0.95 , 0.25 );\n    vec3 objectColor_3 = vec3(0.12, 0.12, 0.9);\n    vec3 ambientLightColor = vec3( 0.3 , 0.1, 0.2 );\n    \n    vec2 res = castRay(ro, rd);\n    float t = res.x;\n    float id = res.y;\n    \n    \/\/ hard set pixel value if its a background one\n    if(id == -1.0)\n    \treturn bkgColor;\n    else\n    {\n        \/\/ calculate pixel normal\n        vec3 pos = ro + t*rd;\n        vec3 normal = calculateNormal(pos);\n        vec3 objectColor = vec3(1);\n        \n        if(id == 1.0)\n            objectColor = objectColor_1;\n        else if(id == 2.0)\n            objectColor = objectColor_2;\n        else if(id == 3.0)\n            objectColor = objectColor_3;\n        \n        float surf = clamp(dot(normal, light), 0.0, 1.0);\n        vec3 pixelColor = objectColor * surf + ambientLightColor;\n\t\treturn pixelColor;            \n    }\n}\n\n\/\/ ~~~~~~~ creates camera matrix used to transform ray point\/direction\n\/\/ input camPos --> camera position\n\/\/ input targetPos --> look at target position\n\/\/ input roll --> how much camera roll\n\/\/ output --> camera matrix used to transform\nmat3 setCamera( in vec3 camPos, in vec3 targetPos, float roll )\n{\n\tvec3 cw = normalize(targetPos - camPos);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    \n    \/\/ get pixel (range from -1.0 to 1.0)\n    vec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) \/ iResolution.y;\n    \n    \/\/ camera stuff\n    float camOrbitSpeed = 0.5;\n    float camOrbitRadius = 7.3333;\n    float camPosX = camOrbitRadius * cos( camOrbitSpeed * iGlobalTime);\n    float camPosZ = camOrbitRadius * sin( camOrbitSpeed * iGlobalTime);\n    vec3 camPos = vec3(camPosX, 0.5, camPosZ);\n    vec3 lookAtTarget = vec3(0.0);\n    mat3 camMatrix = setCamera(camPos, lookAtTarget, 0.0);\n    \n    \/\/ determines ray direction based on camera matrix\n    \/\/ \"lens length\" seems to be related to field of view \/ ray divergence\n    float lensLength = 2.0;\n    vec3 rd = camMatrix * normalize( vec3(p.xy,2.0) );\n    vec3 col = render(camPos,rd);\n    \n\tfragColor = vec4(col,1.0);\n}\n\n\n","name":"","description":"","type":"image"}]}}