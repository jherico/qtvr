{"Shader":{"ver":"0.1","info":{"id":"XsSXDt","date":"1416936415","viewed":1385,"name":"AA Methods","username":"eiffie","description":"Why use your graphics card's features when you can write incredibly over complex code to do the same? Here is a comparison of some of the AA methods I've tried.","likes":42,"published":3,"flags":0,"tags":["antialias","aa"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ AA Methods by eiffie\n\/\/ A comparison of some of the crazy AA methods I've used.\n\/\/ v2 added the FAKE_AA method\n\n\/\/ USE_STANDARD_AA: is a typical 2x2 method but I've added some features to\n\/\/   push the ray a bit farther...\n\/\/   ADD_RAYS_CAN_BE_FEADERS: If a raymarch dies before coming within two pixels\n\/\/     then the next rays start at that point. Instead of being used as samples they\n\/\/     are used to \"fead\" the other rays.\n\/\/   ADD_AUTO_OVERSTEP: Pushes the march faster and backs up if it bumps its head.\n\/\/   ADD_BISECT_ERROR: When you bump your head back up half way.\n\/\/  Also I calc the pixel occlusion so edges are near perfect! The downside is it still\n\/\/  unrolls to 4X the number of instructions.\n\n\/\/  USE_EDGE_DETECT_AA: This is the same AA used in \"Wood Scraps\" only a bit better\n\/\/    implementation with up to 4 edges being drawn per ray. For each edge the pixel \n\/\/    coverage is calculated and the edges are drawn back to front. This method is fast\n\/\/    (one ray march, 4 lighting calculations) but totally fails on really complex surfaces. \n\n\/\/  USE_FAKE_AA: Only the first edge and most occluding surface are used to calc pixel \n\/\/    coverage. One extra set of lighting calculations is needed. If no first edge is detected \n\/\/    the second lighting calc is offset by half a pixel. Because the second\n\/\/    lighting calc is always performed it runs slower than the 4 edge detect!\n\n\/\/  USE_CHEAP_AA: Only the closest surface is used to calc pixel occlusion. No extra\n\/\/    distance estimates are needed but it only smooths the outer edges.\n\n\/\/uncomment one AA type...\n\/\/#define USE_STANDARD_AA\n\t#define ADD_RAYS_CAN_BE_FEADERS\n\t#define ADD_AUTO_OVERSTEP\n\t#define ADD_BISECT_ERROR\n\/\/#define USE_EDGE_DETECT_AA\n#define USE_FAKE_AA\n\/\/#define USE_CHEAP_AA\n\n\/\/for the green line treatment uncomment this...\n\/\/#define COMPARE_TO_NO_AA\n\n#define time iGlobalTime\n#define size iResolution\n#define MAX_DIST 10.0\n\nbool bColoring=false;\/\/i luv globals\nvec3 mcol,offset;\nfloat scale,mr;\nfloat DE(in vec3 z0){\/\/menger sponge by menger\n\tvec4 z=vec4(z0,1.0)\/clamp(dot(z0,z0),mr,1.0);\/\/with a ballfold\n\tfor (int n = 0; n <4; n++) {\n\t\tz = abs(z);\n\t\tif (z.x<z.y)z.xy = z.yx;\n\t\tif (z.x<z.z)z.xz = z.zx;\n\t\tif (z.y<z.z)z.yz = z.zy;\n\t\tz = z*scale;\n\t\tz.xyz -= offset*(scale-1.0);\n\t\tif(bColoring && n==2)mcol+=vec3(0.5)+sin(z.xyz)*0.4;\n\t\tif(z.z<-0.5*offset.z*(scale-1.0))z.z+=offset.z*(scale-1.0);\n\t}\n\treturn (length(max(abs(z.xyz)-vec3(1.0),0.0))-0.05)\/z.w;\n}\nfloat rndStart(vec2 co){return 0.8+0.2*fract(sin(dot(co,vec2(123.42,117.853)))*412.453);}\nfloat ShadAO(vec3 ro, vec3 rd, float px, vec2 fragCoord){\/\/pretty much IQ's SoftShadow\n\tfloat res=1.0,d,t=4.0*px*rndStart(fragCoord.xy);\n\tfor(int i=0;i<12;i++){\n\t\td=max(0.0,DE(ro+rd*t))+0.01;\n\t\tres=min(res,d\/t);\n\t\tt+=d;\n\t}\n\treturn res;\n}\nmat3 lookat(vec3 fw,vec3 up){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,up));return mat3(rt,cross(rt,fw),fw);\n}\nvec3 light_dir,light_col=vec3(1.0,0.0,0.0);\nvec3 Light(vec3 so, vec3 rd, float px, float dist, vec2 fragCoord){\n\tvec2 v=vec2(0.5*px,0.0);\/\/px is really pixelSize*t\n    so-=rd*(px-dist);\n\tmcol=vec3(0.0);\n\tbColoring=true;\/\/take color samples\n\tvec3 norm=normalize(vec3(-DE(so-v.xyy)+DE(so+v.xyy),-DE(so-v.yxy)+DE(so+v.yxy),-DE(so-v.yyx)+DE(so+v.yyx)));\n\tbColoring=false;\/\/crappy lighting below\n\tvec3 diffuse_col=mcol\/6.0+vec3(-0.125,0.0,0.125)*dot(norm,rd);\n\tfloat shad=ShadAO(so,light_dir,px,fragCoord),dif=dot(norm,light_dir)*0.5+0.5;\n\tfloat spec=0.25*pow(max(0.0,dot(light_dir,reflect(rd,norm))),0.25);\n\tdif=clamp(min(dif,shad)+0.15,0.0,1.0);\n\treturn diffuse_col*dif+light_col*spec*shad;\n}\nvec4 shape(float t){\n\tt=mod(t,9.0);\n\tif(t<1.0)return vec4(0.865,1.24,1.48,2.38);\n\tif(t<2.0)return vec4(1.54,-0.02,0.7,2.4);\n\tif(t<3.0)return vec4(0.785,1.1,0.46,2.47);\n\tif(t<4.0)return vec4(0.86,0.7,0.1,2.13);\n\tif(t<5.0)return vec4(0.9,1.485,0.54,2.04);\n\tif(t<6.0)return vec4(1.3,-0.02,-0.14,1.79);\n\tif(t<7.0)return vec4(2.0,-0.3,0.42,2.05);\n\tif(t<8.0)return vec4(1.0,1.0,1.0,3.0);\n\treturn vec4(2.0,0.56,-0.44,2.31);\n}\nvoid ShapeIt(float t){\n\tt\/=3.0;\n\tvec4 sh=mix(shape(t),shape(t+0.1),smoothstep(0.9,1.0,fract(t)));\n\tscale=sh.w;offset=sh.xyz;mr=0.56+sqrt(abs(fract(t)-0.5)*0.4);\n}\nvec3 getRay(int RAY,float zoom,vec2 fragCoord){\/\/creates the unrotated camera ray\n\tvec2 aa=vec2(floor((float(RAY)+0.1)*0.5),mod(float(RAY),2.0));\n\treturn normalize(vec3((2.0*fragCoord.xy+aa-size.xy)\/size.y,zoom));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tfloat zoom=5.0,px=2.0\/(size.y*zoom),MIN_DIST=px*0.01;\/\/find the pixel size\n\tfloat time2=time*0.1,tim=sin(time2)*1.5;\/\/anim junk\n\tlight_dir=normalize(vec3(0.4+sin(time2*5.0-tim),0.7,0.5+sin(time2+tim)*0.7));\n\tShapeIt(time*0.5+tim);\n\t\/\/position camera\n\tvec3 ro=vec3(sin(tim),0.75+0.25*sin(time2*1.3),cos(tim))*(4.25+0.75*sin(time2*1.7));\n\tvec3 rd,up=normalize(vec3(sin(time+tim)*0.3,1.0,0.0));\n\tmat3 cam=lookat(-ro,up);\n\t\n\tvec3 col=vec3(0.0),bcol=vec3(fragCoord.y\/size.y);\n\tfloat t=DE(ro)*rndStart(fragCoord.xy)*0.75,d;\n\t\n#ifdef USE_STANDARD_AA\n\tfloat t0=t;\n#ifdef ADD_RAYS_CAN_BE_FEADERS\n\tbool bSavedDepth=false;\n#else\n\tbool bSavedDepth=true;\n#endif\n\tvec3 closest[4];\n\tfor(int RAY=0;RAY<4;RAY++){\n\t\tclosest[RAY]=vec3(1000.0,0.0,0.0);\n\t\trd=cam*getRay(RAY,zoom);\n\t\tfloat pd=10.0,os=0.0,step=0.0;\n\t\tt=t0;\n\t\tfor(int i=0;i<48;i++){\n\t\t\td=DE(ro+rd*t);\n#ifdef ADD_AUTO_OVERSTEP\n\t\t\tif(d>os){\t\t\/\/we have NOT stepped over anything\n\t\t\t\tos=0.4*d*d\/pd;\/\/calc overstep based on ratio of this step to last\n\t\t\t\tstep=d+os;\t\/\/add in the overstep\n\t\t\t\tpd=d;\t\/\/save this step length for next calc\n\t\t\t}else{\n#ifdef ADD_BISECT_ERROR\t\n\t\t\t\tos*=0.5;step=-os;\t\/\/remove half of overstep\n\t\t\t\tif(os>0.0001)d=1.0;\/\/don't bail\n\t\t\t\telse step=d+os;\n#else\n\t\t\t\tstep=-os;d=1.0;pd=10.0;os=0.0;\/\/remove ALL of overstep\n#endif\n\t\t\t}\n#else\n\t\t\tstep=d; \/\/normal march\n#endif\t\t\t\n\t\t\tif(d<closest[RAY].x)closest[RAY]=vec3(d,t,float(bSavedDepth));\n\t\t\tif(!bSavedDepth && d<2.0*px*t){bSavedDepth=true;t0=t-2.0*px*t;}\n\t\t\tt+=step;\n\t\t\tif(t>MAX_DIST || d<MIN_DIST)break;\/\/hard stop\n\t\t}\n\t\tif(!bSavedDepth)t0=t-2.0*px*t;\n\t}\n\tif(bSavedDepth){\n\t\tfloat hit=0.0;\n\t\tfor(int RAY=3;RAY>=0;RAY--){\n\t\t\tif(closest[RAY].x<px*closest[RAY].y){\n\t\t\t\tvec3 rd=cam*getRay(RAY,zoom);\n\t\t\t\tvec3 scol=Light(ro+rd*closest[RAY].y,rd,px*closest[RAY].y,closest[RAY].x);\n\t\t\t\tvec3 bgc=bcol;\n\t\t\t\tif(!bool(closest[RAY].z))bgc=col\/hit;\n\t\t\t\tscol=mix(scol,bgc,clamp(closest[RAY].x\/(px*closest[RAY].y),0.0,1.0));\n\t\t\t\tcol+=scol;\n\t\t\t\thit+=1.0;\n\t\t\t}else{\n\t\t\t\tif(bool(closest[RAY].z)){\n\t\t\t\t\tcol+=bcol;hit+=1.0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcol\/=hit;\n\t}else col=bcol;\n#elif defined USE_EDGE_DETECT_AA\n\trd=cam*getRay(0,zoom);\n\t\/\/march\n\tt=DE(ro)*rndStart(fragCoord.xy);d=1.0;\n\tfloat od=1000.0;\/\/last dist\n\tbool bGrab=false;\/\/should we save the depth\n\tvec4 hit=vec4(-1.0);\/\/we will grab up to 4 depths that are local mins\n\tfor(int i=0;i<64;i++){\n\t\td=DE(ro+rd*t);\n\t\tif(d>od){\/\/we are moving away from the surface\n\t\t\tif(bGrab && od<px*(t-od) && hit.x<0.0){\/\/we want to draw this edge, it occludes the pixel\n\t\t\t\thit.x=t-od;\/\/save the depth\n\t\t\t\thit=hit.yzwx;\/\/push\n\t\t\t\tbGrab=false;\/\/do not save any more depths for this edge\n\t\t\t}\n\t\t}else bGrab=true;\/\/we are approaching a new edge so get ready to save it\n\t\tod=d;t+=d;\/\/save the old dist and march\n\t\tif(t>MAX_DIST || od<MIN_DIST)break;\/\/hard stop\n\t}\n\tif(od<px*(t-d)){\/\/if we stopped before leaving an edge save it\n\t\tif(hit.x>0.0)hit=hit.wxyz;\/\/write over the last entry, not the first\n\t\thit.x=t-d;hit=hit.yzwx;\n\t}\n\t\n\t\/\/composite\n\tcol=bcol;\n\tfor(int i=0;i<4;i++){\/\/play back the hits and mix the color samples\n\t\thit=hit.wxyz;\/\/pop\n\t\tif(hit.x>0.0){\n\t\t\tfloat ds=DE(ro+rd*hit.x);\n\t\t\tif(ds<px*hit.x)\/\/if close enough mix in the surface coloring\n\t\t\t\tcol=mix(Light(ro+rd*hit.x,rd,px*hit.x,ds),col,clamp(ds\/(px*hit.x),0.0,1.0));\n\t\t}\n\t}\n#elif defined USE_FAKE_AA\n\trd=cam*getRay(0,zoom,fragCoord);\n\tfloat dm=100.0,tm=0.0,df=100.0,tf=0.0,od=1000.0;\n\tfor(int i=0;i<64;i++){\n\t\td=DE(ro+rd*t);\n\t\tif(df==100.0){\/\/save the first edge\n\t\t\tif(d>od){\/\/we are moving away from the surface\n\t\t\t\tif(od<px*(t-od)){\/\/we want to draw this edge, it occludes the pixel\n\t\t\t\t\tdf=od;tf=t-od;\/\/save the depth\n\t\t\t\t}\n\t\t\t}\n\t\t\tod=d;\/\/remember the old distance\n\t\t}\n\t\tif(d<dm){tm=t;dm=d;}\/\/and save the max occluder\n\t\tt+=d;\n\t\tif(t>MAX_DIST || d<MIN_DIST)break;\/\/hard stop\n\t}\n\tcol=bcol;\/\/add the lighting\n\tif(dm<px*tm){\/\/max occluder (min distance)\n\t\tcol=mix(Light(ro+rd*tm,rd,px*tm,dm,fragCoord),col,clamp(dm\/(px*tm),0.0,1.0));\n\t}\n\tfloat p=0.0;\n\tif(df==100.0 || tm==tf){\/\/if no first edge then do a jittered lighting calc\n\t\tro+=cam*vec3(0.5,0.5,0.0)*px*tm;tf=tm;df=dm;p=0.5;\/\/not really jittered :(\n\t}\n\tcol=mix(Light(ro+rd*tf,rd,px*tf,df,fragCoord),col,clamp(p+df\/(px*tf),0.0,1.0));\n\n#elif defined USE_CHEAP_AA\n\trd=cam*getRay(0,zoom);\n\tfloat dm=100.0,tm=0.0;\n\tfor(int i=0;i<64;i++){\n\t\tt+=d=DE(ro+rd*t);\n\t\tif(d<dm){tm=t;dm=d;}\n\t\tif(t>MAX_DIST || d<MIN_DIST)break;\/\/hard stop\n\t}\n\tif(dm<2.0*px*tm){\n\t\tcol=mix(Light(ro+rd*tm,rd,px*tm,dm),bcol,clamp(dm\/(px*tm),0.0,1.0));\n\t}else col=bcol;\n#endif\n#ifdef COMPARE_TO_NO_AA\n\trd=cam*getRay(0,zoom);\n\tif(fragCoord.x>size.x*0.5){\/\/for comparison\n\t\tif(d<10.0*px*t)col=Light(ro+rd*t,rd,px*t,d);\/\/single hit\n\t\telse col=bcol;\n\t}\n\tcol=mix(vec3(0.0,1.0,0.0),col,smoothstep(0.0,1.0,abs(fragCoord.x-size.x*0.5)));\n#endif\n\tfragColor=vec4(col,1.0);\n}","name":"","description":"","type":"image"}]}}