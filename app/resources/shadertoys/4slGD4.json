{"Shader":{"ver":"0.1","info":{"id":"4slGD4","date":"1370540644","viewed":14524,"name":"Mountains","username":"Dave_Hoskins","description":"A Shader version of my terrain renderer:-<br\/>http:\/\/www.youtube.com\/watch?v=qzkBnCBpQAM<br\/>USE MOUSE > TO SHIFT TIME<br\/><br\/><br\/>Video of my OpenGL version that uses streaming texture normals for speed...<br\/>http:\/\/www.youtube.com\/watch?v=qzkBnCBpQAM","likes":138,"published":3,"flags":64,"tags":["raymarching","terrain","landscape","mountains","vr","soundcloud"],"hasliked":0},"renderpass":[{"inputs":[{"id":428,"src":"https:\/\/soundcloud.com\/zzzzra\/zzzzra-conclusion-wip","ctype":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Mountains. By David Hoskins - 2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ https:\/\/www.shadertoy.com\/view\/4slGD4\n\/\/ A ray-marched version of my terrain renderer which uses\n\/\/ streaming texture normals for speed:-\n\/\/ http:\/\/www.youtube.com\/watch?v=qzkBnCBpQAM\n\n\/\/ It uses binary subdivision to accurately find the height map.\n\/\/ Lots of thanks to I\u00f1igo and his noise functions!\n\n\/\/ Video of my OpenGL version that \n\/\/ http:\/\/www.youtube.com\/watch?v=qzkBnCBpQAM\n\n\/\/ Stereo version code thanks to Croqueteer :)\n\/\/#define STEREO \n\nfloat treeLine = 0.0;\nfloat treeCol = 0.0;\n\n\nvec3 sunLight  = normalize( vec3(  0.4, 0.4,  0.48 ) );\nvec3 sunColour = vec3(1.0, .9, .83);\nfloat specular = 0.0;\nvec3 cameraPos;\nfloat ambient;\nvec2 add = vec2(1.0, 0.0);\n#define MOD2 vec2(3.07965, 7.4235)\n#define MOD3 vec3(3.07965, 7.1235, 4.998784)\n\n\/\/ This peturbs the fractal positions for each iteration down...\n\/\/ Helps make nice twisted landscapes...\nconst mat2 rotate2D = mat2(1.3623, 1.7531, -1.7131, 1.4623);\n\n\/\/ Alternative rotation:-\n\/\/ const mat2 rotate2D = mat2(1.2323, 1.999231, -1.999231, 1.22);\n\n\n\/\/  1 out, 2 in...\nfloat Hash12(vec2 p)\n{\n\tp  = fract(p \/ MOD2);\n    p += dot(p.xy, p.yx+19.19);\n    return fract(p.x * p.y);\n}\nvec2 Hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) \/ MOD3);\n    p3 += dot(p3.zxy, p3.yxz+19.19);\n    return fract(vec2(p3.x * p3.y, p3.z*p3.x));\n}\n\n\nfloat Noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    float res = mix(mix( Hash12(p),          Hash12(p + add.xy),f.x),\n                    mix( Hash12(p + add.yx), Hash12(p + add.xx),f.x),f.y);\n    return res;\n}\n\nvec2 Noise2( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y * 57.0;\n   vec2 res = mix(mix( Hash22(p),          Hash22(p + add.xy),f.x),\n                  mix( Hash22(p + add.yx), Hash22(p + add.xx),f.x),f.y);\n    return res;\n}\n\n\/\/--------------------------------------------------------------------------\nfloat Trees(vec2 p)\n{\n\t\n \t\/\/return (texture2D(iChannel1,0.04*p).x * treeLine);\n    return Noise(p*13.0)*treeLine;\n}\n\n\n\/\/--------------------------------------------------------------------------\n\/\/ Low def version for ray-marching through the height field...\n\/\/ Thanks to IQ for all the noise stuff...\n\nfloat Terrain( in vec2 p)\n{\n\tvec2 pos = p*0.05;\n\tfloat w = (Noise(pos*.25)*0.75+.15);\n\tw = 66.0 * w * w;\n\tvec2 dxy = vec2(0.0, 0.0);\n\tfloat f = .0;\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tf += w * Noise(pos);\n\t\tw = -w * 0.4;\t\/\/...Flip negative and positive for variation\n\t\tpos = rotate2D * pos;\n\t}\n\tfloat ff = Noise(pos*.002);\n\t\n\tf += pow(abs(ff), 5.0)*275.-5.0;\n\treturn f;\n}\n\n\/\/--------------------------------------------------------------------------\n\/\/ Map to lower resolution for height field mapping for Scene function...\nfloat Map(in vec3 p)\n{\n\tfloat h = Terrain(p.xz);\n\t\t\n\n\tfloat ff = Noise(p.xz*.3) + Noise(p.xz*3.3)*.5;\n\ttreeLine = smoothstep(ff, .0+ff*2.0, h) * smoothstep(1.0+ff*3.0, .4+ff, h) ;\n\ttreeCol = Trees(p.xz);\n\th += treeCol;\n\t\n    return p.y - h;\n}\n\n\/\/--------------------------------------------------------------------------\n\/\/ High def version only used for grabbing normal information.\nfloat Terrain2( in vec2 p)\n{\n\t\/\/ There's some real magic numbers in here! \n\t\/\/ The Noise calls add large mountain ranges for more variation over distances...\n\tvec2 pos = p*0.05;\n\tfloat w = (Noise(pos*.25)*0.75+.15);\n\tw = 66.0 * w * w;\n\tvec2 dxy = vec2(0.0, 0.0);\n\tfloat f = .0;\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tf += w * Noise(pos);\n\t\tw =  - w * 0.4;\t\/\/...Flip negative and positive for varition\t   \n\t\tpos = rotate2D * pos;\n\t}\n\tfloat ff = Noise(pos*.002);\n\tf += pow(abs(ff), 5.0)*275.-5.0;\n\t\n\n\ttreeCol = Trees(p);\n\tf += treeCol;\n\tif (treeCol > 0.0) return f;\n\n\t\n\t\/\/ That's the last of the low resolution, now go down further for the Normal data...\n\tfor (int i = 0; i < 6; i++)\n\t{\n\t\tf += w * Noise(pos);\n\t\tw =  - w * 0.4;\n\t\tpos = rotate2D * pos;\n\t}\n\t\n\t\n\treturn f;\n}\n\n\/\/--------------------------------------------------------------------------\nfloat FractalNoise(in vec2 xy)\n{\n\tfloat w = .7;\n\tfloat f = 0.0;\n\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tf += Noise(xy) * w;\n\t\tw *= 0.5;\n\t\txy *= 2.7;\n\t}\n\treturn f;\n}\n\n\/\/--------------------------------------------------------------------------\n\/\/ Simply Perlin clouds that fade to the horizon...\n\/\/ 200 units above the ground...\nvec3 GetClouds(in vec3 sky, in vec3 rd)\n{\n\tif (rd.y < 0.01) return sky;\n\tfloat v = (200.0-cameraPos.y)\/rd.y;\n\trd.xz *= v;\n\trd.xz += cameraPos.xz;\n\trd.xz *= .010;\n\tfloat f = (FractalNoise(rd.xz) -.55) * 5.0;\n\t\/\/ Uses the ray's y component for horizon fade of fixed colour clouds...\n\tsky = mix(sky, vec3(.55, .55, .52), clamp(f*rd.y-.1, 0.0, 1.0));\n\n\treturn sky;\n}\n\n\n\n\/\/--------------------------------------------------------------------------\n\/\/ Grab all sky information for a given ray from camera\nvec3 GetSky(in vec3 rd)\n{\n\tfloat sunAmount = max( dot( rd, sunLight), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),5.)*.5;\n\tvec3  sky = vec3(v*sunColour.x*0.4+0.18, v*sunColour.y*0.4+0.22, v*sunColour.z*0.4+.4);\n\t\/\/ Wide glare effect...\n\tsky = sky + sunColour * pow(sunAmount, 6.5)*.32;\n\t\/\/ Actual sun...\n\tsky = sky+ sunColour * min(pow(sunAmount, 1150.0), .3)*.65;\n\treturn sky;\n}\n\n\/\/--------------------------------------------------------------------------\n\/\/ Merge mountains into the sky background for correct disappearance...\nvec3 ApplyFog( in vec3  rgb, in float dis, in vec3 dir)\n{\n\tfloat fogAmount = exp(-dis* 0.00005);\n\treturn mix(GetSky(dir), rgb, fogAmount );\n}\n\n\/\/--------------------------------------------------------------------------\n\/\/ Calculate sun light...\nvoid DoLighting(inout vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float dis)\n{\n\tfloat h = dot(sunLight,normal);\n\tfloat c = max(h, 0.0)+ambient;\n\tmat = mat * sunColour * c ;\n\t\/\/ Specular...\n\tif (h > 0.0)\n\t{\n\t\tvec3 R = reflect(sunLight, normal);\n\t\tfloat specAmount = pow( max(dot(R, normalize(eyeDir)), 0.0), 3.0)*specular;\n\t\tmat = mix(mat, sunColour, specAmount);\n\t}\n}\n\n\/\/--------------------------------------------------------------------------\n\/\/ Hack the height, position, and normal data to create the coloured landscape\nvec3 TerrainColour(vec3 pos, vec3 normal, float dis)\n{\n\tvec3 mat;\n\tspecular = .0;\n\tambient = .1;\n\tvec3 dir = normalize(pos-cameraPos);\n\t\n\tvec3 matPos = pos * 2.0;\/\/ ... I had change scale halfway though, this lazy multiply allow me to keep the graphic scales I had\n\n\tfloat disSqrd = dis * dis;\/\/ Squaring it gives better distance scales.\n\n\tfloat f = clamp(Noise(matPos.xz*.05), 0.0,1.0);\/\/*10.8;\n\tf += Noise(matPos.xz*.1+normal.yz*1.08)*.85;\n\tf *= .55;\n\tvec3 m = mix(vec3(.63*f+.2, .7*f+.1, .7*f+.1), vec3(f*.43+.1, f*.3+.2, f*.35+.1), f*.65);\n\tmat = m*vec3(f*m.x+.36, f*m.y+.30, f*m.z+.28);\n\t\/\/ Should have used smoothstep to add colours, but left it using 'if' for sanity...\n\tif (normal.y < .5)\n\t{\n\t\tfloat v = normal.y;\n\t\tfloat c = (.5-normal.y) * 4.0;\n\t\tc = clamp(c*c, 0.1, 1.0);\n\t\tf = Noise(vec2(matPos.x*.09, matPos.z*.095+matPos.yy*0.15));\n\t\tf += Noise(vec2(matPos.x*2.233, matPos.z*2.23))*0.5;\n\t\tmat = mix(mat, vec3(.4*f), c);\n\t\tspecular+=.1;\n\t}\n\n\t\/\/ Grass. Use the normal to decide when to plonk grass down...\n\tif (matPos.y < 45.35 && normal.y > .65)\n\t{\n\n\t\tm = vec3(Noise(matPos.xz*.023)*.5+.15, Noise(matPos.xz*.03)*.6+.25, 0.0);\n\t\tm *= (normal.y- 0.65)*.6;\n\t\tmat = mix(mat, m, clamp((normal.y-.65)*1.3 * (45.35-matPos.y)*0.1, 0.0, 1.0));\n\t}\n\n\tif (treeCol > 0.0)\n\t{\n\t\tmat = vec3(.02+Noise(matPos.xz*5.0)*.03, .05, .0);\n\t\tnormal = normalize(normal+vec3(Noise(matPos.xz*33.0)*1.0-.5, .0, Noise(matPos.xz*33.0)*1.0-.5));\n\t\tspecular = .0;\n\t}\n\t\n\t\/\/ Snow topped mountains...\n\tif (matPos.y > 80.0 && normal.y > .42)\n\t{\n\t\tfloat snow = clamp((matPos.y - 80.0 - Noise(matPos.xz * .1)*28.0) * 0.035, 0.0, 1.0);\n\t\tmat = mix(mat, vec3(.7,.7,.8), snow);\n\t\tspecular += snow;\n\t\tambient+=snow *.3;\n\t}\n\t\/\/ Beach effect...\n\tif (matPos.y < 1.45)\n\t{\n\t\tif (normal.y > .4)\n\t\t{\n\t\t\tf = Noise(matPos.xz * .084)*1.5;\n\t\t\tf = clamp((1.45-f-matPos.y) * 1.34, 0.0, .67);\n\t\t\tfloat t = (normal.y-.4);\n\t\t\tt = (t*t);\n\t\t\tmat = mix(mat, vec3(.09+t, .07+t, .03+t), f);\n\t\t}\n\t\t\/\/ Cheap under water darkening...it's wet after all...\n\t\tif (matPos.y < 0.0)\n\t\t{\n\t\t\tmat *= .5;\n\t\t}\n\t}\n\n\tDoLighting(mat, pos, normal,dir, disSqrd);\n\t\n\t\/\/ Do the water...\n\tif (matPos.y < 0.0)\n\t{\n\t\t\/\/ Pull back along the ray direction to get water surface point at y = 0.0 ...\n\t\tfloat time = (iGlobalTime)*.03;\n\t\tvec3 watPos = matPos;\n\t\twatPos += -dir * (watPos.y\/dir.y);\n\t\t\/\/ Make some dodgy waves...\n\t\tfloat tx = cos(watPos.x*.052) *4.5;\n\t\tfloat tz = sin(watPos.z*.072) *4.5;\n\t\tvec2 co = Noise2(vec2(watPos.x*4.7+1.3+tz, watPos.z*4.69+time*35.0-tx));\n\t\tco += Noise2(vec2(watPos.z*8.6+time*13.0-tx, watPos.x*8.712+tz))*.4;\n\t\tvec3 nor = normalize(vec3(co.x, 20.0, co.y));\n\t\tnor = normalize(reflect(dir, nor));\/\/normalize((-2.0*(dot(dir, nor))*nor)+dir);\n\t\t\/\/ Mix it in at depth transparancy to give beach cues..\n\t\tmat = mix(mat, GetClouds(GetSky(nor)*vec3(.5,.6,1.0), nor)*.7, clamp((watPos.y-matPos.y)*.35, .2, .9));\n\t\t\/\/ Add some extra water glint...\n\t\tfloat sunAmount = max( dot(nor, sunLight), 0.0 );\n\t\tmat = mat + sunColour * pow(sunAmount, 228.5)*.6;\n\t}\n\tmat = ApplyFog(mat, disSqrd, dir);\n\treturn mat;\n}\n\n\/\/--------------------------------------------------------------------------\nfloat BinarySubdivision(in vec3 rO, in vec3 rD, vec2 t)\n{\n\t\/\/ Home in on the surface by dividing by two and split...\n    float halfwayT;\n\tfor (int n = 0; n < 4; n++)\n\t{\n\t\thalfwayT = (t.x + t.y) * .5;\n\t\tvec3 p = rO + halfwayT*rD;\n\t\tif (Map(p) < 0.5)\n\t\t{\n\t\t\tt.x = halfwayT;\n\t\t}else\n\t\t{\n\t\t\tt.y = halfwayT;\n\t\t}\n\t}\n\treturn t.x;\n}\n\n\/\/--------------------------------------------------------------------------\nbool Scene(in vec3 rO, in vec3 rD, out float resT, in vec2 fragCoord )\n{\n    float t = 1.2 + Hash12(fragCoord.xy);\n\tfloat oldT = 0.0;\n\tfloat delta = 0.0;\n\tbool fin = false;\n\tbool res = false;\n\tvec2 distances;\n\tfor( int j=0; j< 150; j++ )\n\t{\n\t\tif (fin || t > 240.0) break;\n\t\tvec3 p = rO + t*rD;\n\t\t\/\/if (t > 240.0 || p.y > 195.0) break;\n\t\tfloat h = Map(p); \/\/ ...Get this positions height mapping.\n\t\t\/\/ Are we inside, and close enough to fudge a hit?...\n\t\tif( h < 0.5)\n\t\t{\n\t\t\tfin = true;\n\t\t\tdistances = vec2(t, oldT);\n\t\t\tbreak;\n\t\t}\n\t\t\/\/ Delta ray advance - a fudge between the height returned\n\t\t\/\/ and the distance already travelled.\n\t\t\/\/ It's a really fiddly compromise between speed and accuracy\n\t\t\/\/ Too large a step and the tops of ridges get missed.\n\t\tdelta = max(0.01, 0.3*h) + (t*0.0065);\n\t\toldT = t;\n\t\tt += delta;\n\t}\n\tif (fin) resT = BinarySubdivision(rO, rD, distances);\n\n\treturn fin;\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 CameraPath( float t )\n{\n\tfloat m = 1.0+(iMouse.x\/iResolution.x)*300.0;\n\tt = (iGlobalTime*1.5+m+657.0)*.006 + t;\n    vec2 p = 476.0*vec2( sin(3.5*t), cos(1.5*t) );\n\treturn vec3(335.0-p.x, 0.6, 308.0+p.y);\n}\n\n\/\/--------------------------------------------------------------------------\n\/\/ Some would say, most of the magic is done in post! :D\nvec3 PostEffects(vec3 rgb, vec2 uv)\n{\n\t\/\/#define CONTRAST 1.1\n\t\/\/#define SATURATION 1.12\n\t\/\/#define BRIGHTNESS 1.3\n\t\/\/rgb = pow(abs(rgb), vec3(0.45));\n\t\/\/rgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\n\trgb = (1.0 - exp(-rgb * 6.0)) * 1.0024;\n\t\/\/rgb = clamp(rgb+hash12(fragCoord.xy*rgb.r)*0.1, 0.0, 1.0);\n\treturn rgb;\n}\n\n\/\/--------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = -1.0 + 2.0*fragCoord.xy \/ iResolution.xy;\n\tvec2 uv = xy * vec2(iResolution.x\/iResolution.y,1.0);\n\tvec3 camTar;\n\n\t#ifdef STEREO\n\tfloat isCyan = mod(fragCoord.x + mod(fragCoord.y,2.0),2.0);\n\t#endif\n\n\t\/\/ Use several forward heights, of decreasing influence with distance from the camera.\n\tfloat h = 0.0;\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 7; i++)\n\t{\n\t\th += Terrain(CameraPath((.6-f)*.008).xz) * f;\n\t\tf -= .1;\n\t}\n\tcameraPos.xz = CameraPath(0.0).xz;\n\tcamTar.xz\t = CameraPath(.005).xz;\n\tcamTar.y = cameraPos.y = max((h*.25)+3.5, 1.0);\n\t\n\tfloat roll = 0.15*sin(iGlobalTime*.2);\n\tvec3 cw = normalize(camTar-cameraPos);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n\tvec3 rd = normalize( uv.x*cu + uv.y*cv + 1.5*cw );\n\n\t#ifdef STEREO\n\tcameraPos += .45*cu*isCyan; \/\/ move camera to the right - the rd vector is still good\n\t#endif\n\n\tvec3 col;\n\tfloat distance;\n\tif( !Scene(cameraPos,rd, distance, fragCoord) )\n\t{\n\t\t\/\/ Missed scene, now just get the sky value...\n\t\tcol = GetSky(rd);\n\t\tcol = GetClouds(col, rd);\n\t}\n\telse\n\t{\n\t\t\/\/ Get world coordinate of landscape...\n\t\tvec3 pos = cameraPos + distance * rd;\n\t\t\/\/ Get normal from sampling the high definition height map\n\t\t\/\/ Use the distance to sample larger gaps to help stop aliasing...\n\t\tfloat p = min(.3, .0005+.00005 * distance*distance);\n\t\tvec3 nor  \t= vec3(0.0,\t\t    Terrain2(pos.xz), 0.0);\n\t\tvec3 v2\t\t= nor-vec3(p,\t\tTerrain2(pos.xz+vec2(p,0.0)), 0.0);\n\t\tvec3 v3\t\t= nor-vec3(0.0,\t\tTerrain2(pos.xz+vec2(0.0,-p)), -p);\n\t\tnor = cross(v2, v3);\n\t\tnor = normalize(nor);\n\n\t\t\/\/ Get the colour using all available data...\n\t\tcol = TerrainColour(pos, nor, distance);\n\t}\n\n\tcol = PostEffects(col, uv);\n\t\n\t#ifdef STEREO\t\n\tcol *= vec3( isCyan, 1.0-isCyan, 1.0-isCyan );\t\n\t#endif\n\t\n\tfragColor=vec4(col,1.0);\n}\n\n\/\/--------------------------------------------------------------------------","name":"","description":"","type":"image"}]}}