{"Shader":{"ver":"0.1","info":{"id":"ldj3Wh","date":"1387452122","viewed":2785,"name":"Quadratic Bezier - 3D","username":"iq","description":"Intersecting quadratic Bezier segments in 3D. Used Microsoft's paper as pointed out by tayholliday in https:\/\/www.shadertoy.com\/view\/XsX3zf. Since 3D quadratic Bezier segments are planar, the 2D version can be used to compute the distance to 3D curves.","likes":23,"published":3,"flags":0,"tags":["procedural","3d","raymarching","distancefield","bezier","quadratic"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\/\/ Intersecting quadratic Bezier segments in 3D. Used Microsoft's paper as pointed out \n\/\/ by tayholliday in https:\/\/www.shadertoy.com\/view\/XsX3zf. Since 3D quadratic Bezier \n\/\/ segments are planar, the 2D version can be used to compute the distance to 3D curves.\n\t\n\/\/-----------------------------------------------------------------------------------\n\t\n\/\/ undefine this for animation\n\/\/#define ANIMATE\n\n\/\/ undefine to compare to linear segments\n\/\/#define USELINEAR\n\n#define METHOD 0\n\n\/\/ method 0 : approximate http:\/\/research.microsoft.com\/en-us\/um\/people\/hoppe\/ravg.pdf\n\/\/ method 1 : exact       https:\/\/www.shadertoy.com\/view\/ltXSDB\n\n\/\/-----------------------------------------------------------------------------------\n\nvec3  hash3( float n ) { return fract(sin(vec3(n,n+7.3,n+13.7))*1313.54531); }\n\nvec3 noise3( in float x )\n{\n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix( hash3(p+0.0), hash3(p+1.0), f );\n}\n\n\/\/-----------------------------------------------------------------------------------\n#if METHOD==0\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec3 getClosest( vec2 b0, vec2 b1, vec2 b2 ) \n{\n\t\n  float a =     det(b0,b2);\n  float b = 2.0*det(b1,b0);\n  float d = 2.0*det(b2,b1);\n  float f = b*d - a*a;\n  vec2  d21 = b2-b1;\n  vec2  d10 = b1-b0;\n  vec2  d20 = b2-b0;\n  vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n  vec2  pp = -f*gf\/dot(gf,gf);\n  vec2  d0p = b0-pp;\n  float ap = det(d0p,d20);\n  float bp = 2.0*det(d10,d0p);\n  float t = clamp( (ap+bp)\/(2.0*a+b+d), 0.0 ,1.0 );\n  return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\n\nvec2 sdBezier( vec3 a, vec3 b, vec3 c, vec3 p )\n{\n\tvec3 w = normalize( cross( c-b, a-b ) );\n\tvec3 u = normalize( c-b );\n\tvec3 v = normalize( cross( w, u ) );\n\n\tvec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n\tvec2 b2 = vec2( 0.0 );\n\tvec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n\tvec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n\tvec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy );\n\n\treturn vec2( sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z), cp.z );\n}\n#endif\n\n#if METHOD==1\nvec2 sdBezier(vec3 A, vec3 B, vec3 C, vec3 pos)\n{    \n    vec3 a = B - A;\n    vec3 b = A - 2.0*B + C;\n    vec3 c = a * 2.0;\n    vec3 d = A - pos;\n\n    float kk = 1.0 \/ dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) \/ 3.0;\n    float kz = kk * dot(d,a);      \n\n    vec2 res;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) \/ 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0\/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        \/\/ 1 root\n        vec3 qos = d + (c + b*t)*t;\n        res = vec2( length(qos),t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q\/(p*z*2.0) ) \/ 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        \/\/ 3 roots\n        vec3 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos,qos);\n        \n        res = vec2(dis,t.x);\n\n        qos = d + (c + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        if( dis<res.x ) res = vec2(dis,t.y );\n\n        qos = d + (c + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        if( dis<res.x ) res = vec2(dis,t.z );\n\n        res.x = sqrt( res.x );\n    }\n    \n    return res;\n}\n\n#endif\n\nvec2 sdSegment( vec3 a, vec3 b, vec3 p )\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat t = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*t ), t );\n}\n\n\/\/-----------------------------------------------------------------------------------\n\n\nvec2 map( vec3 p )\n{\n    float dm = 100.0;\t\n\n    vec3 a = vec3(0.0,-1.0,0.0);\n    vec3 b = vec3(0.0, 0.0,0.0);\n    vec3 c = vec3(0.0, 0.5,-0.5);\n\tfloat th = 0.0;\n\tfloat hm = 0.0;\n\tfloat id = 0.0;\n    for( int i=0; i<8; i++ )\n\t{\t\n#ifndef USELINEAR\n\t    vec2 h = sdBezier( a, b, c, p );\n#else\n\t\tvec2 h = sdSegment( a, c, p );\n#endif\t\t\t\n\t\tfloat kh = (th + h.y)\/8.0;\n\t\t\n\t\tfloat ra = 0.3 - 0.28*kh + 0.3*exp(-15.0*kh);\n\t\t\n\t    float d = h.x - ra;\n\t\t\n\t\t\/\/dm = min( dm, d );\n\t\tif( d<dm ) { dm=d; hm=kh; }\n\t\t\n        vec3 na = c;\n\t\tvec3 nb = c + (c-b);\n#ifndef ANIMATE\n\t\tvec3 dir = normalize(-1.0+2.0*hash3( id+13.0 ));\n\t\tvec3 nc = nb + 1.0*dir*sign(-dot(c-b,dir));\n#else\t\t\n\t\tvec3 nc = nb + 0.8*normalize(-1.0+2.0*noise3(id+0.5*iGlobalTime));\n        nc.y = max( nc.y, -0.9 );\n#endif\t\t\n\n\t\tid += 3.71;\n\t\ta = na;\n\t\tb = nb;\n\t\tc = nc;\n\t\tth += 1.0;\n\t}\n\n\treturn vec2( 0.5*dm, hm );\n}\n\nfloat map2( in vec3 pos )\n{\n    return min( pos.y+1.0, map(pos).x );\n}\n\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    vec3 res = vec3( -1.0 );\n\n    float maxd = 10.0;\n    \n    \/\/ plane\n    float tp = (-1.0-ro.y)\/rd.y;\n    if( tp>0.0 )\n    {\n        vec3 pos = ro + rd*tp;\n        res = vec3( tp, 0.025*length(pos.xz)*1.0 + 0.01*atan(pos.z,pos.x), 0.0 );\n        maxd = tp;\n    }\n\n    \/\/ tentacle\n\tconst float precis = 0.001;\n    float t = 0.0;\n\tfloat l = 0.0;\n    for( int i=0; i<80; i++ )\n    {\n\t    vec2 h = map( ro+rd*t );\n        if( h.x<precis || t>maxd ) break;\n        t += h.x;\n\t\tl = h.y;\n    }\n    if( t<maxd ) res = vec3( t, l, 1.0 );\n\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.002,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    for( int i=0; i<32; i++ )\n    {\n        h = map(ro + rd*t).x;\n        res = min( res, k*h\/t );\n\t\tt += clamp( h, 0.02, 2.0 );\n        if( res<0.0001 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float ao = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        float h = 0.02 + 0.5*float(i)\/7.0;\n        float d = map2( pos + h*nor );\n        ao += -(d-h);\n    }\n    return clamp( 1.5 - ao*0.6, 0.0, 1.0 );\n}\n\n\nvec3 lig = normalize(vec3(-0.2,0.6,0.9));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x\/iResolution.y;\n    vec2 m = vec2(0.5);\n\tif( iMouse.z>0.0 ) m = iMouse.xy\/iResolution.xy;\n\n\n    \/\/-----------------------------------------------------\n    \/\/ animate\n    \/\/-----------------------------------------------------\n\t\n\tfloat ctime = iGlobalTime;\n\n\t\n    \/\/-----------------------------------------------------\n    \/\/ camera\n    \/\/-----------------------------------------------------\n\n\tfloat an = 2.0 + 0.3*ctime - 12.0*(m.x-0.5);\n\n\tvec3 ro = vec3(7.0*sin(an),0.0,7.0*cos(an));\n    vec3 ta = vec3(0.0,0.0,0.0);\n\n    \/\/ camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n\t\/\/ create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n    \/\/-----------------------------------------------------\n\t\/\/ render\n    \/\/-----------------------------------------------------\n\n\tvec3 col = clamp( vec3(0.95,0.95,1.0) - 0.75*rd.y, 0.0, 1.0 );\n\tfloat sun = pow( clamp( dot(rd,lig), 0.0, 1.0 ), 8.0 );\n\tcol += 0.7*vec3(1.0,0.9,0.8)*pow(sun,4.0);\n\tvec3 bcol = col;\n\t\n\t\/\/ raymarch\n    vec3 tmat = intersect(ro,rd);\n    if( tmat.z>-0.5 )\n    {\n        \/\/ geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormal(pos);\n        if( tmat.z<0.5 )\n            nor = vec3(0.0,1.0,0.0);\n\t\tvec3 ref = reflect( rd, nor );\n\n        \/\/ materials\n\t\tvec3 mate = vec3(0.5);\n\t\tmate *= smoothstep( -0.75, 0.75, cos( 200.0*tmat.y ) );\n\t\t\n\t\tfloat occ = calcAO( pos, nor );\n\t\t\n\t\t\/\/ lighting\n        float sky = clamp(nor.y,0.0,1.0);\n\t\tfloat bou = clamp(-nor.y,0.0,1.0);\n\t\tfloat dif = max(dot(nor,lig),0.0);\n        float bac = max(0.3 + 0.7*dot(nor,-lig),0.0);\n\t\tfloat sha = 0.0; if( dif>0.001 ) sha=softshadow( pos+0.01*nor, lig, 0.0005, 32.0 );\n        float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 5.0 );\n        float spe = max( 0.0, pow( clamp( dot(lig,reflect(rd,nor)), 0.0, 1.0), 8.0 ) );\n\t\t\n\t\t\/\/ lights\n\t\tvec3 brdf = vec3(0.0);\n\t\tbrdf += 2.0*dif*vec3(1.20,1.0,0.60)*sha;\n\t\tbrdf += 1.5*sky*vec3(0.10,0.15,0.35)*occ;\n\t\tbrdf += 1.0*bou*vec3(0.30,0.30,0.30)*occ;\n\t\tbrdf += 1.0*bac*vec3(0.30,0.25,0.20)*occ;\n        brdf += 1.0*fre*vec3(1.00,1.00,1.00)*occ*dif;\n\t\t\n\t\t\/\/ surface-light interacion\n\t\tcol = mate.xyz* brdf;\n\t\tcol += (1.0-mate.xyz)*1.0*spe*vec3(1.0,0.95,0.9)*sha*2.0*(0.2+0.8*fre)*occ;\n\n        \/\/ fog\n\t\tcol = mix( col, bcol, smoothstep(10.0,20.0,tmat.x) );\n    }\n\n\tcol += 0.4*vec3(1.0,0.8,0.7)*sun;\n\t\n    \/\/ gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\n\tfragColor = vec4( col, 1.0 );\n}\n","name":"","description":"","type":"image"}]}}