{"Shader":{"ver":"0.1","info":{"id":"4sS3zz","date":"1382430978","viewed":4862,"name":"Ellipse - Distance","username":"iq","description":"Analytical distance to a ellipse. Same as I wrote for  but standalone for linking to it from my ","likes":10,"published":3,"flags":0,"tags":["2d","distance","ellipse"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Analytical distance to an 2D ellipse, which is more complicated than it seems. It ends up being\n\/\/ a quartic equation, which can be resolved through a cubic, then a quadratic. Some steps through the\n\/\/ derivation can be found in this article: \n\/\/\n\/\/ http:\/\/iquilezles.org\/www\/articles\/ellipsedist\/ellipsedist.htm\n\/\/\n\n\n\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n\t\n    float m = ab.x*p.x\/l; \n\tfloat n = ab.y*p.y\/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)\/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q\/c3)\/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)\/(rx*ry) - m)\/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0\/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0\/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry\/sqrt(rm-rx);\n        co = (p + 2.0*g\/rm - m)\/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = -1.0 + 2.0 * fragCoord.xy\/iResolution.xy;\n\tuv.x *= iResolution.x\/iResolution.y;\n\t\n    vec2 m = iMouse.xy\/iResolution.xy;\n\tm.x *= iResolution.x\/iResolution.y;\n\t\n\tfloat d = sdEllipse( uv, vec2(0.3,0.3)*m + vec2(1.0,0.5)  );\n\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n\n\tfragColor = vec4( col, 1.0 );;\n}","name":"","description":"","type":"image"}]}}