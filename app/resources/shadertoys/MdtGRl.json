{"Shader":{"ver":"0.1","info":{"id":"MdtGRl","date":"1451817831","viewed":329,"name":"Protoplanetary disk","username":"Duke","description":"Based on <a href=\"https:\/\/www.shadertoy.com\/view\/4lSXD1\"  class=\"regular\" target=\"_blank\">\"Dusty nebula 1\"<\/a> and Shane's <a href=\"https:\/\/www.shadertoy.com\/view\/Xsc3R4\"  class=\"regular\" target=\"_blank\">\"Cheap Cloud Flythrough\"<\/a> shaders.<br\/>Press 1-2-3 to zoom in and zoom out.","likes":26,"published":3,"flags":16,"tags":["cloud","star","space","nebula","disk","dust","protoplanetary"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ \"Protoplanetary disk\" by Duke\n\/\/-------------------------------------------------------------------------------------\n\/\/ Based on \"Dusty nebula 1\" (https:\/\/www.shadertoy.com\/view\/4lSXD1) \n\/\/ and Shane's \"Cheap Cloud Flythrough\" (https:\/\/www.shadertoy.com\/view\/Xsc3R4) shaders\n\/\/ Some ideas came from other shaders from this wonderful site\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\/\/-------------------------------------------------------------------------------------\n\n\/\/#define MOUSE_CAMERA_CONTROL\n\n\/\/ comment this string to see fluffy clouds\n#define DENSE_DUST\n\n#define DITHERING\n#define BACKGROUND\n\n\/\/-------------------\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\nmat2 Spin(float angle)\n{\n\treturn mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n}\n\n\/\/ iq's noise\nfloat pn( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D( iChannel0, (uv+ 0.5)\/256.0, -100.0 ).yx;\n\treturn -1.0+2.4*mix( rg.x, rg.y, f.z );\n}\n\nfloat fpn(vec3 p)\n{\n   return pn(p*.06125)*.5 + pn(p*.125)*.25 + pn(p*.25)*.125;\/\/ + pn(p*.5)*.625;\n}\n\nfloat rand(vec2 co)\n{\n\treturn fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat Ring(vec3 p)\n{\n  vec2 q = vec2(length(p.xy)-2.3,p.z);\n  return length(q)-0.01;\n}\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0\/8.0 );\n}\n\n\nfloat Disk( vec3 p, vec3 t )\n{\n    vec2 q = vec2(length2(p.xy)-t.x,p.z*0.5);\n    return max(length8(q)-t.y, abs(p.z) - t.z);\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat map(vec3 p)\n{\n    float t=0.7*iGlobalTime;\n\tfloat d1 = Disk(p,vec3(2.0,1.,0.05)) + fpn(vec3(Spin(t*0.25+p.z*.10)*p.xy*20.,p.z*20.-t)*5.0) * 0.545;\n    float d2 = Ring(p);\n    return smin(d1,d2,1.0);\n\n}\n\n\/\/ assign color to the media\nvec3 computeColor( float density, float radius )\n{\n\t\/\/ color based on density alone, gives impression of occlusion within\n\t\/\/ the media\n\tvec3 result = mix( 1.1*vec3(1.0,0.9,0.8), vec3(0.4,0.15,0.1), density );\n\t\n\t\/\/ color added for disk\n\tvec3 colCenter = 6.*vec3(0.8,1.0,1.0);\n\tvec3 colEdge = 2.*vec3(0.48,0.53,0.5);\n\tresult *= mix( colCenter, colEdge, min( (radius+.5)\/2.0, 1.15 ) );\n\t\n\treturn result;\n}\n\nbool Raycylinderintersect(vec3 org, vec3 dir, out float near, out float far)\n{\n\t\/\/ quadratic x^2 + y^2 = 0.5^2 => (org.x + t*dir.x)^2 + (org.y + t*dir.y)^2 = 0.5\n\tfloat a = dot(dir.xy, dir.xy);\n\tfloat b = dot(org.xy, dir.xy);\n\tfloat c = dot(org.xy, org.xy) - 12.;\n\n\tfloat delta = b * b - a * c;\n\tif( delta < 0.0 )\n\t\treturn false;\n\n\t\/\/ 2 roots\n\tfloat deltasqrt = sqrt(delta);\n\tfloat arcp = 1.0 \/ a;\n\tnear = (-b - deltasqrt) * arcp;\n\tfar = (-b + deltasqrt) * arcp;\n\t\n\t\/\/ order roots\n\tfloat temp = min(far, near);\n\tfar = max(far, near);\n\tnear = temp;\n\n\tfloat znear = org.z + near * dir.z;\n\tfloat zfar = org.z + far * dir.z;\n\n\t\/\/ top, bottom\n\tvec2 zcap = vec2(1.85, -1.85);\n\tvec2 cap = (zcap - org.z) \/ dir.z;\n\n\tif ( znear < zcap.y )\n\t\tnear = cap.y;\n\telse if ( znear > zcap.x )\n\t\tnear = cap.x;\n\n\tif ( zfar < zcap.y )\n\t\tfar = cap.y;\n\telse if ( zfar > zcap.x )\n\t\tfar = cap.x;\n\t\n\treturn far > 0.0 && far > near;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    const float KEY_1 = 49.5\/256.0;\n\tconst float KEY_2 = 50.5\/256.0;\n\tconst float KEY_3 = 51.5\/256.0;\n    float key = 0.0;\n    key += 0.7*texture2D(iChannel1, vec2(KEY_1,0.25)).x;\n    key += 0.7*texture2D(iChannel1, vec2(KEY_2,0.25)).x;\n    key += 0.7*texture2D(iChannel1, vec2(KEY_3,0.25)).x;\n\n\t\/\/ ro: ray origin\n\t\/\/ rd: direction of the ray\n\tvec3 rd = normalize(vec3((gl_FragCoord.xy-0.5*iResolution.xy)\/iResolution.y, 1.));\n\tvec3 ro = vec3(0., 0., -6.+key*1.6);\n\n    #ifdef MOUSE_CAMERA_CONTROL\n    R(rd.yz, -iMouse.y*0.01*pi*2.);\n    R(rd.xz, iMouse.x*0.01*pi*2.);\n    R(ro.yz, -iMouse.y*0.01*pi*2.);\n    R(ro.xz, iMouse.x*0.01*pi*2.);\n    #else\n    R(rd.yz, -pi*3.65);\n    R(rd.xz, pi*3.2);\n    R(ro.yz, -pi*3.65);\n   \tR(ro.xz, pi*3.2);    \n    #endif \n    \n    #ifdef DITHERING\n\tvec2 dpos = ( fragCoord.xy \/ iResolution.xy );\n\tvec2 seed = dpos + fract(iGlobalTime);\n   \t\/\/ randomizing the length \n    \/\/rd *= (1. + fract(sin(dot(vec3(7, 157, 113), rd.zyx))*43758.5453)*0.1-0.03); \n\t#endif \n    \n\t\/\/ ld, td: local, total density \n\t\/\/ w: weighting factor\n\tfloat ld=0., td=0., w=0.;\n\n\t\/\/ t: length of the ray\n\t\/\/ d: distance function\n\tfloat d=1., t=0.;\n   \n\tvec4 sum = vec4(0.0);\n   \n    float min_dist=0.0, max_dist=0.0;\n\n    if(Raycylinderintersect(ro, rd, min_dist, max_dist))\n    {\n       \n\tt = min_dist*step(t,min_dist);\n   \n\t\/\/ raymarch loop\n\tfor (int i=0; i<56; i++) \n\t{\n\t \n\t\tvec3 pos = ro + t*rd;\n\n\t\tfloat fld = 0.0;\n       \n\t\t\/\/ Loop break conditions.\n        if(td>(1.-1.\/80.) || d<0.008*t || t>10. || sum.a > 0.99 || t>max_dist) break;\n\t  \n\t\t\/\/ evaluate distance function\n\t\td = map(pos); \n       \n\t\t\/\/ direction to center\n\t\tvec3 stardir = normalize(vec3(0.0)-pos);\n      \n\t\t\/\/ change this string to control density \n\t\td = max(d,0.08);\n      \n\t\tif (d<0.1) \n\t\t{\n\t\t\t\/\/ compute local density \n\t\t\tld = 0.1 - d;\n\t\t\t\n            #ifdef DENSE_DUST          \n\t\t\tfld = clamp((ld - map(pos+0.2*stardir))\/0.4, 0.0, 1.0 );\n\t\t\tld += fld;\n            #endif\n \t\t\t\n            \/\/ compute weighting factor \n\t\t\tw = (1. - td) * ld;\n     \n\t\t\t\/\/ accumulate density\n\t\t\ttd += w + 1.\/200.;\n\t\t\n\t\t\tfloat radiusFromCenter = length(pos - vec3(0.0));\n\t\t\tvec4 col = vec4( computeColor(td,radiusFromCenter), td );\n\t\t\n\t\t\t\/\/ uniform scale density\n\t\t\tcol.a *= 0.2;\n\t\t\t\/\/ colour by alpha\n\t\t\tcol.rgb *= col.a\/0.8;\n\t\t\t\/\/ alpha blend in contribution\n\t\t\tsum = sum + col*(1.0 - sum.a);  \n\t\t}\n      \n\t\ttd += 1.\/70.;\n       \n        \/\/ point light calculations\n        vec3 ldst = vec3(0.0)-pos;\n        float lDist = max(length(ldst), 0.001);\n\n        \/\/ star in center\n        vec3 lightColor=vec3(1.0,0.5,0.25);\n        sum.rgb+=lightColor\/(lDist*lDist*lDist*7.);\/\/*10.); \/\/add a bloom around the light\n\n        \/\/ using the light distance to perform some falloff\n        \/\/float atten = 1.\/(1. + lDist*0.125 + lDist*lDist*0.4);\n        \/\/ accumulating the color\n        \/\/sum += w*atten*fld;\n       \n        \/\/ enforce minimum stepsize\n        d = max(d, 0.04); \n      \n        #ifdef DITHERING\n        \/\/ add in noise to reduce banding and create fuzz\n        d=abs(d)*(1.+0.28*rand(seed*vec2(i)));\n        #endif \n\t  \n        t +=  max(d * 0.3, 0.02);\n      \n\t}\n    \n    \/\/scattering test\n\t\/\/sum *= 1. \/ exp( ld * 0.2 ) * 1.05;\n        \n   \tsum = clamp( sum, 0.0, 1.0 );\n   \n    sum.xyz = sum.xyz*sum.xyz*(3.0-2.0*sum.xyz);\n    \n\t}\n\n    #ifdef BACKGROUND\n    \/\/ stars background\n    if (td<.8)\n    {\n        vec3 stars = vec3(pn(rd*300.0)*0.4+0.5);\n        vec3 starbg = vec3(0.0);\n        starbg = mix(starbg, vec3(0.8,0.9,1.0), smoothstep(0.99, 1.0, stars)*clamp(dot(vec3(0.0),rd)+0.75,0.0,1.0));\n        starbg = clamp(starbg, 0.0, 1.0);\n        sum.xyz += starbg; \n    }\n\t#endif\n    \n   fragColor = vec4(sum.xyz,1.0);\n}","name":"","description":"","type":"image"}]}}