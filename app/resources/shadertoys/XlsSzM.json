{"Shader":{"ver":"0.1","info":{"id":"XlsSzM","date":"1436060398","viewed":970,"name":"Portal Gameplay","username":"ciberxtrem","description":"Inspired in Portal, Chamber 8.<br\/><br\/>Note: Set the APPLY_COLORS and APPLY_SHADOW to 1 to see all colors and shadows <img src=\"\/img\/emoticonHappy.png\"\/>","likes":8,"published":3,"flags":0,"tags":["procedural","3d","raymarching","portal","cinematic"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Thanks iq and the Shadertoy comunity for all the shared knowledge! :)\n\n\/\/ Set this to 1 to enable colors!\n#define APPLY_COLORS 0\n#define APPLY_SHADOW 0\n\/\/---------------------------\n\n#define PI 3.14159265359\n\nstruct LightStruct {\n  vec3 pos;\n  vec3 color;\n};\n\nstruct PortalStruct {\n  vec3 pos;\n  vec3 front;\n  float rotateY;\n  float time;\n};\n\nstruct StateStruct\n{\n  vec3 posStart;\n  vec3 posEnd;\n  float lerptime;\n  float duration;\n  float isEnterTime;\n  float enterPortal;\n  float exitPortal;\n};\n    \nstruct OrientationStruct\n{\n  vec3 orientation;\n  float lerptime;\n  float duration;\n};\n    \nPortalStruct portalA;\nPortalStruct portalB;\n\nPortalStruct portalsA[8];\nStateStruct states[10];\nOrientationStruct orientations[15];\nLightStruct lights[3];\n\nfloat t;\nvec3 position;\nvec3 orientation;\nfloat ambient = 0.05;\nvec3 ambientcolor;\n\nvec3 rotateY(vec3 p, float a){\n    return vec3(\n        p.x*cos(a) + p.z*sin(a),\n        p.y,\n        p.z*cos(a) - p.x*sin(a)\n    );\n}\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*157.0;\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nfloat fbm( vec2 p ) {\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m2*p*2.02;\n    f += 0.2500*noise( p ); p = m2*p*2.03;\n    f += 0.1250*noise( p ); p = m2*p*2.01;\n    f += 0.0625*noise( p );\n    \n    return f\/0.9375;\n}\n\nfloat dBox(vec3 p, vec3 hsize)\n{\n    return length(max(abs(p)-hsize,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\/\/-------------------------------\n\n\/\/ Scene\nfloat dElipse(vec3 p, vec3 hsize, float globalSize)\n{\n    float d = length(max(abs(p)-hsize,0.0));\n    vec3 q = p;\n    q.y *= 0.6;\n    return max(d, length(q)-max(max(hsize.x, hsize.y)*globalSize, hsize.z));\n}\n\nvec2 dStructure(vec3 p)\n{  \n    \/\/ Front\n    vec2 res = vec2(-1., -1.);\n    vec3 q = p - vec3(0., 0.5, 28.25);\n    vec2 c = vec2(3., 6.2);\n    vec3 q2 = q; q2.xy = mod(q2.xy,c.xy)-0.5*c.xy;\n    float d = udRoundBox(q2, vec3(1.35, 3., 1.0), 0.25);\n    q = p - vec3(0.0, 9.5, 28.); \/\/ Hole for exit\n    float d2 = udRoundBox(q, vec3(3.0, 3.25, 2.0), 0.1);\n    d = max(d,-d2);\n    res = vec2(d, 24.);\n    \/\/Back\n    q = p - vec3(0., 3.5, -28.0);\n    c = vec2(3., 6.2);\n    q.x = mod(q.x,c.x)-0.5*c.x;\n    d = udRoundBox(q, vec3(1.35, 3., 1.0), 0.25);\n    res = mix(vec2(d, 24.), res, step(res.x, d));\n    q = p - vec3(0., 0.6, -28.01); \/\/ Brown block\n    c = vec2(3., 3.0);\n    q.xy = mod(q.xy,c.xy)-0.5*c.xy;\n    d = udRoundBox(q, vec3(1.35, 1.35, 1.0), 0.25);\n    q = p - vec3(0.0, 9.5, -28.); \/\/ Hole for exit\n    d2 = udRoundBox(q, vec3(3.0, 3.25, 2.0), 0.1);\n    d = max(d,-d2);\n    res = mix(vec2(d, 20.), res, step(res.x, d));\n    \/\/Exit\n    vec3 p2 = p; p2.z = abs(p.z);\n    q = p2 - vec3(0.0, 9.5, 30.5);\n    d = udRoundBox(q, vec3(3.0, 3.25, 0.1), 0.1);\n    if(d<res.x){res = vec2(d, 10.);} \/\/ magic panel\n    q2 = q - vec3(4.5, 0., -1.); q2.x += abs(sin(length(1.5+abs(q2.y)*0.36)));\n    d = udRoundBox(q2, vec3(1.5, 4.5, 2.0), 0.1);\n    q2 = q - vec3(-4.5, 0., -1.); q2.x -= abs(sin(length(1.5+abs(q2.y)*0.36)));\n    d2 = udRoundBox(q2, vec3(1.5, 4.5, 2.0), 0.1);\n    d = min(d, d2);\n    res = mix(vec2(d, 11.), res, step(res.x, d));\n    \/\/Left\n    q = p - vec3(-16., 0.5, 0.0);\n    c = vec2(3.0, 6.2);\n    q2 = q; q2.zy = mod(q2.zy,c)-0.5*c;\n    d = udRoundBox(q2, vec3(1., 3., 1.35), 0.25);\n    res = mix(vec2(d, 24.), res, step(res.x, d));\n    \/\/Right\n    q = p - vec3(16.0, 0.5, 0.0);\n    c = vec2(3.0, 6.2);\n    q.zy = mod(q.zy,c)-0.5*c;\n    d = udRoundBox(q, vec3(1., 3., 1.35), 0.25);\n    \/\/ Hole for window\n    q = p - vec3(15.0, 15.5, -9.0);\n    d2 = udRoundBox(q, vec3(2.0, 3., 6.0), 0.02);\n    d = max(d, -d2);\n    res = mix(vec2(d, 24.), res, step(res.x, d));\n    \/\/ Column\n    q = p - vec3(0., 0.6, -23.90);\n    c = vec2(3., 3.0);\n    q.xy = mod(q.xy,c)-0.5*c;\n    d = udRoundBox(q, vec3(1.35, 1.35, 2.70), 0.25);\n    d = max(d, -(p.x-6.1));\n    res = mix(vec2(d, 24.), res, step(res.x, d));\n    \/\/ Ceiling\n    q = p - vec3(0., 20.4, .0);\n    c = vec2(3.0, 3.0);\n    q2 = q; q2.xz = mod(q2.xz,c)-0.5*c;\n    d = udRoundBox(q2, vec3(1.35, 1., 1.35), 0.25);\n    d2 = length(q)-6.;\n    d = max(d, -d2);\n    res = mix(vec2(d, 23.), res, step(res.x, d));\n    \/\/Window\n    q = p - vec3(16.0, 15.5, -9.0);\n    d = udRoundBox(q, vec3(1.25, 3., 6.0), 0.02); \/\/ framework\n    d2 = udRoundBox(q, vec3(1.5, 2.6, 5.6), 0.02);\n    d = max(d, -d2);\n    d = min(d, udRoundBox(q, vec3(1.2, 3., 0.2), 0.02)); \/\/ bars\n    res = mix(vec2(d, 7.), res, step(res.x, d));\n    d = udRoundBox(q, vec3(1.0, 2.6, 5.6), 0.1);\n    d -= smoothstep(-1., 1., cos(p.y*15.)) * 0.0025;\n    res = mix(vec2(d, 5.), res, step(res.x, d));\n    \/\/ Dome\n    q = p-vec3(0., 21.5, 0.);\n    q.y *= 1.0;\n    d = length(q) - 6.;\n    res = mix(vec2(d, 9.), res, step(res.x, d));\n    \/\/Turbina\n    q = p - vec3(0.0, 15.0, 0.0);\n    q = rotateY(q, t);\n    d = dBox(q, vec3(5.5, 0.05, 0.4));\n    d2 = dBox(q, vec3(0.4, 0.05, 5.5));\n    d = min(d, d2);\n    d2 = sdCappedCylinder(q-vec3(0., 0.5, 0.), vec2(0.4, 0.5));\n    d = min(d, d2);\n    res = mix(vec2(d, 4.), res, step(res.x, d));\n    \/\/ Front railing\n    q = p - vec3(-5.5, 6.5, 23.2);\n    d = dBox(q, vec3(9.0, 0.1, 4.0));\n    res = mix(vec2(d, 8.), res, step(res.x, d));\n    d = udRoundBox(q-vec3(0., 1.6, -4.0), vec3(9.0, 1.7, 0.05), 0.02);\n    d2 = udRoundBox(q-vec3(0., 1.6, -4.0), vec3(8.8, 1.5, 0.5), 0.02);\n    d = max(d, -d2);\n    d = min(d, udRoundBox(q-vec3(8.9, 3.2, 0.0), vec3(0.10, 0.10, 4.0), 0.01));\n    res = mix(vec2(d, 7.), res, step(res.x, d));\n    \n    \/\/ Back railing\n    q = p - vec3(-0.5, 6.5, -24.2);\n    d = dBox(q, vec3(6.0, 0.1, 3.0));\n    res = mix(vec2(d, 8.), res, step(res.x, d));\n    d = udRoundBox(q-vec3(0.5, 1.6, 3.2), vec3(6.0, 1.7, 0.1), 0.02);\n    d2 = udRoundBox(q-vec3(0.5, 1.6, 3.2), vec3(5.8, 1.5, 1.0), 0.02);\n    d = max(d, -d2);\n    res = mix(vec2(d, 7.), res, step(res.x, d));\n\n    return res;\n}\n\nvec2 dWater(vec3 p)\n{\n    vec3 q = p - vec3(0., -0., .0);\n    float d = dBox(q, vec3(20., 0.2, 40.));\n    d-=smoothstep(-1., 1., cos(p.x*2.1+t*2.)*cos(p.z*3.5+t*1.6))*0.01;\n    float d2 = smoothstep(-1., 1., cos(length(p.xz)*2.-t))*0.05;\n    d2 = mix(0., d2, smoothstep(1.0, 10., length(q.xz)));\n    d -= d2;\n    \n    return vec2(d, 3.);\n}\n\nvec2 dPlatforms(vec3 p)\n{\n    \/\/ Front Right Platform\n    vec2 res = vec2(-1, -1.);\n    vec3 q = p - vec3(11.5, 7., 7.0);\n    vec2 c = vec2(3.0);\n    vec3 q2 = q; q2.xz = mod(q2.xz+vec2(0., 1.0),c)-0.5*c;\n    float d = udRoundBox(q2, vec3(1.415, 0.2, 1.415), 0.1);\n    d = max(d, q.z-5.); d = max(d, -(q.z+4.)); d = max(d, -(q.x+6.));\n    res = vec2(d, 21.);\n    \/\/Tube\n    d = sdCappedCylinder(q-vec3(0., -4., 0.), vec2(0.65, 3.));\n    d = min(d, sdCappedCylinder(q-vec3(0., -7.5, 0.), vec2(1.0, 2.)));\n    res = mix(vec2(d, 6.), res, step(res.x, d));\n    \/\/ Front Left Platform\n    vec3 leftPlatPos = vec3(-10.0, 7., -2.0);\n    if(t > 29.0){\n        float phase = (t-29.)\/7.;\n    \tfloat seq = mod(phase, 2.);\n    \tleftPlatPos =mix(vec3(-10, 7., -2.), vec3(-11.6, 7., -23.0), fract(phase));\n    }\n    q = p - leftPlatPos;\n    d = udRoundBox(q, vec3(3.8, 0.02, 3.8), 0.01);\n    res = mix(vec2(d, 22.), res, step(res.x, d));\n    \/\/ Border\n    d = udRoundBox(q, vec3(4.0, 0.05, 4.0), 0.1);\n    float d2 = udRoundBox(q, vec3(3.5, 0.1, 3.5), 0.1);\n    d = max(d, -d2);\n    res = mix(vec2(d, 24.), res, step(res.x, d));\n    \/\/ Crosses\n    d = udRoundBox(q-vec3(0., -0.05, 0.), vec3(4.0, 0.08, 0.1), 0.05);\n    d = min(d, udRoundBox(q-vec3(0., -0.05, 0.), vec3(0.1, 0.08, 4.0), 0.05));\n    res = mix(vec2(d, 24.), res, step(res.x, d));\n    \/\/Tube\n    d = sdCappedCylinder(q-vec3(0., -1.5, 0.), vec2(0.65, 1.6));\n    d = min(d, sdCappedCylinder(q-vec3(0., -5.0, 0.), vec2(1.0, 2.)));\n    res = mix(vec2(d, 6.), res, step(res.x, d));\n    \n    return res;\n}\n\nvec4 dBloomObjects(vec3 p)\n{\n    vec4 res = vec4(-1, -1, 999., 0.);\n    \/\/Lamp\n    vec3 q = p - vec3(0.0, 14.6, 0.0);\n    q.y *= 1.4;\n    float d = length(q)-0.8;\n    res.zw = vec2(d, 1.);\n    res.xy = vec2(d, 7.);\n    \/\/ FireballBaseStart\n    q = p - vec3(10.5, 9.5, 27.5);\n    d = length(vec3(q.x, q.y, q.z))-2.5;\n    d = max(d, -(q.z+1.5));\n    float d2 = (length((vec3(q.x, q.y, (q.z+1.5)*0.8)))-1.5); d2 += cos((p.z+0.5)*4.5)*0.1;\n    d = min(d, d2);\n    d += mix(0., 1., smoothstep(0.6, 1., cos(q.x*2.)*cos(q.y*2.)*cos(q.z+1.)))*1.0;\n    res.xy = mix(vec2(d, 12.), res.xy, step(res.x, d));\n    \/\/ FireballBaseEnd\n    q = p - vec3(-15.9, 9.5, -12.0);\n    q = rotateY(q, PI*0.5);\n    d = length(vec3(q.x, q.y, q.z))-2.5;\n    d = max(d, -(q.z+1.5));\n    d = max(d, -(length(q-vec3(0., 0., -5.6))-4.5));\n    d += mix(0., 1., smoothstep(0.5, 1., cos(q.x*2.)*cos(q.y*2.)*cos(q.z+1.)))*1.0;\n    res.xy = mix(vec2(d, 12.), res.xy, step(res.x, d));\n    \/\/ Redpoint\n    q = p - vec3(-15.4, 9.5, -12.0);\n    d = length(q)-0.9;\n    res.xy = mix(vec2(d, 22.), res.xy, step(res.x, d));\n    res.zw = mix(vec2(d, 0.),res.zw, step(res.z, d));\n    \/\/ RedPoint\n   \tq = p - vec3(14.8, 9.5, -12.0);\n    d = length(q)-0.01;\n    res.xy = mix(vec2(d, 22.), res.xy, step(res.x, d));\n    res.zw = mix(vec2(d, 0.),res.zw, step(res.z, d));\n    \/\/ Fireball\n    vec3 firePos = vec3(0.);\n    if(t < 20.) {\n        float phase = t\/4.;\n        float phasePart = fract(phase);\n        float phaseSeq = mod(phase, 2.);\n        firePos = mix( mix(vec3(10., 9.5, 20.5), vec3(10., 9.5, -19.0), phasePart), mix(vec3(10., 9.5, -19.0), vec3(10., 9.5, 20.5), phasePart), step(1.0, phaseSeq));\n    } else if(t < 22.3) {\n        firePos = mix(vec3(14.5, 10., 7.5), vec3(-14.5, 10., 7.5), smoothstep(20., 22.3, t));\n    } else if(t < 24.3) {\n        firePos = mix(vec3(-14.5, 10., 7.5), vec3(14.5, 10., 7.5), smoothstep(22.3, 24.3, t));\n    } else {\n        firePos = mix(vec3(14.5, 9.5, -12.0), vec3(-15.0, 9.5, -12.0), smoothstep(24.3, 27.5, t));\n    }\n        \n    q = p - firePos;\n    d = length(vec3(q.x, q.y, q.z))-0.15;\n    d += cos(q.x*15.+t*2.)*cos(q.y*12.)*cos(q.z*10.)*0.05;\n    res.xy = mix(vec2(d, 13.), res.xy, step(res.x, d));\n    res.zw = mix(vec2(d, 0.),res.zw, step(res.z, d));\n\n    return res;\n}\n\nvec2 dPortalA(vec3 p)\n{\n    vec3 q = rotateY(p - portalA.pos, portalA.rotateY);\n    float d = dElipse(q, vec3(1.6, 2.6, 0.05), smoothstep(0., 0.15, t-portalA.time)*0.6);\n    return vec2(d, 1.);\n}\n\nvec2 dPortalB(vec3 p)\n{\n    vec3 q = rotateY(p - portalB.pos, portalB.rotateY);\n    float d = dElipse(q, vec3(1.6, 2.6, 0.05), smoothstep(0., 0.15, t-portalB.time)*0.6);\n    return vec2(d, 2.);\n}\n\nvec4 map(vec3 p)\n{\n    vec4 res = dBloomObjects(p);\n    vec2 res2 = dStructure(p);\n    if(res2.x < res.x) res.xy = res2.xy;\n    \n    res2 = dWater(p);\n    if(res2.x < res.x) res.xy = res2.xy;\n    \n    res2 = dPortalA(p);\n    if(res2.x < res.x) res.xy = res2.xy;\n    \n    res2 = dPortalB(p);\n    if(res2.x < res.x) res.xy = res2.xy;\n    \n    res2 = dPlatforms(p);\n    if(res2.x < res.x) res.xy = res2.xy;\n    \n    return res;\n}\n\nvec4 intersect(vec3 o, vec3 rd, float tmin, float tmax)\n{\n    float k = tmin;\n    vec4 res = vec4(tmax, -1, 999., 0.);\n    for(int i=0; i<120; ++i)\n    {\n        vec4 r = map(o + rd*k); \n        res.zw = mix(r.zw, res.zw, step(res.z, r.z));\n        if(r.x < 0.01)\n        {\n            res.x = k;\n            res.y = r.y;\n            break;\n        }\n        \n        k+=r.x;\n        if(k > tmax)\n        {\n            break;\n        }\n    }\n    \n    return res;\n}\n\nvec3 calcnormal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.);\n    return normalize(\n        vec3(map(p+e.xyy).x-map(p-e.xyy).x,\n        \t map(p+e.yxy).x-map(p-e.yxy).x,\n        \t map(p+e.yyx).x-map(p-e.yyx).x)\n    );\n}\n\n#if APPLY_SHADOW == 1\nfloat calcshadow(vec3 o, vec3 rd, float tmin, float tmax)\n{\n    float k = tmin;\n    float shadow = 1.;\n    for(int i = 0; i < 20; ++i)\n    {\n        vec4 res = map(o + rd*k);\n        shadow = min(shadow, res.x*1.5);\n        \n        k+=res.x;\n        \n        if(k > tmax)\n        {\n            break;\n        }\n    }\n    \n    return shadow;\n}\n\n#endif\n\nvec4 mapPortalColor(vec3 p, vec3 portalPos, float rotY, vec4 cristalcolor, vec4 fxcolor)\n{\n    vec2 q = rotateY(p-portalPos, rotY).xy; q.y *= 0.55;\n    float d = length(q) - 1.4 + sin(q.x*10.+t*2.)*cos(q.y*10.+t*2.) * 0.05;\n    return mix(cristalcolor, fxcolor, smoothstep(-0.5, 0.2, d));\n}\n\nvoid calculatePosRayDirFromPortals(in PortalStruct portalO, in PortalStruct portalD, in vec3 p, in vec3 rd, out vec3 refpos, out vec3 refdir)\n{\n    vec3 oRight = cross(vec3(0., 1., 0.), portalO.front);\n    vec3 oUp = cross(portalO.front, oRight);\n    \n    vec3 dRight = cross(vec3(0., 1., 0.), portalD.front);\n    vec3 dUp = cross(portalD.front, dRight);\n    \n    vec3 projRD=vec3(dot(oRight, rd), dot(oUp, rd), dot(portalO.front, rd));\n    vec3 localPos = p-portalO.pos;\n    vec3 projPos = vec3(dot(localPos, oRight), dot(localPos, oUp), dot(localPos, portalO.front));\n\n    refdir = normalize(-portalD.front*projRD.z + -dRight*projRD.x + dUp*projRD.y);\n    refpos = portalD.pos + -dRight*projPos.x + dUp*projPos.y + -portalD.front*projPos.z;\n}\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec4 x = texture2D( sam, p.yz );\n\tvec4 y = texture2D( sam, p.zx );\n\tvec4 z = texture2D( sam, p.xy );\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\nvec2 point2plane( in vec3 p, in vec3 n )\n{\n\treturn p.zy*abs(n.x) + p.xz*abs(n.y) + p.xy*abs(n.z);\n}\n\nvec4 mapcolor(inout vec3 p, in vec4 res, inout vec3 normal, in vec3 rd, out vec3 refpos, out vec3 refdir, out vec4 lparams)\n{\n    vec4 color = vec4(0.498, 0.584, 0.619, 1.0); lparams = vec4(1.0, 10., 0., 0.);\n    refdir = reflect(rd, normal); refpos = p;\n\n    if(res.y < 1.1) { \/\/ PortalA\n        color = mapPortalColor(p, portalA.pos, portalA.rotateY, vec4(1., 1., 1., 0.1), vec4(0.0, 0.35, 1.0, 1.));\n        calculatePosRayDirFromPortals(portalA, portalB, p, rd, refpos, refdir);\n    }\n    else if(res.y < 2.1) { \/\/ PortalB\n        color = mapPortalColor(p, portalB.pos, portalB.rotateY, vec4(0.0, 1., 1.0, 0.1), vec4(0.91, 0.46, 0.07, 1.));\n        calculatePosRayDirFromPortals(portalB, portalA, p, rd, refpos, refdir);\n    }\n#if APPLY_COLORS == 1\n    else if(res.y < 3.1) { \/\/ Water\n        color = vec4(0.254, 0.239, 0.007, 1.0); lparams.xy = vec2(2.0, 50.);\n        color.rgb = mix(color.rgb, vec3(0.254, 0.023, 0.007), 1.-smoothstep(0.2, 1., fbm((p.xz+vec2(cos(t+p.x*2.)*0.2, cos(t+p.y*2.)*0.2))*0.5)));\n        color.rgb = mix(color.rgb, vec3(0.007, 0.254, 0.058), smoothstep(0.5, 1., fbm((p.xz*0.4+vec2(cos(t+p.x*2.)*0.2, cos(t+p.y*2.)*0.2))*0.5)));\n    }\n    else if(res.y < 4.1) { \/\/ Turbina\n        color = vec4(0.447, 0.490, 0.513, 1.0);\n    }\n    else if(res.y < 5.1) { \/\/Window\n        color = vec4(0.662, 0.847, 0.898, 0.6); lparams=vec4(3., 5., 0., 0.9);\n    }\n    else if(res.y < 6.1) { \/\/ Metal tube\n        color = vec4(0.431, 0.482, 0.650, 0.6); lparams.xy=vec2(2., 5.);\n    }\n    else if(res.y < 7.1) {\/\/ Plastic\n        color = vec4(0.8, 0.8, 0.8, 1.); lparams.xy=vec2(0.5, 1.);\n    }\n    else if(res.y < 8.1) { \/\/Railing\n        color = mix(vec4(1.), vec4(1., 1., 1., 0.), smoothstep(0.2, 0.21, fract(p.x)));\n        color = mix(vec4(1.), color, smoothstep(0.2, 0.21, fract(p.z)));\n        lparams.xy=vec2(1.0, 1.); refdir = rd;\n    }\n    else if(res.y < 9.1) { \/\/ Reflectance -> can be plastic\n        color = vec4(1., 1., 1., 0.1); lparams.xy=vec2(1.0, 10.);\n    }\n    else if(res.y < 10.1) { \/\/ Exit\n        vec3 q = p - vec3(1.5, 11.0, -31.);\n        color = vec4(0.6, 0.6, 0.6, 0.65);\n        color.rgb = mix(vec3(0.749, 0.898, 0.909), color.rgb, smoothstep(2., 10., length(q.xy)));        \n        color.rgb += mix(vec3(0.1), vec3(0.), smoothstep(2., 5., length(q.xy)));\n\n        vec3 q2 = q;\n        vec2 c = vec2(2., 1.5);\n        float velsign = mix(-1., 1., step(0.5, fract(q2.y*0.5)));\n        q2.x = mod(velsign*t+q2.x+cos(q2.y*3.)*0.5, 1.8);\n        q2.y = mod(q2.y, 1.15);\n\t\tfloat d = max(abs(q2.x)-0.9, abs(q2.y)-0.1);\n        color.rgb += mix(vec3(0.286, 0.941, 0.992)*1.6, vec3(0.), smoothstep(-0.1, 0.1, d));\n        \n        vec3 localp = p - vec3(1.5, 11.0, -31.);\n        refpos = vec3(1.5, 11.0, 28.0) + localp;\n        lparams=vec4(1.0, 10., 0., 0.1); refdir = rd;\n    }\n    else if(res.y < 11.1) { \/\/ Exit border\n        vec3 q = p; q.z = abs(q.z); q = q - vec3(0.0, 9.5, 31.);\n        color = vec4(0.8, 0.8, 0.8, 1.);\n        float d =length(abs(q.x+cos(q.y*0.5)*0.6 -3.0))-0.06;\n        d = min(d, length(abs(q.x+cos(PI+q.y*0.5)*0.6 +3.0))-0.06);        \n        color.rgb = mix(vec3(0.286, 0.941, 0.992), color.rgb, smoothstep(0., 0.01, d));\n        lparams = mix(vec4(0., 0., 0., 1.), lparams, smoothstep(0., 0.2, d));\n    }\n    else if(res.y < 12.1) { \/\/ Fireball base\n        vec3 q = p - vec3(10., 9.5, 26.5);\n        color = vec4(1.0, 1.0, 1.0, 1.);\n        float d = length(q-vec3(0., 0., -2.5)) - 2.0;\n        color = mix(vec4(0.976, 0.423, 0.262, 1.), color, smoothstep(-2., 0.01, d));\n    }\n    else if(res.y < 13.1) { \/\/ Fireball\n        color = vec4(1., 0.0, 0.0, 1.0);\n        color.rgb = mix(color.rgb, vec3(0.75, 0.94, 0.28), smoothstep(26.5, 27.0, t));\n    }\n    \n    else if(res.y > 19. && res.y < 25.) { \/\/ Walls\n        \n        float rand = fbm(point2plane(p, normal));\n        vec3 col = vec3(0.498, 0.584, 0.619);\n        color = vec4(vec3(col), 1.0);\n        color = mix(color, vec4(col*0.75, 1.0), smoothstep(0.2, 1.0, rand));\n        color = mix(color, vec4(col*0.80, 1.0), smoothstep(0.4, 1.0, fbm(point2plane(p*1.5, normal))));\n        color = mix(color, vec4(col*0.7, 1.0), smoothstep(0.6, 1.0, fbm(point2plane(p*4.5, normal))));\n        \n        vec3 dirtcolor = mix(vec3(0., 0., 0.), vec3(0.403, 0.380, 0.274)*0.2, rand);\n        float dirtheight = 0.1+rand*1.0;\n        dirtcolor = mix(dirtcolor, vec3(0.243, 0.223, 0.137), smoothstep(dirtheight, dirtheight + 0.5, p.y));\n        dirtheight = rand*2.;\n        color.rgb = mix(dirtcolor, color.rgb, smoothstep(dirtheight, dirtheight+2.0, p.y));\n        \n        vec4 noise = mix(vec4(0.), texture2D(iChannel0, point2plane(p*0.037, normal)) * 0.2, smoothstep(0.2, 1., rand));\n        normal = normalize(normal + vec3(noise.x, 0., noise.z));\n        refdir = normalize(reflect(rd, normal));\n        \n        if(res.y < 20.1) { \/\/ BROWN_WALL_BLOCK\n            float d = -(p.x-6.1);\n            d = max(d, p.y-12.6); d = min(d, p.y-6.5);\n            color *= mix(vec4(1.), vec4(0.227, 0.137, 0.011, 1.0), smoothstep(0.0, 0.1, d));\n        }\n        else if(res.y < 21.1) { \/\/ WHITE_PLATFORM_BLOCK\n            color *= vec4(0.529, 0.572, 0.709, 1.0);\n            vec3 q = p - vec3(11.5, 6.85, 7.0);\n            float d = abs(q.y)-0.05;\n            color.rgb = mix(vec3(0.945, 0.631, 0.015), color.rgb, smoothstep(0., 0.01, d));\n            lparams.w = mix(1., 0., smoothstep(0., 0.2, d));\n        }\n        else if(res.y < 22.1) { \/\/ TRANSPARENT_PLATFORM_BLOCK\n            color *= vec4(0.431, 0.482, 0.650, 0.1);\n            refdir = rd; lparams.xy=vec2(2., 5.);\n        }\n        else if(res.y < 23.1) { \/\/ CEILING_BLOCK\n            color *= mix(vec4(0.227, 0.137, 0.011, 1.0), vec4(1.), smoothstep(0., 0.01, p.z+6.));\n        }\n    }\n#endif    \n    return color;\n}\n\nvoid initLights()\n{\n    vec3 col = vec3(0.925, 0.968, 0.972);\n    \n    ambientcolor = col;\n    \n    \/\/ Center Up\n    lights[0].pos = vec3(0., 13.0, 0.);\n    lights[0].color = col*0.25;\n    \n    \/\/ Window\n    lights[1].pos = vec3(14.0, 15.5, -12.0);\n    lights[1].color = col*0.25;\n    \n    lights[2].pos = vec3(14.0, 15.5, -6.0);\n    lights[2].color = col*0.25;\n}\n\nvoid initPortals()\n{\n    portalsA[0].pos = vec3(-140.5, 10., 23.0);\t\tportalsA[0].front = vec3(1., 0., 0.);\tportalsA[0].rotateY = PI*0.5; portalsA[0].time = 0.;\n    portalsA[1].pos = vec3(-14.5, 10., 23.0);\t\tportalsA[1].front = vec3(1., 0., 0.);\tportalsA[1].rotateY = PI*0.5; portalsA[1].time = 6.0;\n    portalsA[2].pos = vec3(-14.5, 10., -2.5);\t\tportalsA[2].front = vec3(1., 0., 0.);\tportalsA[2].rotateY = PI*0.5; portalsA[2].time = 13.5;\n    portalsA[3].pos = vec3(10.5, 9.6, -20.5);\t\tportalsA[3].front = vec3(0., 0., 1.);\tportalsA[3].rotateY = 0.; \t  portalsA[3].time = 18.;\n    portalsA[4].pos = vec3(14.5, 9.5, -12.0);\t\tportalsA[4].front = vec3(-1., 0., 0.);\tportalsA[4].rotateY = PI*0.5; portalsA[4].time = 23.5;\n    \n    portalA = portalsA[0]; \n\n    portalB.pos = vec3(14.5, 10., 7.5);\n    portalB.front = vec3(-1., 0., 0.);\n    portalB.rotateY = -PI*0.5; portalB.time = 0.;\n}\n\nvoid initState()\n{  \n    states[0].posStart = vec3(0., 11.0, 26.0); states[0].posEnd = vec3(0., 11.0, 26.0); states[0].duration = 0.; states[0].lerptime = 0.; states[0].isEnterTime = 0.; states[0].enterPortal = 0.;  states[0].exitPortal = 1.;\n    states[1].posStart = vec3(0., 11.0, 26.0); states[1].posEnd = vec3(0., 11.0, 23.0); states[1].duration = 6.75; states[1].lerptime = 0.5; states[0].isEnterTime = 0.; states[0].enterPortal = 0.;  states[0].exitPortal = 1.;\n    states[2].posStart = vec3(0., 11.0, 23.0); states[2].posEnd = vec3(-12.6, 11.0, 23.0); states[2].duration = 4.0; states[2].lerptime = 1.0; states[0].isEnterTime = 0.; states[0].enterPortal = 0.;  states[0].exitPortal = 1.;\n    \n    \/\/ Go to Portal B\n    states[3].posStart = vec3(-12.6, 11.0, 23.0); states[3].posEnd = vec3(-14.5, 11., 23.0); states[3].duration = 0.1; states[3].lerptime = 0.1; states[0].isEnterTime = 0.; states[0].enterPortal = 0.;  states[0].exitPortal = 1.;\n    states[4].posStart = vec3(14.5, 11., 7.5); states[4].posEnd = vec3(13.5, 11., 7.5); states[4].duration = 3.0; states[4].lerptime = 0.5; states[0].isEnterTime = 1.; states[0].enterPortal = 0.;  states[0].exitPortal = 1.;\n    \n    \/\/ Go to Portal A\n    states[5].posStart = vec3(13.5, 11., 7.5); states[5].posEnd = vec3(14.5, 11., 7.5); states[5].duration = 0.1; states[5].lerptime = 1.25; states[0].isEnterTime = 0.; states[0].enterPortal = 0.;  states[0].exitPortal = 1.;\n    states[6].posStart = vec3(-14.5, 11., -2.5); states[6].posEnd = vec3(-11.6, 11., -2.5); states[6].duration = 15.; states[6].lerptime = 1.0; states[0].isEnterTime = 1.; states[0].enterPortal = 0.;  states[0].exitPortal = 1.;\n    \n    states[7].posStart = vec3(-11.6, 11., -2.5); states[7].posEnd = vec3(-11.6, 11., -23.0); states[7].duration = 7.5; states[7].lerptime = 7.0; states[0].isEnterTime = 0.; states[0].enterPortal = 0.;  states[0].exitPortal = 1.;\n    states[8].posStart = vec3(-11.6, 11., -23.0); states[8].posEnd = vec3(0.5, 11., -23.0); states[8].duration = 3.0; states[8].lerptime = 2.5; states[0].isEnterTime = 0.; states[0].enterPortal = 0.;  states[0].exitPortal = 1.;\n    states[9].posStart = vec3(0.5, 11., -23.0); states[9].posEnd = vec3(0.5, 11., -28.0); states[9].duration = 10.; states[9].lerptime = 0.5; states[0].isEnterTime = 0.; states[0].enterPortal = 0.;  states[0].exitPortal = 1.;\n    \n    t = mod(t, 40.);\n}\n\nvoid initOrientations()\n{\n    orientations[0].orientation = vec3(0., 0., -1.); \t\t\t\torientations[0].lerptime = 0.; orientations[0].duration = 0.;\n    orientations[1].orientation = vec3(0., 0., -1.); \t\t\t\torientations[1].lerptime = 0.0; orientations[1].duration = 1.0;\n    orientations[2].orientation = normalize(vec3(0.1, 0.25, -0.5)); orientations[2].lerptime = 1.50; orientations[2].duration = 2.0;\n    orientations[3].orientation = normalize(vec3(1., 0., -1.5)); \torientations[3].lerptime = 0.75; orientations[3].duration = 2.0;\n    orientations[4].orientation = vec3(0., 0., -1.); \t\t\t\torientations[4].lerptime = 1.25; orientations[4].duration = 1.25;\n    orientations[4].orientation = vec3(-1., 0., 0.); \t\t\t\torientations[4].lerptime = 1.0; orientations[4].duration = 6.25;\n    orientations[5].orientation = vec3(0., 0., -1.); \t\t\t\torientations[5].lerptime = 0.75; orientations[5].duration = 1.25;\n    orientations[6].orientation = vec3(-1., 0., -0.4);\t\t\t\torientations[6].lerptime = 0.60; orientations[6].duration = 3.25;\n    orientations[7].orientation = vec3(0., 0., 1.);\t\t\t\t\torientations[7].lerptime = 0.75; orientations[7].duration = 0.75;\n    orientations[8].orientation = vec3(1., 0., -0.65);\t\t\t\torientations[8].lerptime = 0.75; orientations[8].duration = 3.8;\n    orientations[9].orientation = vec3(0.0, 0., 1.);\t\t\t\torientations[9].lerptime = 1.0; orientations[9].duration = 1.5;\n    orientations[10].orientation = vec3(1.0, 0., -0.2);\t\t\t\torientations[10].lerptime = 0.75; orientations[10].duration = 3.2;\n    orientations[11].orientation = vec3(-0.2, 0., -1.);\t\t\t\torientations[11].lerptime = 2.0; orientations[11].duration = 5.0;\n    orientations[12].orientation = normalize(vec3(0.6, -0.5, -1.));\torientations[12].lerptime = 0.5; orientations[12].duration = 5.0;\n    orientations[13].orientation = vec3(1., 0., 0.);\t\t\t\torientations[13].lerptime = 0.5; orientations[13].duration = 3.5;\n    orientations[14].orientation = vec3(0., 0., -1.);\t\t\t\torientations[14].lerptime = 0.5; orientations[14].duration = 10.0;\n\n    orientation = orientations[0].orientation;\n}\n\nvec3 modOrientationToPortals(vec3 or, vec3 enterFront, vec3 exitFront)\n{\n    vec3 enterRight = cross(vec3(0., 1., 0.), enterFront);\n    vec3 enterUp = cross(enterFront, enterRight);\n    \n    vec3 exitRight = cross(vec3(0., 1., 0.), exitFront);\n    vec3 exitUp = cross(exitFront, exitRight);\n    \n    vec3 enterProjection = vec3\n    (\n        dot(or, enterRight),\n        dot(or, enterUp),\n        dot(or, enterFront)\n    );\n    \n    return exitFront*enterProjection.z + exitRight*enterProjection.x + exitUp*enterProjection.y;\n}\n\nvoid updateState()\n{   \n    vec3 axisEnterFront = vec3(0., 0., -1.);\n\tvec3 axisExitFront = vec3(0., 0., -1.);\n    float portalEnterTime = 0.;\n    float at = 0.;\n    position = vec3(-5., 11.0, 26.);\n    \n    for(int i = 4; i >= 0; i--) { \/\/ Set current Portal\n        if(t > portalsA[i].time) {\n            portalA = portalsA[i];\n            break;\n        }\n    }\n    for(int i = 1; i < 10; ++i) { \/\/ Set Camera position\n        at += states[i].duration;\n        portalEnterTime = mix(portalEnterTime, at-states[i].duration, step(0.5, states[i].isEnterTime));\n        \n        vec3 axisEnterFrontA = -mix(portalA.front, portalB.front, step(0.5, states[i].enterPortal));\n        axisEnterFront = mix(axisEnterFront, axisEnterFrontA, step(0.5, states[i].isEnterTime));\n        \n        vec3 axisExitFrontA = mix(portalA.front, portalB.front, step(0.5, states[i].exitPortal));\n        axisExitFront = mix(axisExitFront, axisExitFrontA, step(0.5, states[i].isEnterTime));\n        if(t < at) {\n            position = mix(states[i].posStart, states[i].posEnd, clamp((t - (at-states[i].duration)) \/ (states[i].lerptime), 0., 1.));\n            break;\n        }\n    }\n    at = 0.;\n    for(int i = 1; i < 15; ++i) { \/\/ Set Camera orientation\n        at += orientations[i].duration;\n        if(t < at) {\n            vec3 prevOrientation = mix(modOrientationToPortals(orientations[i-1].orientation, axisEnterFront, axisExitFront), orientations[i-1].orientation, step(portalEnterTime, at-orientations[i].duration-orientations[i-1].duration));\n            vec3 currentOrientation = mix(modOrientationToPortals(orientations[i].orientation, axisEnterFront, axisExitFront), orientations[i].orientation, step(portalEnterTime, at-orientations[i].duration));\n            orientation = normalize(mix(prevOrientation, currentOrientation, clamp((t - (at-orientations[i].duration)) \/ (orientations[i].lerptime), 0., 1.)));\n            break;\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = iGlobalTime;\n\n    initState();\n    initPortals();\n    initOrientations();\n    initLights();\n    \n    updateState();\n    \n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec2 p = (uv * 2. -1.) * vec2(iResolution.x\/iResolution.y, 1.);\n    vec2 mo = mix(vec2(0.), iMouse.xy \/ iResolution.xy, step(0.001, length(iMouse.zw)));\n    \n    vec3 right = cross(vec3(0., 1., 0.), orientation);\n    orientation += right*mo.x + vec3(0., 1., 0)*mo.y;\n    \n    vec3 ww = normalize(orientation);\n    vec3 uu = normalize(cross(vec3(0., 1., 0.), ww));\n\tvec3 vv = normalize(cross(ww, uu));\n    \n    vec3 rd = normalize(p.x*uu*0.7 + p.y*vv + 1.*ww);\n    \n    float fov = tan(0.46);\n    rd = normalize(p.x*uu*fov + p.y*vv*fov + 1.*ww);\n    vec3 color = vec3(0.);\n    float att = 1.;\n    for(int i = 0; i < 3; ++i)\n    {\n        vec4 res = intersect(position, rd, 0.40, 9999.);\n        if(res.y > 0.0)\n        {\n            vec3 point = position + rd*res.x;\n            \n            vec3 normal = calcnormal(point);\n            vec3 refposition;\n            vec3 refdir;\n            vec4 lparams;\n            vec4 colorrgba = mapcolor(point, res, normal, rd, refposition, refdir, lparams);\n            \n            float latt = 1.-ambient;\n            vec3 acolor = colorrgba.rgb*ambientcolor*ambient;            \n            for(int lidx = 0; lidx < 3; ++lidx)\n            {\n                vec3 ldir = lights[lidx].pos - point;\n                float ldirLength = length(ldir);\n                ldir \/= ldirLength;\n                latt *= 1.-clamp((ldirLength-5.)\/35., 0., 1.);\n                \n                vec3 diffuse = colorrgba.rgb;\n                float diffactor = max(0., pow(dot(ldir, normal), 1.0))*latt;\n\n                vec3 reflec = reflect(rd, normal);\n                float specfactor = pow(max(0., dot(ldir, reflec)), lparams.y) * lparams.x;\n\n                float shadow = 1.;\n                #if APPLY_SHADOW == 1\n                shadow =  max(calcshadow(point, ldir, 0.8, ldirLength), 0.01);\n                #endif\n                \n                acolor += diffuse * diffactor * lights[lidx].color* shadow;\n                acolor += specfactor * lights[lidx].color* shadow;\n                color += (acolor*colorrgba.a*att);\n            }\n            \n            color = lparams.w*colorrgba.rgb + (1.-lparams.w)*color.rgb;;\n            vec3 fireballcolor = mix(vec3(0.91, 0.46, 0.07), vec3(0.42, 0.90, 0.00), smoothstep(26.5, 27.0, t));\n            vec3 bloomcolor = mix(fireballcolor, vec3(1.6, 1.65, 1.65), step(0.5, res.w));\n    \t\tcolor.rgb = mix(mix(bloomcolor, color.rgb, 0.5), color.rgb, smoothstep(0., 1.0, res.z));\n            \n            att = max(att*(1.-colorrgba.a), 0.);\n            if(att < 0.01)\n            {\n                break;\n            }\n            \n            rd = refdir;\n            position = refposition;\n        }\n        else\n        {\n            att = 0.;\n            break;\n        }\n    }\n    \n    float fadeFactor = mix(0., 1., smoothstep(39., 40., t));\n    fadeFactor = mix(1., fadeFactor, smoothstep(0., 1., t));\n    \n\tfragColor = mix(vec4(color, 1.), vec4(0.), fadeFactor);\n}\n","name":"","description":"","type":"image"}]}}