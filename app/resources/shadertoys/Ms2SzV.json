{"Shader":{"ver":"0.1","info":{"id":"Ms2SzV","date":"1414085404","viewed":906,"name":"sdf raymarching: min rings","username":"hornet","description":"from the demo 'min' by loopit: http:\/\/www.pouet.net\/prod.php?which=62851<br\/>- code cleaned up a bit, but still in a terrible state<br\/><br\/>added a hue-offset not present in original (as it looks cool <img src=\"\/img\/emoticonLaugh.png\"\/> )","likes":17,"published":3,"flags":0,"tags":["raymarching","sdf","distance","min","loopit"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"const vec4 parms = vec4( 0.0, -1.0, 0.0, 2.25 );\nconst vec4 parms2 = vec4( 1, 10, -0.05, 1.0 );\nconst vec4 parms3 = vec4( 0.075, 0.1, 1, 1 );\n\nconst vec4 camctr = vec4( 0, -10, 0, 1 );\nconst vec4 campos = vec4( 7, 8, 9, 1 );\n\nconst float PI = 3.14159265358979;\n\nconst float NEAR_CLIP = 2.8;\nconst float FAR_CLIP = 30.0;\n\n#define NUM_ITERATIONS 128\nconst float NUM_ITERATIONS_F = float(NUM_ITERATIONS);\nconst float TERM_DIST = 0.5;\nconst float STEP_MULT = 0.25;\n\nconst float ASPECT  = 2.35;\nconst float ASPECT0 = 16.0\/9.0;\n\n\n\/\/nvidia hsv\nfloat min_channel(vec3 v)\n{\n\tfloat t = (v.x<v.y) ? v.x : v.y;\n\tt = (t<v.z) ? t : v.z;\n\treturn t;\n}\n\nfloat max_channel(vec3 v)\n{\n\tfloat t = (v.x>v.y) ? v.x : v.y;\n\tt = (t>v.z) ? t : v.z;\n\treturn t;\n}\nvec3 rgb_to_hsv(vec3 RGB)\n{\n\tvec3 HSV = vec3(0,0,0);\n\tfloat minVal = min_channel(RGB);\n\tfloat maxVal = max_channel(RGB);\n\tfloat delta = maxVal - minVal; \/\/Delta RGB value \n\tHSV.z = maxVal;\n\t\/\/ If gray, leave H & S at zero\n\tif (delta != 0.0) { \n\t\tHSV.y = delta \/ maxVal;\n\t\tvec3 delRGB;\n\t\tdelRGB = ( ( vec3(maxVal) - RGB ) \/ 6.0 + ( delta \/ 2.0 ) ) \/ delta;\n\t\tif      ( RGB.x == maxVal ) HSV.x = delRGB.z - delRGB.y;\n\t\telse if ( RGB.y == maxVal ) HSV.x = 1.0\/3.0 + delRGB.x - delRGB.z;\n\t\telse if ( RGB.z == maxVal ) HSV.x = 2.0\/3.0 + delRGB.y - delRGB.x;\n\t\tif ( HSV.x < 0.0 ) { HSV.x += 1.0; }\n\t\tif ( HSV.x > 1.0 ) { HSV.x -= 1.0; }\n\t}\n\treturn (HSV);\n}\nvec3 hsv_to_rgb(vec3 HSV)\n{\n\tvec3 RGB = HSV.zzz;\n\tif ( HSV.y != 0.0 ) {\n\t\tfloat var_h = HSV.x * 6.0;\n\t\tfloat var_i = floor(var_h); \/\/ Or ... var_i = floor( var_h )\n\t\tfloat var_1 = HSV.z * (1.0 - HSV.y);\n\t\tfloat var_2 = HSV.z * (1.0 - HSV.y * (var_h-var_i));\n\t\tfloat var_3 = HSV.z * (1.0 - HSV.y * (1.0-(var_h-var_i)));\n\t\tif      (var_i == 0.0) { RGB = vec3(HSV.z, var_3, var_1); }\n\t\telse if (var_i == 1.0) { RGB = vec3(var_2, HSV.z, var_1); }\n\t\telse if (var_i == 2.0) { RGB = vec3(var_1, HSV.z, var_3); }\n\t\telse if (var_i == 3.0) { RGB = vec3(var_1, var_2, HSV.z); }\n\t\telse if (var_i == 4.0) { RGB = vec3(var_3, var_1, HSV.z); }\n\t\telse                 { RGB = vec3(HSV.z, var_1, var_2); }\n\t}\n\treturn (RGB);\n}\n\n\n\/\/ ============================================================\n\/\/ most primitive distance-functions honestly stolen from http:\/\/iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\n\nfloat sat( float t )\n{\n\treturn clamp( t, 0.0, 1.0 );\n}\nvec3 sat( vec3 t )\n{\n\treturn clamp( t, 0.0, 1.0 );\n}\n\n\n\/\/ ====\nvec4 select( vec4 a, vec4 b ) {\n\treturn (a.x<b.x) ? a : b;\n}\n\n\/\/ ====\nvec2 rot2d( vec2 p, float a )\n{\n\tvec2 sc = vec2(sin(a),cos(a));\n\tvec2 ret;\n\tret.x = dot( p, sc.yx*vec2(1,-1) );\n\tret.y = dot( p, sc.xy );\n\treturn ret;\n}\n\n\/\/ ====\n\/\/note: local sphere, radius r\nfloat sdSphere( vec3 p, float r ) {\n\treturn length( p ) - r;\n}\n\n\/\/ ====\nfloat sdPlane( vec3 p, vec3 pointonplane, vec3 norm )\n{\n\treturn dot( norm, p-pointonplane);\n}\n\n\/\/note: [-1;1[\n\/\/note: honestly stolen from iq: https:\/\/www.shadertoy.com\/view\/Xsl3Dl\nvec3 shash3( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat trunc( float x, float num_levels )\n{\n\treturn floor(x*num_levels) \/ num_levels;\n}\nvec3 trunc( vec3 x, vec3 num_levels )\n{\n\treturn floor(x*num_levels) \/ num_levels;\n}\n\nvec2 sdHalfCircle( vec3 p )\n{\n\tvec3 ofs = shash3( trunc( p, vec3(13)));\n    vec3 h2 = shash3( trunc( p, vec3(32) + ofs ) );\n    vec3 h3 = shash3( trunc( p, vec3(16) ) );\n\tp += 0.02  * h2;\n\tp += 0.01  * h3;\n\n\tconst float spherer = 1.0;\n\tfloat ds = sdSphere( p, spherer );\n\tds = max( ds, -sdSphere( p, 0.9 * spherer ));\n\tds = max( ds,  p.x-0.1);  \/\/cut sides\n\tds = max( ds, -p.x-0.1); \/\/ -\n\t\n    vec2 ret;\n    ret.x = ds + parms2.z + 0.001*(iMouse.z>0.5 ? iMouse.x : 0.0 );\n    ret.y = min( max(h3.x, h2.x ), max( ofs.x, h2.y ) );\n    ret.y = step( 0.75, ret.y );\n\treturn ret;\n}\n\nvec2 sel_min( vec2 a, vec2 b )\n{\n    return a.x < b.x ? a : b;\n}\n\nvec4 cylinder_radialrepeat( vec3 p, float r )\n{\n\tvec2 d = vec2( FAR_CLIP, 0 );\n\n\tp *= parms2.w;\n\t{\n\t\tvec3 dp = p; \/\/vec3( dp2d.x, p.y, dp2d.y );\n\n\t\tdp.zx = rot2d( dp.xz, 0.3*iGlobalTime );\n\t\tvec2 ds = sdHalfCircle( dp );\n\n\t\tdp.xy = rot2d( dp.xy, -0.7 * iGlobalTime );\n\t\tds = sel_min ( ds, sdHalfCircle( dp.xyz*1.3 ) );\n\n\t\tdp.xz = rot2d( dp.xz, 1.1*iGlobalTime );\n\t\tds = sel_min ( ds, sdHalfCircle( dp.xyz*1.8 ) );\n\n\t\tdp.xz = rot2d( dp.xz, -1.3*iGlobalTime );\n\t\tds = sel_min ( ds, sdHalfCircle( dp.xyz*2.8 ) );\n\n\t\td = sel_min( d, ds );\n\t}\n\n\treturn vec4( d, vec2(0,0) );\n}\n\n\/\/ ============================================================\n\nvoid init1( out vec3 cam_eye, out vec3 cam_lookat, out vec3 cam_up ) {\n\tcam_eye    = vec3( 10, 10, 10 );\n\tcam_lookat = vec3( 0, 0, 0 );\n\tcam_up     = normalize( vec3( 0.2, 1, 0 ) );\n}\n\nvec4 scene1( vec3 p )\n{\n\tvec4 d = vec4( FAR_CLIP, 0.0, 0.0, -1.0 ); \/\/note: background\n\n\tvec3 cyl_pos = vec3( 0, -10, 0 );\n\tfloat cyl_scl = 10.0;\n\tfloat cyl_r = 0.1;\n\tvec4 crr = cylinder_radialrepeat( (p-cyl_pos)\/cyl_scl, cyl_r*0.5 );\n\tcrr.x *= cyl_scl;\n\n    return crr;\n}\n\n\/\/ ===\nvoid init( out vec3 cam_eye, out vec3 cam_lookat, out vec3 cam_up )\n{\n\tinit1( cam_eye, cam_lookat, cam_up );\n}\n\n\/\/ ====\nvec4 scene( vec3 p )\n{\n\treturn scene1( p );\n}\n\n\/\/ ====\n\/\/[0;1[\nfloat nrand( vec2 n ) {\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n\/\/ ============================================================\n\nvec4 raymarch( inout vec3 p, inout vec3 dir, out int out_steps )\n{\n    int iter = 0;\n\tvec4 d;\n\tfloat rdt = 0.0;\n\tfor ( int i=0; i<NUM_ITERATIONS; i++ )\n\t{\n        iter += 1;\n\t\td = scene( p );\n\n\t\tif ( (d.x < 0.0 ) || (rdt > FAR_CLIP) ) {\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfloat dt = 0.01 + STEP_MULT * d.x; \/\/note: constant-multiply to compensate for distorted space, actual dist < dist - could use gradient-approximation instead? (see iq)\n\t\t\tp += dir * dt;\n\t\t\trdt += dt;\n\t\t}\n\t}\n\n\tout_steps = iter;\n\treturn d;\n\n}\n\n\/\/ ====\n\/\/note: way too big but only used for approx dir\nconst vec3 GRAD_EPS = vec3( 0.5, 0, 0 );\n\nvec3 grad3( vec3 p, float d )\n{\n\treturn normalize( vec3( scene( p + GRAD_EPS.xyz ).x - d,\n\t\t\t\t\t\t\tscene( p + GRAD_EPS.zxy ).x - d,\n\t\t\t\t\t\t\tscene( p + GRAD_EPS.yzx ).x - d ) );\n}\n\/\/note: more expensive version\nvec3 grad6( vec3 p )\n{\n\treturn normalize( vec3( scene( p + GRAD_EPS.xyz ).x - scene( p - GRAD_EPS.xyz ).x,\n\t\t\t\t\t\t\tscene( p + GRAD_EPS.zxy ).x - scene( p - GRAD_EPS.zxy ).x,\n\t\t\t\t\t\t\tscene( p + GRAD_EPS.yzx ).x - scene( p - GRAD_EPS.yzx ).x ) );\n}\n\n\/\/ ====\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 cam_eye;\n\tvec3 cam_lookat;\n\tvec3 cam_up;\n\n\tinit( cam_eye, cam_lookat, cam_up );\n\n\tcam_eye = campos.xyz;\n\tcam_lookat = camctr.xyz;\n\n\n\tvec3 negz = normalize( cam_lookat - cam_eye );\n\tvec3 u = cross( negz, cam_up );\n\tvec3 v = cross( u, negz );\n\n    vec2 texcoord0 = fragCoord.xy \/ iResolution.xy - vec2(0.5);\n\tvec2 uv = texcoord0;\n\n    u *= uv.x;\n\tv *= uv.y;\n\n\tfloat aspect = mix( ASPECT, ASPECT0, parms2.x );\n\tu *= aspect;\n\n\tconst float dist = 1.0; \/\/...also controls fov :p\n\tvec3 dir = dist * negz + u + v;\n\tdir = normalize( dir );\n\n\tvec3 p_org = cam_eye + NEAR_CLIP * dir;\n\tvec3 p = p_org;\n\t\n\tfloat rnd = nrand( texcoord0.xy + 0.01 * fract( iGlobalTime ) );\n\n\t\n\t\/\/note: jitter startpos\n\tp -= 4.0*TERM_DIST * dir * rnd;\n\n\tint i;\n\tvec4 d = raymarch( p, dir, i );\n\n    bool valid = d.x < 0.0;\n    \n\tvec4 outcol = vec4( d.yyy, valid ? 1.0 : 0.0 );\n\toutcol.rgb = max( vec3(0), outcol.rgb );\n\n    \/\/vec3 n = grad3( p, d.x );\n    \/\/outcol.rgb *= 1.5 - vec3( dot(n,-dir) );\n\n    outcol.rgb *= outcol.aaa;\n\n    \n\t\/\/note: iteration-glow\n\tfloat it_f = float(i) + 0.5 - rnd;\n\tfloat iterations = it_f \/ NUM_ITERATIONS_F;\n\tfloat glowits = parms2.y * pow(iterations,2.3);\n\tconst vec3 gc0 = vec3(104,79,255)\/255.0;\n\tvec3 glowcol = mix( 0.5*gc0, 2.0*gc0, parms.x );\n\toutcol.rgb += 3.0*glowits * glowcol;\n\n\t\/\/note: vignette\n\tfloat vign = 1.5-length(texcoord0.xy*vec2(2.35,1));\n\tvign = pow(vign, 2.0);\n\toutcol.rgb *= vec3( sat(vign) );\n\n    \/\/note: vertical color-shift\n    vec3 hsv = rgb_to_hsv( outcol.rgb );\n    hsv.x -= 0.1 * pow(0.9-fragCoord.y \/ iResolution.y, 2.0);\n    outcol.rgb = hsv_to_rgb( hsv );\n    \n    \n    fragColor = outcol;\n}\n","name":"","description":"","type":"image"}]}}