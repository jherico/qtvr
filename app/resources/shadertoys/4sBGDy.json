{"Shader":{"ver":"0.1","info":{"id":"4sBGDy","date":"1392806311","viewed":1664,"name":"Torus - intersection","username":"iq","description":"Analytic intersection of a torus. From Antonalog's shader (XdSGWy), simplified the geometrically impossible cases, and optimized coefficients. One can probably do better than this (in terms of big picture and math I mean, not saving individual muls\/adds)","likes":11,"published":3,"flags":0,"tags":["3d","raytracing","torus","intersection","analyticall"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\/\/ Analytic intersection of a torus (degree 4 equation). Motivated by Antonalog's \n\/\/ shader (https:\/\/www.shadertoy.com\/view\/XdSGWy), and simplified the geometrically \n\/\/ impossible cases, and optimized coefficients. One can probably do better than \n\/\/ this though...\n\t\n\n\/\/ f(x) = (|x|\u00b2 + R\u00b2 - r\u00b2)\u00b2 - 4\u00b7R\u00b2\u00b7|xy|\u00b2 = 0\n\nfloat iTorus( in vec3 ro, in vec3 rd, in vec2 torus )\n{\n\tfloat Ra2 = torus.x*torus.x;\n\tfloat ra2 = torus.y*torus.y;\n\t\n\tfloat m = dot(ro,ro);\n\tfloat n = dot(ro,rd);\n\t\t\n\tfloat k = (m - ra2 - Ra2)\/2.0;\n\tfloat a = n;\n\tfloat b = n*n + Ra2*rd.z*rd.z + k;\n\tfloat c = k*n + Ra2*ro.z*rd.z;\n\tfloat d = k*k + Ra2*ro.z*ro.z - Ra2*ra2;\n\t\n    \/\/----------------------------------\n\n\tfloat p = -3.0*a*a     + 2.0*b;\n\tfloat q =  2.0*a*a*a   - 2.0*a*b   + 2.0*c;\n\tfloat r = -3.0*a*a*a*a + 4.0*a*a*b - 8.0*a*c + 4.0*d;\n\tp \/= 3.0;\n\tr \/= 3.0;\n\tfloat Q = p*p + r;\n\tfloat R = 3.0*r*p - p*p*p - q*q;\n\t\n\tfloat h = R*R - Q*Q*Q;\n\tfloat z = 0.0;\n\tif( h < 0.0 )\n\t{\n\t\tfloat sQ = sqrt(Q);\n\t\tz = 2.0*sQ*cos( acos(R\/(sQ*Q)) \/ 3.0 );\n\t}\n\telse\n\t{\n\t\tfloat sQ = pow( sqrt(h) + abs(R), 1.0\/3.0 );\n\t\tz = sign(R)*abs( sQ + Q\/sQ );\n\n\t}\n\t\n\tz = p - z;\n\t\n    \/\/----------------------------------\n\t\n\tfloat d1 = z   - 3.0*p;\n\tfloat d2 = z*z - 3.0*r;\n\n\tif( abs(d1)<1.0e-4 )\n\t{\n\t\tif( d2<0.0 ) return -1.0;\n\t\td2 = sqrt(d2);\n\t}\n\telse\n\t{\n\t\tif( d1<0.0 ) return -1.0;\n\t\td1 = sqrt( d1\/2.0 );\n\t\td2 = q\/d1;\n\t}\n\n    \/\/----------------------------------\n\t\n\tfloat result = 1e20;\n\n\th = d1*d1 - z + d2;\n\tif( h>0.0 )\n\t{\n\t\th = sqrt(h);\n\t\tfloat t1 = -d1 - h - a;\n\t\tfloat t2 = -d1 + h - a;\n\t\t     if( t1>0.0 ) result=t1;\n\t\telse if( t2>0.0 ) result=t2;\n\t}\n\n\th = d1*d1 - z - d2;\n\tif( h>0.0 )\n\t{\n\t\th = sqrt(h);\n\t\tfloat t1 = d1 - h - a;\n\t\tfloat t2 = d1 + h - a;\n\t\t     if( t1>0.0 ) result=min(result,t1);\n\t\telse if( t2>0.0 ) result=min(result,t2);\n\t}\n\n\treturn result;\n}\n\n\/\/ df(x)\/dx\nvec3 nTorus( in vec3 pos, vec2 tor )\n{\n\treturn normalize( pos*(dot(pos,pos)- tor.y*tor.y - tor.x*tor.x*vec3(1.0,1.0,-1.0)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) \/ iResolution.y;\n\n     \/\/ camera movement\t\n\tfloat an = 0.5*iGlobalTime;\n\tvec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    \/\/ camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t\/\/ create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    \/\/ raytrace\n\t\n\t\/\/ raytrace-plane\n\tvec2 torus = vec2(1.0,0.5);\n\tfloat t = iTorus( ro, rd, torus );\n\n    \/\/ shading\/lighting\t\n\tvec3 col = vec3(0.0);\n\tif( t>0.0 && t<100.0 )\n\t{\n\t    vec3 pos = ro + t*rd;\n\t\tvec3 nor = nTorus( pos, torus );\n\t\tfloat dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n\t\tfloat amb = clamp( 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n\t\tcol = vec3(0.2,0.3,0.4)*amb + vec3(1.0,0.9,0.7)*dif;\n\t\tcol *= 0.8;\n\t}\n\t\n\tcol = sqrt( col );\n\n\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}