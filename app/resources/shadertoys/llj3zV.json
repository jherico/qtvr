{"Shader":{"ver":"0.1","info":{"id":"llj3zV","date":"1430612911","viewed":1261,"name":"Gas Giant!","username":"HamzaHutchinson","description":"Trying to make a nice looking space scene. Inspiration, code and learning drawn from a number of different shaders. Thanks to iq, Antonalog and mu6k.","likes":25,"published":3,"flags":0,"tags":["space","planet","stars","gasgiant"],"hasliked":0},"renderpass":[{"inputs":[{"id":10,"src":"\/presets\/tex09.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Reference shaders below\n\/\/ RAYMARCHED BALL (iq):  https:\/\/www.shadertoy.com\/view\/ldfSWs\n\/\/ NOISE (iq): https:\/\/www.shadertoy.com\/view\/4sfGzS#\n\/\/ CUBEMAP (iq): https:\/\/www.shadertoy.com\/view\/ltl3D8\n\/\/ SWIRLY STUFF (Antonalog): https:\/\/www.shadertoy.com\/view\/4s23WK\n\/\/ STAR\/FLARE (mu6k): https:\/\/www.shadertoy.com\/view\/4sX3Rs\n\/\/ RAY V SPHERE (reinder): https:\/\/www.shadertoy.com\/view\/4tjGRh\n\nconst int star_iterations = 10;\nconst float distort_iterations = 5.0;\nconst float tex_scale = 0.025;\nconst float time_scale = 0.2;\nconst vec3 col_star = vec3( 1.0, 0.7, 0.5 );\nconst vec3 pos_star = vec3( 0.0, 9.0, 30.0 );\nconst vec3 world_up = vec3( 0.0, 1.0, 0.0 );\n\nstruct CameraInfo\n{\n    vec3 pos;\n    vec3 dir;\n    mat3 m;\n    mat3 mInv;\n};\n\nfloat hash( float n ) { return fract(sin(n)*123.456789); }\n\nvec2 rotate( in vec2 uv, float a)\n{\n    float c = cos( a );\n    float s = sin( a );\n    return vec2( c * uv.x - s * uv.y, s * uv.x + c * uv.y );\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 fl = floor( p );\n    vec3 fr = fract( p );\n    fr = fr * fr * ( 3.0 - 2.0 * fr );\n\n    float n = fl.x + fl.y * 157.0 + 113.0 * fl.z;\n    return mix( mix( mix( hash( n +   0.0), hash( n +   1.0 ), fr.x ),\n                     mix( hash( n + 157.0), hash( n + 158.0 ), fr.x ), fr.y ),\n                mix( mix( hash( n + 113.0), hash( n + 114.0 ), fr.x ),\n                     mix( hash( n + 270.0), hash( n + 271.0 ), fr.x ), fr.y ), fr.z );\n}\n\nfloat fbm( in vec2 p, float t )\n{\n    float f;\n    f  = 0.5000 * noise( vec3( p, t ) ); p *= 2.1;\n    f += 0.2500 * noise( vec3( p, t ) ); p *= 2.2;\n    f += 0.1250 * noise( vec3( p, t ) ); p *= 2.3;\n    f += 0.0625 * noise( vec3( p, t ) );\n    return f;\n}\n\nvec2 field(vec2 p)\n{\n    float t = time_scale * iGlobalTime;\n\n    p.x += t;\n\n    float n = fbm( p, t );\n\n    float e = 0.25;\n    float nx = fbm( p + vec2( e, 0.0 ), t );\n    float ny = fbm( p + vec2( 0.0, e ), t );\n\n    return vec2( n - ny, nx - n ) \/ e;\n}\n\nvec3 distort( in vec2 p )\n{\n    for( float i = 0.0; i < distort_iterations; ++i )\n    {\n        p += field( p ) \/ distort_iterations;\n    }\n    vec3 s = 2.5 * texture2D( iChannel0, vec2( 0.0, p.y * tex_scale ) ).xyz;\n\n    return fbm( p, 0.0 ) * s;\n}\n\nvec2 map( in vec2 uv )\n{\n    uv.x *= 5.0;\n    uv.x += 0.01 * iGlobalTime;\n    uv.y *= 15.0;\n    return uv;\n}\n\nvec3 doBackgroundStars( in vec3 dir )\n{\n    vec3 n  = abs( dir );\n    vec2 uv = ( n.x > n.y && n.x > n.z ) ? dir.yz \/ dir.x: \n              ( n.y > n.x && n.y > n.z ) ? dir.zx \/ dir.y:\n                                           dir.xy \/ dir.z;\n    \n    float f = 0.0;\n    \n    for( int i = 0 ; i < star_iterations; ++i )\n    {\n        uv = rotate( 1.07 * uv + vec2( 0.7 ), 0.5 );\n        \n        float t = 10. * uv.x * uv.y + iGlobalTime;\n        vec2 u = cos( 100. * uv ) * fbm( 10. * uv, 0.0 );\n        f += smoothstep( 0.5, 0.55, u.x * u.y ) * ( 0.25 * sin( t ) + 0.75 );\n    }\n    \n    return f * col_star;\n}\n\nvec3 doMainStar( in vec2 uv, in vec2 sp)\n{\n    float t = atan( uv.x - sp.x, uv.y - sp.y );\n    float n = 2.0 + noise( vec3( 10.0 * t, iGlobalTime, 0.0 ) );\n    float d = length( uv - sp ) * 25.0;\n    return ( ( 1.0 + n ) \/ ( d * d * d ) ) * col_star;\n}\n\nfloat doCastSphere( in vec3 p, in vec3 rd )\n{\n    float b = dot( p, rd );\n    float c = dot( p, p ) - 1.0;\n    \n    float f = b * b - c;\n    if( f >= 0.0 )\n    {\n        return -b - sqrt( f );\n    }\n    return -1.0;\n}\n\nvec3 doMaterial( in vec3 pos )\n{\n    vec2 uv;\n    uv.x = atan( pos.x, pos.z );\n    uv.y = asin( pos.y );\n    return distort( map( uv ) );\n}\n\nvec3 doLighting( in vec3 n, in vec3 c, in vec3 rd, in vec3 rdc )\n{\n    vec3  l   = normalize( pos_star + 2.0 * ( pos_star - dot( pos_star, rdc ) * rdc ) );\n    float ndl = dot( n, l );\n    float ndr = dot( n, -rd );\n    float ldr = dot( l, rd );\n    float f   = max( ndl, 0.0 ) + 0.002;\n    float g   = ldr * smoothstep( 0.0, 0.1, ndr ) * pow( 1.0 - ndr, 10.0 );\n    return clamp( f * c + g * col_star, 0.0, 1.0 );\n}\n\nfloat doFlare( in vec2 uv, in vec2 dir, float s )\n{\n    float d = length( uv - dot( uv, dir ) * dir );\n    float f = 0.0;\n    f += max( pow( 1.0 - d, 128.0 ) * ( 1.0   * s - length( uv ) ), 0.0 );\n    f += max( pow( 1.0 - d,  64.0 ) * ( 0.5   * s - length( uv ) ), 0.0 );\n    f += max( pow( 1.0 - d,  32.0 ) * ( 0.25  * s - length( uv ) ), 0.0 );\n    f += max( pow( 1.0 - d,  16.0 ) * ( 0.125 * s - length( uv ) ), 0.0 );\n    return f;\n}\n\nfloat doLensGlint( in vec2 uv, in vec2 c, float r, float w )\n{\n    float l = length( uv - c );\n    return length( c ) * smoothstep( 0.0, w * r, l ) * ( 1.0 - smoothstep( w * r, r, l ) );\n}\n\nvec3 render( in vec2 uv, in CameraInfo ci )\n{\n    \/\/ create view ray\n    vec3 rd  = ci.m * normalize( vec3( uv, 1.0 ) );\n    vec3 rdc = ci.m * vec3( 0.0, 0.0, 1.0 );\n    \n    \/\/ background stars\n    vec3 c = doBackgroundStars( rd );\n    \n    \/\/ main star\n    vec3 cp = ci.mInv * (pos_star - ci.pos);\n    vec2 sp = cp.xy \/ cp.z;\n    if( cp.z > 0. )\n    {\n        c += doMainStar( uv, sp );\n    }\n    \n    \/\/ planet\n    float t = doCastSphere( ci.pos, rd );\n    if( t > 0.0 )\n    {\n        vec3 pos = ci.pos + t * rd;\n        vec3 nor = normalize( pos );\n        c = doMaterial( pos );\n        c = doLighting( nor, c, rd, rdc );\n    }\n    \n    \/\/ lens flare\n    if( cp.z > 0.0 && sp.x > -1.0 && sp.x < 1.0 )\n    {\n        float oc = smoothstep( 0.35, 0.4, length( sp ) );\n        float f = 0.0;\n        f += doFlare( uv - sp, vec2( 1.,0. ), oc );\n        f += oc * 0.05 * doLensGlint( uv, -0.4 * sp, 0.2, 0.92 );\n        f += oc * 0.09 * doLensGlint( uv, -0.8 * sp, 0.3, 0.95 );\n        f += oc * 0.04 * doLensGlint( uv, -1.1 * sp, 0.06, 0.8 );\n        c += f * col_star;\n    }\n    \n    return c;\n}\n\nCameraInfo doCamera( in vec3 pos, in vec3 dir )\n{\n    CameraInfo ci;\n    \n    vec3 ww = dir;\n    vec3 uu = normalize( cross( ww, world_up ) );\n    vec3 vv = normalize( cross( uu, ww ) );\n    mat3 m = mat3( uu, vv, ww );\n    mat3 mInv = mat3( uu.x, vv.x, ww.x,\n                      uu.y, vv.y, ww.y,\n                      uu.z, vv.z, ww.z );\n    \n    ci.pos = pos;\n    ci.dir = dir;\n    ci.m = m;\n    ci.mInv = mInv;\n    \n    return ci;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = gl_FragCoord.xy \/ iResolution.xy - 0.5;\n    uv.x *= iResolution.x \/ iResolution.y;\n    \n    vec2 m = iMouse.xy \/ iResolution.xy;\n    \n    \/\/ camera default movement\n    float cx = cos( 0.1 * iGlobalTime + 3.55 );\n    float sx = sin( 0.1 * iGlobalTime + 3.55 );\n    float cy = 0.;\n    \n    \/\/ camera mouse movement\n    if( iMouse.z > 0. )\n    {\n        cx = cos( 10. * m.x );\n        sx = sin( 10. * m.x );\n        cy = cos( 3.2 * m.y );\n    }\n    \n    \/\/ camera position\/direction\n    vec3 camPos = 2. * vec3( cx - sx, cy, sx + cx );\n    vec3 camDir = normalize( -camPos );\n\n    \/\/ render scene\n    vec3 c = render( uv, doCamera( camPos, camDir ) );\n    \/\/vec3 c = vec3( distort( map( uv ) ) );\n    \/\/vec3 c = vec3( fbm( map( uv ), iGlobalTime ) );\n    \n    \/\/ gamma correction\n    c = pow( c, vec3( 0.4545 ) );\n    \n    fragColor = vec4( c, 1.0 );\n}\n","name":"","description":"","type":"image"}]}}