{"Shader":{"ver":"0.1","info":{"id":"4sB3D1","date":"1386834275","viewed":4416,"name":"Lanterns","username":"iq","description":"Another example of using a 2D grid to accelerate raytracing (of procedural content in this case). The lighting is shadowless this time, that's why it's fast. The ambient occlusion is half-procedural, half-analytical.","likes":41,"published":3,"flags":0,"tags":["procedural","3d","raytracing","grid"],"hasliked":0},"renderpass":[{"inputs":[{"id":9,"src":"\/presets\/tex08.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Another example of using a 2D grid to accelerate raytracing (of procedural content in \n\/\/ this case). The lighting is shadowless this time, that's why it's fast. The ambient \n\/\/ occlusion is half-procedural, half-analytical.\n\t\n\/\/ For information on analytical ambient occlusion from spheres, see here:\n\/\/ http:\/\/www.iquilezles.org\/www\/articles\/sphereao\/sphereao.htm\n\n#define VIS_SAMPLES 6\n\nfloat hash1( float n ) { return fract(43758.5453123*sin(n)); }\nfloat hash1( vec2  n ) { return fract(43758.5453123*sin(dot(n,vec2(1.0,113.0)))); }\nvec2  hash2( float n ) { return fract(43758.5453123*sin(vec2(n,n+1.0))); }\nvec3  hash3( vec2  n ) { return fract(43758.5453123*sin(dot(n,vec2(1.0,113.0))+vec3(0.0,1.0,2.0))); }\nvec4  hash4( vec2  n ) { return fract(43758.5453123*sin(dot(n,vec2(1.0,113.0))+vec4(0.0,1.0,2.0,3.0))); }\n\n\/\/------------------------------------------------------------\n\nvec4 makeSphere( vec2 pos )\n{\n\tvec3  rr = hash3(pos);\n\tfloat ha = 0.2 + 1.3*rr.z;\n\tvec2  oo = 0.5 + 0.3*(-1.0 + 2.0*rr.xy);\n\tvec3  ce = vec3( pos.x+oo.x, ha, pos.y+oo.y );\n\tfloat ra = (0.5+0.5*rr.z)*min( min(oo.x,1.0-oo.x), min(oo.y,1.0-oo.y) );\nra *= 0.85+0.15*sin( 1.5*iGlobalTime + hash1(pos)*130.0 );\n\t\n\tce.y += 0.3*smoothstep( 0.995, 0.996, sin(0.015*iGlobalTime+100.0*hash1(hash1(pos))) );\n\t\n\treturn vec4( ce, ra );\n}\n\nvec3 palette( float id )\n{\n\treturn 0.5 + 0.5*sin( 2.0*id + 1.3 + vec3(0.0,1.0,2.0) );\n}\n\nvec3 makeColor( in vec2 p )\n{\n    float id  = hash1( p );\n    return palette( id );\n}\n\nvec3 makeEmission( in vec2 p )\n{\n    float id  = hash1( p );\n    vec3 mate =palette( id );\n\treturn mate * smoothstep( 0.995, 0.998, sin(0.015*iGlobalTime+100.0*hash1(id)) );\n}\n\n\/\/------------------------------------------------------------\n\n\nvec4 castRay( in vec3 ro, in vec3 rd )\n{\n\tvec2 pos = floor(ro.xz);\n\tvec2 ri = 1.0\/rd.xz;\n\tvec2 rs = sign(rd.xz);\n\tvec2 ris = ri*rs;\n\tvec2 dis = (pos-ro.xz+ 0.5 + rs*0.5) * ri;\n\t\n\tvec4 res = vec4( -1.0, 0.0, 0.0, 0.0 );\n\n    \/\/ traverse regular grid (in 2D)\n\tfor( int i=0; i<24; i++ ) \n\t{\n\t\tif( res.x>0.0 ) continue;\n\t\t\n        \/\/ intersect sphere\n\t\tvec4  sph = makeSphere( pos );\n\t\t\t\n\t\tvec3  rc = ro - sph.xyz;\n\t\tfloat b = dot( rd, rc );\n\t\tfloat c = dot( rc, rc ) - sph.w*sph.w;\n\t\tfloat h = b*b - c;\n\t\tif( h>0.0 )\n\t\t{\n\t\t\tfloat s = -b - sqrt(h);\n\t\t\tres = vec4( s, 0.0, pos );\n\t\t}\n        else\n\t\t{\n            float a = dot( rd.xz, rd.xz );\n            b = dot( rc.xz, rd.xz );\n            c = dot( rc.xz, rc.xz ) - min(0.25*sph.w*sph.w,0.005);\n            h = b*b - a*c;\n            if( h>=0.0 )\n            {\n                \/\/ cylinder\t\t\t\n                float s = (-b - sqrt( h ))\/a;\n                if( s>0.0 && (ro.y+s*rd.y)<sph.y )\n                {\n                    res = vec4( s, 1.0, pos );\n                }\n            }\n\t\t}\n\t\t\t\n        \/\/ step to next cell\t\t\n\t\tvec2 mm = step( dis.xy, dis.yx ); \n\t\tdis += mm*ris;\n        pos += mm*rs;\n\t}\n\n\treturn res;\n}\n\n\n\nvec3 calcNormal( in vec3 pos, in float ic )\n{\n\tif( ic>1.5 ) return vec3(0.0,1.0,0.0);\n\treturn normalize(pos*vec3(1.0,1.0-ic,1.0));\n}\n\nfloat occSphere( in vec4 sph, in vec3 pos, in vec3 nor )\n{\n    vec3 di = sph.xyz - pos;\n    float l = length(di);\n    return 1.0 - max(0.0,dot(nor,di\/l))*sph.w*sph.w\/(l*l); \n}\n\nfloat emmSphere( in vec4 sph, in vec3 pos, in vec3 nor )\n{\n    vec3 di = sph.xyz - pos;\n    float l = length(di);\n    float at = 1.0-smoothstep(0.5,2.0,l);\n\treturn at * pow(max(0.0,0.5+0.5*dot(nor,di\/l)),2.0)*sph.w*sph.w\/(l*l); \n}\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec4 x = texture2D( sam, p.yz );\n\tvec4 y = texture2D( sam, p.zx );\n\tvec4 z = texture2D( sam, p.xy );\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\nvec3 cameraPath( float t )\n{\n    \/\/ procedural path\t\n    vec2 p  = 100.0*sin( 0.02*t*vec2(1.2,1.0) + vec2(0.1,0.9) );\n\t     p +=  50.0*sin( 0.04*t*vec2(1.1,1.3) + vec2(1.0,4.5) );\n\tfloat y = 3.5 + 1.5*sin(0.1*t);\n\n\treturn vec3( p.x, y, p.y );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ inputs\t\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n\t\n    vec2 mo = iMouse.xy \/ iResolution.xy;\n    if( iMouse.w<=0.00001 ) mo=vec2(0.0);\n\t\n\t\n\t\/\/ montecarlo\t\n\tvec3 tot = vec3(0.0);\n    #if VIS_SAMPLES<2\n\tint a = 0;\n\t{\n        vec2 p = -1.0 + 2.0*(fragCoord.xy) \/ iResolution.xy;\n        p.x *= iResolution.x\/ iResolution.y;\n        float time = 0.3*iGlobalTime + 50.0*mo.x;\n    #else\n\tfor( int a=0; a<VIS_SAMPLES; a++ )\n\t{\n\t\tvec4 rr = texture2D( iChannel1, (fragCoord.xy+floor(256.0*hash2(float(a))))\/iChannelResolution[1].xy );\n        vec2 p = -1.0 + 2.0*(fragCoord.xy+rr.xz) \/ iResolution.xy;\n        p.x *= iResolution.x\/ iResolution.y;\n        float time = 0.3*(iGlobalTime + 1.0*(0.5\/24.0)*rr.w) + 50.0*mo.x;\n    #endif\t\n\n\t\t\/\/ camera\n        vec3  ro = cameraPath( time );\n        vec3  ta = cameraPath( time*2.0+15.0 );\n\t\tta = ro + normalize(ta-ro);\n\t\tta.y = ro.y - 0.4;\n\t\t\n        float cr = -0.2*cos(0.1*time);\n\t\n        \/\/ build ray\n        vec3 ww = normalize( ta - ro);\n        vec3 uu = normalize(cross( vec3(sin(cr),cos(cr),0.0), ww ));\n        vec3 vv = normalize(cross(ww,uu));\n        float r2 = p.x*p.x*0.32 + p.y*p.y;\n        p *= (7.0-sqrt(37.5-11.5*r2))\/(r2+1.0);\n        vec3 rd = normalize( p.x*uu + p.y*vv + 3.0*ww );\n\n        \/\/ dof\n        #if VIS_SAMPLES>2\n\t\tfloat fft = (ro.y*2.0+0.0)\/dot(rd,ww);\n        vec3 fp = ro + rd * fft;\n\t\tvec2 bo = sqrt(rr.y)*vec2(cos(6.2831*rr.w),sin(6.2831*rr.w));\n        ro += (uu*bo.x + vv*bo.y)*0.005*fft;\n        rd = normalize( fp - ro );\n        #endif\n\n\n        \/\/ background color\t\n\t\tvec3 bgcol = vec3(0.0);\n\n        vec3 col = bgcol;\n\t\t\n\t\n        \/\/ raytrace top bounding plane\n\t\tfloat tp = (2.3-ro.y)\/rd.y;\n\t\tif( tp>0.0 ) ro = ro + rd*tp;\n\n        \/\/ trace linterns\t\t\n\t\tvec4 res  = castRay(  ro, rd );\n\t\t\t\n\t\tfloat tp2 = (0.0-ro.y)\/rd.y;\n\t\tvec4 res2 = vec4(tp2,2.0,floor(ro.xz+tp2*rd.xz));\n\t\tif( res.x<0.0 ) res = res2; else if( tp2<res.x ) res = res2;\n\n\t\t\t\n\t\tfloat t = res.x;\n\t\tvec2 vos = res.zw;\n\t\tif( t>0.0 )\n\t\t{\n\t\t\tvec3  pos = ro + rd*t;\n\t\t\tfloat id  = hash1( vos );\n\t\t\t\t\n\t\t\tvec4 sph = makeSphere( vos );\n\t\t\t\t\n\t\t\tvec3 rpos = pos-sph.xyz;\n\t\n\t\t\tvec3  nor = calcNormal( rpos, res.y );\n\n            \/\/ material\t\t\t\n\t\t\tvec3 mate = makeColor( vos );\n\t\t\tif( res.y>1.5 ) mate=vec3(0.15);\n\t\t\tmate *= 0.5 + 1.5*pow(texcube( iChannel0, pos, nor ).x, 1.5 );\n\t\t\t\n            \/\/ procedural occlusion\n\t\t\tfloat occ = (0.5+0.5*nor.y);\n\t\t\tif( res.y<1.5) \n\t\t\t{\n\t\t\t\tocc*= 0.3+0.7*clamp( pos.y\/.24, 0.0, 1.0 );\n\t\t\t\tif( res.y>0.5 )occ *= 0.6+0.5*clamp( -(pos.y-(sph.y-sph.w))*7.0, 0.0, 1.0 );\n\t\t\t\t\n\t\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tocc *= 0.5 + 0.5*smoothstep(0.0,0.3, length(rpos.xz) );\n\t\t\t\tocc *= 0.5;\n\t\t\t}\n            \/\/ analytic occlusion\n\t\t\tfloat nocc = 1.0;\n\t\t\tnocc *= occSphere( makeSphere(vos+vec2( 1.0, 0.0)), pos, nor );\n\t\t\tnocc *= occSphere( makeSphere(vos+vec2(-1.0, 0.0)), pos, nor );\n\t\t\tnocc *= occSphere( makeSphere(vos+vec2( 0.0, 1.0)), pos, nor );\n            nocc *= occSphere( makeSphere(vos+vec2( 0.0,-1.0)), pos, nor );\n\t\t\tif( res.y>1.5 ) nocc *= occSphere( makeSphere(vos+vec2( 0.0,0.0)), pos, nor );\n            occ *= nocc*nocc;\n \n            \/\/ ambient and emmision\t\t\t\n            vec3 amb = vec3(0.015);\n            vec3 emm = 1.5*makeEmission(vos)*step(res.y,1.5);\n\t\t\t\n            \/\/ direct lichting\t\t\t\n            vec3 dir = vec3(0.0);\n            float ia = 20.0;\t\t\n\t\t\tdir += ia*emmSphere( makeSphere(vos+vec2( 1.0, 0.0)), pos, nor )*makeEmission(vos+vec2( 1.0, 0.0));\n            dir += ia*emmSphere( makeSphere(vos+vec2(-1.0, 0.0)), pos, nor )*makeEmission(vos+vec2(-1.0, 0.0));\n            dir += ia*emmSphere( makeSphere(vos+vec2( 0.0, 1.0)), pos, nor )*makeEmission(vos+vec2( 0.0, 1.0));\n            dir += ia*emmSphere( makeSphere(vos+vec2( 0.0,-1.0)), pos, nor )*makeEmission(vos+vec2( 0.0,-1.0));\n            dir += ia*emmSphere( makeSphere(vos+vec2( 1.0, 1.0)), pos, nor )*makeEmission(vos+vec2( 1.0, 1.0));\n            dir += ia*emmSphere( makeSphere(vos+vec2(-1.0, 1.0)), pos, nor )*makeEmission(vos+vec2(-1.0, 1.0));\n            dir += ia*emmSphere( makeSphere(vos+vec2( 1.0,-1.0)), pos, nor )*makeEmission(vos+vec2( 1.0,-1.0));\n            dir += ia*emmSphere( makeSphere(vos+vec2(-1.0,-1.0)), pos, nor )*makeEmission(vos+vec2(-1.0,-1.0));\n            dir += ia*emmSphere( makeSphere(vos+vec2( 0.0, 0.0)), pos, nor )*makeEmission(vos+vec2( 0.0, 0.0));\n\n            \/\/ lighitng\t\t\t\n            vec3 lin = vec3(0.0);\t\t\t\t\n            lin += emm;\n            lin += amb*occ;\n            lin += dir*occ;\n            lin += (amb*0.2+emm+dir) * 40.0 * pow( clamp( 1.0+dot(rd,nor), 0.0, 1.0), 2.0 )*occ*mate;\n\n            if( res.y<1.5 ) lin *= clamp(pos.y,0.0,1.0);\n\t\t\t\n            col = mate * lin;\n\n            \/\/ fog\t\t\t\n\t\t\tcol *= exp(-0.005*t*t);\n        }\n\t\t\n        col = clamp(col,0.0,1.0);\n\t\ttot += col;\n\t}\n\ttot \/= float(VIS_SAMPLES);\n\n\ttot = pow( clamp(tot,0.0,1.0), vec3(0.44) );\n\t\t\n\tfragColor = vec4( tot, 1.0 );\n}","name":"","description":"","type":"image"}]}}