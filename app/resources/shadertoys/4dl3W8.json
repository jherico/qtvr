{"Shader":{"ver":"0.1","info":{"id":"4dl3W8","date":"1369089194","viewed":2258,"name":"Phoning Home","username":"movAX13h","description":"E.T. The Extra Terrestrial finally phoning home. Mouse enabled. Background \"warp speed\" shader by Dave Hoskins.","likes":31,"published":3,"flags":0,"tags":["3d","raymarching","mouse"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ \"phoning home\" fragment shader by movAX13h, May 2013\n\n\/\/ A fragment shader heavily inspired by T-Shirt artwork (I dont know the artist):\n\/\/ http:\/\/empoz.com\/shopping\/images\/medium\/mpd\/GP019-BLK-Funny-ET-Telephone-tee-shirt_MED.jpg\n\n\/\/ This was my first raymarching shader.\n\n\/\/ Using some of iqs distance functions.\n\/\/ Fragments of code borrowed from all over ShaderToy.\n\n\/\/ There is no real lighting in this scene, transparency and illumination is\n\/\/ based on the distance of the ray inside the main box and is not accurate because\n\/\/ the value is incremented inside the marcher which does not march the same number\n\/\/ of steps for all pixels. This effect fits the flat style of E.T and the telephone, so I kept it.\n\/\/ Anyways, by commenting the following line, everything \"light\" is off.\n#define ILLUMINATION\n\n\/\/ Uncomment the following define to enable Dave Hoskins' \"Warp speed\" shader \n\/\/ in the background (https:\/\/www.shadertoy.com\/view\/Msl3WH)\n\/\/ Daves shader is based on Kalis \"Cosmos\" shader (https:\/\/www.shadertoy.com\/view\/MssGD8)\n\/\/ I liked it so much, I had to see how it combines :)\n#define WARP_SHADER\n\n\nfloat udBox( vec3 p, vec3 b ) \n{\t\n\treturn length(max(abs(p)-b,0.0)); \n}\n\nfloat sdBox( vec3 p, vec3 b ) \n{\t\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdSegment(vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\treturn length(pa - ba*h) - r;\n}\n\nfloat time;\n\nvec4 scene(vec3 p, inout float t, inout vec3 tcol)\n{\n\tfloat d, d1, d2, d3, d4, d5, f, v;\n\t\n\t#ifdef ILLUMINATION\n\tvec3 col = vec3(0.06, 0.06, 0.16);\n\t#else\n    vec3 col = vec3(1.0);\n\t#endif\n\t\n\t\/\/ cell\n\td1 = sdBox(p, vec3(0.6, 1.2, 0.5));\n\tv = sdBox(p-vec3(0.0, 0.01, 0.0), vec3(0.58, 1.1, 0.48)); \/\/ along y\n\td3 = sdBox(p-vec3(0.0, 0.05, 0.0), vec3(0.58, 0.97, 0.7)); \/\/ along z\n\td4 = sdBox(p-vec3(0.0, 0.05, 0.0), vec3(0.7, 0.97, 0.48)); \/\/ along x\n\td = max(-d4, max(-d3, max(-v, d1)));\n\t\n\t\/\/ sash bars\t\n\td = min(d, udBox(p-vec3(0.0, -0.45, 0.48), vec3(0.58, 0.01, 0.01)));\n\td = min(d, udBox(p-vec3(0.0, 0.05, 0.48), vec3(0.58, 0.01, 0.01)));\n\td = min(d, udBox(p-vec3(0.0, 0.55, 0.48), vec3(0.58, 0.01, 0.01)));\n\t\n\td = min(d, udBox(p-vec3(0.0, -0.45, -0.48), vec3(0.58, 0.01, 0.01)));\n\td = min(d, udBox(p-vec3(0.0, 0.05, -0.48), vec3(0.58, 0.01, 0.01)));\n\td = min(d, udBox(p-vec3(0.0, 0.55, -0.48), vec3(0.58, 0.01, 0.01)));\n\t\n\td = min(d, udBox(p-vec3(0.58, 0.05, 0.0), vec3(0.01, 0.01, 0.48)));\n\td = min(d, udBox(p-vec3(0.58, 0.02, 0.0), vec3(0.01, 1.0, 0.01)));\n\n\t\/\/ inner life\n\tif (v < 0.0) \n\t{\n\t\t\/\/ phone & handset\n\t\t\/\/d1 = 100.0;\n\t\t\/\/d2 = 100.0;\n\t\td1 = udRoundBox(p-vec3(-0.493, 0.1, 0.22), vec3(0.05, 0.3, 0.16), 0.02);\n\t\td2 = udRoundBox(p-vec3(-0.475, 0.2, 0.22), vec3(0.07, 0.26, 0.16), 0.02);\n\t\td3 = sdSegment(p, vec3(0.03 , -0.1 , 0.2), vec3(-0.1 , 0.02 , 0.16), 0.03);\n\t\td4 = udRoundBox(p-vec3(0.03 , -0.14 , 0.2), vec3(0.01, 0.01, 0.01), 0.04);\n\t\td5 = udRoundBox(p-vec3(-0.12 , 0.0 , 0.16), vec3(0.01, 0.01, 0.01), 0.04);\n\t\td = min(d, min(min(min(min(d5,d4),d3),d2),d1));\n\t\t\n\t\t\/\/ cable\n\t\tif (abs(p.x+0.16) < 0.22) \n\t\t{\n\t\t\td = min(d, sdSegment(p, vec3(p.x     , -0.23 + sin( p.x     *12.0)*0.2, 0.2), \n\t\t\t\t\t\t \t\t    vec3(p.x-0.1 , -0.23 + sin((p.x-0.1)*12.0)*0.2, 0.2), 0.01));\n\t\t}\n\t\t\n\t\t\/\/ E.T.\n\t\t\n\t\t\/\/ head\t\n\t\td1 = sdSegment(p, vec3(0.11  , 0.42 , 0.12), vec3(0.11  , 0.43 , -0.12), 0.1); \/\/ eyes\n\t\td2 = sdSegment(p, vec3(0.05  , 0.34 , 0.0), vec3(0.38 , 0.3 ,  0.0), 0.1); \/\/ mouth area\n\t\td3 = sdSegment(p, vec3(0.17 , 0.44 , 0.0),  vec3(0.38 , 0.3 ,  0.0), 0.13); \/\/ skull\n\t\td4 = sdSegment(p, vec3(0.35  , 0.31 , 0.0),  vec3(0.38 , -0.2  ,  0.0), 0.06); \/\/ neck\n\t\td = min(d, min(min(min(d4,d3),d2),d1));\t\n\t\t\n\t\t\/\/ pointing arm\/hand\n\t\td1 = sdSegment(p, vec3( 0.2 , -0.18 , -0.18),  vec3(-0.08  , -0.04 , 0.0), 0.05);\n\t\td2 = sdSegment(p, vec3(-0.1 , -0.04  ,  0.0), vec3(-0.13 , 0.29 , 0.11), 0.03);\n\t\td = min(d, min(d2,d1));\n\t\t\n\t\t\/\/ fingers\n\t\td1 = sdSegment(p, vec3(-0.13 , 0.32 , 0.11), vec3(-0.4  , 0.5+p.x*0.3 , 0.14), 0.012); \/\/ pointing\n\t\td2 = sdSegment(p, vec3(-0.12 , 0.31 , 0.12), vec3(-0.24 , 0.33  , 0.1), 0.014); \/\/ angled\n\t\td3 = sdSegment(p, vec3(-0.25 , 0.33  , 0.1), vec3(-0.26 , 0.28  , 0.1), 0.012);\n\t\td4 = sdSegment(p, vec3(-0.13 , 0.31 , 0.13), vec3(-0.25 , 0.3 , 0.15), 0.014); \/\/ thumb\n\t\td = min(d, min(min(min(d4,d3),d2),d1));\t\n\t\t\n\t\t\/\/ other arm\n\t\td1 = sdSegment(p, vec3(0.2, -0.14, 0.18), vec3(0.21, -0.3, 0.2), 0.05);\n\t\td2 = sdSegment(p, vec3(0.21, -0.3, 0.2), vec3(0.03, -0.1, 0.2), 0.04);\n\t\td = min(d, min(d2, d1));\n\t\t\n\t\t\/\/ body & legs\n\t\td1 = sdSegment(p, vec3(0.3, -0.22, 0.0), vec3(0.26, -0.76, 0.1), 0.23);\n\t\td2 = sdSegment(p, vec3(0.3, -0.22, 0.0), vec3(0.26, -0.76, -0.1), 0.23);\n\t\td3 = sdSegment(p, vec3(0.3, -0.22, 0.0), vec3(0.18, -0.72, 0.0), 0.23);\n\t\td4 = sdSegment(p, vec3(0.27, -0.72, 0.16), vec3(0.28, -1.0, 0.14), 0.1);\n\t\td5 = sdSegment(p, vec3(0.28, -0.72, -0.16), vec3(0.28, -1.0, -0.14), 0.1);\n\t\td = min(d, min(min(min(min(d5,d4),d3),d2),d1));\n\t\n\t\t\/\/ finger tip light\n\t\tfloat blink = mod(floor(time*10.0), 2.0);\n\t\tf = length(vec3(-0.4, 0.38, 0.14)-p);\n\t\ttcol += blink*0.04*smoothstep(0.2, 0.0, f)*vec3(0.2, 0.08, 0.0);\n\t\ttcol = mix(tcol, vec3(0.9, 0.08, 0.0), blink*smoothstep(0.06, 0.0, f));\n\t\tt += blink*0.1*smoothstep(0.2, 0.0, f);\n\t\t\n\t\t\/\/ glass\n\t\tt = max(0.2, t + 0.04 + 0.02*sin(p.y*5.0+time));\n\t\ttcol += smoothstep(0.1, 1.2, p.y*0.3)*(1.0-tcol);\n\t\t\n\t\t\/\/ flies\n\t\tf = length(0.3*vec3(sin(time*0.2+66.0), 3.2+sin(time*0.7)*0.5, cos(time*0.6))-p);\n\t\td = min(d, f - 0.01);\n\t\ttcol += step(f, 0.01)*0.01;\n\t\t\n\t\tf = length(0.4*vec3(sin(-time*0.4), 3.3+sin(-t*0.5)*cos(t+100.0), sin(time*0.34+32.0))-p);\n\t\td = min(d, f - 0.006);\n\t\ttcol += step(f, 0.01)*0.01;\n\t\t\n\t\tf = length(0.36*vec3(sin(time*0.6), 3.4+sin(time*0.5)*sin(-time*0.2), sin(-time*0.3))-p);\n\t\td = min(d, f - 0.006);\n\t\ttcol += step(f, 0.01)*0.01;\n\n\t\t\/\/ swirl\n\t\t\/*\n\t\td1 = 0.1*sin((p.y+time)*8.0);\n\t\td2 = 0.1*cos((p.y+time)*8.0);\n\t\td3 = sdSegment(p, vec3(d1 , mod(time*6.0, 8.0) - 4.0, d2),  \n\t\t\t\t\t\t  vec3(d1 , mod(time*6.0, 8.0) - 2.0, d2), 0.47);\n\t\t\n\t\ttcol = mix(tcol, vec3(1.0, 1.0, 1.0), 1.0-smoothstep(-0.5,0.0, d3));\n\t\tif (d3 < 0.0) t += 0.1;\n\t\t*\/\n\t}\t\n\t\n\treturn vec4(col, d);\n}\n\nvec3 Dave_Hoskins_Warp_Shader(in vec2 fragCoord)\n{\n\tfloat s = 0.0, v = 0.0;\n\tvec2 uv = (fragCoord.xy \/ iResolution.xy) * 2.0 - 1.0;\n\tfloat t = time*0.005;\n\tuv.x = (uv.x * iResolution.x \/ iResolution.y) + sin(t)*.5;\n\tfloat si = sin(t+2.17); \/\/ ...Squiffy rotation matrix!\n\tfloat co = cos(t);\n\tuv *= mat2(co, si, -si, co);\n\tvec3 col = vec3(0.0);\n\tfor (int r = 0; r < 100; r++) \n\t{\n\t\tvec3 p= vec3(0.3, 0.2, floor(time) * 0.0008) + s * vec3(uv, 0.143);\n\t\tp.z = mod(p.z,2.0);\n\t\tfor (int i=0; i < 10; i++) p = abs(p*2.04) \/ dot(p, p) - 0.75;\n\t\tv += length(p*p)*smoothstep(0.0, 0.5, 0.9 - s) * .002;\n\t\tcol +=  vec3(v * 0.8, 1.1 - s * 0.5, .7 + v * 0.5) * v * 0.013;\n\t\ts += .01;\n\t}\t\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\t#ifdef WARP_SHADER\n\ttime = (iGlobalTime+2.4) * 60.0;\n\tvec3 col = Dave_Hoskins_Warp_Shader(fragCoord);\n\t#endif\n\t\n\ttime = iGlobalTime + 7.3;\n    vec2 pos = (fragCoord.xy*2.0 - iResolution.xy) \/ iResolution.y;\n\t\n    float focus = 3.0;\n    float far = 9.0;\n\t\n\tfloat atime = time*0.4;\n\tvec3 cp = vec3(2.0+sin(atime)*3.0, 0.6+sin(atime)*0.6, 5.0+cos(atime)); \/\/ anim perspective\n  \t\/\/vec3 cp = vec3(sin(iGlobalTime)*6.0, .0, cos(iGlobalTime)*6.0);\n  \t\/\/vec3 cp = vec3(sin(iGlobalTime)*4.0, sin(iGlobalTime*2.0)*0.7, cos(iGlobalTime)*7.0); \n\t\n\tif (iMouse.z > 0.0)\n\t{\n\t\tfloat d = (iResolution.y-iMouse.y)*0.01+3.0;\n\t\tcp = vec3(sin(iMouse.x*0.01)*d, .0, cos(iMouse.x*0.01)*d);\n\t}\n\t\n    vec3 ct = vec3(0.0, 0.0, 0.0);\n   \tvec3 cd = normalize(ct-cp);\n    vec3 cu  = vec3(sin(time), 1.0, cos(time));\n    vec3 cs = cross(cd, cu);\n    vec3 dir = normalize(cs*pos.x + cu*pos.y + cd*focus);\n\t\n    vec3 ray = cp;\n\tfloat dist = 0.0;\n    vec4 s;\n\t\n\tfloat t = 0.06;\n\tvec3 tcol = vec3(0.0, 0.5, 0.7);\n\t\n    for(int i=0; i < 40; i++) \n\t{\n        s = scene(ray, t, tcol);\n\t\t\n        dist += s.w;\n        ray += dir * s.w;\n\t\t\n        if(s.w < 0.01) break;\n\t\t\n        if(dist > far) \n\t\t{ \n\t\t\tdist = far; \n\t\t\tbreak; \n\t\t}\n    }\n\t\n\t#ifndef ILLUMINATION\n\tt = 0.0;\n\t#endif\n\t\n    float b = 1.0 - dist\/far;\n\tvec3 c = mix(vec3(b * s.rgb), tcol, t);\n\t\n\t#ifdef WARP_SHADER\n\tcol = mix(c, col, smoothstep(0.5, 0.99, min(0.7-b, 1.0-t))); \/\/ mix shaders\n    fragColor = vec4(col, 1.0);\n\t#else\n\tfragColor = vec4(c, 1.0);\n\t#endif\n}\n","name":"","description":"","type":"image"}]}}