{"Shader":{"ver":"0.1","info":{"id":"ltjXzd","date":"1446079423","viewed":746,"name":"Cave Entrance","username":"Shane","description":"Simple raymarching exercise, inspired by IQ's parallax \"Cave\" experiment.","likes":27,"published":3,"flags":0,"tags":["raymarching","bump","cave","rock"],"hasliked":0},"renderpass":[{"inputs":[{"id":2,"src":"\/presets\/tex01.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/*\n    Cave Entrance\n    -------------\n\n\tRaymarched cave entrance flyby, at dusk. This was inspired by IQ's \"Cave\" shader. I love\n\teverything about that example. If you haven't seen it, the link is here:\n\n    Cave: iq    \n    https:\/\/www.shadertoy.com\/view\/4s2Xzc\n\n\tAnyway, this particular version has a different surface, and was produced using a different \n\ttechnique, namely raymarching. It's also bumped, occluded, etc. However, it's essentially \n\tthe\tsame concept.\n\n\tBy the way, I made a trimmed down parallax textured version, just for the fun of it. The\n\tprivate link is here:\n\t\n\tParallax Cave Entrance - Shane\n\thttps:\/\/www.shadertoy.com\/view\/lt2Xzd\n    \n\n\tRelated examples:\n\n    Retro Parallax: TekF\n    https:\/\/www.shadertoy.com\/view\/4sSGD1\n\n\tDeform - fly: iq\n\thttps:\/\/www.shadertoy.com\/view\/XsX3Rn\n\n*\/\n\n#define RMITERATIONS 56\n#define PRECISION 0.004\n#define FAR 32.\n#define PI 3.14159265358979\n\n\/\/#define SHOW_HEATMAP\n\n\/\/ Grey scale.\nfloat getGrey(vec3 p){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\n\n\/\/ 2x2 matrix rotation.\nmat2 rot2( float a ){ float c = cos(a), s = sin(a);\treturn mat2( c, -s,\ts, c ); }\n\n\/\/ Simplified vec3-to-vec3 hash function.\nvec3 hash33(vec3 p){\n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n\/\/ Tri-Planar blending function. Based on an old Nvidia writeup:\n\/\/ GPU Gems 3 - Ryan Geiss: http:\/\/http.developer.nvidia.com\/GPUGems3\/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); \/\/ n = max(abs(n), 0.001), etc.\n    n \/= (n.x + n.y + n.z );  \n    \n    \/\/ Note the \"1-tex.\" That's just for this particular example. Normally, the \"1\" isn't there.\n\treturn 1.-(texture2D(tex, p.yz)*n.x + texture2D(tex, p.zx)*n.y + texture2D(tex, p.xy)*n.z).xyz;\n}\n\n\/\/ The cobble stone, rocky slate surface... or whatever it's supposed to be. Not a lot of thought \n\/\/ was put into this. :)\n\/\/\n\/\/ Basically, mutate a couple of sinusoidal layers using the usual methods - Changes in frequency,\n\/\/ amplitude, feedback, etc. For the final layer, take a variation on the absolute value. The rest\n\/\/ was tweaking things until it looked right.\nfloat surfFunc(in vec3 p){\n\n    \/\/ Layer 1 - Amplitude, 1.\n    vec3 t = sin(p.yzx + cos(p.zxy+1.57\/2.));\n    float res = dot(t + 1., vec3(0.166));\n    p = p*2.5 + (t*0.5 - 0.5)*3.14159265; \/\/ Adding \"t\" gives a bit of curl.\n\n    \/\/ Layer 2 - Amplitude, 0.5.\n    t = sin(p.yzx + cos(p.zxy+1.57\/2.));\n    res += dot(t + 1., vec3(0.166))*0.5;\n    p = p*3.5 + (t*0.5 - 0.5)*3.14159265;\n\n    \/\/ Layer 3 - Amplitude, 0.15.\n    t = sin(p + cos(p+1.57\/2.));\n    res += (1.-abs(dot(t, vec3(0.333))))*0.15; \/\/ Take \"abs\" for rockiness.\n\t\n\t\/\/ Divide by the total amplitude.  \n\treturn (res\/1.65); \/\/ Range: [0, 1] \n\n}\n\n\nfloat map(vec3 p){\n \n     return 1.-abs(p.y) - (0.5-surfFunc(p))*1.5;\n \n}\n\n\/\/ Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\n   \n    const float eps = 0.001;\n    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x-eps, p.y, p.z), nor)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y-eps, p.z), nor)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z-eps), nor)));\n    \n    grad = (grad - getGrey(tex3D(tex,  p , nor)))\/eps; \n            \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n\/\/ Tetrahedral normal: I remember a similar version on \"Pouet.net\" years ago, but this one is courtesy of IQ.\nvec3 getNormal( in vec3 p ){\n\n    vec2 e = vec2(0.5773,-0.5773)*0.001;\n    return normalize( e.xyy*map(p+e.xyy ) + e.yyx*map(p+e.yyx ) + e.yxy*map(p+e.yxy ) + e.xxx*map(p+e.xxx ));\n}\n\n\/\/ Based on original by IQ.\nfloat calculateAO(vec3 p, vec3 n){\n\n    const float AO_SAMPLES = 5.0;\n    float r = 0.0, w = 1.0, d;\n    \n    for (float i=1.0; i<AO_SAMPLES+1.1; i++){\n        d = i\/AO_SAMPLES;\n        r += w*(d - map(p + n*d));\n        w *= 0.5;\n    }\n    \n    return 1.0-clamp(r,0.0,1.0);\n}\n\n\/\/ Cool curve function, by Shadertoy user, Nimitz.\n\/\/\n\/\/ I wonder if any of it relates back to the  discrete finite difference approximation to \n\/\/ the continuous Laplace differential operator? Either way, it gives you a scalar curvature\n\/\/ value for an object's signed distance function, which is pretty handy. I used it to do a \n\/\/ bit of fake, shadowy occlusion.\n\/\/\n\/\/ From an intuitive sense, the function returns a weighted difference between a surface \n\/\/ value and some surrounding values - arranged in a simplex tetrahedral fashion for minimal\n\/\/ calculations, I'm assuming. Almost common sense... almost. :)\n\/\/\n\/\/ Original usage (I think?) - Cheap curvature: https:\/\/www.shadertoy.com\/view\/Xts3WM\n\/\/ Other usage: Xyptonjtroz: https:\/\/www.shadertoy.com\/view\/4ts3z2\nfloat curve(in vec3 p, in float w){\n\n    vec2 e = vec2(-1., 1.)*w;\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return 0.125\/(w*w) *(t1 + t2 + t3 + t4 - 4.*map(p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\t\/\/ Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)\/iResolution.y;\n\t\n\t\/\/ Camera Setup.\n\tvec3 lookAt = vec3(iGlobalTime*4.+1., 0.0, iGlobalTime*2.+ 1.);  \/\/ \"Look At\" position.\n\tvec3 camPos = lookAt + vec3(.0, 0.1, -1.0); \/\/ Camera position, doubling as the ray origin.\n \n    \/\/ Light position. Set at a reasonable distance to the right and in front or the camera.\n    \/\/ Keeping it at a constant distance from the camera gives a slight distant-sun impression.\n    \/\/ By keeping it within a measurable distance, you can still receive a bit of a point light \n    \/\/ effect, which tends to look a little nicer when bumped... because of the changing angles, \n    \/\/ I guess. All of it is fake, of course, so feel free to swap in a directional light setup.\n \tvec3 lp = camPos + vec3(16.0, 0., 8.);\/\/ Put it a bit in front of the camera.\n\n    \/\/ Using the above to produce the unit ray-direction vector.\n    float FOV = PI\/2.; \/\/ FOV - Field of view.\n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n\n    \/\/ rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*cross(forward, right)); \/\/ Cross term is the \"up\" vector.\n\n\t\/\/ I always groan when I see convoluted lines like this. :) It's just a way to flip the camera 180 degrees about the \n\t\/\/ XY plane every now and again. The end term is a bit of camera tilt. There are probably other ways to get this done.\n\trd.xy *= rot2( smoothstep(0.3, 0.7, sin(iGlobalTime*0.1875 - 2.)*0.5+0.5)*3.14159 + sin(iGlobalTime*0.1875 -2.)*0.1 );\n\n\t\t\n    \/\/ Standard ray marching routine, with a couple of tiny tweaks. Note that PRECISION is multiplied by \"t.\" You'll see it \n    \/\/ around here and there. The idea is that you don't need as much precision as you get further away. Makes sense. Having \n    \/\/ said that, I'm always amazed at how well it can work in certain situations. The \"step\" business just varies the \n    \/\/ amount you jump by, depending on whether \"t\" is greater than or equal to 1. It's a weird tweak, but can be effective\n    \/\/ at times. \"Aiekick\" uses a variation on occasion.\n    \/\/\n    \/\/ By the way, if you're interested in optimizing raymarching routines, there's a lot of examples on this site. Shadertoy\n    \/\/ user \"huwb\" does some interesting stuff. His \"Raymarching as root finding,\" et al, is pretty cool. Nimitz's\n    \/\/ \"Log-Bisection Tracing\" example is also worth a look.\n\tfloat t = 0.0, dt = 0.0, itTotal = 1.;\n\t\n\tfor(int i=0; i<RMITERATIONS; i++){\n\t\tdt = map(camPos + rd*t);\n\t\tif(abs(dt)<PRECISION*t || t>FAR){ break; } \/\/ Break statement, and nothing else.\n\t\tt += dt*(0.75 + step(t, 1.)*0.25);\n\t\t#ifdef SHOW_HEATMAP\n\t\titTotal++; \/\/ Total iterations for the heat map, if used.\n\t\t#endif\n\t}\n\n\t\/\/ Initiate the scene color to black.\n\tvec3 sceneCol = vec3(0.);\n\t\n\t\/\/ The ray has effectively hit the surface, so light it up.\n\tif(t<FAR){\n\t\n\t    \/\/ Fudge to gain a little more accuracy. Not really necessary, and according to user BigWIngs,\n\t    \/\/ could cause inaccuracies at grazing angles, so comment it out if that's a concern. I like \n\t    \/\/ to live on the edge, so I'm leaving it in. :) BigWIngs's \"Dying Universe shader is pretty\n\t    \/\/ cool, by the way.\n\t    t += dt;\n    \t\n    \t\/\/ Surface position and surface normal.\n\t    vec3 sp = t * rd+camPos;\n\t    vec3 sn = getNormal(sp);\n        \n        \/\/ Texture scale factor.\n        const float tSize0 = 1.\/4.;\n\n\t    sn = doBumpMap(iChannel0, sp*tSize0, sn, 0.01);\n\n\t    \/\/ Ambient occlusion.\n\t    float ao = calculateAO(sp, sn);\n    \t\n    \t\/\/ Curvature - Nimitz.\n    \t\/\/ Cool for all sorts of things, but used for shading here.\n\t    float crv = clamp(curve(sp, 0.125)*0.5+0.5, .0, 1.);\n\t    \n    \t\/\/ Light direction vector.\n\t    vec3 ld = lp-sp;\n\n        \/\/ Distance from the lights to the surface point.\n\t    float distlpsp = max(length(ld), 0.001);\n    \t\n    \t\/\/ Normalize the light direction vector.\n\t    ld \/= distlpsp;\n\t    \n\t    \/\/ Light attenuation, based on the distance above. I've scaled down the distance before\n        \/\/ attenuating just to make the figures easier to work with.\n\t    distlpsp \/= 18.;\n\t    float atten = min(1.\/(1. + distlpsp*distlpsp*0.025), 1.);\n  \t\n    \t\/\/ Ambient light.\n\t    float ambience = 0.55;\n    \t\n    \t\/\/ Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n  \t\n    \t\/\/ Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 8.);\n\n        \n        \/\/ Obtaining the texel color. \n\t    vec3 texCol = tex3D(iChannel0, sp*tSize0, sn);\/\/*0.66+tex3D(texChannel0, sp.yzx*tSize0*2., sn)*0.34;\n\n    \t\n    \t\/\/ Darkening the crevices. Otherwise known as cheap, scientifically-incorrect shadowing.\t\n\t    float shading =  crv*0.5+0.5; \/\/1.-surfFunc(sp)*0.5;\/\/\/\/\n\t\n    \t\n    \t\/\/ Coloring and lighting the surface color.\n        sceneCol = texCol*(diff*vec3(1.0,0.56, 0.18) + ambience) + vec3(1.0, 0.5, 0.2)*spec*2.;\n        \n        \/\/ Green moss. Off the top of my head, so not paricularly well thought out. :)\n        \/\/\n\t    \/\/ Fresnel term. Good for giving a surface a bit of a reflective glow.\n        \/\/float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 1.); \n        \/\/\n        \/\/sceneCol = (1.-texCol)*(diff*0.25 + ambience*0.1) + fre*texCol.yzx*texCol.yzx + vec3(1.,0.5, 0.2)*spec*1.5;\n     \n        \/\/ Shading.\n        sceneCol *= shading*ao*atten;\n     \n\t\n\t}\n\t\n\tsceneCol = clamp(sceneCol, 0., 1.);\n\n    float fogAtten = 1.\/(1.+t*t*0.025);\n    sceneCol *= fogAtten;\n\t\n    \/\/ Alternative falloff.\n    \/\/float fogAtten = smoothstep(0., FAR\/2., t);\n\t\/\/sceneCol = mix(sceneCol, vec3(0), fogAtten);\n\t\n\t#ifdef SHOW_HEATMAP\n\tfloat heat = min(itTotal\/float(RMITERATIONS), 1.);\t\n\tconst float hLayers = 8.;\n\theat = floor(heat*(hLayers-0.001))\/(hLayers-1.);\n\tsceneCol = vec3(heat);\/\/vec3(min(heat*1.5, 1.), pow(heat, 2.5), pow(heat, 10.));\n\t#endif\n\t\n\t\n\t\n\tfragColor = vec4(sceneCol, 1.0);\n\t\n}\n","name":"","description":"","type":"image"}]}}