{"Shader":{"ver":"0.1","info":{"id":"XdGGzD","date":"1453427047","viewed":103,"name":"Volcanic planet","username":"BiiG","description":"sfsdfdsfds","likes":1,"published":3,"flags":0,"tags":["volcanolavaraymarching"],"hasliked":0},"renderpass":[{"inputs":[{"id":4,"src":"\/presets\/tex03.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":8,"src":"\/presets\/tex07.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/\n\/\/ Example implementation of a fast procedural noise\n\/\/ https:\/\/oneoverzerosite.wordpress.com\/2015\/12\/23\/procedural-noise-generation-in-a-pixel-shader\/\n\/\/\n\nfloat ComputeNoiseSS ( in vec2 fragCoord )\n{\n\tfloat seed = (fragCoord.x+0.5) * (fragCoord.y+1.0);\n    \n    \/\/ Compute 2 frequency perturbations\n    float noise = seed * (1.0-(1.0\/127.0));\t\t\t\/\/ 1st octave\n\tnoise *= fract ( noise * (1.0\/127.0) );\t\t\t\/\/ 2nd\n\tnoise = fract ( noise );\n\n    \/\/ Add some time update\n\treturn noise;\n}\n\nfloat DFSphere( in vec4 sphere, in vec3 point )\n{    \n    vec3 vDelta = point - sphere.xyz;\n    return length ( vDelta ) - sphere.w;      \n}\n\nfloat DFSphere( in vec4 sphere, in vec3 point, out vec3 normal )\n{    \n    vec3 vDelta = point - sphere.xyz;\n    normal = normalize(vDelta);    \n    return length ( vDelta ) - sphere.w;      \n}\n\nfloat DFPlane( in vec4 plane, in vec3 point, out vec3 normal )\n{\n    float dist = dot ( plane.xyz, point ) + plane.w;\n    \n    float att = max((1.0 - point.z\/40.0),0.0);\n    att = att*att;\n    dist -= sin(point.z*2.0)*0.3 * att;\n    dist += cos(point.x*3.5)*0.2 * att;\n           \n    return dist;      \n}\n\nvoid mainImage( out vec4 outColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    \n    vec4 sphere = vec4(2.0,2.0,5.0,3.0+sin(iGlobalTime*3.0)*0.051);\n    vec4 sphere2 = vec4(2.0,2.0,5.0,2.0+cos(iGlobalTime*5.0)*0.051);\n    \n    vec4 plane = vec4(0.0,1.0,-0.5,4.0);\n    plane.xyz = normalize(plane.xyz);\n    \n    vec4 pBackground = vec4(0.0,0.0,-1.0,20.0);\n    pBackground.xyz = normalize(pBackground.xyz);\n    \n    vec3 lightPos = vec3 ( 8.0, 5.0, 0.0 );    \n    \n    vec3 ray = vec3(uv*2.0-1.0,9.0);\n    ray = ray * vec3(16.0,9.0,1.0); \/\/ Aspect ratio\n    ray.x += sin(iGlobalTime*0.3)*5.0;\n    ray.y += cos(iGlobalTime*0.7)*3.0;\n    ray = normalize(ray);\n    \n    vec3 sum = vec3(0.0,0.0,0.0);    \n    const float nearPlane = 1.0;\n    const float farPlane  = 40.0;\n    \n    float rayStep = farPlane;\n    for (float i=nearPlane; i<farPlane; i += 0.2)\n    {\n        vec3 lightDir;\n        vec3 pos = ray * i;\n        float d;\n        vec3 normal;\n        float lRange = 40.0;\n        \n        d = DFSphere (sphere, pos, normal);\n        lightDir = normalize( lightPos - pos);        \n        \n        float l = max ( dot ( normal, lightDir ), 0.1 );\n        \n        float att = min ( length ( pos - lightPos ) \/ lRange, 1.0 );\n        att = 1.0 - att * att * att;\n                       \n        sum.r +=(d<0.0?(-d\/sphere.w*0.05):0.0)*5.0;        \n        \n        d = DFSphere (sphere2, pos, normal);\n        lightDir = normalize( lightPos - pos);        \n              \n\n        sum.rgb +=(d<0.0?(-d\/sphere.w*0.05):0.0)*vec3(0.8,0.9,0.3)*7.0;        \n               \n        d = DFPlane (plane,pos,normal);\n        l = max ( dot ( plane.xyz, lightDir ), 0.1 );      \n        \n       vec2 texuv = vec2(pos.x * 0.2+iGlobalTime*0.02,(pos.y+pos.z+iGlobalTime)*0.4);\n        texuv += vec2(sin(pos.z*0.1)+1.0,0.0);\n        \n       vec3 tex = texture2D(iChannel0,texuv ).rgb * vec3(2.0,1.0,0.3);\n       tex = tex * tex * tex + vec3(0.15,0.0,0.0);\n       if (tex.b<0.0002 ) tex *= tex.b*2000.0+0.05;\n       vec3 planeColor = (d<0.0?l*att:0.0)*tex*4.0;\n       \n       sum.rgb += planeColor;\n        \n        if (planeColor.r>0.0) break;\n        \n        d = DFPlane (pBackground,pos,normal);\n             \n       planeColor = (d<0.0?-d:0.0)*vec3(0.0,0.0001,0.00011)*5.0;\n       \n       sum.rgb += planeColor;\n        \n       if (planeColor.r>0.0) break;\n    }\n    \n    \n    if (fragCoord.y>iResolution.y*0.66)\n    {\n        fragCoord = floor(fragCoord\/2.0)*2.0;   \n        \n        float lum = max(ComputeNoiseSS(fragCoord)-0.99,0.0)*(sin((iGlobalTime*0.5+fragCoord.y)*10.0+fragCoord.x)+2.0)*20.0;\n      \tsum.rgb += lum*lum;\n    }\n\n\toutColor = vec4(sum,1.0);\n}","name":"","description":"","type":"image"}]}}