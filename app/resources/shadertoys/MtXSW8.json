{"Shader":{"ver":"0.1","info":{"id":"MtXSW8","date":"1436224821","viewed":742,"name":"polite asleepening","username":"Sebbert","description":"Very fast party-coded remix of Gargaj - Rude Awakening (Chaos Theory by Conspiracy).<br\/>Graphics by mu6k and tapped <img src=\"\/img\/emoticonHappy.png\"\/>","likes":7,"published":3,"flags":8,"tags":["solskogen2015"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\nfloat t = iGlobalTime;\n\nconst float PI = 3.14159265359;\nconst float TAU = PI * 2.0;\nconst float TEMPO = 175.0;\n\n\/\/ Define note lengths\nconst float b1_4\t= 60.0  \/ TEMPO;\nconst float b1_2\t= b1_4  * 2.0;\nconst float b1_1\t= b1_4  * 4.0;\nconst float b1_8\t= b1_4  \/ 2.0;\nconst float b1_16\t= b1_8  \/ 2.0;\nconst float b1_32\t= b1_16 \/ 2.0;\nconst float b1_64\t= b1_32 \/ 2.0;\n\nconst float b1_4t\t= b1_1  \/ 3.0;\nconst float b1_8t\t= b1_4  \/ 3.0;\nconst float b1_16t\t= b1_8  \/ 3.0;\nconst float b1_32t\t= b1_16 \/ 3.0;\n\nconst float nC\t= 261.63;\nconst float nCs\t= 277.18;\nconst float nDb\t= nCs;\nconst float nD\t= 293.66;\nconst float nDs\t= 311.13;\nconst float nEb\t= nDs;\nconst float nE\t= 329.63;\nconst float nF\t= 349.23;\nconst float nFs = 369.99;\nconst float nGb = nFs;\nconst float nG  = 392.0;\nconst float nGs  = 415.30;\nconst float nAb  = nGs;\nconst float nA  = 440.0;\nconst float nAs  = 466.16;\nconst float nBb  = nAs;\nconst float nB  = 493.88;\n\nfloat clamp_c(float mn, float mx, float n)\n{\n    return max(mn, min(mx, n));\n}\n\n\nfloat oct_down(float freq, float octaves)\n{\n    return freq * (1.0 \/ pow(2.0, octaves));\n}\n\nfloat oct_up(float freq, float offset)\n{\n    return freq * pow(2.0, offset);\n}\n\nvec3 note(int current_i, int i, float freq, float off, float len, float t)\n{\n    float note_on = float(i == current_i && t >= off && t < (off + len));\n    \n    float note_t = 0.0;\n    float outfreq = 0.0;\n    \n    if(note_on > 0.0) {\n        note_t = t - off;\n        outfreq = freq;\n    }\n    \n    return vec3(note_on, note_t, outfreq);\n}\n\n\/\/ Mono note()\nvec3 note(float freq, float off, float len, float t)\n{\n    return note(0, 0, freq, off, len, t);\n}\n\nvec3 bass_patt_2(float time)\n{\n    float t = mod(time, b1_1 * 8.0);\n    vec3 o =\n        note(oct_down(nD, 1.0),  \t0.0,\t\t\tb1_1 * 4.0, t) +\n        note(oct_down(nF, 1.0), b1_1*4.0, b1_1*4.0, t);\n    \n    o.z = oct_down(o.z, 1.0);\n    \n    return o;\n}\n\nvec3 bass_patt(float time)\n{\n    if(time > b1_1 * 16.0) {\n        return bass_patt_2(time);\n    }\n    \n    float t = mod(time, b1_1 * 8.0);\n    \n    vec3 o =\n        note(nD,  \t0.0,\t\t\tb1_1 * 2.0, t) +\n        note(nAs, \tb1_1 * 2., \t\tb1_1, \t\tt) +\n        note(nG,\tb1_1 * 3.,\t\tb1_1,\t\tt) +\n        \n        note(nD,\tb1_1 * 4.,\t\tb1_1 * 2.0,\tt) +\n        note(nAs,\tb1_1 * 6.,\t\tb1_1,\t\tt) +\n        note(nDs,\tb1_1 * 7.,\t\tb1_2,\t\tt) +\n        note(nG,\tb1_1 * 7.+b1_2,\tb1_2,\t\tt);\n    \n    return vec3(o.xy, oct_down(o.z, 2.0));\n}\n\nfloat kick_pattern(float time)\n{\n    float t = mod(time, b1_1);\n    \n    vec3 n =\n        note(0., 0., \t\tb1_8,\t\tt) +\n        note(0., b1_8, \t\tb1_2,\t\tt) +\n        note(0., b1_8+b1_2,\tb1_8*3.0, \tt);\n            \n    return n.y;\n}\n\nfloat snare_pattern(float t)\n{\n    float lt = mod(t + b1_4, b1_4 * 2.0);\n    return lt;\n}\n\n\nvoid rot(inout vec2 v, float a){\n\tv*=mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nfloat are_there_drums() {\n    return float( (t > (b1_1 * 8.0) && t < (b1_1 * 16.0))\n      ||(t > (b1_1 * 24.0)));\n}\n\n\nfloat df(vec3 p){\n    vec3 p2 = p;\n    rot(p.xz,t);\n    \n    \n    \n    float offset = snare_pattern(t) * are_there_drums();\n    \n    p.x -= offset;\n    \n    rot(p.xy, 3. * offset);\n    \n    vec3 c = cos(p*3.0+2.0*t);\n\tfloat a = length(p-(c)*.6)-0.5;\/\/+p.y;\n    \n    p2+=vec3(2.0,2.0,t*8.0);\n    \/\/rot(p2.xy,sin(t*.2)*0.1);\n   \/\/ p2.xyz+=vec3(sin(t*.1),sin(t*.2),sin(t*.3));\n    p2.z += offset * 12.0;\n    p=mod(p2+2.0,vec3(4.0))-2.0;\n    \n    \n    float cube = max(abs(p.x),abs(p.y));\n    cube = min(cube,max(abs(p.z),abs(p.y)));\n    cube = min(cube,max(abs(p.z),abs(p.x)));\n    return min(a,cube-.2);\n}\n\nvec3 nf(vec3 p){\n\tvec2 e = vec2(.001, .0);\n    float c = df(p);\n    return normalize(vec3(\n    \tc - df(p+e.xyy),\n    \tc - df(p+e.yxy),\n    \tc - df(p+e.yyx)\n    ));\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy \/ iResolution.xy -.5)*vec2(1.7,1.0);\n\tvec2 mo = (iMouse.xy \/ iResolution.xy -.5)*vec2(1.7,1.0);\n    \n    vec3 p = vec3(0,0,-4);\n    vec3 op = p;\n    \n    vec3 bp = bass_patt(t);\n    float foo = abs(sin(bp.z * 0.04 * 2. * PI * t) * 0.5) + 0.1;\n    foo = mix(foo, 1., float(t > b1_1*8.));\n    \n    rot(uv, foo * 0.5);\n    \/\/rot(p.xy, t * 4.0);\n    vec3 d = normalize(vec3(uv,1.0));\/\/ - length(uv);\n    \n    \n    rot(d.xy, 0.9*t + length(uv - vec2(.2)));\n    \n    for (int i=0; i<100; i++){\n        float dist = df(p) \/ foo;\n        p+=dist*d * 0.5;\n        if (dist<.001) break;\n        \n    }\n    float fresnel = 1.0-dot(d,nf(p));\n    fresnel*=1.5;\n\tfloat diffuse = 1.0 - max(4.0,dot(nf(p),normalize(vec3(.1,.7,.9))));\n    \n    vec3 sd = reflect(d * vec3(0.4),nf(p));\n    vec3 sp = p+sd*.1;\n    for (int i=0;i<20;i++){\n        float dist = (df(sp) \/ foo) * 0.5;\n    \tsp += dist*sd;\n    }\n    \n    float kick_t = kick_pattern(t) * float(t > b1_1*8.0);\n    \n    float vignette = 1.4 - length(uv)*(0.9-kick_t);\n    \n    float td = distance(op,p);\n    float diff2 = max(.1,dot(nf(sp),normalize(vec3(.1,.7,.9))));\n    \n    float fFactor = (diffuse+fresnel+diff2*(fresnel))*.3\/(1.0+td*.1)*vignette;\n    \n    \/\/float band = clamp_c(sin(fFactor - 4.0) * sin(fFactor * 10.0), 0.0, 1.0);\n    \n    \n\tfragColor\n        = vec4(\n            pow(\n                vec3(fFactor, fFactor, fFactor*1.0),\n                vec3(1.0\/1.7)\n            ),\n          1.0);\n    \n    \n    float x;\/\/ = sin(t * fFactor * 0.8);\n    x = mix(0.0, 0.7, abs(sin(t * fFactor - fresnel)));\n    fragColor *= vec4(hsv2rgb(vec3(t * 0.05, x , -fFactor)), 1.0);\n    \n    \/\/fragColor = vec4(sp.yx \/ 5.0, 0.8, 1.0) * fragColor;\n    \n    \/\/fragColor += vec4(0.0, abs(sp.y), 0.0, 0.0);\n}","name":"","description":"","type":"image"},{"inputs":[],"outputs":[{"channel":"0"}],"code":"precision highp float;\n\nconst float PI = 3.14159265359;\nconst float TAU = PI * 2.0;\nconst float TEMPO = 175.0;\nconst float SMOOTH = 0.01;\n\n\/\/ Define note lengths\nconst float b1_4\t= 60.0  \/ TEMPO;\nconst float b1_2\t= b1_4  * 2.0;\nconst float b1_1\t= b1_4  * 4.0;\nconst float b1_8\t= b1_4  \/ 2.0;\nconst float b1_16\t= b1_8  \/ 2.0;\nconst float b1_32\t= b1_16 \/ 2.0;\nconst float b1_64\t= b1_32 \/ 2.0;\n\nconst float b1_4t\t= b1_1  \/ 3.0;\nconst float b1_8t\t= b1_4  \/ 3.0;\nconst float b1_16t\t= b1_8  \/ 3.0;\nconst float b1_32t\t= b1_16 \/ 3.0;\n\n\/\/ Define note values\nconst float nC\t= 261.63;\nconst float nCs\t= 277.18;\nconst float nDb\t= nCs;\nconst float nD\t= 293.66;\nconst float nDs\t= 311.13;\nconst float nEb\t= nDs;\nconst float nE\t= 329.63;\nconst float nF\t= 349.23;\nconst float nFs = 369.99;\nconst float nGb = nFs;\nconst float nG  = 392.0;\nconst float nGs  = 415.30;\nconst float nAb  = nGs;\nconst float nA  = 440.0;\nconst float nAs  = 466.16;\nconst float nBb  = nAs;\nconst float nB  = 493.88;\n\n\/\/ The number of harmonics for additive oscillators.\nconst int OSCRES = 128;\n\n\/\/ Number of voices\nconst int POLY = 8;\n\n\/\/ How many times to repeat the signal\nconst int DELAY_TAPS = 10;\n\n\/\/ How long between each repeat\nconst float DELAY_DELAY = b1_8t;\n\n\n\n\/\/ PRNG\nvec3 mod289(vec3 x) {return x - floor(x * (1.0 \/ 289.0)) * 289.0;}vec2 mod289(vec2 x) {return x - floor(x * (1.0 \/ 289.0)) * 289.0;}vec3 permute(vec3 x) {return mod289(((x*34.0)+1.0)*x);}float snoise(vec2 v){const vec4 C = vec4(0.211324865405187,0.366025403784439,-0.577350269189626,0.024390243902439); vec2 i= floor(v + dot(v, C.yy) );vec2 x0 = v - i + dot(i, C.xx);vec2 i1;i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);vec4 x12 = x0.xyxy + C.xxzz;x12.xy -= i1;i = mod289(i); vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))+ i.x + vec3(0.0, i1.x, 1.0 ));vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);m = m*m ;m = m*m ;vec3 x = 2.0 * fract(p * C.www) - 1.0;vec3 h = abs(x) - 0.5;vec3 ox = floor(x + 0.5);vec3 a0 = x - ox;m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );vec3 g;g.x= a0.x* x0.x+ h.x* x0.y;g.yz = a0.yz * x12.xz + h.yz * x12.yw;return 130.0 * dot(m, g);}\n\nfloat random(float x)\n{\n    return snoise(vec2(x * 85000.0, sin(x) * 940000.0));\n}\n\nfloat clamp_c(float mn, float mx, float n)\n{\n    return max(mn, min(mx, n));\n}\n\nfloat map(float n, float a, float b, float c, float d)\n{\n    return (n-a)\/(b-a) * (d-c) + c;\n}\n\nfloat maplimit(float n, float a, float b, float c, float d)\n{\n    float o = map(n, a, b, c, d);\n    \n    if(n <  a) return 0.0;\n    if(n >= b) return 0.0;\n    \n    return o;\n}\n\nfloat adsr(vec4 adsr, float t)\n{\n    float a = adsr.x;\n    float d = adsr.y;\n    float s = adsr.z;\n    float r = adsr.w;\n    \n    \/\/ Note off\n    if(t < 0.0)\n    {\n        return 0.0;\n    }\n    \n    \/\/ Attack\n    if(t < a)\n    {\n        return t \/ a;\n    }\n    \n    \/\/ Decay\/sustain\n    if(t < a + d)\n    {\n        return map(t - a, 0.0, d, 1.0, s);\n    }\n    \n    \/\/ Release\n    return max(map(t - a - d, 0.0, r, s, 0.0), 0.0);\n}\n\nfloat adsr(float a, float d, float s, float r, float t)\n{\n    return adsr(vec4(a, d, s, r), t);\n}\n\n\/\/ A 4-point envelope that takes 4 vec2's (and time) in the format:\n\/\/     x = time from previous value to target value\n\/\/    y = target value\n\/\/ Starts at 0.\nfloat env4(vec2 a, vec2 b, vec2 c, vec2 d, float t)\n{\n    float tb = t  - a.x;\n    float tc = tb - b.x;\n    float td = tc - c.x;\n    \n    return\n        maplimit(t , 0.0, a.x, 0.0, a.y) + \/\/ Point A\n        maplimit(tb, 0.0, b.x, a.y, b.y) + \/\/ Point B\n        maplimit(tc, 0.0, c.x, b.y, c.y) + \/\/ Point C\n        maplimit(td, 0.0, d.x, c.y, d.y);\n}\n\nfloat oct_down(float freq, float octaves)\n{\n    return freq * (1.0 \/ pow(2.0, octaves));\n}\n\nfloat oct_up(float freq, float offset)\n{\n    return freq * pow(2.0, offset);\n}\n\nfloat sine_gen(float freq, float t)\n{\n    return sin(TAU * freq * t);\n}\n\nvec2 tex_sample(sampler2D sampler, vec2 coord, vec2 speed, float t)\n{\n    vec2 c = coord + (speed * t);\n    vec4 sample = texture2D(sampler, c);\n    \n    return sample.xy;\n}\n\n\/\/ Generates a sine wave with n harmonics\nfloat sinharm(float freq, int first, int stride, float fshift, float fmul, float t)\n{\n    float s = sine_gen(freq, t);\n    \n    int st = stride + 1;\n    \n    for(int i = 0; i < OSCRES; ++i)\n    {\n        float h = float(first + (i) * (stride + 1));\n        float harm_freq = fshift + freq * h * fmul;\n        float wave = sine_gen(harm_freq, t) \/ h;\n        s += wave;\n    }\n    \n    return s;\n}\n\nfloat sinharm(float freq, int first, int stride, float t)\n{\n    return sinharm(freq, first, stride, 0.0, 1.0, t);\n}\n\nfloat quantize(float s, float res)\n{\n    return floor(s * res) \/ res;\n}\n\nvec2 quantize(vec2 s, float res) {\n    return vec2(\n        quantize(s.x, res),\n        quantize(s.y, res)\n        );\n}\n\nfloat saw_gen(float freq, float t)\n{\n    return sinharm(freq, 1, 0, t);\n}\n\nfloat real_saw(float freq, float t) {\n    float a = mod(t, 1.0 \/ freq) * freq;\n    \n    return (a - 0.5) * 2.0;\n}\n\nfloat sq_gen(float freq, float t)\n{\n    return sinharm(freq, 1, 1, t);\n}\n\nfloat sq_pwm(float freq, float pw, float t)\n{\n    float ph = mod(t, 1.0 \/ freq) * freq;\n    return float(ph > pw);\n}\n\nfloat noise_gen(float t)\n{\n    return mix(-1.0, 1.0, random(t));\n}\n\nfloat simple_dist(float s, float e)\n{\n    return s \/ abs(s) * pow(1.0-e, pow(s, 2.0 \/ abs(s)));\n}\n\n\/\/ Polyphonic version of note(), used as the base of the mono note()\n\/\/ Returns a 3d vector where:\n\/\/    x = 1.0 or 0.0, depending on if the note is on or off\n\/\/    y = time since note started, or 0.0 if note is off.\n\/\/    z = frequency of the note\nvec3 note(int current_i, int i, float freq, float off, float len, float t)\n{\n    float note_on = float(i == current_i && t >= off && t < (off + len));\n    \n    float note_t = 0.0;\n    float outfreq = 0.0;\n    \n    if(note_on > 0.0) {\n        note_t = t - off;\n        outfreq = freq;\n    }\n    \n    return vec3(note_on, note_t, outfreq);\n}\n\n\/\/ Mono note()\nvec3 note(float freq, float off, float len, float t)\n{\n    return note(0, 0, freq, off, len, t);\n}\n\nfloat kick_vol(float t)\n{\n    vec4 vol_env   = vec4(0.0, 0.15, 0.3, 0.2);\n    return adsr(vol_env, t);\n}\n\nfloat kick_pattern(float time)\n{\n    float t = mod(time, b1_1);\n    \n    vec3 n =\n        note(0., 0., \t\tb1_8,\t\tt) +\n        note(0., b1_8, \t\tb1_2,\t\tt) +\n        note(0., b1_8+b1_2,\tb1_8*3.0, \tt);\n            \n    return n.y;\n}\n\nfloat snare_pattern(float t)\n{\n    float lt = mod(t + b1_4, b1_4 * 2.0);\n    return lt;\n}\n\nfloat sidechain(float amount, float t)\n{\n    \n    \/\/ fucked around with curve fitting until something looked good\n    \/\/ f(x) = 10.23669x - 9.98258x - 0.01497 (0.0001^x)\n    \n    float p1 = 10.23669 * t*t;\n    float p2 = 9.928258 * t*t*t;\n    float p3 = 0.014970 * pow(0.0001, max(0.0, t));\n    \n    float amp = p1 - p2 - p3;\n    amp = clamp_c(0.0, 1.0, amp);\n    amp = (amount * amp) - amount + 1.0;\n    \n    return amp;\n}\n\nfloat kick_sidechain(float amount, float time)\n{\n    return sidechain(amount, kick_pattern(time));\n}\n\nfloat snare_sidechain(float amount, float time)\n{\n    return sidechain(amount, snare_pattern(time));\n}\n\nfloat kick_gen(float time)\n{\n    float t = kick_pattern(time);\n    vec4 noise_env = vec4(0.000, 0.03, 0.1, 0.1);\n    float noise = adsr(noise_env, t) * noise_gen(t) * 0.03;\n    \n    float pitch    = env4(\n        vec2(0.0001, nB * 2.0),\n        vec2(0.0003, oct_down(nB, 1.0)),\n        vec2(0.06 , oct_down(nB, 3.0)),\n        vec2(0.9 , oct_down(nB, 4.0)),\n        t);\n        \n    float sub = sine_gen(pitch, t) * kick_vol(t);\n    \n    return sub + noise;\n}\n\nfloat snare_gen(float t)\n{\n    float pitchenv = adsr(0.01, 0.1, 0.3, 0.1, t);\n    float pitch = map(pitchenv, 0.0, 1.0, 100.0, 220.0);\n    \n    float s1 = noise_gen(t * 0.0055) * adsr(0.0, 0.04, 0.25, 0.2, t) * 0.8;\n    float s2 = sine_gen(pitch, t)    * adsr(0.0, 0.01, 0.1, 0.2, t);\n    \n    return\n        (s1 * 0.4) +\n        (s2 * 1.0);\n}\n\nfloat hardclip(float s, float g)\n{\n    return clamp_c(-1.0, 1.0, s * g);\n}\n\nvec3 chord_pat(int i, float t)\n{\n    float mt = mod(t, b1_8t);\n    float mt2 = mod(t, b1_1 * 4.0);\n    \n    float len = b1_16;\n    \n    float c1n1 = nC;\n    float c1n2 = nE;\n    float c1n3 = nG;\n    float c1n4 = nB;\n    \n    float c2n1 = oct_down(nA, 1.0);\n    float c2n2 = nC;\n    float c2n3 = nE;\n    float c2n4 = nG;\n    \n    float c3n1 = nAs;\n    float c3n2 = nD;\n    float c3n3 = nF;\n    float c3n4 = nA;\n    \n    if(mt2 < b1_1 * 2.0) {\n        return\n            note(i, 0, c1n1, 0.0,\tlen, mt) +\n            note(i, 1, c1n2, 0.0, \tlen, mt) +\n            note(i, 2, c1n3, 0.0, \tlen, mt) +\n            note(i, 3, c1n4, 0.0, \tlen, mt);\n    }\n    \n    else if(mt2 < (b1_1 * 3.0 - b1_8t)) {\n        return\n            note(i, 0, c2n1, 0.0,\tlen, mt) +\n            note(i, 1, c2n2, 0.0, \tlen, mt) +\n            note(i, 2, c2n3, 0.0, \tlen, mt) +\n            note(i, 3, c2n4, 0.0, \tlen, mt);\n    }\n    \n    else {\n        return\n            note(i, 0, c3n1, 0.0,\tlen, mt) +\n            note(i, 1, c3n2, 0.0, \tlen, mt) +\n            note(i, 2, c3n3, 0.0, \tlen, mt) +\n            note(i, 3, c3n4, 0.0, \tlen, mt);\n    }\n}\n\nvec3 bass_patt_2(float time)\n{\n    float t = mod(time, b1_1 * 8.0);\n    vec3 o =\n        note(oct_down(nD, 1.0),  \t0.0,\t\t\tb1_1 * 4.0, t) +\n        note(oct_down(nF, 1.0), b1_1*4.0, b1_1*4.0, t);\n    \n    o.z = oct_down(o.z, 1.0);\n    \n    return o;\n}\n\nvec3 bass_patt(float time)\n{\n    if(time > b1_1 * 16.0) {\n        return bass_patt_2(time);\n    }\n    \n    float t = mod(time, b1_1 * 8.0);\n    \n    vec3 o =\n        note(nD,  \t0.0,\t\t\tb1_1 * 2.0, t) +\n        note(nAs, \tb1_1 * 2., \t\tb1_1, \t\tt) +\n        note(nG,\tb1_1 * 3.,\t\tb1_1,\t\tt) +\n        \n        note(nD,\tb1_1 * 4.,\t\tb1_1 * 2.0,\tt) +\n        note(nAs,\tb1_1 * 6.,\t\tb1_1,\t\tt) +\n        note(nDs,\tb1_1 * 7.,\t\tb1_2,\t\tt) +\n        note(nG,\tb1_1 * 7.+b1_2,\tb1_2,\t\tt);\n    \n    return vec3(o.xy, oct_down(o.z, 2.0));\n}\n\nfloat hh_gen(float time)\n{\n    float t = mod(time, b1_16);\n    float t2 = mod(time, b1_8);\n    float t3 = mod(time, b1_2);\n    \n    float d = sine_gen(b1_2, time);\n    d = map(abs(d), 0.0, 1.0, 0.05, 0.12);\n    \n    float env = adsr(0.0, d, 0.0, 0.0, t);\n    \n    return noise_gen(noise_gen(time)) * env;\n    \n}\n\nvec3 arp_patt(float time) {\n    float p1 = mod(time, b1_8);\n    float p2 = mod(p1, b1_8);\n    \n    vec3 n = bass_patt(time);\n    \n    n.z = oct_up(n.z, 1.0);\n    \n    \n    vec3 o =\n        note(n.z, \t\t\t\t0., \t\t\tb1_32, p1) +\n        note(oct_up(n.z, 1.0), \tb1_16,\t\t\tb1_32, p1) +\n        note(oct_up(n.z, 2.0), \tb1_16*2.0, \tb1_32, p1);\n        \/\/note(oct_up(n.z, 1.0),\tb1_32t*3.0,\t\tb1_32, p1);\n    \n    return o;\n}\n\nvec3 solo_patt(float time) {\n    float t = mod(time, b1_1 * 8.0);\n    float t2 = mod(t, b1_1 * 2.0);\n    \n    \n    float lo;\n    if(t < b1_1 * 4.0)\n        lo = oct_down(nD, 1.0);\n    \n    else\n        lo = oct_down(nF, 1.0);\n    \n    vec3 o;\n    \n    if(t < b1_1 * 6.0) {\n    o =\n    \tnote(lo, 0., \t\t\tb1_8, \tt2) +\n    \tnote(nF, b1_8, \t\t\tb1_8, \tt2) +\n        note(nE, b1_8*2., \t\tb1_4, \tt2) +\n        note(nE, b1_8*4., \t\tb1_8*3.,t2) +\n        note(lo, b1_8*7.,\t\tb1_8,\tt2) +\n        \n        note(nA, b1_1,\t\t\tb1_4,\tt2) +\n        note(lo, b1_1+b1_8*2.,\tb1_8,\tt2) +\n        note(nF, b1_1+b1_8*3.,\tb1_4,\tt2) +\n        note(lo, b1_1+b1_8*5.,\tb1_8,\tt2) +\n        note(nG, b1_1+b1_8*6.,\tb1_8,\tt2) +\n        note(nA, b1_1+b1_8*7.,\tb1_8,\tt2);\n    }\n    \n    else {\n        float t3 = t - (b1_1 * 6.0);\n    o =\n        note(nG, 0.,\t\t\tb1_8,\tt3) +\n        note(nF, b1_8,\t\t\tb1_8,\tt3) +\n        note(nE, b1_8*2.,\t\tb1_4,\tt3) +\n        note(oct_down(nA, 1.0), b1_8*4.,\t\tb1_2,\tt3) +\n        \n        note(nG, b1_1,\t\t\tb1_8,\tt3) +\n        note(nA, b1_1+b1_8,\t\tb1_8,\tt3) +\n        note(nG, b1_1+b1_8*2.,\tb1_8,\tt3) +\n        note(nF, b1_1+b1_8*3.,\tb1_8,\tt3) +\n        note(nE, b1_1+b1_8*4.,\tb1_8,\tt3) +\n        note(nF, b1_1+b1_8*5.,\tb1_8,\tt3) +\n        note(nE, b1_1+b1_8*6.,\tb1_8,\tt3) +\n        note(nC, b1_1+b1_8*7.,\tb1_8,\tt3);\n    }\n    \n    return o;\n    \n}\n\n#define SOLO_DETUNE_NUM 4\n\nvec2 solo_gen(float t) {\n    vec3 mel = solo_patt(t);\n    \n    \n        \n    float v1 = saw_gen(mel.z, t);\n\n    vec2 o = vec2(v1) * 0.4;\n        \n    \/\/o = o.xx + o.yy \/ 2.0;\n    \n    \n    o *= adsr(0.0, 0.1, 0.3, 0.4, mel.y);\n    \n    return o;\n}\n\nvec2 bass_gen(float t) {\n    \n    vec3 bp = bass_patt(t);\n    \n    float m = abs(sine_gen((bp.z - 0.0) * 0.04, t) * 0.5) + 0.1;\n    \n    float sq0 = sq_pwm(oct_down(bp.z + 1.0, 0.0), m, t) * m * 0.5;\n    float sq1 = real_saw(bp.z - 0.5, t + 0.3) * 0.8 * m;\n    float sq2 = sq_pwm(bp.z - 0.3, m, t + 0.8) * 0.8 * m;\n    float sub = sine_gen(oct_down(bp.z, 1.0), t) * 1.0;\n    \n    vec2 bass_bus = vec2(0.0);\n    bass_bus += sq0;\n    bass_bus += sq1;\n    bass_bus += sq2;\n    bass_bus += sub;\n    bass_bus *= 0.5;\n    \n    bass_bus = quantize(bass_bus, 32.0);\n    \n    return bass_bus;\n}\n\nvec2 mainSound(float t)\n{\n    \n    vec2 kick = vec2(kick_gen(t));\n    \n    \/\/kick = abs(sin(kick * 2.0)) * 0.4;\n    \n    float c = 0.0;\n    \n    for(int i = 0; i < POLY; ++i)\n    {\n        vec3 n = chord_pat(i, t);\n        c += saw_gen(n.z, t) * n.x;\n    }\n    \n    float sn_pat = snare_pattern(t);\n    float snare = snare_gen(sn_pat);\n    snare = quantize(abs(tan(snare * 5.0)), 8.0);\n    \n    vec2 master = vec2(0.0);\n    \/\/master += vec2(c) * 0.04;\n    \n    \/\/snare = quantize(snare, 40.0);\n    \/\/kick = vec2(quantize(kick.x, 12.0));\n    \n    float hh = hh_gen(t);\n    hh *= kick_sidechain(0.9, t) * snare_sidechain(0.5, t);\n    \n    vec2 bass_bus = bass_gen(t);\n    \n    \n    \/\/ Drums\n    if( (t > (b1_1 * 8.0) && t < (b1_1 * 16.0))\n      ||(t > (b1_1 * 24.0)))\n    {\n    \tbass_bus *= kick_sidechain(0.9, t) * snare_sidechain(0.6, t);\n    \n        master += kick;\n        master += clamp_c(log(snare), -1.0, 0.01) * 0.20;\n        master += hh * 0.15;\n        \n    }\n    \n    \n    master += bass_bus;\n    \n    \n    vec2 m = solo_gen(t) * 0.6;\n  \tmaster += m * 0.7 * float(t > b1_1 * 16.0);\n    \n    if(t > b1_1 * 4.0){\n        vec3 ap = arp_patt(t);\n        float arp = (\n                sq_pwm(ap.z - 3.0, 0.9, t) +\n                sq_pwm(ap.z + 3.0, 0.9, t)\n\n              ) * adsr(0.0, 0.08, 0.2, 0.08, ap.y);\n\n        master += arp * 0.15;\n    }\n    master *= 0.8;\n    \n    \/\/ fadezzzzz\n    master *= env4(\n    \tvec2(b1_1*4.0, 1.0),\n        vec2(0.0,1.0),\n        vec2(b1_1*30.0,1.0),\n        vec2(b1_1*8.0,0.0), t\n    );\n    \n    return vec2(clamp_c(-1.0, 1.0, master.x), clamp_c(-1.0, 1.0, master.y));\n}\n","name":"","description":"","type":"sound"}]}}