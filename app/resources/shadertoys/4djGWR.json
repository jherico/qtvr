{"Shader":{"ver":"0.1","info":{"id":"4djGWR","date":"1386313470","viewed":10552,"name":"Rounded Voxels","username":"iq","description":"Another regular voxel renderer. When a voxel is hit, a distance field is raymarched inside the cell in order to shape it in any arbitrary shape. Looks cool with a video rather than a static texture ^_^","likes":85,"published":3,"flags":0,"tags":["procedural","3d","raymarching","distancefield","voxel"],"hasliked":0},"renderpass":[{"inputs":[{"id":2,"src":"\/presets\/tex01.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ 1, 2, 3 or 4\n#define QUALITY 1\n\n#if QUALITY==1\n #define VIS_SAMPLES 4\n #define LIG_SAMPLES 10\n #define DETAIL_INTER 2\n#endif\n#if QUALITY==2\n #define VIS_SAMPLES 5\n #define LIG_SAMPLES 12\n #define DETAIL_INTER 2\n#endif\n#if QUALITY==3\n #define VIS_SAMPLES 8\n #define LIG_SAMPLES 12\n #define DETAIL_INTER 8\n#endif\n#if QUALITY==4\n #define VIS_SAMPLES 10\n #define LIG_SAMPLES 40\n #define DETAIL_INTER 16\n#endif\n\n\nfloat hash1( vec2  n ) { return fract(sin(dot(n,vec2(1.0,113.0)))*43758.5453123); }\nfloat hash1( vec3  n ) { return fract(sin(dot(n,vec3(1.0,113.0,257.0)))*43758.5453123); }\nvec2  hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\n\n\/\/ voxel map\nfloat map( vec3 c ) \n{\n\tvec3 p = c + 0.5;\n\t\n\tfloat h = -10.0 + 20.0*texture2D( iChannel0, fract(p.xz\/iChannelResolution[0].xy), -100.0 ).x;\n\n\treturn step( p.y, h );\n}\n\n\/\/ distance field for each voxel\nfloat map2( in vec3 p, in float id )\n{\n    float w = 0.05 + 0.35*id;\n    return length(max(abs(p)-0.5+w,0.0))-w+0.001;\n}\n\nvec3 calcNormal( in vec3 pos, in float id )\n{\n    vec3 eps = vec3(0.01,0.0,0.0);\n\n\treturn normalize( vec3(\n           map2(pos+eps.xyy,id) - map2(pos-eps.xyy,id),\n           map2(pos+eps.yxy,id) - map2(pos-eps.yxy,id),\n           map2(pos+eps.yyx,id) - map2(pos-eps.yyx,id) ) );\n}\n\n\nfloat castRay( in vec3 ro, in vec3 rd, out vec3 oVos, out vec3 oDir )\n{\n\tvec3 pos = floor(ro);\n\tvec3 ri = 1.0\/rd;\n\tvec3 rs = sign(rd);\n\tvec3 ris = ri*rs;\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\tfloat t = -1.0;\n\t\n\tvec3 mm = vec3(0.0);\n\tfor( int i=0; i<100; i++ ) \n\t{\n\t\tif( map(pos)>0.5 ) \n\t\t{ \n            \/\/ intersect cube exactly\t\t\t\n\t\t\tvec3 pr = pos+0.5-ro;\n\t\t\tvec3 mini = (pr-0.5*rs)*ri;\n\t        float s = max( mini.x, max( mini.y, mini.z ) );\n\n            \/\/ raymarch internal shape\t\t\t\n\t\t\tfloat id = hash1( pos );\n\t\t\tfloat h = 0.0;\n\t\t\th = map2( -pr+rd*s, id ); s += max(0.0,h);\n\t\t\th = map2( -pr+rd*s, id ); s += max(0.0,h);\n\t\t\th = map2( -pr+rd*s, id ); s += max(0.0,h);\n\t\t\th = map2( -pr+rd*s, id ); s += max(0.0,h);\n\t\t\th = map2( -pr+rd*s, id ); s += max(0.0,h);\n\t\t\th = map2( -pr+rd*s, id ); s += max(0.0,h);\n\t\t\tif( h<0.025 )\n\t\t\t{\n\t\t\t\tt = s;\n\t\t\t\tbreak; \n\t\t\t}\n\t\t}\n\t\tvec3 mi = step( dis.xyz, dis.yzx ); \n\t\tmm = mi*(1.0-mi.zxy);\n\t\tdis += mm * ris;\n        pos += mm * rs;\n\t}\n\n\toDir = mm;\n\toVos = pos;\n\n\treturn t;\n\n}\n\nfloat castShadowRay( in vec3 ro, in vec3 rd, out vec3 oVos )\n{\n\n\tvec3 pos = floor(ro);\n\tvec3 ri = 1.0\/rd;\n\tvec3 rs = sign(rd);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\tvec3 ris = ri*rs;\n\t\n\tfloat res = 1.0;\n\n    \/\/ detailed raymarching\n    \n    for( int i=0; i<DETAIL_INTER; i++ ) \n\t{\n\t\tif( map(pos)>0.5 && i>0 )\n\t\t{\n            float id = hash1( pos );\n            vec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n            float t = max ( mini.x, max ( mini.y, mini.z ) );\n            float h = 0.0;\n            vec3 ce = pos + 0.5;\n            h = map2( ro+rd*t-ce,id ); t += max(0.0,h);\n            h = map2( ro+rd*t-ce,id ); t += max(0.0,h);\n            h = map2( ro+rd*t-ce,id ); t += max(0.0,h);\n            h = map2( ro+rd*t-ce,id ); t += max(0.0,h);\n            h = map2( ro+rd*t-ce,id ); t += max(0.0,h);\n            h = map2( ro+rd*t-ce,id ); t += max(0.0,h);\n            if( h<0.001 )\n            {\n                return 0.0;\n                res=0.0; \n                break; \n\t\t\t}\n\t\t}\n\t\tvec3 mi = step( dis.xyz, dis.yzx ); \n\t\tvec3 mm = mi*(1.0-mi.zxy);\n\t\tdis += mm * ris;\n        pos += mm * rs;\n\t}\n\t\n\n    \/\/ coarse raymarching\n\n\tfor( int i=0; i<(16-DETAIL_INTER); i++ ) \n\t{\n\t\tif( map(pos)>0.5 && i>0 )\n\t\t{\n            res=0.0; \n            break; \n\t\t}\n\t\tvec3 mi = step( dis.xyz, dis.yzx ); \n\t\tvec3 mm = mi*(1.0-mi.zxy);\n\t\tdis += mm * ris;\n        pos += mm * rs;\n\t}\n\t\n\toVos = pos;\n\t\n\treturn res;\n}\n\n\n\nvec3 path( float t )\n{\n    vec2 p  = 100.0*sin( 0.01*t*vec2(1.0,1.2) + vec2(1.5,3.0) );\n\t     p +=  50.0*sin( 0.02*t*vec2(1.3,1.0) + vec2(2.5,5.4) );\t\n\treturn vec3( p.x, 5.5 + 2.0*sin(0.05*t), p.y );\n}\n\nvec3 getVoxelColor( in vec3 pos )\n{\n\tfloat id = hash1( pos.xz + 53.123  );\n\t\n\tfloat f = smoothstep( 0.8, 0.801, id );\n\tf *= smoothstep( 0.6, 0.8, sin(60.0*id + pos.y*0.3 + 2.0*iGlobalTime) );\n\n\tvec3 col = 0.55 + 0.45*sin( 16.0*id + 0.0 + vec3(0.0,0.6,1.5) );\n\tcol = 0.9*normalize(col);\t\n\treturn f*col;\n}\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec4 x = texture2D( sam, p.yz );\n\tvec4 y = texture2D( sam, p.zx );\n\tvec4 z = texture2D( sam, p.xy );\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ inputs\t\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 mo = iMouse.xy \/ iResolution.xy;\n    if( iMouse.w<=0.00001 ) mo=vec2(0.0);\n\t\n\tvec3 bgcol = vec3(0.0);\n\n\t\/\/ montecarlo\t\n\tvec3 tot = vec3(0.0);\n#if VIS_SAMPLES<2\n\tint a = 0;\n\t{\n\t\tvec4 rr = texture2D( iChannel1, (fragCoord.xy+0.5)\/iChannelResolution[1].xy  ).xzyw;\n        vec2 p = -1.0 + 2.0*(fragCoord.xy) \/ iResolution.xy;\n#else\n\tfor( int a=0; a<VIS_SAMPLES; a++ )\n\t{\n\t\tvec4 rr = texture2D( iChannel1, (fragCoord.xy +0.5+103.3137*float(a))\/iChannelResolution[1].xy  ).xzyw;\n        vec2 p = -1.0 + 2.0*(fragCoord.xy+rr.xz) \/ iResolution.xy;\n#endif\t\n\n        p.x *= iResolution.x\/ iResolution.y;\n\n        float time = 2.2*(iGlobalTime + 1.0*(0.5\/24.0)*rr.y) + 50.0*mo.x;\n\n\t\t\/\/ camera\n        vec3 ro = path( time );\n        vec3 ta = path( time+2.0 );\/\/ - vec3(0.0,6.0,0.0);\n\t\tta.y -= 1.0;\n\t\t\/\/ta.y = 0.3*ta.y + 0.7*ro.y - 1.2 + 1.0*sin(0.05*time);\n        float cr = 0.2*cos(0.09*time);\n\t\n        \/\/ build ray\n        vec3 ww = normalize( ta - ro);\n        vec3 uu = normalize(cross( vec3(sin(cr),cos(cr),0.0), ww ));\n        vec3 vv = normalize(cross(ww,uu));\n        float r2 = p.x*p.x*0.32 + p.y*p.y;\n        p *= (7.0-sqrt(37.5-11.5*r2))\/(r2+1.0);\n        vec3 rd = normalize( p.x*uu + p.y*vv + 3.0*ww );\n\n        \/\/ dof\n        #if VIS_SAMPLES>2\n        vec3 fp = ro + rd * 8.0;\n        ro += (uu*(-1.0+2.0*rr.x) + vv*(-1.0+2.0*rr.w))*0.03;\n        rd = normalize( fp - ro );\n        #endif\n\t\t\n        vec3 col = bgcol;\n\t\t\n        \/\/ raymarch\t\n        vec3 vos, dir;\n        float t = castRay( ro, rd, vos, dir );\n        if( t>0.0 )\n        {\n            vec3 pos = ro + rd*t;\n\t\t\tfloat id = hash1( vos );\n\t\t\tvec3 nor = calcNormal( fract(pos)-0.5, id );\n\t\t\t\t\n\t\t\tvec3 uvw = pos - vos;\n\t\n            \/\/ lighting\n            vec3 lin = vec3(0.0);\n\t\t\tvec3 occ = vec3(0.0);\n\t\t\tvec3 spp = vec3(0.0);\n            #if 1\n            vec3  ru  = normalize( cross( nor, vec3(0.0,1.0,1.0) ) );\n            vec3  rv  = normalize( cross( ru, nor ) );\n            for( int j=0; j<LIG_SAMPLES; j++ )\n            {\n                vec2  aa = hash2( rr.x + float(j)*203.1 );\n                float ra = sqrt(aa.y);\n                float rx = ra*cos(6.2831*aa.x); \n                float ry = ra*sin(6.2831*aa.x);\n                float rz = sqrt( 1.0-aa.y );\n                vec3  rr = rx*ru + ry*rv + rz*nor;\n\t\t\t\t\n\t\t\t\tvec3 rpo = vec3( 0.0 );\n\t\t\t\tfloat sha = castShadowRay( pos, rr, rpo );\n\t\t\t\t\n\t\t\t\tvec3 irr = (1.0-sha) * getVoxelColor( rpo );\n                lin += irr;\n\t\t\t\tspp += irr * pow( clamp( dot(reflect(rd,nor),rr), 0.0, 1.0 ), 12.0 );\n\t\t\t\tocc += sha;\n            }\n\t\t\tfloat is = 1.0\/float(LIG_SAMPLES);\n            lin *= is;\n\t\t\tocc *= is;\n\t\t\tspp *= is;\n            #else\t\t\n            lin = vec3(0.0);\n\t\t\tocc = vec3(1.0) * (0.6 + 0.4*nor.y);\n\t\t\tspp = vec3(0.0);\n            #endif\t\t\n\n            \/\/ material\t\t\t\n\t\t\tvec3 mate = getVoxelColor( vos );\n            vec3 tex = (0.5+0.5*texture2D( iChannel0, fract(vos.xz\/iChannelResolution[0].xy), -100.0 ).xyz);\n\t\t\tfloat spe = pow( clamp( -dot(nor,rd), 0.0, 1.0 ), 28.0 );\n\t\t\ttex *=  0.15 + 0.85*id;\n\t\t\tvec3 tt = texcube( iChannel0, 0.5*pos + id*111.143, nor ).xyz;\n\t\t\ttex *= 0.4 + 1.2*tt;\n\t\t\t\t\n            \/\/ final color\t\t\t\n\t\t\tcol = vec3(0.0);\n\t\t\tcol += 1.800*mate;\n            col += 4.000*lin*(mate+tex);\n\t\t\tcol += 0.040*occ*(mate+tex) * 6.0*(0.5+0.5*nor.y) * 0.75;\n            col += 70.000*spe*(mate+tex)*lin*occ * 0.6;\n\t\t\tcol += spp*10.0*(0.2+1.6*tt.x) * 0.75;\n\t\t\tcol *= 1.8;\n\n            \/\/ fog\t\t\t\n\t\t\tfloat ff = 1.0 - smoothstep( 90.0, 128.0, t*1.73 );\n            ff *= exp( -pow(0.015*t,1.0) );\n            col = mix( col, bgcol, 1.0-ff );\n        }\n\t\ttot += col;\n\t}\n\ttot \/= float(VIS_SAMPLES);\n\t\t\n\t\/\/ gamma\t\n\ttot = pow( clamp( tot, 0.0, 1.0 ), vec3(0.45) );\n\n\t\/\/ vignetting\t\n\ttot *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n\tfragColor = vec4( tot, 1.0 );\n}","name":"","description":"","type":"image"}]}}