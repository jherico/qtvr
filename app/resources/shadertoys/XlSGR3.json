{"Shader":{"ver":"0.1","info":{"id":"XlSGR3","date":"1446991137","viewed":384,"name":"Raycasted spheres","username":"Aj_","description":"My first attempt at creating a raycasted scene using intersection equations and all. Not optimized. The lights are tactically positioned to avoid any sharp edges. ;P.<br\/>Also could anyone tell me why lines 80 and 89 doesn't work (when uncommented)?","likes":0,"published":3,"flags":0,"tags":["raycast"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"const int NUM_PRIMS = 4;\nconst int NUM_LIGHTS = 4;\nconst float FAR = 100.;\n\n#define MRX(X) mat3(1., 0., 0. ,0., cos(X), -sin(X) ,0., sin(X), cos(X))\n#define MRY(X) mat3(cos(X), 0., sin(X),0., 1., 0.,-sin(X), 0., cos(X))\n#define MRZ(X) mat3(cos(X), -sin(X), 0.\t,sin(X), cos(X), 0.\t,0., 0., 1.)\n#define MRF(X,Y,Z) MRZ(Z)*MRY(Y)*MRX(X)\n\nstruct Primitive {\n    vec3 forward;\n    float id;\n    vec3 pos;\n    vec3 normal;\n    float size;\n    bool isIntersected ;\n    vec3 intersecPoint;\n    float specular;  \n};  \n    \n\nstruct Light {\n    vec3 pos;\n    vec3 col;\n};\n\n\n    \/\/Sphere-line intersection equations snatched from wikipedia (on a windy morning)\nvoid getSphereIntersec(inout Primitive sph, vec3 rayOr, vec3 rayDir, float smooth) {\n    vec3 rx = rayOr-sph.pos;\n    float vrx = dot(rayDir, rx);\n    float drx = distance(rayOr,sph.pos);\n    float v = vrx*vrx \n         - (drx*drx - (sph.size+smooth)*(sph.size+smooth)); \/\/sphere line intersec equation    \n    float ld = -vrx; \/\/sphere line intersec equation\n\tfloat sqrtv = sqrt(abs(v)); \n    float dist1 = ld + sqrtv; \/\/dist to intersec point1\n    float dist2 = ld - sqrtv; \/\/dist to intersec point2\n    sph.intersecPoint =rayOr+ min(dist1, dist2) * rayDir; \/\/calcing the closest intersec point   \t\n    sph.isIntersected = v<0.?false:true;    \n    sph.normal =normalize(sph.intersecPoint - sph.pos);\/\/ sph.isIntersected?normalize(sph.intersecPoint - sph.pos):vec3(0., 0., 0.);\n      \n}\n\nvoid getPlaneIntersec(inout Primitive plane, vec3 rayOr, vec3 rayDir) {\n    float rdn = dot( rayDir, plane.normal); \/\/plane line intersection\n    float frdn = rdn==0.?1.:rdn; \n    float dfc = dot(plane.normal, (plane.pos - rayOr))\/frdn; \/\/dist of plane from ray origin\n     plane.intersecPoint = rayOr + dfc*rayDir; \/\/intersection point of line and ray\n   \n    plane.isIntersected = rdn==0.?false:true;\n    vec3 dVec = vec3(plane.intersecPoint - plane.pos);\n    plane.isIntersected = (plane.isIntersected&&(abs(dVec.x)\n                          +abs(dVec.y)+abs(dVec.z)<=plane.size))?true:false;\n    \n    \n}\n\n\nfloat minLen;\nPrimitive nope;\nPrimitive prim ;\n    \nPrimitive processRayIntersect(vec3 rayOr, vec3 rayDir,inout Primitive prims[NUM_PRIMS], float smooth) {\n     \n    minLen = FAR+1.;    \n    prim = nope;    \n    \n       float tl; \n    for(int i=1;i<NUM_PRIMS;i++) {\n       \n    \tprims[i].id = float(i);\n        getSphereIntersec(prims[i], rayOr, rayDir, smooth);\n        tl = distance(rayOr, prims[i].intersecPoint);\n        minLen = prims[i].isIntersected&&tl<=minLen?tl:minLen;\n        \/\/prim = tl==minLen?prims[i]:(prim);\n        if(tl==minLen) {\n            prim = prims[i];\n        }\n    }\n    \n    getPlaneIntersec(prims[0], rayOr ,rayDir);\n    tl = distance(rayOr, prims[0].intersecPoint);\n    minLen = prims[0].isIntersected&&tl<=minLen?tl:minLen;\n        \/\/prim = (tl==minLen)?(prims[0]):(prim);\n    if(tl==minLen) {    \n        prim = prims[0];\n\n    }\n    return prim;\n    \n   \n    }\n\n\nvec3 makeScene(vec2 uv, vec3 rayOr,vec3 rayDir\n               , vec3 center, vec3 sphPos, float iGlobaltime) {\n   \n  \n    Primitive sph1, plane1, sph2, sph3, sph4, sph5;\n    sph3.size = .18; \n    sph3.pos =sphPos + vec3(0., 0., sph3.size);\n    \n    sph1.size = .08;\n    sph1.pos = vec3(sph3.pos.x-(sph1.size+sph3.size)*1.02,sph3.pos.y, sph1.size-.001);\n    sph2.size =.18;\n    sph2.pos = vec3(sph3.pos.x+(sph3.size+sph2.size)*1.02,sph3.pos.y, sph3.size-.001);\n    sph1.specular = sph2.specular = sph3.specular = .5;    \n    \n    plane1.pos = vec3(vec2(sph3.pos.xy), sph1.pos.z - sph1.size+.005);\n    plane1.normal = normalize(vec3(0., 0., .1));\n    plane1.size = 1.; \n    plane1.specular = .8;\n    Primitive prims[NUM_PRIMS];\n    \n    prims[0] = plane1;\n    prims[1] = sph1;\n    prims[2] = sph2;\n    prims[3] = sph3;    \n    \/\/prims[4] = sph4;\n    \/\/prims[5] = sph5;\n       \n    \n  \n    Primitive rayPrim = processRayIntersect(rayOr, rayDir, prims, 0.);\n    \n    Light lights[NUM_LIGHTS];\n    lights[0].pos = vec3(sph2.pos.x, sph2.pos.y+.9, .9);\/\/pos of light1;\n    lights[0].col = vec3(.1, .4, .2)*2.;\n    lights[1].pos =  vec3(-.8, .3, .4);\n    lights[1].col = vec3(.4, .1, .1)*3.;\n    lights[2].pos = vec3(1.8, .2, .5);\n    lights[2].col = vec3(.2, .1, .4)*4.;\n    lights[3].pos = vec3(.5, .2, 7.2);\n    lights[3].col = vec3(.3, .3, .8);\n    Primitive lightPrim;\n    vec3 finalCol = vec3(0.,0.,0.);\n    vec3 lRefl;\n    float str;\n    for(int i=0;i<NUM_LIGHTS;i++) {\n        lightPrim = processRayIntersect(lights[i].pos\n                        , normalize(rayPrim.intersecPoint - lights[i].pos), prims, .001);\n        if(lightPrim.id == plane1.id) {\n        finalCol+= lightPrim.id==rayPrim.id?max(dot(rayPrim.normal\n               , normalize( -(rayPrim.intersecPoint) + lights[i].pos))\n               *lights[i].col*.4, 0.):vec3(0., 0., 0.);\n            \n        }\n        else {\n        lRefl = reflect(rayPrim.intersecPoint - lights[i].pos\n                            , rayPrim.normal);\n        str = max((-1.*dot(normalize(lRefl), rayDir)-rayPrim.specular), 0.0) *5.;\n       \n        finalCol += mix(finalCol,                        \n                       lightPrim.id==rayPrim.id?\n                        str*lights[i].col\n            :vec3(0., 0., 0.)\n                        , .9 );\n       }\n    }\n\n    \n    return finalCol;\n    \n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    nope.normal = vec3(0., 0., 0.);\n    nope.id = -1.;\n\tfloat t = iGlobalTime;\n\tvec2 uv = (fragCoord.xy )\/max(iResolution.x, iResolution.y);\n    vec3 center = vec3(vec2(iResolution.xy\/2.\/max(iResolution.x, iResolution.y)), -3.0);\n    uv -=center.xy;\n    mat3 rotM = MRZ(t);\n    vec3 camPos = vec3(0, -4., 3.0);\/\/vec3(0.5, .25, 15.25);\n    camPos = rotM*(camPos);\n    vec3 sph1Pos = vec3 (0., 0., 0.);\n    vec3 forward = normalize(sph1Pos - camPos);\/\/vec3(0., 0., 1.);\/\/vec3(0., 0., -1.);\n    vec3 upVec = normalize(cross(cross(forward, vec3(0., 0., 1.)), forward));\n   \n    vec3 scrnPos = camPos+forward*2.;    \n    vec3 planeLeft = normalize(cross(forward, upVec));\n\tvec3 planeUV =upVec * uv.y + planeLeft*uv.x;\n    vec3 rayDirUV = normalize(scrnPos + planeUV - camPos);\n   \n    vec3 val = makeScene(uv, camPos,rayDirUV, center,sph1Pos, t);\n    fragColor = vec4(vec3(val), 1.);\n    \n}\n\n","name":"","description":"","type":"image"}]}}