{"Shader":{"ver":"0.1","info":{"id":"XdfXD4","date":"1400761906","viewed":114,"name":"Danbo","username":"elias","description":"First shader! Tried to replicate this little guy: https:\/\/en.wikipedia.org\/wiki\/Danbo_(character)","likes":0,"published":3,"flags":0,"tags":["danbo"],"hasliked":0},"renderpass":[{"inputs":[{"id":6,"src":"\/presets\/tex05.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ ToDo\n\/\/ --------------------------\n\/\/ [x] calculate face normals\n\/\/ [ ] antialiasing\n\/\/ [ ] glowing eyes\n\/\/ [ ] rigging\n\n#define STEPS      64\n#define DEPTH      8.0\n#define PRECISION  0.0001\n\n#define PI  3.14159265359\n#define PIH 1.57079632679\n\n#define SHADOWS\n#define SHADOWBLUR 8.0\n\nstruct Ray {\n\tvec3 origin;\n\tvec3 dir;\n};\n\nstruct Hit {\n\tvec3 pos;\n\tfloat dist;\n\tint material;\n};\n\nstruct Material {\n\tvec3 col;\n\tvec3 diff;\n\tvec3 spec;\n};\n\nHit march(Ray);\nHit scene(vec3,bool);\nvec3 processColor(Hit);\nfloat shadowMarch(Ray);\n\nconst int materialCount = 6;\nMaterial material[materialCount];\n\nfloat t = iGlobalTime;\n\n\/* ===================== *\/\n\/* ====== OBJECTS ====== *\/\n\/* ===================== *\/\n\nvec3 eye = vec3(0,0.7,-1.2);\nvec3 danbo = vec3(0,0.5,0);\nvec3 light = vec3(0.5,0.5,-0.5);\n\nfloat ground = -0.4;\n\nvoid initialize()\n{\n\t\/\/ Background\n\tmaterial[0] = Material(vec3(0.1),vec3(0),vec3(0));\n\t\/\/ Floor\n\tmaterial[1] = Material(vec3(0.4),vec3(1),vec3(0));\n\t\/\/ Body\n\tmaterial[2] = Material(vec3(0.82,0.69,0.53)*0.9,vec3(1),vec3(1));\n\t\/\/ Eyes, mouth, marks, joints\n\tmaterial[3] = Material(vec3(0.3),vec3(0),vec3(0));\n\t\/\/ Stand\n\tmaterial[4] = Material(vec3(0.82,0.69,0.53)*0.5,vec3(0.3),vec3(1));\n\t\/\/ Silver\n\tmaterial[5] = Material(vec3(0.7),vec3(0.3),vec3(1));\n}\n\n\/* ===================== *\/\n\/* ====== LIBRARY ====== *\/\n\/* ===================== *\/\n\n\/\/ Thanks iq! - http:\/\/www.iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\n\nfloat sdSphere(vec3 p,float r){return length(p)-r;}\nfloat sdFloor(vec3 p,float y){return p.y-y;}\nfloat sdBox(vec3 p,vec3 b,float r){vec3 d=abs(p)-b;return min(max(d.x,max(d.y,d.z)),0.0)+length(max(d,0.0))-r;}\nfloat sdCappedCylinderZ(vec3 p,vec2 h){vec2 d=abs(vec2(length(p.xy),p.z))-h;return min(max(d.x,d.y),0.0)+length(max(d,0.0));}\nfloat sdCappedCylinderY(vec3 p,vec2 h){vec2 d=abs(vec2(length(p.xz),p.y))-h;return min(max(d.x,d.y),0.0)+length(max(d,0.0));}\nfloat sdTriPrism(vec3 p,vec2 h){vec3 q=abs(p);return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);}\n\nvec3 getNormal( vec3 p )\n{\n    vec3 e = vec3( 0.001, 0.0, 0.0 );\n    return normalize(vec3( scene(p+e.xyy,false).dist - scene(p-e.xyy,false).dist,\n                           scene(p+e.yxy,false).dist - scene(p-e.yxy,false).dist,\n                           scene(p+e.yyx,false).dist - scene(p-e.yyx,false).dist ));\n}\n\nmat3 rot(vec3 a){vec3 s=sin(a);vec3 c=cos(a);return mat3(c.y*c.z,c.y*-s.z,-s.y,s.x*s.y*c.z+c.x*s.z,s.x*s.y*-s.z+c.x*c.z,s.x*c.y,c.x*s.y*c.z+-s.x*s.z,c.x*s.y*-s.z-s.x*c.z,c.x*c.y);}\n\n\/* ======================= *\/\n\/* ====== MATERIALS ====== *\/\n\/* ======================= *\/\n\nMaterial getMaterial(int index)\n{\n\tMaterial m;\n\tfor (int i=0;i<materialCount;i++)\n\t{if(index==i){m=material[i];break;}}\n\treturn m;\n}\n\nvec3 processColor(Hit hit)\n{\n\tMaterial m = getMaterial(hit.material);\n\tvec3 col = m.col;\n\t\n\tif (hit.material == 1) { col = texture2D(iChannel0, hit.pos.xz).rgb; }\n\t\n\tvec3 n = getNormal(hit.pos);\n\tvec3 l = normalize(light-hit.pos);\n\t\n\tfloat distance = length(light-hit.pos);\n\tfloat diff = max(0.0,dot(reflect(-l,n),n));\n\tfloat spec = pow(diff,50.0);\n\t\n\tcol *= vec3(diff)*m.diff;\n\tcol += vec3(spec)*m.spec;\n\tcol *= min(1.0, 1.0\/distance);\n\n\t#ifdef SHADOWS\n\t\tRay ray = Ray(light,normalize(hit.pos));\n\t\tcol *= max(shadowMarch(ray),0.5);\n\t#endif\n\t\n\treturn col;\n}\n\n\/* =================== *\/\n\/* ====== SCENE ====== *\/\n\/* =================== *\/\n\nHit scene(vec3 p, bool shadow)\n{\n\tfloat r = 0.0;\n\tvec3 pd = (p-danbo);\n\t\n\t\/\/ head\n\tfloat ddanbo = max(\n\t\tsdBox(pd,vec3(0.3,0.175,0.15), 0.01),\n\t\t-sdBox(pd-vec3(0,-0.175,0),vec3(0.29,0.025,0.14),0.0)\n\t);\n\t\n\t\/\/ body\n\tddanbo = min(ddanbo, sdBox(pd-vec3(0,-0.175-0.2,0),vec3(0.15,0.2,0.1),r));\n\t\n\t\/\/ flaps (f,b,l,r)\n\tddanbo = min(ddanbo, sdBox((pd-vec3(0,-0.175-0.4-0.06,-0.12))*rot(vec3(0.4,0,0)),vec3(0.145,0.06,0.002),0.005));\n\tddanbo = min(ddanbo, sdBox((pd-vec3(0,-0.175-0.4-0.06,0.12))*rot(vec3(-0.4,0,0)),vec3(0.145,0.06,0.002),0.005));\n\tddanbo = min(ddanbo, sdBox((pd-vec3(-0.16,-0.175-0.4-0.06,0))*rot(vec3(0,0,0.2)),vec3(0.002,0.06,0.1),0.005));\n\tddanbo = min(ddanbo, sdBox((pd-vec3(0.16,-0.175-0.4-0.06,0))*rot(vec3(0,0,-0.2)),vec3(0.002,0.06,0.1),0.005));\n\t\n\t\/\/ arms (l,r)\n\tddanbo = min(ddanbo, sdBox(pd-vec3(-0.21,-0.175-0.2-0.07,0),vec3(0.05,0.21,0.05),r));\n\tddanbo = min(ddanbo, sdBox(pd-vec3(0.21,-0.175-0.2-0.07,0),vec3(0.05,0.21,0.05),r));\n\t\n\t\/\/ legs (l,r)\n\tddanbo = min(ddanbo, sdBox(pd-vec3(-0.07,-0.175-0.4-0.15,0),vec3(0.06,0.12,0.08),r));\n\tddanbo = min(ddanbo, sdBox(pd-vec3(0.07,-0.175-0.4-0.15,0),vec3(0.06,0.12,0.08),r));\n\n\t\/\/ shoulders (l,r)\n\tddanbo = min(ddanbo,max(\n\t\tmax(sdBox(pd-vec3(-0.19,-0.195,0), vec3(0.032,0.04,0.05),0.0),\n\t\t-sdBox(pd-vec3(-0.21,-0.195,0), vec3(0.02,0.1,0.04),0.0)\n\t\t),-sdBox((pd-vec3(-0.31,-0.19,0))*rot(vec3(0,0,-PI\/3.0)), vec3(0.32,0.08,0.1),0.0))\n\t);\n\t\n\tddanbo = min(ddanbo,max(\n\t\tmax(sdBox(pd-vec3(0.19,-0.195,0),vec3(0.032,0.04,0.05),0.0),\n\t\t-sdBox(pd-vec3(0.21,-0.195,0),vec3(0.02,0.1,0.04),0.0)\n\t\t),-sdBox((pd-vec3(0.31,-0.19,0))*rot(vec3(0,0,PI\/3.0)), vec3(0.32,0.08,0.1),0.0))\n\t);\n\t\n\tif (shadow==true) { return Hit(vec3(0),ddanbo,0); }\n\t\n\t\/\/ marks front\/back\n\tfloat dmarks = sdBox(pd-vec3(0.27,-0.14,-0.1601),vec3(0.02,0.02,0),0.0);\n\tdmarks = min(dmarks, sdBox(pd-vec3(-0.18,0.16,-0.1601),vec3(0.1,0.01,0),0.0));\n\tdmarks = min(dmarks, sdBox(pd-vec3(0.18,0.16,0.1601),vec3(0.1,0.01,0),0.0));\n\t\n\tfor(float i=0.0;i<7.0;i++){\n\t\tdmarks = min(dmarks,sdBox(pd-vec3(-0.26,-0.16+i*0.01,-0.1601),vec3(0.03,0.002+mod(i,3.0)*0.001,0),0.0));\n\t\tdmarks = min(dmarks,sdBox(pd-vec3(-0.26,-0.16+i*0.01,0.1601),vec3(0.03,0.002+mod(i,3.0)*0.001,0),0.0));\n\t}\n\t\n\t\/\/ marks right\n\tdmarks = min(dmarks, sdBox(pd-vec3(0.3101,-0.14,0.12),vec3(0,0.02,0.02),0.0));\n\tdmarks = min(dmarks, sdCappedCylinderZ((pd-vec3(0.3101,-0.142,0.07))*rot(vec3(0,PIH,0)),vec2(0.02,0.0)));\n\t\n\t\/\/ screw\n\tfloat dsilver = sdCappedCylinderZ(pd-vec3(0.07,-0.27,-0.1),vec2(0.02,0.0));\n\tdmarks = min(dmarks, sdBox(pd-vec3(0.07,-0.27,-0.101),vec3(0.014,0.0035,0),0.0));\n\n\t\/\/ marks left\n\tdmarks = min(dmarks, sdBox(pd-vec3(-0.3101,-0.12,-0.12),vec3(0.01,0.025,0.01),0.0));\n\tdmarks = min(dmarks, sdBox(pd-vec3(-0.3101,-0.11,-0.12),vec3(0.03,0.01,0.01),0.0));\n\tdsilver = min(dsilver, sdBox(pd-vec3(-0.3101,-0.12,-0.12),vec3(0,0.03,0.015),0.0));\n\n\t\/\/ joints (l,r)\n\tfloat djoints = sdSphere(pd-vec3(-0.22,-0.2,0), 0.04);\n\tdjoints = min(djoints, sdSphere(pd-vec3(0.22,-0.2,0), 0.04));\n\t\n\t\/\/ eyes (l,r)\n\tfloat deyes = min(\n\t\tsdCappedCylinderZ(pd-vec3(-0.1,0,-0.14),vec2(0.03,0.01)),\n\t\tsdCappedCylinderZ(pd-vec3(0.1,0,-0.14),vec2(0.03,0.01))\n\t);\n\t\n\tddanbo = max(ddanbo,-min(\n\t\tsdCappedCylinderZ(pd-vec3(-0.1,0,-0.15),vec2(0.03,0.1)),\n\t\tsdCappedCylinderZ(pd-vec3(0.1,0,-0.15),vec2(0.03,0.1))\n\t));\n\t\n\t\/\/ mouth\n\tfloat dmouth = sdTriPrism((pd-vec3(0,-0.1,-0.14))*vec3(1,1.4,1),vec2(0.05,0)); \n\tddanbo = max(ddanbo, -sdTriPrism((pd-vec3(0,-0.1,-0.14))*vec3(1,1.4,1), vec2(0.05, 0.1))); \n\t\n\t\/\/ stand, floor\n\tfloat dstand = sdCappedCylinderY(pd-vec3(0,-0.85,0),vec2(0.3,0.005));\n\tfloat dfloor = sdFloor(p,ground);\n\t\n\tfloat d = dfloor;\n\t\n\td = min(d,ddanbo);\n\td = min(d,deyes);\n\td = min(d,dmouth);\n\td = min(d,djoints);\n\td = min(d,dstand);\n\td = min(d,dmarks);\n\td = min(d,dsilver);\n\n\tint m = 0;\n\t\n\tif(d==dfloor){m=1;}\n\tif(d==ddanbo){m=2;}\n\tif(d==deyes||d==dmouth||d==djoints||d==dmarks){m=3;}\n\tif(d==dstand){m=4;}\n\tif(d==dsilver){m=5;}\n\t\n\treturn Hit(p,d,m);\n}\n\n\/* =================== *\/\n\/* ====== MARCH ====== *\/\n\/* =================== *\/\n\nHit march(Ray ray)\n{\n\tvec3 p; Hit hit; float t=0.0;\n\t\n\tfor (int i=0;i<STEPS;i++)\n\t{\n\t\tp = ray.origin+ray.dir*t;\n\t\thit = scene(p,false);\n\n\t\tif(t>DEPTH){hit.material=0;break;}\n\t\tif(hit.dist<PRECISION){break;}\n\n\t\tt+=hit.dist;\n\t}\n\t\n\treturn hit;\n}\n\nfloat shadowMarch(Ray ray)\n{\t\n\tfloat t=0.0, d=0.0, r=1.0;\n\t\n\tfor (int i=0;i<STEPS;i++)\n\t{\n\t\td = scene(ray.origin+ray.dir*t,true).dist;\n\t\tif(d<PRECISION||t>DEPTH){break;}\n\t\tr = min(r,SHADOWBLUR*d\/t); t+=d;\n\t}\n\n\treturn r;\n}\n\nRay lookAt(vec3 o, vec3 t)\n{\n\tvec2 uv = (gl_FragCoord.xy*2.0-iResolution.xy)\/iResolution.xx;\n\tvec3 n = normalize(t-o), u=vec3(0,1,0), r=cross(u,n); u=cross(n,r);\n\treturn Ray(o,normalize(r*uv.x + u*uv.y + n));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tinitialize();\n\n\teye *= rot(vec3(0.5,iMouse.x>0.0?iMouse.x\/iResolution.x*PI*4.0:sin(t*0.5),0));\n\n\tRay ray = lookAt(eye,vec3(0,0.15,0));\n\tHit hit = march(ray);\n\t\n\tvec3 color = processColor(hit);\n\tfragColor = vec4(color,1);\n}","name":"","description":"","type":"image"}]}}