{"Shader":{"ver":"0.1","info":{"id":"Xd2XWt","date":"1417183156","viewed":828,"name":"Rolling forever","username":"dr2","description":"Balls rolling endlessly.","likes":13,"published":3,"flags":0,"tags":["raymarch","balls","helix","track"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ \"Rolling forever\" by dr2 - 2014\n\/\/ License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float s = 0.;\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return s;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  vec2 q = vec2 (length (p.xy) - rc, p.z);\n  return length (q) - ri;\n}\n\nint idObj;\nconst int nBall = 8;\nmat3 vuMat;\nvec3 bPos[nBall], bNv[nBall], trNv, qHit, ltDir;\nfloat tCur, posLin, radSpir, dhSpir, ballRad, rollVel, fnSpir, dLinSeg,\n   dRotSeg, lenPath, bAng[nBall], trAng;\nbool showFlap;\nconst int nSpir = 3;\nconst float dstFar = 60.;\nconst float pi = 3.14159;\n\nfloat TrackDf (vec3 p, float dHit)\n{\n  vec3 q, qq;\n  vec2 b;\n  float d, tw;\n  float i2 = 1. \/ sqrt (2.);\n  float hTrk = 0.25;\n  float rTrk = 0.3;\n  float dpTrk = 0.3;\n  float wWid = 0.1;\n  float wdTrk = 2.3;\n  float posSpir = posLin + radSpir;\n  vec3 sn = sign (p);\n  q = p;\n  q.xz -= posSpir * sn.xz;\n  qq = q;\n  qq.xz = sn.z * (qq.xz * vec2 (i2, i2) + sn.x * qq.zx * vec2 (- i2, i2));\n  qq.y -= 0.5 * (atan (qq.z, - sn.z * sn.x * qq.x) \/ pi - fnSpir +\n     0.25 * sn.z + 0.5) * dhSpir - hTrk;\n  tw = (length (qq.xz) - radSpir) \/ wdTrk;\n  for (int j = 0; j <= nSpir; j ++) {\n    d = length (vec2 (tw, qq.y)) - rTrk;\n    b = vec2 (abs (tw) - (rTrk - wWid), abs (qq.y - hTrk) - dpTrk);\n    d = max (d, - (min (max (b.x, b.y), 0.) + length (max (b, 0.))));\n    d = max (d, abs (q.y) - (0.5 * fnSpir + 0.2) * dhSpir);\n    if (j == 0) d = max (d, - PrBoxDf (p + vec3 (0., 0.5 * fnSpir * dhSpir, 0.),\n       vec3 (2. * posSpir, 2.2 * hTrk, posSpir)));\n    else if (j == nSpir) d = max (d, - sn.x * q.x);\n    if (d < dHit) {\n      dHit = d;  idObj = 1;\n    }\n    qq.y -= dhSpir;\n  }\n  q = p;\n  q.y += 0.1 * dhSpir;\n  for (int k = 0; k <= 1; k ++) {\n    qq = q;\n    if (k == 0) {\n      qq.y -= 0.5 * fnSpir * dhSpir;\n    } else {\n      qq.xz = qq.zx;\n      qq.y += 0.5 * (fnSpir - 0.5) * dhSpir;\n    }\n    qq.z = abs (qq.z) - posLin;\n    tw = qq.z \/ wdTrk;\n    d = length (vec2 (tw, qq.y)) - rTrk;\n    b = vec2 (abs (tw) - (rTrk - wWid), abs (qq.y - hTrk) - dpTrk);\n    d = max (d, - (min (max (b.x, b.y), 0.) + length (max (b, 0.))));\n    d = max (d, abs (qq.x) - posSpir);\n    if (d < dHit) {\n      dHit = d;  idObj = 1;\n    }\n  }\n  q = p;\n  q.xz = abs (q.xz) - posLin - radSpir;\n  d = PrCylDf (q.xzy, 0.1 * radSpir, 0.5 * fnSpir * dhSpir);\n  if (d < dHit) {\n    dHit = d;  idObj = 2;\n  }\n  q.y -= 0.1 * dhSpir;\n  q.y += 0.5 * (fnSpir - 0.5) * dhSpir;\n  float cl = 0.5 * (radSpir - 0.25 * wdTrk);\n  for (int j = 0; j < nSpir; j ++) {\n    qq = q;\n    qq.z -= cl;\n    d = PrCylDf (qq, 0.03 * radSpir, cl);\n    if (d < dHit) {\n      dHit = d;  idObj = 2;\n    }\n    qq.y -= 0.5 * dhSpir;\n    qq.z += 2. * cl;\n    d = PrCylDf (qq, 0.03 * radSpir, cl);\n    if (d < dHit) {\n      dHit = d;  idObj = 2;\n    }\n    q.y -= dhSpir;\n  }\n  q = p;\n  q.y += 0.5 * (fnSpir * dhSpir - wdTrk);\n  q.x = abs (q.x) - posLin;\n  d = PrTorusDf (q.yxz, 0.07 * radSpir, 0.5 * wdTrk);\n  if (d < dHit) {\n    dHit = d;  idObj = 3;\n  }\n  if (showFlap) {\n    d = max (PrCylDf (q.yxz, 0.5 * wdTrk, 0.03 * radSpir), - q.y - 0.2 * wdTrk);\n    if (d < dHit) {\n      dHit = d;  idObj = 3;\n    }\n  }\n  q = p - vec3 (0., - 0.5 * fnSpir * dhSpir - 0.2, 0.);\n  d = PrBoxDf (q, vec3 (posLin + 2. * radSpir, 0.2, posLin + 2. * radSpir));\n  if (d < dHit) {\n    dHit = d;  idObj = 4;  qHit = q;\n  }\n  return dHit;\n}\n\nvec3 BallPos (int k)\n{\n  float ht = 0.5 * fnSpir * dhSpir;\n  float htSeg = (2. * ht - 0.25 * dhSpir) \/ dRotSeg;\n  float htd = ht - 0.25 * dhSpir;\n  float posSpir = posLin + radSpir;\n  float da = (2. * fnSpir - 0.5) * pi \/ dRotSeg;\n  float dLRSeg = 0.25 * lenPath;\n  float d = mod (tCur * rollVel + lenPath * float (k) \/ float (nBall), lenPath);\n  trAng = mod (d \/ ballRad, 2. * pi);\n  trNv = vec3 (0.);\n  vec3 p = vec3 (0.);\n  float a;\n  if (d < 2. * dLRSeg) {\n    if (d < dLinSeg) {\n      p = vec3 (- posSpir + d, htd, posLin);\n      trNv.z = -1.;\n    } else if (d < dLRSeg) {\n      d -= dLinSeg;\n      a = d * da - 0.5 * pi;\n      trNv.xz = vec2 (cos (a), sin (a));\n      p.xz = vec2 (posSpir, posSpir) + radSpir * trNv.xz;\n      p.y = htd - d * htSeg;\n    } else if (d < dLinSeg + dLRSeg) {\n      d -= dLRSeg;\n      p = vec3 (posLin, - ht, posSpir - d);\n      trNv.x = -1.;\n    } else {\n      d -= dLinSeg + dLRSeg;\n      a = d * da + pi;\n      trNv.xz = vec2 (cos (a), sin (a));\n      p.xz = vec2 (posSpir, - posSpir) + radSpir * trNv.xz;\n      p.y = - ht + d * htSeg;\n    }\n  } else {\n    d -= 2. * dLRSeg;\n    if (d < dLinSeg) {\n      p = vec3 (posSpir - d, htd, - posLin);\n      trNv.z = 1.;\n    } else if (d < dLRSeg) {\n      d -= dLinSeg;\n      a = d * da - 0.5 * pi;\n      trNv.xz = - vec2 (cos (a), sin (a));\n      p.xz = - vec2 (posSpir, posSpir) + radSpir * trNv.xz;\n      p.y = htd - d * htSeg;\n    } else if (d < dLinSeg + dLRSeg) {\n      d -= dLRSeg;\n      p = vec3 (- posLin, - ht, - posSpir + d);\n      trNv.x = 1.;\n    } else {\n      d -= dLinSeg + dLRSeg;\n      a = d * da + pi;\n      trNv.xz = - vec2 (cos (a), sin (a));\n      p.xz = vec2 (- posSpir, posSpir) + radSpir * trNv.xz;\n      p.y = - ht + d * htSeg;\n    }\n  }\n  p.y += 1.75 * ballRad;\n  return p;\n}\n\nfloat BallDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d;\n  q = p - bPos[0];  d = PrSphDf (q, ballRad);\n  if (d < dHit) {\n    dHit = d;  idObj = 5;  trNv = bNv[0];  trAng = bAng[0];  qHit = q;\n  }\n  q = p - bPos[1];  d = PrSphDf (q, ballRad);\n  if (d < dHit) {\n    dHit = d;  idObj = 5;  trNv = bNv[1];  trAng = bAng[1];  qHit = q;\n  }\n  q = p - bPos[2];  d = PrSphDf (q, ballRad);\n  if (d < dHit) {\n    dHit = d;  idObj = 5;  trNv = bNv[2];  trAng = bAng[2];  qHit = q;\n  }\n  q = p - bPos[3];  d = PrSphDf (q, ballRad);\n  if (d < dHit) {\n    dHit = d;  idObj = 5;  trNv = bNv[3];  trAng = bAng[3];  qHit = q;\n  }\n  q = p - bPos[4];  d = PrSphDf (q, ballRad);\n  if (d < dHit) {\n    dHit = d;  idObj = 5;  trNv = bNv[4];  trAng = bAng[4];  qHit = q;\n  }\n  q = p - bPos[5];  d = PrSphDf (q, ballRad);\n  if (d < dHit) {\n    dHit = d;  idObj = 5;  trNv = bNv[5];  trAng = bAng[5];  qHit = q;\n  }\n  q = p - bPos[6];  d = PrSphDf (q, ballRad);\n  if (d < dHit) {\n    dHit = d;  idObj = 5;  trNv = bNv[6];  trAng = bAng[6];  qHit = q;\n  }\n  q = p - bPos[7];  d = PrSphDf (q, ballRad);\n  if (d < dHit) {\n    dHit = d;  idObj = 5;  trNv = bNv[7];  trAng = bAng[7];  qHit = q;\n  }\n  return dHit;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dHit = dstFar;\n  dHit = TrackDf (p, dHit);\n  dHit = BallDf (p, dHit);\n  return dHit;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  const float dTol = 0.001;\n  float d;\n  float dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < dTol || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  float v0 = ObjDf (p + e.xxx);\n  float v1 = ObjDf (p + e.xyy);\n  float v2 = ObjDf (p + e.yxy);\n  float v3 = ObjDf (p + e.yyx);\n  return normalize (vec3 (v0 - v1 - v2 - v3) + 2. * vec3 (v1, v2, v3));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh = 1.;\n  float d = 0.05;\n  for (int i = 0; i < 100; i++) {\n    float h = ObjDf (ro + rd * d);\n    sh = min (sh, 20. * h \/ d);\n    d += 0.05;\n    if (h < 0.001) break;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao = 0.;\n  for (int i = 0; i < 8; i ++) {\n    float d = 0.1 + float (i) \/ 8.;\n    ao += max (0., d - 3. * ObjDf (ro + rd * d));\n  }\n  return clamp (1. - 0.1 * ao, 0., 1.);\n}\n\nvec4 BallCol ()\n{\n  vec3 col;\n  vec3 q = qHit;\n  float aa = atan (trNv.x, trNv.z);\n  q.xz = q.xz * cos (aa) * vec2 (1., 1.) + q.zx * sin (aa) * vec2 (-1., 1.);\n  if (q.z * (mod (pi + atan (q.x, q.y) + trAng, 2. * pi) - pi) > 0.)\n     col = vec3 (0., 0.6, 0.);\n  else col = vec3 (0.6, 0., 0.);\n  return vec4 (col, 2.);\n}\n\nvec3 WoodCol (vec3 p, vec3 n)\n{\n  p *= 4.;\n  float f = dot (vec3 (Fbm2 (p.yz * vec2 (1., 0.1)),\n     Fbm2 (p.zx * vec2 (1., 0.1)), Fbm2 (p.yx * vec2 (1., 0.1))), abs (n));\n  return 0.5 * mix (vec3 (0.8, 0.4, 0.2), vec3 (0.45, 0.25, 0.1), f);\n}\n\nvec4 ObjCol (vec3 n)\n{\n  vec4 col4;\n  if (idObj == 1) col4 = vec4 (0., 0.6, 0.6, 1.);\n  else if (idObj == 2) col4 = vec4 (0.5, 0.3, 0., 3.);\n  else if (idObj == 3) col4 = vec4 (0.5, 0.5, 0., 3.);\n  else if (idObj == 4) col4 = vec4 (WoodCol (qHit, n), 1.);\n  else if (idObj == 5) col4 = BallCol ();\n  return col4;\n}\n\nvoid BallPM ()\n{\n  float dGap = lenPath \/ float (nBall);\n  float db = tCur * rollVel;\n  showFlap = true;\n  for (int nb = 0; nb < nBall; nb ++) {\n    if (abs (abs (mod (db, lenPath) - (2.5 * dLinSeg + 2. * dRotSeg)) -\n       (dLinSeg + dRotSeg)) < 3. * ballRad) showFlap = false;\n    db += dGap;\n  }\n  bPos[0] = BallPos (0);  bNv[0] = trNv;  bAng[0] = trAng;\n  bPos[1] = BallPos (1);  bNv[1] = trNv;  bAng[1] = trAng;\n  bPos[2] = BallPos (2);  bNv[2] = trNv;  bAng[2] = trAng;\n  bPos[3] = BallPos (3);  bNv[3] = trNv;  bAng[3] = trAng;\n  bPos[4] = BallPos (4);  bNv[4] = trNv;  bAng[4] = trAng;\n  bPos[5] = BallPos (5);  bNv[5] = trNv;  bAng[5] = trAng;\n  bPos[6] = BallPos (6);  bNv[6] = trNv;  bAng[6] = trAng;\n  bPos[7] = BallPos (7);  bNv[7] = trNv;  bAng[7] = trAng;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, objCol;\n  float dstHit;\n  vec3 col = vec3 (0., 0., 0.02);\n  BallPM ();\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  int idObjT = idObj;\n  if (idObj < 0) dstHit = dstFar;\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    vec4 col4 = ObjCol (vn);\n    objCol = col4.xyz;\n    float spec = col4.w;\n    float dif = max (dot (vn, ltDir), 0.);\n    float ao = ObjAO (ro, vn);\n    col = objCol * (0.2 * ao * (1. +\n       max (dot (vn, - normalize (vec3 (ltDir.x, 0., ltDir.z))), 0.)) +\n       max (0., dif) * ObjSShadow (ro, ltDir) *\n       (dif + ao * spec * pow (max (0., dot (ltDir, reflect (rd, vn))), 64.)));\n  }\n  col = sqrt (clamp (col, 0., 1.));\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy \/ iResolution.xy - 1.;\n  uv.x *= iResolution.x \/ iResolution.y;\n  float zmFac = 4.2;\n  tCur = iGlobalTime;\n  fnSpir = float (nSpir);\n  posLin = 1.5;\n  radSpir = 3.;\n  dhSpir = 2.5;\n  rollVel = 2.;\n  dLinSeg = 2. * (posLin + radSpir);\n  dRotSeg = length (vec2 (2. * pi * (fnSpir - 0.25) * radSpir,\n     (fnSpir - 0.25) * dhSpir));\n  lenPath = 4. * (dLinSeg + dRotSeg);\n  ballRad = 0.6;\n  ballRad = lenPath \/ (2. * pi * floor (lenPath \/ (2. * pi * ballRad)));\n  float dist = 15. + 7.5 * fnSpir;\n  float el = 0.1;\n  float az = 0.;\n  el += 0.4 * SmoothBump (5., 25., 5., mod (tCur, 40.));\n  az += mod (0.1 * tCur, 2. * pi);\n  float cEl = cos (el);\n  float sEl = sin (el);\n  float cAz = cos (az);\n  float sAz = sin (az);\n  vuMat = mat3 (1., 0., 0., 0., cEl, - sEl, 0., sEl, cEl) *\n     mat3 (cAz, 0., sAz, 0., 1., 0., - sAz, 0., cAz);\n  vec3 rd = normalize (vec3 (uv, zmFac)) * vuMat;\n  vec3 ro = - vec3 (0., 0., dist) * vuMat;\n  ro.y -= 0.03 * dist;\n  ltDir = normalize (vec3 (0.3, 0.5, -1.)) * vuMat;\n  vec3 col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n","name":"","description":"","type":"image"}]}}