{"Shader":{"ver":"0.1","info":{"id":"4sV3zm","date":"1453810828","viewed":299,"name":"Affine Arithmetic Joint Range","username":"paniq","description":"visualizing the joint and zero crossing range of 1D revised affine arithmetic operations; drag the mouse to change the search width. Intervals are drawn in purple, affine forms in orange.","likes":9,"published":3,"flags":0,"tags":["arithmetic","affine","revised","joint","range"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ undefine if you are running on glslsandbox.com\n\/\/ #define GLSLSANDBOX\n\n#ifdef GLSLSANDBOX\n#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define iGlobalTime time\n#define iResolution resolution\n#define iMouse mouse\n#endif\n\n\/\/ Revised Affine Arithmetic\n\/\/ based on the implementation guide contained in\n\/\/ Fast Reliable Interrogation of Procedurally Defined \n\/\/  \tImplicit Surfaces Using Extended Revised Affine Arithmetic\n\/\/ by Fryazinov, Pasko et al\n\n\/\/ revised affine form of rank 3\nstruct raf3 {\n    float x0;\n    vec3 xi;\n    float e;\n};\n   \nraf3 ra_const(float x) {\n    return raf3(x, vec3(0.0), 0.0);\n}\nfloat ra_radius(raf3 a) {\n    vec3 s = abs(a.xi);\n    return s.x + s.y + s.z + a.e;\n}\nvec2 ra_interval(raf3 a) {\n    float r = ra_radius(a);\n    return vec2(a.x0 - r, a.x0 + r);\n}\n    \nraf3 ra_add(raf3 a, raf3 b) {\n\treturn raf3(a.x0 + b.x0, a.xi + b.xi, a.e + b.e);\n}\nraf3 ra_add(raf3 a, float b) {\n\treturn raf3(a.x0 + b, a.xi, a.e);\n}\nraf3 ra_add(float a, raf3 b) {\n\treturn raf3(a + b.x0, b.xi, b.e);\n}\n\nraf3 ra_sub(raf3 a, raf3 b) {\n\treturn raf3(a.x0 - b.x0, a.xi - b.xi, a.e + b.e);\n}\nraf3 ra_sub(raf3 a, float b) {\n\treturn raf3(a.x0 - b, a.xi, a.e);\n}\nraf3 ra_sub(float a, raf3 b) {\n\treturn raf3(a - b.x0, -b.xi, b.e);\n}\n\nraf3 ra_unm(raf3 a) {\n\treturn raf3(-a.x0, -a.xi, a.e);\n}\n\nraf3 ra_mul(raf3 a, raf3 b) {\n    vec3 s = abs(a.xi);\n    vec3 t = abs(b.xi);\n    float w = dot(a.xi, b.xi);\n    float u = s.x + s.y + s.z;\n    float v = t.x + t.y + t.z;\n    return raf3(\n        a.x0 * b.x0 + 0.5 * w,\n        a.x0 * b.xi + a.xi * b.x0,\n        a.e * b.e\n        + b.e * (abs(a.x0) + u)\n        + a.e * (abs(b.x0) + v)\n        + u * v\n        - 0.5 * dot(s, t));\n}\t\t\nraf3 ra_mul(raf3 a, float b) {\n    return raf3(\n        a.x0 * b,\n        a.xi * b,        \n        a.e * abs(b));\n}\t\t\nraf3 ra_mul(float a, raf3 b) {\n    return ra_mul(b, a);\n}\n\nraf3 ra_pow2(raf3 a) {\n    vec3 s = abs(a.xi);\n    float w = dot(a.xi, a.xi);\n    float u = s.x + s.y + s.z;\n    return raf3(\n        a.x0 * a.x0 + 0.5 * w,\n        2.0 * a.x0 * a.xi,\n        a.e * (1.0 + 2.0 * (abs(a.x0) + u))\n        + u * u\n        - 0.5 * w);\n}\n\nraf3 ra_sqrt(raf3 x) {\n    vec2 i = ra_interval(x);\n    if (i[1] < 0.0) return ra_const(0.0);\n    i[0] = max(i[0], 0.0);\n    vec2 sq = sqrt(i);\n    float c = sq[1] + sq[0];\n    float h = sq[1] - sq[0];\n    float alpha = 1.0 \/ c;\n    float dzeta = c \/ 8.0 + 0.5 * sq[0] * sq[1] \/ c;\n    float delta = h * h \/ (8.0 * c);\n    return raf3(\n        alpha * x.x0 + dzeta,\n        alpha * x.xi,\n        alpha * x.e + delta);\n}\n\nraf3 ra_abs (raf3 a) {\n    vec2 i = ra_interval(a);\n    if (i[0]*i[1] >= 0.0) {\n        return raf3(abs(a.x0), a.xi * sign(a.x0), a.e);\n    } else {\n        vec2 ab = abs(i);        \n        float alpha = (ab[1] - ab[0]) \/ (i[1] - i[0]);\n        float zeta = (ab[0] - i[0] * alpha) * 0.5;\n        float delta = zeta;\n        \n        return raf3(\n            alpha * a.x0 + zeta, \n            alpha * a.xi, \n            abs(alpha) * a.e + delta);\n    }\n}\n\n\/\/ crude approximation for min\/max\n\/\/ there are more opportunities for truncation here, as only\n\/\/ the overlapping parallelogram and either one or both top parts (max)\n\/\/ or bottom parts (min) of each argument need to be bounded.\n\/\/ e.g. if all minimum values of a are above the minimum values of b, \n\/\/ regardless of any overlapping, only a needs to be considered for max(a,b).\n\nraf3 ra_max(raf3 a, raf3 b) {\n    vec2 ia = ra_interval(a);\n    vec2 ib = ra_interval(b);\n    if (ia[0] >= ib[1])\n        return a;\n    else if (ib[0] >= ia[1])\n        return b;\n    else {\n\t    return ra_mul(ra_add(ra_add(a,b),ra_abs(ra_sub(a, b))),0.5);\n    }\n}\n\nraf3 ra_min(raf3 a, raf3 b) {\n    vec2 ia = ra_interval(a);\n    vec2 ib = ra_interval(b);\n    if (ia[1] <= ib[0])\n        return a;\n    else if (ib[1] <= ia[0])\n        return b;\n    else {\n\t    return ra_mul(ra_sub(ra_add(a,b),ra_abs(ra_sub(a, b))),0.5);\n    }\n}\n\n\/\/ interface\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ set color source for stroke \/ fill \/ clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source(sampler2D image);\n\/\/ if enabled, blends using premultiplied alpha instead of\n\/\/ regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n\/\/ set line width in normalized units for stroke\nvoid set_line_width(float w);\n\/\/ set line width in pixels for stroke\nvoid set_line_width_px(float w);\n\/\/ set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n\/\/ add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n\/\/ add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n\n\/\/ set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n\/\/ draw straight line from starting point to P,\n\/\/ and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n\/\/ draw quadratic bezier curve from starting point\n\/\/ over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n\/\/ connect current starting point with first\n\/\/ drawing point.\nvoid close_path();\n\n\/\/ clear screen in the current source color\nvoid clear();\n\/\/ fill paths and clear the path buffer\nvoid fill();\n\/\/ fill paths and preserve them for additional ops\nvoid fill_preserve();\n\/\/ stroke paths and clear the path buffer\nvoid stroke_preserve();\n\/\/ stroke paths and preserve them for additional ops\nvoid stroke();\n\/\/ clears the path buffer\nvoid new_path();\n\n\/\/ return rgb color for given hue (0..1)\nvec3 hue(float hue);\n\/\/ return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n\/\/ rotate the context by A in radians\nvoid rotate(float a);\n\/\/ uniformly scale the context by S\nvoid scale(float s);\n\/\/ translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n\/\/ clear all transformations for the active context\nvoid identity_matrix();\n\/\/ transform the active context by the given matrix\nvoid transform(mat3 mtx);\n\/\/ set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n\/\/ return the active query position for in_fill\/in_stroke\n\/\/ by default, this is the mouse position\nvec2 get_query();\n\/\/ set the query position for subsequent calls to\n\/\/ in_fill\/in_stroke; clears the query path\nvoid set_query(vec2 p);\n\/\/ true if the query position is inside the current path\nbool in_fill();\n\/\/ true if the query position is inside the current stroke\nbool in_stroke();\n\n\/\/ return the transformed coordinate of the current pixel\nvec2 get_origin();\n\/\/ draw a 1D graph from coordinate p, result f(p.x),\n\/\/ and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n\/\/ draw a 2D graph from coordinate p, result f(p),\n\/\/ and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n\/\/ adds a custom distance field as path\n\/\/ this field will not be testable by queries\nvoid add_field(float c);\n\n\/\/ returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) \/ (2.0*get_gradient_eps())\n\/\/ returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) \/ (2.0*get_gradient_eps())\n\/\/ draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n\/\/ draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n\/\/ represents the current drawing context\n\/\/ you usually don't need to change anything here\nstruct Context {\n    \/\/ screen position, query position\n    vec4 position;\n    vec2 shape;\n    float scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n};\n    \n\/\/ save current source color, stroke width and starting\n\/\/ point from active context.\nContext save();\n\/\/ restore source color, stroke width and starting point\n\/\/ to a context previously returned by save()\nvoid restore(Context ctx);\n\n\/\/ draws a half-transparent debug gradient for the\n\/\/ active path\nvoid debug_gradient();\n\/\/ returns the gradient epsilon width\nfloat get_gradient_eps();\n\n\/\/ your draw calls here\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nraf3 ra_myf(raf3 a) {\n    raf3 o = a;\n    a = ra_add(a, sin(iGlobalTime * 0.1));\n    \n    a = ra_pow2(a);\n    \n    a = ra_max(o,ra_abs(ra_sub(a, 0.5)));\n    \n    return ra_sub(a,cos(iGlobalTime * 0.17)*0.5+0.5);\n}\n\nfloat myf(float x) {\n    \/\/return sin(x) * cos((x + iGlobalTime * 0.2) * 20.0);\n    return ra_myf(ra_const(x)).x0;\n}\n\nvoid paint() {\n    float t = iGlobalTime;\n    \n    \/\/ clear screen\n    \n    set_source_rgb(vec3(0.0,0.0,0.5));\n    clear();\n\n    float w = (iMouse.z > 0.5)?abs(get_query().x):0.5;\n    \n    vec2 p = get_origin();\n    float i0 = p.x - mod(p.x, w);\n    float i1 = i0 + w;  \n    \n    \n    raf3 ax = raf3((i1 + i0)*0.5, vec3((i1 - i0)*0.5,0.0,0.0), 0.0);\n    raf3 ay = ra_myf(ax);\n    \n    \/\/ grid\n    move_to(i0, -1.0);\n    line_to(i0, 1.0);\n    move_to(i1, -1.0);\n    line_to(i1, 1.0);\n    move_to(i0, 0.0);\n    line_to(i1, 0.0);\n    set_line_width_px(1.0);\n    set_source_rgba(hsl(0.5,1.0,0.8,0.3));\n    stroke();\n\n    \/\/ visualize interval\n    vec2 iv = ra_interval(ay);\n    \/\/ interval crosses zero?\n    bool crossing = (iv.x*iv.y < 0.0);\n    \n    rectangle(i0,iv.x,w,(iv.y - iv.x));\n    set_source_rgba(hsl(0.9,1.0,0.5,crossing?0.5:0.2));\n    fill();\n    \n    \/\/ visualize minkowski sum of affine segments\n    \/\/ after the description given in\n    \/\/ An Introduction to Affine Arithmetic\n    \/\/ by stolfi et al.\n    vec2 c = vec2(ax.x0,ay.x0);\n    vec2 d = vec2(ax.xi.x, ay.xi.x);\n    vec2 e = vec2(ax.e, ay.e);\n    \n    vec2 c0 = c - d - e;\n    vec2 c1 = c + d - e;\n    vec2 c2 = c - d + e;\n    vec2 c3 = c + d + e;\n    \n    move_to(c0);\n    line_to(c1);\n    move_to(c2);\n    line_to(c3);\n    close_path();\n    set_source_rgba(hsl(0.1,1.0,0.5,1.0));\n    set_line_width_px(1.0);\n    stroke();\n    \n    \/\/ draw 1D graph\n    graph1D(myf);\n    \/\/ graphs only look good at pixel size\n    set_line_width_px(1.0);\n    set_source_rgb(vec3(1.0));\n    stroke();\n    \n\t\/\/ draw intersections with zero plane\n    float dxdy = ax.xi.x \/ ay.xi.x;\n    float a0 = ay.xi.x - ay.x0;\n    float r0 = i0 + dxdy * (a0 + ay.e);\n    float r1 = i0 + dxdy * (a0 - ay.e);\n    move_to(r0,0.0);\n    line_to(r1,0.0);\n    set_source_rgba(hsl(0.0,1.0,0.5,1.0));\n    set_line_width_px(2.0);\n    stroke();\n    \n}\n\n\/\/ implementation\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec2 aspect = vec2(iResolution.x \/ iResolution.y, 1.0);\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH = min(iResolution.x,iResolution.y);\nfloat AA = ScreenH*0.4;\nfloat AAINV = 1.0 \/ AA;\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec3 hue(float hue) {\n    return clamp( \n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, \n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define DEFAULT_SHAPE_V 1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    uv = fragCoord.xy \/ iResolution.xy;\n    vec2 m = iMouse.xy \/ iResolution.xy;\n    \n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n    \n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        1.0,\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0)\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n}\n\nContext save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    \/\/ preserve shape\n    vec2 shape = _stack.shape;    \n    _stack = ctx;\n    _stack.shape = shape;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 \/ d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = 1.0;\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;    \n    _stack.scale = length(vec2(mtx[0].x,mtx[1].y));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    vec2 u = vec2(mtx[0].x, mtx[1].x);\n    _stack.scale *= length(u);\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(float s) {\n    transform(mat3(s,0.0,0.0,0.0,s,0.0,0.0,0.0,1.0));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(_color, 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_field(vec2 d) {\n    d = d \/ _stack.scale;\n    _stack.shape = min(_stack.shape, d);    \n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n}\n\nvoid debug_gradient() {\n    _color = mix(_color, \n        hsl(_stack.shape.x * 6.0, \n            1.0, (_stack.shape.x>=0.0)?0.5:0.3), \n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;    \n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA, 0.0, 1.0);\n    float wb = clamp(-w \/ blur.x + blur.y, 0.0, 1.0);    \n\treturn wa * wb; \/\/min(wa,wb);    \n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*_stack.scale\/AA;\n}\n\nfloat get_gradient_eps() {\n    return _stack.scale\/AA;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width\/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    _stack.source = c;\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) { \n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture2D(image, _stack.position.xy));\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    s*=0.5;\n    o += s;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    add_field(max(dmin.xz, dmin.yw) + length2(dmax));\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rectangle(vec2(ox,oy), vec2(sx,sy));\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n\/\/ stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)\/dot(ba,ba), 0.0, 1.0);\n    add_field(length2(pa - ba.xyxy*h.xxyy));\n    \n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n\/\/ from https:\/\/www.shadertoy.com\/view\/ltXSDB\n\n\/\/ Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a \/ 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) \/ 27.0 + c;\n    float d = q*q + 4.0*p3 \/ 27.0;\n    float offset = -a \/ 3.0;\n    if(d >= 0.0) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) \/ 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0\/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 \/ p3) * q \/ 2.0) \/ 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p \/ 3.0) + offset;\n}\n\n\/\/ Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{    \n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) \/ dot(b,b);      \n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis; \/\/ * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    add_field(vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw)));\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) \/ sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) \/ length(df_x));\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init(fragCoord);\n    \n    paint();\n    \n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n","name":"","description":"","type":"image"}]}}