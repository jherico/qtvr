{"Shader":{"ver":"0.1","info":{"id":"ltXXRS","date":"1437483965","viewed":727,"name":"simulating collisions - partics","username":"FabriceNeyret2","description":"like https:\/\/www.shadertoy.com\/view\/4tfSzS but without array (bricks in grid are encoded as a list of particles)  -> a lot more more efficient !<br\/>see also https:\/\/www.shadertoy.com\/view\/llfXRS with sorted particles: even more efficient !","likes":1,"published":3,"flags":0,"tags":["simulation"],"hasliked":0},"renderpass":[{"inputs":[{"id":1,"src":"\/presets\/tex00.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":9,"src":"\/presets\/tex08.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":10,"src":"\/presets\/tex09.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ array implementation: https:\/\/www.shadertoy.com\/view\/4tfSzS . so slowwww...\n\/\/ here: simple brick particles (https:\/\/www.shadertoy.com\/view\/ltXXRS)\n\/\/ sorted particles: https:\/\/www.shadertoy.com\/view\/llfXRS . the best !\n\nfloat time = floor(4.*iGlobalTime);\nfloat T    = mod(time,48.);\nfloat cycl = time-T-827.31; \/\/ floor(time\/48.);\n\nfloat rnd(float x) { return fract(1345.56*sin(876.654*x)); }\nfloat rnd(int i, int j) { return rnd(float(i)-47.45*float(j)); }\n\n#define N (30*20\/10)\nivec2 grid[N];\n\n#define valid(x,y) ( x>=0 && x<20 && y>=0 && y<30 )\n\n\n\/\/ --- value of grid(y,x)\nint testGrid(int y, int x) { \/\/ test collision with grid-aligned brick-particles\n    \/\/return 0;\n    if ( !valid(x,y) ) return -1; \n      for (int i=0; i<N; i++)\n          if (grid[i].y==y && grid[i].x==x) return 1;\n    return 0;\n}\n\n\nvoid mainImage( out vec4 f, vec2 uv )\n{\n    vec2 r = iResolution.xy;\n\tuv = (2.*uv-r) \/ r.y; uv.y = -uv.y;\n\n    \/\/ --- init grid \n    for (int i=0; i<N; i++)\n        grid[i] = ivec2(20.*rnd(float(i)),30.*rnd(float(i)-7.6543));    \n    \n    \/\/ --- init particle\n \tivec2 p, pos = ivec2(10,0), vel=ivec2(0,1);\n\n    \/\/ --- simulation\n    \/\/ horribly greedy : yes, it replays whole time & pos for each pixel at each frame \n    for (float t=0.; t<48.; t++)\n        if (t>T) break; \/\/ future must be kept unknown for the sake of human beings. \n        else {\n            p = pos+vel; \/\/ target new position\n            p.x = p.x<0 ? 19 : p.x >19 ? 0 : p.x; \/\/ cyclical world\n            p.y = p.y<0 ? 29 : p.y >29 ? 0 : p.y;\n            if (testGrid(p.y,p.x)==0) \/\/ free space on trajectory: go, go !\n            { pos = p; vel = ivec2(0,1);}\n            else vel= ivec2(rnd(t+cycl)<.5?-1:1 ,0); \/\/ blocked: jiggle around\n        }\n    \n    \/\/ --- display\n    vec2 fuv = (uv-vec2(-.666,-1))\/2.*30.; \/\/ 20x30 grid, centered, (0,0) top left\n    ivec2 iuv = ivec2(fuv);\n    \n    int v = testGrid(iuv.y,iuv.x); \n    \n    \/\/ out of playfield\n    if (v<0) {  \n\t    \/\/ f = vec4(.5); \n    \tf = .2+.2*texture2D(iChannel1,uv);\n        return;\n    }\n   \n    \/\/ display blocks\n    \/\/ f = vec4(v);\n   \tif (v==0) f = .3*texture2D(iChannel2,uv); else f = texture2D(iChannel0,uv*2.5);\n       \n    \/\/ display particle\n    \/\/if ((pos.x==iuv.x) && (pos.y==iuv.y) )f = vec4(1,0,0,0);\n    f = mix(f, vec4(1,0,T\/48.,0), smoothstep(.5,.4,length(vec2(pos)+.5-fuv)));\n}","name":"","description":"","type":"image"}]}}