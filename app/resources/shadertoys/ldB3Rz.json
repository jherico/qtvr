{"Shader":{"ver":"0.1","info":{"id":"ldB3Rz","date":"1401316141","viewed":1018,"name":"Larval","username":"P_Malin","description":"Some kind of alien fractal thingy.<br\/>A hacked together KIFS doodle.<br\/>The fractal parameters aren't that exciting but I like the pretty colours <img src=\"\/img\/emoticonLaugh.png\"\/>","likes":23,"published":3,"flags":0,"tags":["glow","kifs"],"hasliked":0},"renderpass":[{"inputs":[{"id":22,"src":"\/presets\/cube00_0.jpg","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Larval - @P_Malin\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ \n\/\/ Some kind of alien fractal thingy.\n\/\/ A hacked together KIFS doodle.\n\/\/ The fractal parameters aren't that exciting but I like the pretty colours :D\n\n#define kRaymarchIterations 24\n#define kIFSIterations 16\n\nvec3 vGlowColour = vec3(1.0, 0.075, 0.01) * 5.0;\nvec3 vEnvColour = vec3(0.1, 0.5, 1.0) * 2.0;\n\nfloat kExposure = 0.1;\n\n\/\/ KIFS parameters\nconst float fScale=1.25;\nvec3 vOffset = vec3(-1.0,-2.0,-0.2);\t\nmat3 m;\n\nconst float kFarClip = 30.0;\n\nvec2 GetSceneDistance( in vec3 vPos )\n{\n\tfloat fTrap = kFarClip;\n\t\n\tfloat fTotalScale = 1.0;\n\tfor(int i=0; i<kIFSIterations; i++)\n\t{\t\n\t\tvPos.xyz = abs(vPos.xyz);\n\t\tvPos *= fScale;\n\t\tfTotalScale *= fScale;\n\t\tvPos += vOffset;\n\t\tvPos.xyz = (vPos.xyz) * m;\n\t\t\n\t\tfloat fCurrDist = length(vPos.xyz) * fTotalScale;\n\t\t\/\/float fCurrDist = max(max(vPos.x, vPos.y), vPos.z) * fTotalScale;\n\t\t\/\/float fCurrDist = dot(vPos.xyz, vPos.xyz);\/\/ * fTotalScale;\t\t\n\t\tfTrap = min(fTrap, fCurrDist);\n\t}\n\n\tfloat l = length(vPos.xyz) \/ fTotalScale;\n\t\n\tfloat fDist = l - 0.1;\n\treturn vec2(fDist, fTrap);\n}\n\nvec4 Raycast( const in vec3 vOrigin, const in vec3 vDir )\n{\n\tfloat fClosest = kFarClip;\n\tvec2 d = vec2(0.0);\n\tfloat t = 0.01;\n\tfor(int i=0; i<kRaymarchIterations; i++)\n\t{\n\t\td = GetSceneDistance(vOrigin + vDir * t);\n\t\tfClosest = min(fClosest, d.x \/ t);\n\t\tif(abs(d.x) < 0.0001)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tt += d.x;\n\t\tif(t > kFarClip)\n\t\t{\n\t\t\tt = kFarClip;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn vec4(t, d.x, d.y, fClosest);\n}\n\nvec3 GetSceneNormal( const in vec3 vPos )\n{\n    const float fDelta = 0.000001;\n\n    vec3 vOffset1 = vec3( fDelta, -fDelta, -fDelta);\n    vec3 vOffset2 = vec3(-fDelta, -fDelta,  fDelta);\n    vec3 vOffset3 = vec3(-fDelta,  fDelta, -fDelta);\n    vec3 vOffset4 = vec3( fDelta,  fDelta,  fDelta);\n\n    float f1 = GetSceneDistance( vPos + vOffset1 ).x;\n    float f2 = GetSceneDistance( vPos + vOffset2 ).x;\n    float f3 = GetSceneDistance( vPos + vOffset3 ).x;\n    float f4 = GetSceneDistance( vPos + vOffset4 ).x;\n\n    vec3 vNormal = vOffset1 * f1 + vOffset2 * f2 + vOffset3 * f3 + vOffset4 * f4;\n\n    return normalize( vNormal );\n}\n\nvec3 TraceRay( const in vec3 vOrigin, const in vec3 vDir )\n{\t\n\tvec4 vHit = Raycast(vOrigin, vDir);\n\t\n\tvec3 vHitPos = vOrigin + vDir * vHit.x;\n\tvec3 vHitNormal = GetSceneNormal(vHitPos);\n\t\n\tfloat fShade = 1.0;\n\tfloat fGlow = 0.0;\n\tvec3 vEnvDir = vDir;\n\tif(vHit.x < kFarClip)\n\t{\n\t\tvEnvDir = reflect(vDir, vHitNormal);\n\t\tfGlow = clamp(vHit.z * 0.1, 0.0, 1.0);\n\t\tfGlow = pow(fGlow, 3.0);\n\t\tfShade = fGlow;\n\t}\n\t\n\tvec3 vEnv = textureCube(iChannel0, vEnvDir).rgb;\n\tvEnv = vEnv * vEnv;\t\n\tvEnv = -log2(1.0 - min(vEnv, 0.99));\n\n\tvEnv *= vEnvColour;\n\t\n\tvec3 vColour = vEnv * (0.25 + fShade * 0.75);\n\t\n\t\/\/ inner glow\n\tif(vHit.x < kFarClip)\n\t{\t\n\t\tvColour += vGlowColour * 10.0 * fGlow;\n\t}\n\n\t\/\/ outer glow\n\t{\t\t\t\t\n\t\tfloat f = 1.0 - clamp(vHit.w * 0.5, 0.0, 1.0);\t\t\n\t\t\n\t\tfloat fGlowAmount = 0.0;\n\t\t\n\t\t\/\/ big glow\n\t\tfloat f1 = pow(f, 20.0);\n\t\tfGlowAmount += f1 * 2.0 * (0.5 + fShade * 0.5);\n\t\n\t\t\/\/ small glow\n\t\tfloat f2 = pow(f, 200.0);\n\t\tfGlowAmount += f2 * 5.0 * fShade;\n\t\t\n\t\tvColour += vGlowColour * fGlowAmount;\n\t}\n\t\n\treturn vColour;\n}\n\n\n\/\/ mat3 from quaternion\nmat3 SetRot( const in vec4 q )\n{\n\tvec4 qSq = q * q;\n\tfloat xy2 = q.x * q.y * 2.0;\n\tfloat xz2 = q.x * q.z * 2.0;\n\tfloat yz2 = q.y * q.z * 2.0;\n\tfloat wx2 = q.w * q.x * 2.0;\n\tfloat wy2 = q.w * q.y * 2.0;\n\tfloat wz2 = q.w * q.z * 2.0;\n \n\treturn mat3 (\t\n     qSq.w + qSq.x - qSq.y - qSq.z, xy2 - wz2, xz2 + wy2,\n     xy2 + wz2, qSq.w - qSq.x + qSq.y - qSq.z, yz2 - wx2,\n     xz2 - wy2, yz2 + wx2, qSq.w - qSq.x - qSq.y + qSq.z );\n}\n\n\/\/ mat3 from axis \/ angle\nmat3 SetRot( vec3 vAxis, float fAngle )\n{\t\n\treturn SetRot( vec4(normalize(vAxis) * sin(fAngle), cos(fAngle)) );\n}\n\nvec3 ApplyPostFx( const in vec3 vIn, const in vec2 fragCoord )\n{\n\tvec2 vUV = fragCoord.xy \/ iResolution.xy;\n\tvec2 vCentreOffset = (vUV - 0.5) * 2.0;\n\t\n\tvec3 vResult = vIn;\n\tvResult.xyz *= clamp(1.0 - dot(vCentreOffset, vCentreOffset) * 0.4, 0.0, 1.0);\n\n\tvResult.xyz = 1.0 - exp(vResult.xyz * -kExposure);\n\t\n\tvResult.xyz = pow(vResult.xyz, vec3(1.0 \/ 2.2));\n\t\n\treturn vResult;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vUV = fragCoord.xy \/ iResolution.xy;\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x \/ iResolution.y;\n\t\n\tvec2 vMouse = iMouse.xy \/ iResolution.xy;\n\t\n\tfloat fHeading = iGlobalTime * 0.21;\n\tfloat fElevation = cos(iGlobalTime * 0.1) * 0.5;\n\tfloat fCameraDistance = 15.0 + sin(iGlobalTime * 0.05) * 5.0;\n\t\n\tfloat fSinElevation = sin(fElevation);\n\tfloat fCosElevation = cos(fElevation);\n\tfloat fSinHeading = sin(fHeading);\n\tfloat fCosHeading = cos(fHeading);\n\t\n\tvec3 vCameraOffset;\n\tvCameraOffset.x = fSinHeading * fCosElevation;\n\tvCameraOffset.y = fSinElevation;\n\tvCameraOffset.z = fCosHeading * fCosElevation;\n\t\n\tvec3 vCameraPos = vCameraOffset * fCameraDistance;\n\n\tvec3 vCameraTarget = vec3(0.0, 0.0, 0.0);\n\t\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\n\tfloat fFov = 2.0;\n\t\n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fFov);\n\t\n\tvec3 vRotationAxis = vec3(1.0, 4.0, 2.0);\n\n\t\/\/ Rotate the rotation axis\n\tmat3 m2 = SetRot( vec3(0.1, 1.0, 0.01), iGlobalTime * 0.3 );\t\t\n\t\n\tvRotationAxis = vRotationAxis * m2;\n\t\n\tfloat fRotationAngle = sin(iGlobalTime * 0.5);\n\t\n\tif( iMouse.z > 0.0 )\n\t{\n\t\tvec2 vMouseOffset = vMouse * 2.0 - 1.0;\n\t\tvRotationAxis = vec3(vMouseOffset.x, 1.0, vMouseOffset.y);\n\t\tfRotationAngle = length(vRotationAxis);\n\t}\n\t\n\tm = SetRot(vRotationAxis, fRotationAngle);\n\t\n\tvec3 vResult = TraceRay(vCameraPos, vDir);\n\t\n\tvResult = ApplyPostFx(vResult,fragCoord);\n\t\n\tfragColor = vec4(vResult,1.0);\n}\n","name":"","description":"","type":"image"}]}}