{"Shader":{"ver":"0.1","info":{"id":"4l2GRW","date":"1427255057","viewed":1468,"name":"mau5head","username":"danyo","description":"My first ray marcher!","likes":10,"published":3,"flags":8,"tags":["raymarchingambientocclusionshadowsaudioghostsnstuff"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define PRECISION 0.0001\n#define DEPTH 20.0\n#define STEPS 125\n#define PI 3.1415926535897932384626433832795\n#define OCCLUSION_SAMPLES 8.0\n#define OCCLUSION_FACTOR .5\n\n#define BPM 128.0\n#define SEC_PER_MIN 60.0\n\nvec3 eye = vec3(0.0);\nvec3 light = vec3(0.0,8.0,8.0);\n#define LIGHT_COLOR vec3(1.0)\n#define LIGHT_AMBIENT vec3(0.05)\n\nmat3 rotmat;\n\nbool hit = false;\nstruct sMaterial\n{\n    float metallic;\n    float roughness;\n    float fresnel_pow;\n    vec3 color;\n};\nsMaterial mat_white = sMaterial(0.0, 5.0, 1.0, vec3(1.0));\nsMaterial mat_red = sMaterial(0.0, 1.0, 1.0, vec3(1.0, 0.0, 0.0));\nstruct sHit\n{\n    float d;\n    sMaterial material;\n};\nsHit map(vec3);\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e=vec2(PRECISION,0);\n    return(normalize(vec3(map(p+e.xyy).d-map(p-e.xyy).d\n                          ,map(p+e.yxy).d-map(p-e.yxy).d\n                          ,map(p+e.yyx).d-map(p-e.yyx).d)));}\n\n\/\/ ROTATION FUNCTIONS TAKEN FROM\n\/\/https:\/\/www.shadertoy.com\/view\/XsSSzG\nmat3 xrotate(float t) {\n\treturn mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrotate(float t) {\n\treturn mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrotate(float t) {\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\n\nmat3 rotate( vec3 r ){\n \n   return xrotate( r.x ) * yrotate( r.y ) * zrotate( r.z );\n    \n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n\t\/\/ c must be normalized\n\tfloat q = length(p.xy);\n\treturn dot(c,vec2(q,p.z));\n}\n\nfloat sdTorus(vec3 p, vec2 t) \n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  \/\/ n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\t\n\/\/ polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)\/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 opCheapBend( vec3 p , float k)\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n\n}\nvec2 hash( vec2 p ) \n{                       \/\/ rand in [-1,1]\n    p = vec2( dot(p,vec2(127.1,311.7)),\n              dot(p,vec2(269.5,183.3)) );\n    return -1. + 2.*fract(sin(p+20.)*53758.5453123);\n}\n\nsHit map( in vec3 p )\n{\n    vec3 q = p*rotmat;\n    \n    \/\/some animation\n    q = q \/ vec3(pow(1.0 + 0.25*sin(PI*fract(iGlobalTime*BPM\/SEC_PER_MIN)),2.0));\n        \n    float mouth = sdTriPrism(zrotate(PI)*q+vec3(-0.866025, -0.5, 0.0), vec2(1.0, 1.5)); \/\/TODO: should be wedge with 50deg edge?\n    \n    float eyes = opU(sdSphere(q+vec3(0.5,-0.5,0.5), 4.5\/14.0),sdSphere(q+vec3(0.5,-0.5,-0.5), 4.5\/14.0));\n    float head = opS(eyes, opS(mouth, sdSphere(q, 1.0)));\n    float teeth = opI(mouth, sdSphere(q, 0.95));\n\n    vec3 ear_p = opCheapBend(q, 0.1); \/\/this causes a strange artifact in soft shadows on my laptop but not my PC?\n    \/\/not sure how to fix it but I like the curved ears too much to remove it\n    float ear_angle = 70.0 * PI\/180.0;\n    vec2 ear_size = vec2(0.9,0.1);\n    float ears_center = opU(sdCappedCylinder(zrotate(ear_angle)*ear_p+vec3(-1.1, 0.0, -1.1), ear_size)\n                     ,sdCappedCylinder(zrotate(ear_angle)*ear_p+vec3(-1.1, 0.0, 1.1), ear_size));\n    float ears_edge = opU(sdTorus(zrotate(ear_angle)*ear_p+vec3(-1.1, 0.0, -1.1), ear_size)\n                     ,sdTorus(zrotate(ear_angle)*ear_p+vec3(-1.1, 0.0, 1.1), ear_size));\n    float ears = opS(head, opU(ears_center,ears_edge));\n    \n    float walls = opU(sdPlane(p + vec3(0.0, 0.0, 4.0), normalize(vec4(0.0, 0.0, 1.0, 1.0)))\n                      ,sdPlane(p + vec3(0.0, 4.0, 0.0), normalize(vec4(0.0, 1.0, 0.0, 1.0)))) + 0.001;\n    \n    float result = 1e10;\n    result = opU(result, head);\n    result = opU(result, teeth);\n    result = opU(result, eyes);\n    result = opU(result, ears);\n    result = opU(result, walls);\n    \n    sHit hit;\n    hit.d = result;\n    if(result == head || result == ears)\n        hit.material = mat_red;\n    else\n        hit.material = mat_white;\n        \n    return hit;\n}\n\nvec3 march( in vec3 ro, in vec3 rd)\n{\n    float t=0.0,d;\n    \n    for(int i=0;i<STEPS;i++)\n    {\n        d=map(ro+rd*t).d;\n        if(abs(d)<PRECISION){hit=true;}\n        if(hit==true||t>DEPTH){break;}\n        t+=d;\n    }\n    \n    return ro+rd*t;\n}\n\nfloat shadow_march( in vec3 ro, in vec3 rd)\n{\n    float t=0.01,d;\n    \n    for(int i=0;i<STEPS;i++)\n    {\n        d = map(ro + rd*t).d;\n        if( d < 0.0001 )\n            return 0.0;\n        t += d;\n    }\n    return 1.0;\n}\n\nfloat soft_shadow_march( in vec3 ro, in vec3 rd, float k)\n{\n    float res = 1.0;\n    float t=0.01;\/\/.0001*sin(PI*fract(iGlobalTime));\n    float d;\n    \n    for(int i=0;i<STEPS;i++)\n    {\n        d = map(ro + rd*t).d;\n        if( d < PRECISION )\n            return 0.0;\n        res = min( res, k*d\/t );\n        t += d;\n    }\n    return res;\n}\n\n\/*  taken from Hamneggs https:\/\/www.shadertoy.com\/view\/4dj3Dw\n\tCalculates the ambient occlusion factor at a given point in space.\n\tUses IQ's marched normal distance comparison technique.\n*\/\nfloat calcOcclusion(vec3 pos, vec3 surfaceNormal)\n{\n\tfloat result = 0.0;\n\tvec3 normalPos = vec3(pos);\n\tfor(float i = 0.0; i < OCCLUSION_SAMPLES; i+=1.0)\n\t{\n\t\tnormalPos += surfaceNormal * (1.0\/OCCLUSION_SAMPLES);\n\t\tresult += (1.0\/exp2(i)) * (i\/OCCLUSION_SAMPLES)-map(normalPos).d;\n\t}\n\treturn 1.0-(OCCLUSION_FACTOR*result);\n}\n\n\/\/some code borrowed from https:\/\/www.shadertoy.com\/view\/XsfXWX#\nfloat phong(vec3 l, vec3 e, vec3 n, float power) {\n    float nrm = (power + 8.0) \/ (PI * 8.0);\n    return pow(max(dot(l,reflect(e,n)),0.0), power) * nrm;\n}\n\nvec3 getColor(vec3 p)\n{\t\n    sHit hit_obj = map(p);\n    sMaterial material = hit_obj.material;\n\tvec3 n = getNormal(p);\n\tvec3 l = normalize(light-p);\n\tvec3 light_color = vec3(0);\n    \/\/vec3 cubemap = textureCube(iChannel0,-n).xyz;   \n    \n    \/\/float shadow = shadow_march(p, l);\n    float shadow = soft_shadow_march(p, l, 50.0);\n    \/\/ Diffuse lighting\n    light_color += LIGHT_COLOR * vec3(shadow) * max(dot(n, l), 0.0);\n    \n\tfloat occlusion = calcOcclusion(p, n);\n    light_color += LIGHT_AMBIENT * occlusion;\n    \n    vec3 diffuse = light_color * max(dot(n, l), 0.0);\n    \/\/ fresnel\n    \/\/float fresnel = max(1.0 - dot(n,p), 0.0);\n    \/\/fresnel = pow(fresnel,material.fresnel_pow);    \n\n    \/\/ specular\n    float power = 1.0 \/ max(material.roughness * 0.4,0.01);\n    vec3 spec = light_color * phong(-l,p,n,power);\n    \/\/reflection -= spec;\n\n    \/\/ diffuse\n    \/\/vec3 diff = diffuse;\n    \/\/diff = mix(diff * material.color,reflection,fresnel);        \n\n    \/\/vec3 color = mix(diff,reflection * material.color,material.metallic) + spec;\n    return diffuse * material.color + spec;\n}\n\n\/\/uncomment below to enable mouse moving\n\/\/#define MOUSE_MOVE\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;    \n    vec2 p = -1.0 + 2.0*uv;\n    p.x *= iResolution.x \/ iResolution.y;\n    \n#ifdef MOUSE_MOVE\n    vec2 mouse = iMouse.xy\/ iResolution.xy;\t\n    rotmat = xrotate((mouse.y)*4.0*PI)*yrotate((mouse.x)*4.0*PI + PI \/ 2.0); \n#else\n\tfloat tb = iGlobalTime * BPM \/ SEC_PER_MIN \/ 4.0 + 1.0; \/\/+1.0 to start at 2nd rotation cuz i like it best\n    float percent = fract(tb);\n    vec2 current = 2.0 * texture2D(iChannel0, vec2(floor(tb) \/ 64.0, floor(tb) \/ 32.0)).rg - 1.0;\n    vec2 next = 2.0 * texture2D(iChannel0, vec2(floor(tb + 1.0) \/ 64.0, floor(tb+1.0) \/ 32.0)).rg - 1.0;\n    vec2 final = mix(current, next, smoothstep(0.75, 1.0, percent));\n    rotmat = xrotate(final.x)*yrotate(final.y + PI \/ 2.0);\n#endif\n    \n    vec3 view = normalize(vec3( p, -1.0 ));\n    vec3 eye = vec3( 0.0, 0.0, 3.0 );\n    \/\/view *= rotmat;\n\t\/\/eye *= rotmat;\n    \n    vec3 pos = march(eye,view);\n    vec3 col = vec3(0);\n    \n    if (hit == true) \n    { \n        col = getColor(pos); \n    }\n    else\n    {\n        \/\/col = pow( textureCube( iChannel0, view ).xyz, vec3(2.0) );\n    }\n    \n\tfragColor = vec4(col,1.0);\n}\n","name":"","description":"","type":"image"},{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define TAU 6.283185307179586476925286766559\n#define PI 3.1415926535897932384626433832795\n\n#define C  32.703\n#define CS 34.648\n#define D  36.708\n#define DS 38.891\n#define E  41.203\n#define F  43.654\n#define FS 46.249\n#define G  48.999\n#define GS 51.913\n#define A  55.0\n#define AS 58.270\n#define B  61.735\n\n#define BPM 128.0\n#define SEC_PER_MIN 60.0\n\n\/\/-------------------------------------------------------------------\n\/\/---------------------------Instruments-----------------------------\n\/\/-------------------------------------------------------------------\n\nfloat noise( float x ){return fract(sin(1371.1*x)*43758.5453);}\n\n\/\/Basic waveforms with note and octave input\nfloat sn(float t, float note, float octave)\n{\n\treturn sin(t*note*exp2(octave)*PI);\n}\n\nfloat saw(float t, float note, float octave)\n{\n\treturn fract(t*note*exp2(octave-1.))-0.5;\n}\n\nfloat tri(float t, float note, float octave)\n{\n    \/\/return abs(4.0 * mod(freq * time - 0.25, 1.0) - 2.0) - 1.0;\n\treturn (abs(fract(t*note*exp2(octave-1.))-0.5)*2.-0.5)*2.;\n}\n\nfloat sqr(float t, float note, float octave)\n{\n\treturn step(fract(t*note*exp2(octave-1.)), 0.5)-0.5;\n}\n\n\/\/-------------------------------------------------------------------\n\/\/----------------------------Mixing---------------------------------\n\/\/-------------------------------------------------------------------\n\n\/\/Simple mixing function with balance control  (balance range 0..1)\nvec2 mixb(float x, float bal)\n{\n\tbal = clamp(bal,0.,1.);\n\treturn vec2(x * bal, x*(1.-bal));\n}\n\n\/\/ cheap and unrealistic distortion\nfloat dist(float s, float d)\n{\n\treturn clamp(s * d, -1.0, 1.0);\n}\nvec2 dist(vec2 s, float d)\n{\n\treturn clamp(s * d, -1.0, 1.0);\n}\n\n\/\/ quantize\nfloat quan(float s, float c)\n{\n\treturn floor(s \/ c) * c;\n}\n\n\/\/ randomize\nfloat nse(float x)\n{\n\treturn fract(sin(x * 110.082) * 19871.8972);\n\t\/\/return fract(sin(x * 110.082) * 13485.8372);\n}\nfloat nse_slide(float x)\n{\n\tfloat fl = floor(x);\n\treturn mix(nse(fl), nse(fl + 1.0), smoothstep(0.0, 1.0, fract(x)));\n}\n\nfloat kick(float tb)\n{\n\tfloat aa = 15.0;\n\ttb = sqrt(tb * aa) \/ aa;\n\t\n\tfloat amp = exp(max(tb - 0.1, 0.0) * -10.0);\n\tfloat v = sin(tb * 120.0 * TAU) * amp;\n\tv = dist(v, 1.0) * amp;\n\t\/\/v += nse(quan(tb, 0.001)) * nse(quan(tb, 0.00001)) * exp(tb * -20.0) * 2.5;\n\treturn v;\n}\n\nfloat hat(float tb)\n{    \n\tfloat aa = 4.0;\n\ttb = sqrt(tb * aa) \/ aa;\n\tfloat v = nse(sin(tb * 4000.0) * 0.0001) \n        * smoothstep(0.0, 0.02, tb) \n        * smoothstep(0.02, 0.0, tb - 0.05);\/\/exp(tb * -10.0);\n    \n\tfloat amp = exp(max(tb, 0.0) * -20.0);\n\tv = dist(v, 1.0) * amp;\n    \n    return v;\n}\n\nfloat snare(float tb)\n{\n\tfloat aa = 1.75;\n\ttb = sqrt(tb * aa) \/ aa;\n    \n    float v = tri(tb, A, 2.0);\n    float env = exp(max(tb, 0.0) * -30.0);\n    float attack = v * env;\n    \n\tfloat v2 = nse(sin(tb * 4000.0) * 0.0001) \n        * smoothstep(0.0, 0.15, tb)\n        * (1.0-smoothstep(0.23, 0.25, tb));\n    float env2 = exp(max(tb - 0.05, 0.0) * -13.0);\n    float decay = v2 * env2;\n    \n    attack = dist(attack, 3.5);\n    decay += dist(attack, 2.5);\n    return attack + decay;\n}\n\nvec2 organ(float tb, float note, float octave)\n{\n    vec2 v = vec2(0);\n    float env = 0.75;\/\/\/*fract(4.0 * tb) *\/ exp(max(tb, 0.0) * -0.1);\n    v += 0.33*sn(tb, note, octave) * env;\n    v += 0.33*dist(sqr(tb + 0.0002 * cos(8.0*tb), note, octave + 1.0), 4.0) * env;\n    v += 0.33*dist(saw(tb + 0.0002 * sin(8.0*tb), note, octave + 2.0), 2.0) * env;\n    v += 0.05*nse(sin(tb * 4000.0) * 0.0001) * env;\n    return v;\n}\n\n#define CHORD3(nl, n1, n2, n3) if(floor(beat) >= bc && floor(beat) - bc < nl){mx += 0.33 * sc * organ(tb \/ 16.0, n1, 3.0);        mx += 0.33 * sc * organ(tb \/ 16.0, n2, 3.0);        mx += 0.33 * sc * organ(tb \/ 16.0, n3, 3.0);    }    bc += nl;\n#define CHORD4(nl, n1, n2, n3, n4) if(floor(beat) >= bc && floor(beat) - bc < nl){mx += 0.33 * sc * organ(tb \/ 16.0, n1, 3.0);        mx += 0.33 * sc * organ(tb \/ 16.0, n2, 3.0);        mx += 0.33 * sc * organ(tb \/ 16.0, n3, 3.0);       mx += 0.33 * sc * organ(tb \/ 16.0, n4, 2.0);    }    bc += nl;\n                                  \nvec2 mainSound(float time)\n{\n    float t = time;\n\tfloat tb = mod(time * 4.0 * BPM \/ SEC_PER_MIN, 16.0); \/\/fraction of beat?\n    vec2 mx = vec2(0);\n    \n    \/\/mx += hat(fract((tb) \/ 2.0) * 0.25) * 0.25;\n    float drum_vol = 0.5;\n    mx += 1.0 * kick(fract(tb \/ 4.0) * 0.5);\n    mx += 1.0 * mixb(hat(fract((tb + 0.002 + 2.0) \/ 4.0) * 0.5), -1.0);\n    mx += 1.0 * mixb(hat(fract((tb + 2.0) \/ 4.0) * 0.5), 1.0);\n    mx += 1.0 * mixb(snare(fract((tb + 4.0) \/ 8.0) * 0.5), -1.0);\n    mx += 1.0 * mixb(snare(fract((tb + 0.002 + 4.0) \/ 8.0) * 0.5), 1.0);\n    mx *= drum_vol;\n    \n\tfloat sc = 0.75 + 0.25 * smoothstep(0.25, 0.5, fract(tb \/ 8.0) );\/\/sidechain every 8th\n    \/\/mx += 0.25 * organ(fract((tb + 2.0) \/ 4.0) * 0.5, D, 2.0) * sc;\n    \n    \/\/F#, C#, A# 4 beats\n    \/\/D#, C, G# 1.5 beats\n    \/\/F#, C#, A#, F# 2 beats\n    \/\/D#, A#, G, D# 8.5 beats\n    \n    \/\/F#, C#, A# 4 beats\n    \/\/D#, C, G# 1.5 beats\n    \/\/F#, C#, A#, F# 2 beats\n    \/\/D#, A#, G, D# 7 beats\n    \/\/D#, G#, C, G# 1.5 beats\n    \n\tfloat beat = mod(time * BPM \/ SEC_PER_MIN, 32.0); \/\/ beat counter\n    float bc = 0.0;\n    \n    CHORD3(4.0, F, CS, AS)\n    CHORD3(1.5, DS, C, GS)\n    CHORD4(2.0, FS, CS, AS, FS)\n    CHORD4(8.5, DS, AS, G, DS)\n        \n    CHORD3(4.0, F, CS, AS)\n    CHORD3(1.5, DS, C, GS)\n    CHORD4(2.0, FS, CS, AS, FS)\n    CHORD4(7.0, DS, AS, G, DS)\n        \n    CHORD4(1.5, DS, C, GS, DS)\n    \n    return vec2(mx);\n}","name":"","description":"","type":"sound"}]}}