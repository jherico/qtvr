{"Shader":{"ver":"0.1","info":{"id":"lds3RX","date":"1376130705","viewed":2876,"name":"Spheres\/Plane","username":"mu6k","description":"Playing around with some materials and shadows. Mouse rotates the camera.","likes":30,"published":3,"flags":0,"tags":["raymarch","shadow","lighting","spheres","occlusion"],"hasliked":0},"renderpass":[{"inputs":[{"id":3,"src":"\/presets\/tex02.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":6,"src":"\/presets\/tex05.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/*by musk License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n Playing around with some materials and shadows. Mouse rotates the camera.\n\n 10\/08\/13: \n\tpublished\n\nmuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuusk!*\/\n\n#define occlusion_enabled\n#define occlusion_pass1_quality 40\n#define occlusion_pass2_quality 8\n\n#define noise_use_smoothstep\n\n#define object_count 8\n#define object_speed_modifier 1.0\n\n#define render_steps 128 \n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0,+1.0);\n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\nvoid rotate(inout vec2 v, const float angle)\n{\n    float cs = cos(angle), ss = sin(angle);\n    v = vec2(cs*v.x + ss*v.y, -ss*v.x + cs*v.y);\n}\n\nfloat spheres(vec3 p)\n{\n    vec3 p2 = p;\n    p2.xz = mod(p.xz+2.0,4.0)-2.0;\n    vec2 idx = p.xy-p2.xy;\n    p2.xz += sin(idx*34.91)*.5;\n    \n\treturn length(p2)-1.0;\t\n}\n\nfloat flr(vec3 p)\n{\n\treturn p.y+1.0;\n}\n\nfloat dist(vec3 p)\/\/distance function\n{\n\tfloat t = iGlobalTime+4.0;\n\tfloat d = 1000.0;\/\/p.y+2.0;\n\t\n\td = min(spheres(p),flr(p));\n\t\n\treturn d;\n}\n\nfloat amb_occ(vec3 p)\n{\n\tfloat acc=0.0;\n\t#define ambocce 0.2\n\n\tacc+=dist(p+vec3(-ambocce,-ambocce,-ambocce));\n\tacc+=dist(p+vec3(-ambocce,-ambocce,+ambocce));\n\tacc+=dist(p+vec3(-ambocce,+ambocce,-ambocce));\n\tacc+=dist(p+vec3(-ambocce,+ambocce,+ambocce));\n\tacc+=dist(p+vec3(+ambocce,-ambocce,-ambocce));\n\tacc+=dist(p+vec3(+ambocce,-ambocce,+ambocce));\n\tacc+=dist(p+vec3(+ambocce,+ambocce,-ambocce));\n\tacc+=dist(p+vec3(+ambocce,+ambocce,+ambocce));\n\treturn 0.5+acc \/(16.0*ambocce);\n}\n\nvec3 normal(vec3 p,float e) \/\/returns the normal, uses the distance function\n{\n\tfloat d=dist(p);\n\treturn normalize(vec3(dist(p+vec3(e,0,0))-d,dist(p+vec3(0,e,0))-d,dist(p+vec3(0,0,e))-d));\n}\n\nvec3 background(vec3 p,vec3 d)\/\/render background\n{\n\td=rotate_z(d,-1.0);\n\tvec3 color = mix(vec3(.9,.6,.2),vec3(.1,.4,.8),d.y*.5+.5);\n\treturn color*(.5+.5*texture2D(iChannel2,d.xz*.01).xxx)*.25;\n\t\/\/return textureCube(iChannel2,d).xyz*vec3(.2,.4,.6);\n}\n\nvec3 object_material(vec3 p, vec3 d) \/\/computes the material for the object\n{\n\tvec3 n = normal(p,.02); \/\/normal vector\n\tvec3 r = reflect(d,n); \/\/reflect vector\n\tfloat ao = amb_occ(p); \/\/fake ambient occlusion\n\tvec3 color = vec3(.0,.0,.0); \/\/variable to hold the color\n\tfloat reflectance = 1.0+dot(d,n);\n\t\/\/return vec3(reflectance);\n\t\n\tfloat or = 1.0;\n    for (int i=-2; i<5; i++)\n    {\n        float fi = float(i);\n        float e = pow(1.4,fi);\n        or = min(or,dist(p+r*e)\/e);\n    }\n    \/\/or = or*.5+.5;\n    or = max(or,.0);\n\t\n\tvec3 diffuse_acc = background(p,n)*ao;\n\t\n\tfloat t = iGlobalTime*0.2;\n\t\n\tfor (int i=0; i<3; i++)\n\t{\n\t\tfloat fi = float(i);\n\t\tvec3 offs = vec3(\n\t\t\t-sin(5.0*(1.0+fi)*123.4+t),\n\t\t\t-sin(4.0*(1.0+fi)*723.4+t),\n\t\t\t-sin(3.0*(1.0+fi)*413.4+t));\n\t\n\t\tvec3 lp = offs*6.0;\n\t\tvec3 ld = normalize(lp-p);\n\t\t\n        float attenuation = distance(lp,p);\n        \n\t\tfloat diffuse = dot(ld,n);\n\t\tfloat od=.0;\n\t\tif (diffuse>.0)\n\t\t{\n            od = 1.0;\n            for (int i=1; i<15; i++)\n            {\n                float fi = float(i);\n                float e = fi*.5;\n                od = min(od,dist(p+ld*e)\/e);\n            }\n           \/\/ od = od*.5+.5;\n            od = max(od,.0);\n\t\t}\n        else\n        {\n            diffuse = .0;\n        }\n\t\t\n\t\tfloat spec = pow(dot(r,ld)*.5+.5,100.0);\n\t\t\n\t\tvec3 icolor = vec3(2.0)*diffuse*od\/(attenuation*.125);\n\t\tdiffuse_acc += icolor;\n\t}\n    \n    \/\/return vec3(diffuse_acc*.5);\n\n\tif(spheres(p)<flr(p))\n\t{\n        vec3 tp = p;\n        vec3 tn = n;\n\t\tvec3 tex = vec3(.5);\n        tex *= texture2D(iChannel0,tp.yz*.7).xyz*tn.x*tn.x \n            + texture2D(iChannel0,tp.zx*.5).xyz*tn.y*tn.y \n            + texture2D(iChannel0,tp.xy*.2).xyz*tn.z*tn.z\n        ;\n        vec3 stex = pow(tex,vec3(5.0));\n        stex*=8.0;\n\t\tcolor = tex*diffuse_acc + stex*background(p,r)*(.1+or*reflectance)*1.8;\n\t}\n\telse\n\t{\n\t\tvec3 tex = vec3(.2);\n        tex = texture2D(iChannel1,p.xz*.4).xyz*.2;\n\t\tcolor = tex*diffuse_acc+background(p,r)*(.1+or*reflectance)*1.5;\n\t}\n\n\t\n\treturn color*min(ao*1.9,1.0)*.8;\n\t\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy - 0.5;\n\tuv.x *= iResolution.x\/iResolution.y; \/\/fix aspect ratio\n\tvec3 mouse = vec3(iMouse.xy\/iResolution.xy - 0.5,iMouse.z-.5);\n\t\n\tfloat t = iGlobalTime*.5*object_speed_modifier + 30.0;\n\tmouse += vec3(sin(t)*.05,sin(t)*.01,.0);\n\t\n\tfloat offs0=5.0;\n\tfloat offs1=1.0;\n\t\n\t\/\/setup the camera\n\tvec3 p = vec3(0,0.0,-1.0);\n\tp = rotate_x(p,mouse.y*9.0+offs0);\n\tp = rotate_y(p,mouse.x*9.0+offs1);\n\tp *= (abs(p.y*2.0+1.0)+1.0);\n\tvec3 d = vec3(uv,1.0);\n\td.z -= length(d)*.6; \/\/lens distort\n\td = normalize(d);\n\td = rotate_x(d,mouse.y*9.0+offs0);\n\td = rotate_y(d,mouse.x*9.0+offs1);\n    \n    \/\/p.x+=iGlobalTime*4.0;\n\t\n\tvec3 sp = p;\n\tvec3 color;\n\tfloat dd,td;\n\t\n\t\/\/raymarcing \n\tfor (int i=0; i<render_steps; i++)\n\t{\n\t\tdd = dist(p);\n\t\tp+=d*dd;\n\t\ttd+=dd;\n\t\tif (dd>5.0) break;\n\t}\n\t\n\tif (dd<0.1)\n\t{\n\t\tcolor = object_material(p,d);\n\t}\n\telse\n\t{\n\t\tcolor = background(p,d);\n\t}\n\t\n\tcolor = mix(background(p,d),color,1.0\/(td*.03+1.0));\n\tcolor = (color-vec3(.01,.01,.01))*vec3(3.0,3.5,3.5);\n    \n\tcolor *= (1.0-length(uv)*.8);\n\tfragColor = vec4(pow(color,vec3(1.0\/2.2)),1.0);\n}","name":"","description":"","type":"image"}]}}