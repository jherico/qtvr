{"Shader":{"ver":"0.1","info":{"id":"4ddGWf","date":"1452758353","viewed":63,"name":"Simple Julia Fractal","username":"maeln","description":"This is my first try at rendering a fractal with a shader. The code is purposely very verbose but I'm interested in any tip to make a more compact code <img src=\"\/img\/emoticonHappy.png\"\/> .","likes":1,"published":3,"flags":0,"tags":["2d","fractal","julia"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define MAXITER 128\n\n\/\/ + op for complex number.\n\/\/vec2 cadd(vec2 i1, vec2 i2)\n\/\/{\n\/\/    return vec2(i1.x+i2.x, i1.y+i2.y);\n\/\/}\n\n\/\/ * op for complex number.\nvec2 cmul(vec2 i1, vec2 i2) \n{\n    return vec2(i1.x*i2.x - i1.y*i2.y, i1.y*i2.x + i1.x*i2.y);\n}\n\n\/\/ ^2 for complex number.\n\/\/float csquare(vec2 i1) \n\/\/{\n\/\/    return i1.x*i1.x + i1.y*i1.y;\n\/\/}\n\nint julia(vec2 z, vec2 c)\n{\n    int i = 0;\n    vec2 zi = z;\n    \n    for(int n=0; n < MAXITER; ++n)\n    {\n        if(dot(zi,zi) > 4.0)\n            break;\n        i++;\n        zi = cmul(zi,zi) + c;\n        \n    }\n    \n    return i;\n}\n\nvec4 gen_color(int iter)\n{\n    vec3 c1 = vec3(1.0,1.0,1.0);\n    vec3 c2 = vec3(0.0,0.6,0.3);\n    vec3 m = vec3(float(iter)\/float(MAXITER));\n    vec3 base = mix(c1,c2,m);\n    return vec4(base,1.0);\n}\n\n\/\/ Remap the OpenGL space to the space where the julia set is defined ( [(-2;-2),(2;2)] ).\nvec2 space(vec2 res, vec2 coord)\n{\n    \/\/ Center the coordinate so that (0,0) is in the center of the screen.\n    vec2 base = (2.*coord.xy - res.xy) \/ res.x;\n    \/\/ base*2 so that the range is [-2;2] (the julia set is defined on this range)\n    return base*2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 z = space(iResolution.xy, fragCoord.xy);\n    \/\/ Display the julia fractal for C = (-0.8, [0.0;0.3]).\n    int iter = julia(z, vec2(-0.8, mix(0.0, 0.3, sin(iGlobalTime))));\n\tfragColor = gen_color(iter);\n}","name":"","description":"","type":"image"}]}}