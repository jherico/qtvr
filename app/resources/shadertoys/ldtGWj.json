{"Shader":{"ver":"0.1","info":{"id":"ldtGWj","date":"1452349689","viewed":455,"name":"Precalculated Voronoi Heightmap","username":"Shane","description":"Generating a simple, abstract stone texture in a single loop pass, then using it as a heightmap for raymarching purposes.","likes":33,"published":3,"flags":32,"tags":["raymarching","voronoi","texture","stone","precalculation"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/*\n\n\tPrecalculated Voronoi Heightmap\n\t-------------------------------\n\n\tGenerating a simple, abstract stone texture in a single offscreen loop pass, then using \n\tit as a heightmap for raymarching purposes. The example itself is nothing exciting, but it \n\tshows that you can now calculate things like multiple terrain layers - or anything you can \n\tdream up - in a single pass. In fact, if you put together a simple resizing system, you \n\tcould get it done in a single frame.\n\n\tYou can find the texture creation behind the \"Buf A\" tab. For the record, I haven't\tproperly \n\tinvestigated correct procedures yet, so there's probably a better way to preload a heightmap. \n\tIdeally, it'd be nice to render to a fixed sized buffer, like 512 by 512 for instance, which\n    would be especially helpful when moving to fullscreen, but I don't think that's possible at \n\tpresent? Either way, the framerate is much, much better in a sub-1000-px sized canvas than \n\tit would be if you had to do the same without multipass.\n\n\tBy the way, thanks to \"poljere,\" \"iq\" - and whoever else was involved - for providing \n\tmultiple-pass functionality. Putting that together would have been a backend nightmare, but \n\tit opens up so many possibilities.\n\n*\/\n\n\/\/ If you want to see what the generated heightmap looks like by itself, uncomment the following.\n\/\/#define SHOW_HEIGHMAP \n\n\/\/ Tri-Planar blending function. Based on an old Nvidia writeup:\n\/\/ GPU Gems 3 - Ryan Geiss: http:\/\/http.developer.nvidia.com\/GPUGems3\/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    p = fract(p);\n    \n    n = max(n*n, 0.001);\n    n \/= (n.x + n.y + n.z ); \n    \n\treturn (texture2D(tex, p.yz)*n.x + texture2D(tex, p.zx)*n.y + texture2D(tex, p.xy)*n.z).xyz;\n}\n\n\/\/ Reducing the heightmap function to a single texel lookup - via the stone texture which was \n\/\/ generated outside the distance function in the onscreen buffer, of course.\n\/\/\n\/\/ Using the single pass system, there would have been no other option than to generate the stone \n\/\/ texture several times a frame... or beg someone behind the scenes to provide a 2D multilayered \n\/\/ Voronoi heightmap. :)\nfloat heightMap( in vec2 p ) { \n\n    \/\/ The stone texture is tileable, or repeatable, which means the pattern is slightly\n    \/\/ repetitive, but not too bad, all things considered. Note that the offscreen buffer \n    \/\/ doesn't wrap, so you have to do that yourself. Ie: fract(p) - Range [0, 1].\n    return texture2D(iChannel0, fract(p\/2.), -100.).w;\n\n}\n\n\n\/\/ Raymarching a textured XY-plane, with a bit of distortion thrown in.\nfloat map(vec3 p){\n\n    \/\/ The height value.\n    float c = heightMap(p.xy);\n    \n    \/\/ Back plane, placed at vec3(0., 0., 1.), with plane normal vec3(0., 0., -1).\n    \/\/ Adding some height to the plane from the texture. Not much else to it.\n    return 1. - p.z - c*.1;\/\/texture2D(texChannel0, p.xy).x*.1;\n\n    \n    \/\/ Smoothed out.\n    \/\/float t =  heightMap(p.xy);\n    \/\/return 1. - p.z - smoothstep(0.1, .8, t)*.06 - t*t*.03;\n    \n}\n\n\n\/\/ Tetrahedral normal, courtesy of IQ.\nvec3 getNormal( in vec3 pos )\n{\n    vec2 e = vec2(0.001, -0.001);\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\n\n\n\/\/ Ambient occlusion, for that self shadowed look.\n\/\/ Based on the original by IQ.\nfloat calculateAO(vec3 p, vec3 n)\n{\n   const float AO_SAMPLES = 5.0;\n   float r = 1.0, w = 1.0;\n   for (float i=1.0; i<=AO_SAMPLES; i++)\n   {\n      float d0 = i\/AO_SAMPLES;\n      r += w * (map(p + n * d0) - d0);\n      w *= 0.5;\n   }\n   return clamp(r, 0.0, 1.0);\n}\n\n\/\/ Cool curve function, by Shadertoy user, Nimitz.\n\/\/\n\/\/ It gives you a scalar curvature value for an object's signed distance function, which \n\/\/ is pretty handy for all kinds of things. Here's it's used to darken the crevices.\n\/\/\n\/\/ From an intuitive sense, the function returns a weighted difference between a surface \n\/\/ value and some surrounding values - arranged in a simplex tetrahedral fashion for minimal\n\/\/ calculations, I'm assuming. Almost common sense... almost. :)\n\/\/\n\/\/ Original usage (I think?) - Cheap curvature: https:\/\/www.shadertoy.com\/view\/Xts3WM\n\/\/ Other usage: Xyptonjtroz: https:\/\/www.shadertoy.com\/view\/4ts3z2\nfloat curve(in vec3 p){\n\n    const float eps = 0.0225, amp = 7.5, ampInit = 0.525;\n\n    vec2 e = vec2(-1., 1.)*eps; \/\/0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return clamp((t1 + t2 + t3 + t4 - 4.*map(p))*amp + ampInit, 0., 1.);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n    \/\/ Unit direction ray. Divisionless one liner, courtesy of user, Coyote.\n    vec3 rd = normalize(vec3(fragCoord - iResolution.xy*.5, iResolution.y*.5));\n    \n    \/\/ Rotating the XY-plane back and forth, for a bit of variance.\n    \/\/ Elegant angle vector, courtesy of user, Fabrice.\n    vec2 th = sin(vec2(1.57, 0) + sin(iGlobalTime\/4.)*.3);\n    rd.xy = mat2(th, -th.y, th.x)*rd.xy;\n    \n    \/\/ Tilting the camera in another direction.\n    \/\/th = sin(vec2(1.57, 0) + sin(iGlobalTime\/8.)*.1);\n    \/\/mat2(th, -th.y, th.x)*rd.yz;\n    \n    \n    \/\/ Ray origin. Moving in the X-direction to the right.\n    vec3 ro = vec3(iGlobalTime, cos(iGlobalTime\/4.), 0.);\n    \n    \n    \/\/ Light position, hovering around behind the camera.\n    vec3 lp = ro + vec3(cos(iGlobalTime\/4.)*.5, sin(iGlobalTime\/4.)*.5, -.5);\n    \n    \/\/ Standard raymarching segment. Because of the straight forward setup, very few \n    \/\/ iterations are needed.\n    float d, t=0.;\n    for(int j=0; j<32; j++){\n      \n        d = map(ro + rd*t); \/\/ Distance to the function.\n        t += d*.7; \/\/ Total distance from the camera to the surface.\n        \n        \/\/ The plane \"is\" the far plane, so no far plane break is needed.\n        if(d<0.001) break; \n    \n    }\n    \n   \n    \/\/ Surface postion, surface normal and light direction.\n    vec3 sp = ro + rd*t;\n    vec3 sn = getNormal(sp);\n    vec3 ld = lp - sp;\n    \n    \n    \/\/ Texture scale factor.\n    const float tSize0 = 1.\/1.;\n    \n    \n    \/\/ Retrieving the texel at the surface postion. A tri-planar mapping method is used to\n    \/\/ give a little extra dimension. The time component is responsible for the texture movement.\n    float c = heightMap(sp.xy);\n   \n    \n    vec3 oC = tex3D(iChannel0, sp*tSize0, sn)*(vec3(c)*.5+.5);\n    \/\/vec3 oC = texture2D(iChannel0, sp.xz*tSize0).xyz*(vec3(c)*.5+.5); \/\/ 2D texel lookup.\n    \/\/vec3 oC = vec3(.55)*(vec3(c)*.9+.1); \/\/ Textureless.\n    \n    \/\/ Mixing in the normal to give the color a bit of a pearlescent quality. These rocks probably\n    \/\/ wouldn't have a pearlecent quality... Um, but these are space rocks. :)\n    oC = clamp(mix(oC, vec3(c*1.1, c, c*c*.3), vec3(c)*sn + .5), 0., 1.);\n\n    \n    \n    float lDist = max(length(ld), 0.001); \/\/ Light distance.\n    float atten = 1.\/(1. + lDist*.125); \/\/ Light attenuation.\n    \n    ld \/= lDist; \/\/ Normalizing the light direction vector.\n    \n    float diff = max(dot(ld, sn), 0.); \/\/ Diffuse.\n    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 16.); \/\/ Specular.\n    float fre = pow(clamp(dot(sn, rd) + 1., .0, 1.), 3.); \/\/ Fake Fresnel, for the glow.\n \n    \/\/ Schlick Fresnel approximation, to tone down the specular component a bit.\n\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.0);\n\tfloat fre2 = mix(.5, 1., Schlick);  \/\/F0 = .5;  \/\/ Hard granite.  \n    \n    \/\/ Shading. Note, there are no actual shadows. The camera is front on, so the following\n    \/\/ two functions are enough to give a shadowy appearance.\n    float crv = curve(sp); \/\/ Curve value, to darken the crevices.\n    crv = smoothstep(0., 1., crv)*.5 + crv*.5; \/\/ Tweaking the curve value a bit.\n    \n    float ao = calculateAO(sp, sn); \/\/ Ambient occlusion, for self shadowing.\n\n\n    \n    \/\/ Combining the terms above to light the texel.\n    vec3 col = (oC*(diff + .75) + vec3(.4, .7, 1)*spec*fre2*2. + vec3(.3, .7, 1.)*fre*fre2*3.);\n    \n    \/\/ Another variation, without the Fresnel glow.\n    \/\/vec3 col = (oC*(diff + 1.) + vec3(1., .9, .7)*spec*fre2*2.);\n \n    \n    \/\/ Applying the shades.\n    col *= atten*crv*ao;\n    \n    \/\/col = vec3(crv);\n    \n    #ifdef SHOW_HEIGHMAP\n    vec2 uv = fragCoord.xy\/iResolution.y;\n    uv = mat2(th, -th.y, th.x)*uv;\n    uv += vec2(iGlobalTime, cos(iGlobalTime\/4.))\/2.;\n    vec4 tex = texture2D(iChannel0, fract(uv\/1.));\n    col = sqrt(tex.xyz)*tex.w;\n\t#endif\n\n    \/\/ Presenting to the screen.\n\tfragColor = vec4(col, 1.);\n}","name":"","description":"","type":"image"},{"inputs":[{"id":6,"src":"\/presets\/tex05.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ 2x2 hash algorithm.\nvec2 hash22(vec2 p) { \n    \n    \/\/ This line makes the pattern repeatable. \n    p = mod(p, 5.); \n\n    \/\/ More concise, but wouldn't disperse things as nicely as other versions.\n    float n = sin(dot(p, vec2(41, 289))); \n    return fract(vec2(8, 1)*262144.*n);\n\n    \/\/p = fract(vec2(8, 1)*262144.*n);\n    \/\/return sin(p*6.283 + iGlobalTime)*0.5 + 0.5;\n\n}\n\n\n\/\/ 2D 2nd-order Voronoi: Obviously, this is just a rehash of IQ's original. I've tidied\n\/\/ up those if-statements. Since there's less writing, it should go faster. That's how \n\/\/ it works, right? :)\n\/\/\nfloat voronoi(in vec2 p){\n    \n\tvec2 g = floor(p), o; p -= g;\n\t\n\tvec3 d = vec3(1); \/\/ 1.4, etc. \"d.z\" holds the distance comparison value.\n    \n\tfor(int y = -1; y <= 1; y++){\n\t\tfor(int x = -1; x <= 1; x++){\n            \n\t\t\to = vec2(x, y);\n            o += hash22(g + o) - p;\n            \n\t\t\td.z = dot(o, o);            \n            d.y = max(d.x, min(d.y, d.z));\n            d.x = min(d.x, d.z); \n                       \n\t\t}\n\t}\n\t\n\t\n    return d.y - d.x;\n    \/\/ return d.x;\n    \/\/ return max(d.y*.91 - d.x*1.1, 0.)\/.91;\n    \/\/ return sqrt(d.y) - sqrt(d.x); \/\/ etc.\n}\n\n\/\/ Prerendering a simple stone texture to one of the offscreen buffers. The process is simple, but\n\/\/ definitely not simple enough to calculate it on the fly inside a distance function.\n\/\/\n\/\/ There is one minor complication, and that is the texture needs to be repeatable. That's its own\n\/\/ discussion, but if you're not sure how it's achieved, the key to repeatable Voronoi are the lines \n\/\/ \"p = mod(p, 5)\" and \"float c = voronoi(p*5.)... .\" I'm sure you'll figure it out from there. :)\n\/\/\n\/\/ The random pixelization business is just a hacky way to redraw the texture when the canvas is resized.\n\/\/ Definitely not the best way to go about it, that's for sure.\n\/\/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \/\/ Offscreen buffer coordinates.\n    vec2 p = fragCoord.xy\/iResolution.xy;\n\n    \/\/ On the first frame, render the entire texture. Otherwise, randomly render every 8 pixels,\n    \/\/ which, in theory, should lessen the workload. I'm continuously rendering parts of the texture\n    \/\/ to account for resizing events. If you resize, the new heighmap will quickly pixel fade in.\n    \n    \/\/ Obviously, a better solution would be to detect a resize and render the texture just once, or \n    \/\/ better yet, have a fixed size offscreen buffer option... Although, that sounds like a backend \n    \/\/ nightmare. :)\n    \/\/if(hash22(p + iGlobalTime).x< 1.\/8. || iFrame==0){\n    if(floor(hash22(p + iGlobalTime).x*8.)< 1. || iFrame==0){    \n        \n        \/\/ The stone texture. I made this up on the spot. Basically add three second order Voronoi\n        \/\/ layers of varying amplitudes and frequency. Also, perturb the initial UV coordinates\n        \/\/ to give it more of a natural look. Finally, add some fine detailing via one of Shadertoy's\n        \/\/ in-house textures. By the way, you could generate that also, but I didn't want to \n        \/\/ overcomplicate a simple example.\n        \n        \/\/ Texture value. Reversing the channels for a different color variation.\n        vec3 tx = texture2D(iChannel1, p).zyx;\n        \n        \/\/ Perturbing the UV coordinates just slightly to give the stones a slightly more natural feel.\n        \/\/ Note the PI frequencies. That's for texture wrapping purposes.\n        p += sin(p*6.283*2. - cos(p.yx*6.283*4.))*.01;\n        \n        \/\/ Three Voronoi layers. Pretty standard. I could have put a lot more effort into this\n        \/\/ part, but it's just a simple proof of concept, so just three lazy layers.\n        \n        \/\/ More stone looking.\n        \/\/float c = voronoi(p*5.)*.8 + voronoi(p*15.)*.15 + voronoi(p*45.)*.05;\n        \n        float c = voronoi(p*5.) - (1.-voronoi(p*15.))*.08 + voronoi(p*45.)*.04;\n        \n\n        \/\/ Finally, using the greyscale texture value to add some fine detailing.\n        c += dot(tx, vec3(.299, .587, .114))*0.2;\n        \n        \n        \/\/ Storing away the values for use in the main part of the application.\n        fragColor.xyz = tx; \/\/ Put the texture color in the XYZ channels.\n        fragColor.w = min(c\/1.1, 1.); \/\/ Store the heightmap value in the \"W\" channel.\n\n\n    }\n    \/\/ Copy the rest of the pixels over to the new frame. Obvious, but it'd been a while, so I had to \n    \/\/ figure that one out. :)\n    else fragColor = texture2D(iChannel0, p); \n    \n}","name":"","description":"","type":"buffer"}]}}