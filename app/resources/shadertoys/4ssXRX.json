{"Shader":{"ver":"0.1","info":{"id":"4ssXRX","date":"1405072299","viewed":2150,"name":"noise distributions","username":"hornet","description":"left to right:<br\/>- uniform noise<br\/>- triangular noise<br\/>- gaussianish noise<br\/>- moar gaussianish noise <img src=\"\/img\/emoticonHappy.png\"\/>","likes":39,"published":3,"flags":0,"tags":["noise","random","gaussian","rnd","rand","distribution","gauss","triangular"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"const int NUM_BUCKETS = 32;\nconst int ITER_PER_BUCKET = 1024;\nconst float HIST_SCALE = 8.0;\n\nconst float NUM_BUCKETS_F = float(NUM_BUCKETS);\nconst float ITER_PER_BUCKET_F = float(ITER_PER_BUCKET);\n\n\n\/\/note: uniformly distributed, normalized rand, [0;1[\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\/\/note: remaps v to [0;1] in interval [a;b]\nfloat remap( float a, float b, float v )\n{\n\treturn clamp( (v-a) \/ (b-a), 0.0, 1.0 );\n}\n\/\/note: quantizes in l levels\nfloat trunc( float a, float l )\n{\n\treturn floor(a*l)\/l;\n}\n\nfloat n1rand( vec2 n )\n{\n\tfloat t = fract( iGlobalTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\treturn nrnd0;\n}\nfloat n2rand( vec2 n )\n{\n\tfloat t = fract( iGlobalTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\n\treturn (nrnd0+nrnd1) \/ 2.0;\n}\nfloat n3rand( vec2 n )\n{\n\tfloat t = fract( iGlobalTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\n\tfloat nrnd2 = nrand( n + 0.13*t );\n\treturn (nrnd0+nrnd1+nrnd2) \/ 3.0;\n}\nfloat n4rand( vec2 n )\n{\n\tfloat t = fract( iGlobalTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\t\n\tfloat nrnd2 = nrand( n + 0.13*t );\n\tfloat nrnd3 = nrand( n + 0.17*t );\n\treturn (nrnd0+nrnd1+nrnd2+nrnd3) \/ 4.0;\n}\n\nfloat n8rand( vec2 n )\n{\n\tfloat t = fract( iGlobalTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\t\n\tfloat nrnd2 = nrand( n + 0.13*t );\n\tfloat nrnd3 = nrand( n + 0.17*t );\n    \n    float nrnd4 = nrand( n + 0.19*t );\n    float nrnd5 = nrand( n + 0.23*t );\n    float nrnd6 = nrand( n + 0.29*t );\n    float nrnd7 = nrand( n + 0.31*t );\n    \n\treturn (nrnd0+nrnd1+nrnd2+nrnd3 +nrnd4+nrnd5+nrnd6+nrnd7) \/ 8.0;\n}\n\nfloat n4rand_inv( vec2 n )\n{\n\tfloat t = fract( iGlobalTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\t\n\tfloat nrnd2 = nrand( n + 0.13*t );\n\tfloat nrnd3 = nrand( n + 0.17*t );\n    float nrnd4 = nrand( n + 0.19*t );\n\tfloat v1 = (nrnd0+nrnd1+nrnd2+nrnd3) \/ 4.0;\n    float v2 = 0.5 * remap( 0.0, 0.5, v1 ) + 0.5;\n    float v3 = 0.5 * remap( 0.5, 1.0, v1 );\n    return (nrnd4<0.5) ? v2 : v3;\n}\n\n\/\/alternative Gaussian,\n\/\/thanks to @self_shadow\n\/\/see http:\/\/www.dspguide.com\/ch2\/6.htm\nfloat n4rand_ss( vec2 n )\n{\n\tfloat nrnd0 = nrand( n + 0.07*fract( iGlobalTime ) );\n\tfloat nrnd1 = nrand( n + 0.11*fract( iGlobalTime + 0.573953 ) );\t\n\treturn 0.23*sqrt(-log(nrnd0+0.00001))*cos(2.0*3.141592*nrnd1)+0.5;\n}\n\n\/*\n\/\/Mouse Y give you a curve distribution of ^1 to ^8\n\/\/thanks to Trisomie21\nfloat n4rand( vec2 n )\n{\n\tfloat t = fract( iGlobalTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\t\n\tfloat p = 1. \/ (1. + iMouse.y * 8. \/ iResolution.y);\n\tnrnd0 -= .5;\n\tnrnd0 *= 2.;\n\tif(nrnd0<0.)\n\t\tnrnd0 = pow(1.+nrnd0, p)*.5;\n\telse\n\t\tnrnd0 = 1.-pow(nrnd0, p)*.5;\n\treturn nrnd0; \n}\n*\/\n\nfloat histogram( int iter, vec2 uv, vec2 interval, float height, float scale )\n{\n\tfloat t = remap( interval.x, interval.y, uv.x );\n\tvec2 bucket = vec2( trunc(t,NUM_BUCKETS_F), trunc(t,NUM_BUCKETS_F)+1.0\/NUM_BUCKETS_F);\n\tfloat bucketval = 0.0;\n\tfor ( int i=0;i<ITER_PER_BUCKET;++i)\n\t{\n\t\tfloat seed = float(i)\/ITER_PER_BUCKET_F;\n\t\t\n\t\tfloat r;\n\t\tif ( iter < 2 )\n\t\t\tr = n1rand( vec2(uv.x,0.5) + seed );\n\t\telse if ( iter<3 )\n\t\t\tr = n2rand( vec2(uv.x,0.5) + seed );\n\t\telse if ( iter<4 )\n\t\t\tr = n4rand( vec2(uv.x,0.5) + seed );\n\t\telse\n\t\t\tr = n8rand( vec2(uv.x,0.5) + seed );\n\t\t\n\t\tbucketval += step(bucket.x,r) * step(r,bucket.y);\n\t}\n\tbucketval \/= ITER_PER_BUCKET_F;\n\tbucketval *= scale;\n    \n    float v0 = step( uv.y \/ height, bucketval );\n    float v1 = step( (uv.y-1.0\/iResolution.y) \/ height, bucketval );\n    float v2 = step( (uv.y+1.0\/iResolution.y) \/ height, bucketval );\n\treturn 0.5 * v0 + v1-v2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\t\n\tfloat o;\n    int idx;\n    vec2 uvrange;\n\tif ( uv.x < 1.0\/4.0 )\n\t{\n\t\to = n1rand( uv );\n        idx = 1;\n        uvrange = vec2( 0.0\/4.0, 1.0\/4.0 );\n\t}\n\telse if ( uv.x < 2.0 \/ 4.0 )\n\t{\n\t\to = n2rand( uv );\n        idx = 2;\n        uvrange = vec2( 1.0\/4.0, 2.0\/4.0 );\n\t}\n\telse if ( uv.x < 3.0 \/ 4.0 )\n\t{\n\t\to = n4rand( uv );\n        idx = 3;\n        uvrange = vec2( 2.0\/4.0, 3.0\/4.0 );\n\t}\n\telse\n\t{\n\t\to = n8rand( uv );\n        idx = 4;\n        uvrange = vec2( 3.0\/4.0, 4.0\/4.0 );\n\t}\n\n    \/\/display histogram\n    if ( uv.y < 1.0 \/ 4.0 )\n\t\to = 0.125 + histogram( idx, uv, uvrange, 1.0\/4.0, HIST_SCALE );\n    \n\t\/\/display lines\n\tif ( abs(uv.x - 1.0\/4.0) < 0.002 ) o = 0.0;\n\tif ( abs(uv.x - 2.0\/4.0) < 0.002 ) o = 0.0;\n\tif ( abs(uv.x - 3.0\/4.0) < 0.002 ) o = 0.0;\n\tif ( abs(uv.y - 1.0\/4.0) < 0.002 ) o = 0.0;\n\n\t\n\tfragColor = vec4( vec3(o), 1.0 );\n}","name":"","description":"","type":"image"}]}}