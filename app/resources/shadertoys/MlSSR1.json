{"Shader":{"ver":"0.1","info":{"id":"MlSSR1","date":"1441531936","viewed":1387,"name":"Metaeaux - Sunset","username":"metaeaux","description":"My first procedural world <img src=\"\/img\/emoticonHappy.png\"\/><br\/>Mountains, sunset, stars, wind, clouds.. I think perhaps it needs a lake next!","likes":28,"published":3,"flags":0,"tags":["raymarching","sunset","clouds","stars","mountains","world","wind","prodedural"],"hasliked":0},"renderpass":[{"inputs":[{"id":8,"src":"\/presets\/tex07.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":17,"src":"\/presets\/tex12.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"precision mediump float;\n\nconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*texture2D( iChannel0, p\/256.0, -100. ).x; p = m2*p*2.02;\n    f += 0.2500*texture2D( iChannel0, p\/256.0, -100. ).x; p = m2*p*2.03;\n    f += 0.1250*texture2D( iChannel0, p\/256.0, -100. ).x; p = m2*p*2.01;\n    f += 0.0625*texture2D( iChannel0, p\/256.0, -100. ).x;\n    return f\/0.9375;\n}\n\nvec2 map (in vec3 p) {\n\tfloat mountains = 19. * fbm(p.xz*0.091);\n    float trees = -.35 * fbm(p.xz*10.);\n    float rocks = -.002 * fbm(p.xz*100.);\n    float result = p.y + mountains + trees + rocks;\n    \n    return vec2(result, 1.0);\n}\n\nvec3 mapColour (in vec3 pos, in vec3 nor) {    \n    float darken = (1.0 - 0.5 * length(normalize(pos)));\n\tvec3 tint = vec3(.7, .7, .6);\n    vec3 texture = texture2D( iChannel1, 0.006125*pos.xz, -100. ).xyz;\n    \n    return  texture * tint;\n}\n\nvec2 raymarch (in vec3 ro, in vec3 rd) {\n    vec2 h = vec2(0.001, 0.);\n    float t = 0.;\n    float tmax = 100.;\n    \n    for (int i = 0; i < 100; i++){\n        if (h.x < 0.0001 || t > tmax) break;\n        h = map(ro + t * rd);\n        t += 0.25 * h.x;\n    }\n    \n    if(t > tmax) h.y = -1.;\n    \n    return vec2(t, h.y);\n}\n\nfloat shadow( in vec3 ro, in vec3 rd, in float maxt)\n{\n\tfloat res = 1.0;\n    float dt = 0.04;\n    float t = .02;\n    for( int i=0; i < 20; i++ )\n    {       \n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, maxt*h\/t );\n        t += h;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    \/\/ show more detail the closer we are to the object\n    vec3  eps = vec3(0.002 * t,0.0,0.0);\n    vec3 nor;\n    nor.x = map(pos+eps.xyy).x - map(pos-eps.xyy).x;\n    nor.y = map(pos+eps.yxy).x - map(pos-eps.yxy).x;\n    nor.z = map(pos+eps.yyx).x - map(pos-eps.yyx).x;\n    return normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x\/iResolution.y;\n    vec2 mo = iMouse.xy\/iResolution.xy;\n\t\n    \/\/ camera\n\tfloat an1 = 0.2*iGlobalTime-6.2831*mo.x;\n\tfloat an2 = clamp( 0.8 + 0.6*sin(2.2+iGlobalTime*0.11)  + 1.0*mo.y, 0.3, 1.35 );\n    vec3 ro = 10.0*normalize(vec3(sin(an2)*cos(an1), cos(an2)-0.5, sin(an2)*sin(an1) ));\n    vec3 ww = normalize(vec3(0.0,0.0,0.0) - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv - 1.4*ww );\n\n    \/\/ raymarch\n    vec3 col =  vec3(0.);\/\/textureCube( iChannel0, rd ).xyz;\n    vec2 march = raymarch(ro, rd);\n    \n    vec3 light = normalize(vec3(0.9, 0.1, 0.9));\n    vec3 ambient = 5. * vec3(0.1, 0.15, 0.2);\n    float sundot = clamp(dot(rd,light),0.0,1.0);\n    vec3 pos = ro + march.x * rd;\n    \n    \/\/ if we hit geometry\n    if(march.y > 0.) {\n        vec3 nor = calcNormal(pos, march.x);\n        \n        float lambert = clamp(dot(nor, light), 0., 1.);\n        col = mapColour(pos, nor);\n        col = mix( col, mapColour(pos, nor) * lambert, 0.8);\n        \n        \/\/snow\n        \/\/float snow = clamp(dot(normalize(nor), vec3(0., 1., 0.)), 0., 1.);\n        \/\/snow = pow(snow, 5.);\n        \/\/col = mix(col, vec3(1.)*snow, clamp(rd.y + 1., 0., 1.)*0.5);\n        \n        \/\/ fog\n        float fo = 1.-exp(-0.04*march.x );\n        vec3 fco = 0.9*vec3(0.5,0.7,0.9) + 0.1*vec3(1.0,0.8,0.5)*pow( sundot, 4.0 );\n\t\tcol = mix( col, fco, fo );\n        \n        float sh = shadow( pos, light, 10.);\n    \tcol = 0.8*col + 0.2* col* sh ;\/\/ + ambient * (1.0 - sh);\n    }\n    \n    \/\/ sky\n    if(march.y < 0.){\n        \/\/ sky colour        \n        vec3 blueSky = vec3(0.3,.55,0.8);\n        vec3 redSky = vec3(0.8,0.8,0.6);\n        \n        vec3 sky = mix(blueSky, redSky, 1.5*pow(sundot, 8.));\n        \n        col =  sky*(1.0-0.8*rd.y);\n        \n        \/\/ stars\n        float s = texture2D( iChannel0, rd.xz * 1.25, -100. ).x;\n        s += texture2D( iChannel0, rd.xz* 4., -100. ).x;\n        \n        s = pow(s, 17.0) * 0.00005 * max(rd.y, -0.2) * pow((1. - max(sundot, 0.)), 2.); \n        if (s > .0)\n        {\n            vec3 backStars = vec3(s);\n            col += backStars;\n        }\n        \n        \/\/ sun\n        col += 0.1*vec3(0.9, 0.3, 0.9)*pow(sundot, 0.5);\n        col += 0.2*vec3(1., 0.7, 0.7)*pow(sundot, 1.);\n        col += 0.95*vec3(1.)*pow(sundot, 256.);\n        \n        \/\/ clouds\n        float cloudSpeed = 0.01;\n        float cloudFlux = 0.5;\n        \n        \/\/ layer 1\n        vec3 cloudColour = mix(vec3(1.0,0.95,1.0), 0.35*redSky,pow(sundot, 2.));\n        \n\t\tvec2 sc = cloudSpeed * 50.*iGlobalTime * ro.xz + rd.xz*(1000.0-ro.y)\/rd.y;\n\t\tcol = mix( col, cloudColour, 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc+fbm(0.0005*sc+iGlobalTime*cloudFlux))));\n        \n        \/\/ cloud layer 2\n        sc = cloudSpeed * 30.*iGlobalTime * ro.xz + rd.xz*(500.0-ro.y)\/rd.y;\n\t\tcol = mix( col, cloudColour, 0.5*smoothstep(0.5,0.8,fbm(0.0002*sc+fbm(0.0005*sc+iGlobalTime*cloudFlux))));\n        \n        \/\/ horizon        \n        col = mix( col, 0.9*vec3(0.9,0.75,0.8), pow( 1.-max(rd.y+0.1,0.0), 8.0));\n        \n        \n    }\n    \/\/ contrast\n    col = clamp(col, 0., 1.);\n    col = col*col*(3.0-2.0*col);\n    \n    \n    \/\/ saturation (amplify colour, subtract grayscale)\n    float sat = 0.2;\n    col = col * (1. + sat) - sat*dot(col, vec3(0.33));\n    \n    \n    \n\tfragColor = vec4(col,1.0);\n}","name":"","description":"","type":"image"}]}}