{"Shader":{"ver":"0.1","info":{"id":"Xsd3Rn","date":"1447728889","viewed":297,"name":"Holcombe's Variaton","username":"mikepfrank","description":"Make sounds and watch it change","likes":1,"published":3,"flags":4,"tags":["fractal","audio"],"hasliked":0},"renderpass":[{"inputs":[{"id":32,"src":"\/presets\/mic.png","ctype":"mic","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define pi 3.14159265359\n\n\/\/#define iGlobalTime tan(iGlobalTime*.1)+iGlobalTime*.1\n\nfloat bassBoostLow = 0.0;\nfloat bassBoostHigh = 0.0;\nfloat time = 0.0;\n\nvec3 hsv(in float h, in float s, in float v)\n{\n\treturn mix(vec3(1.0), clamp((abs(fract(h + vec3(3, 2, 1) \/ 3.0) * 6.0 - 3.0) - 1.0), 0.0 , 1.0), s) * v;\n}\n\nvec3 formula(in vec2 p, in vec2 c)\n{\n\tconst float n = 2.0;\n\tconst int iters = 5;\n\n\t\/\/float time = iGlobalTime*0.1;\n\tvec3 col = vec3(0);\n\tfloat t = 1.0;\n\tfloat dpp = dot(p, p);\n\tfloat lp = sqrt(dpp);\n\tfloat r = smoothstep(0.0, 0.2, lp);\n\t\n\tfor (int i = 0; i < iters; i++) {\n\t\t\/\/ The transformation\n        \/\/p+=vec2(sin(c.x+p.x)*.01,\n        \/\/        cos(c.y+p.y)*.01);\n        float to = bassBoostHigh;\n        float index = mod(float(i)*1234.1234, 2.0);\n        \n        \n        if(index < .1)\n        {\n        \tp = p*mat2(cos(cos(time+to)+time+to), -sin(cos(time+to)+time+to),\n                   sin(cos(time+to)+time+to), cos(cos(time+to)+time+to));\n\t\t\tp = abs(mod(p*(1.0) + c, n) - (n)\/2.0);\n        }\n        else if(index < 1.1)\n\t\t\tp = abs(mod(p*(1.0) + c, n) - (n)\/2.0);\/\/mod(p\/dpp + c, n) - n\/2.0;\n        else if(index < 2.1)\n\t\t\tp = p+to;\n\t\t\n\t\tdpp = dot(p, p);\n        p \/= dpp;\n\t\tlp = pow(dpp, 1.5);\n        \n        \n        \/\/if(int(14.0*sin(iGlobalTime))+iters < i) break;\n\n\t\t\/\/Shade the lines of symmetry black\n#if 0\n\t\t\/\/ Get constant width lines with fwidth()\n\t\tfloat nd = fwidth(dpp);\n\t\tfloat md = fwidth(lp);\n\t\tt *= smoothstep(0.0, 0.5, abs((n\/2.0-p.x)\/nd*n))\n\t\t   * smoothstep(0.0, 0.5, abs((n\/2.0-p.y)\/nd*n))\n\t\t   * smoothstep(0.0, 0.5, abs(p.x\/md))\n\t\t   * smoothstep(0.0, 0.5, abs(p.y\/md));\n#else\n\t\t\/\/ Variable width lines\n\t\tt *= smoothstep(0.0, 0.01, abs(n\/2.0-p.x)*lp)\n\t\t   * smoothstep(0.0, 0.01, abs(n\/2.0-p.y)*lp)\n\t\t   * smoothstep(0.0, 0.01, abs(p.x)*2.0) \n\t\t   * smoothstep(0.0, 0.01, abs(p.y)*2.0);\n#endif\n\n\t\t\/\/ Fade out the high density areas, they just look like noise\n\t\tr *= smoothstep(0.0, 0.2, lp);\n\t\t\n\t\t\/\/ Add to colour using hsv\n\t\tcol += lp+bassBoostHigh;\n\t\t\n\t}\n\t\n\tcol = vec3(sin(col.x+time*.125),\n\t\t\t   cos(col.y+time*.125+4.0*pi\/3.0),\n\t\t\t   sin(col.z+time*.125+2.0*pi\/3.0))*.5+.5;\n    \n\treturn col*t;\n}\n\nfloat lowAverage()\n{\n    const int iters = 32;\n    float sum = 0.0;\n    \n    float last = length(texture2D(iChannel0, vec2(0.0)));\n    float next;\n    for(int i = 1; i < iters\/2; i++)\n    {\n        next = length(texture2D(iChannel0, vec2(float(i)\/float(iters), 0.0)));\n        sum += last;\/\/pow(abs(last-next), 1.0);\n        last = next;\n    }\n    return sum\/float(iters)*2.0;\n}\n\nfloat highAverage()\n{\n    const int iters = 32;\n    float sum = 0.0;\n    \n    float last = length(texture2D(iChannel0, vec2(0.0)));\n    float next;\n    for(int i = 17; i < iters; i++)\n    {\n        next = length(texture2D(iChannel0, vec2(float(i)\/float(iters), 0.0)));\n        sum += last;\/\/pow(abs(last-next), 1.0);\n        last = next;\n    }\n    return sum\/float(iters)*2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = -1.0 + 2.0 * fragCoord.xy \/ iResolution.xy;\n    \n    bassBoostLow += lowAverage()*1.0;\n    bassBoostHigh += highAverage()*1.0;\n    time = iGlobalTime+bassBoostLow*8.0*pi;\n    \n    p += .125;\n    \n    p += .5*vec2(cos(time), sin(time));\n    \n\tp.x *= iResolution.x \/ iResolution.y;\n\tp *= 1.5+1.125*sin(time*.25);\n    \n\tconst vec2 e = vec2(0.06545465634, -0.05346356485);\n\tvec2 c = time*e;\n\t\/\/c = 8.0*iMouse.xy\/iResolution.xy;\n\tfloat d = 1.0;\n\tvec3 col = vec3(0.0);\n\tconst float blursamples = 4.0;\n\tfloat sbs = sqrt(blursamples);\n\tfloat mbluramount = 1.0\/iResolution.x\/length(e)\/blursamples*2.0;\n\tfloat aabluramount = 1.0\/iResolution.x\/sbs*4.0;\n\tfor (float b = 0.0; b < blursamples; b++) {\n\t\tcol += formula(\n\t\t\tp + vec2(mod(b, sbs)*aabluramount, b\/sbs*aabluramount), \n\t\t\tc + e*mbluramount*b);\n\t}\n\tcol \/= blursamples;\n\tfragColor = vec4(col, 1.0);\n}","name":"","description":"","type":"image"}]}}