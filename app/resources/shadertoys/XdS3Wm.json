{"Shader":{"ver":"0.1","info":{"id":"XdS3Wm","date":"1389008433","viewed":2857,"name":"Hello Morph!","username":"Dave_Hoskins","description":"Aardman's (from Wallace & Gromit fame) early work. Morph, the plasticine animation from British childhoods in the 70s and 80s.<br\/>Episode on YouTube: https:\/\/www.youtube.com\/watch?v=daQfoN_xXIc","likes":31,"published":3,"flags":0,"tags":["morph","hellomorph"],"hasliked":0},"renderpass":[{"inputs":[{"id":6,"src":"\/presets\/tex05.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Hello Morph! By David Hoskins. Jan 2014.\r\n\/\/ Aardman's (from Wallace & Gromit fame) early work.\r\n\/\/ http:\/\/www.youtube.com\/watch?v=jSMRPKM1evk\r\n\r\n\/\/ Morph, the plasticine animation from British childhoods in the 70s and 80s:-\r\n\/\/ https:\/\/www.youtube.com\/watch?v=daQfoN_xXIc\r\n\r\n\/\/ COMMENT THE NEXT LINE TO REMOVE STOP MOTION FRAME JUDDER...\r\n#define STOP_MOTION_EFFECT\r\n\r\n\/\/ Some often adjusted defines in one place...\r\n#define elbowR\t\tvec3(1.0, -.1, 0.3)\r\n#define shoulderR\tvec3(0.4, 0.56,  -.05)\r\n#define wristR\t\tvec3(.5, -.4, -0.1)\r\n#define shoulderL\tvec3(-0.4, 0.56, -.05)\r\n#define sunColour\tvec3(1.0)\r\n#define skinColour  vec3(.65, .22, 0.14)\r\n#define sunDir\t\tvec3(.42562, .59588, -.681005)\r\n#define PI 3.14159265359\r\n\r\n\/\/ Animation variables.\r\n\/\/ Possibly a bad idea using globals, but it seems OK if there's only a few of them.\r\n\/\/ They make it much quicker and easier than passing everything in functions.\r\nfloat wave;\r\nfloat hel;\r\nfloat low;\r\nfloat nod;\r\nfloat time;\r\n\r\n\/\/----------------------------------------------------------------------------------------\r\nfloat Hash(vec2 p)\r\n{\r\n\treturn fract(sin(dot(p, vec2(32.3391, 38.5373))) * 74638.5453);\r\n}\r\n\r\n\/\/----------------------------------------------------------------------------------------\r\n\/\/ 2D rotations for 3D vectors make them quicker on axis rotations...\r\nvec2 Rotate2(vec2 p, float a)\r\n{\r\n\tfloat si = sin(a);\r\n\tfloat co = cos(a);\r\n\treturn mat2(co, si, -si, co) * p;\r\n}\r\n\r\n\/\/----------------------------------------------------------------------------------------\r\nfloat Segment(vec3 p,  vec3 a, vec3 b, float r1, float r2)\r\n{\r\n\tvec3 pa = p - a;\r\n\tvec3 ba = b - a;\r\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - r1 + r2*h;\r\n}\r\n\r\n\/\/----------------------------------------------------------------------------------------\r\nfloat Mouth( vec3 p, vec3 a)\r\n{\r\n\tfloat curve = cos(p.x*(5.35+sin(-time)*1.25))*.11;\r\n\tp.y += curve;\r\n\ta.y += pow(abs(curve), 2.0);\r\n\treturn length(max(abs(p) - a,0.0)) -.02;\r\n}\r\n\r\n\/\/ I\u00f1igo's distance functions...\r\n\/\/----------------------------------------------------------------------------------------\r\nfloat  Sphere( vec3 p, float s )\r\n{\r\n    return length(p)-s;\r\n}\r\n\r\n\/\/----------------------------------------------------------------------------------------\r\nfloat Cylinder( vec3 p, vec2 h )\r\n{\r\n  return max( length(p.xz)-h.x, abs(p.y)-h.y );\r\n}\r\n\r\n\/\/----------------------------------------------------------------------------------------\r\nfloat RoundBox( vec3 p, vec3 b, float r )\r\n{\r\n\t\/\/b.x -= p.y * .08;\r\n\treturn length(max(abs(p)-b,0.0))-r;\r\n}\r\n\r\n\/\/----------------------------------------------------------------------------------------\r\nfloat Nose(vec3 p, vec3 a, float r )\r\n{\r\n\tfloat h = clamp( dot(p,a)\/dot(a,a), 0.0, 1.0 );\r\n\treturn length( p - a*h ) - r;\r\n}\r\n\r\n\/\/----------------------------------------------------------------------------------------\r\nfloat sMin( float a, float b )\r\n{\r\n    float k = .12;\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\r\n\treturn mix( b, a, h ) - k*h*(1.-h);\r\n}\r\n\r\n\/\/----------------------------------------------------------------------------------------\r\nvec2 Map( in vec3 pos )\r\n{\r\n    vec2 res = vec2( 1000.0, 3);\r\n\tfloat d;\r\n\tpos.y += -1.0;\r\n\tvec3 elbowL\t\t= vec3(-.95-wave*.05, .2, -0.25);\r\n\tvec3 wristL\t\t= vec3(elbowL.x+1.0*sin(wave)*.55, elbowL.y+cos(wave)*.55, -.75);\r\n\t\r\n\t\/\/ Head...\r\n\tvec3 p = pos;\r\n\t\/\/ Rotate around Y axis for waist movment...\r\n\tfloat h = sin(time*2.3) * .1 - wave*0.01;\r\n\tp.xz = Rotate2(p.xz, h);\r\n\tvec3 p2 = p;\r\n\t\/\/ Rotate head around X axis...\r\n\tp2.zy = Rotate2(p.zy, nod+hel*2.0+wave*.012);\r\n\tp2 -= vec3(0.0, 0.0, -0.05);\r\n\t\r\n\td = Sphere(p2, .37);\r\n\tif (d < res.x)\r\n\t{\r\n\t\tres.x = d;\r\n\t\tvec3 p3 = vec3(abs(p2.x), p2.yz);\r\n\t\tif (dot(normalize(p3*vec3(1.0, .9, 1.0)), normalize(vec3(.32, 0.24, -.7))) > .95) res.y = 4.0;\r\n\t\tif (dot(normalize(p3), normalize(vec3(.32, 0.18-nod*.2, -.8))) > .993) res.y = 5.0;\r\n\t}\r\n\r\n\t\/\/ Mouth and inside colour...\r\n\tfloat mo = -Mouth(p2-vec3(0.0, -.057-hel, -0.3), vec3(.155-low, -.006+hel, .2));\r\n\tif (res.x  < mo ) res = vec2(mo, 2.0);\r\n\r\n\t\/\/ Nose\r\n\tp2 = p2-vec3(0.0, 0.0, 0.0);\r\n\tres.x = min(res.x, Nose(p2, vec3(.0,0.0,-.5), 0.06));\r\n\t\r\n\t\/\/ Neck...\r\n\tp = p-vec3(0.0, -.4, .1);\r\n\td = Cylinder(p, vec2(0.171, .17));\r\n\tres.x = sMin(res.x, d);\r\n\r\n\t\/\/ Body...\t\r\n\tp = p-vec3(0.0, -.82, 0.0);\r\n\td = RoundBox(p, vec3(0.175, .45, 0.0), .26);\r\n\tres.x = sMin(res.x, d);\r\n\t\t\t\r\n\t\/\/ Right arm upper...\r\n\tp = p-vec3(0.0, 0.0, 0.0);\r\n\td = Segment(p, shoulderR, elbowR, .17, .05);\r\n\tres.x = sMin(res.x, d);\r\n\t\/\/ Right arm lower...\r\n\td = Segment(p, elbowR, wristR, .15, .05);\r\n\tres.x = sMin(res.x, d);\r\n\t\/\/ Right hand...\t\r\n\td = Segment(p*vec3(1.0, .75, 1.0), wristR+vec3(0, .1, 0.), wristR+vec3(-.15, .05, -.15), .13, .02);\r\n\tres.x = min(res.x, d);\r\n\t\r\n\t\/\/ Left arm upper...\r\n\td = Segment(p, shoulderL, elbowL, .17, .05);\r\n\tres.x = sMin(res.x, d);\r\n\t\/\/ Left arm lower...\r\n\td = Segment(p, elbowL, wristL, .15, .05);\r\n\tres.x = sMin(res.x, d);\r\n\t\r\n\t\/\/ Left Hand...\t\r\n\tp = (p-wristL);\r\n\tp.z -= p.x*.5;\r\n\tp.yx = Rotate2(p.yx, -wave*1.5);\r\n\td = Segment(p, vec3(0.0), -vec3(-.25, -0.15, 0.1), .06, .01);\r\n\tres.x = sMin(res.x, d);\r\n\td = RoundBox(p-vec3(0.0, .25, 0.0), vec3(.042, .085, -.05), .09);\r\n\tres.x = sMin(res.x, d);\r\n\t\r\n\t\/\/ Mirrored legs...\r\n\tp = pos + vec3(0.0, .35, -.05);\r\n\tp.y += .8;\r\n\tp.x = abs(p.x);  \/\/ <- does the mirroring.\r\n\tvec3 ankle  = vec3(0.3, -1.85, 0.0);\r\n\td = Segment(p, vec3(0.22, -.75, 0.0), ankle, .225, .05);\r\n\tres.x = sMin(res.x, d);\r\n\t\r\n\t\/\/ Feet...\r\n\tankle.y -=.3;\r\n\td = Segment(p, ankle, ankle + vec3(0.27, -.05, -0.3), .24, .05);\r\n\td = max((ankle.y-p.y), d);\r\n\tres.x = sMin(res.x, d);\r\n\r\n\t\/\/ Do wooden box...\r\n\td = RoundBox(pos + vec3(-4.2, 2.7, -1.0), vec3(2.0, .5, 1.0), .075);\r\n\td = min(d, RoundBox(pos + vec3(-4.2, 1.9, -1.0), vec3(2.0, .185, 1.0), .075));\r\n\tif (d < res.x)\r\n\t{\r\n\t\tres = vec2(d, 1.0);\r\n\t}\r\n\r\n    return res;\r\n}\r\n\r\n\/\/----------------------------------------------------------------------------------------\r\nvec2 RayMarch( in vec3 ro, in vec3 rd, in vec2 fragCoord, out int hit)\r\n{\r\n\tconst float precis = 0.01;\r\n\tfloat t = .5 + .1 * Hash(fragCoord.xy);\r\n\thit = 0;\r\n\t\/\/ Had to remove all 'breaks' and 'continues' from the loop as they broke some systems...\r\n\t\/\/ (Scary huh?)\r\n\tvec2 res = vec2(precis*2.0, 0.0);\r\n    for( int i = 0; i < 63; i++ )\r\n    {\r\n\t\tif (hit == 0 && t < 20.0)\r\n\t\t{\r\n\t\t\tres = Map(ro + rd * t);\r\n\t\t\tif(res.x < precis)\r\n\t\t\t{\r\n\t\t\t\thit = 1;\r\n\t\t\t}else\r\n\t\t\t\tt += max(.005, res.x * .5);\r\n\t\t}\r\n    }\r\n\t\/\/ Missed scene, so do table with basic ray casting.\r\n\t\/\/ There's no point in ray-marching the flat gound as it's a\r\n\t\/\/ waste of cycles, especially for background location and accuracy.\r\n\t\/\/ (Well, in this case anyway)\r\n\tif (hit == 0 && rd.y < 0.0)\r\n\t{\r\n\t\thit = 2;\r\n\t\trd.y = min(rd.y, 0.0);\r\n\t\tt = (-2.3-ro.y) \/ rd.y;\r\n\t\tres.y = 6.0;\r\n\t}\r\n\t\/\/ Return the distance to point and material type.\r\n\treturn vec2( t, res.y);\t\r\n}\r\n\r\n\/\/----------------------------------------------------------------------------------------\r\nfloat Shadow( in vec3 ro, in vec3 rd)\r\n{\r\n\tfloat res = 1.0;\r\n    float t = 0.1;\r\n\tfloat h;\r\n\t\r\n    for (int i = 0; i < 7; i++)\r\n\t{\r\n\t\th = Map( ro + rd*t ).x;\r\n\t\tres = min(7.0*h \/ t, res);\r\n\t\tt += h+.04;\r\n\t}\r\n    return max(res, 0.0);\r\n}\r\n\r\n\/\/----------------------------------------------------------------------------------------\r\nvec3 Normal( in vec3 pos )\r\n{\r\n\r\n\tconst vec2 eps = vec2( 0.015, 0.0);\r\n\tvec3 nor = vec3(\r\n\t    Map(pos+eps.xyy).x - Map(pos-eps.xyy).x,\r\n\t    Map(pos+eps.yxy).x - Map(pos-eps.yxy).x,\r\n\t    Map(pos+eps.yyx).x - Map(pos-eps.yyx).x );\r\n\treturn normalize(nor);\r\n}\r\n\r\nvec3 GetMaterial(vec3 pos, vec3 norm, float mat)\r\n{\r\n\t\/\/ These teture reads had to be moved out of the 'if' statements as\r\n\t\/\/ Windoes Chrome34 WebGL broke badly in the hands of those ANGLE guys! :p\r\n\tvec3 col = texture2D(iChannel0, pos.xz*.3).xyz*.65;\t\/\/ Table\r\n\tvec3 tx1 = texture2D(iChannel0, pos.xy*vec2(.05, .25)).xyz * abs(norm.z+norm.x);\r\n\tvec3 tx2 = texture2D(iChannel0, pos.xz*vec2(.05, .25)).xyz * norm.y;\r\n\r\n\tfloat blink = step(mod(time-1.0, 3.0), .11);\r\n\tif (mat < 1.5)\r\n\t{\r\n\t\t\/\/ Wooden box is a lighter version of the table texture.\r\n\t\tcol =  tx1;\r\n\t\tcol += tx2;\r\n\t\tcol = sqrt(col);\r\n\t}else if (mat < 2.5)\r\n\t{\r\n\t\t\/\/ Inside mouth...\r\n\t\tcol = skinColour*.5;\r\n\r\n\t}else if (mat < 3.5)\r\n\t{\r\n\t\t\/\/ Plasticine...\r\n\t\tcol = skinColour;\r\n\r\n\t}else if (mat < 4.5)\r\n\t{\r\n\t\t\/\/ Eye balls...\r\n\t\tcol = skinColour * .7 * blink + vec3(1.0) * (1.0-blink);\r\n\t}else if (mat < 5.5)\r\n\t{\r\n\t\t\/\/ Pupil...\r\n\t\tcol = skinColour * .7 * blink;\/\/ + vec3(0.0) * (1.0-blink);\r\n\t}\r\n\treturn col;\r\n}\r\n\r\n\/\/----------------------------------------------------------------------------------------\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\t\/\/ Stop motion time...\r\n#ifdef STOP_MOTION_EFFECT\r\n\ttime = mod((floor(iGlobalTime*30.0) \/ 30.0), 20.0)-.7;\r\n#else\r\n\ttime = mod(iGlobalTime, 20.0)-.7;\r\n#endif\r\n\r\n\tvec3 col = vec3(0.85);\t\r\n\tvec2 q = fragCoord.xy\/iResolution.xy;\r\n    vec2 p = -1.0+2.0*q;\r\n\tp.x *= iResolution.x\/iResolution.y;\r\n\t\r\n\t\/\/ Animation...\r\n\twave = sin(time*15.0-.8+sin(time)*2.0)*.5+.5;\r\n\twave = wave*wave*(3.0-2.0*wave)-.7;\r\n\tfloat m = fract(time*.19);\r\n\thel = (1.0+sin(m*100.0)) * .02 * (smoothstep(0.0, .015, m) - smoothstep(0.05, .15, m));\r\n\tlow = (smoothstep(0.05, .1, m)-smoothstep(0.12, .15, m))*.11;\r\n\tnod = -(smoothstep(0.22, .28, m)-smoothstep(0.28, .31, m))*.5;\r\n\t\r\n\t\/\/ Camera position...\r\n\tfloat t = clamp(time-3.5, 0.0, 1.0);\r\n\tt = t*t*(3.0-2.0*t);\r\n\tvec3 origin = mix(vec3(0.0, 1.0, -1.275), vec3(-1.0, 1.0, -5.5), t);\r\n\tvec3 target = mix(vec3(0.0, 1.0, 4.0),  vec3( 0.5, -.4, 0.0), t);\r\n\torigin = mix(origin, vec3( 1.0, 1.0, -5.0), clamp((time-6.0)*.075, 0.0, 1.0));\r\n\r\n\t\/\/ Camera matrix...\r\n\tvec3 cw = normalize( target-origin);\r\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\r\n\tvec3 cu = normalize( cross(cw,cp) );\r\n\tvec3 cv = cross(cu,cw);\r\n\tvec3 ray = normalize( p.x*cu + p.y*cv + 2.6*cw );\r\n\r\n\t\/\/ Do the rendering...\r\n\tvec3 pos, norm;\r\n\tint hit = 0;\r\n\tvec2 res = RayMarch(origin, ray, fragCoord, hit);\r\n\r\n\tif (hit > 0)\r\n\t{\r\n\t\tpos = origin + res.x * ray;\r\n\t\t\/\/ Is it the ground?...\r\n\t\thit == 2 ? norm = vec3(0.0, 1.0, 0.0) : norm = Normal(pos);\r\n\r\n\t\tcol\t= GetMaterial(pos, norm, res.y);\r\n\t\t\r\n\t\tfloat diff = max(dot(norm, sunDir), 0.0);\r\n\t\tfloat ambi = clamp(.2 + 0.2 * norm.y,0.0, 1.0);\r\n\t\tfloat shad = Shadow(pos, sunDir);\r\n\t\tfloat spec = max( 0.0, pow( max( dot(sunDir,reflect(ray, norm)), 0.0), 5.0) ) * .08;\r\n\t\t\/\/ Do the lighting... \r\n\t\tvec3 lite = diff * sunColour * shad + col*ambi;\r\n\t\tcol = col * lite + spec * shad;\r\n\t\t\/\/ Fog the background...\r\n\t\tcol = mix(col, vec3(.85), clamp(res.x*res.x*.001-.2, 0.0, 1.0));\r\n\t}\t\r\n\t\r\n\t\/\/ Post effects...\r\n\tcol = pow(col,vec3(.5));\r\n\t\/\/ Add noise and fake flicker for old animation effect.\r\n\tfloat flick = max(1.-sin(fract(iGlobalTime*1.1) * PI), 0.0) * .03;\r\n\tcol += Hash(floor(p*iResolution.y*.25)-time) * .035 -flick;\r\n\tt = 32.0*q.x*q.y*(1.0-q.x)*(1.0-q.y);\r\n\t\/\/ Make screen edge effects to frame the scene and make it look older...\r\n\tcol   -= (1.0-pow(t, 0.1)) * .25;\r\n\tcol.y -= (1.0-pow(t, 0.3-flick*3.0)) * .1;\r\n\tcol.z -= (1.0-pow(t, 0.3)) * .05;\r\n    fragColor=vec4(clamp(col, 0.0, 1.0), 1.0 );\r\n}\r\n","name":"","description":"","type":"image"}]}}