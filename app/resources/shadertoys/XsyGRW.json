{"Shader":{"ver":"0.1","info":{"id":"XsyGRW","date":"1453359259","viewed":507,"name":"2D SDF Toy","username":"hughsk","description":"I've been using this to experiment with different DF operations, but keep losing my link to it! Putting it here for safe keeping <img src=\"\/img\/emoticonHappy.png\"\/> Note that you can use the mouse to test raymarching.","likes":29,"published":3,"flags":0,"tags":["2d","sdf","debug","toy"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define TRACE_STEPS 20\n#define TRACE_RAY\n\n\/\/ 0 = Distance Field Display\n\/\/ 1 = Raymarched Edges\n\/\/ 2 = Resulting Solid\n\/\/ 3 = Distance Field Polarity\n#define DISPLAY 0\n\n\/\/ 0 = Sine Wave\n\/\/ 1 = Circle\n\/\/ 2 = Offset Circle\n\/\/ 3 = Circle Join\n\/\/ 4 = Smooth Circle Join\n#define SCENE 3\n\n#if SCENE == 0\n  #define SAMPLER(p) shape_sine(p)\n#endif\n#if SCENE == 1\n  #define SAMPLER(p) shape_circle(p)\n#endif\n#if SCENE == 2\n  #define SAMPLER(p) shape_circle(p + vec2(0.7, 0))\n#endif\n#if SCENE == 3\n  #define SAMPLER(p) min(shape_circle(p - vec2(cos(iGlobalTime))), shape_circle(p + vec2(sin(iGlobalTime), 0)))\n#endif\n#if SCENE == 4\n  #define SAMPLER(p) shape_circles_smin(p, iGlobalTime * 0.5)\n#endif\n\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (b - a) \/ k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nvec2 squareFrame(vec2 screenSize, vec2 coord) {\n  vec2 position = 2.0 * (coord.xy \/ screenSize.xy) - 1.0;\n  position.x *= screenSize.x \/ screenSize.y;\n  return position;\n}\n\nconst float PI = 3.14159265359;\n\nfloat time = iGlobalTime;\n\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n  return a + b * cos(6.28318 * (c * t + d));\n}\n\n\/\/ r^2 = x^2 + y^2\n\/\/ r = sqrt(x^2 + y^2)\n\/\/ r = length([x y])\n\/\/ 0 = length([x y]) - r\nfloat shape_circle(vec2 p) {\n  return length(p) - 0.5;\n}\n\n\/\/ y = sin(5x + t) \/ 5\n\/\/ 0 = sin(5x + t) \/ 5 - y\nfloat shape_sine(vec2 p) {\n  return p.y - sin(p.x * 5.0 + time) * 0.2;\n}\n\nfloat shape_box2d(vec2 p, vec2 b) {\n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat shape_line(vec2 p, vec2 a, vec2 b) {\n  vec2 dir = b - a;\n  return abs(dot(normalize(vec2(dir.y, -dir.x)), a - p));\n}\n\nfloat shape_segment(vec2 p, vec2 a, vec2 b) {\n  float d = shape_line(p, a, b);\n  float d0 = dot(p - b, b - a);\n  float d1 = dot(p - a, b - a);\n  return d1 < 0.0 ? length(a - p) : d0 > 0.0 ? length(b - p) : d;\n}\n\nfloat shape_circles_smin(vec2 p, float t) {\n  return smin(shape_circle(p - vec2(cos(t))), shape_circle(p + vec2(sin(t), 0)), 0.8);\n}\n\nvec3 draw_line(float d, float thickness) {\n  const float aa = 3.0;\n  return vec3(smoothstep(0.0, aa \/ iResolution.y, max(0.0, abs(d) - thickness)));\n}\n\nvec3 draw_line(float d) {\n  return draw_line(d, 0.0025);\n}\n\nfloat draw_solid(float d) {\n  return smoothstep(0.0, 3.0 \/ iResolution.y, max(0.0, d));\n}\n\nvec3 draw_polarity(float d, vec2 p) {\n  p += iGlobalTime * -0.1 * sign(d) * vec2(0, 1);\n  p = mod(p + 0.06125, 0.125) - 0.06125;\n  float s = sign(d) * 0.5 + 0.5;\n  float base = draw_solid(d);\n  float neg = shape_box2d(p, vec2(0.045, 0.0085) * 0.5);\n  float pos = shape_box2d(p, vec2(0.0085, 0.045) * 0.5);\n  pos = min(pos, neg);\n  float pol = mix(neg, pos, s);\n\n  float amp = abs(base - draw_solid(pol)) - 0.9 * s;\n\n  return vec3(1.0 - amp);\n}\n\nvec3 draw_distance(float d, vec2 p) {\n  float t = clamp(d * 0.85, 0.0, 1.0);\n  vec3 grad = mix(vec3(1, 0.8, 0.5), vec3(0.3, 0.8, 1), t);\n\n  float d0 = abs(1.0 - draw_line(mod(d + 0.1, 0.2) - 0.1).x);\n  float d1 = abs(1.0 - draw_line(mod(d + 0.025, 0.05) - 0.025).x);\n  float d2 = abs(1.0 - draw_line(d).x);\n  vec3 rim = vec3(max(d2 * 0.85, max(d0 * 0.25, d1 * 0.06125)));\n\n  grad -= rim;\n  grad -= mix(vec3(0.05, 0.35, 0.35), vec3(0.0), draw_solid(d));\n\n  return grad;\n}\n\nvec3 draw_trace(float d, vec2 p, vec2 ro, vec2 rd) {\n  vec3 col = vec3(0);\n  vec3 line = vec3(1, 1, 1);\n  vec2 _ro = ro;\n\n  for (int i = 0; i < TRACE_STEPS; i++) {\n    float t = SAMPLER(ro);\n    col += 0.8 * line * (1.0 - draw_line(length(p.xy - ro) - abs(t), 0.));\n    col += 0.2 * line * (1.0 - draw_solid(length(p.xy - ro) - abs(t) + 0.02));\n    col += line * (1.0 - draw_solid(length(p.xy - ro) - 0.015));\n    ro += rd * t;\n    if (t < 0.01) break;\n  }\n\n  #ifdef TRACE_RAY\n    col += 1.0 - line * draw_line(shape_segment(p, _ro, ro), 0.);\n  #endif\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float t = iGlobalTime * 0.5;\n  vec2 uv = squareFrame(iResolution.xy, fragCoord);\n  float d;\n  vec3 col;\n  vec2 ro = vec2(iMouse.xy \/ iResolution.xy) * 2.0 - 1.0;\n  ro.x *= squareFrame(iResolution.xy, iResolution.xy).x;\n\n  vec2 rd = normalize(-ro);\n\n  d = SAMPLER(uv);\n\n  #if DISPLAY == 0\n    col = vec3(draw_distance(d, uv.xy));\n    col -= (iMouse.z > 0.0 ? 1.0 : 0.0) * vec3(draw_trace(d, uv.xy, ro, rd));\n  #endif\n  #if DISPLAY == 1\n    col += 1.0 - vec3(draw_line(d));\n    col += (iMouse.z > 0.0 ? 1.0 : 0.0) * vec3(1, 0.25, 0) * vec3(draw_trace(d, uv.xy, ro, rd));\n    col = 1. - col;\n  #endif\n  #if DISPLAY == 2\n    col = vec3(draw_solid(d));\n  #endif\n  #if DISPLAY == 3\n    col = vec3(draw_polarity(d, uv.xy));\n  #endif\n\n  fragColor.rgb = col;\n  fragColor.a   = 1.0;\n}","name":"","description":"","type":"image"}]}}