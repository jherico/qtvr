{"Shader":{"ver":"0.1","info":{"id":"4s33RX","date":"1451148250","viewed":293,"name":"Moon Rock","username":"foxes","description":"Procedural noised rock model with ray cast rendering.","likes":10,"published":3,"flags":0,"tags":["procedural","3d","noise","shadow","moon","rock","reycast"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define pradius 1.3\n#define mradius 0.1\n#define iterations 20.0\n#define shadowit 10.0\n#define line 0.39\n\nvec4 NC0=vec4(0.0,157.0,113.0,270.0);\nvec4 NC1=vec4(1.0,158.0,114.0,271.0);\n\nvec4 hash4( vec4 n ) { return fract(sin(n)*753.5453123); }\nfloat noise3( vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + dot(p.yz,vec2(157.0,113.0));\n    vec4 s1=mix(hash4(vec4(n)+NC0),hash4(vec4(n)+NC1),vec4(f.x));\n    return mix(mix(s1.x,s1.y,f.y),mix(s1.z,s1.w,f.y),f.z);\n}\n\nfloat heightMap(vec3 rad,float d)\n{\n    float iline=1.0\/(1.0-line);\n    float a=noise3(rad*1.6)*0.885;\n    float na=a;\n    if (a>line) a=pow((a-line)*iline,1.8)*(1.0-line)+line;\n    if (abs(d-a)<0.2) {\n        na+=noise3(rad*8.0)*0.1;\n        a=na;\n        if (a>line) a=pow((a-line)*iline,1.8)*(1.0-line)+line;\n    }\n    if (abs(d-a)<0.02) {\n        na+=noise3(rad*32.0)*0.01;\n        a=na;\n        if (a>line) a=pow((a-line)*iline,1.8)*(1.0-line)+line;\n    }\n    if (abs(d-a)<0.01) a+=noise3(rad*128.0)*0.005;\n    return a;\n}\n\nvec3 distObj(vec3 pos,vec3 ray,float radius,float minr)\n{\n    float b = dot(ray,pos);\n  \tfloat c = dot(pos,pos) - b*b;\n    \n    float sta=radius-minr;\n    float invm=1.0\/sta;\n    float rq=radius*radius;\n    vec3 dist=ray*10000.0;\n    if(c <rq)\n    {\n        vec3 r1 = (ray*(abs(b)-sqrt(rq-c))-pos);\n\t\tfloat maxs=abs(dot(r1,ray));\/\/*0.5;\n        if (c<minr*minr) {\n            vec3 r2 = (ray*(abs(b)-sqrt(minr*minr-c))-pos);\n            maxs=maxs-abs(dot(r2,ray));\n        }\/\/ else {\n            maxs*=0.5;\n        \/\/}\n        float len;\n        float h;\n\n        for (float m=0.0; (m<iterations); m+=1.0) {\n            len=length(r1);\n            vec3 d=r1\/len;\n            h=sta*heightMap(d,(len-minr)*invm)+minr;\n            if (abs(h-len)<0.0001) break;\n            maxs=abs(maxs);\n            if (len<h) maxs=-maxs;\n            r1+=ray*maxs*abs(len-h);\n            maxs*=0.99;\n        }\n        if (len<h+0.1) dist=r1+pos;\n    }\n    return dist;\n}\n\nfloat noiseSpace(vec3 ray,vec3 pos,float r,mat3 mr,float zoom,vec3 subnoise)\n{\n  \tfloat b = dot(ray,pos);\n  \tfloat c = dot(pos,pos) - b*b;\n    \n    vec3 r1=vec3(0.0);\n    \n    float s=0.0;\n    float d=0.0625*1.5;\n    float d2=zoom\/d;\n\n\tfloat rq=r*r;\n    float l1=sqrt(abs(r-c));\n    r1= (ray*(b-l1)-pos)*mr;\n\n    r1*=d2;\n    s+=abs(noise3(vec3(r1+subnoise))*d);\n    s+=abs(noise3(vec3(r1*0.5+subnoise))*d*2.0);\n    s+=abs(noise3(vec3(r1*0.25+subnoise))*d*4.0);\n    return s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) \/ iResolution.y;\n\n\tfloat mx = iMouse.x>0.0?iMouse.x\/iResolution.x*10.0:0.5;\n    float my = iMouse.y>0.0?iMouse.y\/iResolution.y*4.0-2.0:0.0;\n    vec2 rotate = vec2(mx+iGlobalTime*0.02,my);\n\n    vec2 sins=sin(rotate);\n    vec2 coss=cos(rotate);\n    mat3 mr=mat3(vec3(coss.x,0.0,sins.x),vec3(0.0,1.0,0.0),vec3(-sins.x,0.0,coss.x));\n    mr=mat3(vec3(1.0,0.0,0.0),vec3(0.0,coss.y,sins.y),vec3(0.0,-sins.y,coss.y))*mr;    \n    \n    float time=iGlobalTime*1.0;\n\t\n    vec3 ray = normalize(vec3(p,2.0));\n    vec3 ray1 = normalize(vec3(p+vec2(0.0,0.01),2.0));\n    vec3 ray2 = normalize(vec3(p+vec2(0.01,0.0),2.0));\n    vec3 pos = vec3(0.0,0.0,3.0);\n    \n    vec3 light=vec3(-30.0,0.0,-30.0);\n    \n    vec3 n1=distObj(pos*mr,ray1*mr,pradius,mradius);\n    vec3 n2=distObj(pos*mr,ray2*mr,pradius,mradius);\n    vec3 rt=distObj(pos*mr,ray*mr,pradius,mradius);\n    \n    vec3 lightn=normalize(light*mr-rt);\n    vec3 sd=distObj((pos-light)*mr,-lightn,pradius,mradius);\n    \n    float shadow=1.0-clamp(pow(length(sd+light*mr-rt),2.0)*200.0,0.0,1.0);\n    vec3 n=normalize(cross(n1-rt,n2-rt));\n    \n    \/\/fragColor = vec4(vec3(shadow),1.0);\n    fragColor.a = 1.0;\n    \n    if (length(n1)>100.0 || length(n2)>100.0 || length(rt)>100.0) fragColor.a=0.0;\n    \n    float s4=noiseSpace(ray,pos,100.0,mr,0.5,vec3(0.0));\n    if (fragColor.a<1.0) {\n        s4=pow(s4*1.8,5.7);\n        fragColor=vec4((mix(mix(vec3(1.0,0.0,0.0),vec3(0.0,0.0,1.0),s4*3.0),vec3(0.5),pow(s4*2.0,0.1))*s4*0.2),1.0);\n    } else {\n        rt=rt-pos*mr;\n        float fd=(length(rt)-mradius)\/(pradius-mradius);\n        float c=dot(n,lightn)*shadow;\n        if (fd<line) {\n        \tfragColor.xyz = mix(vec3(0.21,0.19,0.0),vec3(1.0,0.99,1.0),noise3(rt*128.0)*0.9+noise3(rt*8.0)*0.1)*c;\n        } else {\n            fragColor.xyz = mix(mix(vec3(1.0,1.0,0.9),vec3(0.8,0.79,0.7),noise3(rt*128.0)*0.9+noise3(rt*8.0)*0.1),vec3(1.0),pow(fd+0.5,10.0))*c;\n        }\n    }\n    \n    fragColor = min( vec4(1.0), fragColor );\n}\n","name":"","description":"","type":"image"}]}}