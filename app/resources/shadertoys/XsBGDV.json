{"Shader":{"ver":"0.1","info":{"id":"XsBGDV","date":"1393636185","viewed":1728,"name":"Stanford Torus","username":"TekF","description":"Because space.","likes":23,"published":3,"flags":0,"tags":["raymarching","scifi","spacestation"],"hasliked":0},"renderpass":[{"inputs":[{"id":4,"src":"\/presets\/tex03.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Ben Quantock 2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ parameters\nconst float SSradius = 200.0; \/\/ Okay, it's actually a lot smaller than the Stanford Torus, but it's a cool name.\nconst float SSthickness = 16.0;\n\nconst float angularSpeed = .221; \/\/ g = r*w^2, e.g. w = sqrt(9.81\/200) = .221\n\nvec3 SunDir = vec3(1,1,-1.5);\n\nconst float tau = 6.28318530717958647692;\n\nvec2 Noise( in vec3 x )\n{\n    vec3 p = floor(x), f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec4 rg = texture2D( iChannel0, (uv+0.5)\/256.0, -100.0 );\n\treturn mix( rg.yw, rg.xz, f.z );\n}\n\n\n#define MAX 1000.0\n\nfloat Foliage( vec3 pos )\n{\n\treturn\n\t\tmax(\n\t\t\tabs(pos.z)-SSthickness,\n\t\t\tabs(length(pos.xy)-SSradius-2.0 + Noise(pos\/16.0).x*2.0 + 2.0*abs(pos.z)\/SSthickness - 1.0)-1.0\n\t\t);\n\t\/\/ todo: leafiness\n}\n\nfloat Water( vec3 pos )\n{\n\treturn max( abs(pos.z)-SSthickness, abs(length(pos.xy)-SSradius-1.0)-1.0 );\n}\n\n\nfloat Building( vec3 pos, float seed )\n{\n\tif ( seed < .1 )\n\t\treturn length(vec3(pos.x,max(abs(pos.y)-2.0,0.0),pos.z))-2.0;\n\t\n\tvec3 p = pos;\n\tp.y += (seed-.5)*p.z;\n\tp = abs(p)-vec3(2,3,2);\n\tvec3 p2 = abs(pos+vec3(0,1.67,0))-vec3(1,.67,1);\n\treturn max(max(max(p.x,p.y),p.z),-max(p2.z,p2.y));\n}\n\n\nfloat Solid( vec3 pos )\n{\n\tfloat r = length(pos.xy);\n\t\n\tvec2 polar = vec2(atan(pos.x,-pos.y),length(pos.xy));\n\n\tvec3 spokep = pos;\n\tconst float spokeangle = tau\/5.0;\n\tfloat spokea = (fract(polar.x\/spokeangle)-.5)*spokeangle;\n\tspokep.xy = polar.y*vec2(sin(spokea),-cos(spokea));\n\t\n\treturn\n\t\tmin(min(\n\t\t\t\/\/ ring\n\t\t\tmax(max(\n\t\t\t\t\/\/ outer torus\n\t\t\t\tabs( length(vec2(pos.z, r-SSradius))-SSthickness-.5 )-.5,\n\t\t\t\t\/\/ window-gap\n\t\t\t\t5.0-abs(r-(SSradius-6.0))),\n\t\t\t\t\/\/ top gap\n\t\t\t\tmin(\n\t\t\t\t\t6.0-abs(pos.z), \/\/todo: close bottom\n\t\t\t\t\tSSradius-r\n\t\t\t\t)\n\t\t\t),\n\t\t\t\/\/ buildings\n\t\t\t\/\/length( vec3((fract(polar.x*40.0)-.5)*polar.y\/40.0,polar.y+1.0-SSradius,pos.z+30.0*(fract(pow(floor(polar.x*40.0)*.777,2.0))-.5) ) ) - .5\n\t\t\t\/\/length( vec3((fract(polar.x*20.0)-.5)*polar.y\/20.0,polar.y-SSradius,pos.z+30.0*(fract(pow(floor(polar.x*20.0)*.444,2.0))-.5) ) ) - 2.0\n\t\t\tBuilding( vec3((fract(polar.x*20.0)-.5)*polar.y\/20.0,polar.y-SSradius,pos.z+30.0*(fract(pow((floor(polar.x*20.0)+5.0)*.444,2.0))-.5) ), fract(pow(floor(polar.x*20.0)*.777,2.0)) )\n\t\t\t\/\/ could do roads connecting them, by drawing 2 for every position\n\t\t\t),\n\t\t\tmax(\n\t\t\t\tmin( min(\n\t\t\t\t\t\/\/ spokes\n\t\t\t\t\tmax(\n\t\t\t\t\t\t-SSradius-spokep.y,\n\t\t\t\t\t\tlength(spokep.xz)-2.0\n\t\t\t\t\t),\n\t\t\t\t\t\/\/ hub\n\t\t\t\t\tmax(\n\t\t\t\t\t\tr-20.0,\n\t\t\t\t\t\tabs(pos.z)-7.0\n\t\t\t\t\t)),\n\t\t\t\t\tmax(\n\t\t\t\t\t\tr-17.0,\n\t\t\t\t\t\tabs(pos.z)-9.0\n\t\t\t\t\t)\n\t\t\t\t),\n\t\t\t\t\/\/ dock\n\t\t\t\tmin(\n\t\t\t\t\t8.0-abs(pos.x),\n\t\t\t\t\t3.0-abs(pos.y)\n\t\t\t\t)\n\t\t\t)\n\t\t);\n}\n\n\n\/\/ smooth min, to prevent hard edges when I use union of lights\nfloat smin ( float a, float b )\n{\n\tconst float s = 1.0;\n\treturn -log2(exp2(-a\/s)+exp2(-b\/s))*s;\n}\n\n\nfloat Lights( vec3 pos )\n{\n\treturn\n\t\tsmin(smin(smin(smin(smin(smin(smin(smin(\/\/smin(\n\t\t\t\/\/ ring light\n\t\t\tlength(vec2(pos.z, length(pos.xy)-188.0))-.5,\n\t\t\t\/\/ landing lights\n\t\t\tlength(pos-vec3(-8,-3,-9))-.3),\n\t\t\tlength(pos-vec3( 8,-3,-9))-.3),\n\t\t\tlength(pos-vec3(-8, 3,-9))-.3),\n\t\t\tlength(pos-vec3( 8, 3,-9))-.3),\n\t\t\tlength(pos-vec3(-8,-3, 9))-.3),\n\t\t\tlength(pos-vec3( 8,-3, 9))-.3),\n\t\t\tlength(pos-vec3(-8, 3, 9))-.3),\n\t\t\tlength(pos-vec3( 8, 3, 9))-.3\/*),\n\t\t\tlength(pos-vec3(-8,-197,12.0*sin(iGlobalTime)))-.3*\/\n\t\t);\n}\n\nvec4 SampleLights( vec3 pos )\n{\n\t\/\/ like then Normal calc\n\tvec2 d = vec2(-1,1) * .1;\n\tvec3 p0 = pos+d.xxx; \/\/ tetrahedral offsets\n\tvec3 p1 = pos+d.xyy;\n\tvec3 p2 = pos+d.yxy;\n\tvec3 p3 = pos+d.yyx;\n\t\n\tfloat f0 = Lights(p0);\n\tfloat f1 = Lights(p1);\n\tfloat f2 = Lights(p2);\n\tfloat f3 = Lights(p3);\n\t\n\t\/\/ this direction is completely  innaccurrate for hard-edged intersections!\n\t\/\/ it gets one or other surface normal, rather than a smoothed result\n\t\/\/ so, build smooth light shapes\n\t\n\treturn vec4(\n\t\t\t\t-normalize( p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3) ),\n\t\t\t\t(f0+f1+f2+f3)\/4.0\n\t\t\t);\n}\n\n\nfloat DistanceField( vec3 pos )\n{\n\treturn min( min( min(\n\t\t\tFoliage( pos ),\n\t\t\tWater( pos ) ),\n\t\t\tSolid( pos ) ),\n\t\t\tLights( pos )\n\t\t);\n}\n\n\nfloat DistanceFieldNoLights( vec3 pos )\n{\n\treturn min( min(\n\t\t\tFoliage( pos ),\n\t\t\tWater( pos ) ),\n\t\t\tSolid( pos )\n\t\t);\n}\n\n\nstruct ShadeData { vec3 pos, ray, normal; float shadow; float t; };\nShadeData SetShadeData( vec3 pos, vec3 ray, vec3 normal, float shadow, float t )\n{\n\tShadeData s;\n\ts.pos = pos;\n\ts.ray = ray;\n\ts.normal = normal;\n\ts.shadow = shadow;\n\ts.t = t;\n\treturn s;\n}\n\n\nvec3 DiffuseLight( ShadeData s )\n{\n\t\/\/ sunlight\n\tvec3 sun = vec3(1)*2.0*max(.0,dot(s.normal,SunDir))*s.shadow;\n\t\n\t\/\/ local soft light sources\n\t\/\/ Actually sample the lights!!\n\tvec4 sl = SampleLights( s.pos );\n\tfloat fade = 1.0\/sl.w; \/\/ point lights should be 1\/(w*w), line lights are 1\/w, infinite area lights are 1\n\tvec3 local = vec3(.4,.7,1)*5.0*(dot(sl.xyz,s.normal)*.5+.5)*fade;\n\n\/*\t\/\/ like ambient occlusion, but towards the light\n\tIt's not quite right\n\tfloat lRange = s.t\/20.0;\n\tfloat lOcclusion = max( 0.0, 1.0 - DistanceFieldNoLights( s.pos + sl.xyz*lRange )\/(lRange*max(.1,dot(sl.xyz,s.normal))) );\n\tlocal *= exp2( -2.0*pow(lOcclusion,2.0) ); \/\/ tweak the curve*\/\n\t\n\t\/\/ ambient\n\tvec3 ambient = vec3(0) + local;\n\t\/\/ this ambient occlusion trick works ridiculously well\n\t\/\/ sample the distance field at a point in front of the surface\n\t\/\/ if there's a nearby concave surface the value will be less than the distance to the sample point\n\tfloat aoRange = s.t\/20.0;\n\tfloat occlusion = max( 0.0, 1.0 - DistanceFieldNoLights( s.pos + s.normal*aoRange )\/aoRange ); \/\/ can be > 1.0\n\tambient *= exp2( -2.0*pow(occlusion,2.0) ); \/\/ tweak the curve\n\t\n\treturn ambient+sun;\n}\n\n\nvec3 ShadeFoliage( ShadeData s )\n{\n\tvec3 albedo = mix( vec3(.05,.02,.01), vec3(.1,.5,.0), Noise(s.pos*20.0).x*.3+.7 );\n\t\n\treturn albedo*DiffuseLight(s);\n}\n\nvec3 ShadeWater( ShadeData s )\n{\n\tconst float albedoScale = 4.0;\n\tfloat rad = (SSradius+1.0)\/albedoScale;\n\trad = floor( rad*tau+.5 )\/tau; \/\/ round it so we get a whole number of texture repeats\n\tvec2 uv = vec2(s.pos.z\/albedoScale,atan(s.pos.x,s.pos.y)*rad);\n\t\n\tvec3 base = vec3(.05,.1,.2)*DiffuseLight(s);\n\t\n\t\/\/ normal map\n\tvec2 noise = (Noise( s.pos*2.0+iGlobalTime*vec3(-4,4,0) )*2.0-1.0)*.1;\n\tvec3 tangent = normalize(vec3(s.pos.y,-s.pos.x,0));\n\tvec3 binormal = vec3(0,0,1);\n\tvec3 normal = s.normal + tangent*noise.x + binormal*noise.y;\n\t\n\tfloat fresnel = dot(normal,s.ray);\n\tvec3 reflection = s.ray-2.0*fresnel*normal;\n\tfresnel = pow( 1.0-abs(fresnel), 5.0 );\n\t\n\tfloat up = dot( reflection, normal );\n\tfloat across = dot( reflection, binormal );\n\t\n\treturn mix( base, vec3(.4,.7,1)*1.0*pow(1.0-abs(across),10.0), fresnel );\n}\n\nvec3 ShadeSolid( ShadeData s )\n{\n\treturn vec3(.8) * DiffuseLight(s);\n}\n\nvec3 ShadeLights( ShadeData s )\n{\n\treturn vec3(.4,.7,1)*8.0*abs(dot(s.ray,s.normal)); \/\/ draw the lightbulb\n}\n\nvec3 Shade( ShadeData s )\n{\n\tfloat foliage = Foliage(s.pos);\n\tfloat water = Water(s.pos);\n\tfloat solid = Solid(s.pos);\n\tfloat lights = Lights(s.pos);\n\tfloat dist = min(min(min(foliage, water),solid),lights);\n\t\n\tif ( lights == dist )\n\t\treturn ShadeLights(s);\n\t\n#if (0) \/\/ test lighting\n\treturn DiffuseLight(s)*.8;\n#else\n\telse if ( foliage == dist )\n\t\treturn ShadeFoliage(s);\n\telse if ( water == dist )\n\t\treturn ShadeWater(s);\n\telse\n\t\treturn ShadeSolid(s);\n#endif\n}\n\n\n\/\/Compute the surface normal\nvec3 Normal( vec3 pos )\n{\n\t\/\/ in theory we should be able to get a good gradient using just 4 points\n\tvec2 d = vec2(-1,1) * .01;\n\tvec3 p0 = pos+d.xxx; \/\/ tetrahedral offsets\n\tvec3 p1 = pos+d.xyy;\n\tvec3 p2 = pos+d.yxy;\n\tvec3 p3 = pos+d.yyx;\n\t\n\tfloat f0 = DistanceField(p0);\n\tfloat f1 = DistanceField(p1);\n\tfloat f2 = DistanceField(p2);\n\tfloat f3 = DistanceField(p3);\n\t\n\treturn normalize( p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3) );\n}\n\n\nstruct Camera { vec3 pos, target, up; float zoom; };\n\nCamera SetCam( vec3 pos, vec3 target, vec3 up, float zoom )\n{\n\tCamera cam;\n\tcam.pos = pos;\n\tcam.target = target;\n\tcam.up = up;\n\tcam.zoom = zoom;\n\treturn cam;\n}\n\nCamera MixCam( Camera a, Camera b, float c )\n{\n\tCamera cam;\n\tcam.pos = mix( a.pos, b.pos, c );\n\tcam.target = mix( a.target, b.target, c );\n\tcam.up = mix( a.up, b.up, c );\n\tcam.zoom = mix( a.zoom, b.zoom, c );\n\treturn cam;\n}\n\nvec3 BGRot( in vec3 v, in vec3 cs )\n{\n\treturn vec3(v.xy*cs.x + v.yx*cs.yz, v.z);\n}\n\nvec2 Trace( vec3 pos, vec3 ray, vec2 interval )\n{\n\tfloat t = interval.x;\n\tfloat h;\n\tfor( int i=0; i<150; i++ )\n\t{\n\t\th = DistanceField( pos + t*ray );\n\t\tif ( h < .01 || t > interval.y )\n\t\t\tbreak;\n\t\tt += h;\n\t}\n\treturn vec2(t,h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\/\/ rotate background\n\tfloat a = iGlobalTime*angularSpeed; \/\/ radians per second\n\tvec3 cs = vec3( cos(a), sin(a)*vec2(1,-1) );\n\tSunDir = normalize( BGRot( SunDir, cs ) );\n\t\n\t\/\/ todo: animate camera between pairs of keyframes\n\tCamera camKeys[8];\n\tcamKeys[0] = SetCam( vec3(-400,-300,-300), vec3(0,0,0), vec3(0,.5,-1), .8 );\n\tcamKeys[1] = SetCam( vec3(-20,20.0-SSradius,-40), vec3(0,-SSradius,0), vec3(0,1,.5), .8 );\n\tcamKeys[2] = SetCam( vec3(-10,2.0-SSradius,16), vec3(0,-SSradius,0), vec3(0,1,0), .8 );\n\tcamKeys[3] = SetCam( vec3(30,2.5-SSradius,5), vec3(-SSradius,40.0-SSradius,-50), vec3(0,1,0), .8 );\n\tcamKeys[4] = SetCam( vec3(30,2.5-SSradius,5), vec3(-SSradius,40.0-SSradius,-50), vec3(0,1,0), .8 );\n\tcamKeys[5] = SetCam( vec3(-10,2.5-SSradius,2), vec3(0,SSradius,0), vec3(.5,3,1), 1.2 );\n\tcamKeys[6] = SetCam( vec3(200,-150,400), vec3(0,0,0), vec3(0,.5,1), .8 );\n\tcamKeys[7] = SetCam( vec3(0,0,50), vec3(0,0,0), vec3(cs.y,-cs.x,0), .8 );\n\n\t\/\/ pick a pair of cameras using time\n\t\/\/ todo: could manually pick cam using all combinations of \"iop\", shown on screen when auto-cycling (cam: io)\n\t\/\/ mouse moves cam along path, and target up\/down (by up*length(target-pos))\n\tfloat T = fract(iGlobalTime\/52.0)*4.0;\n\tCamera cam1, cam2;\n\tbool rotCam = false;\n\tif ( T < 1.0 ) { cam1 = camKeys[0]; cam2 = camKeys[1]; rotCam = true; }\n\telse if ( T < 2.0 ) { cam1 = camKeys[2]; cam2 = camKeys[3]; }\n\telse if ( T < 3.0 ) { cam1 = camKeys[4]; cam2 = camKeys[5]; }\n\telse { cam1 = camKeys[6]; cam2 = camKeys[7]; rotCam = true; }\n\t\n\t\/\/ mix between them\n\t\/\/T = smoothstep( .15, .85, fract(T) );\n\tT = fract(T);\n\tfloat T2 = T*T;\n\tT = (6.0*T2 - 15.0*T + 10.0)*T2*T;\n\tCamera cam = MixCam( cam1, cam2, T );\n\t\n\t\n\t\/\/Camera cam = SetCam( vec3(500.0*(iMouse.xy\/iResolution.xy-.5),0)+vec3(0,-300,-300), vec3(0,-100,0), vec3(0,1,0), .7 );\n\t\n\t\/\/ fire a ray from the camera\n\tvec3 pos = cam.pos;\n\tvec3 forward = normalize(cam.target-cam.pos);\n\tvec3 right = normalize(cross(cam.up,forward));\n\tvec3 up = normalize(cross(forward,right));\n\tvec3 ray = normalize(vec3( fragCoord.xy-iResolution.xy*.5, iResolution.x*cam.zoom ));\n\tray = right*ray.x + up*ray.y + forward*ray.z;\n\t\n\tif ( rotCam )\n\t{\n\t\tpos = BGRot( pos, cs );\n\t\tray = BGRot( ray, cs );\n\t}\n\t\n\t\/\/ intersect that ray with isosurface bounding volume\n\tvec2 interval = vec2(0,1000);\n\t\n\t\/\/ march isosurface\n\tvec2 th = Trace( pos, ray, interval );\n\t\n\t\/\/ shading\n\tvec3 col;\n\t\n\tif ( th.y < 1.0 ) \/\/ shade some near misses to reduce artefacts\n\t{\n\t\tvec3 p = pos + th.x*ray;\n\t\tvec3 n = Normal(p);\n\t\t\n\t\tfloat shadowBias = mix ( 1.0, .1, abs(dot( n, SunDir )) );\n\n\t\tfloat shadow = Trace( p, SunDir, vec2(shadowBias, 1000.0) ).y;\n\t\t\n\t\tshadow = smoothstep( .01, 4.0, shadow );\n\t\t\n\t\tcol = Shade( SetShadeData(p,ray,n,shadow,th.x) );\n\t}\n\telse\n\t{\n\t\t\/\/ draw background\n\t\tray = BGRot( ray, cs.xzy );\n\t\tfloat s = 1.3;\n\t\tvec3 X = texture2D( iChannel1, ray.yz*s ).rgb;\n\t\tvec3 Y = texture2D( iChannel1, ray.xz*s ).rgb;\n\t\tvec3 Z = texture2D( iChannel1, ray.xy*s ).rgb;\n\t\tcol = mix( X, Y, smoothstep(-.3,.3,abs(ray.y)-abs(ray.x)) );\n\t\tcol = mix( col, Z, smoothstep(-.3,.3,abs(ray.z)-max(abs(ray.x),abs(ray.y))) );\n\t\tcol = pow(col,vec3(7,5,3))*.1;\n\t}\n\n\tfragColor = vec4(pow(col,vec3(1.0\/2.2)),1.0);\n}","name":"","description":"","type":"image"}]}}