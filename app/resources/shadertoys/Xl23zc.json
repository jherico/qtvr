{"Shader":{"ver":"0.1","info":{"id":"Xl23zc","date":"1431021208","viewed":762,"name":"Ocean Thing","username":"Kyle273","description":"Wroley noise + distance fields. Terribly optimized!<br\/>Going for a wind-waker style water.","likes":3,"published":3,"flags":0,"tags":["distancefields","noob","wroley"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"const int MAX_ITER = 100;\nconst float MAX_DIST = 20.0;\nconst float EPS = 0.001;\n\n\n\nvec3 camOrigin = vec3(1.0 ,0.0,0.0);\n\n\nfloat length2(vec2 p){\n    return dot(p,p);\n}\n\nfloat noise(vec2 p){\n\treturn fract(sin(fract(sin(p.x) * (43.13311)) + p.y) * 31.0011);\n}\n\nfloat worley(vec2 p) {\n    \/\/Set our distance to infinity\n\tfloat d = 1e30;\n    \/\/For the 9 surrounding grid points\n\tfor (int xo = -1; xo <= 1; ++xo) {\n\t\tfor (int yo = -1; yo <= 1; ++yo) {\n            \/\/Floor our vec2 and add an offset to create our point\n\t\t\tvec2 tp = floor(p) + vec2(xo, yo);\n            \/\/Calculate the minimum distance for this grid point\n            \/\/Mix in the noise value too!\n\t\t\td = min(d, length2(p - tp - noise(tp)));\n\t\t}\n\t}\n\treturn 3.0*exp(-4.0*abs(2.5*d - 1.0));\n}\n\nfloat fworley(vec2 p) {\n    \/\/Stack noise layers \n\treturn sqrt(sqrt(sqrt(\n\t\tworley(p*5.0 + 0.05*iGlobalTime) *\n\t\tsqrt(worley(p * 50.0 + 0.12 + -0.1*iGlobalTime)) *\n\t\tsqrt(sqrt(worley(p * -10.0 + 0.03*iGlobalTime))))));\n}\n   \n\nfloat vNoisePlane(vec3 pos)\n{\n    vec2 xz = (pos.xz)*0.008;\n    float h = fworley(xz) - 2.0;\n    return -pos.y - h;\n    \n}\nfloat sphere(vec3 pos, float radius, vec3 center)\n{\n    float phi = dot(vec3(0.0,1.0,0.0),(normalize(center-pos)));\n    float theta = dot(vec3(1.0,0.0,0.0),(normalize(center-pos)));\n    return length(center-pos)-radius + 0.025*sin(10.0*(phi)) + 0.025*cos(10.0*(theta));\n}\nfloat distFunc(vec3 pos)\n{\n   \n   return  vNoisePlane(pos);\n}\n\nvec4 march(vec3 ray)\n{\n    float totalDist = 0.0;\n    vec3 pos = camOrigin;\n    float dist = EPS;\n    \n    for(int i = 0; i < MAX_ITER; i++)\n    {\n        if(dist < EPS || totalDist > MAX_DIST)\n        \tbreak;\n        dist = distFunc(pos);\n        totalDist += dist;\n        pos += dist*ray;\n    }\n    return vec4(pos,dist);\n}\n\nvec3 light(vec3 pos, vec3 rayDir)\n{\n    float amb = 0.1;\n    vec2 eps = vec2(0.0,EPS);\n    vec3 norm = normalize(vec3(\n        distFunc(pos+eps.yxx)-distFunc(pos-eps.yxx),\n        distFunc(pos+eps.xyx)-distFunc(pos-eps.xyx),\n        distFunc(pos+eps.xxy)-distFunc(pos-eps.xxy)));\n    float diffuse = max(0.0,dot(-rayDir,norm));\n    float spec = pow(diffuse,32.0);\n    return vec3(amb,diffuse,spec);\n                      \n}\nvec4 sun(vec2 uv)\n{\n    float sundist = dot(uv,uv)-0.25;\n    if(sundist < 0.)\n    {\n       \treturn vec4(mix(vec3(0.6,0.5,0.0),vec3(1.0), -sundist\/0.5), 1.0);\n    }\n    return vec4(0.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\t vec3 camTarget = vec3(0.0);\n\t\n\tvec3 upDir = vec3(0.0,1.0,0.0);\t\n\tvec3 camDir = normalize(camTarget-camOrigin);\n\tvec3 camRight = normalize(cross(upDir,camOrigin));\n\tvec3 camUp = cross(camDir, camRight);\n\tvec2 uv = -1.0 + 2.0*fragCoord.xy \/ iResolution.xy;\n    uv.x *= iResolution.x\/iResolution.y;\n    \/\/Orthographic ray march\n    vec3 rayDir = normalize(camRight*uv.x  + camUp*uv.y + camDir);\n    vec4 point = march(rayDir);\n    if(point.w < EPS)\n    {\n        vec3 amb = vec3(0.4,0.4,0.4);\n        vec3 dif = vec3(0.2,0.2,0.8);\n        vec3 spec =vec3(1.0,1.0,1.0);\n        vec3 l = light(point.xyz,rayDir);\n        vec3 col = amb*l.x + dif*l.y + spec * l.z;\n        fragColor = vec4(col, 1.0);\n        \n        if(fworley(point.xz * 0.008) > 0.9)\n        {\n            fragColor +=vec4(0.6);\n        }\n       \n        \n    }\n    else if(uv.y > -0.03)\n    {\n        \n        fragColor = vec4(mix(vec3(1.5,0.3,0.5),vec3(0.4,0.4,0.9),uv.y),1.0) + sun(uv);\n    }\n    else\n    {\n        fragColor = vec4(0.0);\n    }\n\t\n}","name":"","description":"","type":"image"}]}}