{"Shader":{"ver":"0.1","info":{"id":"4s3GW2","date":"1452369726","viewed":460,"name":"Fractal Explorer","username":"Dave_Hoskins","description":"MOUSE click to turn. WASD (or cursor keys) to move. SPACE\/SHIFT for speed up. Camera movement is click and drag.","likes":25,"published":3,"flags":112,"tags":["3d","fractal","multipass","fractalexplorer"],"hasliked":0},"renderpass":[{"inputs":[{"id":4,"src":"\/presets\/tex03.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":10,"src":"\/presets\/tex09.jpg","ctype":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Fractal Explorer. January 2016\n\/\/ by David Hoskins\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ https:\/\/www.shadertoy.com\/view\/4s3GW2\n\n\/\/--------------------------------------------------------------------------\n#define SUN_COLOUR vec3(1., .9, .85)\n#define FOG_COLOUR vec3(.15, 0.15, 0.17)\n#define MOD3 vec3(.1031,.11369,.13787)\n#define TAU 6.28318530718\n#define STORE_DE\n\nvec3 CSize;\nvec4 eStack[2];\nvec4 dStack[2];\nvec2 fcoord;\n\nvec2 camStore = vec2(0.0,  0.0);\nvec2 rotationStore\t= vec2(1.,  0.);\nvec2 mouseStore = vec2(2.,  0.);\nvec3 sunLight  = vec3(  0.4, 0.4,  0.3 );\n\n\/\/ By TekF...\nvoid BarrelDistortion( inout vec3 ray, float degree )\n{\n\tray.z \/= degree;\n\tray.z = ( ray.z*ray.z - dot(ray.xy,ray.xy) );\n\tray.z = degree*sqrt(ray.z);\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 loadValue3( in vec2 re )\n{\n    return texture2D( iChannel0, (0.5+re) \/ iChannelResolution[0].xy, -100.0 ).xyz;\n}\nvec2 loadValue2( in vec2 re )\n{\n    return texture2D( iChannel0, (0.5+re) \/ iChannelResolution[0].xy, -100.0 ).xy;\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ From https:\/\/www.shadertoy.com\/view\/4djSRW\nfloat Hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nmat3 RotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 Colour( vec3 p)\n{\n    p = p.xzy;\n\tfloat col\t= 0.0;\n    float r2\t= dot(p,p);\n\tfor( int i=0; i < 5;i++ )\n\t{\n\t\tvec3 p1= 2.0 * clamp(p, -CSize, CSize)-p;\n\t\tcol += abs(p.x-p1.z);\n\t\tp = p1;\n\t\tr2 = dot(p,p);\n        \/\/float r2 = dot(p,p+sin(p.z*.3)); \/\/Alternate fractal\n\t\tfloat k = max((2.)\/(r2), 0.027);\n\t\tp *= k;\n\t}\n    return texture2D(iChannel3, vec2(p.x+p.z, p.y)*.2).xyz+vec3(.4, .2, 0.2);\n}\n\n\/\/--------------------------------------------------------------------------\n\nfloat Map( vec3 p )\n{\n\tp = p.xzy;\n\tfloat scale = 1.;\n\tfor( int i=0; i < 12;i++ )\n\t{\n\t\tp = 2.0*clamp(p, -CSize, CSize) - p;\n\t\tfloat r2 = dot(p,p);\n        \/\/float r2 = dot(p,p+sin(p.z*.3)); \/\/Alternate fractal\n\t\tfloat k = max((2.)\/(r2), .027);\n\t\tp     *= k;\n\t\tscale *= k;\n\t}\n\tfloat l = length(p.xy);\n\tfloat rxy = l - 4.0;\n\tfloat n = l * p.z;\n\trxy = max(rxy, -(n) \/ 4.);\n\treturn (rxy) \/ abs(scale);\n}\n\n\n\n\/\/--------------------------------------------------------------------------\nfloat Shadow( in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 0.05;\n\tfloat h;\n\t\n    for (int i = 0; i < 15; i++)\n\t{\n\t\th = Map( ro + rd*t );\n\t\tres = min(5.0*h \/ t, res);\n\t\tt += h+.01;\n\t}\n    return max(res, 0.0);\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 DoLighting(in vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float d, in float sh)\n{\n    vec3 sunLight  = normalize( vec3(  0.4, 0.4,  0.3 ) );\n\/\/\tsh = Shadow(pos,  sunLight);\n    \/\/ Light surface with 'sun'...\n\tvec3 col = mat * SUN_COLOUR*(max(dot(sunLight,normal), 0.0)) *sh;\n    \/\/col += mat * vec3(0., .0, .15)*(max(dot(-sunLight,normal), 0.0));\n    \n    normal = reflect(eyeDir, normal); \/\/ Specular...\n    col += pow(max(dot(sunLight, normal), 0.0), 12.0)  * SUN_COLOUR * .5 *sh;\n    \/\/ Abmient..\n    col += mat * .2 * max(normal.y, 0.2);\n    col = mix(FOG_COLOUR,col, min(exp(-d*d*.015), 1.0));\n    \n\treturn col;\n}\n\n\n\/\/--------------------------------------------------------------------------\nvec3 GetNormal(vec3 p, float sphereR)\n{\n\tvec2 eps = vec2(sphereR*.5, 0.0);\n\treturn normalize( vec3(\n           Map(p+eps.xyy) - Map(p-eps.xyy),\n           Map(p+eps.yxy) - Map(p-eps.yxy),\n           Map(p+eps.yyx) - Map(p-eps.yyx) ) );\n}\n\n\/\/--------------------------------------------------------------------------\nfloat SphereRadius(in float t)\n{\n    t = t * .01*(400.\/iResolution.y);\n    return (t*t+0.005);\n}\n\n\/\/--------------------------------------------------------------------------\nfloat Scene(in vec3 rO, in vec3 rD)\n{\n\tfloat  alphaAcc = 0.0;\n\tfloat t = .05 * Hash(fcoord);\n\t\n\tvec3 p = vec3(0.0);\n    int hits = 0;\n\n\tfor( int j=0; j < 120; j++ )\n\t{\n\t\tif (hits == 8 || t > 14.0) break;\n\t\tp = rO + t*rD;\n\t\tfloat sphereR = SphereRadius(t);\n\t\tfloat de = Map(p);\n        \/\/ Is it within the sphere?...\n\t\tif( de < sphereR)\n\t\t{\n\t\t\t\/\/ Accumulate the alphas with the scoop of geometry from the sphere...\n            \/\/ Think of it as an expanding ice-cream scoop flying out of the camera! \n            \/\/ Rotate the stack and insert new value!...\n            \n\t\t\teStack[1].yzw = eStack[1].xyz; eStack[1].x = eStack[0].w;\n\t\t\teStack[0].yzw = eStack[0].xyz;\n            #ifdef STORE_DE\n            eStack[0].x = de-.001;\n            #else\n            float alpha = (1.0 - alphaAcc) * min(((sphereR-de+.001) \/ sphereR), 1.0);\n            \n            eStack[0].x = alpha;\n            #endif\n\t\t\tdStack[1].yzw = dStack[1].xyz; dStack[1].x = dStack[0].w;\n\t\t\tdStack[0].yzw = dStack[0].xyz; dStack[0].x = t;\n\t\t\thits++;\n            #ifndef STORE_DE\n   \t\t\talphaAcc += alpha;\n            #endif\n\n        }\n\t\tt +=  de +.003;\n         \n\t}\n\t\n\treturn clamp(alphaAcc, 0.0, 1.0);\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 PostEffects(vec3 rgb, vec2 xy)\n{\n\t\/\/ Gamma first...\n\trgb = pow(rgb, vec3(0.45));\n\n\t\/\/ Then...\n\t#define CONTRAST 1.4\n\t#define SATURATION 1.3\n\t#define BRIGHTNESS 1.3\n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\n\n\t\/\/ Vignette...\n\trgb *= .4+0.6*pow(180.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.35);\t\n\n\treturn clamp(rgb, 0.0, 1.0);\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 TexCube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec3 x = texture2D( sam, p.yz ).xzy;\n\tvec3 y = texture2D( sam, p.zx ).xyz;\n\tvec3 z = texture2D( sam, p.xy ).yzx;\n\treturn (x*abs(n.x) + y*abs(n.y) + z*abs(n.z))\/(abs(n.x)+abs(n.y)+abs(n.z));\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 Albedo(vec3 pos, vec3 nor)\n{\n    vec3 col = TexCube(iChannel1, pos*1.3, nor).zxy;\n    col *= Colour(pos);\n    return col;\n}\n\n\/\/----------------------------------------------------------------------------------------\n\nvec2 rot2D(inout vec2 p, float a)\n{\n    return cos(a)*p - sin(a) * vec2(p.y, -p.x);\n}\n\n\/\/--------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fcoord = fragCoord;\n\tfloat m = (iMouse.x\/iResolution.x)*20.0;\n\tfloat gTime = ((iGlobalTime+26.)*.2+m);\n    vec2 xy = fragCoord.xy \/ iResolution.xy;\n\tvec2 uv = (-1. + 2.0 * xy) * vec2(iResolution.x\/iResolution.y,1.0);\n\n    CSize = vec3(1., 1., 1.3);\n\t\n    vec3 cameraPos= loadValue3(camStore).xyz;\n    vec2 mou = loadValue2(rotationStore);\n\n    mou*= TAU;\n    mat3 mZ = RotationMatrix(vec3(.0, .0, 1.0), sin(iGlobalTime*.2)*.1);\n    mat3 mX = RotationMatrix(vec3(1.0, .0, .0),  mou.y);\n    mat3 mY = RotationMatrix(vec3(.0, 1.0, 0.0),-mou.x);\n    mX = mY * mX * mZ;\n    vec3 dir = vec3(uv.x, uv.y, 1.2);\n    BarrelDistortion(dir, .5);\n    dir = mX * normalize(dir);\n    \n\n\n\tvec3 col = vec3(.0);\n\t\n    for (int i = 0; i < 2; i++)\n    {\n\t\tdStack[i] = vec4(-20.0);\n        eStack[i] = vec4(0.0);\n    }\n     #ifdef STORE_DE\n    float alphaAcc = 0.0;\n    Scene(cameraPos, dir);\n    #else\n\tfloat alphaAcc = Scene(cameraPos, dir);\n    #endif\n\t\n\n\n    \/\/ Find the first hit for the shadow...\n    float d = 0.;\n    float de = -2.0;\n     for (int s = 1; s >= 0; s--)\n    {\n\t\tfor (int i = 3; i >= 0; i--)\n    \t{\n            if (dStack[s][i] > -19.0)\n            {\n            \td = dStack[s][i];\n            }\n        }\n    }\n    \/\/...The gamble pays off it seems....\n\tvec3 p = cameraPos + dir * d;\n    float sha = Shadow(p, sunLight);\n\n        \n    \/\/ Render both stacks...\n    for (int s = 1; s >= 0; s--)\n    {\n\t\tfor (int i = 3; i >= 0; i--)\n    \t{\n        \tfloat d = dStack[s][i];\n        \tif (d  > -19.)\n            {\n                float sphereR = SphereRadius(d);\n\n                 #ifdef STORE_DE\n                float  de = eStack[s][i];\n                float alpha = (1.0 - alphaAcc) * min(((sphereR-de) \/ sphereR), 1.0);\n                #else\n                float  alpha = eStack[s][i];\n                #endif\n\n                vec3 pos = cameraPos + dir * d;\n                vec3 normal = GetNormal(pos, sphereR);\n                vec3 alb = Albedo(pos, normal);\n                col += DoLighting(alb, pos, normal, dir, d, sha) * alpha;\n                #ifdef STORE_DE\n                alphaAcc+= alpha;\n                #endif\n            }\n\t\t}\n    }\n    \/\/ Fill in the rest with fog...\n   col += FOG_COLOUR *  clamp((1.0-alphaAcc), 0., 1.);\n   \n   \n\tcol = PostEffects(col, xy) * smoothstep(.0, 2.0, iGlobalTime);\t\n\t\n\tfragColor=vec4(col,1.0);\n}\n\n\/\/--------------------------------------------------------------------------","name":"","description":"","type":"image"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Buffer A stores first time the mouse was clicked, for keeping relative rotations.\n\n\/\/ by David Hoskins\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec2 clickStore\t= vec2(4.,  0.);\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\n\nfloat loadValue1( in vec2 re )\n{\n    return texture2D( iChannel0, (0.5+re) \/ iChannelResolution[0].xy, -100.0 ).x;\n}\n\nvoid storeValue1( in vec2 re, float va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? vec4(va, .0, .0, .0) : fragColor;\n}\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n\n\tfragColour = vec4(0);\n    float click = 0.0;\n    float oldClick = loadValue1(clickStore);\n    if (iFrame == 0) oldClick = 0.0;\n        \n    if (iMouse.z > 0.0)\n   \t{\n      if (oldClick == .0)\n        click = 1.0;\n    }\n  \n\tstoreValue1(clickStore, click,  fragColour, fragCoord);\n\n}","name":"","description":"","type":"buffer"},{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":637,"src":"https:\/\/soundcloud.com\/osage69\/aotb-t","ctype":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Flying camera code...\n\/\/ by David Hoskins\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define TAU 6.28318530718\n\n\nconst float KEY_W\t\t= 87.5\/256.0;\nconst float KEY_A\t\t= 65.5\/256.0;\nconst float KEY_S\t\t= 83.5\/256.0;\nconst float KEY_D\t\t= 68.5\/256.0;\nconst float KEY_LEFT  = 37.5\/256.0;\nconst float KEY_UP    = 38.5\/256.0;\nconst float KEY_RIGHT = 39.5\/256.0;\nconst float KEY_DOWN  = 40.5\/256.0;\n\nconst float KEY_SPACE\t= 32.5\/256.0;\nconst float KEY_SHIFT\t= 16.5\/256.0;\n\n\nvec2 clickStoreA = vec2(4.0,  0.0);\nvec2 camStore = vec2(0.0,  0.0);\nvec2 rotationStore\t= vec2(1.,  0.);\nvec2 mouseStore = vec2(2.,  0.);\nvec2 startStore\t\t= vec2(3.,  0.);\nvec2 timeStore = vec2(6.0,  0.0);\n\n\nbool isKeyPressed(float key)\n{\n\treturn texture2D( iChannel2, vec2(key, 0.25) ).x > .0;\n}\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nvec4 loadValue4( in vec2 re )\n{\n    return texture2D( iChannel1, (0.5+re) \/ iChannelResolution[1].xy, -100.0 );\n}\nvec3 loadValue3( in vec2 re )\n{\n    return texture2D( iChannel1, (0.5+re) \/ iChannelResolution[1].xy, -100.0 ).xyz;\n}\nvec2 loadValue2( in vec2 re )\n{\n    return texture2D( iChannel1, (0.5+re) \/ iChannelResolution[1].xy, -100.0 ).xy;\n}\nfloat loadValue1( in vec2 re )\n{\n    return texture2D( iChannel1, (0.5+re) \/ iChannelResolution[0].xy, -100.0 ).x;\n}\nfloat loadValueA1( in vec2 re )\n{\n    return texture2D( iChannel0, (0.5+re) \/ iChannelResolution[0].xy, -100.0 ).x;\n}\n\nvoid storeValue4( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? va : fragColor;\n}\nvoid storeValue3( in vec2 re, in vec3 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? vec4(va, 0.0) : fragColor;\n}\n\nvoid storeValue2( in vec2 re, in vec2 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? vec4(va, .0, .0) : fragColor;\n}\nvoid storeValue1( in vec2 re, in float va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? vec4(va, .0, .0, .0) : fragColor;\n}\nvec2 rot2D(inout vec2 p, float a)\n{\n    return cos(a)*p - sin(a) * vec2(p.y, -p.x);\n}\n\nmat3 RotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n   \tfragColour = vec4(0);\n    \n    \n\tvec2 tempStart \t= loadValue2(startStore);\n\tfloat click \t= loadValueA1(clickStoreA);\n    float time \t\t= loadValue1(timeStore);\n    \n    vec3 camPos;\n    vec2 rot;\n    if (iFrame == 0)\n    {\n        camPos = vec3(-13.0,-1.2,2.5);\n        rot = vec2(.2, 0.);\n    }else\n    {\n        camPos = loadValue3(camStore);\n        rot \t\t= loadValue2(rotationStore);\n    }\n\n\n    vec4 mouse = iMouse \/iResolution.xyxy;\n    \n    if (click > 0.0)\n    {\n    \ttempStart = mouse.xy;\/\/ First clicked\n    }\n    if (mouse.z > 0.0)\n    \trot += mouse.xy - tempStart;\n    \n    \n\tstoreValue2(startStore, tempStart,  fragColour, fragCoord);\n\tstoreValue2(rotationStore, rot,  fragColour, fragCoord);\n    \n    rot*= TAU;\n    mat3 mX = RotationMatrix(vec3(1.0, .0, .0), rot.y);\n    mat3 mY = RotationMatrix(vec3(.0, 1.0, 0.0), -rot.x);\n    mX = mY * mX;\n    \n       \n    \n \n\t\n    time = iGlobalTime - time;\n    float speed = time*.4;\n    if (isKeyPressed(KEY_SPACE) || isKeyPressed(KEY_SHIFT)) speed*=2.0;\n    if (isKeyPressed(KEY_W) || isKeyPressed(KEY_UP))\n\t{\n\t\tcamPos += mX * vec3(0,0,1)* speed;\n\t}\n    if (isKeyPressed(KEY_S) || isKeyPressed(KEY_DOWN))\n\t{\n\t\tcamPos += mX * vec3(0,0,-1)* speed;\n    }\n  \tif (isKeyPressed(KEY_D) || isKeyPressed(KEY_RIGHT))\n\t{\n\t\tcamPos += mX * vec3(1,0,0)* speed;\n\t}\n\tif (isKeyPressed(KEY_A) || isKeyPressed(KEY_LEFT))\n\t{\n\t\tcamPos += mX * vec3(-1,0,0) * speed;\n\t}\n    storeValue3(camStore, camPos,  fragColour, fragCoord);\n    storeValue1(timeStore, iGlobalTime,  fragColour, fragCoord);\n            \n}","name":"","description":"","type":"buffer"}]}}