{"Shader":{"ver":"0.1","info":{"id":"Xt23z3","date":"1430963214","viewed":1943,"name":"Ring Twister","username":"Flyguy","description":" Classic twister effect applied to a ring.","likes":36,"published":3,"flags":0,"tags":["distort","shading","ring","twist"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\n#define ANTI_ALIAS\n\n#define NUM_FACES 4\n#define IN_RADIUS 0.25\n#define OUT_RADIUS 0.70\n#define SCROLL_SPEED -0.9\n\n#define COLOR_1 0.50, 0.90, 0.95\n#define COLOR_2 0.95, 0.60, 0.10\n\nfloat tau = atan(1.0) * 8.0;\nfloat pi = atan(1.0) * 4.0;\nfloat aaSize = 2.0 \/ iResolution.y; \/\/Scale anti aliasing with resolution\n\nvec4 slice(float x0, float x1, vec2 uv)\n{\n    float u = (uv.x - x0)\/(x1 - x0);\n    float w = (x1 - x0);\n    vec3 col = vec3(0);\n    \n    \/\/Gradient\n    col = mix(vec3(COLOR_1), vec3(COLOR_2), u);\n    \n    \/\/Lighting \n    col *= w \/ sqrt(2.0 * IN_RADIUS*IN_RADIUS * (1.0 - cos(tau \/ float(NUM_FACES))));\n    \n    \/\/Edges\n    col *= smoothstep(0.05, 0.10, u) * smoothstep(0.95, 0.90, u) + 0.5;\n    \n    \/\/Checker board\n    uv.y += iGlobalTime * SCROLL_SPEED; \/\/Scrolling\n    \n    #ifdef ANTI_ALIAS\n    \tcol *= (-1.0 + 2.0 * smoothstep(-0.03, 0.03, sin(u*pi*4.0) * cos(uv.y*16.0))) * (1.0\/16.0) + 0.7;\n    #else\n    \tcol *= sign(sin(u * pi * 4.0) * cos(uv.y * 16.0)) * (1.0\/16.0) + 0.7;\n    #endif\n    \n    float clip = 0.0;\n    \n    #ifdef ANTI_ALIAS\n    \tclip = (1.0-smoothstep(0.5 - aaSize\/w, 0.5 + aaSize\/w, abs(u - 0.5))) * step(x0, x1);\n    #else\n    \tclip = float((u >= 0.0 && u <= 1.0) && (x0 < x1));\n    #endif\n    \n    return vec4(col, clip);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy \/ iResolution.y;\n\tvec2 uv = fragCoord.xy \/ iResolution.y;\n    uv -= res \/ 2.0;\n    uv *= 2.0;\n    \n    \/\/Polar coordinates\n    vec2 uvr = vec2(length(uv), atan(uv.y, uv.x) + pi);\n    uvr.x -= OUT_RADIUS;\n    \n    vec3 col = vec3(0.05);\n    \n    \/\/Twisting angle\n    float angle = uvr.y + 2.0*iGlobalTime + sin(uvr.y) * sin(iGlobalTime) * pi;\n    \n    for(int i = 0;i < NUM_FACES;i++)\n    {\n        float x0 = IN_RADIUS * sin(angle + tau * (float(i) \/ float(NUM_FACES)));\n        float x1 = IN_RADIUS * sin(angle + tau * (float(i + 1) \/ float(NUM_FACES)));\n        \n        vec4 face = slice(x0, x1, uvr);\n        \n        col = mix(col, face.rgb, face.a); \n    }\n    \n    \/\/col = (abs(uv.x) > 1.0) ? vec3(1) : col;\n    \n\tfragColor = vec4(col, 1.0);\n}","name":"","description":"","type":"image"}]}}