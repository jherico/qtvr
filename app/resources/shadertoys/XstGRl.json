{"Shader":{"ver":"0.1","info":{"id":"XstGRl","date":"1451717919","viewed":183,"name":"Everyday 002 - Pyramid","username":"Makio64","description":"Hi guys, this year I'm starting a \"everyday\" so here is a simple raymarching code template.<br\/><br\/>comments line 33 to get only one pyramid<br\/><br\/>If I'm doing anything wrong, thanks to let me know & Happy new year again!<br\/>","likes":6,"published":3,"flags":0,"tags":["raymarching","basic","pyramid","everyday"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Pyramid - raymarching\n\/\/ By David Ronai \/ @Makio64\n\n\/\/------------------------------------------------------------------ VISUAL QUALITY\n#define POSTPROCESS\n#define RAYMARCHING_STEP 40\n#define RAYMARCHING_JUMP 1.\n\/\/------------------------------------------------------------------ DEBUG\n\/\/#define RENDER_DEPTH\n\/\/#define RENDER_NORMAL\n\/\/#define RENDER_AO\n\nconst float PI = 3.14159265359;\n\n\/\/------------------------------------------------------------------  SIGNED PRIMITIVES\n\nfloat sdBox( vec3 p, vec3 b ){ return length(max(abs(p)-b,0.0)); }\nfloat sdBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b,0.0))-r; }\nfloat sdGround( in vec3 p ){ return p.y; }\n\n\/\/------------------------------------------------------------------ MAP\n\nfloat map( in vec3 pos ) {\n\tfloat d = 1000000.;\n\tvec3 q;\n\tfloat t = mod(iGlobalTime*2.,1.);\n\tfor(int i=-1; i < 10; i++){\n\t\tfloat ii = float(i);\n        float y = -.1+(-ii-t)*.2;\n        y += .2*t*smoothstep(8.,9.,ii);\n\t\tq = pos+vec3(0.,y,0.);\n        vec3 c = vec3(2.,0.,2.);\n        q = mod(q,c)-0.5*c;\n        float size = 1.-ii*.1-t*.1;\n\t\td = min(sdBox(q, vec3(size,.1,size)),d);\n\t}\n\td = min(d,sdGround(pos));\n\treturn d;\n}\n\n\/\/------------------------------------------------------------------ RAYMARCHING\n\n#ifdef RENDER_DEPTH\nfloat castRay( in vec3 ro, in vec3 rd, inout float depth )\n#else\nfloat castRay( in vec3 ro, in vec3 rd )\n#endif\n{\n\tfloat tmax = 15.;\n\tfloat precis = .01;\n\tfloat t = 0.0;\n\tfloat res;\n\tfor( int i=0; i<RAYMARCHING_STEP; i++ )\n\t{\n\t\tvec3 pos = ro+rd*t;\n\t\tres = map( pos );\n\t\tif( res<precis || t>tmax ) break;\n\t\tt += res*RAYMARCHING_JUMP;\n\t\t#ifdef RENDER_DEPTH\n\t\tdepth += 1.\/float(RAYMARCHING_STEP);\n\t\t#endif\n\t}\n\treturn t;\n}\n\nvec3 calcNormal(vec3 pos) {\n    float eps = 0.001;\n\tconst vec3 v1 = vec3( 1.0,-1.0,-1.0);\n\tconst vec3 v2 = vec3(-1.0,-1.0, 1.0);\n\tconst vec3 v3 = vec3(-1.0, 1.0,-1.0);\n\tconst vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\treturn normalize( v1 * map( pos + v1*eps ) +\n    \t              v2 * map( pos + v2*eps ) +\n        \t          v3 * map( pos + v3*eps ) +\n            \t      v4 * map( pos + v4*eps ) );\n}\n\nfloat hash( float n ){\/\/->0:1\n\treturn fract(sin(n)*3538.5453);\n}\n\nfloat calcAO( in vec3 p, in vec3 n, float maxDist, float falloff ){\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = n*l;\n\t\tao += (l - map( p + rd )) \/ pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao\/float(nbIte), 0., 1.);\n}\n\n\n\/\/------------------------------------------------------------------ POSTEFFECTS\n\n#ifdef POSTPROCESS\nvec3 postEffects( in vec3 col, in vec2 uv, in float time )\n{\n\t\/\/ gamma correction\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\t\/\/ vigneting\n\tcol *= 0.5+0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.15 );\n\treturn col;\n}\n#endif\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv )\n{\n\tvec3 col = vec3(.0,.0,1.2);\n\n\t#ifdef RENDER_DEPTH\n\tfloat depth = 0.;\n\tfloat t = castRay(ro,rd,depth);\n\t#else\n\tfloat t = castRay(ro,rd);\n\t#endif\n\n\t#ifdef RENDER_DEPTH\n\treturn vec3(depth\/10.,depth\/5.,depth);\n\t#endif\n\n\tvec3 pos = ro + t * rd;\n\tvec3 nor = calcNormal(pos);\n\n\t#ifdef RENDER_NORMAL\n\treturn nor;\n\t#endif\n\n\tfloat ao = calcAO(pos,nor,1.,0.1);\n\t#ifdef RENDER_AO\n\treturn vec3(ao);\n\t#endif\n\n\tvec3 light = vec3(.2,.5,.5);\n    col = vec3(1.,.2,.2)*min(max(dot(nor,light),.0) + .05, 1.);\n\tcol *= ao;\n    vec3 fog = vec3(.0,0.,0.);\n\tcol = mix( col, fog, 1.0-exp( -0.05*t*t ));\n\n\treturn col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\treturn mat3( cu, cv, cw );\n}\n\nvec3 orbit(float phi, float theta, float radius)\n{\n\treturn vec3(\n\t\tradius * sin( phi ) * cos( theta ),\n\t\tradius * cos( phi ),\n\t\tradius * sin( phi ) * sin( theta )\n\t);\n}\n\n\/\/------------------------------------------------------------------ MAIN\nvoid mainImage( out vec4 fragColor, in vec2 coords )\n{\n\tfloat time = iGlobalTime;\n\tvec2 uv = coords.xy \/ iResolution.xy;\n\tvec2 mouse = iMouse.xy \/ iResolution.xy;\n\tvec2 q = coords.xy\/iResolution.xy;\n\tvec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x\/iResolution.y;\n\n\t\/\/Camera\n\tfloat radius = 5.;\n\tvec3 ro = orbit(PI\/2.-.7,time,4.5);\n\tvec3 ta  = vec3(0.0, 0.5, 0.0);\n\tmat3 ca = setCamera( ro, ta, 0. );\n\tvec3 rd = ca * normalize( vec3(p.xy,2.) );\n\n\t\/\/ Raymarching\n\tvec3 color = render( ro, rd, uv );\n\t#ifdef POSTPROCESS\n\tcolor = postEffects( color, uv, time );\n\t#endif\n\tfragColor = vec4(color,1.0);\n}\n","name":"","description":"","type":"image"}]}}