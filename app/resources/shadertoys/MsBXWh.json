{"Shader":{"ver":"0.1","info":{"id":"MsBXWh","date":"1411331213","viewed":659,"name":"Circle - tangents","username":"Doublefresh","description":"More circles! This time: how to find tangent lines to circles. You can move the blue circle around.","likes":6,"published":3,"flags":0,"tags":["circles","geometry","tangents"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define LINETHICKNESS \t0.010\n#define LINECOLOUR \t\tvec3(0.3, 0.7, 0.1)\n#define RADIUS1\t\t\t0.12\n#define RADIUS2\t\t\t0.15\n\nfloat Plane(vec2 pix, vec3 plane)\n{\n    \/\/ Absolute distance to the plane(line in R^2)\n    float D = abs(dot(plane, vec3(pix, 1.0))); \n    return 1.2 * smoothstep(LINETHICKNESS, 0.0, D);\n}\n\nfloat Circle(vec2 pix, vec3 C)\n{\n    float r = length(C.xy - pix);\n    float d = abs(r - C.z);  \n    return smoothstep(0.015, 0.0, d) + 0.5*smoothstep(0.06, 0.00, r - C.z);\n}\n\n\/\/ Outer tangent lines for two circles \nfloat CircleOuterTangents(vec2 pix, vec3 C1, vec3 C2)\n{\n    vec3 dx = (C1 - C2) \/ distance(C1.xy, C2.xy);   \n    float ro = sqrt(1.0 - dx.z*dx.z);\n    \n    float X = dx.z*dx.x;\n    float Y = dx.z*dx.y;\n    float Z = dx.y*ro;\n    float W = dx.x*ro;\n    \n    float a = X - Z;\n    float b = Y + W;\n    float c = C1.z - (a*C1.x + b*C1.y);\n \n    float d = X + Z;\n    float e = Y - W;\n    float f = C1.z - (d*C1.x + e*C1.y);\n    \n    return Plane(pix, vec3(a,b,c)) + Plane(pix, vec3(d,e,f));\n}\n\n\/\/ Compute tangent lines for two circles \nfloat CirclesTangents(vec2 pix, vec3 C1, vec3 C2)\n{          \n    float outer = CircleOuterTangents(pix, C1, C2);\n    \/\/ The inner tangent lines are given by negating one of the circles' radii\n    C1.z *= -1.0;\n    float inner = CircleOuterTangents(pix, C1, C2);\n    \n    float signal = smoothstep(-0.15, 0.15, sin(iGlobalTime));    \n    return mix(inner, outer, signal);\n}\n\nvec3 Background(vec2 p)\n{\n \treturn length(p) * vec3(0.16, 0.15, 0.17) * (0.3 + abs(p.y)); \n}\n\nvec2 Mouse()\n{\n    vec2 r = (2.0 * iMouse.xy \/ iResolution.xy) - 1.0;\n    r.x *= iResolution.x \/ iResolution.y;\n    return r;\n}\n\nvec3 Scene(vec2 pix)\n{\n \tvec3 col = Background(pix);\n  \tfloat t = iGlobalTime;\n    \n    vec3 circle1 = vec3(Mouse(), RADIUS1);\n    vec3 circle2 = vec3(0.4*sin(t), 0.4*cos(t), RADIUS2);  \t\n    vec3 circle3 = vec3(0.7*cos(t), 0.7*sin(0.3*t), 0.15);\n    \n    col += vec3(0.1, 0.2, 0.7) * Circle(pix, circle1);\n    col += vec3(0.7, 0.0, 0.3) * Circle(pix, circle2);\n    col += vec3(0.6, 0.6, 0.63) * Circle(pix, circle3);\n    col += LINECOLOUR * CirclesTangents(pix, circle1, circle2);\n    col += (LINECOLOUR + vec3(0.5, -0.1, 0.5)) * CirclesTangents(pix, circle2, circle3);\n    col += (LINECOLOUR + vec3(0.2, -0.0, 0.7)) * CirclesTangents(pix, circle1, circle3);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = 2.0 * (fragCoord.xy \/ iResolution.xy) - 1.0;\n    p.x *= iResolution.x \/ iResolution.y;\n    \n    vec3 s = Scene(p);\n\tfragColor = vec4(s * (1.0 - 0.5 * length(p)), 1.0);\n}","name":"","description":"","type":"image"}]}}