{"Shader":{"ver":"0.1","info":{"id":"XsfGDn","date":"1366756943","viewed":10139,"name":"Texture - Better Filtering","username":"iq","description":"This shader shows how to avoid the ugly artifacts of bilinear texture filtering. You can find more information here: http:\/\/www.iquilezles.org\/www\/articles\/texture\/texture.htm","likes":56,"published":3,"flags":0,"tags":["2d","texture","filtering"],"hasliked":0},"renderpass":[{"inputs":[{"id":16,"src":"\/presets\/tex11.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/\n\/\/ This is the implementation for my article \"improved texture interpolation\"\n\/\/ \n\/\/ http:\/\/www.iquilezles.org\/www\/articles\/texture\/texture.htm\n\/\/\n\/\/ It shows how to get some smooth texture interpolation without resorting to the regular\n\/\/ bicubic filtering, which is pretty expensive because it needs 9 texels instead of the \n\/\/ 4 the hardware uses for bilinear interpolation.\n\/\/\n\/\/ With this techinique here, you van get smooth interpolation while the hardware still \n\/\/ uses only 4 texels, by tricking the hardware. The idea is to get the fractional part\n\/\/ of the texel coordinates and apply a smooth curve to it such that the derivatives are\n\/\/ zero at the extremes. The regular cubic or quintic smoothstep functions are just\n\/\/ perfect for this task.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy \/ iResolution.xy;\n    vec2 uv = p*0.1;\t\n\t\n    \/\/---------------------------------------------\t\n\t\/\/ regular texture map filtering\n    \/\/---------------------------------------------\t\n\tvec3 colA = texture2D( iChannel0, uv ).xyz;\n\n    \/\/---------------------------------------------\t\n\t\/\/ my own filtering \n    \/\/---------------------------------------------\t\n\tfloat textureResolution = 64.0;\n\tuv = uv*textureResolution + 0.5;\n\tvec2 iuv = floor( uv );\n\tvec2 fuv = fract( uv );\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv); \/\/ fuv*fuv*fuv*(fuv*(fuv*6.0-15.0)+10.0);;\n\tuv = (uv - 0.5)\/textureResolution;\n\tvec3 colB = texture2D( iChannel0, uv ).xyz;\n\t\n    \/\/---------------------------------------------\t\n    \/\/ mix between the two colors\n    \/\/---------------------------------------------\t\n\tfloat f = sin(3.14*p.x + 0.7*iGlobalTime);\n\tvec3 col = mix( colA, colB, smoothstep( -0.1, 0.1, f ) );\n\tcol *= smoothstep( 0.0, 0.01, abs(f-0.0) );\n\t\n    fragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}