{"Shader":{"ver":"0.1","info":{"id":"MlfGD8","date":"1421448217","viewed":755,"name":"Kali-Bergwerk","username":"bergi","description":"After a hit on the head, the dwarf seems to forgotten where she came from. Use the mouse to help her find the exit.","likes":1,"published":3,"flags":0,"tags":["raymarching","kaliset"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/*  Kali-Bergwerk\n\n\tAnother nice island in the absdot world\n    https:\/\/www.shadertoy.com\/view\/4tX3W8\n\t(lengthy fractal forums url ommitted for style)\n\n\taGPL3 \/ (c) 2014 stefan berke\n\n\tOh no, there is no flooooooo...\n\n\tThis tunnel would be a great fly-through show. \n\tUp\/down in the hardcoded path is actually the z coord\n\twhich can be travelled for a while.\n\tI messed with some path generation but today only came up with\n\tthis spline which behaves like a drunken mine worker.\n\n\tRaytracing the set is quite difficult for me in general.\n\tThis one looks not completely bad if you let the values untouched. \n\tIt's terribly wrong down there, but i couldn't fix it and keep the look..\n\tThe distant glitches are not very realistic but they show the\n\tinherent tree ornament when looking along z, which forms the cave.\n\n\tAnyways, just came across this part in 2d and it looked interesting. \n\tWould be create to find a function to describe a nice flight through the whole cave. \n\tSee the DEBUG_PLOT define and CEILING..\n*\/\n\n#define PATH 1\t\t\t\t\/\/ 0=mouse, 1=hardcoded spline\n#define NUM_ITER 25\t\t\t\/\/ iterations for distance field\n#define NUM_TEX_ITER 35\t\t\/\/ iterations for texture\n#define NORM_EPS 0.002\t\n#define NUM_TRACE 100\n#define PRECISSION 0.1\t\t\/\/ unfortunately needs very low stepwidth\n#define FOG_DIST 0.27\n#define NUM_SUPERSAMP 1  \t\/\/ super samples - super slow - and somewhat ugly\n\n\/\/ 1 for slice of the cave (mouse y for slice z-position, x for surface distance)\n\/\/ 2 for value graph of a slice\n#define DEBUG_PLOT 0\n\n#define CEILING 0\t\t\t\/\/ ornamental ceiling :)\n\n\/\/ shader-local global animation time\nfloat sec = iGlobalTime - 2.;\n\n\n\/\/ -------------------------- helper ------------------------------\n\n\/\/ just invented these, not special, rather lousy\nfloat hash(float x) { return fract(sin(x*123.543912)*55.39284); }\nvec3 hash3(vec3 x) { return fract(cos(x * vec3(1123.481, 135.2854, 385.21))\n                                        * vec3(1593.70341, 23142.54073, 497.2)); }\nfloat noise(float x)\n{\n    float f = floor(x), t = fract(x);\n    return hash(f) * (1.-t) + t * hash(f+1.);\n}\n\n\nvec2 rotate(in vec2 v, float r)\n{\n\tfloat s = sin(r), c = cos(r);\n    \treturn vec2(v.x * c - v.y * s, v.x * s + v.y * c);\n}\n\n\/\/ cubic \nvec2 spline(float x, vec2 v0, vec2 v1, vec2 v2, vec2 v3) \n{\n\tvec2 p = (v3 - v2) - (v0 - v1);\n\treturn p*(x*x*x) + ((v0 - v1) - p)*(x*x) + (v2 - v0)*x + v1;\n}\n\n\/\/ -------------------------- fractal -----------------------------\n\n\n\/* Kali set\n   somewhere in the sqaure x,y ~[0,1] is a nice 'metal-tree-skelleton-hand-snake-tunnel' \n   where a result of at least 0.1 should be the inside to make it a cave\n   the 'tree decoration' is on the xy-plane while the actual tunnel expands along z.\n   The fractal parameter is locked to the x position.\n*\/\nfloat tunnelthing_scalar(in vec3 p)\n{\n    p *= 0.2;\n    p.x += 0.12;\n    vec3 param = vec3(p.x);\n    p.xy *= 4.;\n    \n\tfloat mag, ac = 0.;\n\tfor (int i=0; i<NUM_ITER; ++i)\n    {\n\t\tmag = dot(p, p);\n        p = abs(p) \/ mag - param;\n        ac += mag;\n    }\n    return 0.1 * ac \/ float(NUM_ITER);\n}\n\n\/\/ same as above but other iteration count\n\/\/ and a color as return value\nvec3 tunnel_texture(in vec3 p)\n{\n    vec3 pin = p;\n    p *= 0.2;\n    p.x += 0.12;\n    vec3 param = vec3(p.x);\n    p.xy *= 4.;\n    \n\tfloat mag;\n    vec3 ac = vec3(0.);\n\tfor (int i=0; i<NUM_TEX_ITER; ++i)\n    {\n        p = abs(p) \/ dot(p, p) - param;\n        ac += 0.5+0.5*sin(p*84.);\n        ac.xy = rotate(ac.xy, p.z);\n        ac.xz = rotate(ac.xz, p.y);\n    }\n    ac = clamp(1.1 * ac \/ float(NUM_TEX_ITER), 0., 1.);\n    \n    float mixf = 0.5*(ac.y*2.+ac.z);\n#if CEILING == 1\n    mixf += smoothstep(0.5, 0.6, pin.z);\n#endif    \n\n    return mix(vec3(0.3,0.5,0.8), ac, mixf);\n\n}\n\n\/\/ position in the tunnel for [0,1]\nvec3 tunnelpos(float t)\n{\n    t *= 21.;\n    vec2 p1  = vec2(0.1, 0.8);\n    vec2 p2  = vec2(0.175, 0.73);\n    vec2 p3  = vec2(0.21, 0.68);\n\tvec2 p4  = vec2(0.22, 0.66);\n\tvec2 p5  = vec2(0.24, 0.61);\n    vec2 p6  = vec2(0.27, 0.59);\n    vec2 p7  = vec2(0.265, 0.55);\n    vec2 p8  = vec2(0.29, 0.50);\n    vec2 p9  = vec2(0.33, 0.52);\n    vec2 p10 = vec2(0.33, 0.47);\n    vec2 p11 = vec2(0.32, 0.47);\n    vec2 p12 = vec2(0.30, 0.45);\n    vec2 p13 = vec2(0.31, 0.37);\n    vec2 p14 = vec2(0.36, 0.35);\n    vec2 p15 = vec2(0.40, 0.38);\n    vec2 p16 = vec2(0.42, 0.38);\n    vec2 p17 = vec2(0.40, 0.41);\n    vec2 p18 = vec2(0.41, 0.45);\n    \/\/ the last part is even more crappy \n    vec2 p19 = vec2(0.46, 0.49);\n    vec2 p20 = vec2(0.51, 0.475);\n    vec2 p21 = vec2(0.545, 0.385);\n    vec2 p22 = vec2(0.535, 0.30);\n    vec2 p23 = vec2(0.47, 0.26);\n\n    vec2 p;\n         if (t < 1.)  p = spline(t,     p1,p2,p3,p4);\n    else if (t < 2.)  p = spline(t-1.,  p2,p3,p4,p5);\n    else if (t < 3.)  p = spline(t-2.,  p3,p4,p5,p6);\n    else if (t < 4.)  p = spline(t-3.,  p4,p5,p6,p7);\n    else if (t < 5.)  p = spline(t-4.,  p5,p6,p7,p8);\n    else if (t < 6.)  p = spline(t-5.,  p6,p7,p8,p9);\n    else if (t < 7.)  p = spline(t-6.,  p7,p8,p9,p10);\n    else if (t < 8.)  p = spline(t-7.,  p8,p9,p10,p10);\n    else if (t < 9.)  p = spline(t-8.,  p9,p10,p11,p12);\n    else if (t < 10.) p = spline(t-9.,  p10,p11,p12,p13);\n    else if (t < 11.) p = spline(t-10., p11,p12,p13,p14);\n    else if (t < 12.) p = spline(t-11., p12,p13,p14,p15);\n    else if (t < 13.) p = spline(t-12., p13,p14,p15,p16);\n    else if (t < 14.) p = spline(t-13., p14,p15,p16,p17);\n    else if (t < 15.) p = spline(t-14., p15,p16,p17,p17);\n    else if (t < 16.) p = spline(t-15., p16,p17,p18,p18);\n    else if (t < 17.) p = spline(t-16., p17,p18,p19,p19);\n    else if (t < 18.) p = spline(t-17., p18,p19,p20,p20);\n    else if (t < 19.) p = spline(t-18., p19,p20,p21,p21);\n    else if (t < 20.) p = spline(t-19., p20,p21,p22,p22);\n    else if (t < 21.) p = spline(t-20., p21,p22,p23,p23);\n        \n    return vec3( p, 0.54)  \n           \/\/+ 0.01*sin(vec3(sec*0.3,sec*0.5,sec*0.7))\n        \t;\n}\n\n\n\n\/\/ ---- canonical rayder  ----\n\n\/\/ 'distance' to the kali set\n\/\/ not really a distance of course\n\/\/ the scaling at the end is matched somewhat to \n\/\/ what the raytracer like\n\/\/ in fact as you can see, it returns a negative value. \n\/\/ somehow this renders better (less noise)\n\/\/ but it screws up everything below. \n\/\/ camera is tracing backwards omg\n#if CEILING == 0\nfloat scene_d(in vec3 p) { return (tunnelthing_scalar(p) - 0.5) * 0.1; }\n\n#else\nfloat scene_d(in vec3 p) \n{ \n    float flr = smoothstep(0.58, 0.6, p.z);\n    return (tunnelthing_scalar(p) - 0.5) * 0.1 * (1.-flr); \n}\n#endif\n\nvec3 scene_n(in vec3 p)\n{\n\tconst vec3 e = vec3(NORM_EPS, 0., 0.);\n\treturn normalize(vec3(\n\t\t\tscene_d(p + e.xyy) - scene_d(p - e.xyy),\n\t\t\tscene_d(p + e.yxy) - scene_d(p - e.yxy),\n\t\t\tscene_d(p + e.yyx) - scene_d(p - e.yyx) ));\n}\n\nvec3 sky_color(in vec3 pos, in vec3 dir)\n{\n\treturn vec3(0.2,0.6,0.9);\n}\n\n\/\/ returns final color\nvec3 traceRay(in vec3 pos, in vec3 dir)\n{\n\tvec3 p;\n\tfloat t = 0.;\n\tfor (int i=0; i<NUM_TRACE; ++i)\n\t{\n\t\tp = pos + t * dir;\n\t\tfloat d = scene_d(p);\n\n        \/\/ increase distance for too close surfaces\n        d += 0.01*(1. - smoothstep(0.01, 0.011, t));\n\n\t\tt += d * PRECISSION;\n\t}\n\n    vec3 nrm = scene_n(p),\n    \n         ambcol = tunnel_texture(p);\n    \n    \/\/ lighting\n    float dull = max(0., dot(nrm, vec3(0.707)));\n\tdull = pow(dull, 2.);\n    \/\/ another ambient light\n    dull += max(0., dot(nrm, normalize(vec3(-1.,-0.3,2.))));\n    \n    vec3 col = ambcol * (0.3 + 0.7 * dull);\n\n    return mix(col, col.zyx*0.3, min(2.0, -t\/FOG_DIST));\n}\n\n\n\n\n\/\/ ---------- helper --------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy \/ iResolution.xy * 2. - 1.;\n    vec2 mouse = iMouse.xy \/ iResolution.xy;\n\n    \/\/ ----------- plot cave slice -----------\n#if DEBUG_PLOT == 1\n\n    vec3 p = vec3(uv*0.5+0.5, mouse.y);\n    float k = tunnelthing_scalar(p);\n    \n    float b = k > 0.09 + 0.9*mouse.x ? 1. : 0.;\n\t    \n    fragColor = vec4(b * tunnel_texture(p), 1.);\n#endif\n\n    \/\/ ----------- plot value graph -----------\n#if DEBUG_PLOT == 2\n\n    vec3 p = vec3(uv.x, mouse.x, mouse.y);\n    float k = tunnelthing_scalar(p);\n    \n    uv.y = (uv.y+1.) * 4.;\n    float b = k >= uv.y ? 1. : 0.;\n    \n    float grid = smoothstep(0.9,1., mod(uv.y, 1.));\n    \n    fragColor = vec4(b, b, grid, 1.);\n#endif\n\n    \/\/ ---------- render thing ----------\n#if DEBUG_PLOT == 0\n    \n    \/\/ aspect\n    uv.x *= float(iResolution.x) \/ float(iResolution.y);\n    \n\t\/\/ look-at\n    vec3 dir = normalize(vec3(uv, -1.5));\n\n#if PATH == 0\n    vec3 pos = vec3((mouse.x-0.5) * 5. + 0.001 * sin(sec), \n                     mouse.x-0.5       + 0.001 * sin(sec*1.1) + 0.07,\n                     0.0 + mouse.y*5.);\n    \n#elif PATH == 1\n    float derd = 1.;\n    vec3 pos = tunnelpos(0.5+0.5*sin(sec\/10.));\n    \/\/ path derivative\n    vec3 posd = (tunnelpos(0.5+0.5*sin((sec+derd)\/10.)) - pos) \/ derd;\n    float movespeed = length(posd);\n    \n    \/\/ walk-up-down\n#ifdef SCENE == 0\n    pos.z += 0.02*length(posd)*sin(sec*9.)\n           - 0.05+.05*sin(sec\/6.);\n#endif    \n    \n    \/\/ look along path\n    float rotz = atan(-posd.x, posd.y);\n\n    \/\/ 'yaw'\n    float rotup = -4.*movespeed;\n    if (iMouse.z < 0.5)\n    \t\/\/ occasionally look up\n        rotup -= 1.13 * (1. - pow(noise(sec*1.), 3.));\n\n    \/\/ ego interaction\n    if (iMouse.z > 0.5)\n    {\n      \trotz = -iMouse.x \/ iResolution.x * 6.;\n        rotup += iMouse.y \/ iResolution.y * 4.;\n    }\n\n    dir.yz = rotate(dir.yz, rotup);\n    dir.xy = rotate(dir.xy, rotz);\n#endif\n    \n    \/\/ run\n#if NUM_SUPERSAMP <= 1\n    vec3 col = traceRay(pos, dir);\n#else\n\tvec3 col = vec3(0.);\n    float dofs = 0.1 + 0.03 * float(NUM_SUPERSAMP);\n    for (int i=0; i<NUM_SUPERSAMP; ++i)\n    {\n        \/\/ some ill-formed dof\n        \/\/ after the dir vec is already set\n        vec3 dis = hash3(vec3(uv, 1.1) * float(1+i)) - 0.5;\n\t\tvec3 di = normalize(dir + dofs*0.05*dis);\n        vec3 p = pos + 0.004*dofs*dis;;\n        col += traceRay(p, di);\n    }\n    col \/= float(NUM_SUPERSAMP);\n#endif\n    \n   \tfragColor = vec4(col,1.0);\n#endif\n}","name":"","description":"","type":"image"}]}}