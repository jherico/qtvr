{"Shader":{"ver":"0.1","info":{"id":"4sf3Dj","date":"1379099558","viewed":5335,"name":"Gamecube","username":"fb39ca4","description":"Phew. That took a while to get looking right. I apologize for the lack of optimization. Anyone good at doing text? All that's missing is the words \"Nintendo Gamecube.\"<br\/><br\/>If it doesn't work and you are using Windows, please disable ANGLE in your browser. ","likes":45,"published":3,"flags":0,"tags":["raymarching","cube","logo","animation","gamecube"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"const int MAX_RAY_STEPS = 20;\n\nconst float pi = 3.14159265359;\n\nfloat maxcomp(vec2 v) { return max(v.x, v.y); }\nfloat maxcomp(vec3 v) { return max(v.x, max(v.y, v.z)); }\n\nfloat mincomp(vec3 v) { return min(v.x, min(v.y, v.z)); }\n\nfloat sum(vec3 v) { return v.x + v.y + v.z; }\n\nvec2 rotate2d(vec2 v, float a) { return vec2(v.x * cos(a) - v.y * sin(a), v.y * cos(a) + v.x * sin(a)); }\n\nfloat smootherstep(float edge0, float edge1, float x)\n{\n    x = clamp((x - edge0)\/(edge1 - edge0), 0.0, 1.0);\n    return x*x*x*(x*(x*6.0 - 15.0) + 10.0);\n}\n\nfloat pulse1(float x) {\n\tx = x \/ (1.0 + 2.5 * step(0.0, x));\n\tx = clamp(abs(x), 0.0, 1.0);\n\treturn 1.0 - x*x*x*(x*(x*6.0 - 15.0) + 10.0);\t\n}\n\nfloat pulse2(float x) {\n\tx = x \/ (1.0 + 1.5 * step(0.0, x));\n\treturn 1.0 - smoothstep(0.0, 1.0, abs(x));\t\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdBox2p(vec3 p, vec3 b1, vec3 b2) {\n\tvec3 pos = (b1 + b2) \/ 2.0;\n\tvec3 b = (b2 - b1) \/ 2.0;\n\treturn sdBox(p - pos, b);\n}\n\nfloat tileCubeShell(vec3 p, float t) {\n\treturn max(p.y, -min(p.x, p.z));\n}\n\nfloat marchingCube(vec3 p, float t) {\n\tp.z -= floor(t);\n\tp.y += 0.5;\n\tp.z -= 0.5;\n\tp.yz = rotate2d(p.yz, -mod(t, 1.0) * pi \/ 2.0);\n\tp.y -= 0.5;\n\tp.z += 0.5;\n\treturn sdBox(p, vec3(0.40)) - 0.05;\n}\n\nfloat tumblingCube(vec3 p, float t) {\n\tt = clamp(t * 0.333, 0.0, 1.0);\n\tvec3 pos;\n\tpos.x = mix(0.5, 0.65, t);\n\tpos.y = -14.0 * t * t + 14.0 * t + mix(-0.5, -0.65, t);\n\tpos.z = mix(-0.5, 0.65, t);\n\tfloat size = mix(0.4, 0.65, pow(t, 4.0));\n\tfloat cornerRounding = mix(0.05, 0.1, pow(t, 4.0));\n\tfloat rot = min(mix(0.0, 2.0 * pi, 2.0 * smoothstep(0.0, 1.0, t)), 2.0 * pi);\n\treturn sdBox(vec3(p.x - pos.z, rotate2d(p.yz - pos.yz, rot)), vec3(size)) - cornerRounding;\t\n}\n\nfloat marchingCubePath(vec3 p, float t) {\n\tif (t < 0.0) \n\t\treturn sdBox(p - vec3(2.5, max(-0.5 - 3.0 * (t + 1.0), 0.5), 0.5), vec3(0.40)) - 0.05;\n\telse if (t < 2.0) \n\t\treturn marchingCube(p - vec3(2.5, 0.5, 0.5), t);\n\telse if (t < 5.0) \n\t\treturn marchingCube(p.zyx * vec3(1.0, 1.0, -1.0) - vec3(2.5, 0.5, -2.5), t - 2.0);\n\telse if (t < 8.0) \n\t\treturn marchingCube(p.zxy * vec3(1.0, -1.0, -1.0) - vec3(2.5, 0.5, -0.5), t - 5.0);\n\telse if (t < 11.0) \n\t\treturn marchingCube(p.yxz * vec3(1.0, -1.0, -1.0) - vec3(-2.5, 0.5, -2.5), t - 8.0);\n\telse if (t < 14.0)\n\t\treturn marchingCube(p.yzx * vec3(1.0, -1.0, 1.0) - vec3(-2.5, 0.5, -0.5), t - 11.0);\n\telse if (t < 16.0)\n\t\treturn marchingCube(p.xzy * vec3(1.0, -1.0, 1.0) - vec3(2.5, 0.5, -2.5), t - 14.0);\n\telse if (t < 18.0)\n\t\treturn marchingCube(p.yzx * vec3(1.0, -1.0, -1.0) - vec3(-0.5, 0.5, -2.5), t - 16.0);\n\telse\n\t\treturn tumblingCube(p, t - 18.0);\n}\n\nfloat finalLogoScene(vec3 p, float t) {\n\tfloat thickness = 0.1;\n\tp.y = -p.y;\n\tfloat shell = max(sdBox2p(p, vec3(0.0), vec3(3.0)), -sdBox2p(p, vec3(thickness), vec3(8.0)));\n\tshell = max(shell, -sdBox2p(p, vec3(-8.0), vec3(2.0)));\n\tshell = max(shell, -sdBox2p(p, vec3(1.0, -1.0, thickness), vec3(4.0, 5.0, 1.0)));\n\tshell = min(shell, sdBox2p(p, vec3(0.0), vec3(3.0, 1.0, thickness)));\n\tshell = min(shell, sdBox2p(p, vec3(0.0), vec3(1.4)));\n\treturn shell;\n}\n\nfloat scene(vec3 p, float t) {\n\tfloat bigCube = tileCubeShell(p, t);\n\tfloat littleCube = marchingCubePath(p, t - 10.0);\n\treturn min(bigCube, littleCube);\n}\n\nfloat getMaterial(vec3 p, float t) {\n\tfloat bigCube = tileCubeShell(p, t);\n\tfloat littleCube = marchingCubePath(p, t - 10.0);\n\tif (bigCube < littleCube) return 0.0;\n\telse return 1.0;\n}\n\nfloat sideY(vec3 p, float t) {\n\tvec3 p1 = vec3(2.5, p.y, min(0.5 + t, p.z));\n\tvec3 p2 = vec3(max(3.5 - (t - 1.0), p.x), p.y, 2.5);\n\treturn max(1.0 - min(length(p - p1), length(p - p2)), 0.0) * step(1.0, p.z);\n}\n\nfloat sideX(vec3 p, float t) {\n\tvec3 p1 = vec3(p.x, min(-1.5 + t, p.y), 2.5);\n\tvec3 p2 = vec3(p.x, 2.5, max(6.5 - t, p.z));\n\treturn max(1.0 - min(length(p - p1), length(p - p2)), 0.0);\n}\n\nfloat sideZ(vec3 p, float t) {\n\tvec3 p1 = vec3(min(-2.5 + t, p.x), 2.5, p.z);\n\tvec3 p2 = vec3(2.5, max(7.5 - t, p.y), p.z);\n\tvec3 p3 = vec3(max(max(9.5 - t, 1.5), p.x), 0.5, p.z);\n\treturn max(1.0 - min(min(length(p - p1), length(p - p2)), length(p - p3)), 0.0);\n}\n\nvec3 translucentColor(vec3 p, float t) {\n\tvec3 color = vec3(0.766, 0.733, 0.813) * 0.5;\n\treturn ( maxcomp(p \/ 3.0) + maxcomp((3.0 - p) \/ 3.0) ) * color * sqrt(pulse1(t - 9.6666) + pulse2(0.75 * (t - 32.5)));\t\n}\n\nvec4 tileColor(vec3 p, float t) {\n\tp.y = -p.y;\n\tif (maxcomp(p) > 3.0) return vec4(0.0);\n\tvec3 uvw = mod(p, 1.0);\n\tvec3 color = vec3(0.566, 0.533, 0.813);\n\tfloat tileBorder = 0.45;\n\tbool inTile = maxcomp(abs(uvw.xy - 0.5)) < tileBorder;\n\tinTile = inTile || maxcomp(abs(uvw.xz - 0.5)) < tileBorder;\n\tinTile = inTile || maxcomp(abs(uvw.yz - 0.5)) < tileBorder;\n\t\n\tvec3 tilePos = floor(p) + 0.5;\n\tvec3 side = vec3(lessThan(p, vec3(0.0000001)));\n\tvec3 sidePattern = vec3(sideX(tilePos, t - 4.0), sideY(tilePos, t), sideZ(tilePos, t - 9.0)) * float(inTile);\n\n\tfloat tileAlpha = sum(side * sidePattern);\n\ttileAlpha = min(tileAlpha, 1.0);\n\t\n\tvec3 tileColor = mix(translucentColor(p, t + 11.0), color, tileAlpha);\n\t\n\treturn vec4(tileColor, 1.0);\n\t\n}\n\nfloat diffuseLit(vec3 p, vec3 n) {\n\tfloat result = 0.0;\n\tn = normalize(n);\n\t\n\tvec3 light1 = vec3(0.0, 9.0, 3.0);\n\tvec3 light1Dir = light1 - p;\n\tfloat light1Dist = length(light1Dir);\n\tresult += max(dot(n, normalize(light1Dir)), 0.0);\n\t\n\tvec3 light2 = vec3(0.0, 1.5, -14.0);\n\tvec3 light2Dir = light2 - p;\n\tfloat light2Dist = length(light2Dir);\n\tresult += max(dot(n, normalize(light2Dir)), 0.0);\n\t\n\tvec3 light3 = vec3(-9.0, -1.5, 2.0);\n\tvec3 light3Dir = light3 - p;\n\tfloat light3Dist = length(light3Dir);\n\tresult += max(dot(n, normalize(light3Dir)), 0.0);\n\t\n\treturn result;\n\t\t\n}\n\nvec4 finalLogoColor(vec3 p, vec3 n) {\n\tn = pow(abs(n), vec3(9001.0));\n\tp.y = -p.y;\n\tvec3 color = vec3(0.0);\n\tcolor.y = 1.0 - pow(length(p.xz - vec2(2.7, 2.3)), 1.3) \/ 3.5;\t\n\tcolor.x = pow(length((p.yz - vec2(3.7, -1.0)) * vec2(1.0, 1.1)), 1.3) \/ 6.0;\n\tcolor.z = pow(length(p.xy - vec2(2.7, 2.3)), 1.3) \/ 4.0;\n\tfloat mixVal = clamp(sum(color * n), 0.0, 1.0);\n\tvec4 res = mix(vec4(0.98, 0.98, 0.99, 1.0), vec4(0.74, 0.71, 0.95, 1.0), mixVal);\n\tres.xyz *= sum(n * vec3(0.85, 1.0, 0.6));\n\treturn res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = mod(iGlobalTime - 1.0, 10.0) * 5.0 + 5.0;\n\tif (iGlobalTime == 10.0 && length(iResolution.xy) < 350.0) time = 40.0;\n\t\n\tvec2 screenPos = (fragCoord.xy \/ iResolution.xy) * 2.0 - 1.0;\n\tscreenPos.x *= iResolution.x \/ iResolution.y;\n\tscreenPos += vec2(0.3, -0.3);\n\tscreenPos = rotate2d(screenPos, 0.25 * pulse1(time - 9.6666));\n\tscreenPos -= vec2(0.3, -0.3);\n\tscreenPos.y -= 0.7;\n\tvec3 cameraPos = normalize(vec3(-1.0, 1.0 + 2.0 * pulse2(0.75 * (time - 32.5)), -1.0)) * 90.0;\n\tvec3 cameraDir = normalize(vec3(3.0, 0.0, 3.0) - cameraPos);\n\t\n\tvec3 cameraPlaneU = vec3(0.0);\n\tcameraPlaneU.xz = cross(vec3(0.0, 1.0, 0.0), vec3(cameraDir.x, 0.0, cameraDir.z)).xz;\n\tcameraPlaneU = normalize(cameraPlaneU);\n\tvec3 cameraPlaneV = normalize(cross(cameraDir, cameraPlaneU));\n\tcameraDir *= 30.0;\n\t\n\tvec3 rayDir = normalize(cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV);\n\tvec3 rayPos = cameraPos;\n\t\n\tfloat dist = scene(rayPos, time);\n\tint stepsTaken;\n\t\n\tvec3 planeDist;\n\tplaneDist.x = cameraPos.x * length(rayDir \/ rayDir.x);\n\tplaneDist.y = cameraPos.y * length(rayDir \/ rayDir.y);\n\tplaneDist.z = cameraPos.z * length(rayDir \/ rayDir.z);\n\tfloat planeIntersectDist = -mincomp(abs(planeDist));\n\t\n\tfor (int i = 0; i < MAX_RAY_STEPS; i++) {\n\t\trayPos += rayDir * dist;\n\t\tdist = scene(rayPos, time);\n\t}\n\tfloat material = getMaterial(rayPos, time);\n\tvec2 dd = vec2(0.0, 1.0) * 0.00001;\n\tvec3 normal = normalize(vec3(scene(rayPos + dd.yxx, time) - scene(rayPos - dd.yxx, time),\n\t\t\t\t\t\t\t     scene(rayPos + dd.xyx, time) - scene(rayPos - dd.xyx, time),\n\t\t\t\t\t\t\t     scene(rayPos + dd.xxy, time) - scene(rayPos - dd.xxy, time)));\n\t\n\tvec4 color;\n\tif (material == 0.0) color = tileColor(rayPos, time - 11.0);\n\telse color = vec4(0.566, 0.533, 0.863, 1.0) * diffuseLit(rayPos, normal);\n\tcolor = clamp(color, 0.0, 1.0);\n\t\n\trayPos = cameraPos;\n\t\n\tdist = finalLogoScene(rayPos, time);\n\tfor (int i = 0; i < MAX_RAY_STEPS; i++) {\n\t\tif (dist < 0.001) continue;\n\t\trayPos += rayDir * dist;\n\t\tdist = finalLogoScene(rayPos, time);\n\t}\n\tnormal = normalize(vec3(finalLogoScene(rayPos + dd.yxx, time) - finalLogoScene(rayPos - dd.yxx, time),\n\t\t\t\t\t\t\t     finalLogoScene(rayPos + dd.xyx, time) - finalLogoScene(rayPos - dd.xyx, time),\n\t\t\t\t\t\t\t     finalLogoScene(rayPos + dd.xxy, time) - finalLogoScene(rayPos - dd.xxy, time)));\n\tfloat mixAmount = smoothstep(32.0, 40.0, time);\n\tif (dist < 0.05)\n\t\tcolor = mix(color, clamp(vec4(vec3(finalLogoColor(rayPos, normal)), 1.0), 0.0, 1.0), mixAmount);\n\telse\n\t\tcolor = mix(color, vec4(0.0), mixAmount);\n\tcolor = mix(color, vec4(0.0), smoothstep(45.0, 50.0, time));\n\tcolor = pow(color, vec4(2.2));\n\n\tfragColor = color;\n}","name":"","description":"","type":"image"}]}}