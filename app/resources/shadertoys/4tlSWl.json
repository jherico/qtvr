{"Shader":{"ver":"0.1","info":{"id":"4tlSWl","date":"1440598001","viewed":3296,"name":"Steel Lattice","username":"Shane","description":"The lattice structure in this example is really simple to construct, and represents just one of infinitely many combinations.","likes":76,"published":3,"flags":0,"tags":["fire","steel","lattice"],"hasliked":0},"renderpass":[{"inputs":[{"id":3,"src":"\/presets\/tex02.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":7,"src":"\/presets\/tex06.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/*\n    Steel Lattice\n    -------------\n    \n    Shadertoy user FabriceNeyret2's \"Crowded Pillars 3\" inspired me to dig up some old\n    \"lattice with holes\" code. Here's the link to his particular example: \n    https:\/\/www.shadertoy.com\/view\/4lfSDn\n    \n    The lattice structure in this example is really simple to construct, and represents \n    just one of infinitely many combinations. I was going for that oldschool, 3D-tube \n\tscreensaver look and had originally hoped to set the thing ablaze.\n\n\tUnfortunately, I couldn't achieve even mild realism whilst maintaining a decent \n\tframerate, so have copped out and settled for a very subtle reflective firey afterglow. \n\tI haven't given up on the original idea, though.\n    \n\tThere's a whole bunch of notes in there. Probably too many, but hopefully, someone\n\twill find some of it useful. I spent far too long reading up on blackbody radiation, \n\tthen barely used it. Typical. :)\n\n\tIf anyone spots any errors, feel free to let me know.\n\n*\/\n\n#define FIRE_REFLECTION \/\/ Comment this out, to get rid of the reflective afterglow.\n\n#define sEPS 0.005 \/\/ Minimum surface distance threshold.\n#define FAR 20. \/\/ Maximum ray distance threshold.\n\n\/\/ Grey scale.\nfloat getGrey(vec3 p){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\n\n\n\/\/ Smooth minimum function. There are countless articles, but IQ explains it best here:\n\/\/ http:\/\/iquilezles.org\/www\/articles\/smin\/smin.htm\nfloat sminP( float a, float b, float smoothing ){\n\n    float h = clamp( 0.5+0.5*(b-a)\/smoothing, 0.0, 1.0 );\n    return mix( b, a, h ) - smoothing*h*(1.0-h);\n}\n\n\n\/\/ 2D rotation. Always handy.\nmat2 rot(float th){ float cs = cos(th), si = sin(th); return mat2(cs, -si, si, cs); }\n\n\n\/\/ Tri-Planar blending function. Based on an old Nvidia writeup:\n\/\/ GPU Gems 3 - Ryan Geiss: http:\/\/http.developer.nvidia.com\/GPUGems3\/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    \/\/n = abs(n)\/1.732051;\n    n = max((abs(n) - 0.2)*7., 0.001); \/\/ n = max(abs(n), 0.001), etc.\n    n \/= (n.x + n.y + n.z );  \n    \n\treturn (texture2D(tex, p.yz)*n.x + texture2D(tex, p.zx)*n.y + texture2D(tex, p.xy)*n.z).xyz;\n}\n\n\n\/\/ I just wanted a simple function to produce some firey blackbody colors with a simple explanation \n\/\/ to go with it, but computer nerds who write academic papers never make it easy. :) Anyway, to save \n\/\/ someone else the trouble, here's some quick, but messy, notes.\n\/\/\n\/\/ The paper located here was pretty helpful. Mind numbingly boring, but helpful:\n\/\/ http:\/\/www.spectralcalc.com\/blackbody\/CalculatingBlackbodyRadianceV2.pdf\n\/\/ So was this:\n\/\/ http:\/\/www.scratchapixel.com\/old\/lessons\/3d-advanced-lessons\/blackbody\/spectrum-of-blackbodies\/\n\/\/\n\/\/ If wasting time reading though countless webpages full of physics and mathematics that never get to \n\/\/ the point isn't your thing, then this Shadertoy example should be far more accommodating:\n\/\/ User - Bejit: https:\/\/www.shadertoy.com\/view\/MslSDl\nvec3 blackbodyPalette(float t){\n\n    \/\/ t = tLow + (tHigh - tLow)*t;\n    t *= 4000.; \/\/ Temperature range. Hardcoded from 0K to 4000K, in this case. \n    \n    \/\/ Planckian locus or black body locus approximated in CIE color space... Color theory is not my thing,\n    \/\/ but I think below is a conversion of the physical temperture (t) above (which has no meaning to a \n    \/\/ computer) to chromacity coordinates. \n    float cx = (0.860117757 + 1.54118254e-4*t + 1.28641212e-7*t*t)\/(1.0 + 8.42420235e-4*t + 7.08145163e-7*t*t);\n    float cy = (0.317398726 + 4.22806245e-5*t + 4.20481691e-8*t*t)\/(1.0 - 2.89741816e-5*t + 1.61456053e-7*t*t);\n    \n    \/\/ Converting the chromacity coordinates to XYZ tristimulus color space.\n    float d = (2.*cx - 8.*cy + 4.);\n    vec3 XYZ = vec3(3.*cx\/d, 2.*cy\/d, 1. - (3.*cx + 2.*cy)\/d);\n    \n    \/\/ Converting XYZ color space to RGB. Note: Below are the transpose of the matrices you'll find all over the \n    \/\/ web, because I'm placing XYZ after the conversion matrix, and not before it. If you're getting the wrong\n    \/\/ colors, that's probably the reason. I found that out the hard way. :) \n    \/\/ http:\/\/www.cs.rit.edu\/~ncs\/color\/t_spectr.html\n    vec3 RGB = mat3(3.240479, -0.969256, 0.055648, \n                    -1.537150, 1.875992, -0.204043, \n                    -0.498535, 0.041556, 1.057311) * vec3(1.\/XYZ.y*XYZ.x, 1., 1.\/XYZ.y*XYZ.z);\n                    \n    \/\/ Alternative conversion matrix: http:\/\/www.brucelindbloom.com\/index.html?Eqn_RGB_XYZ_Matrix.html\n    \/\/ mat3(3.2404542, -0.9692660, 0.0556434, -1.5371385, 1.8760108, -0.2040259, -0.4985314, 0.0415560, 1.0572252);\n\n    \/\/ Apply Stefan\u2013Boltzmann's law to the RGB color, and we're done. \n    \/\/ \n    \/\/ Appendix A: Algorithms for Computing In-band Radiance.\n    \/\/ http:\/\/www.spectralcalc.com\/blackbody\/CalculatingBlackbodyRadianceV2.pdf\n    \/\/ Planck*Light\/Boltzman = 0.01438767312;\n    \/\/ Planck*Light*Light*2. = 1.1910428e-16;\n    \/\/\n    \/\/ Whoever went through the trouble to use the real algorithm to come up with the estimate of 0.0004, \"Thank you!\" :)\n    \/\/ The last term relates to the power radiating through the surface... or something to that effect.\n    \/\/ Some RGB values fall a little below zero, so I've had to rectify that.\n    return max(RGB, 0.)*pow(t*0.0004, 4.); \n}\n\n\/\/ Surface bump function. Cheap, but with decent visual impact.\nfloat bumpSurf3D( in vec3 p, in vec3 n ){\n    \n    \/\/ Placing raised box-like bumps all over the structure.\n    p = abs(mod(p, 0.0625)-0.03125);\n    float x = min(p.x,min(p.y,p.z))\/0.03125;\n    \/\/ More even alternative, but not the look I was after.\n    \/\/float x = (0.03125-max(p.x,max(p.y,p.z)))\/0.03125*1.25;\n    \n    \/\/ More intricate detail.\n    \/\/x = sin(x*1.57+sin(x*1.57)*1.57)*0.5 + 0.5; \n\n    \/\/ Very, very lame, but cheap, smooth noise for a bit of roughness. The frequency is \n    \/\/ high and the amplitude is very low, so the details won't be discernible enough to \n    \/\/ necessitate a real noise algorithm.\n    p = sin(p*380.+sin(p.yzx*192.+64.));\n    float surfaceNoise = (p.x*p.y*p.z);\n\n    return clamp(x + surfaceNoise*0.05, 0., 1.);\/\/x*32. + \/\/To accentuate x*2.\/0.03125, etc\n\n}\n\n\/\/ Standard function-based bump mapping function.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const float eps = 0.001;\n    float ref = bumpSurf3D(p, nor);                 \n    vec3 grad = vec3( bumpSurf3D(vec3(p.x-eps, p.y, p.z), nor)-ref,\n                      bumpSurf3D(vec3(p.x, p.y-eps, p.z), nor)-ref,\n                      bumpSurf3D(vec3(p.x, p.y, p.z-eps), nor)-ref )\/eps;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + bumpfactor*grad );\n\t\n}\n\n\/\/ Shadertoy user FabriceNeyret2's \"Crowded Pillars 3\" inspired me to dig up some old\n\/\/ \"lattice with holes\" code. Here's the link: https:\/\/www.shadertoy.com\/view\/4lfSDn\n\/\/\n\/\/ The technique used here is pretty common: Produce two, or more, repeat field objects, \n\/\/ lattices - or whatever you'd like - at different repeat frequencies, then combine them \n\/\/ with either a standard operation (min(x1, x2), max(x1, -x2), etc) or something less \n\/\/ standard, like the one I've used below (sqrt(x1*x1+x2*x2)-.05). The possibilities are\n\/\/ endless. Menger cubes, and the like, are constructed using a similar method.\n\/\/\n\/\/ For anyone who wants to experiment, use one line from each of the three sections.\n\/\/ There are 24 different combinations all up, and I've probably chosen the least\n\/\/ interesting one. :)\nfloat map(vec3 p){\n \n    \/\/ SECTION 1\n    \/\/\n    \/\/ Repeat field entity one, which is just some tubes repeated in all directions every \n    \/\/ two units, then combined with a smooth minimum function. Otherwise known as a lattice.\n    p = mod(p, 2.)-1.;\n    float x1 = sminP(length(p.xy),sminP(length(p.yz),length(p.xz), 0.25), 0.25)-0.5; \/\/ EQN 1\n    \/\/float x1 = sqrt(min(dot(p.xy, p.xy),min(dot(p.yz, p.yz),dot(p.xz, p.xz))))-0.5; \/\/ EQN 2\n    \/\/p = abs(p); float x1 = min(max(p.x, p.y),min(max(p.y, p.z),max(p.x, p.z)))-0.5; \/\/ EQN 3\n\n    \/\/ SECTION 2\n    \/\/\n    \/\/ Repeat field entity two, which is just an abstract object repeated every half unit. \n    p = abs(mod(p, 0.5)-0.25);\n    float x2 = min(p.x,min(p.y,p.z)); \/\/ EQN 1\n    \/\/float x2 = min(max(p.x, p.y),min(max(p.y, p.z),max(p.x, p.z)))-0.125; \/\/-0.175, etc. \/\/ EQN 2\n    \n    \/\/ SECTION 3\n    \/\/\n    \/\/ Combining the two entities above.\n    return sqrt(x1*x1+x2*x2)-.05; \/\/ EQN 1\n    \/\/return max(x1, x2)-.05; \/\/ EQN 2\n    \n}\n\n\/\/ Standard ray marching function: I included some basic optimization notes. I know\n\/\/ most of it is probably obvious to many, but I thought some might find it useful.\nfloat raymarch(vec3 ro, vec3 rd) {\n\t\n\t\/\/ Surface distance and total ray distance.\n\tfloat d, t = 0.0;\n    \n    \/\/ More iterations means a chance to gain more accuracy, but should be the lowest\n    \/\/ possible number that will render as many scene details as possible.\n    for (int i = 0; i < 128; i++){\n        \/\/ Surface distance.\n        d = map(ro + rd *t);\n        \n        \/\/ If the distance is less than the surface distance threshold (sEPS), or \n        \/\/ further than the maximum ray distance threshold (FAR), exit.\n        \/\/\n        \/\/ An early exit can mean the difference between, say, 20 map calls and the \n        \/\/ maximum iteration count (128, in this case). In general, you want the \n        \/\/ largest sEPS and smallest FAR value that will facilitate an accurate scene. \n        \/\/ Tweaking these two figures is an artform. sEPS values ranging from 0.001 \n        \/\/ to 0.05 tend to work. However, smaller numbers can kill framerate, in some \n        \/\/ cases. I tend to favor 0.005 and 0.01. For the FAR value, it depends on \n        \/\/ the scene.\n        if (d<sEPS || t>FAR) break;  \n        \n        \/\/ Add a portion of the surface distance (d) to the total ray distance (t).\n        \/\/\n        \/\/ Sometimes, the ray can overshoot, so decreasing the jump distance \"d\" can \n        \/\/ help give more accuracy. Of course, the downside is more iterations,\n        \/\/ which in turn, reduces framerate. Tweaking these numbers is also an artform.\n        \/\/ Anywhere between 0.5 (if accuracy is really necessary) and 1.0 works for\n        \/\/ me. 0.75 is a good compromise.\n        t += d*0.75;\n    }\n    \n    \/\/ Adding the final infinitessimal surface distance to the ray distance. Not sure \n    \/\/ if it's necessary, or correct, but I do it anyway. :)\n    if (d<sEPS) t += d;\n    \n    return t;\n}\n\n\/\/ Based on original by IQ.\nfloat calculateAO(vec3 p, vec3 n){\n\n    const float AO_SAMPLES = 5.0;\n    float r = 0.0, w = 1.0, d;\n    \n    for (float i=1.0; i<AO_SAMPLES+1.1; i++){\n        d = i\/AO_SAMPLES;\n        r += w*(d - map(p + n*d));\n        w *= 0.5;\n    }\n    \n    return 1.0-clamp(r,0.0,1.0);\n}\n\n\/\/ The iterations should be higher for proper accuracy, but in this case, the shadows are a subtle background feature.\nfloat softShadow(vec3 ro, vec3 rd, float start, float end, float k){\n\n    float shade = 1.0;\n    const int maxIterationsShad = 16; \/\/ 24 or 32 would be better.\n\n    \/\/ The \"start\" value, or minimum, should be set to something more than the stop-threshold, so as to avoid a collision with \n    \/\/ the surface the ray is setting out from. It doesn't matter how many times I write shadow code, I always seem to forget this.\n    \/\/ If adding shadows seems to make everything look dark, that tends to be the problem.\n    float dist = start;\n    float stepDist = end\/float(maxIterationsShad);\n\n    \/\/ Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    \/\/ number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n        \/\/ End, or maximum, should be set to the distance from the light to surface point. If you go beyond that\n        \/\/ you may hit a surface not between the surface and the light.\n        float h = map(ro + rd*dist);\n        shade = min(shade, k*h\/dist);\n        \n        \/\/ What h combination you add to the distance depends on speed, accuracy, etc. To be honest, I find it impossible to find \n        \/\/ the perfect balance. Faster GPUs give you more options, because more shadow iterations always produce better results.\n        \/\/ Anyway, here's some posibilities. Which one you use, depends on the situation:\n        \/\/ +=max(h, 0.001), +=clamp( h, 0.01, 0.25 ), +=min( h, 0.1 ), +=stepDist, +=min(h, stepDist*2.), etc.\n        \n        \n        \/\/ I'm always torn between local shadowing (clamp(h, 0.0005, 0.2), etc) and accounting for shaowing from\n        \/\/ distant objects all the way to the light source. If in doubt, local shadowing is probably best, but\n        \/\/ here, I'm trying to do the latter.\n        dist += clamp(h, 0.0005, stepDist*2.); \/\/ The best of both worlds... I think. \n        \n        \/\/ There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if (h<0.001 || dist > end) break; \n    }\n\n    \/\/ I usually add a bit to the final shade value, which lightens the shadow slightly. It's a preference thing. Really dark\n    \/\/ shadows look too brutal to me.\n    return min(max(shade, 0.) + 0.4, 1.0); \n}\n\n\/\/ Standard normal function.\nvec3 getNormal(in vec3 p) {\n\tconst float eps = 0.001;\n\treturn normalize(vec3(\n\t\tmap(vec3(p.x+eps,p.y,p.z))-map(vec3(p.x-eps,p.y,p.z)),\n\t\tmap(vec3(p.x,p.y+eps,p.z))-map(vec3(p.x,p.y-eps,p.z)),\n\t\tmap(vec3(p.x,p.y,p.z+eps))-map(vec3(p.x,p.y,p.z-eps))\n\t));\n\n}\n\n\/\/ Curvature function, which Shadertoy user Nimitz wrote. I've hard-coded this one to\n\/\/ get just the range I want. Not very scientific at all.\n\/\/\n\/\/ From an intuitive sense, the function returns a weighted difference between a surface \n\/\/ value and some surrounding values. Almost common sense... almost. :) If anyone \n\/\/ could provide links to some useful articles on the function, I'd be greatful.\n\/\/\n\/\/ Original usage (I think?) - Cheap curvature: https:\/\/www.shadertoy.com\/view\/Xts3WM\n\/\/ Other usage: Xyptonjtroz: https:\/\/www.shadertoy.com\/view\/4ts3z2\nfloat curve(in vec3 p){\n\n    vec2 e = vec2(-1., 1.)*0.05; \/\/0.05->7. - 0.04->11. - 0.03->20.->0.1->2.\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return 7. * (t1 + t2 + t3 + t4 - 4.*map(p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \/\/ Screen coordinates.\n\tvec2 uv = (fragCoord.xy - iResolution.xy*0.5) \/ iResolution.y;\n    \n    \/\/ No camera setup. Just lazily heading straight to the unit direction vector.\n    vec3 rd = normalize(vec3(uv, 0.5));\n    \/\/vec3 rd = normalize(vec3(uv, sqrt(1.-dot(uv, uv))*0.5)); \/\/ Mild fish lens, if you'd prefer.\n    \n    \/\/ Rotating the unit direction vector about the XY and XZ places for a bit of a look around.\n    rd.xy *= rot(iGlobalTime*0.5);\n    rd.xz *= rot(iGlobalTime*0.25); \/\/ Extra variance.\n    \n    \/\/ Ray origin. Set off linearly in the Z-direction. A bit of a lattice cliche, but effective.\n    vec3 ro = vec3(0.0, 0.0, iGlobalTime*1.0);\n    \/\/vec3 ro = vec3(0.5 + iGlobalTime*0.7, 0.0, iGlobalTime*0.7); \/\/ Another lattice traversal cliche.\n    \n    \/\/ Light position. Rotated a bit, then placed a little above the viewing position.\n    vec3 lp = vec3(0.0, 0.125, -0.125);\n    lp.xy *= rot(iGlobalTime*0.5);\n    lp.xz *= rot(iGlobalTime*0.25);\n    lp += ro + vec3(0.0, 1.0, 0.0);\n    \n    \/\/ Initiate the scene color to black.\n    vec3 sceneCol = vec3(0.);\n    \n    \/\/ Distance to the surface in the scene.\n    float dist = raymarch(ro, rd);\n    \n    \/\/ If the surface has been hit, light it up.\n    if (dist < FAR){\n\n        \/\/ Surface point.\n        vec3 sp = ro + rd*dist;\n        \n        \/\/ Surface normal.\n        vec3 sn = getNormal(sp);\n        \n    \t\n\t    \/\/ Standard function-based bump map - as opposed to texture bump mapping. It's possible to \n\t    \/\/ taper the bumpiness (last term) with distance, using something like: 0.0125\/(1.+dist*0.125).\n\t    sn = doBumpMap(sp, sn, 0.01);\n    \t\n    \t\n\t    \/\/ Light direction vector.\n\t    vec3 ld = lp-sp;\n\n        \/\/ Object color at the surface point.\n\t    vec3 objCol = tex3D( iChannel0, sp, sn );\n\t    \/\/ Using the bump function to shade the surface a bit more to enhance the bump mapping a little.\n\t    \/\/ Not mandatory, but I prefer it sometimes.\n\t    objCol *= bumpSurf3D(sp, sn)*0.5+0.5;\n    \t\n\n\t    float lDist = max(length(ld), 0.001); \/\/ Distance from the light to the surface point.\n\t    ld \/= lDist; \/\/ Normalizing the light-to-surface, aka light-direction, vector.\n\t    float atten = min( 1.0 \/( lDist*0.5 + lDist*lDist*0.1 ), 1.0 ); \/\/ Light falloff, or attenuation.\n    \t\n\t    float ambient = .25; \/\/The object's ambient property. You can also have a global and light ambient property.\n\t    float diffuse = max( 0.0, dot(sn, ld) ); \/\/The object's diffuse value.\n\t    float specular = max( 0.0, dot( reflect(-ld, sn), -rd) ); \/\/ Specular component.\n\t    specular = pow(specular, 8.0); \/\/ Ramping up the specular value to the specular power for a bit of shininess.\n\t    \n\t    \/\/ Soft shadows. I really cheaped out on the iterations, so the shadows are not accurate. Thankfully, \n\t    \/\/ they're not a dominant feature, and everything's moving enough so that it's not really noticeable.\n\t    float shadow = softShadow(sp, ld, sEPS*2., lDist, 32.);\n\t    \/\/ Ambient occlusion.\n        float ao = calculateAO(sp, sn)*0.5+0.5;\n    \t    \n\t    \/\/ Fresnel term. Good for giving a surface a bit of a reflective glow.\n        \/\/float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 1.);\n        \n\n        #ifdef FIRE_REFLECTION\n        \/\/ The firey reflection: Not very sophisticated. Use the relected vector to index into a\n        \/\/ moving noisey texture, etc, to obtain a reflective shade value (refShade). Combine it\n        \/\/ with the surface curvature (crv - higher curvature, more reflective heat... probably), \n        \/\/ then feed the result into a blackbody palette function to obtain the reflective color. \n        \/\/ It's mostly made up, with a tiny bit of science thrown in, so is not meant to be taken \n        \/\/ seriously.\n        \n        \/\/ Surface reflection vector.\n        vec3 sf = reflect(rd, sn);\n        \n        \/\/ Curvature. This function belongs to Shadertoy user Nimitz.\n\t    float crv = clamp(curve(sp), 0., 1.);\n        \n        float refShade = getGrey(tex3D( iChannel1, sp\/4. + iGlobalTime\/64., sf ));\n        refShade = refShade*0.4 + max(dot(sf, vec3(0.166)), .0);\n        vec3 refCol = blackbodyPalette(refShade*(crv*0.5+0.5));\n        #endif\n\n    \t\/\/ Combining the terms from above in a pretty standard way to produce the final color.\n\t    sceneCol = objCol*(vec3(1.,0.97,0.92)*diffuse + ambient)  + vec3(1.,0.9,0.92)*specular*0.75;\n\t    #ifdef FIRE_REFLECTION\n\t    \/\/ Add the subtle relected firey afterglow.\n\t    sceneCol += refCol; \/\/*(diffuse + ambient + specular*0.75);\n\t    #endif\n\t    \n\t    \/\/ Shading the color.\n\t    sceneCol *= atten*ao*shadow;\n\t\n\t}\n\n  \t\/\/ Done!\n\tfragColor = vec4(clamp(sceneCol, 0., 1.), 1.0);\n}","name":"","description":"","type":"image"}]}}