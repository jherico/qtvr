{"Shader":{"ver":"0.1","info":{"id":"ldGGRD","date":"1453423889","viewed":195,"name":"Whippy Rope","username":"eiffie","description":"A strange beaded rope. Haha IQ beat me to it with better cloth! (and better code) This should be more stable now.","likes":15,"published":3,"flags":32,"tags":["verlet","rope"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/Whippy Rope by eiffie\n\/\/I uploaded this before realizing IQ made a nice cloth demo so that is a better\n\/\/example if you want to learn verlet.\n\/\/This has some fun features - to interact with the scene yet draw fast the\n\/\/rendering uses tracing and the physics uses distance estimates.\n\/\/I added some really bad but cheap AA that just takes 1 extra sample where\n\/\/the sub-pixel is most different in color. (or it tries to)\n\nvec4 load(in vec2 re) {\n\treturn texture2D(iChannel0, (0.25+floor(re))\/iResolution.xy );\n}\n\n#define PI 3.14159\n#define MAX_DEPTH 1000.0\n\nstruct Hit{float t,id; vec3 n;}; \/\/distance, object id, normal\n\nvoid Plane( in vec3 ro, in vec3 rd, in vec3 p, in vec3 n, in float id, inout Hit H)\n{\/\/intersect a plane\n\tp=ro-p;\n\tfloat t = -dot( n, p ) \/ dot( n, rd );\n\tif(t > 0.0 && t < H.t ){H.t=t;H.n=n;H.id=id;}\n}\n\nvoid Sphere( in vec3 ro, in vec3 rd, in vec3 p, in float r, in float id, inout Hit H)\n{\/\/intersect a sphere - based on iq's\n\tp=ro-p;\n\tfloat b=dot(p,rd);\n\tfloat h=b*b-dot(p,p)+r*r;\n\tif(h>0.0){\n\t\tfloat t=-b-sqrt(h);\n\t\tif(t>0.0 && t<H.t){\n\t\t\tH.t=t;\n\t\t\tH.id=id;\n\t\t\tH.n=normalize(p+rd*t);\/\/mx*;\n\t\t}\n\t}\n}\n\nvoid Quadric(vec3 ro, vec3 rd, vec3 p, vec3 abc, float r, vec2 yCap, float id, inout Hit H)\n{\/\/intersect any quadric Ax^2 + By^2 + Cz^2 - r = 0  (this is only complicated because of the cap)\n \/\/ex: ellipse: abc=vec3(1.0,0.5,1.0), cyl: abc=vec3(1.0,0.0,1.0), cone: abc=vec3(1.0,-1.0,1.0)\n\tp=ro-p ;\/\/mx*(ro-p);rd=mx*rd;\/\/for rotations\n\tvec2 pln=vec2(0.0);\n\tvec3 N;\n\tfloat Y_Plane=1.0,t1=MAX_DEPTH,t2=-MAX_DEPTH;\n\tif(yCap!=vec2(0.0)){ \n\t\tpln=vec2(p.y-yCap)\/-rd.y;\n\t\tif(pln.x>pln.y){pln.xy=pln.yx;Y_Plane=-Y_Plane;}\n\t}\n\tif(pln.y>=0.0){\n\t\tfloat A=dot(abc*rd,rd),B=2.0*dot(abc*p,rd),C=dot(abc*p,p)-abs(r)*r,inner=B*B-4.0*A*C;\n\t\tif(inner<0.0){\/\/throw out if not inside (if inside your looking thru the middle of a cylinder etc.)\n\t\t\tif(C<0.0){t1=-MAX_DEPTH;t2=MAX_DEPTH;}\n\t\t}else{\n\t\t\tinner=sqrt(inner);\n\t\t\tvec2 t=vec2(-B-inner,-B+inner)\/(2.0*A);\n\t\t\tif(t.x>t.y){if(t.y>0.0 && t.y>pln.x){t.x=-MAX_DEPTH;}t.y=MAX_DEPTH;}\n\t\t\tt1=t.x;t2=t.y;N=abc*(p+rd*t.x);\n\t\t}\n\t\tif(yCap!=vec2(0.0)){\n\t\t\tif(pln.x>t2 || pln.y<t1){t1=MAX_DEPTH;}\/\/no hit\n\t\t\telse if(pln.x>t1){t1=pln.x;N=vec3(0.0,Y_Plane,0.0);}\n\t\t}\n\t\tif(t1>0.0 && t1<H.t){\n\t\t\tH.t=t1;H.id=id;H.n=normalize(N);\/\/*mx;\n\t\t}\n\t}\n}\n\nvec4 GN(int i){\/\/plane definitions for geod\n    vec4 n=vec4(0.0,1.0,0.0,0.5);\n    if(i==11)n.y=-n.y;\n    else if(i>0){\n        float j=mod(float(i)-1.0,5.0);\n        float a=2.0*PI\/5.0*j;\n        float y=0.6;\n        if(i>5){a+=PI\/5.0;y=-y;}\n\t\tn=vec4(cos(a),y,sin(a),0.6);\n    }\n    return n;\n}\nvoid Geod( in vec3 ro, in vec3 rd, in vec3 p, in float id, inout Hit H)\n{\/\/a convex shape made by intersecting planes\n \/\/find the farthest facing plane nearer then the closest back-facing plane\n\tp=ro-p;\n\tfloat t1=-MAX_DEPTH,t2=MAX_DEPTH;\n\tvec3 N1;\n\tfor(int i=0;i<12;i++){\n\t\tvec4 n=GN(i); \/\/mx*N[i].xyz;\n\t\tfloat frontface=dot( n.xyz, -rd );\n\t\tfloat t = (dot( n.xyz, p ) - n.w) \/ frontface;\n\t\tif(frontface>0.0){\n\t\t\tif(t>t1){N1=n.xyz;t1=t;}\n\t\t}else{\n\t\t\tif(t<t2){t2=t;}\n\t\t}\n\t}\n\tif(t1>0.0 && t1<=t2 && t1<H.t){\n\t\tH.t=t1;H.id=id;H.n=N1;\/\/*mx;\n\t}\n}\n\n\/\/matrix math - rotate vector with m*v, inverse with v*m\n#define MAT_ID mat3(1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0)\nmat3  rotAA(vec3 v, float angle){\/\/axis angle rotation\n\tfloat c=cos(angle);vec3 s=v*sin(angle);\n\treturn mat3(v.xxx*v,v.yyy*v,v.zzz*v)*(1.0-c)+mat3(c,-s.z,s.y,s.z,c,-s.x,-s.y,s.x,c);\n}\nmat3 lookat(vec3 fw){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0.0,1.0,0.0)));return mat3(rt,cross(rt,fw),fw);\n}\n\nvoid Intersect(in vec3 ro, in vec3 rd, inout Hit H){\n\tH.t=MAX_DEPTH;\n\tPlane(ro,rd,vec3(0.0,-1.0,0.0),vec3(0.0,1.0,0.0),0.0,H);\n\tSphere(ro,rd,vec3(0.0),1.0,1.0,H);\n\tQuadric(ro,rd,vec3(2.0,0.0,0.0),vec3(1.0,0.1,1.0),0.5,vec2(0.5,-1.0),2.0,H);\n\tQuadric(ro,rd,vec3(-2.0,0.0,0.0),vec3(1.0,-0.3,1.0),0.1,vec2(0.3,-1.0),3.0,H);\n\tGeod(ro,rd,vec3(1.0,-0.5,2.0),4.0,H);\n\tfor(int i=0;i<16;i++){\/\/beads\n\t\tvec3 p1=load(vec2(i,0.0)).xyz;\n\t\tSphere(ro,rd,p1,0.1,5.0,H);\n\t}\n}\nvoid DoScene(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 ms=(iMouse.x>0.0)?iMouse.xy\/iResolution.xy:vec2(0.5);ms*=vec2(PI*2.0,PI*0.5);\n\tvec3 ro=vec3(cos(ms.x)*cos(ms.y),sin(ms.y),sin(ms.x)*cos(ms.y))*3.0;\n\tvec3 rd=lookat(-ro)*normalize(vec3((2.0*fragCoord-iResolution.xy)\/iResolution.y,1.0));\n\tHit H;\n\tIntersect(ro,rd,H);\n\tvec3 col=vec3(0.0),L=normalize(vec3(0.3,1.0,0.5));\n\tif(H.t<MAX_DEPTH){\n\t\tif(H.id==0.0){\n\t\t\tvec2 p=abs(fract((ro.xz+rd.xz*H.t)*0.25)-vec2(0.5))-0.25;\n\t\t\tcol=mix(vec3(0.25),vec3(0.75),smoothstep(0.0,H.t*H.t*0.0001,sign(p.x*p.y)*min(abs(p.x),abs(p.y))));\n\t\t}else{\n\t\t\tcol=abs(cos(vec3(H.id,H.id+0.3,H.id+0.8)));\n\t\t}\n\t\tcol*=max(0.1,dot(H.n,L));\n\t\tcol+=vec3(1.0,0.9,0.7)*pow(max(0.0,dot(reflect(rd,H.n),L)),4.0);\n\t\tfloat h=1.1+dot(H.n,rd)*0.2;\n\t\tcol*=vec3(h,1.0,1.0\/h);\n\t\tcol*=exp(-H.t*0.1);\n\t\th=-H.n.y;\n\t\tIntersect(ro+rd*(H.t-0.001),L,H);\n\t\tif(H.t<MAX_DEPTH)col=min(col,vec3(0.1));\n\t\tcol+=vec3(0.1,0.15,0.2)*max(0.0,h);\n\t\t\n\t}\n\tfragColor=vec4(col,1.0);\n}\n\nfloat dot2(vec3 v){return dot(v,v);}\n\n\/\/1+1(rarely) AA\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\t\/\/if(fragCoord.x<10.0){fragColor=vec4(1.0,0.0,0.0,1.0);return;}\n\tvec3 c00=texture2D(iChannel1,(fragCoord.xy+vec2(0.0,0.0))\/iResolution.xy).rgb;\n\tvec3 c10=texture2D(iChannel1,(fragCoord.xy+vec2(1.0,0.0))\/iResolution.xy).rgb;\n\tvec3 c01=texture2D(iChannel1,(fragCoord.xy+vec2(0.0,1.0))\/iResolution.xy).rgb;\n\tvec3 c11=texture2D(iChannel1,(fragCoord.xy+vec2(1.0,1.0))\/iResolution.xy).rgb;\n\t\n\tvec2 v=vec2(dot2(c00-c10),dot2(c00-c10))+vec2(dot2(c00-c11)*0.5);\n\tfloat mx=max(v.x,v.y);\/\/clamp(length(v),0.0,1.0);\n\tif(mx>0.1){\/\/is there enough difference to care?\n\t\t\/\/fragColor=vec4(0.0,1.0,mx*0.5,1.0);return;\n\t\tvec2 coord=fragCoord.xy+v\/mx*0.5; \/\/find the new point to sample\n\t\tDoScene(fragColor,coord);\n\t\tfragColor=mix(vec4(c00,1.0),fragColor,0.4+clamp(0.15*length(v),0.0,0.35));\n\t}else fragColor=vec4(c00,1.0);\n}\n","name":"","description":"","type":"image"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"vec4 load(in vec2 re) {\n\treturn texture2D(iChannel0, (0.25+floor(re))\/iResolution.xy );\n}\n\n#define PI 3.14159\n#define MAX_DEPTH 1000.0\n\nvec4 GN(int i){\/\/plane definitions for geod\n    vec4 n=vec4(0.0,1.0,0.0,0.5);\n    if(i==11)n.y=-n.y;\n    else if(i>0){\n        float j=mod(float(i)-1.0,5.0);\n        float a=2.0*PI\/5.0*j;\n        float y=0.6;\n        if(i>5){a+=PI\/5.0;y=-y;}\n\t\tn=vec4(cos(a),y,sin(a),0.6);\n    }\n    return n;\n}\n\nfloat DEGeod(vec3 p){\n\tfloat d=-2000.0;\n\tfor(int i=0;i<12;i++){\n        vec4 n=GN(i);\n\t\td=max(d,dot(p,n.xyz)-n.w);\n\t}\n\treturn d;\n}\n\/\/A*x^2+B*y^2+C*z^2-D=0\nfloat Quadric(in vec3 p,in vec4 r){return (dot(p*r.xyz,p)-abs(r.w)*r.w)\/length(2.0*r.xyz*p);}\n\nfloat DE(in vec3 p){\n\tfloat flr=p.y+1.0;\/\/plane\n\tfloat sph=length(p)-1.0;\n\tfloat cyl=max(Quadric(p-vec3(2.0,0.0,0.0),vec4(1.0,0.1,1.0,0.5)),abs(p.y+0.25)-0.75);\n\tfloat cone=max(Quadric(p-vec3(-2.0,0.0,0.0),vec4(1.0,-0.3,1.0,0.1)),abs(p.y+0.3)-0.65);\n\tfloat geod=DEGeod(p-vec3(1.0,-0.5,2.0));\n\tfloat d=min(flr,min(sph,min(cyl,cone)));\n\td=min(d,geod);\n\treturn d;\n}\n\n\/\/the verlet routines\n#define AIR_RESISTANCE 0.05\n#define SURFACE_HARDNESS 0.999\n#define STRUCTURAL_RIGIDITY 1.0\n#define GRAVITY 0.2\n#define SLACK 0.01\n#define RADIUS 0.1\n#define REST_LENGTH 0.2\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tif(fragCoord.y>2.0 || fragCoord.x>16.0)discard;\n\tif(fragCoord.x<1.0){fragColor=vec4(3.0*sin(iGlobalTime*0.4),2.0-fragCoord.x*REST_LENGTH-min(0.5,iGlobalTime*0.1),2.0*sin(iGlobalTime*0.3),iGlobalTime);return;}\n\tvec3 cp1,cp2,cp3,pp2;\n\tbool bNotLast=(fragCoord.x<15.0);\n\tfloat dt=iTimeDelta;\n\tif(iFrame<10){\n\t\tcp1=vec3(0.0,2.0,(fragCoord.x-1.0)*REST_LENGTH);\n\t\tcp2=vec3(0.0,2.0,fragCoord.x*REST_LENGTH);\n\t\tcp3=vec3(0.0,2.0,(fragCoord.x+1.0)*REST_LENGTH);\n\t\tpp2=cp2;\n\t}else{\n\t\t\/\/if(iFrame>50)dt=iGlobalTime-load(vec2(0.0)).w;\n\t\tcp1=load(vec2(fragCoord.x-1.0,0.0)).xyz;\n\t\tcp2=load(vec2(fragCoord.x,0.0)).xyz;\n\t\tpp2=load(vec2(fragCoord.x,1.0)).xyz;\n\t\tif(bNotLast)cp3=load(vec2(fragCoord.x+1.0,0.0)).xyz;\n\t}\n\n\t\/\/global forces\n\tfloat visc=1.0-AIR_RESISTANCE*dt;\n\tpp2.y+=GRAVITY*dt;\/\/add gravity to previous pos\n\tvec3 tmp=cp2;\n\tcp2+=(cp2-pp2)*visc;\n\tpp2=tmp;\n\n\t\/\/stick constraints\n\tvec3 delta=cp1-cp2;\n\tfloat deltaLength=length(delta)-REST_LENGTH;\n    if(abs(deltaLength)>SLACK){\n\t\tfloat scl=STRUCTURAL_RIGIDITY*deltaLength\/2.0;\/\/(m1.im+m2.im);\n\t\tcp2+=delta*scl;\n    }\n    if(bNotLast){\/\/yikes I forgot to do this direction!\n\t\tdelta=cp3-cp2;\n\t\tdeltaLength=length(delta)-REST_LENGTH;\n\t\tif(abs(deltaLength)>SLACK){\n\t\t\tfloat scl=STRUCTURAL_RIGIDITY*deltaLength*0.333;\n\t\t\tcp2+=delta*scl;\n\t\t}\n\t}\n    \n\t\/\/DE constraint\t\n\tfloat d=DE(cp2);\n\tif(d<RADIUS){\n\t\tvec3 v=vec3(RADIUS,0.0,-RADIUS);\n\t\tvec3 n=normalize(vec3(DE(cp2+v.xyy)-DE(cp2-v.xyy),DE(cp2+v.yxy)-DE(cp2-v.yxy),DE(cp2+v.yyx)-DE(cp2-v.yyx)));\n\t\tvec3 vel=cp2-pp2;\/\/the velocity\n\t\tif(dot(n,vel)<0.0)vel=reflect(vel,n)*SURFACE_HARDNESS;\/\/if moving toward surface bounce\nif(iFrame>5){\n\t\tcp2+=n*(RADIUS-d);\n\t\tpp2=cp2-vel*visc;\n}\n\t}\n\tif(fragCoord.y<1.0)fragColor.xyz=cp2;else fragColor.xyz=pp2;\n}\n\n","name":"","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"vec4 load(in vec2 re) {\n\treturn texture2D(iChannel0, (0.25+floor(re))\/iResolution.xy );\n}\n\n#define PI 3.14159\n#define MAX_DEPTH 1000.0\n\nstruct Hit{float t,id; vec3 n;}; \/\/distance, object id, normal\n\nvoid Plane( in vec3 ro, in vec3 rd, in vec3 p, in vec3 n, in float id, inout Hit H)\n{\/\/intersect a plane\n\tp=ro-p;\n\tfloat t = -dot( n, p ) \/ dot( n, rd );\n\tif(t > 0.0 && t < H.t ){H.t=t;H.n=n;H.id=id;}\n}\n\nvoid Sphere( in vec3 ro, in vec3 rd, in vec3 p, in float r, in float id, inout Hit H)\n{\/\/intersect a sphere - based on iq's\n\tp=ro-p;\n\tfloat b=dot(p,rd);\n\tfloat h=b*b-dot(p,p)+r*r;\n\tif(h>0.0){\n\t\tfloat t=-b-sqrt(h);\n\t\tif(t>0.0 && t<H.t){\n\t\t\tH.t=t;\n\t\t\tH.id=id;\n\t\t\tH.n=normalize(p+rd*t);\/\/mx*;\n\t\t}\n\t}\n}\n\nvoid Quadric(vec3 ro, vec3 rd, vec3 p, vec3 abc, float r, vec2 yCap, float id, inout Hit H)\n{\/\/intersect any quadric Ax^2 + By^2 + Cz^2 - r = 0  (this is only complicated because of the cap)\n \/\/ex: ellipse: abc=vec3(1.0,0.5,1.0), cyl: abc=vec3(1.0,0.0,1.0), cone: abc=vec3(1.0,-1.0,1.0)\n\tp=ro-p ;\/\/mx*(ro-p);rd=mx*rd;\/\/for rotations\n\tvec2 pln=vec2(0.0);\n\tvec3 N;\n\tfloat Y_Plane=1.0,t1=MAX_DEPTH,t2=-MAX_DEPTH;\n\tif(yCap!=vec2(0.0)){ \n\t\tpln=vec2(p.y-yCap)\/-rd.y;\n\t\tif(pln.x>pln.y){pln.xy=pln.yx;Y_Plane=-Y_Plane;}\n\t}\n\tif(pln.y>=0.0){\n\t\tfloat A=dot(abc*rd,rd),B=2.0*dot(abc*p,rd),C=dot(abc*p,p)-abs(r)*r,inner=B*B-4.0*A*C;\n\t\tif(inner<0.0){\/\/throw out if not inside (if inside your looking thru the middle of a cylinder etc.)\n\t\t\tif(C<0.0){t1=-MAX_DEPTH;t2=MAX_DEPTH;}\n\t\t}else{\n\t\t\tinner=sqrt(inner);\n\t\t\tvec2 t=vec2(-B-inner,-B+inner)\/(2.0*A);\n\t\t\tif(t.x>t.y){if(t.y>0.0 && t.y>pln.x){t.x=-MAX_DEPTH;}t.y=MAX_DEPTH;}\n\t\t\tt1=t.x;t2=t.y;N=abc*(p+rd*t.x);\n\t\t}\n\t\tif(yCap!=vec2(0.0)){\n\t\t\tif(pln.x>t2 || pln.y<t1){t1=MAX_DEPTH;}\/\/no hit\n\t\t\telse if(pln.x>t1){t1=pln.x;N=vec3(0.0,Y_Plane,0.0);}\n\t\t}\n\t\tif(t1>0.0 && t1<H.t){\n\t\t\tH.t=t1;H.id=id;H.n=normalize(N);\/\/*mx;\n\t\t}\n\t}\n}\n\nvec4 GN(int i){\/\/plane definitions for geod\n    vec4 n=vec4(0.0,1.0,0.0,0.5);\n    if(i==11)n.y=-n.y;\n    else if(i>0){\n        float j=mod(float(i)-1.0,5.0);\n        float a=2.0*PI\/5.0*j;\n        float y=0.6;\n        if(i>5){a+=PI\/5.0;y=-y;}\n\t\tn=vec4(cos(a),y,sin(a),0.6);\n    }\n    return n;\n}\nvoid Geod( in vec3 ro, in vec3 rd, in vec3 p, in float id, inout Hit H)\n{\/\/a convex shape made by intersecting planes\n \/\/find the farthest facing plane nearer then the closest back-facing plane\n\tp=ro-p;\n\tfloat t1=-MAX_DEPTH,t2=MAX_DEPTH;\n\tvec3 N1;\n\tfor(int i=0;i<12;i++){\n\t\tvec4 n=GN(i); \/\/mx*N[i].xyz;\n\t\tfloat frontface=dot( n.xyz, -rd );\n\t\tfloat t = (dot( n.xyz, p ) - n.w) \/ frontface;\n\t\tif(frontface>0.0){\n\t\t\tif(t>t1){N1=n.xyz;t1=t;}\n\t\t}else{\n\t\t\tif(t<t2){t2=t;}\n\t\t}\n\t}\n\tif(t1>0.0 && t1<=t2 && t1<H.t){\n\t\tH.t=t1;H.id=id;H.n=N1;\/\/*mx;\n\t}\n}\n\n\/\/matrix math - rotate vector with m*v, inverse with v*m\n#define MAT_ID mat3(1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0)\nmat3  rotAA(vec3 v, float angle){\/\/axis angle rotation\n\tfloat c=cos(angle);vec3 s=v*sin(angle);\n\treturn mat3(v.xxx*v,v.yyy*v,v.zzz*v)*(1.0-c)+mat3(c,-s.z,s.y,s.z,c,-s.x,-s.y,s.x,c);\n}\nmat3 lookat(vec3 fw){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0.0,1.0,0.0)));return mat3(rt,cross(rt,fw),fw);\n}\n\nvoid Intersect(in vec3 ro, in vec3 rd, inout Hit H){\n\tH.t=MAX_DEPTH;\n\tPlane(ro,rd,vec3(0.0,-1.0,0.0),vec3(0.0,1.0,0.0),0.0,H);\n\tSphere(ro,rd,vec3(0.0),1.0,1.0,H);\n\tQuadric(ro,rd,vec3(2.0,0.0,0.0),vec3(1.0,0.1,1.0),0.5,vec2(0.5,-1.0),2.0,H);\n\tQuadric(ro,rd,vec3(-2.0,0.0,0.0),vec3(1.0,-0.3,1.0),0.1,vec2(0.3,-1.0),3.0,H);\n\tGeod(ro,rd,vec3(1.0,-0.5,2.0),4.0,H);\n\tfor(int i=0;i<16;i++){\/\/beads\n\t\tvec3 p1=load(vec2(i,0.0)).xyz;\n\t\tSphere(ro,rd,p1,0.1,5.0,H);\n\t}\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 ms=(iMouse.x>0.0)?iMouse.xy\/iResolution.xy:vec2(0.5);ms*=vec2(PI*2.0,PI*0.5);\n\tvec3 ro=vec3(cos(ms.x)*cos(ms.y),sin(ms.y),sin(ms.x)*cos(ms.y))*3.0;\n\tvec3 rd=lookat(-ro)*normalize(vec3((2.0*fragCoord-iResolution.xy)\/iResolution.y,1.0));\n\tHit H;\n\tIntersect(ro,rd,H);\n\tvec3 col=vec3(0.0),L=normalize(vec3(0.3,1.0,0.5));\n\tif(H.t<MAX_DEPTH){\n\t\tif(H.id==0.0){\n\t\t\tvec2 p=abs(fract((ro.xz+rd.xz*H.t)*0.25)-vec2(0.5))-0.25;\n\t\t\tcol=mix(vec3(0.25),vec3(0.75),smoothstep(0.0,H.t*H.t*0.0001,sign(p.x*p.y)*min(abs(p.x),abs(p.y))));\n\t\t}else{\n\t\t\tcol=abs(cos(vec3(H.id,H.id+0.3,H.id+0.8)));\n\t\t}\n\t\tcol*=max(0.1,dot(H.n,L));\n\t\tcol+=vec3(1.0,0.9,0.7)*pow(max(0.0,dot(reflect(rd,H.n),L)),4.0);\n\t\tfloat h=1.1+dot(H.n,rd)*0.2;\n\t\tcol*=vec3(h,1.0,1.0\/h);\n\t\tcol*=exp(-H.t*0.1);\n\t\th=-H.n.y;\n\t\tIntersect(ro+rd*(H.t-0.001),L,H);\n\t\tif(H.t<MAX_DEPTH)col=min(col,vec3(0.1));\n\t\tcol+=vec3(0.1,0.15,0.2)*max(0.0,h);\n\t\t\n\t}\n\tfragColor=vec4(col,1.0);\n}\n","name":"","description":"","type":"buffer"}]}}