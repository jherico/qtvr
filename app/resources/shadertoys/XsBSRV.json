{"Shader":{"ver":"0.1","info":{"id":"XsBSRV","date":"1413586923","viewed":3169,"name":"On\/Off Spikes","username":"movAX13h","description":"My first rm shader with shadow pass. No AA. Mouse enabled.<br\/>Thank you srtuss for support. Thank you morgan3d for the nebula function.","likes":34,"published":3,"flags":0,"tags":["shadows","raymarcher"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ On\/Off Spikes, fragment shader by movAX13h, oct 2014\n\n#define HARD_SHADOW\n#define GLOW\n#define EDGES\n#define NUM_TENTACLES 6\n#define BUMPS\n#define NUM_BUMPS 8\n#define BACKGROUND\n#define SUN_POS vec3(15.0, 15.0, -15.0)\n\/\/#define SUN_SPHERE\n\n#define SPHERE_COL vec3(0.6, 0.3, 0.1)\n#define MOUTH_COL vec3(0.9, 0.6, 0.1)\n#define TENTACLE_COL vec3(0.06)\n\n#define GAMMA 2.2\n\n\/\/---\n#define resolution iResolution\n#define mouse iMouse\n#define pi2 6.283185307179586476925286766559\n#define pih 1.5707963267949\n\n\/\/ Using the nebula function of the \"Star map shader\" by morgan3d \n\/\/ as environment map and light sphere texture (https:\/\/www.shadertoy.com\/view\/4sBXzG)\nconst float pi= 3.1415927;const int NUM_OCTAVES = 4;float hash(float n) { return fract(sin(n) * 1e4); } float hash(vec2 p){return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 +p.x))));}float noise(float x) { float i = floor(x);float f = fract(x); float u = f * f * (3.0 - 2.0 * f);return mix(hash(i),hash(i+1.0),u);}float noise(vec2 x){vec2 i=floor(x);vec2 f=fract(x);\tfloat a = hash(i); float b=hash(i + vec2(1.0,0.0));float c=hash(i+vec2(0.0, 1.0)); float d = hash(i + vec2(1.0, 1.0)); vec2 u = f * f * (3.0 - 2.0 * f); return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y; }float NOISE(vec2 x){ float v = 0.0; float a = 0.5; vec2 shift=vec2(100);mat2 rot=mat2(cos(0.5),sin(0.5), -sin(0.5), cos(0.50)); for (int i = 0; i < NUM_OCTAVES;++i) {v+=a*noise(x);x = rot* x * 2.0 + shift; a *= 0.5; } return v; }float square(float x) { return x * x;}mat3 rotation(float yaw, float pitch){return mat3(cos(yaw),0,-sin(yaw), 0, 1, 0, sin(yaw), 0, cos(yaw)) * mat3(1, 0, 0, 0, cos(pitch), sin(pitch), 0, -sin(pitch), cos(pitch)); }vec3 nebula(vec3 dir) { float purple = abs(dir.x); float yellow = noise(dir.y);vec3 streakyHue = vec3(purple + yellow, yellow * 0.7, purple);vec3 puffyHue = vec3(0.8, 0.1, 1.0);float streaky = min(1.0, 8.0 * pow(NOISE(dir.yz*square(dir.x) * 13.0+ dir.xy * square(dir.z) * 7.0 + vec2(150.0, 2.0)),10.0));float puffy=square(NOISE(dir.xz * 4.0 + vec2(30, 10)) * dir.y);\nreturn pow(clamp(puffyHue * puffy * (1.0 - streaky) + streaky * streakyHue, 0.0, 1.0), vec3(1.0\/2.2));}\n\/\/ ---\n\nfloat sdBox( vec3 p, vec3 b ) \n{\t\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n\treturn length(p)-r;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 rotate(vec2 p, float a)\n{\n\tvec2 r;\n\tr.x = p.x*cos(a) - p.y*sin(a);\n\tr.y = p.x*sin(a) + p.y*cos(a);\n\treturn r;\n}\n\n\/\/ polynomial smooth min (k = 0.1); by iq\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5+0.5*(b-a)\/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n\/\/ globals\nfloat time = iGlobalTime;\nfloat glow = max(0.0, min(1.0, 2.0*sin(time*0.7-5.0)));\nfloat bite = smoothstep(0.0, 1.0, 1.6*sin(time*0.7));\nvec3 sphere_col = SPHERE_COL*glow;\nvec3 sun = normalize(SUN_POS);\nfloat focus = 5.0;\nfloat far = 23.0;\n\nstruct Hit\n{\n\tfloat d;\n\tvec3 color;\n\tfloat edge;\n};\n\nHit scene(vec3 p)\n{\n\tfloat d, d1, d2, d3, f, e = 0.15;\n\t\n\tvec3 q = p;\n\tq.xy = rotate(q.xy, 1.5);\n\t\n\t\/\/ center sphere\n\td1 = sdSphere(q, 0.3);\n\td = d1; \n    vec3 col = sphere_col; \n    \n\t\/\/ tentacles\n\tfloat r = length(q);\n\tfloat a = atan(q.z, q.x);\n\ta += 0.4*sin(r-time);\n\t\n\tq = vec3(a*float(NUM_TENTACLES)\/pi2,q.y,length(q.xz)); \/\/ circular domain\n\tq = vec3(mod(q.x,1.0)-0.5*1.0,q.y,q.z); \/\/ repetition\n\t\n\td3 = sdCappedCylinder(q-vec3(0.0,0.0,0.9+bite), vec2(0.1-(r-bite)\/18.0,0.8));\n\td2 = min(d3, sdBox(q-vec3(0.0, 0.0, 0.1+bite), vec3(0.2, 0.2, 0.2))); \/\/ close box\n\td2 = smin(d2, sdBox(q-vec3(0.0, 0.0, 0.4+bite), vec3(0.2, 0.05, 0.4)), 0.1); \/\/ wide box\n\t\n    f = smoothstep(0.11, 0.28, d2-d1);\n\tcol = mix(MOUTH_COL, col, f);\n\te = mix(e, 0.0, f);\n\td = smin(d1, d2, 0.24);\n    \n\tcol = mix(TENTACLE_COL, col, smoothstep(0., 0.48, d3-d));\n\t\n    #ifdef SUN_SPHERE\n\td = min(d, sdSphere(p-sun, 0.1));\n    #endif\n    \n\t#ifdef BUMPS\n\tfor(int i = 0; i < NUM_BUMPS; i++)\n\t{\n        d2 = float(i);\n        d1 = sdSphere(p-0.18*smoothstep(0.1, 1.0, glow)*\n                      vec3(sin(4.0*time+d2*0.6), sin(5.3*time+d2*1.4), cos(5.8*time+d2*0.6)),\n                      0.03);\n\t\t\n\t\td = smin(d1, d, 0.2);\n\t\t\/\/d = min(d1, d);\n\t}\n\t#endif\n\t\n\t#ifdef BACKGROUND\n\tq = p;\n\tq.yz = mod(q.yz, 1.0);\n\tq -= vec3(-.6, 0.5, 0.5);\n\td1 = sdBox(q, vec3(0.1, 0.48, 0.48));\n\tif (d1 < d) { d = d1; col = vec3(0.1); }\n\t#endif\n\t\n\treturn Hit(d, col, e);\n}\n\nvec3 normal(vec3 p)\n{\n\tfloat c = scene(p).d;\n\tvec2 h = vec2(0.01, 0.0);\n\treturn normalize(vec3(scene(p + h.xyy).d - c, \n\t\t\t\t\t\t  scene(p + h.yxy).d - c, \n\t\t                  scene(p + h.yyx).d - c));\n}\n\nfloat edges(vec3 p) \/\/ by srtuss\n{\n\tfloat acc = 0.0;\n\tfloat h = 0.01;\n\tacc += scene(p + vec3(-h, -h, -h)).d;\n\tacc += scene(p + vec3(-h, -h, +h)).d;\n\tacc += scene(p + vec3(-h, +h, -h)).d;\n\tacc += scene(p + vec3(-h, +h, +h)).d;\n\tacc += scene(p + vec3(+h, -h, -h)).d;\n\tacc += scene(p + vec3(+h, -h, +h)).d;\n\tacc += scene(p + vec3(+h, +h, -h)).d;\n\tacc += scene(p + vec3(+h, +h, +h)).d;\n\treturn acc \/ h;\n}\n\nvec3 colorize(Hit hit, vec3 n, vec3 dir, const in vec3 lightPos)\n{\n\tfloat diffuse = 0.3*max(0.0, dot(n, lightPos));\n\t\n\tvec3 ref = normalize(reflect(dir, n));\n\tfloat specular = 0.4*pow(max(0.0, dot(ref, lightPos)), 6.5);\n\n\treturn (hit.color.rgb + \n\t\t\tdiffuse * vec3(0.9) +\n\t\t\tspecular * vec3(1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec2 pos = (fragCoord.xy*2.0 - resolution.xy) \/ resolution.y;\n\t\n\tfloat d = clamp(1.5*sin(0.3*time), 0.5, 1.0);\n\tvec3 cp = vec3(10.0*d, -2.3*d, -6.2*d+4.0*clamp(2.0*sin(time*0.5), 0.0, 1.0)); \/\/ anim curious spectator\n\t\n\tif (mouse.x > 10.0)\n\t{\n\t\tvec2 mrel = mouse.xy\/resolution.xy-0.5;\n\t\tfloat mdis = (8.0+6.0*mrel.y);\n\t\tcp = vec3(mdis*cos(-mrel.x*pih), 4.0*mrel.y, mdis*sin(-mrel.x*pih));\n\t}\n\t\n    vec3 ct = vec3(0.0, 0.0, 0.0);\n   \tvec3 cd = normalize(ct-cp);\n    vec3 cu  = vec3(0.0, 1.0, 0.0);\n    vec3 cs = cross(cd, cu);\n    vec3 dir = normalize(cs*pos.x + cu*pos.y + cd*focus);\t\n\t\n    Hit h;\n\tvec3 col = vec3(0.16);\n\tvec3 ray = cp;\n\tfloat dist = 0.0;\n\t\n\t\/\/ raymarch scene\n    for(int i=0; i < 60; i++) \n\t{\n        h = scene(ray);\n\t\t\n\t\tif(h.d < 0.0001) break;\n\t\t\n\t\tdist += h.d;\n\t\tray += dir * h.d * 0.9;\n\n        if(dist > far) \n\t\t{ \n\t\t\tdist = far; \n\t\t\tbreak; \n\t\t}\n    }\n\n\tfloat m = (1.0 - dist\/far);\n\tvec3 n = normal(ray);\n\tcol = colorize(h, n, dir, sun)*m;\n\n    #ifdef EDGES\n\tfloat edge = edges(ray);\n\tcol = mix(col, vec3(0.0), h.edge*edge*smoothstep(0.3, 0.35, length(ray)));\n    #endif\n    \n\tvec3 neb = nebula(n);\n\tcol += min(glow, 0.1)*neb.brg;\n\t\n\t\/\/ HARD SHADOW with low number of rm iterations (from obj to sun)\n\t#ifdef HARD_SHADOW\n\tvec3 ray1 = ray;\n\tdir = normalize(SUN_POS - ray1);\n\tray1 += n*0.002;\n\t\n\tfloat sunDist = length(SUN_POS-ray1);\n\tdist = 0.0;\n\t\n\tfor(int i=0; i < 35; i++) \n\t{\n\t\th = scene(ray1 + dir*dist);\n\t\tdist += h.d;\n\t\tif (abs(h.d) < 0.001) break;\n\t}\n\n\tcol -= 0.24*smoothstep(0.5, -0.3, min(dist, sunDist)\/max(0.0001,sunDist));\n\t#endif\n\t\n\t\/\/ ILLUMINATION & free shadow with low number of rm iterations (from obj to sphere)\n\t#ifdef GLOW\n\tdir = normalize(-ray);\n\tray += n*0.002;\n\t\n\tfloat sphereDist = max(0.0001, length(ray)-0.3);\n\tdist = 0.0;\n\t\n\tfor(int i=0; i < 35; i++) \n\t{\n\t\th = scene(ray + dir*dist);\n\t\tdist += h.d;\n\t\tif (abs(h.d) < 0.001) break;\n\t}\n\t\n\tvec3 neb1 = nebula(dir*rotation(0.0, time*0.4)).brg;\n    \n\tcol += (0.7*sphere_col+glow*neb1)*(0.6*(smoothstep(3.0, 0.0, sphereDist))*min(dist, sphereDist)\/sphereDist + \n\t\t   0.6*smoothstep(0.1, 0.0, sphereDist));\n\t#endif\n    \n\tcol -= 0.2*smoothstep(0.6,3.7,length(pos));\n\tcol = clamp(col, vec3(0.0), vec3(1.0));\n\tcol = pow(col, vec3(2.2, 2.4, 2.5)) * 3.9;\n\tcol = pow(col, vec3(1.0 \/ GAMMA));\n    \n\tfragColor = vec4(col, 1.0);\n}\n","name":"","description":"","type":"image"}]}}