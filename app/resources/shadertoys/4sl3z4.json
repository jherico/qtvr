{"Shader":{"ver":"0.1","info":{"id":"4sl3z4","date":"1364249310","viewed":3772,"name":"Moonlight","username":"reinder","description":"If your using a Mac or Linux please uncomment line 1 to view the full shader with mountains and a floating bottle (screenshot: http:\/\/imgur.com\/KKPZsj4). <br\/><br\/>Part of the code is copy-pasted from shaders by inigo quilez and dave hoskins.","likes":52,"published":3,"flags":0,"tags":["procedural","noise","reflection","raymarch","water","raytrace"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Moonlight. Created by Reinder Nijhoff 2013\n\/\/ @reindernijhoff\n\/\/\n\/\/ https:\/\/www.shadertoy.com\/view\/4sl3z4\n\/\/\n\n#define SHOWALL\n\/\/#define SHOWBOTTLE\n\n#ifdef SHOWALL\n\t#define SHOWBOTTLE\n\t\/\/#define BOTTLESHADOW 0\n\t#define SHOWMOUNTAINS\n\t#define CLOUDDETAiL\n#endif\n\n#define CLOUDSHARPNESS 0.001\n#define WINDSPEED vec2(-43.0, 32.0)\n#define BUMPFACTOR 0.05\n#define BUMPDISTANCE 70.\n#define MAXMOUNTAINDISTANCE 40.\n#define SKYCOLOR vec3(0.1,0.1,0.15)\n#define MOONLIGHTCOLOR vec3(.4,0.4,0.2)\n#define SKYBYMOONLIGHTCOLOR vec3(.4,.2,0.87)\n#define BOTTLECOLOR vec3( 0.7, 1., 0.6 )*0.3\n#define WATERCOLOR vec3( 0.2, 0.2, 0.4 )\n\n#define EXPOSURE 0.9\n#define EPSILON 0.01\n#define MARCHSTEPS 100\n\nfloat time = iGlobalTime + 23.0;\n\nfloat CLOUDCOVER = 0.1*cos( time*0.072+0.2 ) + 0.26;\n\nfloat moont = time * 0.1;\nfloat moonf = -time * 0.1;\nvec3 moondir = normalize( vec3( cos(moont),\n\t\t\t                    0.8*(0.6+0.5*sin(moonf)),\n\t\t\t\t\t\t        sin(moont) ) );\n\n\/\/ math functions\n\nconst mat3 m = mat3( 0.00,  0.90,  0.60,\n                    -0.90,  0.36, -0.48,\n                    -0.60, -0.48,  0.34 );\n\nconst mat2 mr = mat2 (0.84147,  0.54030,\n                      0.54030, -0.84147 );\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D( iChannel0, (uv+ 0.5)\/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn texture2D( iChannel0, (uv+118.4)\/256.0, -100.0 ).x;\n}\n\n\nfloat fbm( vec3 p ) {\n    float f;\n    f  =      0.5000*noise( p ); p = m*p*2.02;\n    f +=      0.2500*noise( p ); p = m*p*2.33;\n    f +=      0.1250*noise( p ); p = m*p*2.01;\n    f +=      0.0625*noise( p ); \n    return f\/(0.9175);\n}\n\nfloat fbm( vec2 p ) {\n    float f;\n    f  =      0.5000*noise( p ); p = mr*p*2.02;\n    f +=      0.2500*noise( p ); p = mr*p*2.33;\n    f +=      0.1250*noise( p ); p = mr*p*2.01;\n    f +=      0.0625*noise( p ); \n    return f\/(0.9175);\n}\n\n\/\/ heightmaps\n\nfloat heightMap( vec3 pos ) {\n\tfloat n = noise( vec2(0.0,4.2)+pos.xz*0.14 );\n\treturn 9.*(n-0.7);\n}\n\nfloat waterHeightMap( vec2 pos ) {\n\tvec2 posm = pos * mr;\n\tposm.x += 0.25*time;\n\tfloat f = fbm( vec3( posm*1.9, time*0.27 ));\n\tfloat height = 0.5+0.1*f;\n\theight += 0.13*sin( posm.x*6.0 + 10.0*f );\n\n#ifdef SHOWBOTTLE\t\n\tfloat d = length(pos-vec2(-3., 0.));\n\theight += 0.1 * cos( d*50.-time*4. ) * (1. - smoothstep( 0., 1.0, d) );\n#endif\n\t\n\treturn  height;\n}\n\n\/\/ intersection functions\n\nbool intersectPlane(vec3 ro, vec3 rd, float height, out float dist) {\t\n\tif (rd.y==0.0) {\n\t\treturn false;\n\t}\n\t\t\n\tfloat d = -(ro.y - height)\/rd.y;\n\td = min(100000.0, d);\n\tif( d > 0. ) {\n\t\tdist = d;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool intersectHeightMap(vec3 ro, vec3 rd, float maxdist, const bool reflection, out float dist ) {\n\tfloat dt = 0.3;\n\tvec3 pos;\n\tdist = 0.0;\n\tbool hit = false;\n\n\tfor( int i=0; i<MARCHSTEPS; i++) {\n\t\tif( hit || dist > maxdist ) break;\n\t\t\n\t\tdist += dt;\n\t\tdt = min( dt*1.1, 0.5 );\n\t\tpos = ro + rd*dist;\n\t\tif( heightMap( pos ) >= pos.y ) {\n\t\t\thit = true;\n\t\t}\n\t}\n\treturn hit;\n}\n\nbool intersectSphere ( in vec3 ro, in vec3 rd, in vec4 sph, out float dist, out vec3 normal ) {\n    vec3  ds = ro - sph.xyz;\n    float bs = dot( rd, ds );\n    float cs = dot(  ds, ds ) - sph.w*sph.w;\n    float ts = bs*bs - cs;\n\t\n    if( ts > 0.0 ) {\n        ts = -bs - sqrt( ts );\n\t\tif( ts>0. ) {\n\t\t\tnormal = normalize( ((ro+ts*rd)-sph.xyz)\/sph.w );\n\t\t\tdist = ts;\n\t\t\treturn true;\n\t\t}\n    }\n\n    return false;\n}\n\nbool intersectCylinder( in vec3 ro, in vec3 rd, in vec3 A, in vec3 B, in float radius, out float dist, out vec3 normal) {\n\tvec3 AB = B - A;\n\tvec3 AO = ro - A;\n \n\tfloat AB_dot_d = dot( AB, rd );\n\tfloat AB_dot_AO = dot( AB, AO );\n\tfloat AB_dot_AB = dot( AB, AB );\n \n\tfloat m = AB_dot_d \/ AB_dot_AB;\n\tfloat n = AB_dot_AO \/ AB_dot_AB;\n \n\tvec3 Q = rd - (AB * m);\n\tvec3 R = AO - (AB * n);\n \n\tfloat a = dot( Q, Q );\n\tfloat b = 2.0 * dot( Q, R );\n\tfloat c = dot( R, R ) - (radius*radius);\n \n\tif(a == 0.0) {\n\t\tfloat adist = 100000., bdist = 100000.;\n\t\tif(\t!intersectSphere( ro, rd, vec4( A, radius ), adist, normal ) ||\n\t\t\t!intersectSphere( ro, rd, vec4( B, radius ), bdist, normal ) ) {\n\t\t\treturn false;\n\t\t}\n \t\tdist = min (adist, bdist);\n\t\tnormal = normalize((ro+rd*dist) - (adist<bdist?A:B) );\n\t\treturn true;\n\t}\n \n\tfloat discriminant = b * b - 4.0 * a * c;\n\tif(discriminant < 0.0) {\n\t\treturn false;\n\t}\n \n\tfloat sqrtdis = sqrt(discriminant);\n\tfloat tmin = (-b - sqrtdis) \/ (2.0 * a);\n\tfloat tmax = (-b + sqrtdis) \/ (2.0 * a);\n\tif( tmin < 0. )\n\t\ttmin = tmax;\n\telse \n\t\ttmin = min(tmin, tmax); \n\t\n\tif( tmin < 0. ) return false;\n\t\n\tfloat t_k1 = tmin * m + n;\n\tfloat dc = 10000000.;\n\t\n\tvec3 nc;\n\t\n\tif(t_k1 < 0.0)\t{\t\t\n\t\tif(intersectSphere( ro, rd, vec4( A, radius ), dist, normal)) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\telse if(t_k1 > 1.0) {\n\t\tif(intersectSphere( ro, rd, vec4( B, radius ), dist, normal)) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\t\/\/ On the cylinder...\n\t\tvec3 p1 = ro + (rd * tmin);\n \t\tvec3 k1 = A + AB * t_k1;\n\t\tdist = tmin;\n\t\tnormal = normalize( p1 - k1 );\n\t\treturn true;\n\t}\n\treturn false;\n}\n\t\nbool intersectBottle ( in vec3 ro,  in vec3 rd, out float dist, out vec3 normal ) {\t\t\n\tfloat d = 1000000.;\n\tbool  hitc;\n\tfloat distc;\n\tvec3  normalc;\t\n\t\n\tfloat rx = sin( iGlobalTime ) * 0.2;\t\n\tvec3 up = vec3( 0., 0.4 * cos(rx), 0.4 * sin(rx) );\n\tvec3 pos = vec3(  -3.0, 0.05*cos(iGlobalTime*0.6)+0.05, 0.);\n\t\n\thitc = intersectCylinder( ro, rd, pos+up*1.5, pos-up*1.5, 0.07, distc, normalc);\n\tif( hitc && distc < d ) {\n\t\td = distc;\n\t\tnormal = normalc;\n\t}\n\thitc = intersectCylinder( ro, rd, pos+up*0.15, pos-up*0.15, 0.22, distc, normalc);\n\tif( hitc && distc < d ) {\n\t\td = distc;\n\t\tnormal = normalc;\n\t}\n\tif( d < 1000000. ) {\n\t\tdist = d;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\/\/ more copy-paste functions...\n\nfloat cloudDensity( vec3 rd ) {\n\tfloat d;\n\tintersectPlane( vec3(0., 0., 0.), rd, 500., d );\n\tvec3 intersection = rd*d;\t\n\t\n\tfloat cloud = 0.5 + 0.5*fbm( vec3( \n\t\t(intersection.xz + WINDSPEED*time)*0.001, time*0.25) ) - (1.-CLOUDCOVER);\n\n#ifdef CLOUDDETAiL\t\n\tcloud += 0.02*noise((intersection.xz - WINDSPEED*time*0.01));\n#endif\n\t\n    if (cloud < 0.) cloud = 0.;\n\t\n\tcloud = 1. - pow(CLOUDSHARPNESS, cloud);\n\t\n\tcloud = mix( CLOUDCOVER, cloud, smoothstep( 0.0, 0.1, dot( rd, vec3(0.,1.,0.) ) ) );\n\t\n\treturn cloud;\n}\n\nvec3 skyColor( vec3 rd ) {\t\n\tfloat moonglow = clamp( 1.0782*dot(moondir,rd), 0.0, 2.0 );\n\tvec3 col = SKYCOLOR * moondir.y;\n\tcol += .4*SKYBYMOONLIGHTCOLOR*moonglow;\n\tcol += 0.43*MOONLIGHTCOLOR*pow( moonglow, 21.0 );\n\n\t\/\/ moon!\n\tfloat dist; vec3 normal; bool moonhit = false;\n\tif( intersectSphere( vec3(0., 0., 0.), rd, vec4( moondir, 0.07), dist, normal ) ) {\n\t\tfloat l = dot( normalize(vec3( -moondir.x, 0.0, -moondir.z)+vec3( 2.2, -1.6, 0.)), normal );\n\t\tcol += 3.0*MOONLIGHTCOLOR*clamp(l, 0.0, 1.);\n\t\tmoonhit = true;\n\t}\n\t\t\n\t\/\/ Do the stars...\n\tif( !moonhit ) {\n\t\tvec3 rds = rd;\n\t\t\n\t\tfloat v = 1.0\/( 2. * ( 1. + rds.z ) );\n\t\tvec2 xy = vec2(rds.y * v, rds.x * v);\n\t\tfloat s = noise(rds.xz*134.);\n\t\ts += noise(rds.xz*370.);\n\t\ts += noise(rds.xz*870.);\n\t\ts = pow(s,19.0) * 0.00000001 * max(rd.y, 0.0 );\n\t\tif (s > 0.1) {\n\t\t\tvec3 backStars = vec3((1.0-sin(xy.x*20.0+time*13.0*rds.x+xy.y*30.0))*.5*s,s, s); \n\t\t\tcol += backStars;\n\t\t}\n\t}\n\t\n\tcol *= (1.0-cloudDensity( rd ) );\n\n\treturn col;\n}\n\n\/\/ trace function\n\nvec3 trace(vec3 ro, vec3 rd, float currentDistance, const bool reflection, out vec3 intersection, out vec3 normal, out float dist, out int material) \n{\n\tmaterial = 0; \/\/ sky\n\tfloat d = 1000000.;\n\tbool  hitc;\n\tfloat distc;\n\tvec3  normalc;\n\n#ifdef SHOWMOUNTAINS\n\thitc = intersectHeightMap( ro, rd, MAXMOUNTAINDISTANCE-currentDistance, reflection, distc );\n\tif( hitc ) {\n\t\tmaterial = 1; \/\/ mountain\n\t\tnormal = -rd; \/\/ ahum\n\t\td = distc;\n\t}\n#endif\n\n\thitc = intersectPlane( ro, rd, 0., distc);\n\tif( hitc && (distc < d) ) {\n\t\tmaterial = 2; \/\/ water\n\t\tnormal = vec3( 0., 1., 0. );\n\t\td = distc;\n\t}\n\t\n#ifdef SHOWBOTTLE\n\thitc = intersectBottle( ro, rd, distc, normalc ); \n\tif( hitc && (distc < d) ) {\n\t\tmaterial = 3; \/\/ bottle\n\t\tnormal = normalc;\n\t\td = distc;\n\t}\n#endif\n\t\n\tif( d < 100000. ) {\n\t\tdist = d;\n\t\tintersection = ro + rd*dist;\n\t}\n\n\tif( !reflection && material == 2 ) {\n\t\tvec2 coord = intersection.xz;\n\t\tvec2 dx = vec2( EPSILON, 0. );\n\t\tvec2 dz = vec2( 0., EPSILON );\n\t\t\n\t\tfloat bumpfactor = BUMPFACTOR * (1. - smoothstep( 0., BUMPDISTANCE, dist) );\n\t\t\n\t\tnormal.x = bumpfactor * (waterHeightMap(coord + dx) - waterHeightMap(coord-dx) ) \/ (2. * EPSILON);\n\t\tnormal.z = bumpfactor * (waterHeightMap(coord + dz) - waterHeightMap(coord-dz) ) \/ (2. * EPSILON);\n\t\tnormal = normalize( normal );\n\t}\n\t\t\n\tvec3 col;\n\tfloat diff = clamp(dot(normal,moondir), 0., 1.);\n\t\n\t\/\/ shadow ?\n#ifdef BOTTLESHADOW\n\tif( intersectBottle( intersection+normal*EPSILON, moondir, distc, normalc ) ) {\n\t\tdiff = 0.;\n\t}\n#endif\n\t\n\tif (material == 2) { \/\/ water\n\t\tcol = WATERCOLOR * MOONLIGHTCOLOR * diff;\n\t} else if( material == 1 ) { \/\/ mountains\n\t\tcol = mix( 0.5 * MOONLIGHTCOLOR * diff, vec3(0.), (currentDistance+dist)\/MAXMOUNTAINDISTANCE);\n\t} else if( material == 3 ) { \/\/ bottle\n\t\tcol = BOTTLECOLOR * diff * smoothstep( 0., 0.2, intersection.y );\n\t} else { \/\/ sky\n\t\tcol = skyColor(rd);\n\t}\n\t\n\tif( material > 0 ) {\n\t\tcol = mix( col, SKYCOLOR*CLOUDCOVER, clamp( dist\/100., 0., 1.) );\t\n\t}\n\t\t\n\treturn col;\n}\n\t\t\n\/\/ main\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 q = fragCoord.xy\/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x\/iResolution.y;\n    vec2 mo = iMouse.xy\/iResolution.xy;\n\t\t \n\tfloat a = moont + 0.3*sin( time*0.12 )+(mo.x>0.?(mo.x-0.5):0.)*3.1415*2.;\n\t\/\/ camera\t\n\tvec3 ce = vec3( 0.0, 0.2, 0.0 );\n\tvec3 ro = ce + vec3( 1.3*cos(0.11*time + 6.0*mo.x), 0.65*(mo.y>0.?mo.y:0.5), 1.3*sin(0.11*time + 6.0*mo.x) );\n\tvec3 ta = ro + vec3( 0.95*cos(a), 0.75*ro.y-0.3+moondir.y*0.2, 0.95*sin(a) );\n\t\n\tfloat roll = -0.15*sin(0.1*time);\n\t\n\t\/\/ camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( sin(roll), cos(roll),0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 1.5*cw );\n\n\t\/\/ raytrace\n\tint material;\n\tvec3 normal, intersection;\n\tfloat dist = 0., dist2 = 0.;\n\t\t\n\tvec3 col = trace(ro, rd, 0.0, false, intersection, normal, dist, material);\n\n\tif( material >= 2 ) {\n\t\t\/\/ reflection\n\t\tvec3 rfld = reflect( rd, normal );\n\t\t\n\t\tfloat reflectstrength = 1.-abs(dot( rd, normal ));\n\t\t\n\t\tcol += 0.9 * reflectstrength * trace(intersection+rfld*EPSILON, rfld, dist, true, intersection, normal, dist2, material);\n\t}\n\n\tcol = pow( col, vec3(EXPOSURE, EXPOSURE, EXPOSURE) );\t\n\tcol = clamp(col, 0.0, 1.0);\n\t\n    \/\/ vigneting\n    col *= 0.25+0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15 );\n\t\n\tfragColor = vec4( col,1.0);\n}","name":"","description":"","type":"image"}]}}