{"Shader":{"ver":"0.1","info":{"id":"4tB3RK","date":"1430153004","viewed":803,"name":"Test: Glass spheres","username":"ruben3d","description":"Figuring out how to write these shaders, my first attempt.","likes":5,"published":3,"flags":0,"tags":["sphere","glass"],"hasliked":0},"renderpass":[{"inputs":[{"id":24,"src":"\/presets\/cube02_0.jpg","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define DIAMETER 128.0\n#define SPECULAR_EXPONENT 128.0\n#define DIFFUSE_INTENSITY 0.25\n#define LIGHT_HEIGHT 256.0\n#define CAMERA_HEIGHT 1024.0\n\n#define HAS_COLOR\n#define HAS_REFLECTION\n#define HAS_REFRACTION\n\n\/\/ Adapted from http:\/\/developer.download.nvidia.com\/SDK\/9.5\/Samples\/DEMOS\/Direct3D9\/src\/HLSL_FresnelReflection\/docs\/FresnelReflection.pdf\nfloat fresnel(vec3 V, vec3 N, float R0)\n{\n    float cosAngle = 1.0-max(dot(V, N), 0.0);\n    float result = cosAngle * cosAngle;\n    result = result * result;\n    result = result * cosAngle;\n    result = clamp(result * (1.0 - R0) + R0, 0.0, 1.0);\n    return result;\n}\n\nvec3 shade(vec3 lightPos, vec3 Kd, vec3 P, vec3 N)\n{\n    vec3 L = normalize(lightPos - P);\n    vec3 R = reflect(-L, N);\n    vec3 V = normalize(vec3(iResolution.x*0.5, iResolution.y*0.5, CAMERA_HEIGHT) - P);\n\n    vec3 I = vec3(0.0);\n\n    vec3 Id = Kd * max(dot(N, L), 0.0);\n    I = I + Id * DIFFUSE_INTENSITY;\n\n    vec3 Is = vec3(pow(max(dot(R,V),0.0), SPECULAR_EXPONENT));\n    I = I + Is;\n\n    float fr = fresnel(V, N, 0.2);\n    \n    #ifdef HAS_REFLECTION\n    \tvec3 Ir = fr * textureCube(iChannel0, reflect(-V, N)).rgb;\n    \tI = I + Ir;\n    #endif\n    \n    #ifdef HAS_REFRACTION\n    \tvec3 It = (1.0-fr) * textureCube(iChannel0, refract(-V, N, 0.8)).rgb;\n    \tI = I + It;\n    #endif\n\n    return I;\n    \/\/return vec3(fr);\n}\n\nvec3 sample(vec2 coord)\n{\n    float t = (sin(iGlobalTime)+1.0)*0.5;\n    float r = DIAMETER * 0.5;\n    \n    \/\/ Center of sphere\n    vec2 rawCenter = vec2(mod(coord.x+  t*iResolution.x*0.5, DIAMETER), mod(coord.y+ t*iResolution.y*0.5, DIAMETER));\n    vec3 C = vec3(coord - rawCenter + r, 0.0);\n\n    \/\/ Is point on sphere?\n    float sqrtTerm = r * r - (coord.x-C.x)*(coord.x-C.x) - (coord.y-C.y)*(coord.y-C.y);\n    if (sqrtTerm >= 0.0)\n    {\n        \/\/ Sphere surface point\n        float h = sqrt(sqrtTerm) + C.z;\n        vec3 P = vec3(coord, h);\n\n        \/\/ Sphere color\n        #ifdef HAS_COLOR\n        \tvec3 Kd = C \/ iResolution;\n        \tKd.z = 1.0-Kd.x;\n       \t#else\n        \tvec3 Kd = vec3(0.0);\n        #endif\n\n        \/\/ Sphere surface normal\n        vec3 N = normalize(P - C);\n\n        \/\/ Shading\n        \/\/vec3 light0 = shade(vec3(iMouse.xy, LIGHT_HEIGHT),\n        \/\/                   Kd, P, N);\n        vec3 light1 = shade(vec3(iResolution.x * t, iResolution.y - iResolution.y * t, LIGHT_HEIGHT),\n                           Kd, P, N);\n\n        return \/*light0 +*\/ light1;\n    }\n    else \/\/ Paint background\n    {\n        return textureCube(iChannel0, normalize(vec3(coord,0.0) - vec3(iResolution.xy*0.5,CAMERA_HEIGHT))).rgb;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ Permform rotated quincunx AA\n    vec3 s0 = sample(fragCoord);\n    vec3 s1 = sample(fragCoord + vec2(-0.4, -0.2));\n    vec3 s2 = sample(fragCoord + vec2(+0.2, -0.4));\n    vec3 s3 = sample(fragCoord + vec2(-0.2, +0.4));\n    vec3 s4 = sample(fragCoord + vec2(+0.4, +0.2));\n    fragColor = vec4((s0+s1+s2+s3+s4)*0.2, 1.0);\n}","name":"","description":"","type":"image"}]}}