{"Shader":{"ver":"0.1","info":{"id":"XsfGD4","date":"1380494400","viewed":12978,"name":"Woods","username":"iq","description":"A wonderful place to explore. The structure is very repetitive and regular, I didn't add any big scale variation cause I didn't expect to move the camera in this one, but focus in this one shot. It runs slow too, I'll try to optimize it later.","likes":98,"published":3,"flags":0,"tags":["procedural","3d","raymarching","distancefield"],"hasliked":0},"renderpass":[{"inputs":[{"id":7,"src":"\/presets\/tex06.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":8,"src":"\/presets\/tex07.jpg","ctype":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":10,"src":"\/presets\/tex09.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define LIGHTRIG 1 \/\/ 0 or 1\n\/\/#define GODRAYS\n\/\/#define HIGH_QUALITY_NOISE \n\n\/\/==============================================================================\n\nfloat hash( vec2 n )\n{\n    return fract(sin(dot(n,vec2(1.0,113.0)))*13.5453123);\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(13.5453123,31.1459123,37.3490423));\n}\n\nvec2 hash2( vec2 x )\n{\n\tfloat n = dot(x,vec2(1.0,113.00));\n    return fract(sin(vec2(n,n+1.0))*vec2(13.5453123,31.1459123));\n}\n\n\n#ifndef HIGH_QUALITY_NOISE \nfloat noise( in vec2 x )\n{\n\t\/\/return texture2D( iChannel0, (x+0.5)\/256.0 ).x;\n\n\tvec2 p = floor(x);\n    vec2 f = fract(x);\n\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\n\treturn texture2D( iChannel0, (uv+0.5)\/256.0, -100.0 ).x;\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D( iChannel0, (uv+0.5)\/256.0, -100.0 ).yx;\n\t\n\treturn mix( rg.x, rg.y, f.z );\n}\n#else\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n\tf =  f*f*(3.0-2.0*f);\n\n\tfloat a = texture2D( iChannel0, (p+vec2(0.5,0.5))\/256.0, -100.0 ).x;\n\tfloat b = texture2D( iChannel0, (p+vec2(1.5,0.5))\/256.0, -100.0 ).x;\n\tfloat c = texture2D( iChannel0, (p+vec2(0.5,1.5))\/256.0, -100.0 ).x;\n\tfloat d = texture2D( iChannel0, (p+vec2(1.5,1.5))\/256.0, -100.0 ).x;\n\n\treturn mix( mix( a, b, f.x ), mix( c, d, f.x ), f.y );\n\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\n\tvec2 rga = texture2D( iChannel0, (uv+vec2(0.5,0.5))\/256.0, -100.0 ).yx;\n\tvec2 rgb = texture2D( iChannel0, (uv+vec2(1.5,0.5))\/256.0, -100.0 ).yx;\n\tvec2 rgc = texture2D( iChannel0, (uv+vec2(0.5,1.5))\/256.0, -100.0 ).yx;\n\tvec2 rgd = texture2D( iChannel0, (uv+vec2(1.5,1.5))\/256.0, -100.0 ).yx;\n\t\n\tvec2 rg = mix( mix( rga, rgb, f.x ),\n\t\t\t\t   mix( rgc, rgd, f.x ), f.y );\n\t\n\treturn mix( rg.x, rg.y, f.z );\n}\n#endif\n\nfloat fbm( in vec3 p )\n{\n    return 0.5000*noise(p*1.0)+\n           0.2500*noise(p*2.0)+\n           0.1250*noise(p*4.0)+\n           0.0625*noise(p*8.0);\n}\n\nfloat fbm( in vec2 p )\n{\n    return 0.5000*noise(p*1.0)+\n           0.2500*noise(p*2.0)+\n           0.1250*noise(p*4.0)+\n           0.0625*noise(p*8.0);\n}\n\nvec3 texturize( sampler2D sa, vec3 p, vec3 n )\n{\n\tvec3 x = texture2D( sa, p.yz ).xyz;\n\tvec3 y = texture2D( sa, p.zx ).xyz;\n\tvec3 z = texture2D( sa, p.xy.yx ).xyz;\n\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\n\/\/==============================================================================\n\nfloat treeBase( vec2 pos )\n{\n\tfloat chsca = 0.2;\n\tvec2 chos = fract(chsca*pos) - 0.5;\n\treturn length( chos );\n}\t\n\nfloat terrain( vec2 pos )\n{\n\tfloat h = 12.0*fbm( pos*0.1 );\n\t\n\tfloat r = treeBase( pos );\n\tr = max(0.0,r-0.1);\n\tfloat ar = 1.0*exp( -50.0*r*r );\n\t\n\treturn h + ar;\n}\n\nvec2 grassDistr( in vec2 pos )\n{\n\tfloat f = fbm( pos );\n    return vec2( smoothstep( 0.45, 0.55, f ), smoothstep(0.4, 0.75, f) );\n}\n\nfloat mushroomAnim( float t )\n{\n    float f = sin( 0.5*t );\t\t\n\t\n\tf = -1.0 + 2.0*smoothstep( 0.45, 0.55, 0.5 + 0.5*f );\n\t\n\treturn 1.0 + 0.1*f;\n}\n\t\nfloat map( in vec3 pos, out vec4 suvw, out float info )\n{\n    float dis;\n\t\n\t\/\/-----------------------------\n\t\/\/ terrain\n\tfloat h = terrain( pos.xz );\n\tfloat mindist = pos.y - h;\n\n\tfloat t = treeBase( pos.xz );\n\tfloat treeOcc = clamp(max(0.0,t-0.15)*3.0,0.0,1.0);\n\tsuvw = vec4( 0.0, 0.0, 0.0, treeOcc );\n\n\t\/\/ grass\n\tvec2 gd = grassDistr(pos.xz);\n\tfloat hi = 1.0*clamp( 2.0*texture2D( iChannel0, pos.xz ).x, 0.0, 1.0 );\n\tfloat g = 0.2*hi * (gd.x * gd.y);\n    mindist -= g;\n\n\n\t\/\/ mushroom position\t\n\tfloat mushSca = 2.0;\n\tvec2  mushWPos = (0.5+floor(mushSca*pos.xz))\/mushSca;\n\tvec3  mushPos = vec3( fract(mushSca*pos.x)-0.5, mushSca*(pos.y-h), fract(mushSca*pos.z)-0.5 );\n    float mushID  = hash( floor(mushSca*pos.xz) );\n\tfloat mushToTree = treeBase(mushWPos);\n\t\n\tfloat sh = 0.2 * (0.5 + 1.0*mushID);\n\t\n\tsuvw.w *= mix( 0.33 + 0.67*clamp( (length( mushPos.xz )-sh)*5.0, 0.0, 1.0 ), 1.0, 1.0*smoothstep( 0.35, 0.45, mushToTree + 0.5*(gd.x * gd.y) ) );\n\tsuvw.w *= mix( smoothstep( 0.5, 1.0, hi ), 1.0, 1.0-gd.x );\n\tsuvw.w *= 0.2 + 0.8*clamp( 2.0*abs(gd.x-0.5), 0.0, 1.0 );\n\t\n\t\/\/-----------------------------\n\t\/\/ trees\n\t{\n\tfloat chsca = 0.2;\n\tvec3 chos = vec3( fract(chsca*pos.x)-0.5, chsca*(pos.y-h), fract(chsca*pos.z)-0.5 );\n\tfloat y = chos.y;\n\tfloat r = length( chos.xz );\n\t\t\n\tfloat ss = exp(-40.0*y*y);\n\tfloat dd = fbm( pos*vec3(1.0,0.1,1.0)*2.0 );\n\tfloat sh = 0.08 + (0.1+0.25*ss)*dd;\n\t\t\n    dis = (r - sh)\/chsca;\n\tif( dis<mindist )\n\t{\n\t\tmindist = dis;\n\t\tsuvw.x = 1.0;\n\t\tsuvw.y = y;\n\t\tsuvw.z = smoothstep( 0.0, 1.0, dd );\n\t\tsuvw.w = smoothstep( 0.0, 1.0, dd*1.4 ) * clamp(0.3+y*1.5, 0.0, 1.0);\n\t\tinfo = atan( chos.x, chos.z );\n\t}\t\t\n\t\t\n\t}\n\t\n\t\/\/-----------------------------\n\t\/\/ mushrooms\n\tif( mushToTree < 0.4)\n\t{\n    float an = mushroomAnim( iGlobalTime*(1.0+mushID) + 6.28*mushID );\t\t\n\n\tfloat y = mushPos.y - 0.2 * 0.5;\n\tfloat r = length( vec3(mushPos.xz,y*2.0) );\n\tfloat sh = 0.2 * (0.5 + 1.0*mushID);\n    sh *= an;\t\t\n    dis = (r - sh)\/mushSca;\n\tif( dis<mindist )\n\t{\n\t\tmindist = dis;\n\t\tsuvw.x = 2.0;\n\t\tsuvw.y = mushID;\n\t\tsuvw.z = mushPos.x \/ an;\n\t\tsuvw.w = clamp( 0.5 + 0.5*y\/.1, 0.0, 1.0 ) * treeOcc;\n\t\tinfo = mushPos.z \/ an;\n\t}\t\t\n\t\t\n\t}\n\n\n\t\n    return mindist * 0.5;\n}\n\n\nfloat map2( in vec3 pos )\n{\n    float dis;\n\t\n\t\/\/-----------------------------\n\t\/\/ terrain\n\tfloat h = terrain( pos.xz );\n\tfloat mindist = pos.y - h;\n\n\t\/\/ grass\n\tvec2 gd = grassDistr(pos.xz);\n\tfloat g = 0.2*(gd.x * gd.y);\n    mindist -= g;\n\n\n\t\/\/ mushroom position\t\n\tfloat rockSca = 2.0;\n\tvec2  rockWPos = (0.5+floor(rockSca*pos.xz))\/rockSca;\n\tvec3  rockPos = vec3( fract(rockSca*pos.x)-0.5, rockSca*(pos.y-h), fract(rockSca*pos.z)-0.5 );\n    float  rockID  = hash( floor(rockSca*pos.xz) );\n\tfloat rockToTree = treeBase(rockWPos);\n\t\n\tfloat sh = 0.2 * (0.5 + 1.0*rockID);\n\t\n\t\n\t\/\/-----------------------------\n\t\/\/ trees\n\t{\n\tfloat chsca = 0.2;\n\tvec3 chos = vec3( fract(chsca*pos.x)-0.5, chsca*(pos.y-h), fract(chsca*pos.z)-0.5 );\n\tfloat y = chos.y;\n\tfloat r = length( chos.xz );\n\t\t\n\tfloat ss = exp(-40.0*y*y);\n\tfloat dd = fbm( pos*vec3(1.0,0.1,1.0)*2.0 );\n\tfloat sh = 0.08 + (0.1+0.25*ss)*dd;\n\t\t\n    dis = (r - sh)\/chsca;\n\tmindist = min( dis, mindist );\n\t\t\n\t}\n\t\n\t\/\/-----------------------------\n\t\/\/ mushrooms\n\tif( rockToTree < 0.4)\n\t{\n\tfloat y = rockPos.y - 0.2 * 0.5;\n\tfloat r = length( vec3(rockPos.xz,y*2.0) );\n\tfloat sh = 0.2 * (0.5 + 1.0*rockID);\n    sh *= mushroomAnim( iGlobalTime*(1.0+rockID) + 6.28*rockID );\n    dis = (r - sh)\/rockSca;\n\tmindist = min( dis, mindist );\n\t\t\n\t}\n\n\n\t\n    return mindist;\n}\n\n\nvec3 calcNormal( in vec3 pos )\n{\n    float eps = 0.01;\n    vec4 kk;\n\tfloat kk2;\n\tfloat ref = map(pos,kk,kk2);\n\tvec3 nor = vec3( map( vec3(pos.x+eps, pos.y, pos.z), kk, kk2 ) - ref,\n                     map( vec3(pos.x, pos.y+eps, pos.z), kk, kk2 ) - ref,\n                     map( vec3(pos.x, pos.y, pos.z+eps), kk, kk2 ) - ref );\n\treturn normalize( nor );\n}\n\nfloat intersect( in vec3 ro, in vec3 rd, out vec4 suvw, out float info )\n{\n    const float maxd = 50.0;\n\tfloat precis = 0.01;\n    float h = 1.0;\n    float t = 0.0;\n    suvw = vec4(0.0);\n\tinfo = 0.0;\n    for( int i=0; i<128; i++ )\n    {\n        if( h<precis||t>maxd ) break;\n\t    h  = map( ro+rd*t, suvw, info );\n        t += h*min(0.25+0.15*t,1.0);\n    }\n\n\tif( t>maxd ) { t=-1.0; suvw=vec4(512.0); }\n    return t;\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, float k, float l )\n{\n    float res = 1.0;\n    float t = 0.1;\n\tvec4 kk;\n\tfloat kk2;\n\tfloat h = 1.0;\n\n\tfor( int i=0; i<38; i++ )\n    {\n\t\th = map2( ro + rd*t );\n\t\th = max( h, 0.0 );\n        res = min( res, k*h\/t );\n\t\tt += clamp( h, 0.001, 0.3 );\n\t\tif( h<0.0001 ) break;\n    }\n\t\n#ifdef GODRAYS\n    \/\/ fake leaves shadow\t\n\tvec3 pp = ro - rd*dot(rd,ro);\n\tres *= mix( 1.0, smoothstep( 0.3, 0.5, texture2D(iChannel2,2.0*pp.zx).x ), 0.5+0.5*l );\n#endif\t\n    return clamp(res,0.0,1.0);\n}\n\nvec4 lpos[7];\n\n\nvec3 shade( in vec3 pos, in vec3 nor, in vec3 rd, float matID, in vec3 uvw, in float info, in vec3 sunDirection )\n{\n\t\n    vec3 rgb = vec3(0.0);\n\t\n    \/\/ ground\n    if( matID<0.5 )\n    {\n\t\tfloat f = grassDistr( pos.xz ).x;\n\t\t\t\n\t\tfloat rs = 1.5;\n\t\tvec3 stones = texture2D(iChannel3,rs*pos.xz).xyz;\n\t\tvec3 nnoise = texture2D( iChannel1, pos.xz*0.5 ).xyz;\n\n        \/\/ dirt\n \t\tvec3 ground = vec3(0.04,0.03,0.01);\n\t\tground *= 0.33 + 1.25*nnoise.x;\n\t\tground = mix( ground, ground+0.02, smoothstep( 0.2, 0.5, stones.x ) );\n\n\t\t\/\/ frass\n\t\tvec3 grass = vec3(0.1,0.1,0.0);\n        \/\/ color variation\t\t\n\t\tgrass += 0.015*sin( nnoise.x*10.0 + vec3(0.0,1.0,2.0) );\n        \/\/ flowers\t\t\n\t\tfloat fl = smoothstep( 0.5, 0.6, texture2D(iChannel3,10.0*pos.xz).z ) ;\n\t\tfl *= smoothstep( 0.3, 0.35, nnoise.z );\n\t\tgrass = mix( grass, vec3(0.4,0.3,0.1), fl );\n\t\t\n\t\trgb = mix( ground, grass, f );\n\t\t\n\t\trgb *= 0.3 + 0.7*texture2D( iChannel2, pos.xz*2.0 ).x;\n\t\t\n        \/\/bump\t\t\n\t\tnor.x -= (1.0-f)*1.0*(smoothstep( 0.2, 0.5, texture2D(iChannel3,rs*pos.xz+vec2(0.05,0.0)).x) - smoothstep( 0.2, 0.5, texture2D(iChannel3,rs*pos.xz-vec2(0.05,0.0)).x));\n\t\tnor.z -= (1.0-f)*1.0*(smoothstep( 0.2, 0.5, texture2D(iChannel3,rs*pos.xz+vec2(0.0,0.05)).x) - smoothstep( 0.2, 0.5, texture2D(iChannel3,rs*pos.xz-vec2(0.0,0.05)).x));\n\t\tnor = normalize( nor );\n    }\n\t\/\/ trees\n    else if( matID<1.5 )\n    {\n        rgb = vec3(0.35,0.1,0.0);\n\t\t\n\t\trgb = mix( rgb*0.15, vec3(0.2,0.12,0.03), smoothstep( 0.0, 1.0, uvw.y ) );\n\t\t\n\t\tfloat tt = texturize( iChannel1, 1.5*pos*vec3(1.0,0.5,1.0), nor ).x;\n\t\trgb *= 0.2+1.5*tt;\n\t\t\n\t\ttt = texturize( iChannel1, 0.03*pos, nor ).x;\n\t\t\n\t\tfloat ff = texturize( iChannel1, 1.5*pos, nor ).x;\n\t\tfloat green = (1.0-smoothstep(0.0, 0.5, uvw.x*4.0 - tt + 0.1));\n\t\trgb = mix( rgb, 2.4*vec3(0.045,0.05,0.00)*ff, 0.8*green );\n\t\t\n\t\t\/\/ bump\n\t\tvec2 cuv = vec2( uvw.x*3.0, info );\n\t\tfloat bu = 0.0;\n\t\tbu = 0.5 + 0.25*green;\n\t\tnor = normalize( nor + bu * (-1.0 + 2.0*texture2D( iChannel0, cuv ).xyz) );\n\t}   \n    \/\/ mushrooms\n    else if( matID<2.5 )\n    {\n        \/\/ base color\t\t\n\t\tvec3 tcol = mix( vec3(0.1,0.01,0.00), vec3(0.14,0.04,0.0), pow( clamp(1.0+dot(rd,nor),0.0,1.0), 2.0 ) );\n\t\t\n        \/\/ color variation\t\t\n\t\ttcol += 0.03*sin( uvw.x*10.0 + vec3(0.0,1.0,2.0) );\n\t\t\n\t\t\/\/ white\n        vec2 uv = vec2(uvw.y,info);\n\t\tvec2 iuv = floor(uv*9.0);\n\t\tvec2 fuv = fract(uv*9.0 );\n\t\tuv = fuv - 0.5 + 0.25*(-1.0+2.0*hash2( iuv ));\n\t\tuv *= 0.5 + 0.5*hash( iuv );\n\t\tfloat f = 1.0 - smoothstep( 0.1, 0.3, length( uv ) );\n\t\tf *= smoothstep( 0.3, 0.31, hash( iuv.yx*1.3 ) );\n\t\tf *= smoothstep( 0.4, 0.5, nor.y );\n\t\trgb = mix( tcol, vec3(0.23,0.21,0.19), f );\n\n\n\t\t\/\/float an = clamp(0.5 + 0.5*(mushroomAnim( iGlobalTime*(1.0+uvw.x) + 6.28*uvw.x )-1.0)\/0.1,0.0,1.0);\n        \/\/rgb *= 0.25 + 2.5*an*vec3(1.0,0.7,0.5);\n\t\t\n\t\trgb *= 0.9;\n\t}\n\t\n\t\/\/ lighting terms\n\tfloat occ = uvw.z;\n\tfloat sha = softshadow( pos, sunDirection, 64.0, 0.0 );\n    float sun = clamp( dot( nor, sunDirection ), 0.0, 1.0 );\n    float sky = clamp( 0.5 + 0.5*nor.y, 0.0, 1.0 );\n    float ind = clamp( dot( nor, normalize(sunDirection*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\n\tfloat fre = pow( clamp( 1.0+dot(nor,rd), 0.0, 1.0 ), 5.0 );\n\t\n\tfloat spe = pow( clamp( dot( reflect( rd, nor ), sunDirection ), 0.0, 1.0 ), 16.0 );\n\t\n    \/\/ compute lighting\n    vec3 lin  = 3.5*sun*vec3(1.75,1.30,1.00)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n         lin += 2.5*sky*vec3(0.82,0.75,0.50)*occ;\n         lin += 1.1*ind*vec3(0.30,0.35,0.25)*occ;\n         lin += 6.0*spe*sha*(0.5+0.5*fre);\n         lin *= 1.0 + 1.0*fre*occ*vec3(1.5,1.0,0.5);\n    for( int i=0; i<7; i++ )\n    {\n        vec3 lig = lpos[i].xyz - pos;\n        float llig = dot(lig,lig);\n        float im = inversesqrt( llig );\n        lig = lig * im;\n\t\tlin += vec3(1.0,0.5,0.2)*1.5*lpos[i].w * clamp(dot(lig,nor),0.0,1.0)*im*im*occ;\n\t}\n\t\t\t\n\treturn rgb * lin * 1.3;\n}\n\n\nvoid moveLights( void )\n{\n\n    for( int i=0; i<7; i++ )\n\t{\n\t\tvec3 pos;\n\t    pos.x = 3.2*cos(0.0+0.08*iGlobalTime*2.0 + 17.0*float(i) );\n\t    pos.z = 3.2*cos(1.65+0.07*iGlobalTime*2.0 + 13.0*float(i) );\n\t    pos.y = terrain( pos.xz ) + 0.4;\n\t\t\n\t\t\/\/ make the lights avoid the trees\n\t    vec2 chos = 2.5 + 5.0*floor( pos.xz\/5.0);\n\t    float r = length( pos.xz - chos);\n\t    pos.xz = chos + max( r, 1.5 )*normalize(pos.xz-chos);\n\t\t\n\t\tlpos[i].xyz = pos;\n\t\tlpos[i].w = smoothstep(5.0,10.0,iGlobalTime)*(0.85 + 0.15*sin(25.0*iGlobalTime+ 23.1*float(i)));\n\t}\n}\n\nfloat doFirefly( in vec3 ro, in vec3 rd, in float t, in vec3 lpo, in float ra )\n{\n\tfloat h = 0.0;\n\tvec3 lv = ro - lpo;\n\tfloat ll = dot(lv,lv);\n    if( ll < (t*t) ) \/\/ depth comparison\n    {\n\t\tfloat b = dot(rd,lv);\n\t\tfloat c = ll - ra;\n\t\th = max(b*b-c,0.0)\/ra;\n        h = h*h*h*h;\n    }\n\treturn h;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    \n\tp.y *= iResolution.y\/iResolution.x;\n\n    vec2 m = vec2(0.5); if( iMouse.z>0.0 ) m = iMouse.xy\/iResolution.xy;\n\n    \/\/ animate\t\n\tmoveLights();\n\t\t\n    \/\/ camera\n\tfloat an = 7.5 + 0.0*0.2*sin(0.05*(iGlobalTime-10.0)) - m.x*3.0;\n\n    vec3  ro = vec3( 5.0*sin(an), 0.0, 5.0*cos(an));\n    vec3  ta = vec3( 0.0, 8.5, 0.0 );\n\tro.y = terrain( ro.xz ) + max( 0.25, 1.0 - 2.0*(m.y-0.5) );\n\t\/\/ro.y = 8.3;\n\tta.y = terrain( ta.xz ) - 0.0;\n\t\n    vec3  ww = normalize( ta - ro );\n    vec3  uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3  vv = normalize( cross(uu,ww));\n    vec3  rd = normalize( p.x*uu + p.y*vv + 1.11*ww );\n\n\tvec3 col = vec3(0.0);\n\n    \/\/ ray march scene\n\tvec4 suvw;\n\tfloat info;\n\tfloat t = intersect( ro, rd, suvw, info );\n\n    #if LIGHTRIG==0\n\tvec3 sunDirection = normalize( vec3(-0.1,0.5,-0.6) );\n\t#else\n\tvec3 sunDirection = normalize( vec3(0.4,0.4,-0.05) );\n    #endif\n\n\tif( t>0.0 )\n\t{\n\t    vec3 pos = ro + t*rd;\n\t    vec3 nor = calcNormal( pos );\n\n        #if LIGHTRIG==0\n\t\tcol = shade( pos, nor, rd, suvw.x, suvw.yzw, info, sunDirection );\n\t\t#else\n  \t    \/\/ super trick\n        vec3 sunDirectionA = normalize( vec3(0.54,0.1,0.0) );\n\t\tvec3 fakeSunDirection = normalize( mix(sunDirection,sunDirectionA,smoothstep(2.0,4.0,t)));\n\t\tcol = shade( pos, nor, rd, suvw.x, suvw.yzw, info, fakeSunDirection );\n        #endif\n\n\t}\n    else\n\t{\n\t\tt = 1e10;\n\t}\t\t\n\n    \/\/ fog\t\n    col = mix( col, vec3(0.20,0.15,0.05), 1.0 - exp(-0.0007*t*t) );\n\n    \/\/ godrays (only Linux)\t\n\t#ifdef GODRAYS\n\tfloat v = 0.0;\n\tfloat s = 0.5 + 0.15*texture2D(iChannel0, fragCoord.xy\/iChannelResolution[0].xy ).x;\n\tfor( int i=0; i<32; i++ )\n    {\n\t\tif( s>t ) continue;\n\t\tvec3 pos = ro + rd*s;\n\t\tfloat h = softshadow( pos, sunDirection, 32.0, 1.0 );\n\t\tv += h * exp(-0.2*s);\n\t\ts += 0.15;\n\t}\n\tv \/= 32.0;\n\t#if LIGHTRIG==1\n\tfloat vm = 2.0;\n\t#else\n\tfloat vm = 1.0;\n\t#endif\n    col += vm*v*v*vec3(1.0,0.75,0.4);\n    #endif\t\n\t\t\n\t\n\t\n\t\n\t\/\/ iluminating fireflies\n\tfor( int i=0; i<7; i++ )\n\t{\n\t\tcol += 3.0*vec3(1.0,0.3,0.05)*lpos[i].w*doFirefly( ro, rd, t, lpos[i].xyz, 0.05 );\n    }\n\n\t\/\/ non iluminating fireflies\t\n\tfor( int i=0; i<32; i++ )\n\t{\n\t\tvec3 rrr = 1.5*sin( hash3(float(i)) + float(i)*vec3(1.2,1.1,1.7) + vec3(0.0,1.0,2.0) + 0.01*iGlobalTime);\n\t\tfloat br = 0.5 + 0.5*sin(2.0*iGlobalTime+ 23.1*float(i));\n\t\t\n\t\tcol += vec3(1.0,0.7,0.3)*br*doFirefly( ro, rd, t, rrr.xyz*vec3(1.5,1.0,1.5) + vec3(0.0,10.0,2.0), 0.0017 );\n\t\tcol += vec3(1.0,0.7,0.3)*br*doFirefly( ro, rd, t, rrr.yzx*vec3(1.5,1.0,1.5) + vec3(0.0,10.0,2.0), 0.0017 );\n\t\tcol += vec3(1.0,0.7,0.3)*br*doFirefly( ro, rd, t, rrr.zxy*vec3(1.5,1.0,1.5) + vec3(0.0,10.0,2.0), 0.0017 );\n\t}\n\n\t\/\/ gamma\n\tcol = pow( clamp( col, 0.0, 1.0 ), vec3(0.45) );\n\n    \/\/ contrast\t\n    col = col*0.7 + 0.3*col*col*(3.0-2.0*col); \n\t\n    \/\/ blue color balance darks\t\n\tcol = mix( col, vec3(0.0,0.0,1.0)*dot(col,vec3(0.33)), 0.25*pow( 1.0-dot(col,vec3(0.33)), 8.0 ) );\n\t\n\t\/\/ vigneting\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\n    \/\/ fade\t\n\tcol *= smoothstep( 0.0, 3.0, iGlobalTime );\n\n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}