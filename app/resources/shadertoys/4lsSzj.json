{"Shader":{"ver":"0.1","info":{"id":"4lsSzj","date":"1438055717","viewed":789,"name":"Infinite Bezier Rectangles","username":"demofox","description":"The same shader as https:\/\/www.shadertoy.com\/view\/4tfXz2, but tiled.  Ray vs plane to figure out where to start raymarching.  This would look way cooler using wang tiling (https:\/\/www.shadertoy.com\/view\/XsSXzR)","likes":4,"published":3,"flags":0,"tags":["3d","bezier"],"hasliked":0},"renderpass":[{"inputs":[{"id":24,"src":"\/presets\/cube02_0.jpg","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/*\nFor more information, check this out:\nhttp:\/\/blog.demofox.org\/2015\/07\/28\/rectangular-bezier-patches\/\n*\/\n\n#define SHOW_BOUNDINGBOX   0\n\nfloat CP00 = sin(iGlobalTime*0.30) * 0.5 + 0.5;\nfloat CP01 = sin(iGlobalTime*0.10) * 0.5 + 0.5;\nfloat CP02 = sin(iGlobalTime*0.70) * 0.5 + 0.5;\nfloat CP03 = sin(iGlobalTime*0.52) * 0.5 + 0.5;\n\nfloat CP10 = sin(iGlobalTime*0.20) * 0.5 + 0.5;\nfloat CP11 = sin(iGlobalTime*0.40) * 0.5 + 0.5;\nfloat CP12 = sin(iGlobalTime*0.80) * 0.5 + 0.5;\nfloat CP13 = sin(iGlobalTime*0.61) * 0.5 + 0.5;\n\nfloat CP20 = sin(iGlobalTime*0.50) * 0.5 + 0.5;\nfloat CP21 = sin(iGlobalTime*0.90) * 0.5 + 0.5;\nfloat CP22 = sin(iGlobalTime*0.60) * 0.5 + 0.5;\nfloat CP23 = sin(iGlobalTime*0.32) * 0.5 + 0.5;\n\nfloat CP30 = sin(iGlobalTime*0.27) * 0.5 + 0.5;\nfloat CP31 = sin(iGlobalTime*0.64) * 0.5 + 0.5;\nfloat CP32 = sin(iGlobalTime*0.18) * 0.5 + 0.5;\nfloat CP33 = sin(iGlobalTime*0.95) * 0.5 + 0.5;\n\nfloat CPMin =\n    min(CP00,min(CP01,min(CP02,min(CP03,\n    min(CP10,min(CP11,min(CP12,min(CP13,\n    min(CP20,min(CP21,min(CP22,min(CP23,\n    min(CP30,min(CP31,min(CP32,CP33)))))))))))))));    \n\nfloat CPMax =\n    max(CP00,max(CP01,max(CP02,max(CP03,\n    max(CP10,max(CP11,max(CP12,max(CP13,\n    max(CP20,max(CP21,max(CP22,max(CP23,\n    max(CP30,max(CP31,max(CP32,CP33))))))))))))))); \n\n#define FLT_MAX 3.402823466e+38\n\n\/\/=======================================================================================\nfloat CubicBezier (float A, float B, float C, float D, float t)\n{\n    float s = 1.0 - t;\n    float s2 = s * s;\n    float s3 = s * s * s;\n    float t2 = t * t;\n    float t3 = t * t * t;\n    \n    return A*s3 + B*3.0*s2*t + C*3.0*s*t2 + D*t3;\n}\n\n\n\/\/=======================================================================================\nfloat HeightAtPos(vec2 P)\n{\n    vec2 tile = mod(floor(P),2.0);\n    \n    P = fract(P);\n    \n    if (tile.x == 1.0)\n        P.x = 1.0 - P.x;\n    \n    if (tile.y == 1.0)\n        P.y = 1.0 - P.y;\n    \n    float CP0X = CubicBezier(CP00, CP01, CP02, CP03, P.x);\n    float CP1X = CubicBezier(CP10, CP11, CP12, CP13, P.x);\n    float CP2X = CubicBezier(CP20, CP21, CP22, CP23, P.x);\n    float CP3X = CubicBezier(CP30, CP31, CP32, CP33, P.x);\n    \n    return CubicBezier(CP0X, CP1X, CP2X, CP3X, P.y);\n}\n\n\/\/=======================================================================================\nvec3 NormalAtPos( vec2 p )\n{\n\tfloat eps = 0.01;\n    vec3 n = vec3( HeightAtPos(vec2(p.x-eps,p.y)) - HeightAtPos(vec2(p.x+eps,p.y)),\n                         2.0*eps,\n                         HeightAtPos(vec2(p.x,p.y-eps)) - HeightAtPos(vec2(p.x,p.y+eps)));\n    return normalize( n );\n}\n\n\/\/=======================================================================================\nbool RayIntersectAABoxYAxis (vec3 boxMin, vec3 boxMax, in vec3 rayPos, in vec3 rayDir, out vec2 time)\n{\n\tfloat roo = rayPos.y - (boxMin.y+boxMax.y)*0.5;\n    float rad = (boxMax.y - boxMin.y)*0.5;\n\n    float m = 1.0\/rayDir.y;\n    float n = m*roo;\n    float k = abs(m)*rad;\n\t\n    float t1 = -n - k;\n    float t2 = -n + k;\n\n    time = vec2(t1, t2);\n\t\n    return time.y>time.x && time.y>0.0;\n}\n\n\/\/=======================================================================================\nfloat RayIntersectSphere (vec4 sphere, in vec3 rayPos, in vec3 rayDir)\n{\n\t\/\/get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    \/\/get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t\/\/exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn -1.0;\n\n\t\/\/calculate discriminant\n\tfloat discr = b * b - c;\n\n\t\/\/a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn -1.0;\n\n\t\/\/ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat collisionTime = -b - sqrt(discr);\n\n\t\/\/if t is negative, ray started inside sphere so clamp t to zero and remember that we hit from the inside\n\tif(collisionTime < 0.0)\n\t\tcollisionTime = -b + sqrt(discr);\n    \n    return collisionTime;\n}\n\n\/\/=======================================================================================\nvec3 DiffuseColor (in vec3 pos)\n{\n\t\/\/ checkerboard pattern\n    return vec3(mod(floor(pos.x * 10.0) + floor(pos.z * 10.0), 2.0) < 1.0 ? 1.0 : 0.4);\n}\n\n\/\/=======================================================================================\nvec3 ShadePoint (in vec3 pos, in vec3 rayDir, float time, bool fromUnderneath)\n{\n\tvec3 diffuseColor = DiffuseColor(pos);\n\tvec3 reverseLightDir = normalize(vec3(1.0,1.0,-1.0));\n\tvec3 lightColor = vec3(0.95,0.95,0.95);\t\n\tvec3 ambientColor = vec3(0.05,0.05,0.05);\n\n\tvec3 normal = NormalAtPos(pos.xz);\n    normal *= fromUnderneath ? -1.0 : 1.0;\n\n    \/\/ diffuse\n\tvec3 color = diffuseColor * ambientColor;\n\tfloat dp = dot(normal, reverseLightDir);\n\tif(dp > 0.0)\n\t\tcolor += (diffuseColor * dp * lightColor);\n    \n    \/\/ specular\n    vec3 reflection = reflect(reverseLightDir, normal);\n    dp = dot(rayDir, reflection);\n    if (dp > 0.0)\n        color += pow(dp, 15.0) * vec3(0.5);\t\t\n    \n    \/\/ reflection (environment mappping)\n    reflection = reflect(rayDir, normal);\n    color += textureCube(iChannel0, reflection).rgb * 0.25;    \n    \n    return color;\n}\n\n\/\/=======================================================================================\nvec3 HandleRay (in vec3 rayPos, in vec3 rayDir, in vec3 pixelColor, out float hitTime)\n{\n\tfloat time = 0.0;\n\tfloat lastHeight = 0.0;\n\tfloat lastY = 0.0;\n\tfloat height;\n\tbool hitFound = false;\n    hitTime = FLT_MAX;\n    bool fromUnderneath = false;\n    \n    vec2 timeMinMax = vec2(0.0);\n    if (!RayIntersectAABoxYAxis(vec3(0.0,CPMin,0.0), vec3(1.0,CPMax,1.0), rayPos, rayDir, timeMinMax))\n        return pixelColor;\n    \n    time = timeMinMax.x;\n    \n    const int c_numIters = 100;\n    float deltaT = (timeMinMax.y - timeMinMax.x) \/ float(c_numIters);\n    \n    vec3 pos = rayPos + rayDir * time;\n    float firstSign = sign(pos.y - HeightAtPos(pos.xz));\n    \n\tfor (int index = 0; index < c_numIters; ++index)\n\t{\t\t\n\t\tpos = rayPos + rayDir * time;\n        \n        height = HeightAtPos(pos.xz);\n        \n        if (sign(pos.y - height) * firstSign < 0.0)\n        {\n            fromUnderneath = firstSign < 0.0; \n        \thitFound = true;\n\t\t\tbreak;\n        }\n\t\t\n\t\ttime += deltaT;\t\t\n\t\tlastHeight = height;\n\t\tlastY = pos.y;\n    }\n    \n\t\n\tif (hitFound) {\n\t\ttime = time - deltaT + deltaT*(lastHeight-lastY)\/(pos.y-lastY-height+lastHeight);\n\t\tpos = rayPos + rayDir * time;\n\t\tpixelColor = ShadePoint(pos, rayDir, time, fromUnderneath);\n        hitTime = time;\n\t}\n    else\n    {\n        #if SHOW_BOUNDINGBOX\n        \tpixelColor += vec3(0.2);\n        #endif\n    }\n    \n\treturn pixelColor;\n}\n\n\/\/=======================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    \/\/ keep it from degenerating when all control points are the same - like at the start!\n    CPMin -= 0.005;\n    CPMax += 0.005;\n    \n    \/\/ scrolling camera\n    vec3 cameraOffset = vec3(iGlobalTime, iGlobalTime \/ 10.0, iGlobalTime);\n    \n    \/\/----- camera\n    vec2 mouse = iMouse.xy \/ iResolution.xy;\n\n    vec3 cameraAt \t= vec3(0.5,0.5,0.5) + cameraOffset;\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14 + iGlobalTime * 0.25;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.5;\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 5.0;\n    cameraPos += vec3(0.5,0.5,0.5) + cameraOffset;\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y \/ iResolution.x;\n    float cameraDistance\t= 6.0;  \/\/ intuitively backwards!\n\t\n\t\t\n\t\/\/ Objects\n\tvec2 rawPercent = (fragCoord.xy \/ iResolution.xy);\n\tvec2 percent = rawPercent - vec2(0.5,0.5);\n\t\n\tvec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n\t\t\t\t   - (cameraLeft * percent.x * cameraViewWidth)\n\t\t           + (cameraUp * percent.y * cameraViewHeight);\n\tvec3 rayDir = normalize(rayTarget);\n\t\n\t\n    float hitTime = FLT_MAX;\n\tvec3 pixelColor = textureCube(iChannel0, rayDir).rgb;\n    pixelColor = HandleRay(cameraPos, rayDir, pixelColor, hitTime);\n    \n    fragColor = vec4(clamp(pixelColor,0.0,1.0), 1.0);\n}","name":"","description":"","type":"image"}]}}