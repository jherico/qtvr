{"Shader":{"ver":"0.1","info":{"id":"4d3GW7","date":"1449892463","viewed":388,"name":"2015\/12\/12","username":"hughsk","description":"Experimenting with refraction \u2014 still some room for improving accuracy\/aesthetics but happy with it so far <img src=\"\/img\/emoticonHappy.png\"\/>","likes":20,"published":3,"flags":0,"tags":["grid","sdf","refraction","color","refract"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define GLSLIFY 1\n\nvec2 mapRefract(vec3 p);\nvec2 mapSolid(vec3 p);\n\nvec2 calcRayIntersection_3975550108(vec3 rayOrigin, vec3 rayDir, float maxd, float precis) {\n  float latest = precis * 2.0;\n  float dist   = +0.0;\n  float type   = -1.0;\n  vec2  res    = vec2(-1.0, -1.0);\n\n  for (int i = 0; i < 50; i++) {\n    if (latest < precis || dist > maxd) break;\n\n    vec2 result = mapRefract(rayOrigin + rayDir * dist);\n\n    latest = result.x;\n    type   = result.y;\n    dist  += latest;\n  }\n\n  if (dist < maxd) {\n    res = vec2(dist, type);\n  }\n\n  return res;\n}\n\nvec2 calcRayIntersection_3975550108(vec3 rayOrigin, vec3 rayDir) {\n  return calcRayIntersection_3975550108(rayOrigin, rayDir, 20.0, 0.001);\n}\n\nvec2 calcRayIntersection_766934105(vec3 rayOrigin, vec3 rayDir, float maxd, float precis) {\n  float latest = precis * 2.0;\n  float dist   = +0.0;\n  float type   = -1.0;\n  vec2  res    = vec2(-1.0, -1.0);\n\n  for (int i = 0; i < 60; i++) {\n    if (latest < precis || dist > maxd) break;\n\n    vec2 result = mapSolid(rayOrigin + rayDir * dist);\n\n    latest = result.x;\n    type   = result.y;\n    dist  += latest;\n  }\n\n  if (dist < maxd) {\n    res = vec2(dist, type);\n  }\n\n  return res;\n}\n\nvec2 calcRayIntersection_766934105(vec3 rayOrigin, vec3 rayDir) {\n  return calcRayIntersection_766934105(rayOrigin, rayDir, 20.0, 0.001);\n}\n\nvec3 calcNormal_3606979787(vec3 pos, float eps) {\n  const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n  const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n  const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n  const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n  return normalize( v1 * mapRefract( pos + v1*eps ).x +\n                    v2 * mapRefract( pos + v2*eps ).x +\n                    v3 * mapRefract( pos + v3*eps ).x +\n                    v4 * mapRefract( pos + v4*eps ).x );\n}\n\nvec3 calcNormal_3606979787(vec3 pos) {\n  return calcNormal_3606979787(pos, 0.002);\n}\n\nvec3 calcNormal_1245821463(vec3 pos, float eps) {\n  const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n  const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n  const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n  const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n  return normalize( v1 * mapSolid( pos + v1*eps ).x +\n                    v2 * mapSolid( pos + v2*eps ).x +\n                    v3 * mapSolid( pos + v3*eps ).x +\n                    v4 * mapSolid( pos + v4*eps ).x );\n}\n\nvec3 calcNormal_1245821463(vec3 pos) {\n  return calcNormal_1245821463(pos, 0.002);\n}\n\nfloat beckmannDistribution_2315452051(float x, float roughness) {\n  float NdotH = max(x, 0.0001);\n  float cos2Alpha = NdotH * NdotH;\n  float tan2Alpha = (cos2Alpha - 1.0) \/ cos2Alpha;\n  float roughness2 = roughness * roughness;\n  float denom = 3.141592653589793 * roughness2 * cos2Alpha * cos2Alpha;\n  return exp(tan2Alpha \/ roughness2) \/ denom;\n}\n\nfloat cookTorranceSpecular_1460171947(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float fresnel) {\n\n  float VdotN = max(dot(viewDirection, surfaceNormal), 0.0);\n  float LdotN = max(dot(lightDirection, surfaceNormal), 0.0);\n\n  \/\/Half angle vector\n  vec3 H = normalize(lightDirection + viewDirection);\n\n  \/\/Geometric term\n  float NdotH = max(dot(surfaceNormal, H), 0.0);\n  float VdotH = max(dot(viewDirection, H), 0.000001);\n  float LdotH = max(dot(lightDirection, H), 0.000001);\n  float G1 = (2.0 * NdotH * VdotN) \/ VdotH;\n  float G2 = (2.0 * NdotH * LdotN) \/ LdotH;\n  float G = min(1.0, min(G1, G2));\n\n  \/\/Distribution term\n  float D = beckmannDistribution_2315452051(NdotH, roughness);\n\n  \/\/Fresnel term\n  float F = pow(1.0 - VdotN, fresnel);\n\n  \/\/Multiply terms and done\n  return  G * F * D \/ max(3.14159265 * VdotN, 0.000001);\n}\n\nvec2 squareFrame_1062606552(vec2 screenSize) {\n  vec2 position = 2.0 * (gl_FragCoord.xy \/ screenSize.xy) - 1.0;\n  position.x *= screenSize.x \/ screenSize.y;\n  return position;\n}\n\nvec2 squareFrame_1062606552(vec2 screenSize, vec2 coord) {\n  vec2 position = 2.0 * (coord.xy \/ screenSize.xy) - 1.0;\n  position.x *= screenSize.x \/ screenSize.y;\n  return position;\n}\n\nmat3 calcLookAtMatrix_1535977339(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nvec3 getRay_870892966(mat3 camMat, vec2 screenPos, float lensLength) {\n  return normalize(camMat * vec3(screenPos, lensLength));\n}\n\nvec3 getRay_870892966(vec3 origin, vec3 target, vec2 screenPos, float lensLength) {\n  mat3 camMat = calcLookAtMatrix_1535977339(origin, target, 0.0);\n  return getRay_870892966(camMat, screenPos, lensLength);\n}\n\nvoid orbitCamera_421267681(\n  in float camAngle,\n  in float camHeight,\n  in float camDistance,\n  in vec2 screenResolution,\n  out vec3 rayOrigin,\n  out vec3 rayDirection,\n  in vec2 coord\n) {\n  vec2 screenPos = squareFrame_1062606552(screenResolution, coord);\n  vec3 rayTarget = vec3(0.0);\n\n  rayOrigin = vec3(\n    camDistance * sin(camAngle),\n    camHeight,\n    camDistance * cos(camAngle)\n  );\n\n  rayDirection = getRay_870892966(rayOrigin, rayTarget, screenPos, 2.0);\n}\n\n\/\/ Originally sourced from:\n\/\/ http:\/\/iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\n\nfloat sdBox_1117569599(vec3 position, vec3 dimensions) {\n  vec3 d = abs(position) - dimensions;\n\n  return min(max(d.x, max(d.y,d.z)), 0.0) + length(max(d, 0.0));\n}\n\nhighp float random_2281831123(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nfloat fogFactorExp2_529295689(\n  const float dist,\n  const float density\n) {\n  const float LOG2 = -1.442695;\n  float d = density * dist;\n  return 1.0 - clamp(exp2(d * d * LOG2), 0.0, 1.0);\n}\n\nfloat intersectPlane(vec3 ro, vec3 rd, vec3 nor, float dist) {\n  float denom = dot(rd, nor);\n  float t = -(dot(ro, nor) + dist) \/ denom;\n\n  return t;\n}\n\nvec3 n4 = vec3(0.577,0.577,0.577);\nvec3 n5 = vec3(-0.577,0.577,0.577);\nvec3 n6 = vec3(0.577,-0.577,0.577);\nvec3 n7 = vec3(0.577,0.577,-0.577);\nvec3 n8 = vec3(0.000,0.357,0.934);\nvec3 n9 = vec3(0.000,-0.357,0.934);\nvec3 n10 = vec3(0.934,0.000,0.357);\nvec3 n11 = vec3(-0.934,0.000,0.357);\nvec3 n12 = vec3(0.357,0.934,0.000);\nvec3 n13 = vec3(-0.357,0.934,0.000);\n\nfloat icosahedral(vec3 p, float r) {\n  float s = abs(dot(p,n4));\n  s = max(s, abs(dot(p,n5)));\n  s = max(s, abs(dot(p,n6)));\n  s = max(s, abs(dot(p,n7)));\n  s = max(s, abs(dot(p,n8)));\n  s = max(s, abs(dot(p,n9)));\n  s = max(s, abs(dot(p,n10)));\n  s = max(s, abs(dot(p,n11)));\n  s = max(s, abs(dot(p,n12)));\n  s = max(s, abs(dot(p,n13)));\n  return s - r;\n}\n\nvec2 rotate2D(vec2 p, float a) {\n  return p * mat2(cos(a), -sin(a), sin(a),  cos(a));\n}\n\nvec2 mapRefract(vec3 p) {\n  float d  = icosahedral(p, 1.0);\n  float id = 0.0;\n\n  return vec2(d, id);\n}\n\nvec2 mapSolid(vec3 p) {\n  p.xz = rotate2D(p.xz, iGlobalTime * 1.25);\n  p.yx = rotate2D(p.yx, iGlobalTime * 1.85);\n  p.y += sin(iGlobalTime) * 0.25;\n  p.x += cos(iGlobalTime) * 0.25;\n\n  float d = length(p) - 0.25;\n  float id = 1.0;\n  float pulse = pow(sin(iGlobalTime * 2.) * 0.5 + 0.5, 9.0) * 2.;\n\n  d = mix(d, sdBox_1117569599(p, vec3(0.175)), pulse);\n\n  return vec2(d, id);\n}\n\n\/\/ Source: http:\/\/www.iquilezles.org\/www\/articles\/palettes\/palettes.htm\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 bg(vec3 ro, vec3 rd) {\n  vec3 col = 0.1 + (\n    palette(clamp((random_2281831123(rd.xz + sin(iGlobalTime * 0.1)) * 0.5 + 0.5) * 0.035 - rd.y * 0.5 + 0.35, -1.0, 1.0)\n      , vec3(0.5, 0.45, 0.55)\n      , vec3(0.5, 0.5, 0.5)\n      , vec3(1.05, 1.0, 1.0)\n      , vec3(0.275, 0.2, 0.19)\n    )\n  );\n\n  float t = intersectPlane(ro, rd, vec3(0, 1, 0), 4.);\n\n  if (t > 0.0) {\n    vec3 p = ro + rd * t;\n    float g = (1.0 - pow(abs(sin(p.x) * cos(p.z)), 0.25));\n\n    col += (1.0 - fogFactorExp2_529295689(t, 0.04)) * g * vec3(5, 4, 2) * 0.075;\n  }\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec3 ro, rd;\n\n  vec2  uv       = squareFrame_1062606552(iResolution.xy, fragCoord);\n  float dist     = 4.5;\n  float rotation = iMouse.z > 0.0\n    ? 6. * iMouse.x \/ iResolution.x\n    : iGlobalTime * 0.45;\n  float height = iMouse.z > 0.0\n    ? 5. * (iMouse.y \/ iResolution.y * 2.0 - 1.0)\n    : -0.2;\n    \n  orbitCamera_421267681(rotation, height, dist, iResolution.xy, ro, rd, fragCoord);\n\n  vec3 color = bg(ro, rd);\n  vec2 t = calcRayIntersection_3975550108(ro, rd);\n  if (t.x > -0.5) {\n    vec3 pos = ro + rd * t.x;\n    vec3 nor = calcNormal_3606979787(pos);\n    vec3 ldir1 = normalize(vec3(0.8, 1, 0));\n    vec3 ldir2 = normalize(vec3(-0.4, -1.3, 0));\n    vec3 lcol1 = vec3(0.6, 0.5, 1.1);\n    vec3 lcol2 = vec3(1.4, 0.9, 0.8) * 0.7;\n\n    vec3 ref = refract(rd, nor, 0.97);\n    vec2 u = calcRayIntersection_766934105(ro + ref * 0.1, ref);\n    if (u.x > -0.5) {\n      vec3 pos2 = ro + ref * u.x;\n      vec3 nor2 = calcNormal_1245821463(pos2);\n      float spec = cookTorranceSpecular_1460171947(ldir1, -ref, nor2, 0.6, 0.95) * 2.;\n      float diff1 = 0.05 + max(0., dot(ldir1, nor2));\n      float diff2 = max(0., dot(ldir2, nor2));\n\n      color = spec + (diff1 * lcol1 + diff2 * lcol2);\n    } else {\n      color = bg(ro + ref * 0.1, ref) * 1.1;\n    }\n\n    color += color * cookTorranceSpecular_1460171947(ldir1, -rd, nor, 0.2, 0.9) * 2.;\n    color += 0.05;\n  }\n\n  float vignette = 1.0 - max(0.0, dot(uv * 0.155, uv));\n\n  color.r = smoothstep(0.05, 0.995, color.r);\n  color.b = smoothstep(-0.05, 0.95, color.b);\n  color.g = smoothstep(-0.1, 0.95, color.g);\n  color.b *= vignette;\n\n  fragColor.rgb = color;\n  fragColor.a   = 1.0;\n}\n","name":"","description":"","type":"image"}]}}