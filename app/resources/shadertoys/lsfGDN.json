{"Shader":{"ver":"0.1","info":{"id":"lsfGDN","date":"1447082224","viewed":712,"name":"Rectangular Area Light","username":"tsone","description":"Approximation for rectangular area light. Uses distance field on a plane. Using this technique, the emitter could probably have any shape, not just rectangle.","likes":22,"published":3,"flags":0,"tags":["light","rectangular","area"],"hasliked":0},"renderpass":[{"inputs":[{"id":6,"src":"\/presets\/tex05.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/*\n\nCopyright 2015 Valtteri \"tsone\" Heikkil\u00e4\n\nThis work is licensed under the Creative Commons Attribution 4.0 International License.\nTo view a copy of this license, visit http:\/\/creativecommons.org\/licenses\/by\/4.0\/\n\n*\/\n\n#define PI\t\t\t3.141592653589793\n#define SQRT2\t\t1.414213562373095\n#define INVSQRT2\t0.707106781186548\n\n\/\/ Set 1 to treat intensity as power (varies by rectangle area).\n#define VARY_LIGHT_INTENSITY 0\n\/\/ Set 1 to detect HDR range overflow.\n#define HDR_DETECTOR 0\n\/\/ HDR range maximum. (0 is minimum.)\n#define HDR_MAX 7.0\n\n\nstruct Material\n{\n    float roughness;\n    float tailamount;\n    float tailtheta;\n    float F0;\n    vec3 basecolor;\n  \tvec3 specularcolor;\n};\n\nstruct RectLight\n{\n    vec3 position;\n    mat3 basis;\n    vec2 size;\n    vec3 intensity;\n    float attenuation;\n};\n\nconst vec3 roomsize = vec3(15.0, 6.0, 15.0);\n    \nMaterial mat = Material(\n    0.163, \/\/ Roughness.\n    0.577, \/\/ Tail amount.\n    PI\/2.0\/3.0, \/\/ Specular cone tail theta angle.\n    0.0205, \/\/ Schlick Fresnel coefficient for zero viewing angle.\n    vec3(1.00), \/\/ Base color.\n   \tvec3(0.45) \/\/ Specular color.\n);\n\nRectLight light = RectLight(\n \tvec3(0.0, 6.0, -15.0), \/\/ Light position (center).\n \tmat3( \/\/ Light basis.\n    \t1.0, 0.0, 0.0,\n    \t0.0, 1.0, 0.0,\n    \t0.0, 0.0, 1.0\n\t),\n \tvec2(15.0, 0.6), \/\/ Light size.\n    vec3(42.0), \/\/ Light intensity.\n\t2.13 \/\/ Constant attenuation at 0 distance.\n);\n\n\nfloat sqr(float x) { return x*x; }\n\n\/\/ Approximate irradiance \"weight\" for a rectangular emitter.\n\/\/ Uses distance function to rectangle and a Gaussian standard\n\/\/ normal distribution (variance v^2 = 1\/2) to approximate the\n\/\/ illumination from the \"cone\". Result is weight in (0,1] in\n\/\/ units 1\/(m^2*sr). Parameter theta is the cone angle.\n\/\/ NOTE: Intersection of cone and plane is a conic, but here\n\/\/ distance to sphere is used. It's not accurate, particularly on\n\/\/ glazing angles.\nfloat RectLight_calcWeight(in vec3 P, in vec3 R, in RectLight light, float theta)\n{\n    \/\/ Intersect ray and light plane.\n    float RoPlN = dot(R, light.basis[2]);\n    float d = dot(light.basis[2], light.position - P) \/ RoPlN;\n    if (d < 0.0 || RoPlN > 0.0) {\n        \/\/ Intersection behind ray, or direction is away from plane.\n    \treturn 0.0;\n    }\n    \/\/ PlC: Point on plane.\n    vec3 PlC = P + d*R - light.position;\n    \/\/ uvPl: UV coordinate on plane.\n    vec2 PlUV = vec2(dot(PlC, light.basis[0]), dot(PlC, light.basis[1]));\n    \/\/ r: Radius of cone at distance d.\n    float r = d * tan(theta);\n    \/\/ s: Rect size shifted by radius. This for weigth 1 inside the rect.\n    vec2 s = max(light.size - 0.5*r, 0.0);\n    \/\/ h: Distance from rect on plane.\n    float h = length(max(abs(PlUV) - s, 0.0));\n    \/\/ sr: Steradians from the sphere cap equation: sr = 2pi * (1-cos(a))\n    float sr = 2.0*PI * (1.0 - cos(theta));\n    \/\/ This distribution f(x) has variance v^2 = 1\/2, hence\n    \/\/ v = (1\/2)^(1\/2) = 2^(-1\/2) = INVSQRT2. Using this we can\n    \/\/ linearly map h = [0,2r] -> x = [0,3v]. Why 3v is to cover\n    \/\/ approximately 100% of the distribution. \n    return exp(-sqr((3.0*INVSQRT2\/2.0) * (h\/r))) \/ (light.attenuation + sqr(d)*sr);\n}\n\n\/\/ TODO: No need to calculate Fresnel inside the function. Add as function param?\n\/\/ TODO: Combine specular and tail calculation into one? Use other distribution?\nvec3 RectLight_shade(in RectLight light, in Material material, in vec3 P, in vec3 N, in vec3 R, float NoR)\n{\n    \/\/ Schlick Fresnel.\n    float Fr = material.F0 + (1.0-material.F0) * pow(1.0 - NoR, 5.0);\n    \n    \/\/ Approximate specular\/glossy.\n    float theta = mix(PI*0.003, PI\/2.0\/3.0, material.roughness);\n    float Cs = RectLight_calcWeight(P, R, light, theta);\n    \/\/ Specular glossy tail. Using other than Gaussian could help. \n    float Cst = RectLight_calcWeight(P, R, light, material.tailtheta);\n    \n    \/\/ Crude hack for diffuse.\n    \/\/ Average normal and inversed emitter direction to create\n    \/\/ a vector W that points towards the light.\n    vec3 W = normalize(N - light.basis[2]);\n    float Cd = RectLight_calcWeight(P, W, light, PI\/4.0);\n\t\n    return light.intensity * mix(\n        (Cd * max(dot(N, W), 0.0)) * material.basecolor,\n        (mix(Cs, Cst, material.tailamount) * NoR) * material.specularcolor,\n        Fr);\n}\n\n\/\/ Simple tone mapping operation from Brian Karis.\n\/\/ Output range hard-coded to 1. Reference:\n\/\/ http:\/\/graphicrants.blogspot.ca\/2013\/12\/tone-mapping.html\nvec3 ToneMap(in vec3 c, float maxc)\n{\n#if HDR_DETECTOR\n    if (c.r > maxc || c.g > maxc || c.b > maxc) {\n    \treturn vec3(1.0, 0.0, 0.0);\n    } else if (c.r < 0.0 || c.g < 0.0 || c.b < 0.0) {\n    \treturn vec3(0.0, 1.0, 0.0);\n    }\n#endif\n   \tfloat v = max(c.r, max(c.g, c.b));\n    return c \/ (1.0 + v \/ maxc);\n}\n\nvec3 Tex3D(in vec3 P, in vec3 N, float s)\n{\n    P *= s;\n    mat3 tc = mat3(\n        texture2D(iChannel0, P.yz).rgb,\n        texture2D(iChannel0, P.xz).rgb,\n        texture2D(iChannel0, P.xy).rgb\n    );\n    N = pow(abs(N), vec3(16.0));\n    N = N \/ (N.x+N.y+N.z);\n    return pow(tc*N, vec3(2.2)); \/\/ Gamma decode.\n}\n\nfloat Map(in vec3 P)\n{\n    \/\/ Room walls.\n    vec3 t = roomsize - abs(vec3(P.x, P.y - roomsize.y, P.z));\n    float d = min(t.x, min(t.y, t.z));\n    \n    \/\/ Repeated sphere.\n    P.xz = mod(P.xz + vec2(0.0, -0.75), 4.0);\n    d = min(d, length(P - vec3(2.0, 3.25, 2.0)) - 1.2);\n    return d;\n}\n\nvec3 Gradient(in vec3 P)\n{\n    const vec3 d = vec3(0.05, 0.0, 0.0);\n    return vec3(\n        Map(P + d.xyy) - Map(P - d.xyy),\n        Map(P + d.yxy) - Map(P - d.yxy),\n        Map(P + d.yyx) - Map(P - d.yyx)\n    );\n}\n\nfloat March(in vec3 P, in vec3 D)\n{\n    float t = 0.01;\n    float m = 0.0;\n    for (int i = 0; i < 72; ++i) {\n        float d = Map(P + D*t);\n        if (d <= 0.008) {\n            break;\n        }\n        t += d + 0.004;\n    }\n    return t;\n}\n\nmat3 LookAt(in vec3 P, in vec3 focusP)\n{\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 dir = normalize(P - focusP);\n    vec3 left = normalize(cross(up, dir));\n    up = cross(dir, left);\n    return mat3(left, up, dir);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = (2.0*fragCoord.xy - iResolution.xy) \/ iResolution.xx;\n    float t = iGlobalTime;\n    \n    \/\/ Modify light.\n    light.size.x = 0.1 + 14.6*(0.5+0.5*sin(t));\n    light.size.y = 0.1 + 5.6*(0.5+0.5*cos(t));\n    \/\/light.position.z = -(0.5+0.5*sin(0.5*t))*roomsize.z;\n    \n#if VARY_LIGHT_INTENSITY\n    \/\/ A bit hacky. Assume intensity is power, so it's adjust by area.\n    light.intensity *= light.size.x*light.size.y \/ (13.0*4.0);\n#endif\n\n    \/\/ Camera position and basis.\n    vec2 a = vec2(0.25*t, 0.0);\n    if (iMouse.z > 0.0) {\n    \ta = (2.0*iMouse.xy\/iResolution.xy - 1.0);\n    \ta.x *= 0.5*PI;\n    }\n    vec3 camP = vec3(14.0*sin(a.x), roomsize.y * (1.0 + 0.8*a.y), 24.0*sqr(cos(a.x)) - 14.0);\n    mat3 camM = LookAt(camP, vec3(0.0, roomsize.y, 1.0-roomsize.z));\n    \n    \/\/ Cast ray and vignette.\n    vec3 D = INVSQRT2*(uv.x*camM[0] + uv.y*camM[1]) - camM[2];\n    vec3 P = camP + D;\n    D = normalize(D);\n    float vignette = 0.77 + 0.23*sqr(D.z);\n\n    \/\/ March for surface point.\n    float res = March(P, D);\n    P = P + res * D;\n    \n    \/\/ Normal and reflection vectors.\n    vec3 N = normalize(Gradient(P));\n    float NoR = -dot(N, D);\n    vec3 R = D + (2.0*NoR)*N;\n    NoR = max(NoR, 0.0);\n    \n    \/\/ Modify material.\n    vec3 texColor = Tex3D(P, N, 0.35);\n    float maxv = max(texColor.r, max(texColor.g, texColor.b));\n    mat.basecolor = min(0.33+maxv, 1.0) * vec3(1.0, 0.53, 0.32);\n    \/\/mat.roughness = res.y;\n    \n    vec3 C = vec3(0.0);\n    if (P.z <= -roomsize.z+0.15) {\n        if (abs(P.y-light.position.y) < light.size.y\n            \t&& abs(P.x-light.position.x) < light.size.x) {\n    \t\tC = vec3(HDR_MAX);\n        } else {\n            C = vec3(0.0);\n        }\n    } else {\n    \tC = RectLight_shade(light, mat, P, N, R, NoR);\n    }\n    \n    C = C * vignette;\n    C = ToneMap(C, HDR_MAX);\n    C = pow(C, vec3(1.0\/2.2)); \/\/ Gamma encode.\n\tfragColor = vec4(C, 1.0);\n}\n\n","name":"","description":"","type":"image"}]}}