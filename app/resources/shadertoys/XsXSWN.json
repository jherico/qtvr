{"Shader":{"ver":"0.1","info":{"id":"XsXSWN","date":"1400884539","viewed":1466,"name":"Cheesy","username":"P_Malin","description":"A very cheesy raytracing (not raymarching!) shader.<br\/>Raytracing with CSG, bump mapping, shiny things and cheese!<br\/>(I don't know why)","likes":20,"published":3,"flags":0,"tags":["raytracing","csg","cheese"],"hasliked":0},"renderpass":[{"inputs":[{"id":1,"src":"\/presets\/tex00.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":22,"src":"\/presets\/cube00_0.jpg","ctype":"cubemap","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"id":23,"src":"\/presets\/cube01_0.png","ctype":"cubemap","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Cheesy - @P_Malin\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/\n\/\/ A very cheesy raytracing (not raymarching!) shader.\n\/\/ Raytracing with CSG, bump mapping, shiny things and cheese!\n\/\/ (I don't know why)\n \n#define kIterations 2\n\nfloat kFarClip=1000.0;\nfloat kNearClip = 0.001;\n\nvec2 GetWindowCoord( const in vec2 vUV );\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget );\nvec3 GetSceneColour( in vec3 vRayOrigin,  in vec3 vRayDir );\nvec3 ApplyPostFX( const in vec2 vUV, const in vec3 vInput );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vUV = fragCoord.xy \/ iResolution.xy;\n\n\tvec2 vMouse = iMouse.xy \/ iResolution.xy;\t\n\n\tif(iMouse.z <= 0.0)\n\t{\n\t\tvMouse = vec2(0.37, 0.56);\n\t}\n\t\n\tfloat fAngle = vMouse.x * 2.0 * 3.14;\n\tconst float fDist = 14.0;\n\tvec3 vCameraPos = vec3(sin(fAngle) * fDist, vMouse.y * fDist - 1.5, cos(fAngle) * fDist);\n\tvec3 vCameraTarget = vec3(0.0, 0.0, 0.0);\n\t\n\tvec3 vRayOrigin = vCameraPos;\n\tvec3 vRayDir = GetCameraRayDir( GetWindowCoord(vUV), vCameraPos, vCameraTarget );\n\t\n\tvec3 vResult = GetSceneColour(vRayOrigin, vRayDir);\n\t\n\tvec3 vFinal = ApplyPostFX( vUV, vResult );\n\t\n\t\/\/ super contrast\n\t\/\/vFinal = vFinal * 1.1 - 0.1;\n\t\n\tfragColor = vec4(vFinal, 1.0);\n}\n\n\/\/ CAMERA\n\nvec2 GetWindowCoord( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x \/ iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget )\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\t\t\t\t\t\t  \n\tconst float fFov = 3.0;\n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fFov);\n\n\treturn vDir;\n}\n\n\/\/ POSTFX\n\nvec3 ApplyVignetting( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0);\n\t\n\tfloat fDist = dot(vOffset, vOffset);\n\t\n\tconst float kStrength = 0.5;\n\t\n\tfloat fShade = mix( 1.0, 1.0 - kStrength, fDist );\t\n\n\treturn vInput * fShade;\n}\n\nvec3 ApplyTonemap( const in vec3 vLinear )\n{\n\tconst float kExposure = 1.0;\n\t\n\treturn 1.0 - exp2(vLinear * -kExposure);\t\n}\n\nvec3 ApplyGamma( const in vec3 vLinear )\n{\n\tconst float kGamma = 2.2;\n\n\treturn pow(vLinear, vec3(1.0\/kGamma));\t\n}\n\nvec3 ApplyPostFX( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec3 vTemp = ApplyVignetting( vUV, vInput );\t\n\t\n\tvTemp = ApplyTonemap(vTemp);\n\t\n\treturn ApplyGamma(vTemp);\t\t\n}\n\t\n\/\/ RAYTRACE\n\nstruct C_Intersection\n{\n\tvec3 vPos;\n\tfloat fDist;\t\n\tvec3 vNormal;\n\tvec3 vUVW;\n\tfloat fObjectId;\n};\n\nstruct C_SpanIntersection\n{\n\tvec3 vNormal;\n\tfloat fDist;\t\n\tfloat fObjectId;\n};\n\t\nstruct C_Span\n{\n\tC_SpanIntersection iMin;\n\tC_SpanIntersection iMax;\t\n};\n\t\n#define INVALID_SPAN( S ) (S.iMin.fDist >= S.iMax.fDist)\n\nvoid SetupNullSpan( out C_Span span )\n{\n\tspan.iMin.fDist = kFarClip;\n\tspan.iMin.vNormal = vec3(0.0, 1.0, 0.0);\n\tspan.iMin.fObjectId = 0.0;\n\t\n\tspan.iMax.fDist = -kFarClip;\n\tspan.iMax.vNormal = vec3(0.0, 1.0, 0.0);\n\tspan.iMax.fObjectId = 0.0;\t\t\n}\n\n\nvoid TraceFloor( out C_Span span, const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fFloorHeight, const in float fObjectId )\n{\n\tSetupNullSpan(span);\n\t\t\n\tif(vRayDir.y < 0.0)\n\t{\n\t\tfloat fDh = vRayOrigin.y - fFloorHeight;\n\t\tfloat t = -fDh \/ vRayDir.y;\n\t\t\n\t\tspan.iMin.fDist = t;\n\t\tspan.iMin.vNormal = vec3(0.0, 1.0, 0.0);\n\t\tspan.iMin.fObjectId = fObjectId;\n\n\t\tspan.iMax.fDist = kFarClip;\n\t\tspan.iMax.vNormal = vec3(0.0, -1.0, 0.0);\n\t\tspan.iMax.fObjectId = fObjectId;\t\t\n\t}\n}\n\nvoid TracePlane( out C_Span span, const in vec3 vRayOrigin, const in vec3 vRayDir, vec3 vPlaneNormal, float fPlaneDist, float fObjectId )\n{\n\tSetupNullSpan(span);\n\n\tfloat fStartDist = dot(vRayOrigin, vPlaneNormal) - fPlaneDist;\n\tfloat fDeltaDist = dot(vRayDir, vPlaneNormal);\n\t\n\tif(fStartDist > kNearClip)\n\t{\n\t\t\/\/ if looking towards the plane\n\t\tif(fDeltaDist < 0.0)\n\t\t{\n\t\t\tfloat t = -fStartDist \/ fDeltaDist;\n\t\t\tif(t > -kNearClip)\n\t\t\t{\n\t\t\t\tspan.iMin.fDist = t;\n\t\t\t\tspan.iMin.vNormal = vPlaneNormal;\n\t\t\t\tspan.iMin.fObjectId = fObjectId;\n\t\t\t\t\n\t\t\t\tspan.iMax.fDist = kFarClip;\n\t\t\t\tspan.iMax.vNormal = vRayDir;\n\t\t\t\tspan.iMax.fObjectId = fObjectId;\t\t\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\t\t\n\t\tspan.iMin.fDist = kNearClip;\n\t\tspan.iMin.vNormal = -vRayDir;\n\t\tspan.iMin.fObjectId = fObjectId;\t\t\n\t\t\n\t\tspan.iMax.fDist = kFarClip;\n\t\tspan.iMax.vNormal = vRayDir;\n\t\tspan.iMax.fObjectId = fObjectId;\n\t\t\n\t\t\/\/ if looking towards the plane\t\t\n\t\tif(fDeltaDist > 0.0)\n\t\t{\t\t\n\t\t\tfloat t = -fStartDist \/ fDeltaDist;\n\t\t\t\n\t\t\tif(t > -kNearClip)\n\t\t\t{\n\t\t\t\tspan.iMin.fDist = kNearClip;\n\t\t\t\tspan.iMin.vNormal = -vRayDir;\n\t\t\t\tspan.iMin.fObjectId = fObjectId;\t\t\t\t\t\n\t\t\t\t\n\t\t\t\tspan.iMax.fDist = t;\n\t\t\t\tspan.iMax.vNormal = -vPlaneNormal;\n\t\t\t\tspan.iMax.fObjectId = fObjectId;\t\n\t\t\t}\t\t\n\t\t}\t\t\n\t}\n}\n\nvoid TraceSphere( out C_Span span, const in vec3 vRayOrigin, const in vec3 vRayDir, const in vec3 vSphereOrigin, const in float fSphereRadius, const in float fObjectId )\n{\t\n\tSetupNullSpan(span);\n\t\n\tvec3 vToOrigin = vSphereOrigin - vRayOrigin;\n\tfloat fProjection = dot(vToOrigin, vRayDir);\n\tvec3 vClosest = vRayOrigin + vRayDir * fProjection;\n\t\n\tvec3 vClosestToOrigin = vClosest - vSphereOrigin;\n\tfloat fClosestDist2 = dot(vClosestToOrigin, vClosestToOrigin);\n\n\tfloat fSphereRadius2 = fSphereRadius * fSphereRadius;\n\t\n\tif(fClosestDist2 < fSphereRadius2)\n\t{\n\t\tfloat fHCL = sqrt(fSphereRadius2 - fClosestDist2);\n\n\t\tfloat fMinDist = clamp(fProjection - fHCL, kNearClip, kFarClip);\n\t\tfloat fMaxDist = fProjection + fHCL;\n\t\t\n\t\tif(fMaxDist > fMinDist)\n\t\t{\t\t\t\n\t\t\tspan.iMin.fDist = fMinDist;\n\t\t\tvec3 vMinPos = vRayOrigin + vRayDir * span.iMin.fDist;\n\t\t\tspan.iMin.vNormal = normalize(vMinPos - vSphereOrigin);\n\t\t\tspan.iMin.fObjectId = fObjectId;\n\t\n\t\t\tspan.iMax.fDist = fMaxDist;\n\t\t\tvec3 vMaxPos = vRayOrigin + vRayDir * span.iMax.fDist;\n\t\t\tspan.iMax.vNormal = normalize(vMaxPos - vSphereOrigin);\n\t\t\tspan.iMax.fObjectId = fObjectId;\n\t\t}\n\t}\n}\n\n\nvec3 Project( vec3 a, vec3 b )\n{\n\treturn a - b * dot(a, b);\n}\n\nvoid TraceCylinder( out C_Span span, const in vec3 vRayOrigin, const in vec3 vRayDir, const in vec3 vCylinderOrigin, const in vec3 vCylinderDir, const in float fCylinderRadius, const in float fObjectId )\n{\t\n\tSetupNullSpan(span);\n\t\n\tvec3 vOffset = vCylinderOrigin - vRayOrigin;\n\t\n\tvec3 vProjOffset = Project(vOffset, vCylinderDir);\n\tvec3 vProjDir = Project(vRayDir, vCylinderDir);\n\tfloat fProjScale = length(vProjDir);\n\tvProjDir \/= fProjScale;\n\t\n\t\/\/ intersect circle in projected space\n\t\n\tfloat fTClosest = dot(vProjOffset, vProjDir);\n\t\n\tvec3 vClosest = vProjDir * fTClosest;\n\tfloat fDistClosest = length(vClosest - vProjOffset);\n\tif(fDistClosest < fCylinderRadius)\n\t{\t\t\n\t\tfloat fHalfChordLength = sqrt(fCylinderRadius * fCylinderRadius - fDistClosest * fDistClosest);\n\t\tfloat fTIntersectMin = clamp((fTClosest - fHalfChordLength) \/ fProjScale, kNearClip, kFarClip);\n\t\tfloat fTIntersectMax = (fTClosest + fHalfChordLength) \/ fProjScale;\t\n\t\t\n\t\tif(fTIntersectMax > fTIntersectMin)\n\t\t{\t\n\t\t\tspan.iMin.fDist = fTIntersectMin;\n\t\t\tspan.iMin.vNormal = normalize(vProjDir * (fTClosest - fHalfChordLength) - vProjOffset );\n\t\t\tspan.iMin.fObjectId = fObjectId;\n\t\n\t\t\tspan.iMax.fDist = fTIntersectMax;\n\t\t\tspan.iMax.vNormal = normalize(vProjDir * (fTClosest + fHalfChordLength) - vProjOffset );\n\t\t\tspan.iMax.fObjectId = fObjectId;\t\t\t\t\t\t\n\t\t}\t\t\n\t}\n}\n\nvoid SpanUnion(out C_Span resultSpan, const in C_Span spanA, const in C_Span spanB)\n{\t\n\t\/\/ B is invalid\n\tif(INVALID_SPAN(spanB))\n\t{\n\t\tif(INVALID_SPAN(spanA))\n\t\t{\n\t\t\tSetupNullSpan(resultSpan);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresultSpan = spanA;\n\t\t}\n\t}\n\telse\n\t\/\/ A is invalid\n\tif(spanA.iMin.fDist >= spanA.iMax.fDist)\n\t{\n\t\tresultSpan = spanB;\n\t}\n\telse\n\t{\n\t\tif(spanA.iMin.fDist < spanB.iMin.fDist)\n\t\t{\n\t\t\tresultSpan.iMin = spanA.iMin;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresultSpan.iMin = spanB.iMin;\n\t\t}\n\t\t\n\t\tif(spanA.iMax.fDist > spanB.iMax.fDist)\n\t\t{\n\t\t\tresultSpan.iMax = spanA.iMax;\n\t\t}\t\n\t\telse\n\t\t{\n\t\t\tresultSpan.iMax = spanB.iMax;\t\t\t\n\t\t}\n\t}\n}\n\nvoid SpanIntersect(out C_Span resultSpan, const in C_Span spanA, const in C_Span spanB)\n{\t\n\tSetupNullSpan( resultSpan );\n\t\n\tif(spanA.iMin.fDist > spanB.iMin.fDist)\n\t{\n\t\tresultSpan.iMin = spanA.iMin;\n\t}\n\telse\n\t{\n\t\tresultSpan.iMin = spanB.iMin;\n\t}\n\n\tif(spanA.iMax.fDist < spanB.iMax.fDist)\n\t{\n\t\tresultSpan.iMax = spanA.iMax;\n\t}\n\telse\n\t{\n\t\tresultSpan.iMax = spanB.iMax;\n\t}\n}\n\nvoid SpanSubtract(out C_Span resultSpan, const in C_Span spanA, const in C_Span spanB)\n{\t\n\tSetupNullSpan( resultSpan );\n\n\t\/\/ a is invalid\n\tif(INVALID_SPAN(spanA))\n\t{\n\t\treturn;\n\t}\t\n\n\t\/\/ b is invalid\n\tif(INVALID_SPAN(spanB))\n\t{\n\t\tresultSpan = spanA;\n\t\treturn;\n\t}\n\t\n\t{\t\t\t\t\t\t\n\t\t\/\/ if we enter A before B\n\t\tif(spanA.iMin.fDist < spanB.iMin.fDist)\n\t\t{\n\t\t\t\/\/ if A completely infront of B\n\t\t\tif(spanA.iMax.fDist < spanB.iMin.fDist)\n\t\t\t{\n\t\t\t\t\/\/ AAAAA \n\t\t\t\t\/\/        BBBB\n\t\t\t\t\/\/ RRRRR\n\t\t\t\tresultSpan = spanA;\n\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(spanA.iMax.fDist < spanB.iMax.fDist)\n\t\t\t\t{\n\t\t\t\t\t\/\/ AAAAA\n\t\t\t\t\t\/\/    BBBBBBB\n\t\t\t\t\t\/\/ RRR\t\t\t\t\n\t\t\t\t\tresultSpan.iMin = spanA.iMin;\n\t\t\t\t\tresultSpan.iMax = spanB.iMin;\n\t\t\t\t\tresultSpan.iMax.vNormal = -resultSpan.iMax.vNormal;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t\/\/ AAAAAAAAAAAAA\n\t\t\t\t\t\/\/    BBBBBBB\n\t\t\t\t\t\/\/ RRR\t\t RRR\n\t\t\t\t\t\n\t\t\t\t\tresultSpan.iMin = spanA.iMin;\n\t\t\t\t\t\/\/ we need to choose the result here, really we should produce two spans\n\t\t\t\t\tif(false)\n\t\t\t\t\t{\n\t\t\t\t\t\tresultSpan.iMax = spanA.iMax;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tresultSpan.iMax = spanB.iMin;\n\t\t\t\t\t\tresultSpan.iMax.vNormal = -resultSpan.iMax.vNormal;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\t\t\t\n\t\t}\n\t\t\/\/ else we enter B before A\n\t\telse\t\t\n\t\t\/\/ if B completely infront of A\n\t\tif(spanB.iMax.fDist < spanA.iMin.fDist)\n\t\t{\n\t\t\t\/\/   \t\t   AAAAAA\n\t\t\t\/\/   BBBBBBB\n\t\t\t\/\/\t\t       RRRRRR\n\t\t\tresultSpan = spanA;\t\t\t\n\t\t}\n\t\telse\n\t\t\/\/ if we leave B before A, select B max\n\t\tif(spanB.iMax.fDist < spanA.iMax.fDist)\n\t\t{\n\t\t\t\/\/        AAAAAA\n\t\t\t\/\/    BBBBBBB\n\t\t\t\/\/\t\t     RRR\n\t\t\tresultSpan.iMin = spanB.iMax;\n\t\t\t\/\/ negate normal\n\t\t\tresultSpan.iMin.vNormal = -resultSpan.iMin.vNormal;\n\t\t\t\n\t\t\tresultSpan.iMax = spanA.iMax;\n\t\t}\n\t\t\/\/ else we leave A before B\n\t\telse\n\t\t{\n\t\t\t\/\/        AAAAAA\n\t\t\t\/\/    BBBBBBBBBBBB\n\t\t\t\/\/\t\t    \n\t\t}\n\t}\t\n}\n\n\nvoid TraceCappedCylinder( out C_Span span, const in vec3 vRayOrigin, const in vec3 vRayDir, const in vec3 vPos, const in float fRadius, const in float fObjectId )\n{\n\tconst vec3 vUp = vec3(0.0, 1.0, 0.0);\n\t\n\tC_Span cylinderSpan;\n\tTraceCylinder( cylinderSpan, vRayOrigin, vRayDir, vPos, vUp, fRadius, fObjectId );\n\n\tC_Span planeSpan;\n\tTracePlane( planeSpan, vRayOrigin, vRayDir, vUp, vPos.y, fObjectId );\n\t\n\tSpanIntersect(span, cylinderSpan, planeSpan);\n}\n\nconst vec3 vCheesePointA = vec3(0.0, -0.8, -2.0);\nconst vec3 vCheesePointA1 = vec3(0.0, 1.5, -2.0);\nconst vec3 vCheesePointB = vec3(1.5, 1.5, 2.0);\nconst vec3 vCheesePointC = vec3(-1.5, 1.5, 2.0);\n\nvoid TraceCheese( out C_Span span, const in vec3 vRayOrigin, const in vec3 vRayDir )\n{\n\tconst float fCheeseObjectId = 3.0;\n\tconst float fRindObjectId = 4.0;\t\n\n\tvec3 vPlaneANormal = normalize(cross(vCheesePointA1 - vCheesePointA, vCheesePointB - vCheesePointA));\n\tfloat fPlaneADist = dot(vCheesePointA, vPlaneANormal);\n\t\n\tvec3 vPlaneBNormal = -normalize(cross(vCheesePointA1 - vCheesePointA, vCheesePointC - vCheesePointA));\n\tfloat fPlaneBDist = dot(vCheesePointA, vPlaneBNormal);\n\t\n\tC_Span planeASpan;\n\tTracePlane( planeASpan, vRayOrigin, vRayDir, vPlaneANormal, fPlaneADist, fCheeseObjectId );\n\n\tC_Span planeBSpan;\n\tTracePlane( planeBSpan, vRayOrigin, vRayDir, vPlaneBNormal, fPlaneBDist, fCheeseObjectId );\n\tSpanIntersect(span, planeASpan, planeBSpan);\n\n\tC_Span planeTopSpan;\n\tTracePlane( planeTopSpan, vRayOrigin, vRayDir, vec3(0.0, 1.0, 0.0), vCheesePointA1.y, fCheeseObjectId );\t\n\tSpanIntersect(span, span, planeTopSpan);\n\t\n\tvec3 vSphereCentre = (vCheesePointA + vCheesePointA1) * 0.5;\n\tfloat fSphereRadius = length(vCheesePointA - vCheesePointB);\n\tC_Span sphereSpan;\n\tTraceSphere( sphereSpan, vRayOrigin, vRayDir, vSphereCentre, fSphereRadius, fRindObjectId );\n\tSpanIntersect(span, span, sphereSpan);\t\n\t\n\t\/\/if(false)\n\t{\n\t\tconst float fRepeat = 1.0;\n\t\tvec3 vPos = vRayOrigin + vRayDir * span.iMin.fDist;\n\t\tvec3 vHoleFract = mod(vPos, fRepeat);\n\t\tvec3 vHoleDiv = vPos - vHoleFract;\n\t\tfloat fRandom = fract(sin(vHoleDiv.x * 123.45 + vHoleDiv.y * 234.56 + vHoleDiv.z * 345.67));\n\t\tfloat fHoleSize = 0.1 + fRandom * 0.2;\n\t\tvec3 vRandomOffset = 0.5 + vec3(sin(fRandom * 12.34), sin(fRandom * 23.45), sin(fRandom * 34.56)) * 0.5;\n\t\tvec3 vHolePos = vHoleDiv + (fHoleSize + vRandomOffset * (1.0 - fHoleSize * 2.0)) * fRepeat;\n\n\t\t\/\/ no holes near rind\n\t\tif(length(vHolePos - vSphereCentre) < (fSphereRadius - fHoleSize * fRepeat))\n\t\t{\t\t\n\t\t\tC_Span holeSpan;\n\t\t\tTraceSphere( holeSpan, vRayOrigin,  vRayDir, vHolePos, fHoleSize * fRepeat, fCheeseObjectId);\t\n\t\t\t\n\t\t\tSpanSubtract( span, span, holeSpan );\n\t\t}\n\t}\n}\n\nvoid TraceTray( out C_Span span, const in vec3 vRayOrigin, const in vec3 vRayDir )\n{\n\tconst vec3 vPos = vec3(0.0, -0.8, 0.0);\n\tconst float fRadius = 5.0;\n\tconst vec3 vUp = vec3(0.0, 1.0, 0.0);\n\t\n\tC_Span cylinderSpan;\n\tTraceCylinder( cylinderSpan, vRayOrigin, vRayDir, vPos, vUp, fRadius, 5.0 );\n\n\tC_Span planeSpan;\n\tTracePlane( planeSpan, vRayOrigin, vRayDir, vUp, vPos.y, 5.0 );\n\tSpanIntersect(span, cylinderSpan, planeSpan);\n}\n\nvoid TraceCloche( out C_Span span, const in vec3 vRayOrigin, const in vec3 vRayDir )\n{\n\tSetupNullSpan(span);\n\n\tfloat fBlend = clamp((iGlobalTime - 3.0) * 0.5, 0.0, 1.0);\n\t\n\tif(iGlobalTime==10.0) fBlend = 0.0;\n\t\n\tconst vec3 vSphereOrigin1 = vec3(-5.5, -2.0, 5.0);\n\tconst vec3 vSphereOrigin2 = vec3(0.0, -1.8, 0.0);\n\tconst float fSphereRadius = 4.5;\n\tconst float fSphereRadius2 = 0.3;\n\t\n\tvec3 vSphereOrigin = mix(vSphereOrigin2, vSphereOrigin1, sqrt(fBlend));\n\tvSphereOrigin.y += (fBlend * fBlend - fBlend) * -18.0;\n\tvec3 vDir = normalize(vSphereOrigin + vec3(0.0, 50.0, 0.0));\n\t\n\tC_Span sphereSpan;\n\tTraceSphere( sphereSpan, vRayOrigin,  vRayDir, vSphereOrigin, fSphereRadius, 5.0);\t\n\tSpanUnion( span, span, sphereSpan );\n\n\tTraceSphere( sphereSpan, vRayOrigin,  vRayDir, vSphereOrigin - vDir * 0.1, fSphereRadius + 0.02, 5.0);\t\n\tSpanSubtract( span, span, sphereSpan );\n\n\tTraceSphere( sphereSpan, vRayOrigin,  vRayDir, vSphereOrigin + vDir * (fSphereRadius + fSphereRadius2), fSphereRadius2, 5.0);\t\n\tSpanUnion( span, span, sphereSpan );\n\t\n}\n\nvoid TraceScene( out C_Intersection outIntersection, const in vec3 vRayOrigin,  const in vec3 vRayDir )\n{\n\tC_Span span;\n\t\n\tSetupNullSpan(span);\n\t\n\tC_Span pedistalSpan;\n\tTraceCappedCylinder( pedistalSpan, vRayOrigin, vRayDir, vec3(0.0, -1.0, 0.0), 8.0, 1.0 );\n\tSpanUnion( span, span, pedistalSpan );\n\t\n\t\n\tC_Span boardSpan;\n\tTraceTray( boardSpan, vRayOrigin, vRayDir );\n\t\/\/TraceCappedCylinder( boardSpan, vRayOrigin, vRayDir, vec3(0.0, -0.8, 0.0), 5.0, 5.0 );\t\n\tSpanUnion( span, span, boardSpan );\t\n\t\n\tC_Span cheeseSpan;\n\tTraceCheese( cheeseSpan, vRayOrigin, vRayDir );\n\tSpanUnion( span, span, cheeseSpan );\n\t\n\tC_Span clocheSpan;\n\tTraceCloche( clocheSpan, vRayOrigin,  vRayDir );\t\n\tSpanUnion( span, span, clocheSpan );\n\t\t\n\toutIntersection.vPos = vRayOrigin + vRayDir * span.iMin.fDist;\n\toutIntersection.fDist = span.iMin.fDist;\n\toutIntersection.vNormal = span.iMin.vNormal;\n\tif(abs(outIntersection.vNormal.y) > 0.3)\n\t{\n\t\toutIntersection.vUVW = outIntersection.vPos.xzy;\n\t}\n\telse\n\t{\n\t\toutIntersection.vUVW = outIntersection.vPos.xyx;\n\t}\n\toutIntersection.fObjectId = span.iMin.fObjectId;\n}\n\nfloat TraceShadow( const in vec3 vOrigin, const in vec3 vDir, const in float fDist )\n{\n\tC_Intersection shadowIntersection;\n\tTraceScene(shadowIntersection, vOrigin, vDir);\n\tif(shadowIntersection.fObjectId != 0.0)\n\t{\n\t\tif(shadowIntersection.fDist < fDist)\n\t\t{\n\t\t\treturn 0.0;\t\t\n\t\t}\n\t}\n\t\n\treturn 1.0;\n}\n\n\/\/ LIGHTING\n\nvoid AddLighting(inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightColour)\n{\n\tfloat fNDotL = clamp(dot(vLightDir, vNormal), 0.0, 1.0);\n\t\n\tvDiffuseLight += vLightColour * fNDotL;\n\t\n\tvec3 vHalfAngle = normalize(-vViewDir + vLightDir);\n\tfloat fSpecularPower = exp2(4.0 + 6.0 * fSmoothness);\n\tfloat fSpecularIntensity = (fSpecularPower + 2.0) * 0.125;\n\tvSpecularLight += vLightColour * fSpecularIntensity * clamp(pow(dot(vHalfAngle, vNormal), fSpecularPower), 0.0, 1.0) * fNDotL;\n}\n\nvoid AddPointLight(inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vPos, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightPos, const in vec3 vLightColour)\n{\n\tvec3 vToLight = vLightPos - vPos;\t\n\tfloat fDistance2 = dot(vToLight, vToLight);\n\tfloat fAttenuation = 100.0 \/ (fDistance2);\n\tvec3 vLightDir = normalize(vToLight);\n\t\n\tvec3 vShadowRayDir = vLightDir;\n\tvec3 vShadowRayOrigin = vPos + vShadowRayDir * 0.01;\n\n\tfloat fShadowFactor = TraceShadow(vShadowRayOrigin, vShadowRayDir, length(vToLight));\n\t\n\tAddLighting(vDiffuseLight, vSpecularLight, vViewDir, vLightDir, vNormal, fSmoothness, vLightColour * fShadowFactor * fAttenuation);\n}\n\nvoid AddPointLightFlare(inout vec3 vEmissiveGlow, const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fIntersectDistance, const in vec3 vLightPos, const in vec3 vLightColour, const in float fInvSpread)\n{\n    vec3 vToLight = vLightPos - vRayOrigin;\n    float fPointDot = dot(vToLight, vRayDir);\n    fPointDot = clamp(fPointDot \/ (max(fInvSpread,0.01)), 0.0, fIntersectDistance);\n\n    vec3 vClosestPoint = vRayOrigin + vRayDir * fPointDot;\n    float fDist = length(vClosestPoint - vLightPos);\n\tvEmissiveGlow += (vLightColour * 1.0 \/ (fDist * fDist));\n}\n\nvoid AddDirectionalLight(inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vPos, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightDir, const in vec3 vLightColour)\n{\t\n\tconst float fAttenuation = 1.0;\n\n\tvec3 vShadowRayDir = -vLightDir;\n\tvec3 vShadowRayOrigin = vPos + vShadowRayDir * 0.01;\n\n\tfloat fShadowFactor = TraceShadow(vShadowRayOrigin, vShadowRayDir, 10.0);\n\t\n\tAddLighting(vDiffuseLight, vSpecularLight, vViewDir, -vLightDir, vNormal, fSmoothness, vLightColour * fShadowFactor * fAttenuation);\t\n}\n\nvoid AddDirectionalLightFlareToFog(inout vec3 vFogColour, const in vec3 vRayDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fDirDot = clamp(dot(-vLightDir, vRayDir), 0.0, 1.0);\n\tconst float kSpreadPower = 4.0;\n\tvFogColour += vLightColour * pow(fDirDot, kSpreadPower) * 4.0;\t\n}\n\n\/\/ SCENE MATERIALS\n\nvoid GetSurfaceInfo(out vec3 vOutAlbedo, out vec3 vOutR0, out float fOutSmoothness, out vec3 vOutBumpNormal, const in C_Intersection intersection )\n{\n\tvOutBumpNormal = intersection.vNormal;\n\t\n\tif(intersection.fObjectId == 1.0)\n\t{\n\t\tvec2 vUV = intersection.vUVW.xy*0.1;\/\/ + vec2(iGlobalTime * 0.5, 0.0);\n\t\tvOutAlbedo = texture2D(iChannel0, vUV).rgb;\n\t\tfloat fBumpScale = 1.0;\n\t\t\n\t\tvec2 vRes = iChannelResolution[0].xy;\n\t\tvec2 vDU = vec2(1.0, 0.0) \/ vRes;\n\t\tvec2 vDV = vec2(0.0, 1.0) \/ vRes;\n\t\t\n\t\tfloat fSampleW = texture2D(iChannel0, vUV - vDU).r;\n\t\tfloat fSampleE = texture2D(iChannel0, vUV + vDU).r;\n\t\tfloat fSampleN = texture2D(iChannel0, vUV - vDV).r;\n\t\tfloat fSampleS = texture2D(iChannel0, vUV + vDV).r;\n\t\t\n\t\tvec3 vNormalDelta = vec3(0.0);\n\t\tvNormalDelta.x += \n\t\t\t( fSampleW * fSampleW\n\t\t\t - fSampleE * fSampleE) * fBumpScale;\n\t\tvNormalDelta.z += \n\t\t\t(fSampleN * fSampleN\n\t\t\t - fSampleS * fSampleS) * fBumpScale;\n\t\t\n\t\tvOutBumpNormal = normalize(vOutBumpNormal + vNormalDelta);\n\n\t\tvOutAlbedo = vOutAlbedo * vOutAlbedo;\t\n\n\t\tfOutSmoothness = vOutAlbedo.r * 0.7;\/\/\n\t\t\n\t\tvOutR0 = vec3(0.25) * vOutAlbedo.r;\n\t}\n\telse if(intersection.fObjectId == 3.0)\n\t{\n\t\tvOutAlbedo = vec3(0.7, 0.6, 0.3);\n\t\tfOutSmoothness = 0.05;\t\n\t\tvOutR0 = vec3(0.01);\n\t}\n\telse if(intersection.fObjectId == 4.0)\n\t{\n\t\tvOutAlbedo = vec3(0.7, 0.6, 0.3);\n\t\tfOutSmoothness = 0.0;\t\n\t\tvOutR0 = vec3(0.01);\n\t}\n\telse if(intersection.fObjectId == 5.0)\n\t{\n\t\tvOutAlbedo = vec3(0.1);\n\t\tfOutSmoothness = 0.9;\t\n\t\tvOutR0 = vec3(0.25, 0.28, 0.3);\n\t}\n}\n\nvec3 GetSkyColour( const in vec3 vDir, const in float fInvSpread )\n{\n\tvec3 vResult = vec3(0.0);\n\t\n\tif(false)\n\t{\n\t\tvResult = mix(vec3(1.5, 2.5, 4.0), vec3(3.0, 5.0, 8.0), abs(vDir.y));\n\t}\n\telse\n\t{\n\t\tfloat kEnvmapExposure = 0.5;\t\t\n\t\t\n\t\tvec3 vEnvMap = textureCube(iChannel2, vDir).rgb;\n\t\tvEnvMap = vEnvMap * vEnvMap;\n\t\tvEnvMap = log2(1.0 - min(vEnvMap, 0.99)) \/ -kEnvmapExposure;\n\n\t\tvec3 vEnvMap2 = textureCube(iChannel3, vDir).rgb;\n\t\tvEnvMap2 = vEnvMap2 * vEnvMap2;\n\t\tvEnvMap2 = log2(1.0 - min(vEnvMap2, 0.99)) \/ -kEnvmapExposure;\n\t\t\n\t\tvResult = mix(vEnvMap2, vEnvMap, fInvSpread);\n\t}\n\t\n\treturn vResult;\t\n}\n\nfloat GetFogFactor(const in float fDist)\n{\n\tconst float kFogDensity = 0.0005;\n\treturn exp(fDist * -kFogDensity);\t\n}\n\nvec3 GetFogColour(const in vec3 vDir)\n{\n\tconst vec3 vResult = vec3(0.4);\n\t\n\treturn vResult;\t\t\n}\n\nconst vec3 vSunLightColour = vec3(1.0, 0.9, 0.6) * 2.0;\nvec3 vSunLightDir = normalize(vec3(0.4, -0.3, 0.05));\n\nconst vec3 vLightPos = vec3(5.0, 2.5, 3.0);\t\t\t\nconst vec3 vLightColour = vec3(0.6, 0.8, 1.0);\n\nvoid ApplyAtmosphere(inout vec3 vColour, const in float fDist, const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fInvSpread)\n{\t\t\n\tfloat fFogFactor = GetFogFactor(fDist);\n\tvec3 vFogColour = GetFogColour(vRayDir);\t\t\t\n\tAddDirectionalLightFlareToFog(vFogColour, vRayDir, vSunLightDir, vSunLightColour);\n\t\n\tvec3 vGlow = vec3(0.0);\n\tAddPointLightFlare(vGlow, vRayOrigin, vRayDir, fDist, vLightPos, vLightColour, fInvSpread);\t\t\t\t\t\n\t\n\tvColour = mix(vFogColour, vColour, fFogFactor) + vGlow;\t\n}\n\n\/\/ TRACING LOOP\n\nvec3 GetSceneColour( in vec3 vRayOrigin,  in vec3 vRayDir )\n{\n\tvec3 vColour = vec3(0.0);\n\tvec3 vRemaining = vec3(1.0);\n\t\n\tfloat fInvSpread = 1.0;\t\n\t\n\tfor(int i=0; i<kIterations; i++)\n\t{\t\n\t\tfloat fShouldApply = 1.0;\n\t\tvec3 vCurrRemaining = vRemaining;\n\t\t\n\t\tC_Intersection intersection;\n\t\tTraceScene( intersection, vRayOrigin, vRayDir );\n\n\t\tvec3 vResult = vec3(0.0);\n\t\tvec3 vBlendFactor = vec3(0.0);\n\t\t\t\t\t\t\n\t\tif(intersection.fObjectId == 0.0)\n\t\t{\n\t\t\tvBlendFactor = vec3(1.0);\n\t\t\tfShouldApply = 0.0;\n\t\t}\n\t\telse\n\t\t{\t\t\n\t\t\tvec3 vAlbedo;\n\t\t\tvec3 vR0;\n\t\t\tfloat fSmoothness;\n\t\t\tvec3 vBumpNormal;\n\t\t\t\n\t\t\tGetSurfaceInfo( vAlbedo, vR0, fSmoothness, vBumpNormal, intersection );\t\t\t\n\t\t\n\t\t\tvec3 vDiffuseLight = vec3(0.0);\n\t\t\tvec3 vSpecularLight = vec3(0.0);\n\n\t\t\tAddPointLight(vDiffuseLight, vSpecularLight, vRayDir, intersection.vPos, vBumpNormal, fSmoothness, vLightPos, vLightColour);\t\t\t\t\t\t\t\t\n\n\t\t\tAddDirectionalLight(vDiffuseLight, vSpecularLight, vRayDir, intersection.vPos, vBumpNormal, fSmoothness, vSunLightDir, vSunLightColour);\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\tif(intersection.fObjectId == 3.0)\n\t\t\t{\n\t\t\t\t\/\/ healthy cheese glow\n\t\t\t\tvec3 vCheesePointA = vec3(0.0, -0.8, -2.0);\t\t\t\n\t\t\t\tvec3 vCheesePlane = normalize(cross(vCheesePointA1 - vCheesePointA, vCheesePointC - vCheesePointA));\n\t\t\t\tfloat dist = clamp(dot(intersection.vPos - vCheesePointA, vCheesePlane), 0.0, kFarClip);\n\t\t\t\tvDiffuseLight += clamp(vBumpNormal.y * 0.25 + 0.75, 0.0, 1.0) * vec3(0.5, 0.4, 0.2) * (exp2(-dist * 0.25) * 2.0 + 0.4);\n\t\t\t}\n\n\t\t\tvec3 vReflect = normalize(reflect(vRayDir, vBumpNormal));\n\t\t\tvec3 vHalf = normalize(vReflect + -vRayDir);\n\t\t\tfloat fSmoothFactor = fSmoothness * 0.9 + 0.1;\n\t\t\tvec3 vFresnel = vR0 + (1.0 - vR0) * pow(1.0 - dot(vHalf, -vRayDir), 5.0) * fSmoothFactor;\n\t\t\t\t\t\t\n\t\t\tvResult = mix(vAlbedo * vDiffuseLight, vSpecularLight, vFresnel);\t\t\n\t\t\tvBlendFactor = vFresnel;\n\t\t\t\n\t\t\tApplyAtmosphere(vResult, intersection.fDist, vRayOrigin, vRayDir, fInvSpread);\n\t\t\t\n\t\t\tvRemaining *= vBlendFactor;\t\t\t\t\n\t\t\tvRayDir = vReflect;\n\t\t\tvRayOrigin = intersection.vPos;\n\t\t\t\n\t\t\tfInvSpread *= fSmoothness * fSmoothness;\t\t\t\n\t\t}\t\t\t\n\n\t\tvColour +=vResult * vCurrRemaining * fShouldApply;\n\t}\n\t\n\tvec3 vSkyColor = GetSkyColour(vRayDir, fInvSpread);\n\tApplyAtmosphere(vSkyColor, kFarClip, vRayOrigin, vRayDir, fInvSpread);\n\n\tvColour += vSkyColor * vRemaining;\n\t\n\treturn vColour;\n}\n","name":"","description":"","type":"image"}]}}