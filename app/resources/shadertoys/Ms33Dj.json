{"Shader":{"ver":"0.1","info":{"id":"Ms33Dj","date":"1452158255","viewed":192,"name":"Garage","username":"dr2","description":"Fun in the parking deck","likes":15,"published":3,"flags":0,"tags":["raymarching","lighting","cars"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ \"Garage\" by dr2 - 2016\n\/\/ License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s = vec3 (0.);\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 e = vec3 (0.2, 0., 0.);\n  float s = Fbmn (p, n);\n  vec3 g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h = clamp (0.5 + 0.5 * (b - a) \/ r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\n#define NCAR 6\n\nmat3 carMat[NCAR + 1], oMat;\nvec3 carPos[NCAR + 1], oPos, qHit;\nfloat ti[6], tPer, ts, tCur, qFy, fLen, spDist, spRad, trWid, dstFar;\nint carCv[NCAR], oCv, idObj, idObjGrp;\nbool tracking, refMir, smSurf;\n\nvoid TrackSetup ()\n{\n  float r, dtc;\n  fLen = 3.5;\n  trWid = 0.12;\n  spRad = 0.7;\n  spDist = 0.82 * fLen;\n  r = spRad \/ spDist;\n  ts = length (vec2 (2. * pi * r, 1. \/ spDist));\n  dtc = (0.5 * pi - 2.) * r;\n  ti[0] = 0.;\n  ti[1] = ti[0] + ts + 2. + dtc;\n  ti[2] = ti[1] + ts + 2. + dtc;\n  ti[3] = ti[2] + ts + 4. + 2. * dtc;\n  ti[4] = ti[3] + ts + 4. + 3. * dtc;\n  ti[5] = ti[4] + ts + 4. + 3. * dtc;\n  tPer =  ti[5] + ts + 4. + 2. * dtc;\n}\n\nvec3 TrackPath (float t)\n{\n  vec3 p;\n  vec2 sn;\n  float tm, tsi, tc, a, r, mr, dtc, av, c1, c2;\n  const float c025 = 0.25, c05 = 0.5, c075 = 0.75;\n  bool axFlip;\n  int pType;\n  r = spRad \/ spDist;\n  mr = 1. - r;\n  tsi = 1. \/ ts;\n  tc = c05 * pi * r;\n  av = c025 \/ tc;\n  dtc = (c05 * pi - 2.) * r;\n  t = mod (t, tPer);\n  p = vec3 (0.);\n  axFlip = false;\n  pType = 0;\n  sn = vec2 (1.);\n  if (t < ti[3]) {\n    if (t < ti[1] + ts) {\n      if (t < ti[0] + ts) {\n        pType = 4;  tm = t - ti[0];\n        p.xzy = vec3 (0., - mr, tm * tsi);  a = tm * tsi + c075;\n      } else if (t < ti[1]) {\n        pType = 2;  tm = t - (ti[0] + ts);\n        p.y = 1.;  a = c075;\n      } else {\n        pType = 4;  tm = t - ti[1];\n        p.xzy = vec3 (mr, 0., 1. + tm * tsi);  a = tm * tsi;\n      }\n    } else {\n      if (t < ti[2]) {\n        pType = 2;  tm = t - (ti[1] + ts);\n        p.y = 2.;  a = 0.;\n        axFlip = true;\n        sn.x = -1.;\n      } else if (t < ti[2] + ts) {\n        pType = 4;  tm = t - ti[2];\n        p.xzy = vec3 (0., mr, 2. + tm * tsi);  a = tm * tsi + c025;\n      } else {\n        pType = 1;  tm = t - (ti[2] + ts);\n        p.y = 3.;  a = c025;\n      }\n    }\n  } else {\n    if (t < ti[4] + ts) {\n      if (t < ti[3] + ts) {\n        pType = 4;  tm = t - ti[3];\n        p.xzy = vec3 (0., - mr, 3. - tm * tsi);  a = tm * tsi + c075;\n      } else if (t < ti[4]) {\n        pType = 3;  tm = t - (ti[3] + ts);\n        p.y = 2.;  a = c075;\n      } else {\n        pType = 4;  tm = t - ti[4];\n        p.xzy = vec3 (- mr, 0., 2. - tm * tsi);  a = tm * tsi + c05;\n      }\n    } else {\n      if (t < ti[5]) {\n        pType = 3;  tm = t - (ti[4] + ts);\n        p.y = 1.;  a = c05;\n        axFlip = true;\n        sn.y = -1.;\n      } else if (t < ti[5] + ts) {\n        pType = 4;  tm = t - ti[5];\n        p.xzy = vec3 (0., mr, 1. - tm * tsi);  a = tm * tsi + c025;\n      } else {\n        pType = 1;  tm = t - (ti[5] + ts);\n        p.y = 0.;  a = c025;\n      }\n    }\n  }\n  if (pType == 1) {\n    if (tm < mr) p.xz = vec2 (- tm, 1.);\n    else if (tm < mr + tc) {\n      p.xz = vec2 (-1., 1.);  a += (tm - mr) * av;\n      pType = 5;\n    } else if (tm < 3. * mr + tc) p.xz = vec2 (-1., - tm + 2. * mr + tc);\n    else if (tm < 3. * mr + 2. * tc) {\n      p.xz = vec2 (-1., -1.);  a += (tm - (3. * mr + tc)) * av + c025;\n      pType = 5;\n    } else p.xz = vec2 (tm - (4. * mr + 2. * tc), -1.);\n  } else if (pType == 2) {\n    if (tm < mr) p.xz = vec2 (tm, -1.);\n    else if (tm < mr + tc) {\n      p.xz = vec2 (1., -1.);  a += (tm - mr) * av;\n      pType = 5;\n    } else p.xz = vec2 (1., tm - (2. * mr + tc));\n    p.xz = axFlip ? p.zx : p.xz;\n  } else if (pType == 3) {\n    c1 = 2. - 3. * r + tc;\n    c2 = 3.5 - 5. * r + 2. * tc;\n    if (tm < c05 - r) p.xz = vec2 (tm, -1.);\n    else if (tm < c05 - r + tc) {\n      p.xz = vec2 (c05, -1.);  a += (tm - (c05 - r)) * av;\n      pType = 5;\n    } else if (tm < c1) p.xz = vec2 (c025 + r, tm - (1.5 - 2. * r + tc));\n    else if (tm < c1 + tc) {\n      p.xz = vec2 (c05, c05);  a += (tm - c1) * av + c025;\n      pType = 5;\n    } else if (tm < c2) p.xz = vec2 (- (tm - (c1 + tc)) + c025, c05);\n    else if (tm < c2 + tc) {\n      p.xz = vec2 (-1., c05);  a += (tm - c2) * av + c05;\n      pType = 5;\n    } else p.xz = vec2 (-1., c025 - (tm - (c2 + tc)));\n    p.xz = axFlip ? p.zx : p.xz;\n  }\n  p.xz *= sn;\n  oCv = 0;\n  if (pType == 5) p.xz -= r * sign (p.xz);\n  if (pType == 4 || pType == 5) {\n    a *= 2. * pi;\n    p.xz += r * vec2 (cos (a), sin (a));\n    oCv = 1;\n  }\n  p.xz *= spDist;\n  p.y += 0.1;\n  return p;\n}\n\nfloat CarDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;\n  d = SmoothMin (PrRoundBoxDf (q + vec3 (0., -0.08, 0.),\n     vec3 (0.06, 0.01, 0.15), 0.02), PrRoundBoxDf (q + vec3 (0., -0.13, 0.02),\n     vec3 (0.035, 0.005, 0.07), 0.02), 0.06);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 1;  qHit = q; }\n  q.xz = abs (q.xz) - vec2 (0.07, 0.1);\n  q.y -= 0.055;\n  d = PrCylDf (q.yzx, 0.03, 0.012);\n  if (d < dMin) { dMin = d;  idObj = idObjGrp + 2;  qHit = q; }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, dr, fy, sn34, sn4, flThk, htWl, wThk;\n  bool is24;\n  flThk = 0.03;\n  htWl = 0.02;\n  wThk = 0.03;\n  dMin = dstFar;\n  fy = floor (p.y) + 1.;\n  is24 = (fy == 2. || fy == 4.);\n  sn34 = ((fy == 3. || fy == 4.) ? -1. : 1.);\n  sn4 = ((fy == 4.) ? -1. : 1.);\n  if (fy >= 1. && fy <= 3.) {\n    q = p;\n    q.xz = is24 ? q.zx : q.xz;\n    q.z = abs (q.z) - spDist + spRad;\n    q.xz = vec2 (- q.z, q.x * sn34);\n    q.y -= atan (q.z, - q.x) \/ (2. * pi) + fy;\n    dr = length (q.xz) - spRad;\n    d = max (max (PrBox2Df (vec2 (dr, q.y), vec2 (trWid + wThk, htWl)),\n       - PrBox2Df (vec2 (dr, q.y - htWl), vec2 (trWid, htWl))), q.z);\n    q.y += 1.;\n    d = min (d, max (max (PrBox2Df (vec2 (dr, q.y), vec2 (trWid + wThk, htWl)),\n       - PrBox2Df (vec2 (dr, q.y - htWl), vec2 (trWid, htWl))), - q.z));\n    if (d < dMin) { dMin = d;  idObj = 1;  qHit = q; }\n  }\n  if (fy >= 0. && fy <= 3.) {\n    q = p;\n    q.y -= fy - flThk;\n    d = PrBoxDf (q, vec3 (fLen, flThk, fLen));\n    if (fy >= 1.) {\n      q.xz = is24 ? q.xz : q.zx;\n      q.x = abs (q.x) - spDist + 0.5 * spRad;\n      q.z += 0.65 * spRad * sn34;\n      d = max (d, - PrBox2Df (q.xz, spRad * vec2 (0.9, 0.65)));\n    }  \n    if (d < dMin) { dMin = d;  idObj = 2;  qFy = fy;  qHit = p; }\n  }\n  if (fy >= 2. && fy <= 4.) {\n    q = p;\n    q.y -= fy - 1. + 2. * flThk;\n    q.xz = is24 ? q.zx : q.xz;\n    q.x = abs (q.x) - spDist + 0.5 * spRad;\n    q.z += 0.65 * spRad * sn4;\n    d = PrBoxDf (q, spRad * vec3 (0.9, 0., 0.65) + flThk * vec3 (2.));\n    d = max (d, - min (PrBox2Df (q.xz, spRad * vec2 (0.9, 0.65)),\n       PrBox2Df (q.xz - spRad * vec2 (0.5, 0.6 * sn4),\n       spRad * vec2 (0.3, 0.2))));\n    if (d < dMin) { dMin = d;  idObj = 3; }\n  }\n  if (fy >= 1. && fy <= 4.) {\n    q = p;\n    q.y -= fy - 1. + 2. * flThk;\n    d = max (PrBoxDf (q, vec3 (fLen, 2. * flThk, fLen)),\n       - PrBox2Df (q.xz, vec2 (fLen - flThk)));\n    if (d < dMin) { dMin = d;  idObj = 4; }\n  }\n  q = p;\n  q.y -= 1.5;\n  q.xz = Rot2D (q.xz, 0.25 * pi);\n  q.xz = abs (q.xz) - (spDist - spRad) \/ sqrt (2.);\n  d = PrCylDf (q.xzy, 3. * flThk, 1.49);\n  if (d < dMin) { dMin = d;  idObj = 5; }\n  q = p;\n  q.y -= 1.5;\n  q.xz = abs (q.xz) - 0.95 * fLen;\n  d = PrCylDf (q.xzy, 3. * flThk, 1.49);\n  if (d < dMin) { dMin = d;  idObj = 6; }\n  q = p;\n  q.y -= 1.9;\n  d = max (PrBoxDf (q, vec3 (0.2 * fLen, 1.9, 0.2 * fLen)),\n     - PrBox2Df (q.xz, vec2 (0.2 * fLen - wThk)));\n  if (fy >= 1. && fy <= 4.) {\n    q = p;\n    q.y -= fy - 0.7;\n    d = max (d, - min (PrBox2Df (q.xy, vec2 (0.05 * fLen, 0.3)),\n       PrBox2Df (q.zy, vec2 (0.05 * fLen, 0.3))));\n  }\n  if (d < dMin) { dMin = d;  idObj = 7;  qHit = q; }\n  idObjGrp = 0;\n  for (int nc = 0; nc < NCAR; nc ++) {\n    q = p - carPos[nc];\n    d = PrBoxDf (q, vec3 (0.2));\n    idObjGrp += 256;\n    if (d < dMin) dMin = CarDf (carMat[nc] * q, dMin);\n  }\n  return dMin;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec3 e = vec3 (0.0001, -0.0001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float d, dHit, srd, dda;\n  dHit = 0.;\n  srd = - sign (rd.y);\n  dda = - srd \/ (rd.y + 0.00001);\n  for (int j = 0; j < 200; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    dHit += min (d, 0.01 + max (0., fract (dda * fract (srd * p.y))));\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec4 FloorCol (vec3 vn)\n{\n  vec3 col;\n  vec2 u, uu;\n  float spec, wFac, f, ff;\n  bool nrTrail;\n  col = vec3 (0.4);\n  spec = 0.1;\n  smSurf = false;\n  u = qHit.xz;\n  if (idObj == 1) {\n    f = abs (length (u) - spRad) \/ trWid;\n    if (vn.y > 0. && f < 0.95) {\n      col = mix (vec3 (0.1), vec3 (1., 1., 0.),\n         SmoothBump (-0.05, 0.1, 0.05, abs (f) - 0.85));\n      spec = 0.3;\n      smSurf = true;\n    } else if (vn.y < -0.8) {\n      col = mix (col, vec3 (0.3, 0.3, 1.),\n         smoothstep (0., 0.02, abs (f) - 0.93));\n    } else {\n      col = vec3 (0.7, 0.6, 0.4);\n    }\n  } else if (idObj == 2) {\n    wFac = 1.;\n    if (vn.y > 0.999) {\n      uu = mod (u + 0.25, 0.5);\n      f = 1. - (1. - SmoothBump (0.24, 0.26, 0.01, uu.x)) *\n         ( 1. - SmoothBump (0.24, 0.26, 0.01, uu.y));\n      col = mix (col, vec3 (0.5, 0.5, 0.8), f);\n      if (qFy == 0. || qFy == 3.) nrTrail = (u.x < 0.);\n      else {\n        if (qFy == 1.) u.y *= -1.;\n        if (u.x > 0. || u.y > 0.) {\n          if (u.x > 0. && u.y > 0. && length (u.xy) > 0.6 * fLen) nrTrail = true;\n          else {\n            u.xy += 0.25 * spDist;\n            wFac = 0.75;\n            nrTrail = true;\n          }\n        }\n      }\n      if (nrTrail) {\n        f = (pow (length (pow (abs (u), vec2 (5.))), 0.2) -\n           0.82 * wFac * fLen) \/ trWid;\n        if (abs (f) < 0.98) {\n          uu = mod (u + 0.4, 0.8) - 0.4;\n          ff = (1. - SmoothBump (- 0.1, 0.1, 0.02, uu.x)) *\n             (1. - SmoothBump (- 0.1, 0.1, 0.02, uu.y));\n          col = mix (vec3 (0.1), vec3 (1., 1., 0.),\n             ff * SmoothBump (-0.05, 0.1, 0.05, abs (f) - 0.85));\n          spec = 0.3;\n          smSurf = true;\n        }\n      }\n    } else if (qFy > 0. && vn.y < -0.999) {\n      uu = mod (u + 0.1, 0.35) - 0.1;\n      f = 1. - (1. - SmoothBump (-0.006, 0.006, 0.002, uu.x)) *\n         (1. - SmoothBump (-0.006, 0.006, 0.002, uu.y));\n      col = mix (col, vec3 (0.5), f);\n      uu = mod (u, 0.35) - 0.175;\n      if (length (uu) < 0.03) {\n        col = vec3 (1., 0.7, 0.2);\n        spec = -1.;\n      }\n    } else if (abs (vn.y) < 0.01) col = vec3 (0.45, 0.45, 0.4);\n  }\n  return vec4 (col, spec);\n}\n\nvec4 CarCol ()\n{\n  vec3 col;\n  vec2 u;\n  float f, spec, br;\n  int ig, id;\n  bool brkLt;\n  ig = idObj \/ 256;\n  id = idObj - 256 * ig;\n  if (id == 1) {\n    col = vec3 (0.3, 1., 0.5);\n    f = abs (qHit.z + 0.02);\n    f = max (max (step (0.075, f) * step (0.045, abs (qHit.x)),\n       step (f, 0.007)), step (0.017, abs (qHit.y - 0.13)));\n    if (f == 0.) {\n      col = vec3 (0.2, 0.1, 0.);\n      spec = 0.5;\n    }\n    if (abs (qHit.z) > 0.15) {\n      if (qHit.z > 0.) {\n        if (length (vec2 (qHit.x, 3. * (qHit.y - 0.08))) < 0.03) col *= 0.3;\n        u = qHit.xy;\n        u.x = abs (u.x);\n        u -= vec2 (0.045, 0.08);\n        if (length (u) < 0.009) {\n          col = vec3 (1., 1., 0.3);\n          spec = -1.;\n        }\n      } else {\n        brkLt = false;\n        u = qHit.xy;\n        u.y -= 0.095;\n        if (abs (u.x) < 0.03 && abs (u.y) < 0.0025) brkLt = true;\n        u = qHit.xy;\n        u.x = abs (u.x);\n        u -= vec2 (0.055, 0.08);\n        if (length (u) < 0.007) brkLt = true;\n        if (brkLt) {\n          br = 0.;\n          for (int nc = 0; nc < NCAR; nc ++) {\n            if (nc == ig - 1 && carCv[nc] == 1) br = 1.;\n          }\n          col = vec3 (1., 0., 0.) * (0.5 + 0.5 * br);\n          spec = -1.;\n        }\n        u.x += 0.02;\n        if (length (u) < 0.007) {\n          col = vec3 (1., 0., 0.);\n          spec = -1.;\n        }\n      }\n    }\n  } else if (id == 2) {\n    f = length (qHit.yz);\n    if (f < 0.018) {\n      col = (f > 0.005) ? vec3 (0.9) : vec3 (0.3);\n      spec = 0.7;\n    } else {\n      col = vec3 (0.03);\n      spec = 0.1;\n    } \n  }\n  return vec4 (col, spec);\n}\n\nfloat BrickPat (vec2 p)\n{\n  vec2 q, iq;\n  q = 8. * p * vec2 (1., 4.);\n  iq = floor (q);\n  if (2. * floor (iq.y \/ 2.) != iq.y) q.x += 0.5;\n  q = smoothstep (0.02, 0.05, abs (fract (q + 0.5) - 0.5));\n  return (0.7 + 0.3 * q.x * q.y);\n}\n\nvec4 ObjCol (vec3 ro, vec3 vn)\n{\n  vec4 objCol;\n  vec3 q;\n  float f;\n  objCol.a = 0.1;\n  if (idObj == 1 || idObj == 2) {\n    objCol = FloorCol (vn);\n  } else if (idObj == 3) {\n    f = (max (abs (vn.x), abs (vn.z)) > abs (vn.y)) ?\n       BrickPat ((abs (vn.x) >  abs (vn.z) ? ro.zy : ro.xy)) : 1.;\n    objCol.rgb = f * vec3 (0.5, 0.4, 0.3);\n  } else if (idObj == 4) {\n    f = (dot (vn.xz, ro.xz) < 0.) ?\n       BrickPat ((abs (vn.x) >  abs (vn.z) ? ro.zy : ro.xy)) : 1.;\n    objCol.rgb = f * vec3 (0.7, 0.6, 0.4);\n  } else if (idObj == 5) {\n    f = smoothstep (0.1, 0.15, abs (mod (10. * ro.y, 1.)));\n    objCol.rgb = mix (vec3 (0., 0., 1.), vec3 (0.7, 0.6, 0.4), f);\n  } else if (idObj == 6) {\n    f = smoothstep (0.1, 0.15, abs (mod (10. * ro.y, 1.)));\n    objCol.rgb = (0.7 + 0.3 * f) * vec3 (0.7, 0.6, 0.4);\n  } else if (idObj == 7) {\n    q = abs (vn.x) > abs (vn.z) ? qHit.zyx : qHit;\n    if (dot (vn.xz, ro.xz) > 0. && length (q.xy - vec2 (0., 0.35)) < 0.02) {\n      objCol.rgb = vec3 (1., 0.2, 0.2);\n      objCol.a = -1.;\n    } else objCol.rgb = BrickPat (q.xy) * vec3 (0.7, 0.6, 0.4);\n  } else if (idObj > 256) {\n    objCol = CarCol ();\n  }\n  return objCol;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 objCol;\n  vec3 ltPos, ltAx, ltDir, col, vn, rds;\n  float dstHit, diff, ltDiff, ltSpec, d, atten, f;\n  int idObjT;\n  dstHit = ObjRay (ro, rd);\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    objCol = ObjCol (ro, vn);\n    if ((idObj == 1 || idObj == 2) && ! smSurf || idObj >= 3 && idObj <= 7)\n       vn = VaryNf (100. * ro, vn, 0.2);\n    if (objCol.a >= 0.) {\n      ltDiff = 0.;\n      ltSpec = 0.;\n      for (int nc = 0; nc < NCAR + 1; nc ++) {\n        if (tracking || nc < NCAR) {\n          ltPos = carPos [nc];\n          ltAx = vec3 (0., 0., 1.) * carMat[nc];\n          ltPos += 0.2 * ltAx;\n          ltPos.y += 0.05;\n          ltDir = ltPos - ro;\n\t  ltDir.y += 0.05;\n          atten = 1. - smoothstep (0.85, 0.95, abs (ltAx.y));\n\t  if (nc < NCAR) atten *= 1. - smoothstep (0.05, 0.1, ltDir.y);\n          d = max (length (ltDir), 0.3);\n          ltDir = normalize (ltDir);\n          f = max (dot (ltAx, - ltDir), 0.);\n          atten *= f * f \/ pow (d, 2.);\n          diff = max (dot (ltDir, vn), 0.);\n          ltDiff += atten * diff;\n          ltSpec += step (0., diff) *\n             atten * pow (max (dot (reflect (ltDir, vn), rd), 0.), 32.);\n         }\n      }\n      ltDiff = min (0.4 * ltDiff, 1.) +\n         0.2 * max (dot (vec3 (0., 0., 1.), vn), 0.);\n      col = objCol.rgb * (0.1 + ltDiff + objCol.a * min (0.3 * ltSpec, 1.));\n      if (! tracking) col *= 1.5;\n    } else col = objCol.rgb;\n  } else {\n    col = vec3 (0., 0., 0.07);\n    f = step (0., (rd.y + 0.3) \/ 1.3);\n    rds = (rd + vec3 (1., 0.7, 0.3));\n    for (int j = 0; j < 14; j ++) rds = 11. * abs (rds) \/ dot (rds, rds) - 3.;\n    col += min (1., 1.5e-6 * pow (min (16., length (rds)), 5.)) *\n       f * f * vec3 (0.65, 0.65, 0.6);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid ObjPM (float t)\n{\n  vec3 vuF, vuB, dv;\n  vec2 ort, cr, sr;\n  oPos = TrackPath (t);\n  vuF = TrackPath (t + 0.05);\n  vuB = TrackPath (t - 0.05);\n  dv = vuF - vuB;\n  ort = vec2 (- asin (dv.y \/ length (dv)), atan (dv.z, dv.x) - 0.5 * pi);\n  cr = cos (ort);\n  sr = sin (ort);\n  oMat = mat3 (1., 0., 0., 0., cr.x, - sr.x, 0., sr.x, cr.x) *\n     mat3 (cr.y, 0., - sr.y, 0., 1., 0., sr.y, 0., cr.y);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  mat3 vuMat, vuMatT;\n  vec3 col, ro, rd, vd, u, p1, p2;\n  vec2 canvas, uv, ut, uvs, vf, cf, sf, mMid, mSize;\n  float el, az, f, s, cd, vel, cdGap, fnc;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy \/ canvas - 1.;\n  uvs = uv;\n  uv.x *= canvas.x \/ canvas.y;\n  tCur = iGlobalTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy \/ canvas - 0.5;\n  tracking = ! (mPtr.z > 0.);\n  dstFar = tracking ? 10. : 30.;\n  mMid = vec2 (-1., 0.6);\n  mSize = vec2 (0.6, 0.3);\n  ut = abs (uv - mMid) - mSize;\n  refMir = tracking && (max (ut.x, ut.y) < 0.);\n  vel = 0.3;\n  TrackSetup ();\n  s = vel * tCur;\n  cdGap = 0.4 + 0.6 * SmoothBump (0.3, 0.8, 0.2, fract (2.5 * s \/ tPer));\n  for (int nc = 0; nc < NCAR; nc ++) {\n    fnc = float (nc);\n    ObjPM (s + cdGap * (floor (0.5 * fnc) + 1.) * (2. * mod (fnc, 2.) - 1.));\n    carPos[nc] = oPos;\n    carPos[nc].y -= 0.125;\n    carMat[nc] = oMat;\n    carCv[nc] = oCv;\n  }\n  if (tracking) {\n    s += 0.1 * (SmoothBump (0.2, 0.7, 0.1, fract (7. * s \/ tPer)) - 0.5);\n    ObjPM (s);\n    carPos[NCAR] = oPos;\n    carPos[NCAR].y -= 0.125;\n    carMat[NCAR] = oMat;\n    p1 = TrackPath (s + 0.1);\n    p2 = TrackPath (s - 0.1);\n    ro = 0.5 * (p1 + p2);\n    vd = normalize (p1 - p2);\n    if (refMir) vd *= -1.;\n    u = - vd.y * vd;\n    f = 1. \/ sqrt (1. - vd.y * vd.y);\n    vuMatT = mat3 (f * vec3 (- vd.z, 0., vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n  }\n  az = 0.;\n  el = refMir ? -0.1 : 0.1;\n  if (mPtr.z > 0.) {\n    el = el - 4. * mPtr.y;\n    az = az + 10. * mPtr.x;\n  }\n  el = clamp (el, -0.45 * pi, 0.45 * pi);\n  vf = vec2 (el, az);\n  cf = cos (vf);\n  sf = sin (vf);\n  vuMat = mat3 (1., 0., 0., 0., cf.x, - sf.x, 0., sf.x, cf.x) *\n     mat3 (cf.y, 0., sf.y, 0., 1., 0., - sf.y, 0., cf.y);\n  if (tracking) {\n    ro.y += 0.05;\n    if (refMir) uv = (uv - mMid) \/ mSize.x;\n    rd = vuMatT * (vuMat * normalize (vec3 (uv, (refMir ? 1.5 : 1.8))));\n  } else {\n    ro = vec3 (0., 2., -12.) * vuMat;\n    rd = normalize (vec3 (uv, 3.)) * vuMat;\n  }\n  col = ShowScene (ro, rd);\n  col = mix (vec3 (0.3), col, pow (max (0., 0.85 -\n     length (pow (abs (uvs), vec2 (10.)))), 0.2));\n  ut = abs (ut);\n  if (refMir && min (ut.x, ut.y) * canvas.y < 2.) col = vec3 (0.3, 0.5, 0.2);\n  fragColor = vec4 (col, 1.);\n}\n","name":"","description":"","type":"image"}]}}