{"Shader":{"ver":"0.1","info":{"id":"MtjXRK","date":"1445099206","viewed":482,"name":"Blocky Color Wheel","username":"freerunnering","description":"A color wheel designed for use in an app as the color selection UI for a kids game. (the viewport is meant to be circular)","likes":0,"published":3,"flags":0,"tags":["simple","color","wheel","hsv","hsl"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"const float M_PI = 3.14159265359;\nconst float BLOCKY = (M_PI * 0.2);\nconst float center = 0.15;\nfloat circleEdgeBlur = 0.3;\n\n\/\/ HSL & HSV to RGB conversion\nvec3 hsv2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\nvec3 hsl2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0,1.0);\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n\n\/\/ Entire shader is in here\nvec3 hslForPixel(in vec2 pixel)\n{\n    \/\/ Lightness\n    float l = 0.5;\n    \n    \/\/ Position normalised into (0, 1)\n    vec2 position = pixel\/iResolution.xy;\n    \/\/position.y = 1.0-position.y; \/\/ Flip y for my brain\n    \n    \/\/ Position normalised into (-1, 0, 1)\n    vec2 d = 1.0 - (position * 2.0);\n    \/\/ Distance from center\n    float dist = length(d); \/\/ sqrt((d.x*d.x) + (d.y*d.y));\n    \n    \/\/ Anti alias the circle (TODO: Do this to the color edges somehow)\n    if (dist < center) {\n        l = (1. - ((smoothstep(center-circleEdgeBlur, center, (dist*1.)) \/ 2.)));\n    }\n    \n    \/\/ Get the rotation\n    float r = acos(d.x \/ dist);\n    \/\/ Sort out the bottom half (y=-1)\n    r = sign(d.y) * r; \/\/if (d.y < 0.0) { r = M_PI-(r + M_PI); }\n    \/\/ Make it blocky (TODO: anti alias)\n    r = (ceil((r\/BLOCKY)-0.5) * BLOCKY);\n    r += (M_PI * 0.5); \/\/ Rotate by 90 degrees (red on top)\n    \n    float hue = (r \/ M_PI) \/ 2.0; \/\/ Normalise from (0 - 2_PI) to (0 - 1)\n    \n    return vec3(hue, 1.0, l);\n}\n\n\n\/\/ Just call the above function (lets us do it multiple times)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    circleEdgeBlur = 5. \/ iResolution.x;\n    vec3 pixelColor;\n    \n    \/\/ Anti Aliasing attempt (really just blur)\n    pixelColor = hsl2rgb(hslForPixel(fragCoord)); \/\/ 5.;\n    \/*pixelColor += hsl2rgb(hslForPixel(fragCoord.xy + vec2( 1., 1.))) \/ 5.;\n    pixelColor += hsl2rgb(hslForPixel(fragCoord.xy + vec2( 1.,-1.))) \/ 5.;\n    pixelColor += hsl2rgb(hslForPixel(fragCoord.xy + vec2(-1.,-1.))) \/ 5.;\n    pixelColor += hsl2rgb(hslForPixel(fragCoord.xy + vec2(-1., 1.))) \/ 5.;*\/\n    \n    fragColor = vec4(pixelColor, 1.0);\n}\n","name":"","description":"","type":"image"}]}}