{"Shader":{"ver":"0.1","info":{"id":"lssGW7","date":"1372433267","viewed":3533,"name":"Brigthton Beach","username":"Dave_Hoskins","description":"A low down camera sweep of Brigthton's Beach on a misty morning. <img src=\"\/img\/emoticonHappy.png\"\/><br\/>Mouse X to drag through time.","likes":48,"published":3,"flags":0,"tags":["raycast","clouds","brigthton"],"hasliked":0},"renderpass":[{"inputs":[{"id":2,"src":"\/presets\/tex01.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":4,"src":"\/presets\/tex03.jpg","ctype":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":8,"src":"\/presets\/tex07.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":10,"src":"\/presets\/tex09.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Brighton Beach. David Hoskins - 2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ It uses binary subdivision to accurately find the pebble height map.\n\/\/ I've probably overdone the post noise effect, but tough, it's staying for now!\n\n\/\/v 1.1 Added water, plus colour gradient and extra shine to wet stones.\n\/\/v 1.2 Some optimisations.\n\n\/\/#define STEREO \n\/\/#define VARY_SIZE\n\nvec3 sunLight  = normalize( vec3(  0.35, 0.3,  0.6 ) );\nvec3 cameraPos;\nvec3 sunColour = vec3(1.0, .8, .7);\nconst mat2 rotate2D = mat2(1.932, 1.623, -1.623, 1.952);\nfloat gTime;\n \n\/\/--------------------------------------------------------------------------\n\/\/ Noise functions...\nfloat Hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n\/\/--------------------------------------------------------------------------\nfloat Hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\/\/--------------------------------------------------------------------------\nvec2 Hash2(vec2 p) \n{\n\tfloat r = 523.0*sin(dot(p, vec2(37.3158, 53.614)));\n\treturn vec2(fract(17.12354 * r), fract(23.15865 * r));\n}\n\n\/\/--------------------------------------------------------------------------\nfloat Noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    float res = mix(mix( Hash(n+  0.0), Hash(n+  1.0),f.x),\n                    mix( Hash(n+ 57.0), Hash(n+ 58.0),f.x),f.y);\n    return res;\n}\n\n\/\/--------------------------------------------------------------------------\nvec2 Noise2( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 res = mix(mix( Hash2(p), Hash2(p + vec2(1.0,0.0)),f.x),\n                   mix( Hash2(p + vec2(0.0,1.0)), Hash2(p + vec2(1.0,1.0)),f.x),f.y);\n    return res-vec2(.5);\n}\n\n\/\/--------------------------------------------------------------------------\nfloat CloudNoise( in vec2 uv )\n{\n\tvec2 iuv = floor(uv);\n\tvec2 fuv = fract(uv);\n\tuv = (iuv + fuv*fuv*(3.0-2.0*fuv)) \/ 1024.0;\n    return texture2D(iChannel0, uv, -100.0 ).z;\n}\n\n\/\/--------------------------------------------------------------------------\nfloat SmoothTerrain( in vec2 p)\n{\n\tvec2 pos = p*0.013;\n\tfloat w = 27.0;\n\tvec2 dxy = vec2(0.0, 0.0);\n\tfloat f = .0;\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tf += Noise(pos) * w;\n\t\tw = -w * 0.5;\n\t\tpos *= 2.0;\n\t}\n\t\/\/ Slide down hill between -8 and 21 of pos.y for sea to appear...\n\tf -= smoothstep(-12.0, 23.0, pos.y)*30.0-2.0;\n\treturn f;\n}\n\n\/\/--------------------------------------------------------------------------\nvec2 Terrain( in vec2 p)\n{\n\t\/\/ type is either 0.0 for land or > 1.0 for depth in sea...\n\tfloat type = 0.0;\n\tfloat f = SmoothTerrain(p);\n\t\/\/ Now the pebbles...\n\t#ifdef VARY_SIZE\n\tp *= .38+(Noise2(p*.001)*.15);\n\t#else\n\tp *= .45;\n\t#endif\n\tp = p + Noise2(p);\n\tvec2 v2 = fract(p)-.5;\n\tf += max(.45-(dot(v2,v2)), 0.0)*(1.5+Hash(floor(p))*3.0);\n\tfloat water = Noise(p*.02+vec2(0.0, iGlobalTime*.28))*8.0+sin(p.y*.5+iGlobalTime)*.3;\n\tif (f < water)\n\t{\n\t\ttype = 1.0+(water-f);\n\t\tf = water;\n\t}\n\treturn vec2(f, type);\n}\n\n\/\/--------------------------------------------------------------------------\nvec2 Map(in vec3 p)\n{\n\tvec2 h = Terrain(p.xz);\n    return vec2(p.y - h.x, h.y);\n}\n\n\/\/--------------------------------------------------------------------------\nfloat Shadow( in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n\tfloat t = .01;\n\t\n\tfor (int i = 0; i < 6; i++) \n\t{\n        float d = Map(ro + rd * t).x;\n        res = min(res, 0.1 * d \/ t);\n\n        t += .05;\n    }\n\n    return clamp(res*1.7,.1, 1.0);\n}\n\/\/--------------------------------------------------------------------------\nfloat FractalNoise(in vec2 xy)\n{\n\tfloat w = .8;\n\tfloat f = 0.0;\n\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tf += CloudNoise(xy) * w;\n\t\tw = w*0.5;\n\t\txy = rotate2D * xy;\n\t}\n\treturn f;\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 GetClouds(in vec3 sky, in vec3 rd)\n{\n\t\/\/if (rd.y < 0.0) return sky;\n    rd.y = max(rd.y,0.0);\n\t\/\/ Uses the ray's y component for horizon fade of fixed colour clouds...\n\tfloat v = (2300.0-cameraPos.y)\/rd.y;\n\trd.xz = (rd.xz * v + cameraPos.xz+vec2(300.0,-3830.0)) * 0.004;\n\tfloat f = (FractalNoise(rd.xz) -.1) * 3.0;\n\tvec3 cloud = mix(vec3(.25, .12, .02), vec3(.13, .12, .1), min(f*1.2, 1.0));\n\tsky = mix(sky, cloud, clamp(f*rd.y*rd.y*5.5, 0.0, 1.0));\n\treturn sky;\n}\n\n\/\/--------------------------------------------------------------------------\n\/\/ Grab all sky information for a given ray from camera\nvec3 GetSky(in vec3 rd)\n{\n    rd.y = abs(rd.y);\n\tfloat sunAmount = max( dot( rd, sunLight), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),8.);\n\tvec3  sky = mix(vec3(.1, .15, .2), vec3(.27, .25, .22), v);\n\tsky = sky + sunColour * sunAmount * sunAmount * .3;\n\tsky = sky + sunColour * min(pow(sunAmount, 650.0)*.5, .1);\n\treturn clamp(sky, 0.0, 1.0);\n}\n\n\/\/--------------------------------------------------------------------------\n\/\/ Merge peebles into te sky background for correct fog colouring...\nvec3 ApplyFog( in vec3  rgb, in float dis, in vec3 dir)\n{\n\tfloat fogAmount = clamp(dis* 0.000022, 0.0, 1.0);\n\treturn mix( rgb, GetSky(dir), fogAmount );\n}\n\n\/\/--------------------------------------------------------------------------\n\/\/ Calculate sun light...\nvoid DoLighting(inout vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float dis)\n{\n\tfloat h = dot(sunLight,normal);\n\tmat = mat * (max(h, 0.0)+.2);\n\t\/\/ Specular...\n\tvec3 R = reflect(sunLight, normal);\n    float fre = pow(1.0 + dot(normal, eyeDir), 2.0) * 5.0;\n\tfloat specAmount = pow( max(dot(R, normalize(eyeDir)), 0.0), 20.0) * (.5+smoothstep(8.0, 0.0, pos.y)*4.0);\n\tmat = mix(mat, sunColour, specAmount*fre);\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 Texturize(vec3 p, vec3 n )\n{\n\tvec3 x = texture2D(iChannel3, p.yz, 1.0).xyz;\n\tvec3 y = texture2D(iChannel3, p.zx, 1.0).xyz;\n\tvec3 z = texture2D(iChannel3, p.xy, 1.0).xyz;\n\treturn (x*abs(n.x) + y*abs(n.y) + z*abs(n.z))*.6;\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 TerrainColour(vec3 pos, vec3 dir,  vec3 normal, float dis, float type)\n{\n\tvec3 mat;\n\tdis *= dis;\n\tif (type >= 1.0)\n\t{\n\t\t\/\/ Sea...\n\t\tnormal = normalize(reflect(dir, normal));\n\t\tmat = GetSky(normal);\n\t\tfloat sunAmount = max( dot( normal, sunLight), 0.0 );\n\t\t\/\/ Emphasise sun as a reflection,\n\t\t\/\/ because the sky reflect has been diminished...\n\t\tmat = mix(mat, sunColour, pow(sunAmount, 150.0)*2.0);\n\t\tmat = GetClouds(mat, normal);\n\t\tmat = mix(mat*mat, vec3(0.0, 0.005, .01), .3);\n\t\t\/\/ The depth of rocks appears to make a nice foam effect,\n\t\t\/\/ so I'll just let it do the whole job...\n\t\t\/\/ 'type' doubles up for material type and depth.\n\t\tmat = mix(vec3(1.0), mat, clamp((type-.4)*.3 + texture2D(iChannel0, pos.xz*.1).z*2.5, .85, 1.0));\n\t\tmat = ApplyFog(mat, dis, dir);\n\t\treturn mat;\n\t}else\n\t{\n\t\t\/\/ Land...\n\t\t#ifdef VARY_SIZE\n\t\tvec2 p = pos.xz * (.38+(Noise2(pos.xz*.001)*.15));\n\t\t#else\n\t\tvec2 p = pos.xz * .45;\n\t\t#endif\n\t\tvec2 rnd = Noise2(p);\n\t\tmat.xy = floor(p+rnd);\n\t\tfloat f = Noise(mat.xy);\n\t\tif(f < .25) \n\t\t\tmat = texture2D(iChannel0, p*.36).xyz;\n\t\telse\n\t\tif(f < .5) \n\t\t\tmat = texture2D(iChannel1, p).xyz;\n\t\telse\n\t\tif(f < .75) \n\t\t\tmat = texture2D(iChannel2, p*.12).xyz*.35;\n\t\telse\n\t\t\tmat = texture2D(iChannel3, p*1.3).xyz*.5;\n\t\t\/\/ Add some variation to the normal for a rougher wet look...\n\t\tnormal = normalize(normal+Texturize(pos*.25, normal));\n\t\tmat *= smoothstep(1.0, 10.0, pos.y);\n\t\tDoLighting(mat, pos, normal,dir, dis);\n\n\t\tmat *= Shadow(pos, sunLight);\n\t}\n\n\tmat = ApplyFog(mat, dis, dir);\n\treturn mat;\n}\n\n\/\/--------------------------------------------------------------------------\n\/\/ Home in on the surface by dividing by two and split...\nfloat BinarySubdivision(in vec3 rO, in vec3 rD, float t, float oldT)\n{\n\tfloat halfwayT = 0.0;\n\tfor (int n = 0; n < 6; n++)\n\t{\n\t\thalfwayT = (oldT + t ) * .5;\n\t\tif (Map(rO + halfwayT*rD).x < .25)\n\t\t{\n\t\t\tt = halfwayT;\n\t\t}else\n\t\t{\n\t\t\toldT = halfwayT;\n\t\t}\n\t}\n\treturn t;\n}\n\n\/\/--------------------------------------------------------------------------\nbool Scene(in vec3 rO, in vec3 rD, out float resT, out float type )\n{\n    float t = 8.;\n\tfloat oldT = 0.0;\n\tfloat delta = 0.4;\n    bool ret = false;\n\tfor( int j=0; j<110; j++ )\n\t{\n\t\tif (t > 220.0) break; \/\/ ...Too far awway\n\t    vec3 p = rO + t*rD;\n\n\t\tvec2 h = Map(p); \/\/ ...Get this position's height mapping.\n\t\t\/\/ Are we inside, and close enough to fudge a hit?...\n\t\tif( h.x < 0.25)\n\t\t{\n\t\t\t\/\/ Yes! So home in on height map...\n\/\/\/\t\t\tresT = BinarySubdivision(rO, rD, t, oldT);\n\t\t\ttype = h.y;\n            ret = true;\n\t\t\tbreak;\n\t\t}\n\t\t\/\/ Delta ray advance - a fudge between the height returned\n\t\t\/\/ and the distance already travelled.\n\t\t\/\/ It's a really fiddly compromise between speed and accuracy\n\t\tdelta = max(0.02, 0.35*h.x) + (t*0.005);\n\t\toldT = t;\n\t\tt += delta;\n\t}\n    if (ret) \t\t\tresT = BinarySubdivision(rO, rD, t, oldT);\n\n\treturn ret;\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 CameraPath( float t )\n{\n\tfloat m = 1.0+(iMouse.x\/iResolution.x)*300.0;\n\tgTime = (iGlobalTime*5.0+m+610.)*.006 + t;\n    vec2 p = vec2(200.0 * sin(3.54*gTime), 75.0 * cos(3.0*gTime) );\n\treturn vec3(p.x+55.0, 0.6, -94.0+p.y);\n} \n\n\/\/--------------------------------------------------------------------------\nvec3 PostEffects(vec3 rgb, vec2 xy)\n{\n\t\/\/ Gamma first...\n\trgb = pow(rgb, vec3(0.45));\n\t\n\t\/\/ Then...\n\t#define CONTRAST 1.2\n\t#define SATURATION 1.3\n\t#define BRIGHTNESS 1.3\n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\n\t\/\/ Tint and vignette...\n\trgb *= vec3(.5, .5, .47) + 0.5*pow(50.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.2 );\t\n\t\/\/ Noise...\n\trgb = clamp(rgb-Hash(rgb.rb+xy*iGlobalTime)*.05, 0.0, 1.0);\n\n\treturn rgb;\n}\n\n\/\/--------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord.xy \/ iResolution.xy;\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x\/iResolution.y,1.0);\n\tvec3 camTar;\n\n\t#ifdef STEREO\n\tfloat isCyan = mod(fragCoord.x + mod(fragCoord.y,2.0),2.0);\n\t#endif\n\t\n\tcameraPos.xz = CameraPath(0.0).xz;\n\t\n\tfloat tim = mod(gTime+.8, 1.9);\n\tfloat jump = max(sin(smoothstep(0.3, .8, tim)* 3.1415), 0.0) * 80.0;\n\t\n\tcamTar.xz\t = CameraPath(.005).xz;\n\tcameraPos.y = SmoothTerrain(CameraPath(.005).xz) + jump + 10.0;\n\t\/\/ Bob camera above water line...\n\tif (cameraPos.y < 13.0)\n\t{\n\t\tfloat f = 13.0-cameraPos.y;\n\t\tcameraPos.y = 13.0 - f*(1.0-min(f\/10.0, 1.0));\n\t}\n\tcamTar.y = cameraPos.y-jump*.05;\n\t\n\tfloat roll = .4*sin(iGlobalTime*.25);\n\tvec3 cw = normalize(camTar-cameraPos);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n\tvec3 dir = normalize( uv.x*cu + uv.y*cv + 1.5*cw );\n\n\t#ifdef STEREO\n\tcameraPos += .5*cu*isCyan; \/\/ move camera to the right - the rd vector is still good\n\t#endif\n\n\tvec3 col;\n\tfloat distance;\n\tfloat type;\n\tif( !Scene(cameraPos, dir, distance, type) )\n\t{\n\t\t\/\/ Missed scene, now just get the sky value...\n\t\tcol = GetSky(dir);\n\t\tcol = GetClouds(col, dir);\n\t}\n\telse\n\t{\n\t\t\/\/ Get world coordinate of landscape...\n\t\tvec3 pos = cameraPos + distance * dir;\n\t\t\/\/ Get normal from sampling the high definition height map\n\t\t\/\/ Use the distance to sample larger gaps to help stop aliasing...\n\t\tfloat p = min(.5, .001+.00005 * distance*distance);\n\t\tvec3 nor  \t= vec3(0.0,\t\t    Terrain(pos.xz).x, 0.0);\n\t\tvec3 v2\t\t= nor-vec3(p,\t\tTerrain(pos.xz+vec2(p,0.0)).x, 0.0);\n\t\tvec3 v3\t\t= nor-vec3(0.0,\t\tTerrain(pos.xz+vec2(0.0,-p)).x, -p);\n\t\tnor = cross(v2, v3);\n\t\tnor = normalize(nor);\n\n\t\t\/\/ Get the colour using all available data...\n\t\tcol = TerrainColour(pos, dir, nor, distance, type);\n\t}\n\n\n\tcol = PostEffects(col, xy);\n\t\n\t#ifdef STEREO\t\n\tcol *= vec3( isCyan, 1.0-isCyan, 1.0-isCyan );\t\n\t#endif\n\t\n\tfragColor=vec4(col,1.0);\n}\n\n\/\/--------------------------------------------------------------------------","name":"","description":"","type":"image"}]}}