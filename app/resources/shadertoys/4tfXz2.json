{"Shader":{"ver":"0.1","info":{"id":"4tfXz2","date":"1437861550","viewed":886,"name":"Cubic Bezier Rectangle","username":"demofox","description":"Using ray marching to render a bezier rectangle.  Raytrace bounding box, raymarch interior.  The control points of the rectangle are 1d, which makes it easier to render, but limits the control points to only moving on the Y axis.","likes":9,"published":3,"flags":0,"tags":["3d","bezier"],"hasliked":0},"renderpass":[{"inputs":[{"id":24,"src":"\/presets\/cube02_0.jpg","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/*\nFor more information, check this out:\nhttp:\/\/blog.demofox.org\/2015\/07\/28\/rectangular-bezier-patches\/\n*\/\n\n#define SHOW_BOUNDINGBOX   0\n#define SHOW_CONTROLPOINTS 0\n\nfloat CP00 = sin(iGlobalTime*0.30) * 0.5 + 0.5;\nfloat CP01 = sin(iGlobalTime*0.10) * 0.5 + 0.5;\nfloat CP02 = sin(iGlobalTime*0.70) * 0.5 + 0.5;\nfloat CP03 = sin(iGlobalTime*0.52) * 0.5 + 0.5;\n\nfloat CP10 = sin(iGlobalTime*0.20) * 0.5 + 0.5;\nfloat CP11 = sin(iGlobalTime*0.40) * 0.5 + 0.5;\nfloat CP12 = sin(iGlobalTime*0.80) * 0.5 + 0.5;\nfloat CP13 = sin(iGlobalTime*0.61) * 0.5 + 0.5;\n\nfloat CP20 = sin(iGlobalTime*0.50) * 0.5 + 0.5;\nfloat CP21 = sin(iGlobalTime*0.90) * 0.5 + 0.5;\nfloat CP22 = sin(iGlobalTime*0.60) * 0.5 + 0.5;\nfloat CP23 = sin(iGlobalTime*0.32) * 0.5 + 0.5;\n\nfloat CP30 = sin(iGlobalTime*0.27) * 0.5 + 0.5;\nfloat CP31 = sin(iGlobalTime*0.64) * 0.5 + 0.5;\nfloat CP32 = sin(iGlobalTime*0.18) * 0.5 + 0.5;\nfloat CP33 = sin(iGlobalTime*0.95) * 0.5 + 0.5;\n\nfloat CPMin =\n    min(CP00,min(CP01,min(CP02,min(CP03,\n    min(CP10,min(CP11,min(CP12,min(CP13,\n    min(CP20,min(CP21,min(CP22,min(CP23,\n    min(CP30,min(CP31,min(CP32,CP33)))))))))))))));    \n\nfloat CPMax =\n    max(CP00,max(CP01,max(CP02,max(CP03,\n    max(CP10,max(CP11,max(CP12,max(CP13,\n    max(CP20,max(CP21,max(CP22,max(CP23,\n    max(CP30,max(CP31,max(CP32,CP33))))))))))))))); \n\n#define FLT_MAX 3.402823466e+38\n\n\/\/=======================================================================================\nfloat QuadraticBezier (float A, float B, float C, float t)\n{\n    float s = 1.0 - t;\n    float s2 = s * s;\n    float t2 = t * t;\n    \n    return A*s2 + B*2.0*s*t + C*t2;\n}\n\n\/\/=======================================================================================\nfloat CubicBezier (float A, float B, float C, float D, float t)\n{\n    float s = 1.0 - t;\n    float s2 = s * s;\n    float s3 = s * s * s;\n    float t2 = t * t;\n    float t3 = t * t * t;\n    \n    return A*s3 + B*3.0*s2*t + C*3.0*s*t2 + D*t3;\n}\n\n\/\/=======================================================================================\nfloat HeightAtPos(vec2 P)\n{\n    float CP0X = CubicBezier(CP00, CP01, CP02, CP03, P.x);\n    float CP1X = CubicBezier(CP10, CP11, CP12, CP13, P.x);\n    float CP2X = CubicBezier(CP20, CP21, CP22, CP23, P.x);\n    float CP3X = CubicBezier(CP30, CP31, CP32, CP33, P.x);\n    \n    return CubicBezier(CP0X, CP1X, CP2X, CP3X, P.y);\n}\n\n\/\/=======================================================================================\nvec3 Gradient (vec2 p)\n{\n    float CP0_ = CubicBezier(CP00, CP01, CP02, CP03, p.x);\n    float CP1_ = CubicBezier(CP10, CP11, CP12, CP13, p.x);\n    float CP2_ = CubicBezier(CP20, CP21, CP22, CP23, p.x);\n    float CP3_ = CubicBezier(CP30, CP31, CP32, CP33, p.x);  \n    float FY1 = CP1_ - CP0_;\n    float FY2 = CP2_ - CP1_;\n    float FY3 = CP3_ - CP2_;\n    float valueY = 3.0 * QuadraticBezier(FY1, FY2, FY3,  p.y);    \n    \n    float CP_0 = CubicBezier(CP00, CP10, CP20, CP30, p.y);\n    float CP_1 = CubicBezier(CP01, CP11, CP21, CP31, p.y);\n    float CP_2 = CubicBezier(CP02, CP12, CP22, CP32, p.y);\n    float CP_3 = CubicBezier(CP03, CP13, CP23, CP33, p.y);  \n    float FX1 = CP_1 - CP_0;\n    float FX2 = CP_2 - CP_1;\n    float FX3 = CP_3 - CP_2;\n    float valueX = 3.0 * QuadraticBezier(FX1, FX2, FX3,  p.x);      \n    \n    return vec3(valueX,-1.0,valueY)*-1.0;\n}\n\n\/\/=======================================================================================\nvec3 NormalAtPos( vec2 p )\n{\n    #if 1\n    return normalize(Gradient(p));\n    #else    \n\tfloat eps = 0.01;\n    vec3 n = vec3( HeightAtPos(vec2(p.x-eps,p.y)) - HeightAtPos(vec2(p.x+eps,p.y)),\n                         2.0*eps,\n                         HeightAtPos(vec2(p.x,p.y-eps)) - HeightAtPos(vec2(p.x,p.y+eps)));\n    return normalize( n );\n\t#endif\n}\n\n\/\/=======================================================================================\nbool RayIntersectAABox (vec3 boxMin, vec3 boxMax, in vec3 rayPos, in vec3 rayDir, out vec2 time)\n{\n\tvec3 roo = rayPos - (boxMin+boxMax)*0.5;\n    vec3 rad = (boxMax - boxMin)*0.5;\n\n    vec3 m = 1.0\/rayDir;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    time = vec2( max( max( t1.x, t1.y ), t1.z ),\n                 min( min( t2.x, t2.y ), t2.z ) );\n\t\n    return time.y>time.x && time.y>0.0;\n}\n\n\/\/=======================================================================================\nfloat RayIntersectSphere (vec4 sphere, in vec3 rayPos, in vec3 rayDir)\n{\n\t\/\/get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    \/\/get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t\/\/exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn -1.0;\n\n\t\/\/calculate discriminant\n\tfloat discr = b * b - c;\n\n\t\/\/a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn -1.0;\n\n\t\/\/ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat collisionTime = -b - sqrt(discr);\n\n\t\/\/if t is negative, ray started inside sphere so clamp t to zero and remember that we hit from the inside\n\tif(collisionTime < 0.0)\n\t\tcollisionTime = -b + sqrt(discr);\n    \n    return collisionTime;\n}\n\n\/\/=======================================================================================\nvec3 DiffuseColor (in vec3 pos)\n{\n\t\/\/ checkerboard pattern\n    return vec3(mod(floor(pos.x * 10.0) + floor(pos.z * 10.0), 2.0) < 1.0 ? 1.0 : 0.4);\n}\n\n\/\/=======================================================================================\nvec3 ShadePoint (in vec3 pos, in vec3 rayDir, float time, bool fromUnderneath)\n{\n\tvec3 diffuseColor = DiffuseColor(pos);\n\tvec3 reverseLightDir = normalize(vec3(1.0,1.0,-1.0));\n\tvec3 lightColor = vec3(0.95,0.95,0.95);\t\n\tvec3 ambientColor = vec3(0.05,0.05,0.05);\n\n\tvec3 normal = NormalAtPos(pos.xz);\n    normal *= fromUnderneath ? -1.0 : 1.0;\n\n    \/\/ diffuse\n\tvec3 color = diffuseColor * ambientColor;\n\tfloat dp = dot(normal, reverseLightDir);\n\tif(dp > 0.0)\n\t\tcolor += (diffuseColor * dp * lightColor);\n    \n    \/\/ specular\n    vec3 reflection = reflect(reverseLightDir, normal);\n    dp = dot(rayDir, reflection);\n    if (dp > 0.0)\n        color += pow(dp, 15.0) * vec3(0.5);\t\t\n    \n    \/\/ reflection (environment mappping)\n    reflection = reflect(rayDir, normal);\n    color += textureCube(iChannel0, reflection).rgb * 0.25;    \n    \n    return color;\n}\n\n\/\/=======================================================================================\nvec3 HandleRay (in vec3 rayPos, in vec3 rayDir, in vec3 pixelColor, out float hitTime)\n{\n\tfloat time = 0.0;\n\tfloat lastHeight = 0.0;\n\tfloat lastY = 0.0;\n\tfloat height;\n\tbool hitFound = false;\n    hitTime = FLT_MAX;\n    bool fromUnderneath = false;\n    \n    vec2 timeMinMax = vec2(0.0);\n    if (!RayIntersectAABox(vec3(0.0,CPMin,0.0), vec3(1.0,CPMax,1.0), rayPos, rayDir, timeMinMax))\n        return pixelColor;\n    \n    time = timeMinMax.x;\n    \n    const int c_numIters = 100;\n    float deltaT = (timeMinMax.y - timeMinMax.x) \/ float(c_numIters);\n    \n    vec3 pos = rayPos + rayDir * time;\n    float firstSign = sign(pos.y - HeightAtPos(pos.xz));\n    \n\tfor (int index = 0; index < c_numIters; ++index)\n\t{\t\t\n\t\tpos = rayPos + rayDir * time;\n        \n        height = HeightAtPos(pos.xz);\n        \n        if (sign(pos.y - height) * firstSign < 0.0)\n        {\n            fromUnderneath = firstSign < 0.0; \n        \thitFound = true;\n\t\t\tbreak;\n        }\n\t\t\n\t\ttime += deltaT;\t\t\n\t\tlastHeight = height;\n\t\tlastY = pos.y;\n    }\n    \n\t\n\tif (hitFound) {\n\t\ttime = time - deltaT + deltaT*(lastHeight-lastY)\/(pos.y-lastY-height+lastHeight);\n\t\tpos = rayPos + rayDir * time;\n\t\tpixelColor = ShadePoint(pos, rayDir, time, fromUnderneath);\n        hitTime = time;\n\t}\n    else\n    {\n        #if SHOW_BOUNDINGBOX\n        \tpixelColor += vec3(0.2);\n        #endif\n    }\n    \n\treturn pixelColor;\n}\n\n\/\/=======================================================================================\nvec3 HandleControlPoints (in vec3 rayPos, in vec3 rayDir, in vec3 pixelColor, inout float hitTime)\n{\n    #if SHOW_CONTROLPOINTS\n    float cpHitTime = RayIntersectSphere(vec4(0.0, CP00, 0.0, 0.01), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(1.0,0.0,0.0);\n    }\n    cpHitTime = RayIntersectSphere(vec4(1.0\/3.0, CP01, 0.0, 0.01), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(1.0,0.0,0.0);\n    }    \n    cpHitTime = RayIntersectSphere(vec4(2.0\/3.0, CP02, 0.0, 0.01), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(1.0,0.0,0.0);\n    }    \n    cpHitTime = RayIntersectSphere(vec4(1.0, CP03, 0.0, 0.01), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(1.0,0.0,0.0);\n    }        \n    \n    \n    cpHitTime = RayIntersectSphere(vec4(0.0, CP10, 1.0\/3.0, 0.01), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(0.0,1.0,0.0);\n    }\n    cpHitTime = RayIntersectSphere(vec4(1.0\/3.0, CP11, 1.0\/3.0, 0.01), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(0.0,1.0,0.0);\n    }    \n    cpHitTime = RayIntersectSphere(vec4(2.0\/3.0, CP12, 1.0\/3.0, 0.01), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(0.0,1.0,0.0);\n    }       \n    cpHitTime = RayIntersectSphere(vec4(1.0, CP13, 1.0\/3.0, 0.01), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(0.0,1.0,0.0);\n    }      \n    \n    \n    cpHitTime = RayIntersectSphere(vec4(0.0, CP20, 2.0 \/ 3.0, 0.01), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(0.0,0.0,1.0);\n    }\n    cpHitTime = RayIntersectSphere(vec4(1.0\/3.0, CP21, 2.0 \/ 3.0, 0.01), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(0.0,0.0,1.0);\n    }    \n    cpHitTime = RayIntersectSphere(vec4(2.0\/3.0, CP22, 2.0 \/ 3.0, 0.01), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(0.0,0.0,1.0);\n    }     \n    cpHitTime = RayIntersectSphere(vec4(1.0, CP23, 2.0 \/ 3.0, 0.01), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(0.0,0.0,1.0);\n    }     \n    \n    \n    cpHitTime = RayIntersectSphere(vec4(0.0, CP30, 1.0, 0.01), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(1.0,1.0,0.0);\n    }\n    cpHitTime = RayIntersectSphere(vec4(1.0\/3.0, CP31, 1.0, 0.01), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(1.0,1.0,0.0);\n    }    \n    cpHitTime = RayIntersectSphere(vec4(2.0\/3.0, CP32, 1.0, 0.01), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(1.0,1.0,0.0);\n    }     \n    cpHitTime = RayIntersectSphere(vec4(1.0, CP33, 1.0, 0.01), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(1.0,1.0,0.0);\n    }       \n    #endif\n    \n    return pixelColor;\n}\n\n\/\/=======================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\t\n    \/\/ keep it from degenerating when all control points are the same - like at the start!\n    CPMin -= 0.005;\n    CPMax += 0.005;\n    \n    \/\/----- camera\n    vec2 mouse = iMouse.xy \/ iResolution.xy;\n\n    vec3 cameraAt \t= vec3(0.5,0.5,0.5);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14 + iGlobalTime * 0.25;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.5;\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 3.0;\n    cameraPos += vec3(0.5,0.5,0.5);\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y \/ iResolution.x;\n    float cameraDistance\t= 6.0;  \/\/ intuitively backwards!\n\t\n\t\t\n\t\/\/ Objects\n\tvec2 rawPercent = (fragCoord.xy \/ iResolution.xy);\n\tvec2 percent = rawPercent - vec2(0.5,0.5);\n\t\n\tvec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n\t\t\t\t   - (cameraLeft * percent.x * cameraViewWidth)\n\t\t           + (cameraUp * percent.y * cameraViewHeight);\n\tvec3 rayDir = normalize(rayTarget);\n\t\n\t\n    float hitTime = FLT_MAX;\n\tvec3 pixelColor = textureCube(iChannel0, rayDir).rgb;\n    pixelColor = HandleRay(cameraPos, rayDir, pixelColor, hitTime);\n    pixelColor = HandleControlPoints(cameraPos, rayDir, pixelColor, hitTime);\n    \n    fragColor = vec4(clamp(pixelColor,0.0,1.0), 1.0);\n}","name":"","description":"","type":"image"}]}}