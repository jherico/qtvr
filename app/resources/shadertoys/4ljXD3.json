{"Shader":{"ver":"0.1","info":{"id":"4ljXD3","date":"1446942712","viewed":435,"name":"glass ball 2","username":"archee","description":"glass ball with stuff inside it. Internal and external reflections, refractions.<br\/>Mouse rotates camera. Runs well in full screen.","likes":10,"published":3,"flags":0,"tags":["refraction","glass"],"hasliked":0},"renderpass":[{"inputs":[{"id":9,"src":"\/presets\/tex08.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":27,"src":"\/presets\/cube05_0.png","ctype":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"vec3 sunDir = normalize(vec3(0.0,0.3,1.0));\nfloat refractratio = 1.5;\nfloat heightAboveGround = 0.0;\n\n\/\/ rotate camera\n#define pee 3.141592653\nvec3 pos;\nvec3 dir;\n \nvec3 backGround2() \/\/ unused checkerboard\n{\n\tif (dir.y>0.0) return vec3(1,1,1);\n\tvec2 floorcoords = pos.xz + dir.xz*(-pos.y\/dir.y);\n\tvec2 t = (fract(floorcoords.xy*0.5))-vec2(0.5,0.5);\n\treturn vec3(1,1,1) - vec3(0.6,0.3,0)*float(t.x*t.y>0.0);\n}\n\nfloat texture2(vec2 pos)\n{\n    return texture2D(iChannel1,pos\/2.0).z;\n}\n\nfloat texture3(vec2 pos)\n{\n    pos *=2.0;\n    if (fract(pos.x)<0.05) return 0.0;\n    if (fract(pos.y)<0.05) return 0.0;\n    return 1.0;\n}\n\nfloat texture1(vec2 pos) \/\/ let's steal his heart \/\/ unused\n{\n\tfloat rot = pos.x;\n\tpos.x += pos.y*0.3; \/\/ rotate and scale to misalign\n\tpos.y -= rot*0.3;\n\tpos=(fract((pos))-vec2(0.5,0.7))*0.8; \/\/ fract makes it repetitive, 0.8 scales the heart size\n\tfloat f1 = abs(atan(pos.x,pos.y)\/pee);\n\treturn (f1*6.5 - f1*f1*11.0 + f1*f1*f1*5.0)\/(6.0-f1*5.0)-length(pos);\n}\n\n\nvec3 sky(vec3 dir)\n{\n\tfloat f = max(dir.y,0.0);\n\tvec3 color = 1.0-vec3(1,0.85,0.7)*f;\n\tcolor *= (dir.z*0.2+0.8)*1.7;\n\t\n\tif (dot(sunDir,dir)>0.0)\n\t{\n\t f = max(length(cross(sunDir,dir))*10.0,1.0);\n\t\t\n\t color += vec3(1,0.9,0.7)*40.0\/(f*f*f*f);\n\t}\n\treturn color;\n\t\n}\n\nvec3 backGround(vec3 dir) \/\/ sky and floor texture with fog\n{\n \tif (dir.y>=0.0) return sky(dir);\n \tvec3 raypos2 = pos - dir*((pos.y+heightAboveGround) \/ dir.y);\n\tfloat fog = exp(length(raypos2)\/-20.0);\n    \n    float sunshadow = 1.0;\n    \n    if (length(cross(  raypos2-vec3(0.,1.,0.),sunDir))<1.0) sunshadow=0.6;\n    \n \treturn sky(dir)*(1.0-fog)+(sunshadow*texture2D(iChannel1,raypos2.xz\/4.0).xyz*0.6)*fog;\n    return sky(dir)*(1.0-fog)+(sunshadow*vec3(0.9,0.7,0.6)*0.4*((clamp(texture2(raypos2.xz)*10.0,0.5,1.0))))*fog;\n}\n\nvec3 backGround3(vec3 dir) \n{\n    vec3 td = textureCube(iChannel0, dir).xyz;\n\treturn td * pow(length(td)*sqrt(1.0\/3.0),1.);\n}\n\n\nvec3 rotatex(vec3 v,float anglex)\n{\n\tfloat t;\n\tt =   v.y*cos(anglex) - v.z*sin(anglex);\n\tv.z = v.z*cos(anglex) + v.y*sin(anglex);\n\tv.y = t;\n\treturn v;\n}\n\nvec3 rotcam(vec3 v)\n{\n    float anglex = sin((iGlobalTime-3.0)*0.3)*0.5+0.15;\n    float angley = iGlobalTime*0.2-1.0;\n    \n    if (iMouse.x!=0.0) \/\/ use mouse only if user has clicked the screen\n    {\n    \tanglex = (0.5 - iMouse.y\/iResolution.y)*pee*1.2; \/\/ mouse cam\n    \tangley = (-iMouse.x\/iResolution.x+0.5)*pee*2.0;\n    }\n\n\tfloat t;\n\tv = rotatex(v,anglex);\n\t\n\tt = v.x * cos(angley) - v.z*sin(angley);\n\tv.z = v.z*cos(angley) + v.x*sin(angley);\n\tv.x = t;\n\treturn v;\n}\n\nfloat side; \/\/ 1 for raytracing outside glass,  -1 for raytracing inside glass\n\n\n\nvec3 glassColorFunc(float dist) \/\/ exponentioanly turn light green as it travels inside glass (real glass has this porperty)\n{\n    dist*=.4;\n\tif(side>0.) return vec3(1,1,1);\n\treturn vec3(exp(dist*-0.4),exp(dist*-0.05),exp(dist*-0.2));\n}\n\n\nvec3 intersectPos;\nvec3 intersectNormal;\n\nfloat intersectsphere(vec3 center,float rad)\n{\n    vec3 rp = pos-center;\n    rp\/=rad;\n    rp -= dir*dot(dir,rp);\n    if (length(rp)>1.0) return 0.;\n    \n    float goback = sqrt(1.0-dot(rp,rp));\n    rp -= side*dir*goback;\n    \n    vec3 ip = rp*rad + center;\n    \n    if (dot(dir,ip-intersectPos)<0.0) \/\/ check if this is the closest intersection\n    { \n        intersectNormal = rp;\n    \tintersectPos = ip;\n    }\n    return 1.;\n}\n\nvec3 get()\n{\n    side = 1.;\n    vec3 colorSum = vec3(0.);\n    vec3 colormul = vec3(1.);\n    \n    \n        \n    intersectPos = dir*1e10;\n    if (intersectsphere(vec3(0.,1.,0.),1.0)!=0.)  \/\/ sphere hit by initial camera ray\n        \n    {\n\n        vec3 outside = normalize(reflect(dir,intersectNormal));\n        float f=min(1.-dot(outside,intersectNormal),1.0);\n        float fresnel = 0.05+0.95*pow(f,5.);\n\n        colorSum += backGround(outside)*colormul*fresnel;\n        colormul *= 1.-fresnel;\n        \n        side=-1.;\n        pos = intersectPos;   \/\/ continue at the intersection point\n        dir = refract(dir,intersectNormal,1.0\/refractratio);  \/\/ light gets inside the sphere\n        \n        for(int p=0;p<4;p++) \/\/ bouncing inside sphere\n        {\n            intersectPos = dir*1e10;\n            side=1.;\n            for(int k=0;k<9;k++)\n             intersectsphere(vec3(0.8-0.1*float(k),0.7,0.),0.1);\n            \n            intersectsphere(vec3(-0.3,1.3,0.),0.1);\n            intersectsphere(vec3(0.5,1.4,0.),0.033);\n            intersectsphere(vec3(0.5,1.6,0.),0.033);\n            intersectsphere(vec3(0.2,1,0.8),0.1);\n            intersectsphere(vec3(0.2,1,-0.5),0.1);\n            intersectsphere(vec3(0.2,1,-0.7),0.14);\n\n            if (length(intersectPos)<1e9)\n            {\n                colormul *= glassColorFunc(length(intersectPos-pos));\n                colorSum += (dot(intersectNormal,sunDir)*0.5+0.5)*vec3(1.0,0.3,0.1)*colormul*0.8;\n                return colorSum;\n            }\n            \n            side=-1.;\n            intersectsphere(vec3(0.,1.,0.),1.0);\n            colormul *= glassColorFunc(length(intersectPos-pos));\n            pos = intersectPos;\n            \n            vec3 outside = normalize(refract(dir,-intersectNormal ,refractratio));\n            \n            float f=min(1.-dot(outside,intersectNormal),1.0);\n            float fresnel = 0.05+0.95*pow(f,5.);\n            colorSum += backGround(outside)*colormul*(1.-fresnel);\n            colormul *=fresnel;\n            dir = reflect(dir,-intersectNormal);\n            \n        }\n    }\n    else return backGround(dir); \/\/ initial camera ray missed sphere, goes directly to background\n    \n    return colorSum;\n}\n\n\t\t\nfloat func(float x) \/\/ the func for HDR\n{\n\treturn x\/(x+3.0)*3.0;\n}\nvec3 HDR(vec3 color)\n{\n\tfloat pow = length(color);\n\treturn color * func(pow)\/pow*1.2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat brightNess = min(iGlobalTime\/5.0,1.0);\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\tpos = vec3(0,1.0,0);\n\tdir = vec3(uv*2.0-1.0,2.5);\n\tdir.y *= 9.0\/16.0; \/\/ wide screen\n\t\n\tdir = normalize(rotcam(dir));\n    \n\tpos -= rotcam(vec3(0,0,5.6)); \/\/ back up from subject\n    if (pos.y<-heightAboveGround) \/\/ under ground\n    {\n        vec3 dir2 = normalize(rotcam(vec3(0.,0.,1.)));\n        pos = pos - dir2*((pos.y+heightAboveGround) \/ dir2.y);\n    }\n\t\n\t\n\t\t\n\tfragColor = vec4(HDR(get()*brightNess),1.0); \n}","name":"","description":"","type":"image"}]}}