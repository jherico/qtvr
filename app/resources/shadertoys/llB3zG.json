{"Shader":{"ver":"0.1","info":{"id":"llB3zG","date":"1429880393","viewed":967,"name":"Ray Marching Experiment 22","username":"aiekick","description":"Pattern based on IQ shader https:\/\/www.shadertoy.com\/view\/Xd2GR3 <br\/>Thanks to public_int_i\/ethan for godray adding<br\/>use mouse y to change pattern and use mouse x to change camera distance","likes":15,"published":3,"flags":0,"tags":["ray","experiment","marching","22"],"hasliked":0},"renderpass":[{"inputs":[{"id":22,"src":"\/presets\/cube00_0.jpg","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Stephane Cuillerdier - Aiekick\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ use mouse y to change pattern\n\/\/ use mouse x to change camera distance\n\nconst vec2 RMPrec = vec2(0.5, 0.001); \/\/ ray marching tolerance precision \/\/ low, high\nconst vec2 DPrec = vec2(1e-5, 10.); \/\/ ray marching distance precision \/\/ low, high\n    \nfloat pattern = 3.; \/\/ pattern value 1. to 5. use mouse y to change\n\nfloat kernelRadius = 4.5; \/\/ radius of kernel\n\nfloat sphereThick = 0.02; \/\/ thick of sphere plates\nfloat sphereRadius = 6.; \/\/ radius of sphere\n\nfloat norPrec = 0.01; \/\/ normal precision \n\n\/\/ public_int_i\/ethan adding\nconst int godrayIter = 128;\nconst float godrayIntensity = .06;\nconst float godrayPrecision = .05;\n\n\/\/ light\nconst vec3 LCol = vec3(0.8,0.5,0.2);\nconst vec3 LPos = vec3(-0.6, 0.7, -0.5);\nconst vec3 LAmb = vec3( 0. );\nconst vec3 LDif = vec3( 1. , 0.5, 0. );\nconst vec3 LSpe = vec3( 0.8 );\n\n\/\/ material\nconst vec3 MCol = vec3(0.);\nconst vec3 MAmb = vec3( 0. );\nconst vec3 MDif = vec3( 1. , 0.5, 0. );\nconst vec3 MSpe = vec3( 0.6, 0.6, 0.6 );\nconst float MShi =30.;\n    \n#define mPi 3.14159\n#define m2Pi 6.28318\n\nvec2 uvs(vec3 p)\n{\n    p = normalize(p);\n    vec2 tex2DToSphere3D;\n    tex2DToSphere3D.x = 0.5 + atan(p.z, p.x) \/ (m2Pi*1.1547);\n    tex2DToSphere3D.y = 0.5 - asin(p.y) \/ (mPi*1.5);\n    return tex2DToSphere3D;\n}\n\n\/\/ Hex Pattern based on IQ Shader https:\/\/www.shadertoy.com\/view\/Xd2GR3\nfloat hex(vec2 p, int i)\n{\n    p*=50.;\n    \n    vec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\tvec2 pi = floor(q);\n\tvec2 pf = fract(q);\n\n    \/\/ 3. => hexagon\n    \/\/ 4. => brain pattern\n\tfloat v = mod(pi.x + pi.y, pattern);\n\n    float ca = step(1.,v);\n\tfloat cb = step(2.,v);\n\tvec2  ma = step(pf.xy,pf.yx);\n\t\n    float e = dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) );\n\n    float hex = i==0?clamp(0.,0.2,e):1.-smoothstep(e, 0.1, 0.0);\n    \n    return hex*.2;\n}\n\nvec2 map(vec3 p)\n{\n    vec2 res = vec2(0.);\n    \n    float t = sin(iGlobalTime*.5)*.5+.5;\n    \n    float sphereOut = length(p) -sphereRadius - hex(uvs(p.xyz),0);\n    res = vec2(sphereOut, 1.);\n    \n    float sphereIn = length(p) - sphereRadius - sphereThick;\n    if (-sphereIn>res.x) \n        res = vec2(-sphereIn, 2.);\n    \n    float kernel = length(p) - kernelRadius;\n    if (kernel<res.x)\n        res = vec2(kernel,3.);\n    \n    return res;\n}\n\nvec3 nor(vec3 p, float prec)\n{\n    vec2 e = vec2(prec, 0.);\n    \n    vec3 n;\n    \n    n.x = map(p+e.xyy).x - map(p-e.xyy).x; \n    n.y = map(p+e.yxy).x - map(p-e.yxy).x; \n    n.z = map(p+e.yyx).x - map(p-e.yyx).x;  \n    \n    return normalize(n); \n}\n\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. \/ 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. \/ 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)\/255.;\n    if (Temp < 1000.) col *= Temp\/1000.;\n   \treturn col;\n}\n\nvec3 ads( vec3 p, vec3 n )\n{\n    vec3 ldif = normalize( LPos - p);\n    vec3 vv = normalize( vec3(0.) - p );\n    vec3 refl = reflect( vec3(0.) - ldif, n );\n    \n    vec3 amb = MAmb*LAmb+ blackbody(2000.);\n    vec3 dif = max(0., dot(ldif, n.xyz)) * MDif * LDif;\n    vec3 spe = vec3( 0. );\n    if( dot(ldif, vv) > 0.)\n        spe = pow(max(0., dot(vv,refl)),MShi)*MSpe*LSpe;\n    \n    return amb*1.2 + dif*1.5 + spe*0.8;\n}\n\n\/\/ thanks to public_int_i\/ethan for his adding\n\/\/ in shader https:\/\/www.shadertoy.com\/view\/MtSGzy\nvec4 god(vec4 c, vec3 ro, vec3 rd ) \n{\n    float sc = dot(ro, ro) - 48.;\n    float sb = dot(rd, ro);\n\n    float sd = sb*sb - sc;\n    float st = -sb - sqrt(abs(sd));\n\n    float r = 6.92839855;\n    if (!(sd < 0.0 || st < 0.0)) \n    {\n        float gr = 0.;\n\n        ro += rd*st;\n        \n        float rlen = r - length(ro);\n\n        for (int i = 0; i < godrayIter; i++) \n        {\n            if (hex(uvs(ro),0) < .04) \n                gr+=rlen;\n            \n            ro += rd * godrayPrecision;\n            \n            rlen = r -length(ro);\n            \n            if (!(rlen > 0. && rlen < 1.)) break;\n        }\n        \n        c.xyz += LCol * godrayIntensity * gr;\n    }\n    return c;\n}\n\nvec4 scn(vec4 col, vec3 ro, vec3 rd)\n{\n    vec2 s = vec2(DPrec.x);\n    float d = 0.;\n    vec3 p = ro+rd*d;\n    vec4 c = col;\n    \n    float b = 0.35;\n    \n    float t = 1.1*(sin(iGlobalTime*.3)*.5+.6);\n    \n    for(int i=0;i<200;i++)\n    {\n    \tif(s.x<DPrec.x||s.x>DPrec.y) break;\n        s = map(p);\n        d += s.x*(s.x>DPrec.x?RMPrec.x:RMPrec.y);\n        p = ro+rd*d;\n    }\n    \n    if (s.x<DPrec.x)\n    {\n        vec3 n = nor(p, norPrec); \n      \tvec3 ray = reflect(rd, n);\n\t\t\n        if ( s.y < 1.5) \/\/ ext\n        {\n            vec3 cuberay = textureCube(iChannel0, ray).rgb * 0.5;\n            c.rgb = MCol + cuberay + pow(b, 25.);\n        }\n        else if ( s.y < 2.5) \/\/ int\n        {\n            c.rgb = ads(p,n);\n        }\n        else if ( s.y < 3.5) \/\/ kernel\n        {\n            float b = dot(n,normalize(ro-p))*0.8;\n            c = (b*vec4(blackbody(2000.),0.2)+pow(b,0.2))*(1.0-d*.01);\n        }\n    }\n    else\n    {\n       \tc = textureCube(iChannel0, rd);\n    }\n    \n    return c;\n}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cu, vec3 org, float persp)\n{\n\tvec3 rorg = normalize(org-ro);\n    vec3 u =  normalize(cross(cu, rorg));\n    vec3 v =  normalize(cross(rorg, u));\n    vec3 rd = normalize(rorg + u*uv.x + v*uv.y);\n    return rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 s = iResolution.xy;\n    vec2 g = fragCoord.xy;\n    vec2 uv = (2.*g-s)\/s.y;\n    vec2 m = iMouse.xy;\n    \n    float t = iGlobalTime*0.2;\n    float ts = sin(t)*.5+.5;\n    \n    float axz = -t; \/\/ angle XZ\n    float axy = .8; \/\/ angle XY\n    float cd = 7.5;\/\/*ts; \/\/ cam dist to scene origine\n    \n    if ( iMouse.z>0.) cd = 10. * m.x\/s.x; \/\/ mouse x axis \n    if ( iMouse.z>0.) pattern = floor(6. * m.y\/s.y); \/\/ mouse y axis \n    \n    float ap = 1.; \/\/ angle de perspective\n    vec3 cu = vec3(0.,1.,0.); \/\/ cam up \n    vec3 org = vec3(0., 0., 0.); \/\/ scn org\n    vec3 ro = vec3(cos(axz),sin(axy),sin(axz))*cd; \/\/ cam org\n    \n    vec3 rd = cam(uv, ro, cu, org, ap);\n    \n    vec4 c = vec4(0.,0.,0.,1.); \/\/ col\n    \n    c = scn(c, ro, rd);\/\/scene\n\t\n    c = god(c, ro, rd);\/\/god rays\n    \n    fragColor = c;\n}\n","name":"","description":"","type":"image"}]}}