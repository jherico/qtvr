{"Shader":{"ver":"0.1","info":{"id":"ldSGzR","date":"1382482572","viewed":3009,"name":"Screen space bump mapping","username":"iq","description":"Mikkelsen's technique for Bump Mapping Unparametrized Surfaces  (pretty much copy & pasted).","likes":34,"published":3,"flags":0,"tags":["3d","bump","bumpmapping","mikkelsen"],"hasliked":0},"renderpass":[{"inputs":[{"id":2,"src":"\/presets\/tex01.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Mikkelsen's technique for Bump Mapping Unparametrized Surfaces \n\/\/ https:\/\/dl.dropboxusercontent.com\/u\/55891920\/papers\/mm_sfgrad_bump.pdf\n\/\/ Pretty much copy & pasted, with minor changes. It aliases quite a bit :(\n\t\n\n\/\/===============================================================================================\n\/\/===============================================================================================\n\/\/===============================================================================================\n\/\/===============================================================================================\n\/\/===============================================================================================\n\nvec3 doBump( in vec3 pos, in vec3 nor, in float signal, in float scale )\n{\n    \/\/ build frame\t\n    vec3  s = dFdx( pos );\n    vec3  t = dFdy( pos );\n    vec3  u = cross( t, nor );\n    vec3  v = cross( nor, s );\n    float d = dot( s, u );\n\n    \/\/ compute bump\t\n    float bs = dFdx( signal );\n    float bt = dFdy( signal );\n\t\n    \/\/ offset normal\t\n#if 1\n\treturn normalize( nor - scale*(bs*u + bt*v)\/d );\n#else\n    \/\/ if you cannot ensure the frame is not null\t\n\tvec3 vSurfGrad = sign( d ) * ( bs * u + bt * v );\n    return normalize( abs(d)*nor - scale*vSurfGrad );\n#endif\n}\n\n\/\/===============================================================================================\n\/\/===============================================================================================\n\/\/===============================================================================================\n\/\/===============================================================================================\n\/\/===============================================================================================\nfloat softShadowSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = sph.xyz - ro;\n    float b = dot( oc, rd );\n\t\n    float res = 1.0;\n    if( b>0.0 )\n    {\n        float h = dot(oc,oc) - b*b - sph.w*sph.w;\n        res = clamp( 2.0 * h \/ b, 0.0, 1.0 );\n    }\n    return res;\n}\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec4 x = texture2D( sam, p.yz );\n\tvec4 y = texture2D( sam, p.zx );\n\tvec4 z = texture2D( sam, p.xy );\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) \/ iResolution.y;\n\n\tfloat bump = smoothstep( -0.9, -0.6, cos( 0.5*iGlobalTime ) );\n\t\n     \/\/ camera movement\t\n\tfloat an = 3.1 + 0.25*iGlobalTime + iMouse.x\/200.0;\n\tvec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 1.0, 0.0 );\n    \/\/ camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t\/\/ create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    \/\/ sphere center\t\n\tvec3 sc = vec3(0.0,1.0,0.0);\n\n\tvec3 mate = vec3(0.0);\n\t\n    \/\/ raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tfloat occ = 1.0;\n\tvec3  pos = vec3(0.0);\n\t\n\t\/\/ raytrace-plane\n\tfloat h = (0.0-ro.y)\/rd.y;\n\tif( h>0.0 ) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.0,1.0,0.0); \n\t\tpos = ro + h*rd;\n\t\t\n\t\tvec3 di = sc - pos;\n\t\tfloat l = length(di);\n\t\tocc = 1.0 - dot(nor,di\/l)*1.0*1.0\/(l*l); \n\t\t\n\t\t\n\t\tmate = texture2D( iChannel0, 0.25*pos.zx, .3*l ).xyz;\n\t\tnor = doBump( pos, nor, dot(mate,vec3(0.33)), 0.1*bump );\n\t}\n\n\t\/\/ raytrace-sphere\n\tvec3  ce = ro - sc;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - 1.0;\n\th = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\th = -b - sqrt(h);\n\t\tif( h<tmin ) \n\t\t{ \n\t\t\ttmin=h; \n            pos = ro + tmin*rd;\n\t\t\tnor = normalize(ro+h*rd-sc); \n\t\t\tmate = texcube( iChannel0, 0.25*pos, nor ).xyz;\n\t\t    nor = doBump( pos, nor, dot(mate,vec3(0.33)), 0.025*bump );\n\n\t\t\tocc = 0.5 + 0.5*nor.y;\n\t\t}\n\t}\n\n    \/\/ shading\/lighting\t\n\tvec3 col = vec3(0.9);\n\tif( tmin<100.0 )\n\t{\n\t    pos = ro + tmin*rd;\n\t\t\n\t\tfloat sh = softShadowSphere( pos, vec3(0.57703), vec4(sc,1.0) );\n        vec3 lin = vec3(0.8,0.7,0.6)*sh * clamp(dot(nor,vec3(0.57703)),0.0,1.0);\n\t\t     lin += occ*vec3(0.2,0.3,0.4);\n\t\t     lin += sh*0.5*pow(clamp(dot(reflect(rd,nor),vec3(0.57703)),0.0,1.0),12.0);\n\t\tcol = mate * lin;\n\t\tcol = mix( col, vec3(0.9), 1.0-exp( -0.003*tmin*tmin ) );\n\t}\n\t\n\tcol = sqrt( col );\n\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}