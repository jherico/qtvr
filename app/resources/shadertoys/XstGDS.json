{"Shader":{"ver":"0.1","info":{"id":"XstGDS","date":"1452005170","viewed":391,"name":"Black and White Spheres","username":"PauloFalcao","description":"USE YOUR MOUSE!!!<br\/><br\/>A variation of Cubes and Spheres (black and white version)<br\/>With stochastic sampling anti-aliasing<br\/>Using buffers for accumulation<br\/><br\/>Original made in Jan 2012 for glslsandbox - http:\/\/glslsandbox.com\/e#1215.0<br\/>","likes":26,"published":3,"flags":32,"tags":["antialiasing","dof"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Black and White Spheres \/ Cubes with anti-aliasing and dof using buffers\n\/\/ by @paulofalcao\n\/\/\n\/\/ Original made in Jan 2012 for glslsandbox\n\/\/\n\/\/ http:\/\/glslsandbox.com\/e#1215.0\n\/\/ \n\/\/ ================================\n\/\/\n\/\/ A variation of Cubes and Spheres (black and white version)\n\/\/ With stochastic sampling anti-aliasing\n\/\/ Using the backbuffer for acumulation\n\/\/\n\/\/ I love Monte Carlo rendering tecniques! :)\n\/\/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv=fragCoord.xy\/iResolution.xy;\n\tvec4 c=texture2D(iChannel0,uv);\n\tfragColor=c;\n}\n","name":"","description":"","type":"image"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Black and White Spheres \/ Cubes with anti-aliasing and dof using buffers\n\/\/ by @paulofalcao\n\/\/\n\/\/ Original made in Jan 2012 for glslsandbox\n\/\/\n\/\/ http:\/\/glslsandbox.com\/e#1215.0\n\/\/ \n\/\/ ================================\n\/\/\n\/\/ A variation of Cubes and Spheres (black and white version)\n\/\/ With stochastic sampling anti-aliasing\n\/\/ Using the backbuffer for acumulation\n\/\/\n\/\/ I love Monte Carlo rendering tecniques! :)\n\/\/\n\n#define MAXAA 120.0\n\n\/\/Util Start\nfloat PI=3.14159265;\n\nfloat time=mod(iGlobalTime,20.0);\/\/After some time some artifacts appear\n\nvec2 ObjUnion(\n  in vec2 obj0,\n  in vec2 obj1)\n{\n  if (obj0.x<obj1.x)\n    return obj0;\n  else\n    return obj1;\n}\n\nvec2 sim2d(\n  in vec2 p,\n  in float s)\n{\n   vec2 ret=p;\n   ret=p+s\/2.0;\n   ret=fract(ret\/s)*s-s\/2.0;\n   return ret;\n}\n\nvec3 stepspace(\n  in vec3 p,\n  in float s)\n{\n  return p-mod(p-s\/2.0,s);\n}\n\nvec3 phong(\n  in vec3 pt,\n  in vec3 prp,\n  in vec3 normal,\n  in vec3 light,\n  in vec3 color,\n  in float spec,\n  in vec3 ambLight)\n{\n   vec3 lightv=normalize(light-pt);\n   float diffuse=dot(normal,lightv);\n   vec3 refl=-reflect(lightv,normal);\n   vec3 viewv=normalize(prp-pt);\n   float specular=pow(max(dot(refl,viewv),0.0),spec);\n   return (max(diffuse,0.0)+ambLight)*color+specular;\n}\n\nvec2 rand3d_2d(vec3 co){\n    return vec2(\n      fract(sin(dot(co.xyz,vec3(27.2344,98.2142,57.2324)))*43758.5453)-0.5,\n      fract(cos(dot(co.xyz,vec3(34.7483,42.8534,12.1234)))*53978.3542)-0.5);\n}\nfloat rand3d_1d(vec3 co){\n    return fract(sin(dot(co.xyz,vec3(27.2344,98.2142,57.2324)))*43758.5453)-0.5;\n}\n\n\/\/Util End\n\n\/\/Scene Start\n\nvec2 obj(in vec3 p)\n{ \n  vec3 fp=stepspace(p,2.0);;\n  float d=sin(fp.x*0.3+0.5*4.0)+cos(fp.z*0.3+0.5*2.0);\n  p.y=p.y+d;\n  p.xz=sim2d(p.xz,2.0);\n  float c1=length(max(abs(p)-vec3(0.6,0.6,0.6),0.0))-0.35;\n  float c2=length(p)-1.0;\n  float cf=sin(0.5)*0.5+0.5;\n  return vec2(mix(c1,c2,cf),1.0);\n}\n\nvec3 obj_c(in vec3 p){\n  p=fract((p+1.0)\/4.0);\n  p.x=p.x>.5?-p.x:p.x;\n  p.x=p.z>.5?-p.x:p.x;  \n  return p.x>.0?vec3(0):vec3(1);   \n}\n\n\/\/Scene End\n\nfloat raymarching(\n  in vec3 prp,\n  in vec3 scp,\n  in int maxite,\n  in float precis,\n  in float startf,\n  in float maxd,\n  out float objid)\n{ \n  const vec3 e=vec3(0.1,0,0.0);\n  vec2 s=vec2(startf,0.0);\n  vec3 c,p,n;\n  float f=startf;\n  for(int i=0;i<256;i++){\n    if (abs(s.x)<precis||f>maxd||i>maxite) break;\n    f+=s.x;\n    p=prp+scp*f;\n    s=obj(p);\n    objid=s.y;\n  }\n  if (f>maxd) objid=-1.0;\n  return f;\n}\n\n\nvec3 camera(\n  in vec3 prp,\n  in vec3 vrp,\n  in vec3 vuv,\n  in float vpd,\n  out vec3 u,\n  out vec3 v)\n{\n  vec2 rnd=rand3d_2d(vec3(gl_FragCoord.xy,time));\n  vec2 vPos=-1.0+2.0*(gl_FragCoord.xy+rnd)\/iResolution.xy;\n  vec3 vpn=normalize(vrp-prp);\n  u=normalize(cross(vuv,vpn));\n  v=cross(vpn,u);\n  vec3 scrCoord=prp+vpn*vpd+vPos.x*u*iResolution.x\/iResolution.y+vPos.y*v;\n  return normalize(scrCoord-prp);\n}\n\nvec3 normal(in vec3 p)\n{\n  \/\/tetrahedron normal\n  const float n_er=0.01;\n  float v1=obj(vec3(p.x+n_er,p.y-n_er,p.z-n_er)).x;\n  float v2=obj(vec3(p.x-n_er,p.y-n_er,p.z+n_er)).x;\n  float v3=obj(vec3(p.x-n_er,p.y+n_er,p.z-n_er)).x;\n  float v4=obj(vec3(p.x+n_er,p.y+n_er,p.z+n_er)).x;\n  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\n}\n\nvec3 render(\n  in vec3 prp,\n  in vec3 scp,\n  in int maxite,\n  in float precis,\n  in float startf,\n  in float maxd,\n  in vec3 background,\n  in vec3 light,\n  in float spec,\n  in vec3 ambLight,\n  out vec3 n,\n  out vec3 p,\n  out float f,\n  out float objid)\n{ \n  objid=-1.0;\n  f=raymarching(prp,scp,maxite,precis,startf,maxd,objid);\n  if (objid>-0.5){\n    p=prp+scp*f;\n    vec3 c=obj_c(p);\n    n=normal(p);\n    vec3 cf=phong(p,prp,n,light,c,spec,ambLight);\n    return vec3(cf);\n  }\n  f=maxd;\n  return vec3(background); \/\/background color\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n \n  vec2 position = ( gl_FragCoord.xy \/ iResolution.xy );\n  vec4 backpixel = texture2D(iChannel0, position);\t\n\t\n  \/\/Camera animation\n  const vec3 vuv=vec3(0,1,0);\n  const vec3 vrp=vec3(0.0,0.0,0.0);\n\n  float mx=(iMouse.x\/iResolution.x)*PI*2.0;\n  float my=(iMouse.y\/iResolution.y)*PI\/2.01;\n  \n  \/\/1st img fix  \n  if (mx==0.0) mx=4.0; if (my==0.0) my=0.45;\n  \n  \n  vec3 prp=vrp+vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*12.0; \/\/Trackball style camera pos\n  const float vpd=2.0;\n  vec3 light=prp+vec3(5.0,0,5.0);\n  \n  \n  vec3 u,v;\n  vec3 scp=camera(prp,vrp,vuv,vpd,u,v); \n\n  \/\/Depth of Field using a flat field lens and disk sampling for circle of confusion\n  \/\/\n  \/\/The focus is a plane, i think it's nice this way\n  \/\/The focus can also be curved using just the distance to the camera\n  \/\/Or just a point\n  \/\/\n  \/\/8bits color depth is not the best for this kind of stuff :(\n  \/\/We need a floating point target for pretty bokeh and better convergence...\n  \/\/\n  \/\/ UPDATE 2016 with Shadertoy - Now we have floating point targets!!! :)\n  \/\/\n  vec3 vp=vrp-prp;\n  vec3 focuspoint=prp+scp*(dot(vp,vp)\/dot(vp,scp)); \/\/flat field lens\n  vec2 rnd=rand3d_2d(vec3(position*time,time))*1.0+0.5;\n  rnd=vec2(sqrt(rnd.x)*cos(rnd.y),sqrt(rnd.x)*sin(rnd.y)); \/\/random disk\n  prp=prp+scp*1.0+rnd.x*u+rnd.y*v;\n  scp=normalize(focuspoint-prp);\n\n  vec3 n,p;\n  float f,o;\n  const float maxe=0.01;\n  const float startf=0.1;\n  const vec3 backc=vec3(0.0,0.0,0.0);\n  const float spec=8.0;\n  const vec3 ambi=vec3(0.1,0.1,0.1);\n  \n  vec3 c1=render(prp,scp,256,maxe,startf,60.0,backc,light,spec,ambi,n,p,f,o);\n  c1=c1*max(1.0-f*.015,0.0);\n  vec3 c2=backc;\n  if (o>0.5){\n    scp=reflect(scp,n);\n    c2=render(p+scp*0.05,scp,32,maxe,startf,10.0,backc,light,spec,ambi,n,p,f,o);\n  }\n  c2=c2*max(1.0-f*.1,0.0);\n  fragColor=vec4(c1.xyz*0.75+c2.xyz*0.25,1.0)*(1.0\/MAXAA)+backpixel*((MAXAA-1.0)\/MAXAA);\n  \n}","name":"","description":"","type":"buffer"}]}}