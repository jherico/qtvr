{"Shader":{"ver":"0.1","info":{"id":"XtlXRs","date":"1438990924","viewed":749,"name":"metan grid","username":"miloszmaki","description":"experimenting with raymarching","likes":2,"published":3,"flags":0,"tags":["3d","raymarching"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"const int RAYMARCH_ITER = 50;\nconst float RAYMARCH_EPS = 0.01;\nconst float PI = 3.14159265;\n\nfloat dPlane(vec3 p) { return p.y; }\nfloat dSphere(vec3 p, float r) { return length(p) - r; }\nfloat dBox(vec3 p, vec3 s) { return length(max(abs(p) - s, 0.)); }\n\nvec2 dUnion(vec2 d1, vec2 d2) { return (d1.x < d2.x) ? d1 : d2; }\n\nvec3 pMov(vec3 p, vec3 t) { return p - t; }\nvec3 pRep(vec3 p, vec3 s) { return mod(p+.5*s, s) - .5*s; }\n\nvoid addSphere(inout vec2 d, vec3 pos, vec3 t, float mtl)\n{\n    d = dUnion(d, vec2(dSphere(pRep(pMov(pos, t), vec3(10,4,5)), 0.35), mtl));\n}\n\nvec2 scene(vec3 pos)\n{\n    vec2 d = vec2(dPlane(pMov(pos, vec3(0,-2,0))), 1.0);\n    addSphere(d, pos, vec3(0,1,0), 1.0);\n    addSphere(d, pos, vec3(0,-1,0), 1.0);\n    addSphere(d, pos, vec3(1,0,0), 1.0);\n    addSphere(d, pos, vec3(-1,0,0), 1.0);\n    addSphere(d, pos, vec3(0,0,1), 1.0);\n    addSphere(d, pos, vec3(0,0,-1), 1.0);\n    addSphere(d, pos, vec3(0,0,0), 1.0);\n    return d;\n}\n\nfloat rayMarch(vec3 eye, vec3 dir, float zn, float zf, out float mtl)\n{\n    float z = zn;\n    mtl = -1.0;\n    \n    for (int i=0; i < RAYMARCH_ITER; i++)\n    {\n        vec2 d = scene(eye + z * dir);\n        mtl = d.y;\n        if (d.x < RAYMARCH_EPS || z > zf) break;\n        z += d.x;\n    }\n    \n    if (z > zf) mtl = -1.0;\n    return z;\n}\n\nvec3 render(vec3 eye, vec3 dir)\n{\n    float mtl;\n    float dist = rayMarch(eye, dir, 1., 100., mtl);\n    \n    vec3 color = vec3(dist \/ 100.);\n    \/\/if (mtl > 0.) color *= mtl;\n    \n    return clamp(color, 0., 1.);\n}\n\nvec3 lookAtDir(vec2 uv, vec3 eye, vec3 at, vec3 up, float fov)\n{\n    vec3 f = normalize(at - eye);\n    vec3 r = normalize(cross(up, f));\n    vec3 u = normalize(cross(f, r));\n    return normalize(f + fov * (uv.x*r + uv.y*u));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    vec2 uv0 = uv;\n    uv.x *= iResolution.x \/ iResolution.y;\n    \n    float angle = iGlobalTime * 0.3 + 0.5;\n    if (iMouse.z > 0.) angle = iMouse.x \/ iResolution.x * 2. * PI;\n    vec3 eye = vec3(sin(angle), 0.5 + sin(angle * 4.5)*0.1, cos(angle));\n    eye *= 8. + 2. * sin(iGlobalTime * 0.6);\n    vec3 dir = lookAtDir(uv, eye, vec3(0, 0, 0), vec3(0, 1, 0), 1.0);\n\t\n    float at = 0.005 + 0.008 * fract(sin(iGlobalTime) * 204.512598);\n    vec3 color;\n    color.r = render(eye, dir + vec3(-1,1,0)*at).x;\n    color.g = render(eye, dir).x;\n    color.b = render(eye, dir + vec3(0,-1,0)*at).x;\n    \n    color *= 1. - pow(max(0., length(uv0)-.5), 3.);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"","description":"","type":"image"}]}}