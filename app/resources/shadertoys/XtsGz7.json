{"Shader":{"ver":"0.1","info":{"id":"XtsGz7","date":"1420247765","viewed":717,"name":"Vorono\u00ef Experiment 1","username":"aiekick","description":"Voronoi Experiment 1","likes":2,"published":3,"flags":0,"tags":["raymarching","voronoi","experiment","sphere","blob","mapping"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Stephane Cuillerdier - Aiekick\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ VORONOI based on IQ shader https:\/\/www.shadertoy.com\/view\/ldl3W8\n\/\/vec2 getHash2BasedTex(vec2 p) {return texture2D( iChannel0, (p+0.5)\/256.0, -100.0 ).xy;}\/\/texture based white noise\nvec2 getHash2BasedProc(vec2 p){return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);}\/\/procedural white noise\nvec3 getVoronoi(vec2 x){\n    vec2 n=floor(x),f=fract(x),mr;\n    float md=5.;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ ){\n        vec2 g=vec2(float(i),float(j));\n\t\tvec2 o=0.5+0.5*sin(iGlobalTime+6.2831*getHash2BasedProc(n+g));\/\/animated\n        vec2 r=g+o-f;\n        float d=dot(r,r);\n        if( d<md ) {md=d;mr=r;} }\n    return vec3(md,mr);}\n\/\/ sphere mapping of v2 voronoi\nvec3 voronoiSphereMapping(vec3 n){\n\tvec2 uv=vec2(atan(n.x,n.z),acos(n.y));\n   \treturn getVoronoi(1.5*uv);}\n\/\/ blobby voronoi\nfloat map(vec3 p){\n    float disp=length(vec4(voronoiSphereMapping(normalize(p)),1.))*0.4-0.8;\n\treturn length(p)-1.+disp;}\n\/\/ normal calc based on nimitz shader https:\/\/www.shadertoy.com\/view\/4sSSW3\nvec3 getNormal(const in vec3 p){  \n    vec2 e = vec2(-1., 1.)*0.005;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );}\n\/\/ ray-marcher based on sebastien shader https:\/\/www.shadertoy.com\/view\/XtXGzM\nfloat march(vec3 ro,vec3 rd){\n\tfloat maxd=10.;\n    float tmpDist=1.;\n    float finalDist=0.;\n    for(int i=0;i<50;i++){\n        if( tmpDist<0.001||finalDist>maxd) break;\n\t    tmpDist=map(ro+rd*finalDist);\n        finalDist+=tmpDist; }\n    if(finalDist>maxd) finalDist=-1.;\n\treturn finalDist; }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy\/iResolution.xy*2.-1.;\n    uv.x*=iResolution.x\/iResolution.y;\n    vec3 ro=vec3(0.,0.,2.),rd=normalize(vec3(uv,-1.));\n   \tfloat t=march(ro,rd);\n     if(t>0.){\n        vec3 pos = ro+t*rd;\n        vec3 col = mix(vec3(max(0.,2.3-t)),voronoiSphereMapping(normalize(pos)),0.5);\n        float bright=dot(getNormal(pos),normalize(pos))*0.8;\n        fragColor= vec4(bright*col+pow(bright,8.0)*(1.-t*.01),1.); } }","name":"","description":"","type":"image"}]}}