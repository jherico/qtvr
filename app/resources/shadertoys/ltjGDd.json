{"Shader":{"ver":"0.1","info":{"id":"ltjGDd","date":"1435129525","viewed":1844,"name":"Shiny sphere lights","username":"shaderology","description":"Fun with spherical lights, area shadows, occlusion and reflections.<br\/>Sphere and trace functions by inigo quilez, http:\/\/www.iquilezles.org","likes":40,"published":3,"flags":8,"tags":["3d","raytracing","sphere","intersection","shadows","area"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Fun with spherical lights, area shadows, occlusion and reflections.\n\/\/ Sphere and trace functions by inigo quilez, http:\/\/www.iquilezles.org\n\n#define BIAS 0.0001\n#define PI 3.1415927\n#define SEED 4.\n\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n  vec3 oc = ro - sph.xyz;\n  float b = dot( oc, rd );\n  float c = dot( oc, oc ) - sph.w*sph.w;\n  float h = b*b - c;\n  if( h<0.0 ) return -1.0;\n  return -b - sqrt( h );\n}\n\nfloat sphOcclusion( in vec3 pos, in vec3 nor, in vec4 sph )\n{\n    vec3  r = sph.xyz - pos;\n    float l = length(r);\n    float d = dot(nor,r);\n    float res = d;\n\n    if( d<sph.w ) res = pow(clamp((d+sph.w)\/(2.0*sph.w),0.0,1.0),1.5)*sph.w;\n    \n    return clamp( res*(sph.w*sph.w)\/(l*l*l), 0.0, 1.0 );\n\n}\n\nfloat sphAreaShadow( vec3 P, in vec4 L, vec4 sph )\n{\n  vec3 ld = L.xyz - P;\n  vec3 oc = sph.xyz - P;\n  float r = sph.w - BIAS;\n  \n  float d1 = sqrt(dot(ld, ld));\n  float d2 = sqrt(dot(oc, oc));\n  \n  if (d1 - L.w \/ 2. < d2 - r) return 1.;\n  \n  float ls1 = L.w \/ d1;\n  float ls2 = r \/ d2;\n\n  float in1 = sqrt(1.0 - ls1 * ls1);\n  float in2 = sqrt(1.0 - ls2 * ls2);\n  \n  if (in1 * d1 < in2 * d2) return 1.;\n  \n  vec3 v1 = ld \/ d1;\n  vec3 v2 = oc \/ d2;\n  float ilm = dot(v1, v2);\n  \n  if (ilm < in1 * in2 - ls1 * ls2) return 1.0;\n  \n  float g = length( cross(v1, v2) );\n  \n  float th = clamp((in2 - in1 * ilm) * (d1 \/ L.w) \/ g, -1.0, 1.0);\n  float ph = clamp((in1 - in2 * ilm) * (d2 \/ r) \/ g, -1.0, 1.0);\n  \n  float sh = acos(th) - th * sqrt(1.0 - th * th) \n           + (acos(ph) - ph * sqrt(1.0 - ph * ph))\n           * ilm * ls2 * ls2 \/ (ls1 * ls1);\n  \n  return 1.0 - sh \/ PI;\n}\n\n\n\/\/-------------------------------------------------------------------------------------------\nconst int SPH = 27; \/\/3x3x3\n\nvec4 sphere[SPH];\nvec4 L;\n\nvec3 rand3( float x, float seed )\n{ \n  float f = x+seed;\n  return fract( PI*sin( vec3(f,f+5.33,f+7.7)) );\n}\n\nfloat areaShadow( in vec3 P )\n{\n  float s = 1.0;\n  for( int i=0; i<SPH; i++ )\n    s = min( s, sphAreaShadow(P, L, sphere[i] ) );\n  return s;           \n}\n\nvec3 reflections( vec3 P, vec3 R, vec3 tint, int iid )\n{\n  float t = 1e20;\n\n  vec3 s = vec3(R.y < 0. ? 1.-sqrt(-R.y\/(P.y+1.)) : 1.); \/\/ P.y+1 floor pos\n  for( int i=0; i<SPH; i++ )\n  {    \n    float h = sphIntersect( P, R, sphere[i] );\n    if( h>0.0 && h<t )\n    {\n      s = i == iid ? tint * 2. : vec3(0.);\n      t = h;\n    }\n  }     \n  return max( vec3(0.), s);           \n}\n\nfloat occlusion( vec3 P, vec3 N )\n{\n  float s = 1.0;\n  for( int i=0; i<SPH; i++ )\n    s *= 1.0 - sphOcclusion( P, N, sphere[i] ); \n  return s;           \n}\n\nfloat sphLight( vec3 P, vec3 N, vec4 L)\n{\n  vec3 oc = L.xyz  - P;\n  float dst = sqrt( dot( oc, oc ));\n  vec3 dir = oc \/ dst;\n  \n  float c = dot( N, dir );\n  float s = L.w  \/ dst;\n    \n  return max(0., c * s);\n}\n  \n\/\/-------------------------------------------------------------------------------------------\n\nvec3 shade( vec3 I, vec3 P, vec3 N, float id, float iid )\n{\n  vec3 base = rand3( id, SEED );\n  vec3 wash = mix( vec3(0.9), base, 0.4);\n  vec3 hero = rand3( iid, SEED );\n  \n  vec3 ref = reflections( P, I - 2.*(dot(I,N))*N, hero, int(iid) );\n  float occ = occlusion( P, N );\n  float ocf = 1.-sqrt((0.5 + 0.5*-N.y)\/(P.y+1.25))*.5; \/\/floor occusion. 1.25 floor P.\n  float fre = clamp( 1. + dot( I, N), 0., 1.); fre = (0.01+0.4*pow(fre,3.5));\n  float lgh = sphLight( P, N, L) *  areaShadow( P );\n  float inc = ( id == iid ? 1.0 : 0.0 );\n   \n  \/\/ Env light\n  vec3 C = wash * occ * ocf * .2;\n  \n  \/\/ Sphere light\n  C += ( inc + lgh * 1.3 ) * hero;\n\n  \/\/ Reflections\n  C = mix( C, ref, fre );\n  \n  return C;\n}    \n\nvec3 trace( vec3 E, vec3 I, vec3 C, float px, float iid )\n{\n  float t = 1e20;\n  float id  = -1.0;\n  vec4  obj = vec4(0.);\n  for( int i=0; i<SPH; i++ )\n  {\n    vec4 sph = sphere[i];\n    float h = sphIntersect( E, I, sph ); \n    if( h>0.0 && h<t ) \n    {\n      t = h;\n      obj = sph;\n      id = float(i);\n    }\n  }\n              \n  if( id>-0.5 )\n  {\n    vec3 P = E + t*I;\n    vec3 N = normalize(P-obj.xyz);\n    C = shade( I, P, N, id, iid  );\n  }\n\n  return C;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)\/iResolution.y;\n    vec2 m = step(0.0001,iMouse.z) * iMouse.xy\/iResolution.xy;\n    \n    \/\/-----------------------------------------------------\n    \n    float time = iGlobalTime;\n    float an = 0.3*time - 7.0*m.x;\n    float sec = mod(time,1.);\n    \n    float spI = floor(mod(time,float(SPH)));\n\n    \/\/-----------------------------------------------------\n    for( int i=0; i<SPH; i++ )\n    {\n      float ra = 0.4;\n      float id = float(i);\n      sphere[i] = vec4( mod( id, 3.0) - 1.0,\n                        mod( floor( id\/3.0 ), 3.0 ) - .55,\n                        floor( id\/9.0 )-1.0, ra );\n\n      if( i == int(spI) )\n      {\n        sphere[i].w += 0.025 * sin(sec*50.) \/ sqrt(sec) * ( 1.-sqrt(sec));\n        L = sphere[i];\n      }\n    }\n\n    \/\/-----------------------------------------------------\n    \n    float fov = 1.8;\n    vec3 E = vec3( 3.5*sin(an), 2.0, 3.5*cos(an));\n    vec3 V = normalize( -E );\n    vec3 uu = normalize( cross( V, vec3(0., 1., 0.)));\n    vec3 vv = normalize( cross( uu, V));\n    vec3 I = normalize( p.x*uu + p.y*vv + fov*V );\n\n    float px = 1.0*(2.0\/iResolution.y)*(1.0\/fov);\n\n\n    \/\/-----------------------------------------------------\n    \n    vec3 C = vec3(1.);\n\n    float tmin = 1e20;\n    float t = -(1.0+E.y)\/I.y;\n    if( t>0.0 )\n    {\n        tmin = t;\n        vec3 pos = E + t*I;\n        vec3 nor = vec3(0.0,1.0,0.0);\n        C = shade( I, pos, nor, -1.0, spI );\n    }    \n    \n    C = trace( E, I, C, px, spI );\n    \n    \/\/ post\n    C = pow( C, vec3(0.41545) );   \n    C *= 0.5 + 0.5*pow(18.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.12);\n\n    fragColor = vec4( C, 1. );\n}\n","name":"","description":"","type":"image"},{"inputs":[],"outputs":[{"channel":"0"}],"code":"vec2 mainSound(float time)\n{\n\tfloat sec = mod(time,1.);\n    float ech = mod(time,.2);\n    float sph = floor( mod(time,27.));\n    float rnd = fract( 876.432 * sin( sph ) ) + 5.;\n    float hum = sin(400.0*time) * sin(8.0*time) * 0.2;\n    float bel = sin(rnd*340.0*sec)*exp(-4.0*sec)*exp(-4.0*ech)*.5;\n    return vec2( hum + bel );\n}\n","name":"","description":"","type":"sound"}]}}