{"Shader":{"ver":"0.1","info":{"id":"4tsGWs","date":"1426202793","viewed":704,"name":"sinMountains","username":"Fred1024","description":"Been playing with raymarch algorithms <img src=\"\/img\/emoticonHappy.png\"\/>","likes":9,"published":3,"flags":0,"tags":["3d","raymarch"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ ~ sinMountains ~\n\/\/ Frederic Heintz\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define FOV_DEGRE 60.0\n#define E 0.15\n#define LIGHT_RANGE 3000.0\n\nvec3 camPos;\nint scapeType;\n\nfloat mapY( in vec3 pos )\n{\n    if(scapeType == 1)\n    {\n\t    pos.x = floor(pos.x \/ 10.0) * 10.0;\n    }\n    float y = sin( (pos.x + iGlobalTime * 5.0) * 0.1) * sin( (pos.z + iGlobalTime * 3.0) * 0.1) * 30.0;\n    y += (sin( (pos.x + iGlobalTime * 10.0) * 0.05) * sin( (pos.z - iGlobalTime * 7.0) * 0.05) * 30.0);\n    y += sin( (pos.x + iGlobalTime * 8.0) * 0.025) * sin( (pos.z + iGlobalTime * 12.0) * 0.025) * 30.0;\n\n    if(scapeType == 2)\n    {\n\t   \ty = floor(y \/ 10.0) * 10.0;\n    }\n    float q = length(pos.xz - camPos.xz) * 2.0;\n    return y * (0.2 + q * q * 0.0000015);\n}\n\nvec3 mapNormal( in vec3 pos )\n{\n\tfloat yl = mapY( pos + vec3(-E, 0.0, 0.0));\n\tfloat yr = mapY( pos + vec3(E, 0.0, 0.0));\n\tfloat yt = mapY( pos + vec3(0.0, 0.0, -E));\n\tfloat yb = mapY( pos + vec3(0.0, 0.0, E));\n    vec3 vx = normalize(vec3(E, yr - yl, 0.0));\n    vec3 vz = normalize(vec3(0.0, yt - yb, -E));\n    vec3 norm = normalize(cross( vx, vz ));\n\treturn norm;\n}\n\n\/\/ the higher we get in the map the further we go\nbool rayMarchFirstHit( in vec3 ray, inout float delta, inout vec3 ptr)\n{\n\tfor( int i = 0; i < 90; i++)\n\t{\n\t\tptr += (delta * ray);\n        float dy = ptr.y - mapY(ptr);\n\t\tif(dy <= 0.0)\n\t\t{\n\t\t\tptr -= (delta * ray);\n            return true;\n        }\n        delta = clamp(dy, 0.1, 9.0);\n    }\n    return false;\n}\n\n\/\/ refine with smaller and smaller steps\nvoid rayMarchRefine( in vec3 ray, in float delta, inout vec3 ptr)\n{\n\tfor( int i = 0; i < 20; i++)\n\t{\n\t\tptr += (delta * ray);\n\n\t\tif(ptr.y < mapY(ptr))\n\t\t{\n\t\t\tptr -= (delta * ray);\n            delta *= 0.5;\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float localTime = mod((iGlobalTime + (fragCoord.x \/ iResolution.x) * 8.0), 40.0);\n    \n    if(abs(mod(localTime, 20.0)) < 0.01)\tscapeType = 0;\n    else if(localTime <= 20.0)\t\t\t\tscapeType = 1;\n    else\t\t\t\t\t\t\t\t\tscapeType = 2;\n\n    vec3 lightPos = vec3(sin(iGlobalTime * 0.08) * 700.0, 150.0 - sin(iGlobalTime * 0.25) * 30.0, cos(iGlobalTime * 0.08) * 100.0);\n\n    \/\/ Camera setup\n    float height = 20.0 + (iMouse.y \/ iResolution.y) * 100.0;\n    camPos = mix(vec3(0.4, height, 0.3), lightPos, 0.3);\n    camPos.y = height;\n    \n    vec3 camTgt = vec3(lightPos.x, lightPos.y * 0.2, lightPos.z);\n\n    \/\/ A view matrix\n    vec3 dir = normalize(camTgt - camPos);\t\t\t\t\t\/\/ z dir\n    vec3 side = normalize(cross(dir, vec3(0.0, 1.0, 0.0)));\t\/\/ side\n    vec3 up = normalize(cross(side, dir));\t\t\t\t\t\/\/ up\n    mat3 viewMatrix = mat3(side.x, up.x, dir.x, side.y, up.y, dir.y, side.z, up.z, dir.z);\n    \n    \/\/ Ray setup\n    float tangF = tan(radians(FOV_DEGRE));\n    float ratio = iResolution.y \/ iResolution.x;\n    float rX = (((fragCoord.x \/ iResolution.x) * 2.0) - 1.0) * tangF;\n    float rY = (((fragCoord.y \/ iResolution.y) * 2.0) - 1.0) * tangF * ratio;\n    vec3 ray = normalize(vec3(rX, rY, 1.0));\n    \n    \/\/ apply camera trans to ray\n    ray = ray * viewMatrix;\n\n\t\/\/ sky\n    vec3 lightDir = (lightPos - camPos);\n    float lightDist = length(lightDir);\n   \tlightDir = normalize(lightDir);\n    float skyDot = clamp(dot(lightDir, ray), 0.0, 1.0);\n    vec3 colorSky = mix(vec3(0.5, 0.5, 1.0), vec3(0.0, 0.0, 1.0), clamp(ray.y, 0.0, 1.0));\n    colorSky += mix(vec3(0.0, 0.0, 0.0), vec3(0.5, 0.5, 1.0), vec3(pow(skyDot, 30.0) * 0.8, pow(skyDot, 15.0) * 0.6, pow(skyDot, 20.0) * 0.75));\n\n    vec3 color = colorSky;\n        \n\tvec3 ptr = camPos;\n    float delta = 2.0;\n\tif(scapeType == 0)\n    {\n        color = vec3(1.0, 1.0, 1.0);\n    }\n    else if( rayMarchFirstHit( ray, delta, ptr ) == true)\n    {\n        rayMarchRefine( ray, delta * 0.5, ptr );\n\n        vec3 norm = mapNormal(ptr);\n        \/\/ surface color\n        if( abs(norm.z) > 0.8)          color = vec3(1.0, 0.04, 0.0);\n        else if( abs(norm.y) < 0.8)     color = mix(vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), clamp((ptr.y + 25.0) * 0.05, 0.0, 1.0));\n        else if( abs(norm.y) < 0.82)    color = vec3(1.0, 1.0, 0.0);\n        else            \t\t\t\tcolor = mix(vec3(0.5, 0.5, 1.0), vec3(1.0, 0.5, 0.0), clamp((ptr.y + 16.0) * 0.025, 0.0, 1.0));\n\n        \/\/ shading\n\t    float lightDot = clamp(dot(lightDir, norm), 0.0, 1.0);\n\n\t    float spec = 0.0;\n\t\tfloat lightI = 0.0;\n        if(lightDot >= 0.0 && lightDist < LIGHT_RANGE)\n\t    {\n        \tlightI = lightDot * pow(1.0 - (lightDist \/ LIGHT_RANGE), 2.0) * 1.6;\n\t    \tspec = clamp(dot(ray, normalize(lightDir - norm)), 0.0, 1.0);\n\t    \tspec = pow(spec, 200.0) * 1.0;\n        }\n        color = ( (color * 0.15) + (color * lightI) + spec );\n        \n        \/\/ mix with sky in the distance\n        vec3 hitDir = (ptr - camPos);\n        float hitDist = length(hitDir);\n        float q = min(1.0, hitDist * hitDist * 0.0000017);\n        color = mix( color, colorSky, q );\n    }\n\n    \/\/ show light\n    lightDir = normalize(lightDir);\n    float lightQ = max( 0.0, dot(ray, lightDir));\n    color.xyz += vec3(pow(lightQ, 600.0 + sin(iGlobalTime * 50.0) * 20.0));\n\n    \/\/ Gamma\n    color = pow(color, vec3(0.4545));\n\n    color = clamp(color, 0.0, 1.0);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n","name":"","description":"","type":"image"}]}}