{"Shader":{"ver":"0.1","info":{"id":"ltB3Dw","date":"1429440249","viewed":787,"name":"Psychofract","username":"curena","description":"animated fractal tree","likes":9,"published":3,"flags":0,"tags":["fractal","animated","tree"],"hasliked":0},"renderpass":[{"inputs":[{"id":19,"src":"\/presets\/mzk02.mp3","ctype":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ \"Psychofract\" by Carlos Ure\u00f1a - 2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nmat3 tran1, \n     tran2 ; \/\/transform matrix for each branch\n\nconst float pi = 3.1415926535 ;\n\nconst float rsy = 0.30 ; \/\/ length of each tree root trunk in NDC\n\n\/\/ -----------------------------------------------------------------------------\n\nmat3 RotateMat( float rads )\n{\n   float c = cos(rads),\n         s = sin( rads ) ;\n   \n   return mat3(  c,  s, 0.0,\n                -s,   c, 0.0,\n               0.0, 0.0, 1.0  );\n}\n\/\/ -----------------------------------------------------------------------------\n\nmat3 TranslateMat( vec2 d )\n{\n   return mat3(  1.0, 0.0, 0.0,\n                 0.0, 1.0, 0.0,\n                 d.x, d.y, 1.0 );\n}\n\/\/ -----------------------------------------------------------------------------\n\nmat3 ScaleMat( vec2 s )\n{\n   return mat3( s.x, 0.0, 0.0,\n                0.0, s.y, 0.0,\n                0.0, 0.0, 1.0 );\n}\n\/\/ -----------------------------------------------------------------------------\n\nmat3 ChangeFrameToMat( vec2 org, float angg, float scale )\n{\n   float angr = (angg*pi)\/180.0 ;\n   return\n        ScaleMat( vec2( 1.0\/scale, 1.0\/scale ) )\n      * RotateMat( -angr )\n      * TranslateMat( -org ) ;\n}\n\/\/ -----------------------------------------------------------------------------\n\nfloat RectangleDistSq( vec3 p )\n{ \n   if ( 0.0 <= p.y && p.y <= rsy )\n       return p.x * p.x;\n    \n   if (p.y > rsy)\n       return p.x*p.x + (p.y-rsy)*(p.y-rsy) ;\n    \n   return p.x*p.x + p.y*p.y ;\n}\n\/\/ -----------------------------------------------------------------------------\n\nfloat BlendDistSq( float d1, float d2, float d3 )\n{\n   float dmin = min( d1, min(d2,d3)) ;\n      \n   return 0.5*dmin ; \n}\n\/\/ -----------------------------------------------------------------------------\n\nvec4 ColorF( float distSq, float angDeg )\n{\n   float b = min(1.0, 0.1\/(sqrt(distSq)+0.1)),\n         v = 0.5*(1.0+cos( 200.0*angDeg\/360.0 + b*15.0*pi ));\n     \n   return vec4( b*b*b,b*b,0.0,distSq) ; \/\/ returns squared distance in alpha component\n}\n\/\/ -----------------------------------------------------------------------------\n\nfloat Trunk4DistSq( vec3 p )\n{\n   float d1 = RectangleDistSq( p ); \n    \n   return d1 ;   \n}\n\n\/\/ -----------------------------------------------------------------------------\n\nfloat Trunk3DistSq( vec3 p )\n{\n   float d1 = RectangleDistSq( p ),\n         d2 = Trunk4DistSq( tran1*p ),\n         d3 = Trunk4DistSq( tran2*p );\n      \n   return BlendDistSq( d1, d2, d3 ) ;  \n}\n\n\/\/ -----------------------------------------------------------------------------\n\nfloat Trunk2DistSq( vec3 p )\n{\n   float d1 = RectangleDistSq( p ), \n         d2 = Trunk3DistSq( tran1*p ),\n         d3 = Trunk3DistSq( tran2*p );\n    \n   return BlendDistSq( d1, d2, d3 ) ;  \n}\n\n\/\/ -----------------------------------------------------------------------------\n\nfloat Trunk1DistSq( vec3 p )\n{\n   float d1 = RectangleDistSq( p ) ,\n         d2 = Trunk2DistSq( tran1*p ),\n         d3 = Trunk2DistSq( tran2*p );\n    \n   return BlendDistSq( d1, d2, d3 ) ;  \n}\n\n\/\/ -----------------------------------------------------------------------------\n\nfloat Trunk0DistSq( vec3 p )\n{\n   float d1 = RectangleDistSq( p ) ,\n         d2 = Trunk1DistSq( tran1*p ),\n         d3 = Trunk1DistSq( tran2*p );\n    \n   return BlendDistSq( d1, d2, d3 ) ;  \n}\n\/\/ -----------------------------------------------------------------------------\n\/\/ compute the color and distance to tree, for a point in NDC coords\n\nvec4 ComputeColorNDC( vec3 p, float angDeg )\n{   \n   vec2 org = vec2(0.5,0.5) ;\n   vec4 col = vec4( 0.0, 0.0, 0.0, 1.0 );\n   float dmin ;\n    \n   for( int i = 0 ; i < 4 ; i++ )\n   {\n      mat3 m = ChangeFrameToMat( org, angDeg + float(i)*90.0, 0.7 ); \n   \t  vec3 p_transf = m*p ;\n      float dminc = Trunk0DistSq( p_transf ) ;\n            \n      if ( i == 0 )\n         dmin = dminc ;\n      else if ( dminc < dmin )\n         dmin = dminc ;\n   }  \n   return ColorF( dmin, angDeg ); \/\/ returns squared dist in alpha component\n}\n\/\/ -----------------------------------------------------------------------------\n\nvec3 ComputeNormal( vec3 p, float dd, float ang, vec4 c00 )\n{\n   vec4   \/\/c00  = ComputeColorNDC( p, ang )  ,\n         c10  = ComputeColorNDC( p + vec3(dd,0.0,0.0), ang )  ,\n         c01  = ComputeColorNDC( p + vec3(0.0,dd,0.0) , ang ) ;\n   float h00  = sqrt(c00.a),\n         h10  = sqrt(c10.a),\n         h01  = sqrt(c01.a);\n   vec3  tanx = vec3( dd, 0.0, h10-h00 ),\n         tany = vec3( 0.0, dd, h01-h00 );\n   vec3  n    = normalize( cross( tanx,tany ) );\n       \n   if ( n.z < 0.0 ) n *= -1.0 ; \n   return n ;\n}\n\n\/\/ -----------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n   const float width = 0.1 ;\n\n   \n   vec2  res  = iResolution.xy ;\n   float mind = min(res.x,res.y);\n   vec2  pos  = fragCoord.xy ;\n   float x0   = (res.x - mind)\/2.0 ,\n         y0   = (res.y - mind)\/2.0 ,\n         px   = pos.x - x0 ,\n         py   = pos.y - y0 ;\n      \n  \n   \/\/ compute 'tran1' and 'tran2':\n    \n   vec2  org1      = vec2( 0.0, rsy ) ;\n   float ang1_deg  = +20.0 + 30.00*cos( 2.0*pi*iGlobalTime\/4.05 ),\n         scale1    = +0.85 +  0.40*cos( 2.0*pi*iGlobalTime\/2.10 )  ;\n\n   vec2  org2      = vec2( 0.0, rsy ) ;\n   float ang2_deg  = -30.0 + 40.00*sin( 2.0*pi*iGlobalTime\/2.52 ),\n         scale2    = +0.75 +  0.32*sin( 2.0*pi*iGlobalTime\/4.10 )  ;\n   \n   tran1 = ChangeFrameToMat( org1, ang1_deg, scale1 ) ;\n   tran2 = ChangeFrameToMat( org2, ang2_deg, scale2 ) ; \n   \n   \/\/ compute pixel color (pixCol)\n    \n   float mainAng = 360.0*iGlobalTime\/15.0 ,    \/\/ main angle, proportional to time\n         dd      = 1.0\/float(mind) ;           \/\/ pixel width or height in ndc\n   vec3  pixCen  = vec3( px*dd, py*dd, 1.0 ) ; \/\/ pixel center\n   vec4  pixCol  = ComputeColorNDC( pixCen, mainAng ), \n         resCol  ;\n   \n   \/\/ compute output color as a function 'use_normal'\n   \n    const bool use_gradient = false ;\n    \n   if ( use_gradient )\n   {\n      vec3 nor     = ComputeNormal( pixCen, dd, mainAng, pixCol );\n      vec4 gradCol = vec4( max(nor.x,0.0), max(nor.y,0.0), max(nor.z,0.0), 1.0 ) ;\n       \n      resCol = 0.8*pixCol+ 0.2*gradCol ;\n   }\n   else\n      resCol = pixCol ;\n      \n       \n   fragColor = vec4( resCol.rgb, 1.0 ) ;\n}\n","name":"","description":"","type":"image"}]}}