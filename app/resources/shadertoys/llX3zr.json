{"Shader":{"ver":"0.1","info":{"id":"llX3zr","date":"1417882206","viewed":1531,"name":"Space Jewels","username":"Dave_Hoskins","description":"Uses a stack of 8 samples on each pixel to render the fractal. Please watch in full-screen if your GPU is up to it!! <img src=\"\/img\/emoticonHappy.png\"\/><br\/>It uses near field out of focus effects.","likes":22,"published":3,"flags":64,"tags":["3d","raymarching","antialiasing","dof","spacejewels","soundcloud"],"hasliked":0},"renderpass":[{"inputs":[{"id":10,"src":"\/presets\/tex09.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":231,"src":"https:\/\/soundcloud.com\/2012wonder_girl\/we-had-today-rachel-portman","ctype":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Space Jewels. December 2014\n\/\/ by David Hoskins\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ https:\/\/www.shadertoy.com\/view\/llX3zr\n\n\/\/--------------------------------------------------------------------------\n#define SUN_COLOUR vec3(1., .9, .85)\n#define FOG_COLOUR vec3(0.07, 0.05, 0.05)\n#define MOD2 vec2(443.8975,397.2973)\n\nvec3 CSize;\nvec4 aStack[2];\nvec4 dStack[2];\nvec2 fcoord;\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ From https:\/\/www.shadertoy.com\/view\/4djSRW\nfloat Hash(vec2 p)\n{\n\tp  = fract(p * MOD2);\n    p += dot(p.xy, p.yx+19.19);\n    return fract(p.x * p.y);\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 Colour( vec3 p)\n{\n\tfloat col\t= 0.0;\n    float r2\t= dot(p,p);\n\t\t\n\tfor( int i=0; i < 12;i++ )\n\t{\n\t\tvec3 p1= 2.0 * clamp(p, -CSize, CSize)-p;\n\t\tcol += abs(p.z-p1.z);\n\t\tp = p1;\n\t\tr2 = dot(p,p);\n\t\tfloat k = max((1.1)\/(r2), .03);\n\t\tp *= k;\n\t}\n\treturn (0.5+0.5*sin(col*vec3(1.647,-1.0,4.9)));\n}\n\n\/\/--------------------------------------------------------------------------\n\nfloat Map( vec3 p )\n{\n\tfloat scale = 1.0;\n\t\n\tfor( int i=0; i < 12;i++ )\n\t{\n\t\tp = 2.0*clamp(p, -CSize, CSize) - p;\n\t\tfloat r2 = dot(p,p);\n\t\tfloat k = max((1.1)\/(r2), .03);\n\t\tp     *= k;\n\t\tscale *= k;\n\t}\n\tfloat l = length(p.xy);\n\tfloat rxy = l - 4.0;\n\tfloat n = l * p.z;\n\trxy = max(rxy, -(n) \/ (length(p))-.1);\n\treturn (rxy) \/ abs(scale);\n}\n\n\n\n\/\/--------------------------------------------------------------------------\nfloat Shadow( in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 0.05;\n\tfloat h;\n\t\n    for (int i = 0; i < 6; i++)\n\t{\n\t\th = Map( ro + rd*t );\n\t\tres = min(7.0*h \/ t, res);\n\t\tt += h+.01;\n\t}\n    return max(res, 0.0);\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 DoLighting(in vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float d)\n{\n    vec3 sunLight  = normalize( vec3(  0.5, 0.2,  0.3 ) );\n\tfloat sh = Shadow(pos,  sunLight);\n    \/\/ Light surface with 'sun'...\n\tvec3 col = mat * SUN_COLOUR*(max(dot(sunLight,normal), 0.0)) *sh;\n    \/\/col += mat * vec3(0.1, .0, .0)*(max(dot(-sunLight,normal), 0.0));\n    \n    normal = reflect(eyeDir, normal); \/\/ Specular...\n    col += pow(max(dot(sunLight, normal), 0.0), 25.0)  * SUN_COLOUR * 1.5 *sh;\n    \/\/ Abmient..\n    col += mat * .2 * max(normal.z, 0.0);\n    col = mix(FOG_COLOUR,col, min(exp(-d*d*.05), 1.0));\n    \n\treturn col;\n}\n\n\n\/\/--------------------------------------------------------------------------\nvec3 GetNormal(vec3 p, float sphereR)\n{\n\tvec2 eps = vec2(sphereR*.5, 0.0);\n\treturn normalize( vec3(\n           Map(p+eps.xyy) - Map(p-eps.xyy),\n           Map(p+eps.yxy) - Map(p-eps.yxy),\n           Map(p+eps.yyx) - Map(p-eps.yyx) ) );\n}\n\n\/\/--------------------------------------------------------------------------\nfloat SphereRadius(in float t)\n{\n\tif (t< 1.4) t= (1.4-t) * 4.5;\n\tt = t*0.04;\n\treturn max(t*t, 16.0\/iResolution.x);\n}\n\n\/\/--------------------------------------------------------------------------\nfloat Scene(in vec3 rO, in vec3 rD)\n{\n    \/\/float t = 0.0;\n\tfloat t = .1 * Hash(fcoord*fract(iGlobalTime));\n\tfloat  alphaAcc = 0.0;\n\tvec3 p = vec3(0.0);\n    int hits = 0;\n\n\tfor( int j=0; j < 80; j++ )\n\t{\n\t\tif (hits == 8 || alphaAcc >= 1.0 || t > 10.0) break;\n\t\tp = rO + t*rD;\n\t\tfloat sphereR = SphereRadius(t);\n\t\tfloat h = Map(p);\n        \/\/ Is it within the sphere?...\n\t\tif( h < sphereR)\n\t\t{\n\t\t\t\/\/ Accumulate the alphas with the scoop of geometry from the sphere...\n            \/\/ Think of it as an expanding ice-cream scoop flying out of the camera! \n\t\t\tfloat alpha = (1.0 - alphaAcc) * min(((sphereR-h) \/ sphereR), 1.0);\n\t\t\t\/\/ put it on the 2 stacks, alpha and distance...\n\t\t\taStack[1].yzw = aStack[1].xyz; aStack[1].x = aStack[0].w;\n\t\t\taStack[0].yzw = aStack[0].xyz; aStack[0].x = alpha;\n\t\t\tdStack[1].yzw = dStack[1].xyz; dStack[1].x = dStack[0].w;\n\t\t\tdStack[0].yzw = dStack[0].xyz; dStack[0].x = t;\n\t\t\talphaAcc += alpha;\n\t\t\thits++;\n\t\t}\n\t\tt +=  h*.85+t*.001;\n        \n\t}\n\t\n\treturn clamp(alphaAcc, 0.0, 1.0);\n}\n\n\n\/\/--------------------------------------------------------------------------\nvec3 PostEffects(vec3 rgb, vec2 xy)\n{\n\t\/\/ Gamma first...\n\trgb = pow(rgb, vec3(0.45));\n\n\t\/\/ Then...\n\t#define CONTRAST 1.3\n\t#define SATURATION 1.3\n\t#define BRIGHTNESS 1.2\n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\n\n\t\/\/ Vignette...\n\trgb *= .5+0.5*pow(180.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.3 );\t\n\n\treturn clamp(rgb, 0.0, 1.0);\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 TexCube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec3 x = texture2D( sam, p.yz ).xzy;\n\tvec3 y = texture2D( sam, p.zx ).xyz;\n\tvec3 z = texture2D( sam, p.xy ).yzx;\n\treturn (x*abs(n.x) + y*abs(n.y) + z*abs(n.z))\/(abs(n.x)+abs(n.y)+abs(n.z));\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 Albedo(vec3 pos, vec3 nor)\n{\n    vec3 col = TexCube(iChannel0, pos*.1, nor).zxy;\n    col *= Colour(pos);\n    return col;\n}\n\n\n\/\/--------------------------------------------------------------------------\nvec3 CameraPath( float t )\n{\n    vec3 p = vec3(-13.0 +3.4 * sin(t),-0.+4.5 * cos(t),-1.1+.3 * sin(2.3*t+2.0) );\n\treturn p;\n} \n    \n\n\/\/--------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fcoord = fragCoord;\n\tfloat m = (iMouse.x\/iResolution.x)*20.0;\n\tfloat gTime = ((iGlobalTime+26.)*.2+m);\n    vec2 xy = fragCoord.xy \/ iResolution.xy;\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x\/iResolution.y,1.0);\n\n    \/\/ Animate...\n    CSize = vec3(.808, .99-sin((gTime+35.0)*.5)*.3, 1.151-sin((gTime+16.0)*.78)*.3);\n\t\n\tvec3 cameraPos \t= CameraPath(gTime + 0.0);\n\tvec3 camTarget \t= vec3 (-12., .0, -2.0);\n\n\tvec3 cw = normalize(camTarget-cameraPos);\n\tvec3 cp = vec3(0.0, 0.0,1.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = cross(cu,cw);\n\tvec3 dir = normalize(uv.x*cu + uv.y*cv + 1.1*cw);\n\n\tvec3 col = vec3(.0);\n\t\n    for (int i = 0; i <2; i++)\n    {\n\t\tdStack[i] = vec4(-20.0);\n    }\n\tfloat alpha = Scene(cameraPos, dir);\n\t\n    \n    \/\/ Render both stacks...\n    for (int s = 0; s < 2; s++)\n    {\n        for (int i = 0; i < 4; i++)\n        {\n            float d = dStack[s][i];\n            if (d < 0.0) continue;\n            float sphereR = SphereRadius(d);\n            vec3 pos = cameraPos + dir * d;\n            vec3 normal = GetNormal(pos, sphereR);\n            vec3 alb = Albedo(pos, normal);\n            col += DoLighting(alb, pos, normal, dir, d)* aStack[s][i];\n        }\n    }\n    \/\/ Fill in the rest with fog...\n   col += FOG_COLOUR *  (1.0-alpha);\n   \n   \n\tcol = PostEffects(col, xy) * smoothstep(.0, 2.0, iGlobalTime);\t\n\t\n\tfragColor=vec4(col,1.0);\n}\n\n\/\/--------------------------------------------------------------------------","name":"","description":"","type":"image"}]}}