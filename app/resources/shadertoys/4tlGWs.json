{"Shader":{"ver":"0.1","info":{"id":"4tlGWs","date":"1426283169","viewed":907,"name":"Britney Planet","username":"leon","description":"Learning raymarching distance fields with experiments","likes":8,"published":3,"flags":0,"tags":["raymarching","planet"],"hasliked":0},"renderpass":[{"inputs":[{"id":4,"src":"\/presets\/tex03.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":12,"src":"\/presets\/vid01.webm","ctype":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ <3 Shadertoy\n\/\/ thank to @uint9 -> http:\/\/9bitscience.blogspot.fr\/2013\/07\/raymarching-distance-fields_14.html\n\n#define PI 3.141592653589\n\n\/\/ Raymarching\nconst float rayEpsilon = 0.001;\nconst float rayMin = 0.1;\nconst float rayMax = 10.0;\nconst int rayCount = 24;\n\n\/\/ Camera\nvec3 eye = vec3(0, 0, -1.5);\nvec3 front = vec3(0, 0, 1);\nvec3 right = vec3(1, 0, 0);\nvec3 up = vec3(0, 1, 0);\n\n\/\/ Animation\nvec2 uvScale1 = vec2(2.0);\nvec2 uvScale2 = vec2(2.0);\nfloat terrainHeight = 0.2;\nfloat sphereRadius = 0.9;\nfloat translationSpeed = 0.4;\nfloat rotationSpeed = 0.1;\n\n\/\/ Colors\nvec3 skyColor = vec3(0, 0, 0.1);\nvec3 shadowColor = vec3(0.1, 0, 0);\n\nvec3 rotateY(vec3 v, float t)\n{\n    float cost = cos(t); float sint = sin(t);\n    return vec3(v.x * cost + v.z * sint, v.y, -v.x * sint + v.z * cost);\n}\nvec3 rotateX(vec3 v, float t)\n{\n    float cost = cos(t); float sint = sin(t);\n    return vec3(v.x, v.y * cost - v.z * sint, v.y * sint + v.z * cost);\n}\n\nfloat sphere( vec3 p, float s ) { return length(p)-s; }\nfloat reflectance(vec3 a, vec3 b) { return dot(normalize(a), normalize(b)) * 0.5 + 0.5; }\nvec2 kaelidoGrid(vec2 p) { return vec2(step(mod(p, 2.0), vec2(1.0))); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \/\/ Ray from UV\n\tvec2 uv = fragCoord.xy * 2.0 \/ iResolution.xy - 1.0;\n    uv.x *= iResolution.x \/ iResolution.y;\n    vec3 ray = normalize(front + right * uv.x + up * uv.y);\n    \n    \/\/ Color\n    vec3 color = shadowColor;\n    \n    \/\/ Animation\n    float translationTime = iGlobalTime * translationSpeed;\n    \n    \/\/ Raymarching\n    float t = 0.0;\n    for (int r = 0; r < rayCount; ++r)\n    {\n        \/\/ Ray Position\n        vec3 p = eye + ray * t;\n        vec3 originP = p;\n        \n        \/\/ Transformations\n        p = rotateY(p, PI \/ 2.0);\n       \tp = rotateX(p, PI \/ 2.0);\n        vec2 translate = vec2(0.0, translationTime);\n        \n        \/\/ Sphere UV\n        float angleXY = atan(p.y, p.x);\n        float angleXZ = atan(p.z, p.x);\n        vec2 sphereP1 = vec2(angleXY \/ PI, 1.0 - reflectance(p, eye)) * uvScale1;\n        vec2 sphereP2 = vec2(angleXY \/ PI, reflectance(p, eye)) * uvScale2;\n        sphereP1 += 0.5;\n        sphereP2 += mix(vec2(translationTime), vec2(-translationTime), \n                        vec2(step(angleXY, 0.0), step(angleXZ, 0.0)));\n        vec2 uv1 = mod(mix(sphereP1, 1.0 - sphereP1, kaelidoGrid(sphereP1)), 1.0);\n        vec2 uv2 = mod(mix(sphereP2, 1.0 - sphereP2, kaelidoGrid(sphereP2)), 1.0);\n        \n        \/\/ Texture\n        vec3 texture = texture2D(iChannel0, uv1).rgb;\n        vec3 texture2 = texture2D(iChannel1, uv2).rgb;\n        \n        \/\/ Height from luminance\n        float luminance = (texture.r + texture.g + texture.b) \/ 3.0;\n        texture = mix(texture, texture2, 1.0 - step(texture.g - texture.r - texture.b, -0.3));\n        color = texture;\n        luminance = (texture.r + texture.g + texture.b) \/ 3.0;\n        \n        \/\/ Displacement\n        p -= normalize(p) * terrainHeight * luminance * reflectance(originP, eye);\n        \n        \/\/ Distance to Sphere\n        float d = sphere(p, sphereRadius);\n        \n        \/\/ Distance min or max reached\n        if (d < rayEpsilon || t > rayMax)\n        {\n            \/\/ Shadow from ray count\n            color = mix(color, shadowColor, float(r) \/ float(rayCount));\n            \/\/ Sky color from distance\n            color = mix(color, skyColor, smoothstep(rayMin, rayMax, t));\n            break;\n        }\n        \n        \/\/ Distance field step\n        t += d;\n    }\n    \n    \/\/ Hop\n\tfragColor = vec4(color, 1);\n}","name":"","description":"","type":"image"}]}}