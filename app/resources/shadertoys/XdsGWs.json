{"Shader":{"ver":"0.1","info":{"id":"XdsGWs","date":"1381824467","viewed":1656,"name":"Star PSF","username":"FabriceNeyret2","description":"TAB: 1 vs many. <br\/>      if 1: col=BlackBody(T) vs RGB ( SPACE: mouse.xy = rGB\/RGb )<br\/><br\/>star proj = fraction of captor pixel.<br\/>But lense+aperture diffraction yields Airy spot + cross (diffract on 2ndary mirror handles). <br\/>And bright stars saturate filters.","likes":8,"published":3,"flags":0,"tags":["astrophysics","optics"],"hasliked":0},"renderpass":[{"inputs":[{"id":17,"src":"\/presets\/tex12.png","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ #### realistic display of star in Hubble images ################\n\/\/                            Fabrice NEYRET 15 oct 2013\n\/\/ toggles:\n\/\/    T:      tune (R)GB  vs   Planck spectrum(T)\n\/\/    SPACE:  tune 1GB  vs RG1\n\n#define NB_STARS 200\n#define PERS 1          \/\/ perspective\n\n#define SCALE 40.\nfloat star_luminosity = 1e3;\nvec3 star_color = vec3(1.,.3,.1)*star_luminosity;\n#define PI 3.1415927\nfloat t = iGlobalTime;\nvec2 FragCoord;\n\n\/\/--- filter integration (l0..l1) on black body spectrum(T) ---------\nfloat F(float x) \n{ return (6.+x*(6.+x*(3.+x)))*exp(-x); }\nfloat IntPlanck(float T,float lambda1,float lambda0) \n{\n\tconst float A=1.1, B=1.\/1.05;\n\tfloat C0 = 0.014387770, C=C0\/(B*T);\n\tT = 1.; \/\/ normalised spectrum better for display :-)\n\treturn 100.*A\/B*pow(100.*T\/C0,4.)*( F(C\/lambda1) - F(C\/lambda0) );\n}\n\n\/\/ --- Planck black body color I.spectrum(Temp) -----------------------\nvec3 Planck(float T) {\n\treturn vec3(\n\t\tIntPlanck(T,.7e-6,.55e-6),   \/\/ red filter\n        IntPlanck(T,.55e-6,.49e-6),  \/\/ green filter\n        IntPlanck(T,.49e-6,.4e-6)    \/\/ blue filter\n\t\t)*1e-14;\n}\n\n\/\/--- draw one star:  (I.filter(color)).dirac * PSF ------------------ \nvec3 draw_star(vec2 pos, float I) {\n\t\/\/ star out of screen\n\tif (pos!=clamp(pos,vec2(0.),vec2(1.8,1.))) return vec3(0.);\n\t\n\tpos -= FragCoord.xy\/iResolution.y; \n\t\n\/\/ Airy spot = (2BesselJ(1,x)\/x)^2 ~ cos^2(x-2Pi\/4)\/x^3 for x>>1\n\/\/ pixels >> fringes -> smoothed Airy ~ 1\/x^3\n\tfloat d = length(pos)*SCALE;\n\t\n\tvec3 col, spectrum = I*star_color;\n#if 1\n\tcol = spectrum\/(d*d*d);\n#else\n\tcol = spectrum*(1.+.323*cos(d\/4.+PI\/2.))\/(d*d*d);\n#endif\n\t\n\/\/ 2ndary mirror handles signature (assuming handles are long ellipses)\n\td = length(pos*vec2(50.,.5))*SCALE;\n\tcol += spectrum\/(d*d*d);\n\td = length(pos*vec2(.5,50.))*SCALE;\n\tcol += spectrum\/(d*d*d);\n\n\treturn col;\n}\n\n\/\/ --- utility functions ----------------------------------\nfloat rnd ( int n ) { return fract(sin(float(n)*543.21)*43758.5453);} \nfloat srnd( int n ) { return -1.+2.*fract(sin(float(n)*543.21)*43758.5453);} \n\nbool key_toggle(float ascii) { \n\treturn (texture2D(iChannel0,vec2((ascii+.5)\/256.,0.75)).x > 0.); \n}\n\n\/\/ --- GUI: mouse tuning ----------------------------------\nvec3 userInterface() {\n\tvec2 uv = FragCoord.xy\/iResolution.y - vec2(.8,.5);\n\tvec3 col=vec3(0.); float d;\n\tvec4 mouse = iMouse\/iResolution.y;\n\n\tif(!key_toggle(9.)) return col; \/\/ 'TAB' key : automatic stars field -> exit\n\t\n\tif (mouse.x+mouse.y==0.) mouse.xy=vec2(.3,.1); \/\/ 1st mouse position silly\n\t\n\td = length(uv+vec2(.8,.5)-mouse.xy); \/\/ color cursor\n\tif (d<.02) col = vec3(0.,0.,1.);\n\t\n\tif(key_toggle(84.))  \/\/ 'T' key : tune RGB vs Temperature->Planck Spectrum\n\t{   \/\/ ---  Plank Spectrum mode ---\n\t\tfloat T = 40000.*iMouse.x\/iResolution.x;\n\t\tstar_color = Planck(T);\n\t\t\/\/ star_luminosity = pow(T,4.);\n\t} \n\telse \n\t{   \/\/ --- RGB mode ---\n\t\tstar_color.gb = mouse.xy*star_luminosity; \n\t\tif(key_toggle(32.))  \/\/ SPACE key: red or blue dominant, tune the 2 others\n\t\t{ star_color=star_color.bgr; col=col.bgr;}\n\t}\n\t\n\t\/\/ display the 3-filters analyzor at bottom\n\tif ((uv.y<-.4)&&(abs(uv.x)<.102)) {\n\t\tif (uv.y<-.402) col=  vec3(\n\t\t\t((uv.x>-.10)&&(uv.x<-.031))?1.:0., \/\/ red frame\n\t\t\t((uv.x>-.029)&&(uv.x<.029))?1.:0., \/\/ green frame\n\t\t\t((uv.x< .10)&&(uv.x> .031))?1.:0.  \/\/ blue frame\n\t\t)*star_color\/star_luminosity;\n\tif ((abs(uv.x)<.102)&&(col.r+col.g+col.b==0.)) col = vec3(1.);\n\t}\n\t\n\treturn col;\n}\n\n\n\/\/ --- main -----------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec3 col;\n\tFragCoord=fragCoord;\n    \n\t\/\/ --- tunings (color and display mode)\n\tcol = userInterface(); \n\t\n\t\/\/ --- camera\n\tvec3 cam = vec3(.3*sin(12.+t+.3*sin(2.2*t)),\n\t\t\t\t\t.3*sin(5.+.5*t-.2*cos(t)+sin(.31*t)),\n\t\t\t\t\t.3*sin(-2.+.6*t+.16*sin(.26*t))-3.);\n\tfloat a = .7*sin(.1*t+.02*sin(.33*t) );\n\tfloat c=cos(a),s=sin(a);\n\tmat2 m = mat2(c,-s, s,c), im=mat2(c,s, -s,c);\n\t\/\/mat3 m = mat3(c,-s,0., s,c,0., 0.,0.,1.);\n\t\n\t\/\/ --- display stars \n\tif(key_toggle(9.)) \/\/ 'TAB' key\n\t\tcol += draw_star(vec2(.8,.5),1.);  \/\/ one single centred star\n\telse \n\t{\n\t\t\/\/ background\n\t\tvec2 uv = im*(fragCoord.xy\/iResolution.y)+cam.xy;\n\t\tfloat bg = texture2D(iChannel1,uv).r;\n\t\tcol += .5*exp(-7.*bg);\n\n\t\t\/\/ do stars\n\t\tfor (int i=0; i<NB_STARS; i++) {\n\t\t\t\/\/ random position, intensity(=surf), temperature(->color)\n\t\t\tvec3 pos = vec3(3.*srnd(6*i), 3.*srnd(6*i+1), 2.*srnd(6*i+3));\n\t\t\tfloat I = .02*exp(-15.*rnd(6*i+4));\n\t\t\tstar_color = Planck(40000.*exp(-3.*rnd(6*i+5)));\n\n\t\t\t\/\/ project to screen coords\n\t\t\tpos = pos-cam;\n\t\t\tpos.xy = m*pos.xy;\n#if PERS \/\/ perspective\n\t\t\tpos.xy \/= pos.z;\n#endif\n\t\t\tif (pos.z>0.)\n\t\t\t\tcol += draw_star(pos.xy+vec2(.8,.5),I\/(pos.z*pos.z));\n\t\t}\n\t}\n\n\t\n\tfragColor = vec4(col,1.0);\n}","name":"","description":"","type":"image"}]}}