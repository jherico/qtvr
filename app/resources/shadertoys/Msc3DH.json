{"Shader":{"ver":"0.1","info":{"id":"Msc3DH","date":"1449307843","viewed":337,"name":"2015\/12\/05","username":"hughsk","description":"Reducing artifacts in repeated SDFs by mirroring their contents in each cell. Hold down LMB to view with mirroring disabled.","likes":10,"published":3,"flags":0,"tags":["mod","mirror","repeat"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define GLSLIFY 1\n\nvec2 geometry(vec3 p);\n\nfloat sFract(float x){\n  x = fract(x); \n  return min(x, x*(1.-x)*8.);\n}\n\nvec3 getRulerColor_0_2(float t) {\n  float t1 = pow(sFract(t), 5.0);\n  float t2 = pow(sFract(t * 10.0), 2.0);\n  float t3 = clamp(t1 * 0.25 + t2 * 0.15, 0.0, 1.0);\n  vec3 c = mix(mix(vec3(0.1,0.2,1.0), vec3(1.0,0.2,0.1), t*0.5), vec3(1.0), smoothstep(0.2,0.5,t*0.12));\n  return vec3(c) - vec3(t3);\n}\n\nvec2 squareFrame_1_3(vec2 screenSize) {\n  vec2 position = 2.0 * (gl_FragCoord.xy \/ screenSize.xy) - 1.0;\n  position.x *= screenSize.x \/ screenSize.y;\n  return position;\n}\n\nvec2 squareFrame_1_3(vec2 screenSize, vec2 coord) {\n  vec2 position = 2.0 * (coord.xy \/ screenSize.xy) - 1.0;\n  position.x *= screenSize.x \/ screenSize.y;\n  return position;\n}\n\nmat3 calcLookAtMatrix_7_1(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nvec3 getRay_9_4(mat3 camMat, vec2 screenPos, float lensLength) {\n  return normalize(camMat * vec3(screenPos, lensLength));\n}\n\nvec3 getRay_9_4(vec3 origin, vec3 target, vec2 screenPos, float lensLength) {\n  mat3 camMat = calcLookAtMatrix_7_1(origin, target, 0.0);\n  return getRay_9_4(camMat, screenPos, lensLength);\n}\n\nvec3 calcNormal_2_5(vec3 pos, float eps) {\n  const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n  const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n  const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n  const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n  return normalize( v1 * geometry( pos + v1*eps ).x +\n                    v2 * geometry( pos + v2*eps ).x +\n                    v3 * geometry( pos + v3*eps ).x +\n                    v4 * geometry( pos + v4*eps ).x );\n}\n\nvec3 calcNormal_2_5(vec3 pos) {\n  return calcNormal_2_5(pos, 0.002);\n}\n\nvec2 calcRayIntersection_3_6(vec3 rayOrigin, vec3 rayDir, float maxd, float precis) {\n  float latest = precis * 2.0;\n  float dist   = +0.0;\n  float type   = -1.0;\n  vec2  res    = vec2(-1.0, -1.0);\n\n  for (int i = 0; i < 40; i++) {\n    if (latest < precis || dist > maxd) break;\n\n    vec2 result = geometry(rayOrigin + rayDir * dist);\n\n    latest = result.x;\n    type   = result.y;\n    dist  += latest;\n  }\n\n  if (dist < maxd) {\n    res = vec2(dist, type);\n  }\n\n  return res;\n}\n\nvec2 calcRayIntersection_3_6(vec3 rayOrigin, vec3 rayDir) {\n  return calcRayIntersection_3_6(rayOrigin, rayDir, 20.0, 0.001);\n}\n\nfloat beckmannDistribution_6_0(float x, float roughness) {\n  float NdotH = max(x, 0.0001);\n  float cos2Alpha = NdotH * NdotH;\n  float tan2Alpha = (cos2Alpha - 1.0) \/ cos2Alpha;\n  float roughness2 = roughness * roughness;\n  float denom = 3.141592653589793 * roughness2 * cos2Alpha * cos2Alpha;\n  return exp(tan2Alpha \/ roughness2) \/ denom;\n}\n\nfloat cookTorranceSpecular_8_7(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float fresnel) {\n\n  float VdotN = max(dot(viewDirection, surfaceNormal), 0.0);\n  float LdotN = max(dot(lightDirection, surfaceNormal), 0.0);\n\n  \/\/Half angle vector\n  vec3 H = normalize(lightDirection + viewDirection);\n\n  \/\/Geometric term\n  float NdotH = max(dot(surfaceNormal, H), 0.0);\n  float VdotH = max(dot(viewDirection, H), 0.000001);\n  float LdotH = max(dot(lightDirection, H), 0.000001);\n  float G1 = (2.0 * NdotH * VdotN) \/ VdotH;\n  float G2 = (2.0 * NdotH * LdotN) \/ LdotH;\n  float G = min(1.0, min(G1, G2));\n  \n  \/\/Distribution term\n  float D = beckmannDistribution_6_0(NdotH, roughness);\n\n  \/\/Fresnel term\n  float F = pow(1.0 - VdotN, fresnel);\n\n  \/\/Multiply terms and done\n  return  G * F * D \/ max(3.14159265 * VdotN, 0.000001);\n}\n\nfloat smin_4_8(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (b - a) \/ k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat fogFactorExp2_5_9(\n  const float dist,\n  const float density\n) {\n  const float LOG2 = -1.442695;\n  float d = density * dist;\n  return 1.0 - clamp(exp2(d * d * LOG2), 0.0, 1.0);\n}\n\nfloat intersectPlane(vec3 ro, vec3 rd, vec3 nor, float dist) {\n  float denom = dot(rd, nor);\n  float t = -(dot(ro, nor) + dist) \/ denom;\n\n  return t;\n}\n\nvec2 rotate2D(vec2 p, float a) {\n  return p * mat2(cos(a), -sin(a), sin(a),  cos(a));\n}\n\nvec2 mirror(vec2 p, float v) {\n  float hv = v * 0.5;\n  vec2  fl = mod(floor(p \/ v + 0.5), 2.0) * 2.0 - 1.0;\n  vec2  mp = mod(p + hv, v) - hv;\n\n  if (iMouse.z > 0.0) fl = abs(fl);\n    \n  return fl * mp;\n}\n\nvec2 geometry(vec3 p) {\n  p.x += cos(iGlobalTime) * 5.0;\n\n  p.xz = mirror(p.xz, 10.0);\n  p.xz = rotate2D(p.xz, iGlobalTime);\n  float d = 99999.;\n\n  d = min(d, length(p - vec3(5, 0, 0)) - 0.5);\n  d = min(d, length(p - vec3(0, 0, 5)) - 0.5);\n  d = min(d, length(p + vec3(5, 0, 0)) - 0.5);\n  d = min(d, length(p + vec3(0, 0, 5)) - 0.5);\n  d = smin_4_8(d, length(p) - 2.0 * (sin(iGlobalTime) * 0.5 + 0.75), 3.0);\n  return vec2(d, 1.0);\n}\n\nvec3 draw(vec2 coord, vec3 co, vec3 cd) {\n  vec2 uv = squareFrame_1_3(iResolution.xy, coord);\n  cd = getRay_9_4(co, co + cd, uv, 2.0);\n\n  vec3 bg = vec3(0.3 + 0.7 * gl_FragCoord.x \/ iResolution.x, 0.7, 1.2);\n  bg *= 1.0 + 0.8 * max(0.0, gl_FragCoord.y \/ iResolution.y - 0.8);\n    \n  float u = intersectPlane(co, cd, vec3(0, 1, 0), 0.0);\n  vec2  t = calcRayIntersection_3_6(co, cd, 75., 0.01);\n\n  if (max(t.x, u) < 0.0) return pow(bg, vec3(0.75));\n\n  bool plane = (u > 0.0 && t.x > u) || (t.x < 0.0 && u > 0.0);\n  vec3 dir = vec3(0, 1, 0);\n  vec3 pos, nor, col;\n\n  if (plane) {\n    pos = co + cd * u;\n    nor = vec3(0, 1, 0);\n    col = getRulerColor_0_2(geometry(pos).x);\n  } else {\n    pos = co + cd * t.x;\n    nor = calcNormal_2_5(pos);\n    float spec = cookTorranceSpecular_8_7(dir, -cd, nor, 0.5, 0.5);\n    float diff = max(0.0, dot(nor, dir));\n    col = vec3(spec * 0.8 + diff * vec3(0.5) + 0.4);\n  }\n\n  col = mix(col, bg, fogFactorExp2_5_9(plane ? u : t.x, 0.025));\n  col = pow(col, vec3(0.75));\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  fragColor.rgb = draw(fragCoord.xy, vec3(0, 6., 0), normalize(vec3(0.5, -0.25, 0.6)));\n  fragColor.a = 1.0;\n}\n","name":"","description":"","type":"image"}]}}