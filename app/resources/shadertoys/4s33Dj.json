{"Shader":{"ver":"0.1","info":{"id":"4s33Dj","date":"1452130061","viewed":505,"name":"Swarm Segregation (ICRA 2014)","username":"vgs","description":"Please rewind the shader (reset time button) to fix initialization issues (black screen or others)<br\/>Each colored circle belongs to a team, and they must flock while segregating from different teams.<br\/>Press SPACE to switch the number of teams! Try it!","likes":29,"published":3,"flags":48,"tags":["robot","control","swarm","robotics","flocks","flocking"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Vinicius Graciano Santos - vgs\/2016\n\/\/ This shader is an implementation of my ICRA 2014 paper:\n\/\/ \"Segregation of Multiple Heterogeneous Units in a Robotic Swarm\"\n\n\/\/ If you are interested, the paper can be found in these links:\n\/\/ http:\/\/dx.doi.org\/10.1109\/ICRA.2014.6906993\n\/\/ http:\/\/viniciusgraciano.com\/downloads\/icra2014-segregation.pdf\n\n\/\/ The controller works in 3D too, as you can see in the end of this video:\n\/\/ https:\/\/www.youtube.com\/watch?v=tN6yEOUU00I\n\nvec4 loadState(in vec2 id) {\n    vec2 uv = (id + 0.5) \/ iChannelResolution[0].xy;\n    return texture2D(iChannel0, uv);\n}\n\n\/\/ https:\/\/www.shadertoy.com\/view\/MsS3Wc (by iq)\nvec3 hsv2rgb(in vec3 c) {\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);\n\trgb = rgb*rgb*(3.0-2.0*rgb);\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n    \/\/ Center the scene around the centroid of the swarm.\n    vec2 c = vec2(0.0);\n    for (int i = 0; i < 10; ++i)\n        for (int j = 0; j < 10; ++j)\n        \tc += loadState(vec2(i, j)).xy;    \n    \n    vec2 uv = 6.0 * (-iResolution.xy + 2.0*fragCoord) \/ iResolution.y + c\/100.0;     \n    \n    \/\/ Render the swarm.\n    float dist = 1e10; int id = 0;\n    for (int i = 0; i < 10; ++i) {\n        for (int j = 0; j < 10; ++j) {\n       \t \tfloat d = length(uv - loadState(vec2(i, j)).xy);\n        \tif (d < dist) {dist = d; id = 10*i+j;}\n    \t}    \n    }\n    dist = smoothstep(0.1, 0.2, dist);    \n    float fadein = smoothstep(0.5, 2.0, iGlobalTime);\n    \n    \/\/ Select a color for each team.    \n    int TEAMS = int(loadState(vec2(10.0)).x), RPT = 100 \/ TEAMS;\n    vec3 col = fadein * (1.0 - dist) * hsv2rgb(vec3(float(id\/RPT)\/float(TEAMS), 1.0, 1.0)) + 0.1;\n    \n    col = smoothstep(0.0, 1.0, col);\n    col = pow(col, vec3(0.4545));    \n\tfragColor = vec4(col, 1.0);\n}","name":"","description":"","type":"image"},{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/* Simulation Logic *\/\n\n\/\/ If the simulation is too fast\/slow, decrease\/increase the values of ALPHA and DT\n\/\/ This happens because the simulation currently depends on the frame rate...\n\/\/ I'll try to fix this soon...\n\n\/\/ ALPHA controls the magnitude of the pairwise force\n\/\/ dAA relates to the spacing between robots in the same team\n\/\/ dAB relates to the spacing between robots in different teams\n\/\/ DT is the delta time of the simulation\n\/\/ HINT: if you switch the values of dAA and dAB the swarm will aggregate instead of segregate\n#define ALPHA 12.5\n#define dAA 4.0\n#define dAB 7.0\n#define DT 0.01\n\nvec4 initState(in vec2 id) {\n    vec2 uv = (id + 0.5) \/ iChannelResolution[1].xy;\n    vec2 r = 2.0 * texture2D(iChannel1, uv).rg - 1.0;\n    return vec4(40.0 * r, 0.0, 0.0);    \n}\n\nvec4 loadState(in vec2 id) {\n    vec2 uv = (id + 0.5) \/ iChannelResolution[0].xy;\n    return texture2D(iChannel0, uv);\n}\n\nvec4 updateState(in vec2 id, in int teams) {\n    int RPT = 100 \/ teams;\n    \n    vec2 u = vec2(0.0);\n    vec4 qi = loadState(id);\n        \n    for (int i = 0; i < 10; ++i) {\n    \tfor (int j = 0; j < 10; ++j) {        \t\n        \n        \tvec4 qj = loadState(vec2(i, j));\n        \tvec2 qij = qi.xy - qj.xy;\n        \tfloat mqij = length(qij);\n        \tfloat dij = ((10*i+j)\/RPT == int(10.0*id.x+id.y)\/RPT) ? dAA : dAB;\n        \n        \tif (mqij < 1e-2) continue;\n    \n        \t\/\/ Control equation (eq. 2 in the paper)\n        \tu -= ALPHA * (mqij - dij + 1.0\/mqij - dij\/(mqij*mqij)) * qij \/ mqij;\n        \tu -= qi.zw - qj.zw;        \n    \t}\n\t}\n\n    \/\/ Simple ODE solver.\n    qi.xy += qi.zw * DT + 0.5 * u * DT * DT;\n    qi.zw += u * DT;\n    return qi;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    fragCoord = floor(fragCoord);    \n    if (fragCoord.x > 10.0 || fragCoord.y > 10.0) discard;\n        \n    vec4 data = vec4(5.0, 0.0, 0.0, 0.0), state = initState(fragCoord);\n    \n    if (iFrame > 30) {\n        data = loadState(vec2(10.0));\n    \tstate = updateState(fragCoord, int(data.x));\n        \n        float space = texture2D(iChannel2, vec2(32.5\/256.0,0.25)).x;\n        if (space > 0.5 && (iGlobalTime - data.y) > 0.5) {\n        \tdata.y = iGlobalTime;\n        \tif (data.x == 2.0) data.x = 4.0;\n        \telse if (data.x == 4.0) data.x = 5.0;\n        \telse if (data.x == 5.0) data.x = 10.0;\n        \telse data.x = 2.0;\n        }        \n    }    \n    \n    fragColor = fragCoord != vec2(10.0) ? state : data;\n}","name":"","description":"","type":"buffer"}]}}