{"Shader":{"ver":"0.1","info":{"id":"ltSSDh","date":"1443161254","viewed":379,"name":"Space versus Time.","username":"qwert33","description":"Without time, space is nothing","likes":0,"published":3,"flags":0,"tags":["time","space","homestuck"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\nfloat space;\nfloat time;\n\n\/\/ Code made by Dominik Schmid (DominikSchmid93@gmail.com)\n\/\/ All rights reserved.\n\/\/ I'm willing to give permission but you need to request it.\n\n\/\/======= configuration ======\nconst bool stars              = true;  \/\/ true or false\nconst bool antialiasing       = !stars;  \/\/ performance \/ quality tradeoff\nconst float star_brightness   = 60.0;\nconst float period_animating  = 7.0;\nconst float period_paused     = 3.0;  \/\/ set to 0.0 for continuous spinning\nconst float noise_speed       = 0.04;\nconst float noise_period      = 2.0;\nconst float symbol_spin_speed = 0.5;\nconst float symbol_size       = 0.47;\n\/\/============================\n\n\n\n\nfloat semiCircle(float x) {\n    x = (2.0 * x - 1.0);\n    return sqrt(1.0 - x*x);\n}\n\n\/\/ ====== GOD-TIER MAGIC NUMBERS BE HERE ======\nbool funcTop(vec2 uv) {\n    float v = uv.x;\n    return uv.y < (\n        semiCircle(v) * 1.0572 +\n    \tv * -2.5859 +\n    \tv*v * 4.6388 +\n    \tv*v*v * -3.4358 +\n    \tv*v*v*v * -0.3645 +\n    \tv*v*v*v*v * 2.3144 +\n        v*v*v*v*v*v * -0.74707\n    );\n}\nbool funcBot(vec2 uv) {\n    float v = uv.x;\n    return uv.y > (\n    \tv * 3.6983 +\n    \tv*v * -15.727 +\n    \tv*v*v * 37.77 +\n    \tv*v*v*v * -52.872 +\n    \tv*v*v*v*v * 39.513 +\n        v*v*v*v*v*v * -12.563\n    );\n}\nfloat arc(vec2 uv) {\n    if (uv.x < 0.0) return 0.0;\n    if (uv.x > 1.0) return 0.0;\n    if (funcTop(uv) && funcBot(uv)) return 1.0;\n    return 0.0;\n}\n\n\/\/ outputs a linearly rising function which is periodically flat\nfloat pauseStep(float x, float d1, float d2) {\n    return (\n        min(d1, mod(x, d1+d2)) + \n        d1 * floor(x \/ (d1+d2))\n    );\n}\n\nfloat rand(vec2 p){\n    p \/= iResolution.xy;\n    return fract(sin(dot(p.xy, vec2(12.9898, 78.2377))) * 43758.5453);\n}\n\nfloat getNoise(vec2 noiseCoord, float angleOffset, float noiseSeed, float r) {\n    float angle = noise_period * time;\n    angle += angleOffset;\n    r *= space;\n    noiseCoord += vec2(\n        floor(r * sin(angle)),\n        floor(r * cos(angle))\n    );\n    \n    noiseCoord.x += noiseSeed;\n    \n    return rand(noiseCoord);    \n}\n\n\/\/ makes a rotation matrix\nmat2 rotate(float theta) {\n    float s = sin(theta);\n    float c = cos(theta);\n    return mat2(\n        c, -s,\n        s,  c\n    );\n}\n\n\/\/ magic function to make a bending curve\nfloat twang(float x, float d) {\n    return (\n        (x * (d*d*d + d)) \/\n        (d * (d*d + abs(x)))\n    );\n}\n\nvoid isInSymbol(vec2 uv, out float layer) {\n    uv \/= symbol_size;\n    \n    \/\/layer += (length(uv) < 0.7)? 1.0 : 0.0;  \/\/ a circle in the middle\n    float t = time * symbol_spin_speed;\n    layer += arc(rotate(t + radians(000.0)) * uv);\n    layer += arc(rotate(t + radians(060.0)) * uv);\n    layer += arc(rotate(t + radians(120.0)) * uv);\n    layer += arc(rotate(t + radians(180.0)) * uv);\n    layer += arc(rotate(t + radians(240.0)) * uv);\n    layer += arc(rotate(t + radians(300.0)) * uv);\n}\n\n\/\/ clamps to 0..1\nfloat clamp01(float x) {\n    return max(0.0, min(1.0, x));\n}\n\n\/\/ maps from pixel coordinate frame to UV coordinate frame\nvec2 toSpace_uv(vec2 space_pixel) {\n    return space_pixel.xy \/ space;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    space = min(iResolution.x, iResolution.y);\n\ttime = pauseStep(iGlobalTime, period_animating, period_paused);\n    \n    vec2 pix = fragCoord;\n    vec2 uv = toSpace_uv(pix.xy);\/\/(p.xy - iResolution.xy \/ 2.0) \/ space;\n    uv -= toSpace_uv(iResolution.xy \/ 2.0);\n    \/\/ uv += toSpace_uv(vec2(sin(time), 0.0)); \/\/ minor wobble to test antialiasing\n    \n    float layer = 0.0; \/\/ in which of the two layers are we? range 0..1\n    isInSymbol(uv, layer);\n    \n    if (antialiasing) {\n        const float AA_radius = 0.5;\n        isInSymbol(uv + toSpace_uv(AA_radius * vec2( 1.0,  0.0)), layer);\n        isInSymbol(uv + toSpace_uv(AA_radius * vec2(-1.0,  0.0)), layer);\n        isInSymbol(uv + toSpace_uv(AA_radius * vec2( 0.0, -1.0)), layer);\n        isInSymbol(uv + toSpace_uv(AA_radius * vec2( 0.0,  1.0)), layer);\n        layer \/= 5.0;\n    }\n    \n\n    float layer0 = !stars? 0.0 : getNoise(pix, radians(  0.0), 0.0, 1.0*noise_speed);\n    float layer1 = !stars? 1.0 : getNoise(pix, radians(180.0), 0.5, 1.0*noise_speed);\n    float brightness = mix(layer0, layer1, layer);\n    if (stars) {\n        brightness = 1.0 - twang(1.0 - brightness, star_brightness \/ space); \/\/ make stars less bright if we have more pixels\n    }\n    fragColor = vec4(brightness);\n    \n    if (stars) {\n        \/\/ apply some post-processing\n        fragColor *= vec4(0.8, 1.0, 0.9, 1.0);\n        \/\/fragColor *= min(1.0, 1.5 \/ (length(uv) * length(uv)));  \/\/ vignette\n        fragColor *= pow(1.5, -length(uv));  \/\/ subtle vignette\n    }\n}","name":"","description":"","type":"image"}]}}