{"Shader":{"ver":"0.1","info":{"id":"lstGDs","date":"1453124592","viewed":355,"name":"Fast Buddhabrot","username":"iq","description":"Low quality but fast Buddhabrot rendering. More info here: <a href=\"http:\/\/iquilezles.org\/www\/articles\/budhabrot\/budhabrot.htm\" class=\"regular\" target=\"_blank\">http:\/\/iquilezles.org\/www\/articles\/budhabrot\/budhabrot.htm<\/a>","likes":4,"published":3,"flags":32,"tags":["2d","fractal","buddhabrot"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\/\/ Low quality (somehow blurred) but fast Buddhabrot rendeirng. More info \n\/\/ here: http:\/\/iquilezles.org\/www\/articles\/budhabrot\/budhabrot.htm and\n\/\/ here: http:\/\/iquilezles.org\/www\/articles\/mset_1bulb\/mset1bulb.htm\n\nconst float precission = 350.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 f = texture2D( iChannel0, fragCoord\/iResolution.xy ).xyz;\n\n    f *= precission*0.4\/float(iFrame+1);\n    \n    f = pow( f, vec3(0.8,0.68,0.6) );\n    \n    fragColor = vec4( f, 1.0 );\n}","name":"","description":"","type":"image"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\/\/ Low quality (somehow blurred) but fast Buddhabrot rendeirng. More info \n\/\/ here: http:\/\/iquilezles.org\/www\/articles\/budhabrot\/budhabrot.htm and\n\/\/ here: http:\/\/iquilezles.org\/www\/articles\/mset_1bulb\/mset1bulb.htm\n\nvec2 p2c( in vec2 p )\n{\n    vec2 q = p\/iResolution.xy; \n    q = -1.0 + 2.0*q;\n    q.x *= iResolution.x\/iResolution.y;\n    return (q - vec2(0.5,0.0))*1.1;\n}\n\n\nvec2 c2p( in vec2 c )\n{\n    vec2 q = c\/1.1 + vec2(0.5,0.0);\n    \n    q.x *= iResolution.y\/iResolution.x;\n\tq = (q+1.0)\/2.0;    \n    return q*iResolution.xy;\n    \n}\n\nvec2 hash( in float n )\n{ \n    return fract(sin(n+vec2(0.0,17.7))*1987.654321); \n}\n\nconst float precission = 350.0; \/\/ change in the image shader as well\n    \nconst vec3 thresholds = vec3(512.0,256.0,128.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 g = texture2D( iChannel0, fragCoord\/iResolution.xy ).xyz;\n    \n    float a = (500.0\/iResolution.x);\n    \n    \/\/ do 6 passes per frame (since texture memory bandwidh is slow, the \n    \/\/ more computations I do per frame the better)\n    for( int j=0; j<6; j++ )\n    {\n        vec3 f = g;\n\n        vec2 of =  hash( dot(fragCoord,vec2(12.9898,78.233)) + iGlobalTime*137.1123 + 99.62*float(j));\n\n        \/\/ pick a random point, but not in H1 or H2\n        vec2 c = vec2(0.0);\n        for( int i=0; i<10; i++ )\n        {\n            of = hash(dot(of,vec2(12.9898,78.233)));\n\n            c = p2c( of*iResolution.xy)*1.1;\n\n            \/\/ test H1 and H2\n            float c2 = dot(c,c);\n            vec2  d = c + vec2(1.0,0.0);\n            float h1 = 256.0*c2*c2 - 96.0*c2 + 32.0*c.x - 3.0;\n            float h2 = 16.0*dot(d,d) - 1.0;\n            if( h1>0.0 && h2>0.0 ) break;\n        }\n\n\n        \/\/ compute orit    \n        vec2 z  = vec2(0.0);\n        float n = 0.0;\n        for( int i=0; i<512; i++ )\n        {\n            z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n            if( dot(z,z)>9.0 ) break;\n\n            vec2  p1 = c2p(z);\n            vec2  p2 = c2p(vec2(z.x,-z.y));\n            float m1 = dot(p1-fragCoord,p1-fragCoord);\n            float m2 = dot(p2-fragCoord,p2-fragCoord);\n            vec3 ma = step( n, thresholds );\n            f += exp( -a*a*m1 )*ma;\n            f += exp( -a*a*m2 )*ma;\n            n += 1.0;\n        }\n\n        \/\/ accumulate, if divergent    \n        g = mix( g, f, step( n, thresholds-1.0 ) );\n        \n    }\n\n    fragColor = vec4( g, 1.0 );\n}","name":"","description":"","type":"buffer"}]}}