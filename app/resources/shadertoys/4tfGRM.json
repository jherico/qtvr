{"Shader":{"ver":"0.1","info":{"id":"4tfGRM","date":"1419644442","viewed":740,"name":"Shulgins' Eye","username":"jimbo00000","description":"A ripoff of, or homage to <a href=\"http:\/\/alexgrey.com\/art\/paintings\/soul\/the-shulgins\/\"  class=\"regular\" target=\"_blank\">Alex Grey's work.<\/a> I'd put it on the front of my Rift if it didn't block the positional tracking LEDs.","likes":4,"published":3,"flags":0,"tags":["eye","flames","alexgray","thirdeye","pihkal"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"const float PI = 3.1415926535979;\n\n\/\/\/\/\/\/\/\/ Matrix math library\nvec2 rotate(vec2 p, float t)\n{\n    mat2 m = mat2(cos(t),-sin(t),sin(t),cos(t));\n    return m*p;\n}\n\nvec2 topolar(vec2 p)\n{\n    return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 tocartesian(vec2 p)\n{\n    return vec2(cos(p.y)*p.x, sin(p.y)*p.x);\n}\n\n\/\/\/\/\/\/\/\/ Shape library\nfloat d_cone1( vec2 p, vec2 c, float time )\n{\n    p.x += 0.03 * sin(20.*(p.y+0.2 *time) );\n    float q = length(3.*p.x);\n    return dot(c,vec2(q,p.y));\n}\n\nfloat d_compound_cone_flame( vec2 p, vec2 c )\n{\n    float time = iGlobalTime;\n    float d = d_cone1( p, c, time );\n    for (float i=0.; i<7.; i+=1.)\n    {\n        float x = i*0.3;\n        vec2 off = vec2(x,\n            smoothstep(0.,1.1,x)\n            *1.2\n            );\n        vec2 ofs = vec2(-off.x, off.y);\n        vec2 pr = p;\n        vec2 ps = p;\n        if ((i == 2.0) || (i == 1.0))\n        {\n            pr = rotate(p+off, 0.15)-off;\n            ps = rotate(p+ofs, -0.15)-ofs;\n        }\n    \td = min(d, d_cone1( pr+off, c, time+i*37. ));\n        off.x = -off.x;\n    \td = min(d, d_cone1( ps+off, c, time+i*13. ));\n    }\n    return d;\n}\nfloat d_sphere( vec2 p, float radius )\n{\n    return length(p) - radius;\n}\n\nfloat d_eye2( vec2 p, float radius )\n{\n    p.y *= 1.-.6*p.y*step(0.,p.y);\n    float e = 0.2;\n    p.x += mix(-e,e,step(0.,p.x));\n    return d_sphere(p, radius);\n}\n\nfloat d_cone( vec2 p, vec2 c, float rot )\n{\n    if (p.x > 0.)\n        return 1e8;\n    p = rotate(p, rot);\n    float q = 16.*length(p.x);\n    return dot(c,vec2(q,p.y));\n}\n\nfloat d_conecomb( vec2 p, vec2 c )\n{\n    p.x += -0.005*sin(30.*p.x);\n    p.x = -abs(p.x);\n\n    p.x -= .15+.05*p.y;\n\n    float d = 1e8;\n    for (float i=0.25; i<.8; i+=.115)\n    {\n        vec2 pi = p;\n        pi.y += i;\n        d = min(d, d_cone(pi, c, .8*i+.5));\n    }\n    return d;\n}\n\nfloat eye_lashes( vec2 p )\n{\n    return\n        min(\n        d_eye2( p, 0.4),\n        d_conecomb(p+vec2(.0,-0.34), vec2(0.08,.05))\n        );\n}\n\nvec2 pupil_move( float x )\n{\n    float angle =\n        0.18*floor(5.*x)\n        ;\n    vec2 cp = tocartesian((vec2(1.,angle)));\n    \n    float flick =\n        pow(clamp(1.5*sin(1.7*x),0.,1.),10.)\n        +pow(clamp(1.*sin(3.7*x),0.,1.),10.)\n        ;\n\n    flick *= step(6.,x);\n\n    cp = normalize(cp) * flick;\n    cp *= vec2(1.,2.);\n    return 0.08*cp;\n}\n\n\n\/\/\/\/\/\/\/\/ Colorization\n\nvec3 col_step_flame( float d, vec2 uv )\n{    \n    vec2 sunpos = vec2(.0,-.45);\n    vec3 hot = vec3(1.,1.,1.);\n    vec3 orange = vec3(1.,.65,0.);\n    vec3 yellow = vec3(1.,1.,0.);\n    vec3 red = vec3(1.,0.,0.);\n    \n    float ds = length(uv-sunpos);\n    float f = clamp(pow(1.3-ds,3.),.0,1.);\n\n    float x = .75 * ds;\n    float mp = .3;\n    vec3 suncol =\n    \t(1.-step(mp,x))*mix(hot, yellow, x\/mp) +\n    \tstep(mp,x)*mix(yellow, red, .5*(x-mp))\n        ;\n    \/\/suncol = mix(orange, hot, f);\n    \n    \/\/ border blend\n    float bw = .05;\n    vec3 bcol = vec3(0.);\n    vec3 outcol = vec3(0.5);\n    vec3 col =\n        vec3\n        (\n        mix(suncol,bcol,smoothstep(-0.01,0.01,d))\n      + mix(bcol,outcol,smoothstep(bw,2.*bw,d))\n        );\n\n    return col;\n}\n\nvec3 border_blend(\n    float d,\n    float bw, float c, float co, \/\/ border width and softness\n    vec3 cin, vec3 cout, vec3 con \/\/ colors in, on and out\n    )\n{\n\treturn\n    \tmix(cin,con,smoothstep(-c,c,d))\n      + mix(con,cout,smoothstep(bw,(1.+co)*bw,d));\n}\n\nvec3 hue_bullseye( in vec2 uv, in vec2 center )\n{\n    float d = length(center - uv);\n    \n    vec3 dred = vec3(.5,0.,0.);\n    vec3 red = vec3(1.,0.,0.);\n    vec3 orange = vec3(1.,.75,0.);\n    vec3 yellow = vec3(1.,1.,0.);\n    vec3 green = vec3(0.,.75,0.);\n    vec3 blue = vec3(0.,0.,1.);\n\n    return\n        mix(mix(mix(mix(mix(mix(\n                  red,dred, smoothstep(0.01,0.05,d)\n                  ), orange,  smoothstep(0.05,0.08,d)\n                  ), yellow,  smoothstep(0.08,0.10,d)\n                  ), green,   smoothstep(0.10,0.14,d)\n                  ), blue,    smoothstep(0.13,0.16,d)\n                  ), vec3(1.),smoothstep(0.14,0.18,d)\n          );\n}\n\nvec3 getEyeColorFromUV( in vec2 uv, in vec3 cout )\n{\n    float dist = 1e9;\n\n    dist = eye_lashes(uv);\n    vec2 pupil = vec2(0.);\n\n    vec3 cin =\n    \thue_bullseye(uv, pupil + pupil_move(iGlobalTime));\n    \/\/vec3 cout = vec3(1.);\n    vec3 con = vec3(.0);\n    \n    return mix(\n        border_blend(dist, 0.03, .003, .21, cin, cout, con),\n        cout,step(.75,uv.y));\n}\n\nvec3 getFlameColorFromUV( in vec2 uv )\n{\n    float dist = 1.;\n    dist = d_compound_cone_flame(uv-vec2(0.,.9), vec2(1.,1.));\n    return vec3(col_step_flame(dist, uv));\n}\n\nvec3 getColorFromUV( in vec2 uv )\n{\n    vec3 fc = getFlameColorFromUV(uv);\n    return getEyeColorFromUV(uv+vec2(0.,.25), fc);\n}\n\n\n\/\/\/\/\/\/\/\/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\n\t\/\/ Fit [-1,1] into screen and expand for aspect ratio\n\tvec2 uv11 = 2.0*uv - vec2(1.0,1.0);\n\tfloat aspect = iResolution.x \/ iResolution.y;\n\tif (aspect > 1.0) uv11.x *= aspect;\n\telse              uv11.y \/= aspect;\n    \n    vec2 center = vec2(0.0,0.0);\n    \/\/vec2 center = vec2(sin(iGlobalTime),0.0);\n    uv11 -= center;\n\t\n\tfragColor = vec4(getColorFromUV(uv11), 1.0);\n}\n","name":"","description":"","type":"image"},{"inputs":[],"outputs":[{"channel":"0"}],"code":"float PI = 3.1415926535979;\n\nfloat fundamental(float time, float freq)\n{\n    float a = 0.;\n\n    for (float i=1.; i<=67.; i+=1.) \/\/ overtone series\n    {\n        float x = .0001*i*(time+16.);\n        float p =\n            1.\n            *sin(x*32.)\n            ;\n        \n        a += sin(2.*PI*freq*i*(time+p))\n            * .8\n            *1.\/(5.*i)\n            ;\n    }\n    \n    return a;\n}\n\nvec2 mainSound(float time)\n{\n    float freq = 64.;\n    \/\/return vec2(sin(2.*PI*freq*time)); \/\/ tuning check\n\n    float a = 0.;\n    a += fundamental(time, freq);\n    a += fundamental(time, freq*2.001);\n    a += fundamental(time, freq*1.500015);\n    \n    float vol = 1.05\n        * smoothstep(0., 5., time)\n        ;\n    return vol * vec2(a);\n}\n","name":"","description":"","type":"sound"}]}}