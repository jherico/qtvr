{"Shader":{"ver":"0.1","info":{"id":"XlX3RS","date":"1422730282","viewed":975,"name":"Page Curl Effect","username":"aiekick","description":"Shadertoy version of shader from qt540 project sample \"qmlvideofx\" himself inspired from <br\/>http:\/\/rectalogic.github.com\/webvfx\/examples_2transition-shader-pagecurl_8html-example.html<br\/>you can use mouse for control curl effect","likes":12,"published":3,"flags":0,"tags":["curl","effect","page"],"hasliked":0},"renderpass":[{"inputs":[{"id":12,"src":"\/presets\/vid01.webm","ctype":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"float curlExtent = 0.;\n    \nconst float minAmount = -0.16;\nconst float maxAmount = 1.3;\nconst float PI = 3.141592653589793;\nconst float scale = 512.0;\nconst float sharpness = 3.0;\nvec4 bgColor;\n\nfloat amount;\nfloat cylinderCenter;\nfloat cylinderAngle;\nconst float cylinderRadius = 1.0 \/ PI \/ 2.0;\n\nvec3 hitPoint(float hitAngle, float yc, vec3 point, mat3 rrotation)\n{\n    float hitPoint = hitAngle \/ (2.0 * PI);\n    point.y = hitPoint;\n    return rrotation * point;\n}\n\nvec4 antiAlias(vec4 color1, vec4 color2, float distance)\n{\n    distance *= scale;\n    if (distance < 0.0) return color2;\n    if (distance > 2.0) return color1;\n    float dd = pow(1.0 - distance \/ 2.0, sharpness);\n    return ((color2 - color1) * dd) + color1;\n}\n\nfloat distanceToEdge(vec3 point)\n{\n    float dx = abs(point.x > 0.5 ? 1.0 - point.x : point.x);\n    float dy = abs(point.y > 0.5 ? 1.0 - point.y : point.y);\n    if (point.x < 0.0) dx = -point.x;\n    if (point.x > 1.0) dx = point.x - 1.0;\n    if (point.y < 0.0) dy = -point.y;\n    if (point.y > 1.0) dy = point.y - 1.0;\n    if ((point.x < 0.0 || point.x > 1.0) && (point.y < 0.0 || point.y > 1.0)) return sqrt(dx * dx + dy * dy);\n    return min(dx, dy);\n}\n\nvec4 seeThrough(float yc, vec2 p, mat3 rotation, mat3 rrotation)\n{\n    float hitAngle = PI - (acos(yc \/ cylinderRadius) - cylinderAngle);\n    vec3 point = hitPoint(hitAngle, yc, rotation * vec3(p, 1.0), rrotation);\n    if (yc <= 0.0 && (point.x < 0.0 || point.y < 0.0 || point.x > 1.0 || point.y > 1.0))\n        return bgColor;\n    if (yc > 0.0)\n        return texture2D(iChannel0, p);\n    vec4 color = texture2D(iChannel0, point.xy);\n    vec4 tcolor = vec4(0.0);\n    return antiAlias(color, tcolor, distanceToEdge(point));\n}\n\nvec4 seeThroughWithShadow(float yc, vec2 p, vec3 point, mat3 rotation, mat3 rrotation)\n{\n    float shadow = distanceToEdge(point) * 30.0;\n    shadow = (1.0 - shadow) \/ 3.0;\n    if (shadow < 0.0)\n        shadow = 0.0;\n    else\n        shadow *= amount;\n    vec4 shadowColor = seeThrough(yc, p, rotation, rrotation);\n    shadowColor.r -= shadow;\n    shadowColor.g -= shadow;\n    shadowColor.b -= shadow;\n    return shadowColor;\n}\n\nvec4 backside(float yc, vec3 point)\n{\n    vec4 color = texture2D(iChannel0, point.xy);\n    float gray = (color.r + color.b + color.g) \/ 15.0;\n    gray += (8.0 \/ 10.0) * (pow(1.0 - abs(yc \/ cylinderRadius), 2.0 \/ 10.0) \/ 2.0 + (5.0 \/ 10.0));\n    color.rgb = vec3(gray);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy\/iResolution.xy;\n    \n    bgColor = texture2D(iChannel0, uv).rgga;\n    \n    curlExtent = sin(iGlobalTime*0.3)*0.5+0.5;\n    \n    if (iMouse.z>0.) curlExtent = iMouse.y\/iResolution.y;\n        \n\tamount = curlExtent * (maxAmount - minAmount) + minAmount;\n\tcylinderCenter = amount;\n\tcylinderAngle = 2.0 * PI * amount;\n\n    const float angle = 30.0 * PI \/ 180.0;\n    float c = cos(-angle);\n    float s = sin(-angle);\n    mat3 rotation = mat3(c, s, 0, -s, c, 0, 0.12, 0.258, 1);\n    c = cos(angle);\n    s = sin(angle);\n    mat3 rrotation = mat3(c, s, 0, -s, c, 0, 0.15, -0.5, 1);\n    vec3 point = rotation * vec3(uv, 1.0);\n    float yc = point.y - cylinderCenter;\n    vec4 color = vec4(1.0, 0.0, 0.0, 1.0);\n    if (yc < -cylinderRadius) \/\/ See through to background\n    {\n        color = bgColor;\n    } \n    else if (yc > cylinderRadius) \/\/ Flat surface\n    {\n        \n        color = texture2D(iChannel0, uv);\n    } \n    else \n    {\n        float hitAngle = (acos(yc \/ cylinderRadius) + cylinderAngle) - PI;\n        float hitAngleMod = mod(hitAngle, 2.0 * PI);\n        if ((hitAngleMod > PI && amount < 0.5) || (hitAngleMod > PI\/2.0 && amount < 0.0)) \n        {\n            color = seeThrough(yc, uv, rotation, rrotation);\n        } \n        else \n        {\n            point = hitPoint(hitAngle, yc, point, rrotation);\n            if (point.x < 0.0 || point.y < 0.0 || point.x > 1.0 || point.y > 1.0) \n            {\n                color = seeThroughWithShadow(yc, uv, point, rotation, rrotation);\n            } \n            else \n            {\n                color = backside(yc, point);\n                vec4 otherColor;\n                if (yc < 0.0) \n                {\n                    float shado = 1.0 - (sqrt(pow(point.x - 0.5, 2.0) + pow(point.y - 0.5, 2.0)) \/ 0.71);\n                    shado *= pow(-yc \/ cylinderRadius, 3.0);\n                    shado *= 0.5;\n                    otherColor = vec4(0.0, 0.0, 0.0, shado);\n                } \n                else \n                {\n                    otherColor = texture2D(iChannel0, uv);\n                }\n                color = antiAlias(color, otherColor, cylinderRadius - abs(yc));\n            }\n        }\n    }\n    fragColor = color;\n}","name":"","description":"","type":"image"}]}}