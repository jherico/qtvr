{"Shader":{"ver":"0.1","info":{"id":"MlBGWz","date":"1428020316","viewed":674,"name":"Birdie bird","username":"such","description":"The geometry is built with ray marching constructive solid geometry. The background is a result from taking the end result from ray marching regardless whether it hit something or not with distances estimated in different transformations for each compone.","likes":0,"published":3,"flags":0,"tags":["raymarchingcsg"],"hasliked":0},"renderpass":[{"inputs":[{"id":17,"src":"\/presets\/tex12.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"const float closed_left_eye = 0.75;\nconst float closed_right_eye = 0.8;\nconst float bend_back = 1.;\n\n\/\/ as allways, higher is better\n#define RM_MAX_ITER 15\n#define DISTANCE 2.\n\n\/\/ define one of these\n\/\/#define CLEAN \/\/ at least 10 iterations\n\/\/#define EVIL_BIRD_IN_THE_DARK \/\/ at least 16 iterations\n#define FUNKY_BACKGROUND\n\n\/\/ this is cool with FUNKY_BACKGROUND\n\/\/#define ONLY_BEAK\n\n\/\/ woho!\n\/\/#define DANCE_GROOVE\n\/\/#define DANCE_FUNK\n\n\/\/#define EAT_MUSHROOMS\n\n\/\/#define UNDERCOVER\n\n\/\/#define BANDANA\n\n\/\/#define BACKGROUNDTEXTURE\n\nconst float eps = 0.01;\n\n\/\/ raymarching CSG: min = union, max = intersection\nfloat sphere(vec3 p, vec3 c, float r)\n{\n    return length(p-c) - r;\n}\n\nfloat plane(vec3 p, vec3 n, float d)\n{\n    return dot(p,n)-d;\n}\n\nvec3 bendBody(vec3 p)\n{\n    \/\/ offset position to compute distance from to give the effect of the object moving\n    float bending = bend_back*0.025;\n    \/\/float bending = 0.015*sin(4.*iGlobalTime);\n    p.z = p.z - p.y*p.y*bending;\n    #ifdef EAT_MUSHROOMS\n    p.x = p.x - sin(p.y);\n    #endif\n    #ifdef DANCE_GROOVE\n    float o = p.y*p.y*bending*2.*sin(4.*iGlobalTime);\n    p.x += o;\n    p.y += abs(o);\n    #endif\n    #ifdef DANCE_FUNK\n    float o2 = p.y*p.y*bending*2.*sin(4.*iGlobalTime);\n    p.x += o2;\n    p.y -= abs(o2);\n    #endif\n    return p;\n}\n\nfloat birdieBody(in vec3 p)\n{\n    \/\/ Model the body as a cylinder with varying radius\n    float y = clamp(p.y,0.,1.);\n\n    float r;\n\tfloat neck = 0.48;\n    if (y<neck)\n    \tr = mix(1.4,0.15,y\/neck);\n    else\n    {\n        float t = 1. - (y-neck)\/(1.-neck);\n        r = -.85*t*t*t*t + 1.;\n        r *= sin(acos(1.-t));\n    }\n    \n    float body = length(p.xz) - r*0.1;\n    return max(max(p.y-1.,-p.y),body);\n}\n\nfloat birdieBeak1(in vec3 p)\n{\n    float d_back = p.z - (-0.02);\n    float d_bottom = -(p.y - 0.57);\n    float d_left = sphere(p,vec3(-.15, 0.6, 0.02),.2);\n    float d_right = sphere(p,vec3(.15, 0.6, 0.02),.2);\n    \n    return max(max(d_left,d_right),max(d_bottom,d_back));\n}\n\nfloat birdieBeak2(in vec3 p,float openjaw)\n{\n    float d_back = p.z - (-0.02);\n    float d_top = plane(p, vec3(0.,1.,-.6-.3*openjaw), 0.6+.03*openjaw);\n    float d_left = sphere(p,vec3(-.115, 0.65, 0.06),.2);\n    float d_right = sphere(p,vec3(.115, 0.65, 0.06),.2);\n    \n    return max(max(d_left,d_right),max(d_top,d_back));\n}\n\nfloat birdieBeak(in vec3 p)\n{\n    float beak1 = birdieBeak1(p);\n    float beak2 = birdieBeak2(p, pow(sin(iGlobalTime),31.));\n    \n    return min(beak1,beak2);\n}\n\nfloat birdieEyePupil(in vec3 p, float angley, float anglex)\n{\n    anglex = clamp(anglex,-.1,.3);\n    angley = clamp(angley,-.4,.4);\n    \n\tanglex = 0.04*sin(anglex);\n    vec3 off1 = vec3( 0.04, 0.717+anglex, -0.048);\n    vec3 off2 = vec3( -0.04, 0.717+anglex, -0.048);\n\n    float ca = cos(angley);\n    float sa = sin(angley);\n    \n    off1 = vec3(off1.z*sa + off1.x*ca, off1.y, off1.z*ca - off1.x*sa);\n    off2 = vec3(off2.z*sa + off2.x*ca, off2.y, off2.z*ca - off2.x*sa);\n    \n    return min(length(p-off1),length(p-off2)) - .025; \/\/ distance to sphere\n}\n\nfloat birdieEyeWhite(float body,in vec3 p)\n{\n    float d_bottom = plane(p,vec3(0.,-1.,0.),-0.69);\n    float d_top = plane(p,vec3(0.,1.,0.),0.9);\n    float d_sphere = min(sphere(p,vec3(0.1,0.75,-0.1),.1),\n                         sphere(p,vec3(-0.1,0.75,-0.1),.1));\n    return max(max(body,d_sphere),max(d_top,d_bottom));\n}\n\nfloat birdieBandana(float body,in vec3 p)\n{\n#ifdef BANDANA\n    float d_bottom = plane(p,vec3(0.,-1.,0.),-0.85);\n    float d_top = plane(p,vec3(0.,1.,0.),0.91);\n#else\n    float d_bottom = plane(p,vec3(0.,-1.,0.),-0.92);\n    float d_top = plane(p,vec3(0.,1.,0.),0.91);\n#endif\n#ifdef UNDERCOVER\n    return body;\n#else\n    return max(body,max(d_top,d_bottom));\n#endif\n}\n\nfloat birdieEyeLid(in vec3 p, float closed_left, float closed_right)\n{\n    p.y = (p.y-0.75)*0.5 + 0.75;\n    float d_bottom = plane(p,vec3(-.8*(1.-closed_left),-1.,0.),-0.9 + 0.21*closed_left);\n    float d_sphere1 = sphere(p,vec3(-0.1,0.75,-0.1),.1);\n    float d_sphere2 = sphere(p,vec3(0,0.77,0),.1);\n    float lid1 = max(max(d_sphere1,d_sphere2),d_bottom);\n\n    d_bottom = plane(p,vec3(0.8*(1.-closed_right),-1.,0.),-0.9 + 0.21*closed_right);\n    d_sphere1 = sphere(p,vec3(0.1,0.75,-0.1),.1);\n    d_sphere2 = sphere(p,vec3(0,0.77,0),.1);\n    float lid2 = max(max(d_sphere1,d_sphere2),d_bottom);\n    return min(lid1,lid2);\n}\n\nvec4 birdie(in vec3 p)\n{\n    p.y += 0.5;\n    p = bendBody(p);\n    float body = birdieBody(p);\n    float beak = birdieBeak(p);\n    float eyepupil = max(body,birdieEyePupil(p,sin(iGlobalTime),cos(iGlobalTime)));\n    float eyewhite = birdieEyeWhite(body,p);\n    float eyelid = birdieEyeLid(p,closed_left_eye+0.05*pow(sin(.22873*iGlobalTime),391.), closed_right_eye+0.05*pow(sin(.22873*iGlobalTime),391.));\n    float ninjabandana = birdieBandana(body,p);\n    \n    #ifdef ONLY_BEAK\n    body += 10.;\n    eyepupil += 10.;\n    eyewhite += 10.;\n    eyelid += 10.;\n    #endif\n\n    float m = min(min(min(body,beak),min(eyepupil,eyewhite)),eyelid);\n    vec4 r;\n    if (m==beak) return vec4(0.8, 0.4, 0.2, m);\n    if (m==eyepupil) return vec4(0.0, 0.0, 0.0, m);\n    if (m==ninjabandana) return vec4(0.1, 0.2, 0.3, m);\n    if (m==eyewhite) return vec4(1.0, 1.0, 1.0, m);\n    if (m==eyelid) return vec4(0.6, 0.6, 0.6, m);\n    return vec4(0.8, 0.8, 0.8, m); \/\/ m==body\n}\n\nvec4 scene(in vec3 p)\n{\n    return birdie(p);\n}\n\n\/\/ gradient normal\nvec3 getNormal(in vec3 p)\n{\n    vec3 normal;\n    vec3 ep = vec3(eps,0,0);\n    normal.x = scene(p + ep.xyz).w - scene(p - ep.xyz).w;\n    normal.y = scene(p + ep.yxz).w - scene(p - ep.yxz).w;\n    normal.z = scene(p + ep.yzx).w - scene(p - ep.yzx).w;\n    return normalize(normal);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy*0.5) \/ iResolution.yy;    \n    \n    vec3 rayStart = vec3(0,0,DISTANCE);\n    vec3 rayDir = normalize(vec3(uv,-1));\n    \n    \/\/float a = 3.14+1.4*iGlobalTime;\n    float a = 3.14+sin(.1*iGlobalTime);\n    float ca = cos(a);\n    float sa = sin(a);\n    rayStart = vec3(rayStart.z*sa + rayStart.x*ca, rayStart.y, rayStart.z*ca - rayStart.x*sa);\n    rayDir = vec3(rayDir.z*sa + rayDir.x*ca, rayDir.y, rayDir.z*ca - rayDir.x*sa);\n\n    a = 0.1*sin(.1*iGlobalTime);\n    \/\/a = 3.14+.4*iGlobalTime;\n    ca = cos(a);\n    sa = sin(a);\n\trayStart = vec3(rayStart.x, rayStart.z*sa + rayStart.y*ca, rayStart.z*ca - rayStart.y*sa);\n    rayDir = vec3(rayDir.x, rayDir.z*sa + rayDir.y*ca, rayDir.z*ca - rayDir.y*sa);\n    \n    vec3 p;\n    float t = 0.0;\n    vec4 currentColor;\n    for (int i=0; i<RM_MAX_ITER; ++i)\n    {\n        p = rayStart + rayDir*t;\n        currentColor = scene(p);\n\t\tt += currentColor.w;\n    }\n\n    vec3 finalColor = vec3(0,0,0);\n    vec3 normal = getNormal(p.xyz);\n    \/\/vec3 normal = vec3(0,0,1);\n    vec3 light1 = vec3(sin(iGlobalTime),cos(iGlobalTime),0);\n    vec3 light2 = vec3(0,0,-1);\n    \/\/            finalColor = normal;\n    \/\/            finalColor = vec3(1,0,1) *\n    \/\/                dot(vec3(1.,sin(iGlobalTime ),cos(iGlobalTime )),normal);\n    float diffuse1 = 0.1+dot(light1,normal);\n    float diffuse2 = 0.1+dot(light2,normal);\n    float specular = pow(max(0.,dot(light1,normal)),21.);\n    \n    #ifdef CLEAN\n    \/\/if (currentColor.w>100.)\n    if (currentColor.w>eps)\n    {\n        currentColor = vec4(0.,0.,0.,0.);\n    }\n    #endif\n    \n    #ifdef EVIL_BIRD_IN_THE_DARK\n    if (currentColor.w>0.)\n    {\n        currentColor = vec4(0.,0.,0.,0.);\n    }\n    #endif\n\n\n    \/\/float specular = 0.;\n    float ambient = 0.2;\n    finalColor = currentColor.xyz *\n        (ambient + max(0.,0.5* diffuse1) + 0.5*diffuse2 + specular);\n    \n\tfragColor = vec4(finalColor, min(1.,max(0.,1.-currentColor.w) + length(finalColor)));\n\n    #ifdef BACKGROUNDTEXTURE\n    fragColor = mix(vec4(pow(texture2D (iChannel0,fragCoord\/iResolution.xy).r,21.)), fragColor, fragColor.a);\n    #endif\n}\n","name":"","description":"","type":"image"}]}}