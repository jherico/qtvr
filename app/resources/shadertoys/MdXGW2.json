{"Shader":{"ver":"0.1","info":{"id":"MdXGW2","date":"1379503432","viewed":7054,"name":"Venice","username":"reinder","description":"My attempt to create a procedural city with a lot of lights. The city is inspired by Venice. The shader is a combination of my shaders: https:\/\/www.shadertoy.com\/view\/Mdf3zM and https:\/\/www.shadertoy.com\/view\/lslGDB.<br\/>(I have never been in Venice btw)","likes":71,"published":3,"flags":0,"tags":["procedural","distancefield","reflection","water","city"],"hasliked":0},"renderpass":[{"inputs":[{"id":1,"src":"\/presets\/tex00.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":6,"src":"\/presets\/tex05.jpg","ctype":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":10,"src":"\/presets\/tex09.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":16,"src":"\/presets\/tex11.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Venice. Created by Reinder Nijhoff 2013\n\/\/ @reindernijhoff\n\/\/\n\/\/ https:\/\/www.shadertoy.com\/view\/MdXGW2\n\/\/\n\/\/ My attempt to create a procedural city with a lot of lights. The city is inspired by Venice. \n\/\/ The shader is a combination of my shaders: https:\/\/www.shadertoy.com\/view\/Mdf3zM and \n\/\/ https:\/\/www.shadertoy.com\/view\/lslGDB.\n\/\/ (I have never been in Venice btw)\n\/\/\n\n\/\/ #define SHOW_ORNAMENTS\n#define SHOW_GALLERY\n#define SHOW_LIGHTS\n#define SHOW_BRIDGES\n#define SHOW_MOON_AND_CLOUDS\n\n\/\/----------------------------------------------------------------------\n\n#define BUMPFACTOR 0.2\n#define EPSILON 0.1\n#define BUMPDISTANCE 200.\n\n#define CAMERASPEED 15.\n\n#define BUILDINGSPACING 20.\n#define MAXBUILDINGINSET 12.\n\n#define GALLERYHEIGHT 10.5\n#define GALLERYINSET 2.5\n\nfloat time = iGlobalTime+43.;\n\nfloat hash( float n ) {\n\treturn fract(sin(n)*32.5454412211233);\n}\nvec2 hash2( float n ) {\n\treturn fract(sin(vec2(n,n+1.0))*vec2(11.1451239123,34.349430423));\n}\nvec3 hash3( float n ) {\n\treturn fract(sin(vec3(n,n+1.0,n+2.0))*vec3(84.54531253,42.145259123,23.349041223));\n}\n\nfloat noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\n\treturn -1.0 + 2.0*texture2D( iChannel0, (uv+0.5)\/256.0, -100.0 ).x;\n}\n\nfloat noise( in vec3 x )\n{\n\tfloat  z = x.z*64.0;\n\tvec2 offz = vec2(0.317,0.123);\n\tvec2 uv1 = x.xy + offz*floor(z); \n\tvec2 uv2 = uv1  + offz;\n\treturn mix(texture2D( iChannel0, uv1 ,-100.0).x,texture2D( iChannel0, uv2 ,-100.0).x,fract(z))-0.5;\n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nconst mat3 m3 = mat3( 0.00,  0.80,  0.60,\n                     -0.80,  0.36, -0.48,\n                     -0.60, -0.48,  0.64 );\n\nfloat fbm( vec3 p ) {\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m3*p*2.02;\n    f += 0.2500*noise( p ); p = m3*p*2.03;\n    f += 0.1250*noise( p ); p = m3*p*2.01;\n    f += 0.0625*noise( p );\n    return f\/0.9375;\n}\n\n\/\/----------------------------------------------------------------------\n\/\/ distance functions\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\nfloat sdSphere( vec3 p, float s ) {\n    return length(p)-s;\n}\nfloat udBox( vec3 p, vec3 b) {\n  return length(max(abs(p)-b,0.0));\n}\nfloat sdCylinderXY( vec3 p, vec2 h ) {\n  return max( length(p.xy)-h.x, abs(p.z)-h.y );\n}\nfloat sdCylinderXZ( vec3 p, vec2 h ) {\n  return max( length(p.xz)-h.x, abs(p.y)-h.y );\n}\nfloat sdTriPrism( vec3 p, vec2 h ) {\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n\/\/----------------------------------------------------------------------\n\nfloat opS( float d1, float d2 ) {\n    return max(-d2,d1);\n}\nfloat opU( float d1, float d2 ) {\n    return min(d2,d1);\n}\nvec2 opU( vec2 d1, vec2 d2 ) {\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\nfloat opI( float d1, float d2 ) {\n    return max(d1,d2);\n}\n\n\/\/----------------------------------------------------------------------\n\/\/ building functions\n\nfloat getXoffset( float z ) {\n\treturn 20.*sin( z*0.02);\n}\n\nvec2 getBuildingInfo( in vec3 pos ) {\n\tvec2 res;\n\t\/\/ base index\t\n\tres.x = floor( pos.z\/BUILDINGSPACING + 0.5 );\n\t\/\/ base z coord\n\tres.y = res.x * BUILDINGSPACING;\n\t\n\t\/\/ negative index for buildings at the right side\n\tres.x *= sign( pos.x + getXoffset(pos.z) );\n\t\n\treturn res;\n}\n\nvec4 getBuildingParams( in float buildingindex ) {\n\tvec3 h = hash3( buildingindex );\n\treturn vec4(\n\t\t20. + 4.5*floor( h.x*7. ),\t \/\/ height\n\t\th.y*MAXBUILDINGINSET,\n\t\tstep(h.z, 0.5),\t\t\t\t \/\/ sidewalk\n\t\tstep(abs(h.z-0.4),0.25)\t\t \/\/ balcony\n\t);\n}\n\nfloat baseBuilding( in vec3 pos, in float h ) {\n\tvec3 tpos = vec3( pos.z, pos.y, pos.x );\n\t\n\tfloat res = \n\topS(\t\t\n\t\t\/\/ main building\n\t\tudBox( tpos, vec3( 8.75, h, 8.75 ) ),\n\t\t\t\/\/ windows\n\t\topS(\n\t\t\topU(\n\t\t\t\tsdBox( vec3( mod(tpos.x+1.75, 3.5)-1.75, mod(tpos.y+4.5, 9.)-2.5, tpos.z-5.), vec3( 1.,2.,4.) ),\n\t\t\t\tsdCylinderXY( vec3( mod(tpos.x+1.75, 3.5)-1.75, mod(tpos.y+4.5, 9.)-4.5, tpos.z-5.), vec2( 1.,4.) )\n\t\t\t),\n\t\t\tudBox( tpos+vec3(0.,-h,0.), vec3( 9.0, 1.0, 9.0 ) )\n\t\t)\t\t\n\t);\n\t\n\tres =\n\topU( \n\t\tres,\n\t\topI( \/\/ main building windows\n\t\t\tudBox( tpos, vec3( 8.75, h, 8.75 ) ), \n\t\t\topU(\n\t\t\t\tudBox(  vec3( mod(tpos.x+1.75, 3.5)-1.75, tpos.y, tpos.z-8.45), vec3( 0.05, h, 0.05 ) ),\n\t\t\t\tudBox(  vec3( tpos.x, mod(tpos.y+0.425, 1.75)-0.875, tpos.z-8.45), vec3( 10.0, 0.05, 0.05 ) )\n\t\t\t)\n\t\t)\n\t);\n\treturn res;\t\n}\n\nfloat baseGallery( in vec3 pos ) {\n\tvec3 tpos = vec3( pos.z, pos.y, pos.x );\n\t\n\tfloat res = \n\topU(\t\n\t\topS(\n\t\t\tudBox( tpos+vec3(0.,0.,-GALLERYINSET), vec3( 8.75, GALLERYHEIGHT, 0.125 ) ),\n\t\t\topU(\n\t\t\t\tsdBox( vec3( mod(tpos.x+1.75, 3.5)-1.75, tpos.y-5., tpos.z-5.), vec3( 1.6,3.,10.) ),\n\t\t\t\tsdCylinderXY( vec3( mod(tpos.x+1.75, 3.5)-1.75, tpos.y-8., tpos.z-5.), vec2( 1.6,10.) )\n\t\t\t)\n\t\t),\n\t\tsdTriPrism( vec3( tpos.z+3.4,-44.4+3.9*tpos.y, tpos.x), vec2( 7.5, 8.7 ) )\n\t);\n\t\n\treturn res;\t\n}\n\nfloat baseBalcony( in vec3 pos, in float h ) {\n\tfloat res = opI(\t\t\n\t\t\/\/ main building\n\t\tudBox( pos, vec3( 9.0, h, 9.0 ) ),\n\t\t\t\/\/ balcony\n\t\tsdBox( vec3( pos.x, mod(pos.y+4.5, 9.)-7.5, pos.z-5.), vec3( 40.,0.5,40.) )\n\t);\n\treturn res;\t\t\n}\n\nfloat baseBridge( in vec3 pos ) {\n\tpos.x *= 0.38;\n\tfloat res = \n\topS(\t\n\t\topU( \n\t\t\tsdBox( pos, vec3( 4., 2., 2.5 ) ),\n\t\t\tsdTriPrism( vec3( pos.x,-8.+3.*pos.y, pos.z), vec2( 4.5, 2.5 ) )\n\t\t),\n\t\tsdCylinderXY( pos+vec3( 0., 1.5, 0. ), vec2( 3.8, 3. ) )\n\t);\n\treturn res;\n}\n\n\/\/ dinstancefield definitions\n\nfloat mapSimpleTerrain( in vec3 p ) {\t\n\tp.x += getXoffset( p.z );\t\n\tp.x = -abs( p.x );\n\tvec2 res = vec2( udBox( vec3(p.x+30., p.y-1., p.z) , vec3( 20., 100.25, 99999. ) ), 1.);\n\n#ifdef SHOW_BRIDGES\n\tfloat zcenter = mod(p.z+60.,120.)-70.;\n\tres = opU( res, vec2( baseBridge( vec3( p.x, p.y, zcenter) ), 8. ) ); \/\/ bridge\n#endif\n\t\n\treturn min( res.x, p.y+10. );\n}\n\nvec2 mapTerrain( in vec3 p ) {\t\n\tvec2 buildingInfo = getBuildingInfo( p );\n\tvec4 buildingParams = getBuildingParams( buildingInfo.x );\n\t\n\tvec3 pos = p;\n\tpos.x += getXoffset( pos.z );\n\tpos.x = -abs( pos.x );\n\t\n\tvec2 res = vec2( udBox( vec3(pos.x+30., pos.y, pos.z) , vec3( 20., 0.25, 99999. ) ), 1.); \/\/ ground\n\t\n\tfloat z = buildingInfo.y;\n\tfloat zcenter = mod(pos.z+10.,20.)-10.;\n\n#ifdef SHOW_BRIDGES\n\tres = opU( res, vec2( baseBridge( vec3( pos.x, pos.y,  mod(pos.z+60.,120.)-70.) ), 8. ) ); \/\/ bridge\n#endif\n\t\t\n\tres =  opU( res, vec2( sdSphere( vec3( pos.x+11.5, pos.y-6.0, zcenter) , 0.5 ), 3. ) ); \/\/ light\t\n\tres =  opU( res, vec2( sdSphere( vec3( pos.x+11.5, pos.y-5.4, zcenter+0.6) , 0.35 ), 3. ) ); \/\/ light\t\n\tres =  opU( res, vec2( sdSphere( vec3( pos.x+11.5, pos.y-5.4, zcenter-0.6) , 0.35 ), 3. ) ); \/\/ light\n\t\n\tres =  opU( res, vec2( sdCylinderXZ( vec3( pos.x+11.5, pos.y, zcenter), vec2( 0.1, 6.0) ), 4.)); \/\/ \n\t\t\t\t\t\t  \n\tpos += vec3( 28.75+buildingParams.y, 2.5, 0.);\t\t\n\tres =  opU( res, vec2( baseBuilding( vec3( pos.x, pos.y, zcenter), buildingParams.x+2.5  ), 2. ) );\n\n#ifdef SHOW_ORNAMENTS\n\tres = mix( res, opU( res, vec2( baseBalcony( vec3( pos.x, pos.y, zcenter), buildingParams.x+2.5  ), 9. ) ), buildingParams.w );\n#endif\n\t\n#ifdef SHOW_GALLERY\n\tpos.x += -8.75-GALLERYINSET;\t\t\n\tres = mix( res, opU( res, vec2( baseGallery( vec3( pos.x, pos.y, zcenter) ), 5. ) ), buildingParams.z );\n#endif\t\n\t\t\t\t\t\t\t\t\t  \n\treturn vec2( min( res.x,  11.-zcenter ), res.y );\n}\n\nfloat waterHeightMap( vec2 pos ) {\n\tvec2 posm = 0.02*pos * m2;\n\tposm.x += 0.001*time;\n\tfloat f = fbm( vec3( posm*1.9, time*0.01 ));\n\tfloat height = 0.5+0.1*f;\n\theight += 0.05*sin( posm.x*6.0 + 10.0*f );\n\t\n\treturn  height;\n}\n\n\/\/ intersection functions\n\nbool intersectPlane(vec3 ro, vec3 rd, float height, out float dist) {\t\n\tif (rd.y==0.0) {\n\t\treturn false;\n\t}\n\t\t\n\tfloat d = -(ro.y - height)\/rd.y;\n\td = min(100000.0, d);\n\tif( d > 0. ) {\n\t\tdist = d;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool intersectSphere ( in vec3 ro, in vec3 rd, in vec4 sph, out vec3 normal ) {\n    vec3  ds = ro - sph.xyz;\n    float bs = dot( rd, ds );\n    float cs = dot(  ds, ds ) - sph.w*sph.w;\n    float ts = bs*bs - cs;\n\t\n    if( ts > 0.0 ) {\n        ts = -bs - sqrt( ts );\n\t\tif( ts>0. ) {\n\t\t\tnormal = normalize( ((ro+ts*rd)-sph.xyz)\/sph.w );\n\t\t\treturn true;\n\t\t}\n    }\n\n    return false;\n}\n\nvec3 intersect( const vec3 ro, const vec3 rd ) {\n\tfloat maxd = 1500.0;\n\tfloat precis = 0.01;\n    float h=precis*2.0;\n    float t = 0.0;\n\tfloat d = 0.0;\n    float m = 1.0;\n    for( int i=0; i<140; i++ ) {\n\t\tif( abs(h)<precis || t>maxd ) break; {\n\t\t\tt += h;\n\t\t\tvec2 mt = mapTerrain( ro+rd*t );\n\t\t\th = 0.96*mt.x;\n\t\t\tm = mt.y;\n\t\t}\n    }\n\n    if( t>maxd ) m=-1.0;\n    return vec3( t, d, m );\n}\n\nfloat intersectSimple( const vec3 ro, const vec3 rd ) {\n\tfloat maxd = 10000.0;\n\tfloat precis = 0.01;\n    float h=precis*2.0;\n    float t = 0.0;\n    for( int i=0; i<50; i++ ) {\n\t\tif( abs(h)<precis || t>maxd ) break;  {\n\t\t\tt += h;\n\t\t\th = mapSimpleTerrain( ro+rd*t );\n\t\t}\n    }\n\n    return t;\n}\n\nvec3 calcNormal( const vec3 pos ) {\n    vec3 eps = vec3(0.1,0.0,0.0);\n\n\treturn normalize( vec3(\n           mapTerrain(pos+eps.xyy).x - mapTerrain(pos-eps.xyy).x,\n           mapTerrain(pos+eps.yxy).x - mapTerrain(pos-eps.yxy).x,\n           mapTerrain(pos+eps.yyx).x - mapTerrain(pos-eps.yyx).x ) );\n}\n\nfloat calcAO( const vec3 pos, const vec3 nor ) {\n\tfloat totao = 0.0;\n    float sca = 1.0;\n    for( int aoi=0; aoi<5; aoi++ ) {\n        float hr = 0.01 + 0.05*float(aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = mapTerrain( aopos ).x;\n        totao += -(dd-hr)*sca;\n        sca *= 0.75;\n    }\n    return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );\n}\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec4 x = texture2D( sam, p.yz );\n\tvec4 y = texture2D( sam, p.zx );\n\tvec4 z = texture2D( sam, p.xy );\n\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\nvoid getSkyColor( in vec3 rd, out vec3 bgcol, out vec3 col ) {\n\tvec3 lig = normalize( vec3( -2.5, 1.7, 2.5 ) );\n\t\n\tbgcol = 1.1*vec3(0.15,0.15,0.4) - rd.y*0.4;\t\n\tbgcol *= 0.3;\n    float moon = clamp( dot(rd,lig), 0.0, 1.0 );\n\tbgcol += vec3(2.0,1.5,0.8)*0.015*pow( moon, 32.0 );\n\t\n\tcol = bgcol;\n\t\n#ifdef SHOW_MOON_AND_CLOUDS\t\n\t\/\/ moon!\n\tvec3 normal;\n\tif( intersectSphere( vec3(0., 0., 0.), rd, vec4( lig, 0.03), normal ) ) {\n\t\tfloat l = dot( normalize( vec3( 2.2, -1.9, 0.5)), normal )*(0.4+texture2D( iChannel2, normal.xy*0.5 ).y);\n\t\tcol += 0.2*clamp( 2.5*vec3(2.0,1.5,0.8)*clamp(l, 0.0, 1.), vec3(0.), vec3(1.) );\n\t}\t\t\t\n\t\n\/\/ cloud function by inigo: https:\/\/www.shadertoy.com\/view\/Mds3z2 \n\tvec2 cuv = rd.xz*(100.0)\/rd.y;\n\tfloat cc = texture2D( iChannel2, 0.0001*cuv +0.1+ 0.0013*time ).x;\n\tcc = 0.65*cc + 0.35*texture2D( iChannel2, 0.0001*2.0*cuv + 0.0013*.5*time ).x;\n\tcc = smoothstep( 0.3, 1.0, 1.1*cc );\n\tcol = mix( col, 0.1*vec3(0.05,0.05,0.4), 0.99*cc );\n#endif\n}\n\n\/\/-----------------------------------------------------\n\nvec3 path( float time ) {\n\tfloat z = time*CAMERASPEED;\t\n\treturn vec3( -getXoffset(z)+5.*cos(time*0.1), 1.25, z );\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 q = fragCoord.xy \/ iResolution.xy;\n\tvec2 p = -1.0 + 2.0*q;\n\tp.x *= iResolution.x \/ iResolution.y;\n\t\n\t\n    \/\/ camera\t\n\tfloat off = step( 0.001, iMouse.z )*6.0*iMouse.x\/iResolution.x;\n\ttime += off;\n\tvec3 ro = path( time+0.0 );\n\tvec3 ta = path( time+1.6 );\n\t\n\tta.y *= 1.1 + 0.25*sin(0.09*time);\n\tfloat roll = 0.3*sin(1.0+0.07*time);\n\t\n\t\/\/ camera tx\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n\t\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.1*cw );\n\n\t\n    \/\/-----------------------------------------------------\n\t\/\/ render\n    \/\/-----------------------------------------------------\n\t\n\t\/\/ raymarch\n    float distSimple = intersectSimple(ro,rd);\n\tbool reflection = false;\n\t\n\tfloat dist, totaldist = 0., depth = 0.;\n\tvec3 normal, tmat, lp, lig;\n\t\n\tif( intersectPlane( ro, rd, 0., dist ) && dist < distSimple ) {\t\t\t\n\t\tro = ro+rd*dist;\n\t\ttotaldist = dist;\n\t\t\n\t\tdepth = mapTerrain(ro).x;\n\t\t\n\t\tvec2 coord = ro.xz;\n\t\tvec2 dx = vec2( EPSILON, 0. );\n\t\tvec2 dz = vec2( 0., EPSILON );\n\t\t\n\t\tfloat bumpfactor = BUMPFACTOR * (1. - smoothstep( 0., BUMPDISTANCE, dist) );\n\t\t\t\t\n\t\tnormal = vec3( 0., 1., 0. );\n\t\tnormal.x = -bumpfactor * (waterHeightMap(coord + dx) - waterHeightMap(coord-dx) ) \/ (2. * EPSILON);\n\t\tnormal.z = -bumpfactor * (waterHeightMap(coord + dz) - waterHeightMap(coord-dz) ) \/ (2. * EPSILON);\n\t\tnormal = normalize( normal );\n\t\t\n\t\trd = reflect( rd, normal );\n\t\treflection = true;\n\t} \n\t\n\t\/\/ intersect scene\t\n\ttmat = intersect(ro,rd);\n\ttotaldist += tmat.x;\n\t\n\t\/\/ sky\t \n\tvec3 col, bgcol;\n\tgetSkyColor( rd, bgcol, col );\n\t\t\t\n    vec3 pos = ro + tmat.x*rd;\n\t\n    if( tmat.z>-0.5 && totaldist < 500.) {\n\t\t\/\/ info building hit\n\t\tvec2 buildingInfo = getBuildingInfo( pos );\t\t\t\n\t\tvec4 buildingParams = getBuildingParams( buildingInfo.x );\n\t\t\t\n\t\tfloat z = buildingInfo.y;\n\t\tlp = vec3( 11.5*sign(buildingInfo.x)-getXoffset(z), 6.0, z );\n\t\tlig = normalize(lp-pos);\n\t\t\n\t\t\/\/ geometry\n        vec3 nor = calcNormal(pos);\n\t\t\t\t\n        \/\/ material\n\t\tvec3 mate, origmate;\n\t\tvec3 matpos = pos*0.3;\n\t\t\n#ifdef SHOW_GALLERY\n\t\tif( tmat.z == 5. )\n\t\tmate.xyz = texcube(iChannel3, matpos, nor ).xyz*0.2;\n\t\t\telse\n#endif\n\t\torigmate = mate.xyz = texcube(iChannel1, matpos, nor ).xyz*0.4;\n\t\t\n\t\tbool aboveGallery = false;\n\t\t\n\t\tif( tmat.z == 3. ) mate.xyz = 160.*vec3(1.30,1.10,0.40);\n\t\telse if( tmat.z == 2. ) mate.xyz *= \n\t\t\tclamp( 4.*texture2D( iChannel2, buildingInfo.x*vec2(1.4231153121) ).xyz\n\t\t\t,vec3(0.), vec3(1.) );\n\t\t\t\n\t\t\/\/ lighting\n\t\tfloat occ = calcAO( pos, nor );\n        float amb = clamp(0.5 + 0.5*nor.y,0.0,1.0);\n\t\tfloat dif = max(dot(nor,lig),0.0);\n\t\tif( tmat.z == 5. && pos.y > GALLERYHEIGHT-2.6 ) {\n\t\t\tdif = abs(dot(nor,lig));\n\t\t\tmate.xyz = vec3(0.3,0.,0.);\n\t\t}\n\t\tdif \/= dot( lp-pos,lp-pos );\n\t\t\n        float bac = max(0.2 + 0.8*dot(nor,normalize(vec3(-lig.x,0.0,-lig.z))),0.0);\n\t\t\n\t\tif( buildingParams.z == 1. && pos.y > GALLERYHEIGHT ) {\n\t\t\taboveGallery=true;\n\t\t}\t\t\n\t\tvec3 lcol = aboveGallery?vec3(2.9, 1.65, 0.65 ):vec3(1.30,0.60,0.40);\n\t\t\n\t\t\/\/ lights\n\t\tvec3 brdf = vec3(0.0);\n        brdf += (60.0*dif)*lcol;\n\t\tbrdf += (0.1*amb)*vec3(0.10,0.15,0.30);\n\t\tbrdf += (0.1*bac)*vec3(0.09,0.03,0.01);\n\t\t\n\t\t\/\/ surface-light interacion\n\t\tcol = (mate.xyz*brdf)*occ;\n\t\t\n\t\t\/\/ in room ?\n\t\tfloat isLeft = sign(buildingInfo.x);\n\t\t\n\t\tif( ((pos.x+getXoffset( pos.z ))*isLeft > buildingParams.y+20.25 &&\n\t\t    abs( pos.z-buildingInfo.y ) < 8.5 &&\n\t\t  \tpos.y < buildingParams.x-0.5) || false ) {\n\t\t\t\n\t\t\tvec2 roomcoord = pos.zy;\n\t\t\troomcoord.x = floor( (roomcoord.x-buildingInfo.y+5.) \/ 3.5 ) * 3.5 +\n\t\t\t\t\t\t  floor( (buildingInfo.y+5. ) \/ 10.) * 10.;\n\t\t\troomcoord.y = floor( roomcoord.y \/ 9. ) * 9.;\n\t\t\t\n\t\t\tif( noise( vec3(roomcoord*1.15321*isLeft, time*0.0005 ) ) > -0.1 ) {\n\t\t\t\tvec3 rlc = vec3( \n\t\t\t\t\t(buildingParams.y+3.+20.25)*isLeft-getXoffset( roomcoord.x-5. ), \n\t\t\t\t\troomcoord.y+5.5, \n\t\t\t\t\troomcoord.x-5. );\n\t\t\t\t\tvec3 ld = rlc-pos;\n\t\t\t\t\tdif = max(dot(nor,normalize(ld) ),0.0)\/dot(ld,ld);\n\t\t\t\t\tcol += origmate*(dif*120.)*texture2D( iChannel2, roomcoord*0.1231 ).xyz;\n\t\t\t}\n\t\t}\n\n#ifdef SHOW_LIGHTS\n\t\t\/\/ and extra lights!\n\t\tfloat basez = floor( (pos.z)\/2. )*2.-2.0;\n\t\tfor(int i=0; i<3; i++) {\n\t\t\tbuildingInfo = getBuildingInfo( vec3( pos.x, pos.y, basez ) );\n\t\t\t\/\/ check if building lights here\n\t\t\tif( abs( basez - buildingInfo.y ) > 8.75 ||\n\t\t\t  \tnoise( buildingInfo ) > 0.15 ) {\n\t\t\t\tbasez += 2.;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbuildingParams = getBuildingParams( buildingInfo.x );\n\t\t\tvec3 rlc = vec3( (buildingParams.y-1.+20.25)*isLeft-getXoffset( basez ),\n\t\t\t\t\t\t7.7-1.5*abs(sin(basez*0.3)), basez );\n\t\t\tvec3 ld = rlc-pos;\n\t\t\tdif = max(dot(nor,normalize(ld) ),0.0)\/dot(ld,ld);\n\t\t\tcol += mate.xyz*(dif*6.0)*texture2D( iChannel2, vec2(basez*time*0.0001)*0.1231 ).xyz;\t\n\t\t\tbasez += 2.;\n\t\t}\n#endif\n\t\n\t\tif( reflection ) {\n\t\t\tcol = mix( bgcol, col, exp(-0.00000001*pow(totaldist-dist,3.0)) );\t\t\n\t\t\tcol *= 0.9*vec3( 0.8, 0.9, 1. )*(0.5+clamp( depth*2., 0.0, 0.5));\t\t\n\t\t\tif( dist != totaldist ) totaldist = dist;\n\t\t} \n\t\tcol = mix( bgcol, col, exp(-0.00000001*pow(totaldist,3.0)) );\n\t} \n\n\t\n\t\/\/-----------------------------------------------------\n\t\/\/ postprocessing\n    \/\/-----------------------------------------------------\n    \/\/ gamma\n\tcol = clamp( col, 0.0, 1.0 );\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\t\n\tcol *= vec3(1.03,1.02,1.0);\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n    fragColor = vec4( col, 1.0 );\n}\n","name":"","description":"","type":"image"}]}}