{"Shader":{"ver":"0.1","info":{"id":"4tfXDN","date":"1451934010","viewed":491,"name":"Hierarchical ray marching","username":"Dave_Hoskins","description":"A bit glitchy - needs more fudging. It ray marches 1\/16 screen and uses the resulting Z to ray march 1\/4, and then uses that to do the final march. I think it's quite fast.","likes":17,"published":3,"flags":32,"tags":["3d","raymarching","multiscale","hierarchical","terrrain"],"hasliked":0},"renderpass":[{"inputs":[{"id":8,"src":"\/presets\/tex07.jpg","ctype":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":10,"src":"\/presets\/tex09.jpg","ctype":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":47,"src":"\/presets\/tex19.png","ctype":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define MOD3 vec3(.1031,.11369,.13787)\n#define MOD4 vec4(.1031,.11369,.13787, .09987)\nvec3 sunDir  = normalize( vec3(  0.7, 0.6,  .48 ) );\nconst vec3 sunColour = vec3(1.0, .95, .8);\nfloat pix;\n\n\/\/----------------------------------------------------------------------------------------\n\nvec2 rot2D(inout vec2 p, float a)\n{\n    return cos(a)*p - sin(a) * vec2(p.y, -p.x);\n}\n\n\n\/\/----------------------------------------------------------------------------------------\nfloat roundedBox( vec3 p, vec3 b, float r )\n{\n\treturn length(max(abs(p)-b,0.0))-r;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat smoothMin( float a, float b, float k )\n{\n    \n\tfloat h = clamp(0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.-h);\n}\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                 \nmat2 m2 = mat2(0.970,  0.242, -0.242,  0.970);\n\nfloat triNoise3d(in vec3 p)\n{\n    float z=1.2;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=7.; i++ )\n\t{\n        vec3 dg = tri3(bp);\n        p += (dg);\n\n        bp *= 2.;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))\/z;\n        bp += 0.18;\n\t}\n\treturn max(rz-.3, 0.0)*2.5;\n}\n\nfloat turbulence(vec3 p)\n{\n    float t = triNoise3d(p*.003);\n    return t;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat mapDE(vec3 p)\n{\n    float d;\n    p.xz *= .3;\n\n    float disp = turbulence(p)*16.0;\n    d = smoothstep( 0.1, .7, texture2D(iChannel1, p.xz*.00015+.1, -99.).y)*4.0;\n    d += smoothstep( 0.,.8, texture2D(iChannel2, p.xz*.0002+.4, -99.).y)*3.;\n    d += smoothstep( 0.,.6, texture2D(iChannel2, p.xz*.0004+.2, -99.).y)*1.5;\n    d =  max(d*d*8.0, 0.0)+disp;\n    \n    \/\/ Ridges\n    float s = sin(p.x*.02-p.z*.044)*12.0+33.; \n    float w = mod(d, s)\/s;\n\tw = w*w*(3.0-2.0*w);\n    d = (floor(d \/ s) * s) + w * s;\n    \n    return (p.y +70.0 - d);\n}\n\/\/----------------------------------------------------------------------------------------\nfloat mapCam(vec3 p)\n{\n    float d;\n    p.xz *= .3;\n\n\n\n    d = smoothstep( 0.1, .7, texture2D(iChannel1, p.xz*.00015+.1, -99.).y)*4.0;\n    d += smoothstep( 0.,.8, texture2D(iChannel2, p.xz*.0002+.4, -99.).y)*3.;\n    d += smoothstep( 0.,.6, texture2D(iChannel2, p.xz*.0004+.2, -99.).y)*1.5;\n    d =  max(d*d*8.0-20., 0.0);\n\n    return (p.y +80.0 - d);\n}\n\nfloat sphereSize(float d)\n{\n    d = pix * d;\n    return d;\n\n}\n\n\nfloat binarySubdivision(in vec3 rO, in vec3 rD, vec2 t)\n{\n\t\/\/ Home in on the surface by dividing by two and split...\n    float halfwayT;\n\tfor (int n = 0; n < 5; n++)\n\t{\n\t\thalfwayT = (t.x + t.y) * .5;\n        (mapDE(rO + halfwayT*rD) < sphereSize(t.x)) ? t.x = halfwayT:t.y = halfwayT;\n\t}\n\treturn halfwayT;\n}\n\n\n\n\/\/----------------------------------------------------------------------------------------\nfloat rayMarch(vec3 pos, vec3 dir, vec2 uv, float d)\n{\n    d = max(d,.0);\n    bool hit = false;\n\tfloat de = 0.0, od = 0.0;\n    for (int i = 0; i < 150; i++)\n    {\n        de = mapDE(pos + dir * d);\n\n       if(de < sphereSize(d)  || d > 2000.0) break;\n\n        od = d;\n\t\td += 0.5*de;\n\n   \n    }\n\tif (d < 2000.0)\n        d = binarySubdivision(pos, dir, vec2(d, od));\n\telse\n\t\td = 2000.0;\n    \n    return d;\n}\n\n\/\/ Grab all sky information for a given ray from camera\nvec3 getSky(in vec3 rd)\n{\n\tfloat sunAmount = max( dot( rd, sunDir), 0.0 );\n    float horizon = pow(1.0-max(rd.y,0.0), 3.2)*.7;\n\n\tvec3  sky = vec3(.25, .35, .5);\n\t\/\/ Wide glare effect...\n\tsky = mix(sky, vec3(sunColour), horizon);\n\t\/\/ Actual sun...\n\tsky = sky+ sunColour * min(pow(sunAmount, 50.0), .3)*1.65;\n\treturn min(sky, 1.0);\n}\n\nvec3 normal( in vec3 pos, in float d )\n{\n\tvec2 eps = vec2( max(sphereSize(d*2.), .01), 0.0);\n\tvec3 nor = vec3(\n\t    mapDE(pos+eps.xyy) - mapDE(pos-eps.xyy),\n\t    mapDE(pos+eps.yxy) - mapDE(pos-eps.yxy),\n\t    mapDE(pos+eps.yyx) - mapDE(pos-eps.yyx)\n    );\n\treturn normalize(nor);\n}\nvec3 texCube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec3 x = texture2D( sam, p.yz ).xyz*vec3(.8, 1.0, 1.);\n\tvec3 y = texture2D( sam, p.zx ).xyz*vec3(.4, 1., .1);\n\tvec3 z = texture2D( sam, p.xy ).xyz;\n\treturn (x*abs(n.x) + y*abs(n.y) + z*abs(n.z))\/(abs(n.x)+abs(n.y)+abs(n.z));\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 cameraPos()\n{\n\tvec3 pos = vec3(190, 20.,4800.0+iGlobalTime*53.0+(iMouse.x\/iResolution.x)*1200.0);\n    float t = mapCam(pos);\n    pos.y = -t+80.;\n\treturn pos;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 cameraDir(vec2 uv)\n{\n    vec3 dir = normalize(vec3(0.0, 0.0, 1.0));\n\n    dir.yz = rot2D(dir.yz, -uv.y);\n    dir.xz = rot2D(dir.xz, uv.x);\n  \n        \n\treturn dir;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 outColour, in vec2 coords )\n{\n     \/\/coords-= .5;\n\n    pix = 1.\/iResolution.y;\n\tvec4 prev = texture2D(iChannel0, (coords)*.25\/iChannelResolution[0].xy);\n\n    vec3 col = vec3(0);\n    vec3 pos = cameraPos();\n    float d = prev.x;\n    float dOld = d;\n\n \tvec2 p = coords\/ iResolution.xy;\n\n\tvec2 uv = (p-.5)*vec2( iResolution.x \/ iResolution.y, 1);\n    vec3 dir = cameraDir(uv);\n    d = rayMarch(pos, dir, coords, max(d-80., 0.0));\n    vec3 sky = getSky(dir);\n    if (d < 2000.0)\n    {\n        vec3  loc = pos+dir*d;\n        vec3  nor = normal(loc, d);\n        \n        vec3  dif = texCube(iChannel3, loc*.03, nor);\n\t\tvec3  ref = reflect(dir, nor);\n        \n        col = dif * max(dot(sunDir, nor), 0.0);\n        float occ = 1.0 - max(1.0-turbulence(loc)*2.0, 0.0);\n        \n        float spe = pow(max(dot(sunDir, ref), 0.0), 5.)*.7;\n        vec3 amb = getSky(nor)*.25;\n        col += sunColour*spe*occ+amb;\n       \tcol = mix(sky, col, exp(-d*.001));\n\n    }else\n        col = sky;\n\n    \n    col = col*col*(3.0-2.0*col);\n\tcol *= .4+0.6*pow(70.0*p.x*p.y*(1.0-p.x)*(1.-p.y), .2 );\n\n    outColour = vec4(d\/2000.0,dOld\/2000.0,dOld\/2000.0,1.0);\n    \/\/outColour = vec4(dOld\/2000.0,dOld\/2000.0,dOld\/2000.0,1.0);\n    outColour = vec4(col,1.0);\n\n\n}","name":"","description":"","type":"image"},{"inputs":[{"id":8,"src":"\/presets\/tex07.jpg","ctype":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":47,"src":"\/presets\/tex19.png","ctype":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define MOD3 vec3(.1031,.11369,.13787)\n#define MOD4 vec4(.1031,.11369,.13787, .09987)\nvec3 sunDir  = normalize( vec3(  0.5, 0.6,  .48 ) );\nconst vec3 sunColour = vec3(1.0, .95, .8);\n\nfloat pix;\n\n\/\/----------------------------------------------------------------------------------------\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec2 rot2D(inout vec2 p, float a)\n{\n    return cos(a)*p - sin(a) * vec2(p.y, -p.x);\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                 \nmat2 m2 = mat2(0.970,  0.242, -0.242,  0.970);\n\nfloat triNoise3d(in vec3 p)\n{\n    float z=1.2;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=7.; i++ )\n\t{\n        vec3 dg = tri3(bp);\n        p += (dg);\n\n        bp *= 2.;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))\/z;\n        bp += 0.18;\n\t}\n\treturn max(rz-.3, 0.0)*2.5;\n}\n\n\nfloat turbulence(vec3 p)\n{\n \n    float t = triNoise3d(p*.04);\n    return t;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat mapDE(vec3 p)\n{\n    float d;\n    p.xz *= .3;\n\n    float disp = turbulence(p)*16.0;\n    d = smoothstep( 0.1, .7, texture2D(iChannel1, p.xz*.00015+.1, -99.).y)*4.0;\n    d += smoothstep( 0.,.8, texture2D(iChannel2, p.xz*.0002+.4, -99.).y)*3.;\n    d += smoothstep( 0.,.6, texture2D(iChannel2, p.xz*.0004+.2, -99.).y)*1.5;\n    d =  max(d*d*8.0, 0.0)+disp;\n    \n    \/\/ Ridges\n    float s = sin(p.x*.02-p.z*.044)*12.0+33.; \n    float w = mod(d, s)\/s;\n\tw = w*w*(3.0-2.0*w);\n    d = (floor(d \/ s) * s) + w * s;\n    \n    return (p.y +70.0 - d);\n}\n\/\/----------------------------------------------------------------------------------------\nfloat mapCam(vec3 p)\n{\n    float d;\n    p.xz *= .3;\n\n    d = smoothstep( 0.1, .7, texture2D(iChannel1, p.xz*.00015+.1, -99.).y)*4.0;\n    d += smoothstep( 0.,.8, texture2D(iChannel2, p.xz*.0002+.4, -99.).y)*3.;\n    d += smoothstep( 0.,.6, texture2D(iChannel2, p.xz*.0004+.2, -99.).y)*1.5;\n    d =  max(d*d*8.0-20., 0.0);\n\n    return (p.y +80.0 - d);\n}\n\nfloat sphereSize(float d)\n{\n    return d * 128.0 * pix;\n}\n    \n\/\/----------------------------------------------------------------------------------------\nfloat rayMarch(vec3 pos, vec3 dir, vec2 uv, float d)\n{\n    d = max(d,.0);\n    float oldD = d;\n    bool hit = false;\n    for (int i = 0; i < 80; i++)\n    {\n\t\tfloat de = mapDE(pos + dir * d);\n\n\t\tif(de < sphereSize(d) || d > 2000.0) break;\n\t\toldD = d;\n\n\t\td += 0.5*de;\n   \n    }\n\tif (d > 2000.0)\n\t\toldD = 2000.0;\n\n    \n    return oldD;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 cameraPos()\n{\n\tvec3 pos = vec3(190, 20.,4800.0+iGlobalTime*53.0+(iMouse.x\/iResolution.x)*1200.0);\n    float t = mapCam(pos);\n    pos.y = -t+80.;\n\treturn pos;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 cameraDir(vec2 uv)\n{\n    vec3 dir = normalize(vec3(0.0, 0.0, 1.0));\n\n    dir.yz = rot2D(dir.yz, -uv.y);\n    dir.xz = rot2D(dir.xz, uv.x);\n    \n\n\treturn dir;\n}\n\/\/----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 outColour, in vec2 coords )\n{\n \/\/coords-= .5;\n\n    vec2 p = (coords)\/ iResolution.xy;\n    pix = 1.0\/iResolution.y;\n\n    \/\/ Do a sixteenth of the screen...\n    if(p.x > 0.0625 || p.y > .0625) discard;\n    p *= 16.;\n    \/\/coords-= 8.0;\n    \n\tvec2 uv = (p-.5) * vec2( iResolution.x \/ iResolution.y, 1);\n\tvec3 pos = cameraPos();\n\tvec3 dir = cameraDir(uv);\n    vec3 col = vec3(0);\n    float d = rayMarch(pos, dir, coords, 0.);\n\n\toutColour = vec4(d);\n\n}","name":"","description":"","type":"buffer"},{"inputs":[{"id":8,"src":"\/presets\/tex07.jpg","ctype":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":47,"src":"\/presets\/tex19.png","ctype":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define MOD3 vec3(.1031,.11369,.13787)\n#define MOD4 vec4(.1031,.11369,.13787, .09987)\nvec3 sunDir  = normalize( vec3(  0.5, 0.6,  .48 ) );\nconst vec3 sunColour = vec3(1.0, .95, .8);\n\nfloat pix;\n\n\n\/\/----------------------------------------------------------------------------------------\nvec2 rot2D(inout vec2 p, float a)\n{\n    return cos(a)*p - sin(a) * vec2(p.y, -p.x);\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\nmat2 m2 = mat2(0.970,  0.242, -0.242,  0.970);\nfloat triNoise3d(in vec3 p)\n{\n    float z=1.2;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=7.; i++ )\n\t{\n        vec3 dg = tri3(bp);\n        p += (dg);\n\n        bp *= 2.;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))\/z;\n        bp += 0.18;\n\t}\n\treturn max(rz-.3, 0.0)*2.5;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat turbulence(vec3 p)\n{\n\n    float t = triNoise3d(p*.04);\n    return t;\n}\n\n\n\/\/----------------------------------------------------------------------------------------\nfloat mapDE(vec3 p)\n{\n    float d;\n    p.xz *= .3;\n\n    float disp = turbulence(p)*16.0;\n    d = smoothstep( 0.1, .7, texture2D(iChannel1, p.xz*.00015+.1, -99.).y)*4.0;\n    d += smoothstep( 0.,.8, texture2D(iChannel2, p.xz*.0002+.4, -99.).y)*3.;\n    d += smoothstep( 0.,.6, texture2D(iChannel2, p.xz*.0004+.2, -99.).y)*1.5;\n    d =  max(d*d*8.0, 0.0)+disp;\n    \n    \/\/ Ridges\n    float s = sin(p.x*.02-p.z*.044)*12.0+33.; \n    float w = mod(d, s)\/s;\n\tw = w*w*(3.0-2.0*w);\n    d = (floor(d \/ s) * s) + w * s;\n    \n    return (p.y +70.0 - d);\n}\n\/\/----------------------------------------------------------------------------------------\nfloat mapCam(vec3 p)\n{\n    float d;\n    p.xz *= .3;\n\n\n\n    d = smoothstep( 0.1, .7, texture2D(iChannel1, p.xz*.00015+.1, -99.).y)*4.0;\n    d += smoothstep( 0.,.8, texture2D(iChannel2, p.xz*.0002+.4, -99.).y)*3.;\n    d += smoothstep( 0.,.6, texture2D(iChannel2, p.xz*.0004+.2, -99.).y)*1.5;\n    d =  max(d*d*8.0-20., 0.0);\n\n    return (p.y +80.0 - d);\n}\n\nfloat sphereSize(in float d)\n{\n\treturn pix*d*64.0;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat rayMarch(vec3 pos, vec3 dir, vec2 uv, float d)\n{\n    d = max(d,.0);\n    float oldD = d;\n    bool hit = false;\n    for (int i = 0; i < 80; i++)\n    {\n\t\tfloat de = mapDE(pos + dir * d);\n\n       if(de < sphereSize(d) || d > 2000.0) break;\n\n\t\toldD = d;\n\t\td += 0.5*de;\n\n        \n   \n    }\n\tif (d > 2000.0)\n\t\toldD = 2000.0;\n\n    \n    return oldD;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 cameraPos()\n{\n\tvec3 pos = vec3(190, 20.,4800.0+iGlobalTime*53.0+(iMouse.x\/iResolution.x)*1200.0);\n    float t = mapCam(pos);\n    pos.y = -t+80.;\n\treturn pos;\n}\n\n\n\/\/----------------------------------------------------------------------------------------\nvec3 cameraDir(vec2 uv)\n{\n    vec3 dir = normalize(vec3(0.0, 0.0, 1.0));\n    \n    dir.yz = rot2D(dir.yz, -uv.y);\n    dir.xz = rot2D(dir.xz, uv.x);\n            \n\treturn dir;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 outColour, in vec2 coords )\n{\n \/\/coords-= .5;\n    vec2 p = coords\/ iResolution.xy;\n\tpix = 1.0\/iResolution.y;\n    \n    \/\/ Do a quarter of a screen...\n    if(p.x > .25 || p.y > .25) discard;\n    p*= 4.0;\n   \n    float d = texture2D(iChannel0, p*.0625).x;\n    \n    vec2 uv = (p-.5) * vec2( iResolution.x \/ iResolution.y, 1);\n\n    vec3 pos = cameraPos();\n    vec3 dir = cameraDir(uv);\n\n    vec3 col = vec3(0);\n    \n  \td = rayMarch(pos, dir, coords, max(d-40., 0.));\n\n\toutColour = vec4(d);\n}","name":"","description":"","type":"buffer"}]}}