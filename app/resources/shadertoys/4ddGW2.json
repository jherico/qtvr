{"Shader":{"ver":"0.1","info":{"id":"4ddGW2","date":"1452375191","viewed":345,"name":"Interactive kinetic Sponge","username":"iapafoto","description":"[Mouse] Use mouse to move the spring<br\/>[Space]  Use 2nd spring","likes":19,"published":3,"flags":48,"tags":["sponge","kinetic"],"hasliked":0},"renderpass":[{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/-----------------------------------------------------\n\/\/ Created by sebastien durand - 2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/-----------------------------------------------------\n\n\/\/ Lightening, essentially based on one of incredible TekF shaders:\n\/\/ https:\/\/www.shadertoy.com\/view\/lslXRj\n\n\/\/-----------------------------------------------------\n\n\n\/\/ Change this to improve quality (3 is good)\n\n#define ANTIALIASING 1\n\n\n\/\/ consts\nconst float tau = 6.2831853;\nconst float phi = 1.61803398875;\n\n\/\/ Isosurface Renderer\nconst int g_traceLimit=40;\nconst float g_traceSize=.002;\nconst float g_dSpringLen = .25;\n\n\/\/ storage register\/texel addresses\nconst vec2 txCMP = vec2(0.0,0.0);\nconst vec2 txCMV = vec2(1.0,0.0);\nconst vec2 txAM  = vec2(2.0,0.0);\nconst vec2 txO1  = vec2(3.0,0.0);\nconst vec2 txO2  = vec2(4.0,0.0);\nconst vec2 txO3  = vec2(5.0,0.0);\n\n\nconst vec3 g_boxSize = vec3(.4);\n\nconst vec3 g_ptOnBody = vec3(g_boxSize.x*.5, g_boxSize.y*.15, g_boxSize.z*.5); \nconst vec3 g_ptOnBody2 = vec3(g_boxSize.x*.5, -g_boxSize.y*.5, -g_boxSize.z*.5); \n\n\/\/ Data to read in Buf A\n\nvec3 g_posBox;\nmat3 g_rotBox;\n\nvec3 g_envBrightness = vec3(.5,.6,.9); \/\/ Global ambiant color\nvec3 g_lightPos1, g_lightPos2;\nvec3 g_vConnexionPos, g_posFix; \nvec3 g_vConnexionPos2;\nconst vec3 g_posFix2 = vec3(0.,1.,0.);\nfloat g_rSpring, g_rSpring2;\nbool g_WithSpring2;\n\n\/\/ -----------------------------------------------------------------\n\nfloat keyPress(int ascii) {\n\treturn texture2D(iChannel2,vec2((.5+float(ascii))\/256.,0.25)).x ;\n}\n\n\nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\n\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D( iChannel0, (uv+ 0.5)\/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\/\/--------------------------------------------------------------------\n\/\/ from iq shader Brick [https:\/\/www.shadertoy.com\/view\/MddGzf]\n\/\/--------------------------------------------------------------------\nvec3 load(in vec2 re) {\n    return texture2D(iChannel0, (0.5+re) \/ iChannelResolution[0].xy, -100.0 ).xyz;\n}\n\/\/--------------------------------------------------------------------\n\n\n\/\/ ---------------------------------------------\n\n\/\/ Distance from ray to point\nfloat distance(vec3 ro, vec3 rd, vec3 p) {\n\treturn length(cross(p-ro,rd));\n}\n\n\/\/ Intersection ray \/ sphere\nbool intersectSphere(in vec3 ro, in vec3 rd, in vec3 c, in float r, out float t0, out float t1) {\n    ro -= c;\n\tfloat b = dot(rd,ro), d = b*b - dot(ro,ro) + r*r;\n    if (d<0.) return false;\n\tfloat sd = sqrt(d);\n\tt0 = max(0., -b - sd);\n\tt1 = -b + sd;\n\treturn (t1 > 0.);\n}\n\nmat3 transpose(mat3 m) {\n    return mat3(\n        m[0][0], m[1][0], m[2][0],\n        m[0][1], m[1][1], m[2][1],\n        m[0][2], m[1][2], m[2][2]);\n}\n\n\/\/ -- Modeling Primitives ---------------------------------------------------\n\n\nfloat sdPlane( vec3 p ) {\n\treturn p.y;\n}\n\nvec2 sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n    return vec2(length( pa - ba*h ) - r, h);\n}\n\n\/\/ Mengerfold by Gijs [https:\/\/www.shadertoy.com\/view\/MlBXD1]\nfloat sdSponge(vec3 z){\n    z \/= .2;\n    \/\/folding\n    for(int n=0;n <3;n++) {\n       z = abs(z);\n       z.xy = (z.x<z.y) ? z.yx : z.xy;\n       z.xz = (z.x<z.z) ? z.zx : z.xz;\n       z.zy = (z.y<z.z) ? z.yz : z.zy;\t \n       z = z*3.-2.;\n       z.z += (z.z<-1.) ? 2. : 0.;\n    }\n    \/\/distance to cube\n    z = abs(z) - vec3(1.);\n    float dis = min(max(z.x,max(z.y,z.z)),0.) + length(max(z,0.)); \n    \/\/scale cube size to iterations\n    return dis *.2* pow(3., -3.); \n}\n\n\/\/----------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 ) {\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n\n\/\/----------------------------------------------------------------------\n\n\n\n\nfloat map(in vec3 p) {\n    float res = sdSponge( (p-g_posBox)*g_rotBox);\n    float spring = sdCapsule(p, g_posFix, g_vConnexionPos, g_rSpring).x;\n    if (g_WithSpring2)\n    \tspring = min(spring, sdCapsule(p, g_posFix2, g_vConnexionPos2, g_rSpring2).x);\n    return min(res, spring);\n}\n\n\/\/ render for color extraction\nfloat colorField(vec3 p) {\n    vec2 res = vec2(sdPlane(p-vec3(0.,-.5,0.)), 1.0 );\n    res = opU(res, vec2( sdSponge((p-g_posBox)*g_rotBox), 3.0 ));\n    vec2 spring = sdCapsule(p, g_posFix, g_vConnexionPos, g_rSpring );\n    spring = vec2(spring.x, 30.+ smoothstep(.1,.105, mod(spring.y,.2)));\n\tif (g_WithSpring2) {\n\t\tvec2 sp2 = sdCapsule(p, g_posFix2, g_vConnexionPos2, g_rSpring2);\n    \tspring = opU(spring, vec2(sp2.x, 40. + smoothstep(.1,.105,mod(sp2.y,.2))));\n\t}\n    res = opU( res, spring);\n    return res.y;\n}\n\n\n\/\/ ---------------------------------------------------------------------------\n\nfloat SmoothMax( float a, float b, float smoothing ) {\n\treturn a-sqrt(smoothing*smoothing + pow(max(.0,a-b),2.0));\n}\n\nvec3 Sky( vec3 ray) {\n\treturn g_envBrightness*mix( vec3(.8), vec3(0), exp2(-(1.0\/max(ray.y,.01))*vec3(.4,.6,1.0)) );\n}\nfloat isGridLine(vec2 p, vec2 v) {\n    vec2 k = smoothstep(.0,1.,abs(mod(p+v*.5, v)-v*.5)\/.01);\n    return k.x * k.y;\n}\n\/\/ -------------------------------------------------------------------\n\n\nvec3 Shade( vec3 pos, vec3 ray, vec3 normal, vec3 lightDir1, vec3 lightDir2, vec3 lightCol1, vec3 lightCol2, float shadowMask1, float shadowMask2, float distance )\n{\n    \n    float colorId = colorField(pos);\n    \n\tvec3 ambient = g_envBrightness*mix( vec3(.2,.27,.4), vec3(.4), (-normal.y*.5+.5) ); \/\/ ambient\n    \n    \/\/ ambient occlusion, based on my DF Lighting: https:\/\/www.shadertoy.com\/view\/XdBGW3\n\tfloat aoRange = distance\/20.0;\n\t\n\tfloat occlusion = max( 0.0, 1.0 - map( pos + normal*aoRange )\/aoRange ); \/\/ can be > 1.0\n\tocclusion = exp2( -2.0*pow(occlusion,2.0) ); \/\/ tweak the curve\n    \n\tambient *= occlusion*.8+.2; \/\/ reduce occlusion to imply indirect sub surface scattering\n\n\tfloat ndotl1 = max(.0,dot(normal,lightDir1));\n\tfloat ndotl2 = max(.0,dot(normal,lightDir2));\n    \n\tfloat lightCut1 = smoothstep(.0,.1,ndotl1);\n\tfloat lightCut2 = smoothstep(.0,.1,ndotl2);\n\n\tvec3 light = vec3(0);\n    \n\n\tlight += lightCol1*shadowMask1*ndotl1;\n\tlight += lightCol2*shadowMask2*ndotl2;\n\n    \n\t\/\/ And sub surface scattering too! Because, why not?\n    float transmissionRange = distance\/10.0; \/\/ this really should be constant... right?\n    float transmission1 = map( pos + lightDir1*transmissionRange )\/transmissionRange;\n    float transmission2 = map( pos + lightDir2*transmissionRange )\/transmissionRange;\n    \n    vec3 sslight = lightCol1 * smoothstep(0.0,1.0,transmission1) + \n                   lightCol2 * smoothstep(0.0,1.0,transmission2);\n    vec3 subsurface = vec3(1,.8,.5) * sslight;\n\n    float specularity = .012; \n\tvec3 h1 = normalize(lightDir1-ray);\n\tvec3 h2 = normalize(lightDir2-ray);\n    \n\tfloat specPower;\n    specPower = exp2(3.0+5.0*specularity);\n\n    vec3 albedo;\n    if (colorId < .5) {  \n        \/\/ Toge 1\n        albedo = vec3(1.,.6,0.);\n       \/\/ specPower = sqrt(specPower);\n    } else if (colorId < 1.5) {  \n        \/\/ Ground\n       float f = mod( floor(4.*pos.z) + floor(4.*pos.x), 2.0);\n        albedo = (0.4 + 0.1*f)*vec3(.7,.6,.8);\n        albedo *= .2*(.3+.5*isGridLine(pos.xz, vec2(.25)));\n      specPower *= 5.;\n    } else if (colorId < 12.5) {\n         \/\/ Skin color\n        albedo = vec3(.6,.3,.0); \/\/,.43,.3); \n        \n\n    } else if (colorId < 35.) {\n        albedo = mix(vec3(.5,.1,.1), vec3(.5,0.,0.), (colorId-30.));\n        specPower *= specPower;\n    } else {\n        albedo = mix(vec3(.1,.1,.5), vec3(0.,0.,.5), (colorId-40.));\n        specPower *= specPower;\n    }        \n    \n\tvec3 specular1 = lightCol1*shadowMask1*pow(max(.0,dot(normal,h1))*lightCut1, specPower)*specPower\/32.0;\n\tvec3 specular2 = lightCol2*shadowMask2*pow(max(.0,dot(normal,h2))*lightCut2, specPower)*specPower\/32.0;\n    \n\tvec3 rray = reflect(ray,normal);\n\tvec3 reflection = Sky( rray );\n\t\n\t\/\/ specular occlusion, adjust the divisor for the gradient we expect\n\tfloat specOcclusion = max( 0.0, 1.0 - map( pos + rray*aoRange )\/(aoRange*max(.01,dot(rray,normal))) ); \/\/ can be > 1.0\n\tspecOcclusion = exp2( -2.0*pow(specOcclusion,2.0) ); \/\/ tweak the curve\n\t\n\t\/\/ prevent sparkles in heavily occluded areas\n\tspecOcclusion *= occlusion;\n\n\treflection *= specOcclusion; \/\/ could fire an additional ray for more accurate results\n    \n\tfloat fresnel = pow( 1.0+dot(normal,ray), 5.0 );\n\tfresnel = mix( mix( .0, .01, specularity ), mix( .4, 1.0, specularity ), fresnel );\n\n    light += ambient;\n\tlight += subsurface;\n\n    vec3 result = light*albedo;\n\tresult = mix( result, reflection, fresnel );\n\tresult += specular1;\n    result += specular2;\n\n\treturn result;\n}\n\n\nfloat Trace( vec3 pos, vec3 ray, float traceStart, float traceEnd ) {\n    float t0=0.,t1=100.;\n    float t2=0.,t3=100.;\n    \/\/ trace only if intersect bounding spheres\n  \n\tfloat t = max(traceStart, min(t2,t0));\n\ttraceEnd = min(traceEnd, max(t3,t1));\n\tfloat h;\n\tfor( int i=0; i < g_traceLimit; i++) {\n\t\th = map( pos+t*ray );\n\t\tif (h < g_traceSize || t > traceEnd)\n\t\t\treturn t>traceEnd?100.:t;\n\t\tt = t+h;\n\t}\n        \n\treturn 100.0;\n}\n\n\n\nvec3 Normal( vec3 pos, vec3 ray, float t) {\n\n\tfloat pitch = .2 * t \/ iResolution.x;   \n\tpitch = max( pitch, .005 );\n\tvec2 d = vec2(-1,1) * pitch;\n\n\tvec3 p0 = pos+d.xxx; \/\/ tetrahedral offsets\n\tvec3 p1 = pos+d.xyy;\n\tvec3 p2 = pos+d.yxy;\n\tvec3 p3 = pos+d.yyx;\n\n\tfloat f0 = map(p0), f1 = map(p1), f2 = map(p2),\tf3 = map(p3);\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3);\n\t\/\/return normalize(grad);\n\t\/\/ prevent normals pointing away from camera (caused by precision errors)\n\treturn normalize(grad - max(.0,dot (grad,ray ))*ray);\n}\n\n\/\/ Camera\nvec3 Ray( float zoom, in vec2 fragCoord) {\n\treturn vec3( fragCoord.xy-iResolution.xy*.5, iResolution.x*zoom );\n}\n\nvec3 Rotate( inout vec3 v, vec2 a ) {\n\tvec4 cs = vec4( cos(a.x), sin(a.x), cos(a.y), sin(a.y) );\n\t\n\tv.yz = v.yz*cs.x+v.zy*cs.y*vec2(-1,1);\n\tv.xz = v.xz*cs.z+v.zx*cs.w*vec2(1,-1);\n\t\n\tvec3 p;\n\tp.xz = vec2( -cs.w, -cs.z )*cs.x;\n\tp.y = cs.y;\n\t\n\treturn p;\n}\n\n\/\/ Camera Effects\n\nvoid BarrelDistortion( inout vec3 ray, float degree ){\n\t\/\/ would love to get some disperson on this, but that means more rays\n\tray.z \/= degree;\n\tray.z = ( ray.z*ray.z - dot(ray.xy,ray.xy) ); \/\/ fisheye\n\tray.z = degree*sqrt(ray.z);\n}\n\n\nmat2 matRot(in float a) {\n    float ca = cos(a), sa = sin(a);\n    return mat2(ca,sa,-sa,ca);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    g_posBox = load(txCMP);\n    g_rotBox = mat3(load(txO1),load(txO2),load(txO3));\n    \n    vec2 m = iMouse.xy\/iResolution.y - .5;\n\tg_posFix = vec3(m.x,1.,m.y);\n    g_vConnexionPos = g_posBox + g_rotBox*g_ptOnBody;\n    \n    g_WithSpring2 = (keyPress(32) > .5);\n        \n    g_vConnexionPos2 = g_posBox + g_rotBox*g_ptOnBody2; \n    \n    \/\/ Keep constant volume for spring\n    g_rSpring = .01*sqrt(g_dSpringLen\/length(g_posFix-g_vConnexionPos));\n    g_rSpring2 = .01*sqrt(g_dSpringLen\/length(g_posFix2-g_vConnexionPos2));\n\n    vec2 mo = vec2(0);\/\/iMouse.xy\/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iGlobalTime;\n\n    \n\n\/\/ Positon du point lumineux\n    float distLightRot =  .7;\n                              \n    float lt = 3.*(time-1.);\n    \n   \n    g_lightPos1 = g_posBox + distLightRot*vec3(cos(lt*.5), .4+.15*sin(2.*lt), sin(lt*.5));\n    g_lightPos2 = g_posBox + distLightRot*vec3(cos(-lt*.5), .4+.15*sin(-2.*lt), sin(-lt*.5));\n\t\n\t\/\/ Ambiant color\n\tg_envBrightness = vec3(.6,.65,.9);\n    \n\/\/ intensitee et couleur du point\n    vec3 lightCol1 = vec3(1.05,.95,.95)*.5;\/\/*.2*g_envBrightness;\n\tvec3 lightCol2 = vec3(.95,1.,1.05)*.5;\/\/*.2*g_envBrightness;\n\t\n\n    \n\tfloat lightRange1 = .4, \n          lightRange2 = .4; \n\tfloat traceStart = .2;\n\n    float t, s1, s2;\n    \n    vec3 col, colorSum = vec3(0.);\n\tvec3 pos;\n    vec3 ro, rd;\n\t\n#if (ANTIALIASING == 1)\t\n\tint i=0;\n#else\n\tfor (int i=0;i<ANTIALIASING;i++) {\n#endif\n        float randPix = hash(iGlobalTime);\n        vec2 subPix = .4*vec2(cos(randPix+6.28*float(i)\/float(ANTIALIASING)),\n                              sin(randPix+6.28*float(i)\/float(ANTIALIASING)));        \n    \t\/\/ camera\t\n        vec2 q = (fragCoord.xy+subPix)\/iResolution.xy;\n        vec2 p = -1.0+2.0*q;\n        p.x *= iResolution.x\/iResolution.y;\n\n        ro = 5.*vec3( .9*cos(0.1*time),.45, .9*sin(0.1*time) );\n        vec3 ta = 5.*vec3( -0., 0.05, 0. );\n\n        \/\/ camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0);\n\n        \/\/ ray direction\n         rd = ca * normalize( vec3(p.xy,4.5) );\n\n        float tGround = -(ro.y+.5) \/ rd.y;\n        float traceEnd = min(tGround+1.,10.); \n        col = vec3(0);\n        vec3 n;\n        t = Trace(ro, rd, traceStart, traceEnd);\n        if ( t > tGround ) {\n            pos = ro + rd*tGround;   \n            n = vec3(0,1.,0);\n            t = tGround;\n        } else {\n            pos = ro + rd*t;\n            n = Normal(pos, rd, t);\n        }\n\n        \/\/ Shadows\n        vec3 lightDir1 = g_lightPos1-pos;\n        float lightIntensity1 = length(lightDir1);\n        lightDir1 \/= lightIntensity1;\n        \n        vec3 lightDir2 = g_lightPos2-pos;\n        float lightIntensity2 = length(lightDir2);\n        lightDir2 \/= lightIntensity2;\n\n        s1 = Trace(pos, lightDir1, .04, lightIntensity1 );\n        s2 = Trace(pos, lightDir2, .01, lightIntensity2 );\n\n        lightIntensity1 = lightRange1\/(.1+lightIntensity1*lightIntensity1);\n        lightIntensity2 = lightRange2\/(.1+lightIntensity2*lightIntensity2);\n\n        col = Shade(pos, rd, n, lightDir1, lightDir2, lightCol1*lightIntensity1, lightCol2*lightIntensity2,\n                    (s1<40.0)?0.0:1.0, (s2<40.0)?0.0:1.0, t );\n\n#if (ANTIALIASING > 1)\t\n        colorSum += col;\n\t}\n    \n    col = colorSum\/float(ANTIALIASING);\n#endif\n    \n    \/\/ fog\n    float f = 100.0;\n    col = mix( vec3(.8), col, exp2(-t*vec3(.4,.6,1.0)\/f) );\n    \n    \/\/ Draw light\n    s1 = .5*max(distance(ro, rd, g_lightPos1)+.05,0.);\n    float dist = .5*length(g_lightPos1-ro);\n    if (dist < t*.5) {\n        vec3 col1 = 2.*lightCol1*exp( -.03*dist*dist );\n        float BloomFalloff = 50000.;\n        col += col1*col1\/(1.+s1*s1*s1*BloomFalloff);\n    }\n\n    s2 = .5*max(distance(ro, rd, g_lightPos2)+.05,0.);\n    dist = .5*length(g_lightPos2-ro);\n    if (dist < t*.5) {\n        vec3 col2 = 2.*lightCol2*exp( -.03*dist*dist );\n        float BloomFalloff = 50000.;\n        col += col2*col2\/(1.+s2*s2*s2*BloomFalloff);\n    }\n        \n    \/\/ Compress bright colours, (because bloom vanishes in vignette)\n    vec3 c = (col-1.0);\n    c = sqrt(c*c+.05); \/\/ soft abs\n    col = mix(col,1.0-c,.48); \/\/ .5 = never saturate, .0 = linear\n\t\n\t\/\/ compress bright colours\n\tfloat l = max(col.x,max(col.y,col.z));\/\/dot(col,normalize(vec3(2,4,1)));\n\tl = max(l,.01); \/\/ prevent div by zero, darker colours will have no curve\n\tfloat l2 = SmoothMax(l,1.0,.01);\n\tcol *= l2\/l;\n    \n\tfragColor =  vec4(pow(col,vec3(1.\/1.6)),1);\n}\n","name":"","description":"","type":"image"},{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/Calculates the acceleration of each object and integrates its position.\n\n#define TIME_SCALE 2.\n#define dKdl .188\n#define dKda .0188\n\n\/\/ storage register\/texel addresses\nconst vec2 txCMP = vec2(0.0,0.0);\nconst vec2 txCMV = vec2(1.0,0.0);\nconst vec2 txAM  = vec2(2.0,0.0);\nconst vec2 txO1  = vec2(3.0,0.0);\nconst vec2 txO2  = vec2(4.0,0.0);\nconst vec2 txO3  = vec2(5.0,0.0);\n\nconst vec3 g_boxSize = vec3(.4);\nconst vec3 ptOnBody1 = vec3(g_boxSize.x*.5, g_boxSize.y*.15, g_boxSize.z*.5); \nconst vec3 ptOnBody2 = vec3(g_boxSize.x*.5, -g_boxSize.y*.5, -g_boxSize.z*.5); \nconst vec3 g_posFix2 = vec3(0.,1.,0.);\nconst float dSpringLen = .25;\nconst float dSpringK = 100.;\nconst float boxMass = 2.;\n\nfloat hash( int n ) { return fract(sin(float(n))*43758.5453123); }\n\nstruct Body {\n    vec3 vCMPosition,\n         vCMVelocity, \n         vAngularMomentum;\n    mat3 mOrientation;\n};\n\n    \nfloat keyPress(int ascii) {\n\treturn texture2D(iChannel2,vec2((.5+float(ascii))\/256.,0.25)).x ;\n}\n\n\n\/\/--------------------------------------------------------------------\n\/\/ from iq shader Brick [https:\/\/www.shadertoy.com\/view\/MddGzf]\n\/\/--------------------------------------------------------------------\n    \nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\n\nvec3 load(in vec2 re) {\n    return texture2D(iChannel0, (0.5+re) \/ iChannelResolution[0].xy, -100.0 ).xyz;\n}\n\nvoid store( in vec2 re, in vec3 va, inout vec4 fragColor, in vec2 fragCoord) {\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? vec4(va,0.) : fragColor;\n}\n   \n\/\/ --------------------------------------------------------------------------------------------\n\n\nBody getBody() {\n    return Body(load(txCMP), load(txCMV), load(txAM), mat3(load(txO1), load(txO2), load(txO3)));\n}\n\nvoid saveBody(Body body, inout vec4 fragColor, in vec2 fragCoord) {\n\tstore(txCMP, body.vCMPosition,  \tfragColor, fragCoord);\n\tstore(txCMV, body.vCMVelocity,  \tfragColor, fragCoord);\n\tstore(txAM,  body.vAngularMomentum, fragColor, fragCoord);\n\tstore(txO1,  body.mOrientation[0],  fragColor, fragCoord);\n\tstore(txO2,  body.mOrientation[1],  fragColor, fragCoord);\n\tstore(txO3,  body.mOrientation[2],  fragColor, fragCoord);\n}\n                    \n\nmat3 orthonormalize(mat3 m) {\n    vec3 v0 = normalize(m[0]), v2 = normalize(cross(v0, m[1])), v1 = normalize(cross(v2,v0));\n    return mat3(v0,v1,v2);\n}\n       \nmat3 skewSymmetric(vec3 v) {\n    return mat3(\n          0., v.z,  -v.y,\n        -v.z,   0.,  v.x,\n         v.y,  -v.x,   0.);\n}\n \nmat3 transpose(mat3 m) {\n    return mat3(\n        m[0][0], m[1][0], m[2][0],\n        m[0][1], m[1][1], m[2][1],\n        m[0][2], m[1][2], m[2][2]);\n}\n\n\n\/\/ for cube Size: meter, Mass: kg\nmat3 inverseInertiaTensor(vec3 s, float m) {\n\treturn mat3(\n        3.\/(m*dot(s.yz,s.yz)), 0., 0.,\n        0., 3.\/(m*dot(s.zx,s.zx)), 0.,\n        0., 0., 3.\/(m*dot(s.xy, s.xy)));\n}\n\nBody Integrate3D(float mass, mat3 mInverseBodyInertiaTensor, \n                 Body obj, vec3 vCMForce, vec3 vTorque, float dt) {\n    \/\/ compute auxiliary quantities\n    mat3 mInverseWorldInertiaTensor = obj.mOrientation * mInverseBodyInertiaTensor * transpose(obj.mOrientation);\n    vec3 vAngularVelocity = mInverseWorldInertiaTensor * obj.vAngularMomentum;\n       \t\t\n    vCMForce -= obj.vCMVelocity * dKdl\/dt; \/\/ Air friction\n    vTorque -= vAngularVelocity * dKda\/dt;\n    \n    obj.vCMVelocity\t+= vCMForce * (dt\/mass);\n    \n    obj.mOrientation\t += skewSymmetric(vAngularVelocity) * obj.mOrientation  * dt;\n    obj.vAngularMomentum += vTorque * dt;\n    obj.mOrientation = orthonormalize(obj.mOrientation);\n\n    \/\/ integrate primary quantities\n    obj.vCMPosition\t+= obj.vCMVelocity * dt;\n    \n    return obj;\n}\n\nvec3 getSpringForce(vec3 vSpringPos, vec3 vConnexionPos) {\n\t\/\/ force of this string\n    vec3 v = vSpringPos - vConnexionPos;\n\tfloat dLen = length(v);\n    float dSpringF = dSpringK * clamp(dLen - dSpringLen, 0., dSpringLen*4.);\n\treturn v * (dSpringF \/ dLen);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    \/\/ don't compute gameplay outside of the data area\n    if( fragCoord.x > 6. || fragCoord.y>.5 ) discard;\n       \n    vec2 res = iResolution.xy \/ iResolution.y;\n    int id = int(fragCoord.x);  \n    Body body;\n  \n    \/\/Initialization (iFrame == 0 doesn't seem to work when the page is initially loaded)\n    if(iFrame < 30) { \/\/iGlobalTime < 1.0) {\n        vec2 rpos = vec2(float(id) * 1.85, float(id) * -0.03); \n        body = Body(vec3(0.), vec3(0.), vec3(0.), mat3(1,0,0,0,1,0,0,0,1));\n    }\n    else {\n\n        body = getBody();\n        \n        vec3 sumF = vec3(0), sumTorque = vec3(0);\n       \n        \/\/ Gravity\n        sumF += vec3(0.,-9.81,0.) * boxMass; \n        \n        \/\/ Mouse\n        vec2 m = iMouse.xy\/iResolution.y - .5;\n        vec3 posFix = vec3(m.x,1.,m.y);\n\t\t\/\/ connexion pt in world base\n        vec3 vConnexionPos = body.vCMPosition + body.mOrientation*ptOnBody1; \n        vec3 springForce = getSpringForce(posFix, vConnexionPos);\n\n        \/\/ sum forces applied to object\n        sumF += springForce;\n        sumTorque += cross(vConnexionPos - body.vCMPosition, springForce);\n\n        if (keyPress(32) > .5) { \/\/ SPACE\n        \t\n\t\t\/\/ connexion pt in world base\n        \tvec3 vConnexionPos2 = body.vCMPosition + body.mOrientation*ptOnBody2; \n       \t\tvec3 springForce2 = getSpringForce(g_posFix2, vConnexionPos2);\n        \n            \/\/ sum forces applied to object\n            sumF += springForce2;\n            sumTorque += cross(vConnexionPos2 - body.vCMPosition, springForce2);\n        }\n        \n        \n        \n        body = Integrate3D(boxMass, inverseInertiaTensor(g_boxSize, boxMass), body, sumF, sumTorque, iTimeDelta * TIME_SCALE);\n    }\n    \n    fragColor = vec4(0.0);\n    saveBody(body, fragColor, fragCoord);                   \n}\n                           \n                           \n    ","name":"","description":"","type":"buffer"}]}}