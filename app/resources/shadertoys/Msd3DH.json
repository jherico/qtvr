{"Shader":{"ver":"0.1","info":{"id":"Msd3DH","date":"1449507791","viewed":353,"name":"Binary system","username":"Duke","description":"Based on \"Binary star\" <a href=\"https:\/\/www.shadertoy.com\/view\/ltjSWV\"  class=\"regular\" target=\"_blank\">Shadertoy<\/a> shader<br\/>Blackhole based on this <a href=\"http:\/\/glslsandbox.com\/e#21204.0\"  class=\"regular\" target=\"_blank\">Glslsandbox<\/a> shader<br\/>Press 1-2-3 to zoom in and zoom out.","likes":15,"published":3,"flags":16,"tags":["binary","sun","star","jet","blackhole","gargantua"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ \"Binary system\" by Duke\n\/\/ Based on \"Binary star\" https:\/\/www.shadertoy.com\/view\/ltjSWV shader \n\/\/ Blackhole based on this http:\/\/glslsandbox.com\/e#21204.0 shader\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#define DITHERING\n#define KEYBOARDZOOM\n\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\nconst float KEY_1 = 49.5\/256.0;\nconst float KEY_2 = 50.5\/256.0;\nconst float KEY_3 = 51.5\/256.0;\n\nconst float spin_speed=0.7;\n\nmat2 Spin(float angle){\n\treturn mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n}\n\n\/\/ mass (and radius of the event horizon as well)\nconst float mass = .15;\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\/\/-------------------------Noise--------------------------\n\/\/ IQ's noise\nfloat pn( in vec3 p )\n{\n    vec3 ip = floor(p);\n    p = fract(p);\n    p *= p*(3.0-2.0*p);\n    vec2 uv = (ip.xy+vec2(37.0,17.0)*ip.z) + p.xy;\n    uv = texture2D( iChannel0, (uv+ 0.5)\/256.0, -100.0 ).yx;\n    return mix( uv.x, uv.y, p.z );\n}\n\n\/\/ FBM\nfloat fpn(vec3 p) {\n    return pn(p*.06125)*.57 + pn(p*.125)*.28 + pn(p*.25)*.15;\n}\n\nfloat rand(vec2 co){\/\/ implementation found at: lumina.sourceforge.net\/Tutorials\/Noise.html\n\treturn fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\/\/-------------------------Disk---------------------------\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0\/8.0 );\n}\n\nfloat Disk( vec3 p, vec3 t )\n{\n    vec2 q = vec2(length2(p.xy)-t.x,p.z*0.5);\n    return max(length8(q)-t.y, abs(p.z) - t.z);\n}\n\n\/\/-------------------------Star---------------------------\n\/\/ Noise Settings\n#define NoiseSteps 4\n#define NoiseAmplitude 0.08\n#define NoiseFrequency 48.0\n  \nfloat Turbulence(vec3 position, float minFreq, float maxFreq, float qWidth)\n{\n    float value = 0.0;\n    float cutoff = clamp(0.5\/qWidth, 0.0, maxFreq);\n    float fade;\n    float fOut = minFreq;\n    for(int i=NoiseSteps ; i>=0 ; i--)\n    {\n      if(fOut >= 0.5 * cutoff) break;\n      fOut *= 2.0;\n      value += abs(pn(position * fOut))\/fOut;\n    }\n    fade = clamp(2.0 * (cutoff-fOut)\/cutoff, 0.0, 1.0);\n    value += fade * abs(pn(position * fOut))\/fOut;\n    return 1.0-value;\n}\n\nfloat SphereDist(vec3 position, vec3 rposition, float radius)\n{\n    return length(position - rposition) - radius;\n}\n\nfloat Star(vec3 position, vec3 rotdir, vec3 rposition, float radius)\n{\n    float distance;\n    float t=spin_speed*iGlobalTime;\n    float noise = Turbulence(vec3(Spin(t*0.25+rotdir.y*.81)*rotdir.zx*50.,rotdir.y*50.+t), 0.1, 1.5, 0.03) * NoiseAmplitude;\n    noise = clamp((abs(noise)),0.0,1.0);\n    distance = SphereDist(position, rposition, radius) - noise;\n    return distance;\n}\n\n\/\/-------------------------Vortex-------------------------\nfloat ridged(float f){\n\treturn 1.0-2.0*abs(f);\n}\n\nfloat Vortex(vec3 q, vec3 rposition, float h, float invjet) \/\/ the isosurface shape function, the surface is at o(q)=0\n{\n    q += rposition;\n\tfloat t=spin_speed*iGlobalTime;\n\tif(q.y<0.0) return length(q.xyz*vec3(1.0,invjet,1.0))-5.75;\n    vec3 spin_pos=vec3(Spin(t-sqrt(q.y))*q.xz,q.y-t*5.0);\n\tfloat zcurve=pow(q.y,1.5)*0.03;\n\tfloat v=abs(length(q.xz)-zcurve)-5.5-clamp(zcurve*0.2,0.1,1.0)*pn(spin_pos*vec3(0.1,0.1,0.1))*5.0;\n\treturn max(v, q.y - h);\n}\n\n\/\/-------------------------Map----------------------------\nvec2 map(vec3 p) {\n    \n    float t=spin_speed*iGlobalTime;\n\n    \/\/ system rotation\n    R(p.xy, pi*iGlobalTime*0.02);\n   \n    float StarD = Star(p,p,vec3(-1.0,6.5,0.0),2.5);\n    float VortexD = Vortex(p\/0.02, vec3(45.0,-100.0,0.0), 80.0, 1.0)*0.02;\n    \/\/---------------------------    \n    float Radius = 0.98;\n    \/\/float DiskD = Disk(p,vec3(1.0,Radius,0.35)) + fpn(vec3(Spin(t*0.125+p.z*.80)*p.xy*80.,p.z*40.-t)*6.0) * length(p) * 0.34; \/\/old variant\n    float DiskD = Disk(p,vec3(1.0,Radius,0.35)) + fpn(vec3(Spin(t*0.25+p.z*.10)*p.xy*20.,p.z*20.-t)*5.0) * length(p) * 0.34;\n    float r = (sqrt(dot(p,p))\/sqrt(2.0))*0.6;\n\tfloat a = atan(p.y, p.x);\n\tfloat dOffset = cos( (a+r*r*20.0)*2.-iGlobalTime*2.5) * .5 + .5;\n\tdOffset *= 1.0-r\/Radius;\n\tDiskD += dOffset * .2;\n    \/\/---------------------------\n    \/\/float d4 = Star(p,p.yzx,vec3(0.0,0.0,0.0),0.05)*.8;\n    \/\/---------------------------\n    vec3 q = p;\n    R(q.yz, -0.25*pi*2.);\n    float Jet1D = Vortex(q\/0.012, vec3(0.0,130.0,0.0), 90.0, 0.0)*0.012 + pn(vec3(Spin(t*4.5+p.z*.80)*p.xy*80.,p.z*40.-t)) * 0.18;\n    \/\/---------------------------\n    q = p;\n    R(q.yz, 0.25*pi*2.);\n    float Jet2D = Vortex(q\/0.012, vec3(0.0,130.0,0.0), 90.0, 0.0)*0.012 + pn(vec3(Spin(t*4.5+p.z*.80)*p.xy*80.,p.z*40.-t)) * 0.18;\n    \/\/---------------------------\n    vec2 result = vec2(smin(smin(VortexD,DiskD\/*smin(DiskD,d4,0.1)*\/,1.0),StarD,1.5), 1.0);\n    \n    result = vec2 (min(min(Jet1D,Jet2D),result.x), step(min(Jet1D,Jet2D),result.x));\n    \n    return result;\n}\n\n\/\/-------------------------Color palette------------------\n\/\/ See \"Combustible Voronoi\"\n\/\/ https:\/\/www.shadertoy.com\/view\/4tlSzl\nvec3 firePalette(float i){\n\n    float T = 1550. + 1400.*i; \/\/ Temperature range (in Kelvin).\n    vec3 L = vec3(7.4, 5.6, 4.4); \/\/ Red, green, blue wavelengths (in hundreds of nanometers).\n    L = pow(L,vec3(5.0)) * (exp(1.43876719683e5\/(T*L))-1.0);\n    return 1.0-exp(-5e8\/L); \/\/ Exposure level. Set to \"50.\" For \"70,\" change the \"5\" to a \"7,\" etc.\n}\n\n\/\/-------------------------Main---------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\n    \/\/ rd: direction of the ray\n    vec3 rd = normalize(vec3((gl_FragCoord.xy-0.5*iResolution.xy)\/iResolution.y, 1.));\n\n    #ifdef KEYBOARDZOOM\n    \/\/ keyboard control zoom\n    \/\/ Press 1-2-3 to zoom in and zoom out.\n    float key = 0.0;\n    key += 0.7*texture2D(iChannel1, vec2(KEY_1,0.25)).x;\n    key += 0.7*texture2D(iChannel1, vec2(KEY_2,0.25)).x;\n    key += 0.7*texture2D(iChannel1, vec2(KEY_3,0.25)).x;    \n    vec3 ro = vec3(0., 0., -11.+key*3.8);\n    R(rd.yz, -iMouse.y*0.005*pi*2.);\n    R(rd.xz, iMouse.x*0.005*pi*2.);\n    R(ro.yz, -iMouse.y*0.005*pi*2.);\n    R(ro.xz, iMouse.x*0.005*pi*2.);\n    #else\n    \/\/ mouse control zoom \n    vec3 ro = vec3(0., 0., -11.0 + iMouse.y * 0.022);\n    R(rd.yz, -0.0*0.01*pi*2.);\n\tR(rd.xz, iMouse.x*0.01*pi*2.);\n    R(ro.yz, -0.0*0.01*pi*2.);\n\tR(ro.xz, iMouse.x*0.01*pi*2.);\n    #endif\n    \n    \/\/ ld, td: local, total density \n    \/\/ w: weighting factor\n    float ld=0., td=0., w;\n\n    \/\/ t: length of the ray\n    \/\/ d: distance function\n    float d=1., t=0.;\n   \n    \/\/ Distance threshold.\n    const float h = .1;\n   \n    \/\/ total color\n    vec3 tc = vec3(0.);\n   \n    #ifdef DITHERING\n    vec2 pos = ( fragCoord.xy \/ iResolution.xy );\n    vec2 seed = pos + fract(iGlobalTime);\n    t=(.4+0.2*rand(seed*vec2(1)));\n    #endif\n\n    \/\/ p: position on the ray\n    vec3 p = ro+t*rd;\n    \n    vec2 sc = vec2(0.0);\n    \/\/ rm loop\n    for (int i=0; i<48; i++) {\n\n      \/\/ Loop break conditions. \n      if(td>(1.0-1.\/200.) || d<0.001*t || t>22. ||  dot(p,p) > 125. || dot(p,p) < mass*mass) break;\n\n      \/\/ evaluate distance function\n      sc = map(p);\n      d = sc.x;\n      \n      \/\/ check whether we are close enough (step)\n      \/\/ compute local density and weighting factor \n      \/\/ const float h = .1;\n      ld = (h - d) * step(d, h);\n      w = (1. - td) * ld;   \n\t       \n      \/\/ accumulate color and density\n      tc.x += (w*w + 1.\/50.) * sc.y * step(d, 0.55) * 3.0; \/\/ Jets color\n      tc.y += (w*w + 1.\/50.) * step(sc.y, h) * step(d, 1.95); \/\/ Star and disk color\n        \n      td += w +1.\/200.;\n\n\t  #ifdef DITHERING \n      d=abs(d)*(0.4+0.2*rand(seed*vec2(i)));\n      #endif         \n         \n      d = min(d, (length(p)-mass)*.5);\n        \n      \/\/ enforce minimum stepsize\n      d = max(d, 0.04); \n      \n      p += d*rd;\n\n      \/\/ step forward\n      t +=  max(d * 0.5, 0.02);\n        \n      \/\/ Approximated event horizon.\n\t  vec3 fieldDeriv = p * mass \/ pow(length(p),3.) \/ (2.*(1. - mass\/length(p)));\n\t  rd = normalize(rd-d*fieldDeriv);\n\n    }\n    \n\t\/\/ Coloring\n\ttc = mix(firePalette(tc.y),vec3(0.0,0.0,tc.x),0.4)*2.0;\n\t    \n    \/\/ stars background\n    if (td>0.6) {fragColor = vec4(tc, 1.0); return;}\n    vec3 stars = vec3(pn(rd*300.0)*0.5+0.5);\n    vec3 col = vec3(0.0);\n    col = mix(col, vec3(0.8,0.9,1.0), smoothstep(0.95, 1.0, stars)*clamp(dot(vec3(0.0),rd)+0.75,0.0,1.0));\n    col = clamp(col, 0.0, 1.0);\n    tc += col; \n    \n    fragColor = vec4(tc, 1.0);\n}","name":"","description":"","type":"image"}]}}