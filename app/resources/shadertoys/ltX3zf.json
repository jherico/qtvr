{"Shader":{"ver":"0.1","info":{"id":"ltX3zf","date":"1423785544","viewed":777,"name":"Retro City Parallax","username":"TekF","description":"Using my infinite city distance field for something a bit more abstract.","likes":3,"published":3,"flags":0,"tags":["parallax"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Ben Quantock 2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec2 Rand( vec2 pos )\n{\n\treturn texture2D( iChannel0, (pos+.5)\/256.0, -100.0 ).xz;\n}\n\nvec3 VoronoiPoint(vec2 pos, vec2 delta )\n{\n\tconst float randScale = .8; \/\/ reduce this to remove axis-aligned hard edged errors\n\t\n\tvec2 p = floor(pos)+delta;\n\tvec2 r = (Rand(p)-.5)*randScale;\n\tvec2 c = p+.5+r;\n\t\n\t\/\/ various length calculations for different patterns\n\t\/\/float l = length(c-pos);\n\t\/\/float l = length(vec3(c-pos,.1));\n\tfloat l = abs(c.x-pos.x)+abs(c.y-pos.y); \/\/ more interesting shapes\n\t\n\treturn vec3(c,l);\n}\n\n\/\/ For building height I want to know which voronoi point I used\n\/\/ For side-walls I want difference between distance of closest 2 points\nvec3 Voronoi( vec2 pos )\n{\n\t\/\/ find closest & second closest points\n\tvec3 delta = vec3(-1,0,1);\n\n\t\/\/ sample surrounding points on the distorted grid\n\t\/\/ could get 2 samples for the price of one using a rotated (17,37) grid...\n\tvec3 point[9];\n\tpoint[0] = VoronoiPoint( pos, delta.xx );\n\tpoint[1] = VoronoiPoint( pos, delta.yx );\n\tpoint[2] = VoronoiPoint( pos, delta.zx );\n\tpoint[3] = VoronoiPoint( pos, delta.xy );\n\tpoint[4] = VoronoiPoint( pos, delta.yy );\n\tpoint[5] = VoronoiPoint( pos, delta.zy );\n\tpoint[6] = VoronoiPoint( pos, delta.xz );\n\tpoint[7] = VoronoiPoint( pos, delta.yz );\n\tpoint[8] = VoronoiPoint( pos, delta.zz );\n\n\tvec3 closest;\n\tclosest.z =\n\t\tmin(\n\t\t\tmin(\n\t\t\t\tmin(\n\t\t\t\t\tmin( point[0].z, point[1].z ),\n\t\t\t\t\tmin( point[2].z, point[3].z )\n\t\t\t\t), min(\n\t\t\t\t\tmin( point[4].z, point[5].z ),\n\t\t\t\t\tmin( point[6].z, point[7].z )\n\t\t\t\t)\n\t\t\t), point[8].z\n\t\t);\n\t\n\t\/\/ find second closest\n\t\/\/ maybe there's a better way to do this\n\tclosest.xy = point[8].xy;\n\tfor ( int i=0; i < 8; i++ )\n\t{\n\t\tif ( closest.z == point[i].z )\n\t\t{\n\t\t\tclosest = point[i];\n\t\t\tpoint[i] = point[8];\n\t\t}\n\t}\n\t\t\n\tfloat t;\n\tt = min(\n\t\t\tmin(\n\t\t\t\tmin( point[0].z, point[1].z ),\n\t\t\t\tmin( point[2].z, point[3].z )\n\t\t\t), min(\n\t\t\t\tmin( point[4].z, point[5].z ),\n\t\t\t\tmin( point[6].z, point[7].z )\n\t\t\t)\n\t\t);\n\t\n\treturn vec3( closest.xy, t-closest.z );\n}\n\n\nfloat DistanceField( vec3 pos )\n{\n\tvec3 v = Voronoi(pos.xz);\n\tvec2 r = Rand(v.xy*4.0); \/\/ per-building seed\n\t\n\tfloat f = (.2+.3*r.y-v.z)*.5; \/\/.7071; \/\/ correct for max gradient of voronoi x+z distance calc\n\t\n\t\/\/ random height\n\tfloat h = r.x; \/\/ v.xy is position of cell centre, use it as random seed\n\th = mix(.2,2.0,pow(h,2.0));\n\th = pos.y-h;\n\n\t\/\/ we get precision problems caused by the discontinuity in height\n\t\/\/ so clamp it near to the surface and then apply a plane at max height\t\n\th = max( min( h, .08 ), pos.y-2.0 );\n\n\/\/\tf = max( f, h );\n\tif ( f > 0.0 && h > 0.0 )\n\t\tf = sqrt(f*f+h*h); \/\/ better distance computation, to reduce errors\n\telse\n\t\tf = max(f,h);\n\t\n\tf = min( f, pos.y ); \/\/ ground plane\n\t\n\treturn f;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 iHalfRes = iResolution.xy*.5;\n\tvec2 uv = fragCoord.xy;\n\/\/    uv = floor(uv\/6.0)*6.0; \/\/ pixellate! (would look better if I aligned each layer to the pixels)\n\tuv = (uv - iHalfRes)\/iHalfRes.y;\n    \n    vec3 pos = vec3(1.2,0,0)*iGlobalTime+vec3(0,.4+2.0*smoothstep(.0,1.,cos(iGlobalTime*.1)),0);\n    float water = step(uv.y\/1.4,-pos.y)*-2.0+1.0;\n    \n    fragColor.rgb = sin(vec3(11,7,3)*uv.y*water)*.5+.5;\n\n    float s = 2.;\n    for ( int i=0; i < 20; i++ )\n    {\n        if ( DistanceField( (vec3(uv*.4,1)*s + pos)*vec3(1,water,1) ) < .0 )\n        {\n            fragColor.rgb = sin(vec3(11,7,3)*.2*s+6.)*.5+.5;\n            break;\n        }\n        s *= 1.05+s*.02;\n    }\n    \n    if ( water < .0 )\n    {\n        fragColor.rgb = fragColor.rgb*mix(vec3(1), vec3(.1,.0,.2), smoothstep(-.5,-1.4,uv.y\/1.4-pos.y) );\n    }\n    \n\tfragColor.a = 1.0;\n}\n\n","name":"","description":"","type":"image"}]}}