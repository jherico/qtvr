{"Shader":{"ver":"0.1","info":{"id":"lsX3DH","date":"1368639478","viewed":7555,"name":"More spheres","username":"reinder","description":"A simple pathtracer based on my shader https:\/\/www.shadertoy.com\/view\/lsX3WH showing motion blur, depth of field and importance sampling. Based on: http:\/\/www.iquilezles.org\/www\/articles\/simplepathtracing\/simplepathtracing.htm<br\/>","likes":74,"published":3,"flags":0,"tags":["motionblur","spheres","pathtracer","depthoffield"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ More spheres. Created by Reinder Nijhoff 2013\n\/\/ @reindernijhoff\n\/\/\n\/\/ https:\/\/www.shadertoy.com\/view\/lsX3DH\n\/\/\n\/\/ based on: http:\/\/www.iquilezles.org\/www\/articles\/simplepathtracing\/simplepathtracing.htm\n\/\/\n\n#define MOTIONBLUR\n#define DEPTHOFFIELD\n\n#define CUBEMAPSIZE 256\n\n#define SAMPLES 8\n#define PATHDEPTH 4\n#define TARGETFPS 60.\n\n#define FOCUSDISTANCE 17.\n#define FOCUSBLUR 0.25\n\n#define RAYCASTSTEPS 20\n#define RAYCASTSTEPSRECURSIVE 2\n\n#define EPSILON 0.001\n#define MAXDISTANCE 180.\n#define GRIDSIZE 8.\n#define GRIDSIZESMALL 5.9\n#define MAXHEIGHT 10.\n#define SPEED 0.5\n\nfloat time = iGlobalTime;\n\n\/\/\n\/\/ math functions\n\/\/\n\nfloat hash( const float n ) {\n\treturn fract(sin(n)*43758.54554213);\n}\nvec2 hash2( const float n ) {\n\treturn fract(sin(vec2(n,n+1.))*vec2(43758.5453123));\n}\nvec2 hash2( const vec2 n ) {\n\treturn fract(sin(vec2( n.x*n.y, n.x+n.y))*vec2(25.1459123,312.3490423));\n}\nvec3 hash3( const vec2 n ) {\n\treturn fract(sin(vec3(n.x, n.y, n+2.0))*vec3(36.5453123,43.1459123,11234.3490423));\n}\n\/\/\n\/\/ intersection functions\n\/\/\n\nfloat intersectPlane( const vec3 ro, const vec3 rd, const float height) {\t\n\tif (rd.y==0.0) return 500.;\t\n\tfloat d = -(ro.y - height)\/rd.y;\n\tif( d > 0. ) {\n\t\treturn d;\n\t}\n\treturn 500.;\n}\n\nfloat intersectUnitSphere ( const vec3 ro, const vec3 rd, const vec3 sph ) {\n\tvec3  ds = ro - sph;\n\tfloat bs = dot( rd, ds );\n\tfloat cs = dot( ds, ds ) - 1.0;\n\tfloat ts = bs*bs - cs;\n\n\tif( ts > 0.0 ) {\n\t\tts = -bs - sqrt( ts );\n\t\tif( ts > 0. ) {\n\t\t\treturn ts;\n\t\t}\n\t}\n\treturn 500.;\n}\n\n\/\/\n\/\/ Scene\n\/\/\n\nvoid getSphereOffset( const vec2 grid, out vec2 center ) {\n\tcenter = (hash2( grid+vec2(43.12,1.23) ) - vec2(0.5) )*(GRIDSIZESMALL);\n}\nvoid getMovingSpherePosition( const vec2 grid, const vec2 sphereOffset, out vec3 center ) {\n\t\/\/ falling?\n\tfloat s = 0.1+hash( grid.x*1.23114+5.342+74.324231*grid.y );\n\tfloat t = 14.*s + time\/s;\n\t\n\tfloat y =  s * MAXHEIGHT * abs( cos( t ) );\n\tvec2 offset = grid + sphereOffset;\n\t\n\tcenter = vec3( offset.x, y, offset.y ) + 0.5*vec3( GRIDSIZE, 2., GRIDSIZE );\n}\nvoid getSpherePosition( const vec2 grid, const vec2 sphereOffset, out vec3 center ) {\n\tvec2 offset = grid + sphereOffset;\n\tcenter = vec3( offset.x, 0., offset.y ) + 0.5*vec3( GRIDSIZE, 2., GRIDSIZE );\n}\nvec3 getSphereColor( const vec2 grid ) {\n\treturn 0.8*normalize( hash3( grid+vec2(43.12*grid.y,12.23*grid.x) ) );\n}\n\nvec3 sundir = normalize( vec3(-1.0,0.8,0.2) );\n\nvec3 getBackgroundColor( const vec3 ro, const vec3 rd ) {\t\n\treturn vec3( 0.8, 0.9, 1.0 ) * (1.8 * (rd.y+0.5) );\n}\n\n\/\/ code duplication because the for-loop requires a const\nvec3 traceRec( const vec3 ro, const vec3 rd, out vec3 intersection, out vec3 normal, out float dist, out int material) {\n\tdist = MAXDISTANCE;\n\tfloat distcheck;\n\t\n\tvec3 sphereCenter, col;\n\n\tmaterial = 0;\t\n\tcol = getBackgroundColor(ro, rd);\n\t\n\tif( (distcheck = intersectPlane( ro,  rd, 0.)) < MAXDISTANCE ) {\n\t\tdist = distcheck;\n\t\tmaterial = 1;\n\t\tnormal = vec3( 0., 1., 0. );\n\t\tcol = vec3( 0.5 );\n\t}\n\t\n\t\/\/ trace grid\n\tvec3 pos = floor(ro\/GRIDSIZE)*GRIDSIZE;\n\tvec3 ri = 1.0\/rd;\n\tvec3 rs = sign(rd) * GRIDSIZE;\n\tvec3 dis = (pos-ro + 0.5  * GRIDSIZE + rs*0.5) * ri;\n\tvec3 mm = vec3(0.0);\n\tvec2 offset;\n\t\n\tfor( int i=0; i<RAYCASTSTEPSRECURSIVE; i++ ) {\n\t\tif( material == 2 ) break; {\t\t\n\t\t\tgetSphereOffset( pos.xz, offset );\t\t\t\n\t\t\t\n\t\t\tgetMovingSpherePosition( pos.xz, -offset, sphereCenter );\t\t\t\n\t\t\tif( (distcheck = intersectUnitSphere( ro, rd, sphereCenter )) < dist ) {\n\t\t\t\tdist = distcheck;\n\t\t\t\tnormal = normalize((ro+rd*dist)-sphereCenter);\n\t\t\t\tcol = getSphereColor(pos.xz);\n\t\t\t\tmaterial = 2;\n\t\t\t}\n\t\t\t\n\t\t\tgetSpherePosition( pos.xz, offset, sphereCenter );\n\t\t\tif( (distcheck = intersectUnitSphere( ro, rd, sphereCenter )) < dist ) {\n\t\t\t\tdist = distcheck;\n\t\t\t\tnormal = normalize((ro+rd*dist)-sphereCenter);\n\t\t\t\tcol = getSphereColor(pos.xz+vec2(1.,2.));\n\t\t\t\tmaterial = 2;\n\t\t\t}\n\t\t\t\n\t\t\tmm = step(dis.xyz, dis.zyx);\n\t\t\tdis += mm * rs * ri;\n\t\t\tpos += mm * rs;\t\n\t\t}\n\t}\n\t\n\tintersection = ro+rd*dist;\n\t\n\treturn col;\n}\n\n\nvec3 trace(const vec3 ro, const vec3 rd, out vec3 intersection, out vec3 normal, out float dist, out int material) {\n\tdist = MAXDISTANCE;\n\tfloat distcheck;\n\t\n\tvec3 sphereCenter, col, normalcheck;\n\t\n\tmaterial = 0;\n\tcol = getBackgroundColor(ro, rd);\n\t\n\tif( (distcheck = intersectPlane( ro,  rd, 0.)) < MAXDISTANCE ) {\n\t\tdist = distcheck;\n\t\tmaterial = 1;\n\t\tnormal = vec3( 0., 1., 0. );\n\t\tcol = vec3( 0.5 );\n\t} \n\t\n\t\/\/ trace grid\n\tvec3 pos = floor(ro\/GRIDSIZE)*GRIDSIZE;\n\tvec3 ri = 1.0\/rd;\n\tvec3 rs = sign(rd) * GRIDSIZE;\n\tvec3 dis = (pos-ro + 0.5  * GRIDSIZE + rs*0.5) * ri;\n\tvec3 mm = vec3(0.0);\n\tvec2 offset;\n\t\t\n\tfor( int i=0; i<RAYCASTSTEPS; i++ )\t{\n\t\tif( material == 2 ||  distance( ro.xz, pos.xz ) > dist+GRIDSIZE ) break; {\n\t\t\tgetSphereOffset( pos.xz, offset );\n\t\t\t\n\t\t\tgetMovingSpherePosition( pos.xz, -offset, sphereCenter );\t\t\t\n\t\t\tif( (distcheck = intersectUnitSphere( ro, rd, sphereCenter )) < dist ) {\n\t\t\t\tdist = distcheck;\n\t\t\t\tnormal = normalize((ro+rd*dist)-sphereCenter);\n\t\t\t\tcol = getSphereColor(pos.xz);\n\t\t\t\tmaterial = 2;\n\t\t\t}\n\t\t\t\n\t\t\tgetSpherePosition( pos.xz, offset, sphereCenter );\n\t\t\tif( (distcheck = intersectUnitSphere( ro, rd, sphereCenter )) < dist ) {\n\t\t\t\tdist = distcheck;\n\t\t\t\tnormal = normalize((ro+rd*dist)-sphereCenter);\n\t\t\t\tcol = getSphereColor(pos.xz+vec2(1.,2.));\n\t\t\t\tmaterial = 2;\n\t\t\t}\t\t\n\t\t\tmm = step(dis.xyz, dis.zyx);\n\t\t\tdis += mm * rs * ri;\n\t\t\tpos += mm * rs;\t\t\n\t\t}\n\t}\n\t\n\tintersection = ro+rd*dist;\n\t\n\treturn col;\n}\n\nvec2 rv2;\n\nvec3 cosWeightedRandomHemisphereDirection2( const vec3 n ) {\n\tvec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );\n\tvec3  vv = cross( uu, n );\n\t\n\tfloat ra = sqrt(rv2.y);\n\tfloat rx = ra*cos(6.2831*rv2.x); \n\tfloat ry = ra*sin(6.2831*rv2.x);\n\tfloat rz = sqrt( 1.0-rv2.y );\n\tvec3  rr = vec3( rx*uu + ry*vv + rz*n );\n\n    return normalize( rr );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 q = fragCoord.xy\/iResolution.xy;\n\tvec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x\/iResolution.y;\n\t\n\tvec3 col = vec3( 0. );\n\t\n\t\/\/ raytrace\n\tint material;\n\tvec3 normal, intersection;\n\tfloat dist;\n\tfloat seed = time+(p.x+iResolution.x*p.y)*1.51269341231;\n\t\n\tfor( int j=0; j<SAMPLES; j++ ) {\n\t\tfloat fj = float(j);\n\t\t\n#ifdef MOTIONBLUR\n\t\ttime = iGlobalTime + fj\/(float(SAMPLES)*TARGETFPS);\n#endif\n\t\t\n\t\trv2 = hash2( 24.4316544311*fj+time+seed );\n\t\t\n\t\tvec2 pt = p+rv2\/(0.5*iResolution.xy);\n\t\t\t\t\n\t\t\/\/ camera\t\n\t\tvec3 ro = vec3( cos( 0.232*time) * 10., 6.+3.*cos(0.3*time), GRIDSIZE*(time\/SPEED) );\n\t\tvec3 ta = ro + vec3( -sin( 0.232*time) * 10., -2.0+cos(0.23*time), 10.0 );\n\t\t\n\t\tfloat roll = -0.15*sin(0.5*time);\n\t\t\n\t\t\/\/ camera tx\n\t\tvec3 cw = normalize( ta-ro );\n\t\tvec3 cp = vec3( sin(roll), cos(roll),0.0 );\n\t\tvec3 cu = normalize( cross(cw,cp) );\n\t\tvec3 cv = normalize( cross(cu,cw) );\n\t\n#ifdef DEPTHOFFIELD\n    \/\/ create ray with depth of field\n\t\tconst float fov = 3.0;\n\t\t\n        vec3 er = normalize( vec3( pt.xy, fov ) );\n        vec3 rd = er.x*cu + er.y*cv + er.z*cw;\n\n        vec3 go = FOCUSBLUR*vec3( (rv2-vec2(0.5))*2., 0.0 );\n        vec3 gd = normalize( er*FOCUSDISTANCE - go );\n\t\t\n        ro += go.x*cu + go.y*cv;\n        rd += gd.x*cu + gd.y*cv;\n\t\trd = normalize(rd);\n#else\n\t\tvec3 rd = normalize( pt.x*cu + pt.y*cv + 1.5*cw );\t\t\n#endif\t\t\t\n\t\tvec3 colsample = vec3( 1. );\n\t\t\n\t\t\/\/ first hit\n\t\trv2 = hash2( (rv2.x*2.4543263+rv2.y)*(time+1.) );\n\t\tcolsample *= trace(ro, rd, intersection, normal, dist, material);\n\n\t\t\/\/ bounces\n\t\tfor( int i=0; i<(PATHDEPTH-1); i++ ) {\n\t\t\tif( material != 0 ) {\n\t\t\t\trd = cosWeightedRandomHemisphereDirection2( normal );\n\t\t\t\tro = intersection + EPSILON*rd;\n\t\t\t\t\t\t\n\t\t\t\trv2 = hash2( (rv2.x*2.4543263+rv2.y)*(time+1.)+(float(i+1)*.23) );\n\t\t\t\t\t\t\n\t\t\t\tcolsample *= traceRec(ro, rd, intersection, normal, dist, material);\n\t\t\t}\n\t\t}\t\n\t\tif( material == 0 ) {\t\t\t\n\t\t\tcol += colsample;\t\n\t\t}\n\t}\n\tcol  \/= float(SAMPLES);\n\t\n\tcol = pow( col, vec3(0.7) );\t\n\tcol = clamp(col, 0.0, 1.0);\n\t\/\/ contrast\t\n \/\/   col = clamp( col*0.7 + 0.3*col*col*(3.0-2.0*col), 0., 1.); \n\t   \n\t\/\/ vigneting\n\tcol *= 0.25+0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15 );\n\t\n\tfragColor = vec4( col,1.0);\n}","name":"","description":"","type":"image"}]}}