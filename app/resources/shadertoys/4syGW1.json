{"Shader":{"ver":"0.1","info":{"id":"4syGW1","date":"1454167020","viewed":47,"name":"Citrus Rat Traversal","username":"eiffie","description":"This probably has another name but could it be better than \"Citrus Rat\"?","likes":2,"published":3,"flags":32,"tags":["traversal","search"],"hasliked":0},"renderpass":[{"inputs":[{"id":16,"src":"\/presets\/tex11.png","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/Citrus Rat Traversal by eiffie\n\/\/The impatient citrus rat wants to get to the orange as quickly as possible but it\n\/\/doesn't have the intelligence to plan a route or remember where it has been past\n\/\/the last branch. How does it find the orange every time and often in the\n\/\/shortest time?\n\n\/\/1. Start going up.\n\/\/2. If going up take the branch that seems to point towards the orange (local min)\n\/\/3. If it gets too far away go back down.\n\/\/4. If going down you come to a branch look to see which way you came down.\n\/\/   a) If you came down from the direction of the orange take the opposite branch up.\n\/\/   b) If not keep going down.\n\n\/\/Even though the citrus rat doesn't need to remember his moves I still had to use\n\/\/a stack... I hate rats.\n\n\/\/Actually this search method although not optimal does work on any problem where\n\/\/you make decisions that can be ranked best to worst. Those solutions\n\/\/that are local minimums are reached quickly, others are reached eventually.\n\n\/\/I tried it on the parametric curve from iq and it took 100 touchs compared\n\/\/to 35 for a march with \"fudging\" so it is nothing magical.\n\/\/https:\/\/www.shadertoy.com\/view\/MsKGDz\n\n#define DEPTH 6.\n#define MIN_DIST 0.01\n#define load(a) texture2D(iChannel0,(vec2(a,0.0)+0.5)\/iResolution.xy)\n\nfloat IDX,DONE;\/\/index and branch done bit stacks for ease\nvoid clear(){IDX=1.;DONE=0.;}\/\/to get a usable index number start at 1\nbool push(bool bLeft, bool bDone){\n\tIDX=IDX*2.0+(bLeft?1.0:0.0);\n\tDONE=DONE*2.0+(bDone?1.0:0.0);\n\treturn IDX>pow(2.0,DEPTH)-0.5;\n}\nbool pop(out bool bLeft, out bool bDone){\n\tIDX\/=2.0;bLeft=(fract(IDX)>0.0);IDX=floor(IDX);\n\tDONE\/=2.0;bDone=(fract(DONE)>0.0);DONE=floor(DONE);\n\treturn IDX<0.5;\n}\n\n\/\/tree config\nfloat scl1,scl2,BO;\nmat2 mx1,mx2;\n\nvoid setup(){\n\tvec4 st=load(0);\n\tscl1=st.z;scl2=st.w;\n\tBO=1.0\/(min(scl1,scl2)-1.0);BO*=BO;\n\tmx1=mat2(cos(st.x),sin(st.x),-sin(st.x),cos(st.x));\n\tmx2=mat2(cos(st.y),sin(st.y),-sin(st.y),cos(st.y));\n}\n\n\/\/do transformations with each push\/pop, scale,rot space and offset by constant \nbool Push(inout vec3 p, bool bLeft, bool bDone){\n\tif(bLeft){p*=scl1;p.xy=p.xy*mx1;}\n\telse {p*=scl2;p.xy=mx2*p.xy;}\n\tp.y-=1.0;\n\treturn push(bLeft, bDone);\n}\nbool Pop(inout vec3 p, out bool bLeft, out bool bDone){\/\/reverse transform\n\tbool b=pop(bLeft, bDone);\n\tp.y+=1.0;\n\tif(bLeft){p.xy=mx1*p.xy;p\/=scl1;}\n\telse {p.xy=p.xy*mx2;p\/=scl2;}\n\treturn b;\n}\n\nfloat Branch(vec3 p){return length(vec3(p.x,p.y-clamp(p.y,-1.0,0.0),p.z))-0.05+p.y*0.025;}\n\nfloat Tree(vec2 p0){\n\tvec3 p=vec3(p0,1.0);\/\/p.z is scale\n\tclear();\n\t\n\t\/\/these three control the rats behavior\n\tbool bLeft;\/\/did the rat use the left branch?\n\tbool bDone=false;\/\/did the rat come down the wrong side? (branch exhausted)\n\tbool bUp=true;\/\/is the rat ascending?\t\n    bool bQuit=false;\n\t\n\tfloat dm=Branch(vec3(p.xy,0.0)); \/\/minimum distance to branchs\n\n\tfor(int i=0;i<99;i++){\n        if(dm<MIN_DIST || IDX<0.5)break;\/\/we hit the surface or ran out of tree\n\t\tif(bDone){\/\/we have already made a second attempt so bail this level\n            if(Pop(p,bLeft,bDone))bDone=true; \/\/drop down a level, quit if below trunk\n\t\t\tbUp=false; \/\/the rat is going back down\n\t\t}\n        if(!bDone){\/\/if this level is also done we keep popping\n\t\t\tif(bUp){ \/\/this is a new branch\n\t\t\t\tbLeft=(p.x<0.0); \/\/find the best direction\n\t\t\t}else{ \/\/this branch was searched once\n\t\t\t\tbLeft=!bLeft; \/\/now go the opposite direction\n        \t    bDone=true;\/\/ and mark as done\n\t\t\t}\n       \t\tbUp=true;\/\/default to going up\n\t\t\tbDone=Push(p,bLeft,bDone); \/\/move up a branch and see if we hit the end\n\t\t\tdm=min(Branch(vec3(p.xy,0.0))\/p.z,dm);\/\/save nearest length to branch for drawing\n\t\t\tif(dot(p.xy,p.xy)>BO)bDone=true;\/\/this branch is out of range so back down \n        }\n\t}\n\treturn dm;\n}\n\nvec2 Rat(vec2 uv){\n\tvec4 p=load(1);\n\tp.xy+=texture2D(iChannel1,uv).xy*0.03;\n\treturn vec2(length(uv-p.zw)-0.05,length(uv-p.xy)-0.05);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv=4.0*(fragCoord.xy\/iResolution.xy-vec2(0.5,0.4));\n\tsetup();\n\tfloat d=Tree(uv);\n\tvec2 d2=Rat(uv);\n\tvec3 col=vec3(smoothstep(0.0,0.01,d));\n\tcol=mix(vec3(0.85,0.75,0.0),col,smoothstep(0.0,0.01,d2.x));\n\tcol=mix(vec3(0.5,0.0,0.0)+texture2D(iChannel1,uv).rgb*0.5,col,smoothstep(0.0,0.01,d2.y));\n\tfragColor=vec4(col,1.0);\n}\n","name":"","description":"","type":"image"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/Citrus Rat Traversal by eiffie (rat logic)\n\n#define DEPTH 6.0\n#define MIN_DIST 0.01\n\n#define inside(a) (abs(fragCoord.y-a.y) < 0.5 && abs(fragCoord.x-a.x) < 0.5)\n#define load(a) texture2D(iChannel0,(vec2(a,0.0)+0.5)\/iResolution.xy)\n#define save(a,b) if(inside((vec2(a,0.0)+0.5))){fragColor=b;return;}\n\nfloat IDX,DONE;\/\/index and branch done bit stacks for ease\nvoid clear(){IDX=1.0;DONE=0.0;}\/\/to get a usable index number start at 1\nbool push(bool bLeft, bool bDone){\n\tIDX=IDX*2.0+(bLeft?1.0:0.0);\n\tDONE=DONE*2.0+(bDone?1.0:0.0);\n\treturn IDX>pow(2.0,DEPTH)-0.5;\n}\nbool pop(out bool bLeft, out bool bDone){\n\tIDX\/=2.0;bLeft=(fract(IDX)>0.0);IDX=floor(IDX);\n\tDONE\/=2.0;bDone=(fract(DONE)>0.0);DONE=floor(DONE);\n\treturn IDX<0.5;\n}\n\n\/\/tree config\nfloat scl1,scl2,BR,randSeed;\/\/scale, bounding radius, random seed\nmat2 mx1,mx2;\/\/rotation mats\n\nfloat rand(){return fract(sin(randSeed++)*4321.34);}\n\nvoid setup(vec4 st){\n\tscl1=st.z;scl2=st.w;\n\tBR=1.0\/(min(scl1,scl2)-1.0);\n\tmx1=mat2(cos(st.x),sin(st.x),-sin(st.x),cos(st.x));\n\tmx2=mat2(cos(st.y),sin(st.y),-sin(st.y),cos(st.y));\n}\n\nvec4 GetRandomTree(){\/\/random angles and scales\n\treturn vec4(0.1+rand(),0.1+rand(),1.25+rand(),1.25+rand());\n}\n\n\/\/do transformations with each push\/pop, this is a direct construction (scale,rot the offset)\nbool RPush(inout vec4 p, bool bLeft, bool bDone){\n\tif(bLeft){p.zw\/=scl1;p.zw=mx1*p.zw;}\n\telse {p.zw\/=scl2;p.zw=p.zw*mx2;}\n\tp.xy+=p.zw;\n\treturn push(bLeft, bDone);\n}\nbool RPop(inout vec4 p, out bool bLeft, out bool bDone){\n\tbool b=pop(bLeft, bDone);\n\tp.xy-=p.zw;\n\tif(bLeft){p.zw*=scl1;p.zw=p.zw*mx1;}\n\telse {p.zw*=scl2;p.zw=mx2*p.zw;}\n\treturn b;\n}\nvec2 GetRandomTreeNode(){\n\tvec4 p=vec4(0.0,0.0,0.0,1.0);\n\tfor(int i=0;i<int(DEPTH);i++){\n\t\tif(rand()>0.2)RPush(p,(rand()>0.5),false);\n\t}\n\treturn p.xy;\n}\nfloat Cross2(vec2 v1, vec2 v2){return v1.y*v2.x-v1.x*v2.y;}\/\/maybe backwards?\n\nvec2 Rat(vec2 p0, float tim){\n\tvec4 p=vec4(0.0,0.0,0.0,1.0);\n\tvec2 po=p.xy;\n\tclear();\n\tfloat br=BR;\/\/we have to scale the bounding radius now\n\t\n\t\/\/these three control the rats behavior\n\tbool bLeft;\/\/did the rat use the left branch?\n\tbool bDone=false;\/\/did the rat come down the wrong side? (branch exhausted)\n\tbool bUp=true;\/\/is the rat ascending?\t\n\t\n    \n\tfor(int i=0;i<99;i++){\/\/this was ripped from a non-buffered version so the whole path is rerun\n        if(float(i)>tim || IDX<0.5)break;\/\/we ran out of time or ran out of tree\n        po=p.xy;\/\/save old position\n\t\tif(bDone){\/\/we have already made a second attempt so bail this level\n            if(RPop(p,bLeft,bDone))bDone=true; \/\/drop down a level, quit if at trunk\n            br*=min(scl1,scl2);\n\t\t\tbUp=false; \/\/the rat is going back down\n\t\t}\n        if(!bDone){\/\/if this level is also done keep popping\n            po=p.xy;\n\t\t\tif(bUp){ \/\/this is a new branch\n\t\t\t\tbLeft=(Cross2(p.zw,p0-p.xy)<0.0); \/\/find the best direction\n\t\t\t}else{ \/\/this branch was searched once\n\t\t\t\tbLeft=!bLeft; \/\/now go the opposite direction\n        \t    bDone=true;\/\/ and mark as done\n\t\t\t}\n       \t\tbUp=true;\/\/default to going up\n\t\t\tbDone=RPush(p,bLeft,bDone); \/\/move up a branch and see if we hit the end\n\t\t\tbr\/=min(scl1,scl2);\n\t\t\tfloat d=length(p0-p.xy);\/\/get length to node\n\t\t\tif(d>br)bDone=true;\/\/this branch is out of range so back down \n        }\n\t}\n\treturn mix(po,p.xy,fract(tim));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tif(fragCoord.y>1.0 || fragCoord.x>3.0)discard;\n\tvec2 po=vec2(1.0);\n\tvec4 st=vec4(1.0,iGlobalTime,0.0,0.0); \/\/state of rat, x=found,starttime\n\tvec4 ts=vec4(0.0);\n\tif(iFrame>0){\n\t\tts=load(0);\n\t\tpo=load(1).zw;\n\t\tst=load(2);\n\t}\n\tsetup(ts);\n\tif(st.x>0.0){\n\t\tst.x=0.0;\n\t\tst.y=iGlobalTime;\n\t\trandSeed=fract(iGlobalTime+iDate.w);\n\t\tts=GetRandomTree();\n\t\tsetup(ts);\n\t\tpo=GetRandomTreeNode();\n\t}\n\tvec2 p=Rat(po,(iGlobalTime-st.y)*2.0);\n\tif(length(p-po)<0.1){\/\/the rat found the orange so new tree\n\t\tst.x=1.0;\n\t}\n\tsave(0,ts);\/\/tree state\n\tsave(1,vec4(p,po));\/\/position of rat, orange\n\tsave(2,st);\/\/demo state\n}\n","name":"","description":"","type":"buffer"}]}}