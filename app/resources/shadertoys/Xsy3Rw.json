{"Shader":{"ver":"0.1","info":{"id":"Xsy3Rw","date":"1453623025","viewed":90,"name":"othello \/ reversi - computers","username":"FabriceNeyret2","description":"computer against computer. Not pretending to play well ! :-)","likes":4,"published":3,"flags":32,"tags":["game","othello","reversi"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define DEBUG 0\n\n#define text(U)  texture2D(iChannel0, (U)\/iResolution.xy)\n\nvoid mainImage( out vec4 O, vec2 U )\n{       \n    O-=O;\n#if DEBUG\n    O = text(.1*U)\/2.;  \/\/ debug display\n    if (length(O.rg)>=1.) return; \n#endif\n    \n\tvec2 R = iResolution.xy;\n    U = (U+U-R)\/R.y;\n    O += smoothstep(.4,.35,length(4.*U-vec2(-5.5,0)))*(text(vec2(.5,9.5)).x*2.-3.); \/\/ actor\n    if (abs(U.x)>1.) { O+=.5; return; }                 \/\/ out of board    \n    \n    vec2 P = floor(4.+4.*U);                            \/\/ curr cell\n    if (P==text(vec2(.5,8.5)).rg) \n         O.r++;                                         \/\/ mark play position\n    else O.g=.5;                                        \/\/ default cell color\n    \n    float v = text(P+.5).x;                                     \/\/ pawn value\n    U = fract(U*4.+.05);                                        \/\/ cell coordinates\n    if (v>0.) O += smoothstep(.4,.35,length(U-.55))*(v+v-3.);   \/\/ draw pawn\n    if (min(U.x,U.y)<.07) O-=O;                                 \/\/ lines between cells\n}","name":"","description":"","type":"image"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define INIT_BOARD 0 \/\/ 0: classical  1: random\n\nfloat ME = 2.; \/\/ current color played 1: black 2: white\n    \n#define cell(P,d) texture2D(iChannel0, ( P + 8.*(d) +.5) \/ iResolution.xy)\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U -= .5; \/\/ integer pixel position\n    \n    if (iFrame==0) {                      \/\/ --- init ------\n        O-=O;\n        if (max(U.x,U.y)<8.) {            \/\/ board data\n            float t=fract(iDate.w);\n#if INIT_BOARD   \/\/ start with a random board\n            O.x = floor(3.*fract(1e4*sin(dot(U+t,vec2(71.17,13.13))))); \/\/ 0,1,2\n#else            \/\/ classical start board\n            if (min(U.x,U.y)>=3.&&max(U.x,U.y)<=4.) O.x = 1.+mod(U.x+U.y,2.);\n#endif\n            O.a = fract(1e4*sin(dot(U+t,vec2(7.17,91.13))));  \/\/ to help choice :-)\n        }\n        return;\n    }\n     \n    O = cell(U, 0.);    \/\/ for persistancy of all states\n\tME = 1.+mod(float((iFrame-1)\/60),2.); \/\/ switch player\n    if (U==vec2(0,9)) O.x=ME;\n        \n    if (U==vec2(0,8)) {           \n        float M=0.; vec2 pM=vec2(-1);    \/\/ --- find the place of maximum score ----\n        for (int j=0; j<8; j++)    \/\/ <><><> should time-serialize these loops as well\n            for (int i=0; i<8; i++) { \n                float v = cell(vec2(i,j), 2.).x;                   \/\/ #pawn taken if play(i,j)\n                \/\/ enrich strategy by modifying weight here\n                if (v>0.) v += cell(vec2(i,j), 0.).a;              \/\/ rand to prevent cases of equality\n                if (v>0. && (i==0||i==7) && (j==0||j==7) ) v+=8.;  \/\/ border bonus\n                if (v>M) {  M = v; pM=vec2(i,j); }                 \/\/ best for now\n            }\n        O.rg = pM; \/\/ store coordinates\n        return;\n    }\n    \n    vec2 d = floor(U\/8.)-2.; U = mod(U,8.);        \/\/ memory page, cell index in page\n\t\/\/ page 0.x:    board\n    \/\/ page 2+dir: .y: number of taken pawn in this direction .x: tmp pawn index in line\n    \/\/ page 2.x:    total number of taken pawn (for each play position)\n    \/\/ (0,8): best location to play\n    \/\/ (0,9): current player\n    \/\/ (shown with DEBUG=1 in Image shader)\n    \n    if (mod(float(iFrame),60.)==0.) {  \/\/ triggers play every 60 frames\n        \n        if (d==vec2(-2)) {                                \/\/ --- do the play ---------\n            vec2 p0 = cell(vec2(0,8),0.).rg;              \/\/ best location to play\n            if (p0==vec2(-1)) return;             \/\/ can't play\n            for (int j=-1; j<2; j++)              \/\/ check what's taken in each direction\n                for (int i=-1; i<2; i++) {\n                    float l = cell(p0, vec2(i,j)+2.).y; if (l==0.) continue; \/\/ #pawns in dir(i,j)\n                    vec2 dp = vec2(i,j)*l, p1 = p0+dp;    \/\/ twin attackant location\n                    if (length(clamp( dot(U-p0,dp)\/dot(dp,dp), .0,1.) *dp - (U-p0)) < 1e-1) \n                        O.x = ME;               \/\/ eaten line of pawns\n                } \n        }  \n        else O-=O;                               \/\/ reset all states\n        return;\n    }\n    \n    if (max(abs(d.x),abs(d.y))>1.) return;      \/\/ not in a compute page\n    \n    if (d==vec2(0)) {                           \/\/ --- combine directional scores --------\n        O.x=0.;\n        for (int j=-1; j<2; j++)\n            for (int i=-1; i<2; i++)\n                if (i!=0 || j!=0) O.x += cell(U,vec2(i,j)+2.).y;\n        O.g = 2.*float(U==cell(vec2(0,8),0.).rg);  \/\/ draw location of max (debug)\n        return;\n    }\n    \n    O.b=.5+2.*mod(d.x+d.y+2.,2.);   \/\/ checkboard for debug     \n    \n                               \/\/ --- find all playable position and their score ---------\n                               \/\/ (time-serialized loops)\n    vec2 P = U+d;                                    \/\/ neighbor cell in direction d\n    if (min(P.x,P.y)<0. || max(P.x,P.y)>7.) return;  \/\/ is out of board\n    \n    float v = cell(U, 0.).x;                   \/\/ cell content in board page \n    if (v==3.-ME)                              \/\/ current cell is target color\n        if ( cell(P,0.).x == ME ) O.x = 1.;    \/\/ neighbor in direction p is me: mark cur cell \"eatable in dir d\".\n        else { float c = cell(P, d+2.).x;      \/\/ recursion to neighbor mark\n               if (c>0.) O.x = c+1.;\n             }\n    else if (v == 0.)                          \/\/  current cell is free\n        O.y = cell(P, d+2.).x;                 \/\/ #N pawn takable in direction d \n}","name":"","description":"","type":"buffer"}]}}