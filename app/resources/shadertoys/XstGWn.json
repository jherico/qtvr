{"Shader":{"ver":"0.1","info":{"id":"XstGWn","date":"1450034382","viewed":360,"name":"River Styx","username":"Dave_Hoskins","description":"River Styx. With cheap varying fractal lacunarity & some illuminated fog patches.<br\/>","likes":18,"published":3,"flags":64,"tags":["3d","raymarching","fog","cave","soundcloud","styx"],"hasliked":0},"renderpass":[{"inputs":[{"id":24,"src":"\/presets\/cube02_0.jpg","ctype":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":47,"src":"\/presets\/tex19.png","ctype":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":433,"src":"https:\/\/soundcloud.com\/adrian-dulu\/01-aphex-twin-xtal","ctype":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ River Styx\n\/\/ David Hoskins.\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ https:\/\/www.shadertoy.com\/view\/XstGWn\n\n\n#define MOD3 vec3(.1031,.11369,.13787)\nvec3 sunDir  = normalize( vec3(  .4, 0.4,  .48 ) );\nconst vec3 sunColour = vec3(1., 1., .6);\nconst vec2 add = vec2(.0, 1.0);\n\nvec3 lightPos;\nfloat gTime;\nfloat fogAmount;\nfloat fogShine;\n\n\n\/\/----------------------------------------------------------------------------------------\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ Neat huh? Not mine though...\nvec2 rot2D(inout vec2 p, float a)\n{\n    return cos(a)*p - sin(a) * vec2(p.y, -p.x);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ Where the boat is going + light...\nvec3 path(float z)\n{\n    vec3 p = vec3(cos((z *.005))*140.0, 90., z);\n    return p;\n}\n\n\/\/----------------------------------------------------------------------------------------\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D( iChannel0, (uv+ 0.5)\/256.0, -99.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\n\/\/----------------------------------------------------------------------------------------\nconst mat3 m = mat3( 0.01,  0.8,  0.6,\n                    -0.80,  0.1, -0.44,\n                    -0.50, -0.28,  0.63 );\nfloat fbm(in vec3 p)\n{\n    float f = 0.0;\n    p *= 0.005;\n \n    float a = 1.; \n    for (int i= 0; i < 4; i++)\n    {\n\t\tf += a*noise( p);\n        p = p*m*(textureCube(iChannel1, p).xzy+1.3);\n        a = a*.5;\n    }\n    return f;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat fogIntensity(vec3 p)\n{\n    p*= .012;\n    \n\tfloat f = max(noise(p)+noise(p*2.3)*.5-.3, 0.0);\n    return clamp(f*f+(.2-p.y*.1)*.2, 0.0, 1.0);\n}\n\/\/----------------------------------------------------------------------------------------\nfloat mapDE(vec3 p)\n{\n    float disp = fbm(p) * 600.0;\n    disp =   900.+p.y*.5 - disp - length((path(p.z)-p));\n    return min(disp, p.y-10.0);\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat binarySubdivision(in vec3 rO, in vec3 rD, vec2 t)\n{\n\t\/\/ Home in on the surface by dividing by two and split...\n    float halfwayT;\n\tfor (int n = 0; n < 6; n++)\n\t{\n\t\thalfwayT = (t.x + t.y) * .5;\n        (mapDE(rO + halfwayT*rD) < 0.) ? t.x = halfwayT:t.y = halfwayT;\n\t}\n\treturn t.y;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat rayMarch(inout vec3 pos, inout vec3 dir, vec2 uv)\n{\n    float d =  hash12(uv)*20., de = 0.0, od = 0.0;\n    float di = 2000.0;\n    if(dir.y < 0.0)\n    \tdi = (-pos.y+10.) \/ dir.y;\n    fogAmount = 0.0;\n    fogShine = 0.0;\n    \n    for (int i = 0; i < 200; i++)\n    {\n        \n        vec3 p = pos + dir * d;\n        \n        de = mapDE(p);\n        if(de < 0. || d > 1700.0) break;\n        float f = fogIntensity(p)*.05;\n\t\tfogShine += f * (1.-clamp((.003 * length(lightPos-p)), 0.0, 1.0));\n        fogAmount += f + 0.005;\n        \n        od = d;\n\t\td += max(.02+d*.02, 0.12*de);\n\n    }\n\tif (d < 1700.0)\n        d = binarySubdivision(pos, dir, vec2(d, od));\n    fogAmount = clamp(fogAmount, 0.0, 1.0);\n    fogShine = clamp(fogShine, 0.0, 1.0);\n    \n    return d;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 getSky(in vec3 rd)\n{\n\n    float horizon = pow(1.0-max(rd.y, 0.0), 2.2)*.06;\n\tvec3  sky = vec3(.0, .0, .07);\n\tsky = mix(sky, vec3(sunColour), horizon);\n\treturn min(sky, 1.0);\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 normal( in vec3 pos, in float d )\n{\n\tvec2 eps = vec2( .001+d*.01, 0.0);\n\tvec3 nor = vec3(\n\t    mapDE(pos+eps.xyy) - mapDE(pos-eps.xyy),\n\t    mapDE(pos+eps.yxy) - mapDE(pos-eps.yxy),\n\t    mapDE(pos+eps.yyx) - mapDE(pos-eps.yyx)\n    );\n\treturn normalize(nor);\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 texCube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec3 x = texture2D( sam, p.yz ).xyz*vec3(.3, .5, .3);\n\tvec3 y = texture2D( sam, p.zx ).xyz*vec3(.0, .3 , .8);\n\tvec3 z = texture2D( sam, p.xy ).xyz;\n\treturn (x*abs(n.x) + y*abs(n.y) + z*abs(n.z))\/(abs(n.x)+abs(n.y)+abs(n.z));\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat shadow(in vec3 ro, in vec3 rd, float dist)\n{\n\tfloat res = 1.0;\n    float t = .03;\n\tfloat h = 0.0;\n    \n\tfor (int i = 0; i < 12; i++)\n\t{\n\t\t\/\/ Don't run past the point light source...\n\t\tif(t < dist)\n\t\t{\n\t\t\th = mapDE(ro + rd * t);\n\t\t\tres = min(2.*h \/ t, res);\n\t\t\tt += max(.01, h);\n\t\t}\n\t}\n    return clamp(res, 0.2, 1.0);\n}\n\n\n\n\/\/----------------------------------------------------------------------------------------\nfloat lightGlow(vec3 light, vec3 ray, float t)\n{\n\tfloat ret = 0.0;\n\tif (length(light) <= t+30.0)\n\t{\n\t\tlight = normalize(light);\n\t\tret = pow(max(dot(light, ray), 0.0), 1000.0)*.5;\n        \n\t\tfloat a = atan(light.x-ray.x, light.y-ray.y);\n\t\tret = (1.0+(sin(a*10.0-iGlobalTime*4.3)+sin(a*13.141+iGlobalTime*3.141)))*(sqrt(ret))*.05+ret;\n\t\tret *= 2.;\n\t}\n\t\t\n\treturn ret;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 outColour, in vec2 coords )\n{\n\tvec2 uv = ((coords.xy \/ iResolution.xy)-.5)*vec2( iResolution.x \/ iResolution.y, 1);\n    gTime = iGlobalTime*40.0+iMouse.x*3.0+23600.;\n\n    vec3 pos = path(gTime);\n    \/\/ Bob camera...\n    pos.y += sin(gTime*.02+1.2)*20.0;\n    \n    \/\/ Look at target...\n    vec3 tar = path(gTime+30.);\n    vec3 dir =  (pos-tar);\n\n    \/\/ Position light ahead of camera...\n   \tlightPos = path(gTime+860.0-850.0*cos(gTime*.003+2.5));   \n    lightPos.y += 55.+45.*sin(gTime*.01-2.4);\n\n    \n    float a = atan(dir.x, dir.z);\n    \n    \/\/ Do camera without flat projection...\n    dir = vec3(0.0, 0., -1.0);\n    uv.xy = rot2D(uv.xy, sin(gTime*.01)*.1);\n    dir.yz = rot2D(dir.yz, uv.y*1.3+.2);\n    dir.xz = rot2D(dir.xz, uv.x*1.3-a);\n    \n    vec3 col = vec3(0);\n    float d = rayMarch(pos, dir, coords);\n    \n    vec3 sky = getSky(dir);\n    if (d < 1700.0)\n    {\n        float specAmount = 1.;\n        vec3  loc = pos+dir*d;\n    \tsunDir = normalize(lightPos-loc);    \n        vec3  nor = normal(loc, d);\n        \n        float sha  = shadow(loc + nor*.01, sunDir, length(lightPos-loc));\n        vec3  dif = texCube(iChannel3, loc*.007, nor);\n        vec2 off = vec2(0.0, -gTime*.002);\n        vec3 amb = vec3(0.0);\n        if (loc.y < 10.18)\n        {\n            dif = vec3(1.,0.0,0.0);\n            nor.xz += texture2D(iChannel0, loc.xz*.0005+gTime*.0002).xy*.2-.1;\n           \tnor.xz += texture2D(iChannel3, -loc.xz*.004+off).xy*.8-.4 ;\n          \tnor = normalize(nor);\n            specAmount=3.;\n            amb = vec3(.08, .0, .0);\n        }\n\t\tvec3  ref = reflect(dir, nor);\n        \n        col = dif * max(dot(sunDir, nor)*.7, 0.0)*sha;\n        \n        float spe = pow(max(dot(sunDir, ref), 0.0), 7.)*texCube(iChannel3, loc*.007, nor).y*specAmount;\n        float bri = texture2D(iChannel3, -loc.xz*.005+off).x;\n        amb += max(-nor.y, 0.0)*vec3(.06, .0, .0)*bri;\/\/+getSky(nor)*.2;\n\t    col += sunColour*spe*sha+amb;\n        col = mix(sky, col, exp(-d*.0005));\n\n    }else\n        col = sky;\n    \n    \n    col += lightGlow(lightPos-pos, dir, d)*sunColour;\n    col += sunColour * fogShine;\n    col += mix(col, sky, fogAmount*1.1);\n\tcol = clamp(col, 0.0, 1.0);\n    col = col*col*(3.0-2.0*col);\n    \n\toutColour = vec4(sqrt(col),1.0);\n}","name":"","description":"","type":"image"}]}}