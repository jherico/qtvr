{"Shader":{"ver":"0.1","info":{"id":"XtlXD8","date":"1436381028","viewed":780,"name":"Circle AA","username":"W_Master","description":"Click to change position","likes":1,"published":3,"flags":0,"tags":["2d","circle"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define PI 3.1415926535897932384626433832795\n\nvec3 color_bg = vec3(0.2,0.3,0.4);\n\nvec3 color_circle = vec3(1.0,1.0,0.0);\n\nvec3 color_guide = vec3(1.0,0.0,0.0);\n\n\/\/ Rounded detail (threshold 0.2%)\n\/\/ Radius\n\/\/ 0  - 15   = should enable\n\/\/ 15 - 112  = hardly visible, only for perfectionists.. like myself (probably need double precision anyway)\n\/\/      112+ = should disable\n\n\/\/ Comment next line to disable\n#define ROUNDED_DETAIL\n\nfloat radius = 10.0;\n\nfloat pixelSize = 15.0;\n\nbool viewGuide = true;\n\n\nvec2 toPixel(vec2 coord)\n{\n    coord -= vec2(0.5,0.5);\n    coord \/= pixelSize;\n    return vec2(floor(coord.x) + 0.5, floor(coord.y) + 0.5);\n}\n\nfloat getVolume(vec2 localPos, float radius)\n{\n    localPos = abs(localPos);\n    \n    vec2 maxPos = localPos + vec2(0.5);\n    \n    float rr2 = radius * radius;\n    \n    if( dot(maxPos, maxPos) <= rr2)\n    {\n        return 1.0;\n    }\n    \n    vec2 minPos = localPos - vec2(0.5);\n    if( dot(minPos, minPos) >= rr2)\n    {\n        #ifdef ROUNDED_DETAIL\n        if(min(maxPos.x,maxPos.y) < 1.0) \/\/ the 4 pixels aligned to circle origin (possible hit 'n run a pixel)\n        {\n            float passDis = radius - max(minPos.x, minPos.y);\n\t\t\tif( passDis > 0.0 )\n            {\n                if(passDis > radius * 2.0) \/\/ circle totaly contained in pixel\n                {\n                    return rr2 * PI;\n                }\n                \/\/ flooding the circle area\n                if( passDis > radius ) \/\/ top half of circle\n                {\n                    float pC = passDis - radius;\n                    \n                    return rr2 * ( PI - acos(pC \/ radius)) +\n                        (pC * sqrt(rr2 - pC*pC));\n\t\t\t\t\t\n                }\n                else \/\/bottom half\n                {\n                    return (rr2 * acos(1.0 - passDis \/ radius))\n                        - ((radius - passDis) * sqrt(2.0 * radius * passDis - passDis * passDis));\n                } \n            }\n        }\n        #endif\n        \n        return 0.0;\n    }\n    \n    vec2 pA, pB;\n    \/\/ pA\n    if( sqrt(radius * radius - minPos.x * minPos.x) > maxPos.y)\n    {\n        pA = vec2(sqrt(rr2 - maxPos.y * maxPos.y) , maxPos.y);\n    }\n    else\n    {\n        pA = vec2(minPos.x, sqrt(rr2 - minPos.x * minPos.x));\n    }\n    \/\/pB\n    if( sqrt(radius * radius - minPos.y * minPos.y) > maxPos.x)\n    {\n        pB = vec2( maxPos.x, sqrt(rr2 - maxPos.x * maxPos.x));\n    }\n    else\n    {\n        pB = vec2( sqrt(rr2 - minPos.y * minPos.y), minPos.y);\n    }\n    \n    vec2 block = abs(pB-pA);\n    float areaTri = (block.x * block.y) \/ 2.0;\n    \n    float areaBoxWidth = min(pA.x, pB.x) - minPos.x;\n    float areaBoxHeight = min(pA.y, pB.y) - minPos.y;\n    \n    float areaBoxOverlap = areaBoxWidth * areaBoxHeight;\n    \n    float areaTotal = areaTri + areaBoxWidth + areaBoxHeight - areaBoxOverlap;\n    \n    \/\/ Rounded circle part detail (threshold 0.2% of circle, means excludes every pixel from radius 112.54)\n    #ifdef ROUNDED_DETAIL\n    float circleFactor = acos(dot(pA,pB) \/ (length(pA)*length(pB))) \/ (PI * 2.0);\n    if(circleFactor >= 0.002)\n    {\n        float areaCircle = circleFactor * (radius * radius * PI);\n\n        vec2 midPoint = (pA+pB) \/ 2.0;\n        areaCircle -= length(midPoint) * length(pA-pB) \/ 2.0;\n        \n        areaTotal += max(0.0, areaCircle);\n    }\n    #endif\n    \n    return areaTotal;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 circleLocation = iMouse.xy;\n    \n    \/\/ Circle rotate movement\n    \/*\n    float rotateSpeed = 0.1;\n    circleLocation += vec2(sin(iGlobalTime * rotateSpeed), cos(iGlobalTime * rotateSpeed)) * radius * pixelSize;\n\t*\/\n    \n    if(viewGuide)\n    {\n        float ring = getVolume(fragCoord.xy - circleLocation, radius*pixelSize);\n\n        if(ring != 1.0 && ring != 0.0)\n        {\n            fragColor = vec4(color_guide,1.0);\n            return;\n        }\n    }\n    \n    float volume = getVolume(toPixel(fragCoord.xy)- circleLocation \/ pixelSize, radius);\n    \n    vec3 finalColor = mix(color_bg, color_circle, volume);\n    \n\tfragColor = vec4(finalColor,1.0);\n}","name":"","description":"","type":"image"}]}}