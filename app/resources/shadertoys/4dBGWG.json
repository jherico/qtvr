{"Shader":{"ver":"0.1","info":{"id":"4dBGWG","date":"1392583078","viewed":418,"name":"Rotoscoping","username":"4rknova","description":"Simple rotoscoping.<br\/>Use the mouse to position the divider and compare the input with the output.","likes":2,"published":3,"flags":0,"tags":["rotoscoping"],"hasliked":0},"renderpass":[{"inputs":[{"id":36,"src":"\/presets\/vid03.webm","ctype":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ by Nikos Papadopoulos, 4rknova \/ 2014\n\/\/ Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ The layers\n\/\/#define ENABLE_EDGES\n#define ENABLE_COLOR\n#define ENABLE_QUANTIZATION\n\n#define EDGE_COEF         7.\n#define QUANTIZATION_FULL 6.\n#define QUANTIZATION_LOW  1.2\n\nvec3 sample(vec2 uv, float mul)\n{\n\treturn texture2D(iChannel0, uv).xyz * mul;\n}\n\nfloat rlum(vec3 col)\n{\n\treturn dot(col, vec3(.2126, .7152, .0722));\n}\n\nvec3 denoise(inout vec2 uv, float mul)\n{\n\tconst float rads = 256., val0 = 1., val1 = .125;\n    float dx, dy;\n\n\tvec3 acc = vec3(0);\n\n\tfor (int i = 1; i < 16; ++i)\n  \t{\n    \tdx = dy = 1. \/ rads;\n    \tacc += sample(uv + vec2(-dx, -dy), mul) * val1;\n    \tacc += sample(uv + vec2( 0., -dy), mul) * val1;\n    \tacc += sample(uv + vec2(-dx,  0.), mul) * val1;\n    \tacc += sample(uv + vec2( dx,  0.), mul) * val1;\n    \tacc += sample(uv + vec2( 0.,  dy), mul) * val1;\n    \tacc += sample(uv + vec2( dx,  dy), mul) * val1;\n    \tacc += sample(uv + vec2(-dx,  dy), mul) * val1;\n    \tacc += sample(uv + vec2( dx, -dy), mul) * val1;\n  \t}\n\t\n  \treturn acc \/ 16.;\n}\n\nvec3 rotoscope_full(vec2 uv)\n{\n\tvec3 cl = denoise(uv, 3.5) \/ QUANTIZATION_FULL;\n\t\n\t\/\/ Quantize\n\tvec3 rc = vec3(0);\n\tfloat lm = rlum(cl);\n\tfor (int l = 1; l <= int(QUANTIZATION_FULL); ++l) {\n\t\tfloat coef = 1. \/ float(l);\n\t\tif (lm > coef){\n\t\t\trc += coef;\n\t\t}\n\t}\n\t\n\treturn rc;\n}\n\nvec3 rotoscope_low(vec2 uv)\n{\n\tvec3 cl = denoise(uv, 3.5) \/ QUANTIZATION_LOW;\n\t\n\t\/\/ Quantize\n\tvec3 rc = vec3(0);\n\tfloat lm = rlum(cl);\n\tfor (int l = 1; l <= int(QUANTIZATION_LOW); ++l) {\n\t\tfloat coef = 1. \/ float(l);\n\t\tif (lm > coef){\n\t\t\trc += coef;\n\t\t}\n\t}\n\t\n\treturn rc;\n}\n\n\nfloat edge(vec2 uv)\n{\n\tconst float d = 1. \/ 768.;\n\t\n\tvec3 hc =rotoscope_low(uv + vec2(-d,-d)) *  1. + rotoscope_low(uv + vec2( 0,-d)) *  2.\n\t\t \t+rotoscope_low(uv + vec2( d,-d)) *  1. + rotoscope_low(uv + vec2(-d, d)) * -1.\n\t\t \t+rotoscope_low(uv + vec2( 0, d)) * -2. + rotoscope_low(uv + vec2( d, d)) * -1.;\n\t\t\n\tvec3 vc =rotoscope_low(uv + vec2(-d,-d)) *  1. + rotoscope_low(uv + vec2(-d, 0)) *  2.\n\t\t \t+rotoscope_low(uv + vec2(-d, d)) *  1. + rotoscope_low(uv + vec2( d,-d)) * -1.\n\t\t \t+rotoscope_low(uv + vec2( d, 0)) * -2. + rotoscope_low(uv + vec2( d, d)) * -1.;\n\t\n\treturn rlum(vc*vc + hc*hc) \/ EDGE_COEF;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\tvec3 ns = sample(uv, 1.);\n\n#ifdef ENABLE_QUANTIZATION\n\tvec3 cl = rotoscope_full(uv);\n#else \t\n\tvec3 cl = vec3(1);\n#endif\n\n\tfloat m = iMouse.x \/ iResolution.x ;\n\t\n#ifdef ENABLE_EDGES\n\tfloat e = edge(uv);\n\tcl -= vec3(e < .5 ? e : 1.) \/ float(QUANTIZATION_FULL);\n#endif\n\t\n#ifdef ENABLE_COLOR\n\tcl *= ns;\n#endif\t\n\t\n\tvec3  frs = vec3(\n\t\t  (uv.x  < m ? ns : cl)    \/\/ Mix the 2 channels\n\t\t* smoothstep(0., 1. \/ iResolution.y, abs(m - uv.x))\n\t);\n\t\n\tfragColor = vec4(frs, 1);\n}","name":"","description":"","type":"image"}]}}