{"Shader":{"ver":"0.1","info":{"id":"Msf3z4","date":"1366212974","viewed":2530,"name":"Reprojection II","username":"P_Malin","description":"Projecting a cubemap texture onto a 3d scene. Click in window to see the grid over the 3d scene.<br\/>The cubemap texture is sampled to generate a bumpmap and the blurry cubemap is used as a reflection.","likes":61,"published":3,"flags":0,"tags":["cubemap","raytrace","projection"],"hasliked":0},"renderpass":[{"inputs":[{"id":22,"src":"\/presets\/cube00_0.jpg","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"id":23,"src":"\/presets\/cube01_0.png","ctype":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Reprojection II - @P_Malin\n\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define FORCE_SHADOW\n#define ENABLE_REFLECTION\n\nstruct C_Ray\n{\n    vec3 vOrigin;\n    vec3 vDir;\n};\n\t\n#define kMaxDist 1000.0\n#define kEpsilon 0.0001\n\t\nvoid TraceSlab(const in C_Ray ray, const in vec3 vMin, const in vec3 vMax, const in vec3 vNormal, inout float fNear, inout float fFar)\n{\n\tvec3 vMinOffset = vMin - ray.vOrigin;\n\tvec3 vMaxOffset = vMax - ray.vOrigin;\n\n\t\/\/ Project offset and dir\n\tfloat fMinOffset = dot(vMinOffset, vNormal);\t\n\tfloat fMaxOffset = dot(vMaxOffset, vNormal);\t\n\t\n\tfloat fDir = dot(ray.vDir, vNormal);\n\t\t\n\tif(abs(fDir) < kEpsilon)\n\t{\n\t\t\/\/ ray parallel to slab\n\t\t\n\t\t\/\/if origin is not between slabs return false;\n\t\tif((fMinOffset > 0.0) || (fMaxOffset < 0.0))\n\t\t{\n\t\t\tfNear = kMaxDist;\n\t\t\tfFar = -kMaxDist;\n\t\t}\n\t\t\n\t\t\/\/ else this slab does not influence the result\n\t}\n\telse\n\t{\n\t\t\/\/ ray is not parallel to slab, calculate intersections\n\t\t\n\t\tfloat t0 = (fMinOffset) \/ fDir;\n\t\tfloat t1 = (fMaxOffset) \/ fDir;\n\t\t\n\t\tfloat fIntersectNear = min(t0, t1);\n\t\tfloat fIntersectFar = max(t0, t1);\n\t\t\n\t\tfNear = max(fNear, fIntersectNear); \/\/ track largest near\n\t\tfFar = min(fFar, fIntersectFar); \/\/ track smallest far\n\t}\n}\n\t\nfloat TraceBox( const in C_Ray ray, const in vec3 vCorner1, const in vec3 vCorner2 )\n{\n\tvec3 vMin = min(vCorner1, vCorner2);\n\tvec3 vMax = max(vCorner1, vCorner2);\n\t\n\tfloat fNear = -kMaxDist;\n\tfloat fFar = kMaxDist;\n\t\n\tTraceSlab(ray, vMin, vMax, vec3(1.0, 0.0, 0.0), fNear, fFar);\n\tTraceSlab(ray, vMin, vMax, vec3(0.0, 1.0, 0.0), fNear, fFar);\n\tTraceSlab(ray, vMin, vMax, vec3(0.0, 0.0, 1.0), fNear, fFar);\n\t\n\tif(fNear > fFar)\n\t{\n\t\treturn kMaxDist;\n\t}\n\t\n\tif(fFar < 0.0)\n\t{\n\t\treturn kMaxDist;\n\t}\n\t\n\treturn fNear;\n}\n\nvec3 Project( vec3 a, vec3 b )\n{\n\treturn a - b * dot(a, b);\n}\n\nfloat TraceCylinder( const in C_Ray ray, vec3 vPos, vec3 vDir, float fRadius, float fLength )\n{\t\n\tvec3 vOffset = vPos - ray.vOrigin;\n\t\n\tvec3 vProjOffset = Project(vOffset, vDir);\n\tvec3 vProjDir = Project(ray.vDir, vDir);\n\tfloat fProjScale = length(vProjDir);\n\tvProjDir \/= fProjScale;\n\t\n\t\/\/ intersect circle in projected space\n\t\n\tfloat fTClosest = dot(vProjOffset, vProjDir);\n\t\n\tvec3 vClosest = vProjDir * fTClosest;\n\tfloat fDistClosest = length(vClosest - vProjOffset);\n\tif(fDistClosest > fRadius)\n\t{\n\t\treturn kMaxDist;\n\t}\n\tfloat fHalfChordLength = sqrt(fRadius * fRadius - fDistClosest * fDistClosest);\n\tfloat fTIntersectMin = (fTClosest - fHalfChordLength) \/ fProjScale;\n\tfloat fTIntersectMax = (fTClosest + fHalfChordLength) \/ fProjScale;\n\t\n\t\/\/ cap cylinder ends\n\tTraceSlab(ray, vPos, vPos + vDir * fLength, vDir, fTIntersectMin, fTIntersectMax);\n\n\tif(fTIntersectMin > fTIntersectMax)\n\t{\n\t\treturn kMaxDist;\n\t}\n\t\n\tif(fTIntersectMin < 0.0)\n\t{\n\t\treturn kMaxDist;\n\t}\n\t\n\treturn fTIntersectMin;\t\t\n}\n\t\t\t   \n\nfloat TraceFloor( const in C_Ray ray, const in float fHeight )\n{\n\tif(ray.vOrigin.y < fHeight)\n\t{\n\t\treturn 0.0;\n\t}\n\t\n\tif(ray.vDir.y > 0.0)\n\t{\n\t\treturn kMaxDist;\n\t}\n\t\n\tfloat t = (fHeight - ray.vOrigin.y) \/ ray.vDir.y;\n\t\n\treturn max(t, 0.0);\n}\n\nfloat TracePillar( const in C_Ray ray, in vec3 vPos )\n{\n\tvPos.y = -1.0;\n\tfloat fRadius = 0.3;\n\tfloat fDistance = TraceCylinder( ray, vPos, vec3(0.0, 1.0, 0.0), fRadius, 10.0);\n\tfloat fBaseSize = 0.4;\n\t\n\tvec3 vBaseMin = vec3(-fBaseSize, 0.0, -fBaseSize);\n\tvec3 vBaseMax = vec3(fBaseSize, 0.8, fBaseSize);\n\tfDistance = min( fDistance, TraceBox( ray, vPos + vBaseMin, vPos + vBaseMax) );\n\t\n\tfloat fTopSize = 0.4;\n\tvec3 vTopMin = vec3(-fTopSize, 5.6, -fTopSize);\n\tvec3 vTopMax = vec3(fTopSize, 7.0, fTopSize);\n\tfDistance = min( fDistance, TraceBox( ray, vPos + vTopMin, vPos + vTopMax) );\n\t\n\treturn fDistance;\t\n}\n\nfloat TraceColumn( const in C_Ray ray, vec3 vPos )\n{\n\tvec3 vColumnMin = vec3(-0.84, -10.0, -0.4);\n\tvec3 vColumnMax = - vColumnMin;\n\treturn TraceBox( ray, vPos + vColumnMin, vPos + vColumnMax );\t\n}\n\nfloat fBuildingMin = -90.0;\nfloat fBuildingMax = 50.0;\n\nfloat TraceBuildingSide( const in C_Ray ray )\n{\n\tfloat fDistance = kMaxDist;\n\t\n\tfloat fStepHeight = 0.14;\n\tfloat fStepDepth = 0.2;\n\tfloat fStepStart = 7.5;\n\tfDistance = min(fDistance, TraceBox( ray, vec3(fBuildingMin, -1.5 + fStepHeight * 0.0, fStepStart + fStepDepth * 0.0), vec3(fBuildingMax, -1.5 + fStepHeight * 1.0, fStepStart + 20.0) ));\n\tfDistance = min(fDistance, TraceBox( ray, vec3(fBuildingMin, -1.5 + fStepHeight * 1.0, fStepStart + fStepDepth * 1.0), vec3(fBuildingMax, -1.5 + fStepHeight * 2.0, fStepStart + 20.0) ));\n\tfDistance = min(fDistance, TraceBox( ray, vec3(fBuildingMin, -1.5 + fStepHeight * 2.0, fStepStart + fStepDepth * 2.0), vec3(fBuildingMax, -1.5 + fStepHeight * 3.0, fStepStart + 20.0) ));\n\tfDistance = min(fDistance, TraceBox( ray, vec3(fBuildingMin, -1.5 + fStepHeight * 3.0, fStepStart + fStepDepth * 3.0), vec3(fBuildingMax, -1.5 + fStepHeight * 4.0, fStepStart + 20.0) ));\n\n\tfloat x = -2.0;\n\tfor(int i=0; i<5; i++)\n\t{\n\t\tvec3 vBase = vec3(x * 11.6, 0.0, 0.0);\n\t\tx += 1.0;\n\t\t\n\t\tfDistance = min(fDistance, TraceColumn(ray, vBase + vec3(0.0, 0.0, 8.5)));\n\t\t\n\t\t\n\t\tfDistance = min(fDistance, TracePillar(ray, vBase + vec3(-4.1, 0.0, 8.5)));\t\n\t\tfDistance = min(fDistance, TracePillar(ray, vBase + vec3(4.0, 0.0, 8.5)));\n\t}\n\t\n\n\tfloat fBackWallDist = 9.5;\n\tfloat fBuildingHeight = 100.0;\n\tfDistance = min(fDistance, TraceBox( ray, vec3(fBuildingMin, -3.0, fBackWallDist), vec3(fBuildingMax, fBuildingHeight, fBackWallDist + 10.0) ));\n\n\tfloat fBuildingTopDist = 8.1;\n\tfloat fCeilingHeight = 4.7;\n\tfDistance = min(fDistance, TraceBox( ray, vec3(fBuildingMin, fCeilingHeight, fBuildingTopDist), vec3(fBuildingMax, fBuildingHeight, fBuildingTopDist + 10.0) ));\n\n\tfloat fRoofDistance = 6.0;\n\tfloat fRoofHeight = 21.0;\n\tfDistance = min(fDistance, TraceBox( ray, vec3(fBuildingMin, fRoofHeight, fRoofDistance), vec3(fBuildingMax, fRoofHeight + 0.2, fRoofDistance + 10.0) ));\t\n\t\n\treturn fDistance;\n}\n\t\nfloat TraceScene( const in C_Ray ray )\n{        \n    float fDistance = kMaxDist;\n        \n\tfloat fFloorHeight = -1.5;\n\tfDistance = min(fDistance, TraceFloor( ray, fFloorHeight ));\n\t\n\t\/\/ end of row\n\tfDistance = min(fDistance, TraceBox( ray, vec3(fBuildingMax, fFloorHeight, -100.0), vec3(fBuildingMax+1.0, 100.0, 100.0) ));\n\tfDistance = min(fDistance, TraceBox( ray, vec3(fBuildingMin, fFloorHeight, -100.0), vec3(fBuildingMin-1.0, 100.0, 100.0) ));\n\t\t\n\tfDistance = min(fDistance, TraceBuildingSide( ray ));\n\t\n\tC_Ray ray2;\t\t\t\t\t\n\tray2.vOrigin = ray.vOrigin * vec3(1.0, 1.0, -1.0);\n\tray2.vDir = ray.vDir * vec3(1.0, 1.0, -1.0);\n\tray2.vOrigin.z -= 0.3;\n\tfDistance = min(fDistance, TraceBuildingSide( ray2 ));\n\t\t\t\t\t\n\treturn fDistance;\n}\n               \n\nvoid GetCameraRay( const in vec3 vPos, const in vec3 vForwards, const in vec3 vWorldUp, const in vec2 px, out C_Ray ray)\n{\n    vec2 vUV = ( px \/ iResolution.xy );\n    vec2 vViewCoord = vUV * 2.0 - 1.0;\t\n\n\tvViewCoord.x *= iResolution.x \/ iResolution.y;\n\tvViewCoord.y *= -1.0;\n\n    ray.vOrigin = vPos;\n\n    vec3 vRight = normalize(cross(vWorldUp, vForwards));\n    vec3 vUp = cross(vRight, vForwards);\n    \n\tvViewCoord *= 0.5;\n\t\n    ray.vDir = normalize( vRight * vViewCoord.x + vUp * vViewCoord.y + vForwards);    \n}\n\nvoid GetCameraRayLookat( const in vec3 vPos, const in vec3 vCameraTarget, const in vec2 px, out C_Ray ray)\n{\n\tvec3 vForwards = normalize(vCameraTarget - vPos);\n\tvec3 vUp = vec3(0.0, 1.0, 0.0);\n\n\tGetCameraRay(vPos, vForwards, vUp, px, ray);\n}\n\nvoid GetCameraPosAndTarget( float fCameraIndex, out vec3 vCameraPos, out vec3 vCameraTarget )\n{\n\tfloat fCameraCount = 6.0;\n\tfloat fCameraIndexModCount = mod(fCameraIndex, fCameraCount);\n\n\tif(fCameraIndexModCount < 0.5)\n\t{\n\t\tvCameraPos = vec3(0.0, 0.0, 0.0);\n\t\tvCameraTarget = vec3(0.0, 0.0, 8.0);\n\t}\n\telse if(fCameraIndexModCount < 1.5)\n\t{\n\t\tvCameraPos = vec3(-3.0, 0.0, -5.0);\n\t\tvCameraTarget = vec3(3.0, -5.0, 5.0);\n\t}\n\telse if(fCameraIndexModCount < 2.5)\n\t{\n\t\tvCameraPos = vec3(8.0, 0.0, 0.0);\n\t\tvCameraTarget = vec3(-10.0, 0.0, 0.0);\n\t}\n\telse if(fCameraIndexModCount < 3.5)\n\t{\n\t\tvCameraPos = vec3(8.0, 3.0, -3.0);\n\t\tvCameraTarget = vec3(-4.0, -2.0, 0.0);\n\t}\n\telse if(fCameraIndexModCount < 4.5)\n\t{\n\t\tvCameraPos = vec3(8.0, 5.0, 5.0);\n\t\tvCameraTarget = vec3(-4.0, 2.0, -5.0);\n\t}\n\telse\n\t{\n\t\tvCameraPos = vec3(-10.0, 3.0, 0.0);\n\t\tvCameraTarget = vec3(4.0, 4.5, -5.0);\n\t}\n}\n\nvec3 BSpline( const in vec3 a, const in vec3 b, const in vec3 c, const in vec3 d, const in float t)\n{\n\tconst mat4 mSplineBasis = mat4( -1.0,  3.0, -3.0, 1.0,\n\t\t\t\t\t\t\t         3.0, -6.0,  0.0, 4.0,\n\t\t\t\t\t\t\t        -3.0,  3.0,  3.0, 1.0,\n\t\t\t\t\t\t\t         1.0,  0.0,  0.0, 0.0) \/ 6.0;\t\n\t\n\tfloat t2 = t * t;\n\tvec4 T = vec4(t2 * t, t2, t, 1.0);\n\t\n\tvec4 vCoeffsX = vec4(a.x, b.x, c.x, d.x);\n\tvec4 vCoeffsY = vec4(a.y, b.y, c.y, d.y);\n\tvec4 vCoeffsZ = vec4(a.z, b.z, c.z, d.z);\n\t\n\tvec4 vWeights = T * mSplineBasis;\n\t\n\tvec3 vResult;\n\t\n\tvResult.x = dot(vWeights, vCoeffsX);\n\tvResult.y = dot(vWeights, vCoeffsY);\n\tvResult.z = dot(vWeights, vCoeffsZ);\n\t\n\treturn vResult;\n}\n\nvoid GetCamera(out vec3 vCameraPos, out vec3 vCameraTarget)\n{\n\tfloat fCameraGlobalTime = iGlobalTime * 0.5;\n\tfloat fCameraTime = fract(fCameraGlobalTime);\n\tfloat fCameraIndex = floor(fCameraGlobalTime);\n\t\n\tvec3 vCameraPosA;\n\tvec3 vCameraTargetA;\n\tGetCameraPosAndTarget(fCameraIndex, vCameraPosA, vCameraTargetA);\n\t\n\tvec3 vCameraPosB;\n\tvec3 vCameraTargetB;\n\tGetCameraPosAndTarget(fCameraIndex + 1.0, vCameraPosB, vCameraTargetB);\n\t\n\tvec3 vCameraPosC;\n\tvec3 vCameraTargetC;\n\tGetCameraPosAndTarget(fCameraIndex + 2.0, vCameraPosC, vCameraTargetC);\n\t\n\tvec3 vCameraPosD;\n\tvec3 vCameraTargetD;\n\tGetCameraPosAndTarget(fCameraIndex + 3.0, vCameraPosD, vCameraTargetD);\n\t\n\tvCameraPos = BSpline(vCameraPosA, vCameraPosB, vCameraPosC, vCameraPosD, fCameraTime);\n\tvCameraTarget = BSpline(vCameraTargetA, vCameraTargetB, vCameraTargetC, vCameraTargetD, fCameraTime);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    C_Ray ray;\n\n\tvec3 vResult = vec3(0.0);\n\t\n\tvec2 vMouse = iMouse.xy \/ iResolution.xy;\t\n\t\n\tvec3 vCameraPos;\n\tvec3 vCameraTarget;\n\t\n\tGetCamera(vCameraPos, vCameraTarget);\t\t\n\n\tGetCameraRayLookat( vCameraPos, vCameraTarget, fragCoord, ray);\n\t\n    float fHitDist = TraceScene(ray);\n\tvec3 vHitPos = ray.vOrigin + ray.vDir * fHitDist;\n\t\n\tvResult = textureCube(iChannel0, vHitPos.xyz).rgb;\t\n\tvResult = vResult * vResult;\n\t\n\t#ifdef FORCE_SHADOW\n\tif( abs(vHitPos.z) > 9.48)\n\t{\n\t\tif( abs(vHitPos.x) < 20.0)\n\t\t{\n\t\t\tfloat fIntensity = length(vResult);\n\t\t\t\n\t\t\tfIntensity = min(fIntensity, 0.05);\n\t\t\t\n\t\t\tvResult = normalize(vResult) * fIntensity;\n\t\t}\n\t}\n\t#endif\t\n\t\n\t#ifdef ENABLE_REFLECTION\n\tif(vHitPos.y < -1.4)\n\t{\n\t\tfloat fDelta = -0.1;\n\t\tfloat vSampleDx = textureCube(iChannel0, vHitPos.xyz + vec3(fDelta, 0.0, 0.0)).r;\t\n\t\tvSampleDx = vSampleDx * vSampleDx;\n\n\t\tfloat vSampleDy = textureCube(iChannel0, vHitPos.xyz + vec3(0.0, 0.0, fDelta)).r;\t\n\t\tvSampleDy = vSampleDy * vSampleDy;\n\t\t\n\t\tvec3 vNormal = vec3(vResult.r - vSampleDx, 2.0, vResult.r - vSampleDy);\n\t\tvNormal = normalize(vNormal);\n\t\t\n\t\tvec3 vReflect = reflect(ray.vDir, vNormal);\n\t\t\n\t\tfloat fDot = clamp(dot(-ray.vDir, vNormal), 0.0, 1.0);\n\t\t\n\t\tfloat r0 = 0.1;\n\t\tfloat fSchlick =r0 + (1.0 - r0) * (pow(1.0 - fDot, 5.0));\n\t\t\n\t\tvec3 vResult2 = textureCube(iChannel1, vReflect).rgb;\t\n\t\tvResult2 = vResult2 * vResult2;\n\t\tfloat shade = smoothstep(0.3, 0.0, vResult.r);\n\t\tvResult += shade * vResult2 * fSchlick * 5.0;\n\t}\n\t#endif\n\t\n\tif(iMouse.z > 0.0)\n\t{\n\t\tvec3 vGrid =  step(vec3(0.9), fract(vHitPos + 0.01));\n\t\tfloat fGrid = min(dot(vGrid, vec3(1.0)), 1.0);\n\t\tvResult = mix(vResult, vec3(0.0, 0.0, 1.0), fGrid);\n\t}\n\t\n\tfragColor = vec4(sqrt(vResult),1.0);\n}\n","name":"","description":"","type":"image"}]}}