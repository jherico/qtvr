{"Shader":{"ver":"0.1","info":{"id":"XljXzW","date":"1442014877","viewed":881,"name":"Terrain Experiment 3","username":"aiekick","description":"Terrain Experiment 3","likes":3,"published":3,"flags":0,"tags":["terrain","experiment","3"],"hasliked":0},"renderpass":[{"inputs":[{"id":23,"src":"\/presets\/cube01_0.png","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Stephane Cuillerdier - Aiekick\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat dstepf = 0.0;\n    \nconst vec2 RMPrec = vec2(.1, 0.001); \nconst vec3 DPrec = vec3(0.01, 20., 1e-6); \n\n\/\/ by shane\nfloat Voronesque( in vec3 p )\n{\n    vec3 i  = floor(p + dot(p, vec3(0.333333)) );  p -= i - dot(i, vec3(0.166666)) ;\n    vec3 i1 = step(0., p-p.yzx), i2 = max(i1, 1.0-i1.zxy); i1 = min(i1, 1.0-i1.zxy);    \n    vec3 p1 = p - i1 + 0.166666, p2 = p - i2 + 0.333333, p3 = p - 0.5;\n    vec3 rnd = vec3(7, 157, 113); \/\/ I use this combination to pay homage to Shadertoy.com. :)\n    vec4 v = max(0.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);\n    vec4 d = vec4( dot(i, rnd), dot(i + i1, rnd), dot(i + i2, rnd), dot(i + 1., rnd) ); \n    d = fract(sin(d)*262144.)*v*2.; \n    v.x = max(d.x, d.y), v.y = max(d.z, d.w), v.z = max(min(d.x, d.y), min(d.z, d.w)), v.w = min(v.x, v.y); \n    return max(v.x, v.y);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nvec2 map(vec3 p)\n{\n\tvec2 res = vec2(0.);\n    dstepf += 0.002;\n\tfloat voro = Voronesque(p);\n\tfloat disp = sin(iGlobalTime*.2)*.5 + .7;\n\treturn vec2(p.y - voro\/disp, 0.);\n}\n\nvec3 nor( vec3 pos, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n    map(pos+e.xyy).x - map(pos-e.xyy).x,\n    map(pos+e.yxy).x - map(pos-e.yxy).x,\n    map(pos+e.yyx).x - map(pos-e.yyx).x );\n    return normalize(n);\n}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cu, vec3 cv)\n{\n\tvec3 rov = normalize(cv-ro);\n    vec3 u =  normalize(cross(cu, rov));\n    vec3 v =  normalize(cross(rov, u));\n    vec3 rd = normalize(rov + u*uv.x + v*uv.y);\n    return rd;\n}\n\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. \/ 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. \/ 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)\/255.;\n    if (Temp < 1000.) col *= Temp\/1000.;\n   \treturn col;\n}\n\nvoid mainImage( out vec4 f, in vec2 g )\n{\n\tvec2 si = iResolution.xy;\n\tvec2 uv = (g+g-si)\/min(si.x, si.y);\n    vec3 cu = vec3(0,1,0);\n    vec3 ro = vec3(0., 2., iGlobalTime); \n\tvec3 cv = vec3(0,0,1);\n    vec3 rd = cam(uv, ro, cu, ro+cv);\n\n    vec3 d = vec3(1);\n    vec3 p = ro+rd*d.x;\n\tvec2 s = vec2(DPrec.y,0.);\n\t\n    for(int i=0;i<200;i++)\n    {      \n\t\tif(s.x<DPrec.x||s.x>DPrec.y) break;\n        s = map(p);\n\t\ts.x *= (s.x>DPrec.x?RMPrec.x:RMPrec.y);\n\t\td.x += s.x;\n        p = ro+rd*d.x;\n   \t}\n\t\n\tif (d.x<DPrec.y)\n    {\n\t\tvec3 n = nor(p, 0.1);\n\t\tf.rgb = textureCube(iChannel0, n).rgb*.4;\n\t\t\n\t\tif ( s.y < 1.5) \/\/ rock\n        {\n\t\t\td.y = d.x;\n        \ts.x = DPrec.x;\n\t\t\tro = p;\t\t\n            rd = reflect(rd, n);\n\t\t\tp = ro+rd*d.x;\t\t\n\t\t\tfor(int i=0;i<20;i++)\n\t\t\t{      \n\t\t\t\tif(s.x<DPrec.x) break;\n\t\t\t\ts.x = map(p).x * RMPrec.x;\n\t\t\t\td.x += s.x;\n               \tf.rgb += blackbody(200.\/(d.x + d.y));\n\t\t\t\tp = ro+rd*d.x;\n\t\t\t}\t\n\t\t}\n   \t}\n    else\n    {\n\t\tf.rgb = vec3(1,.5,.5);\n\t}\n    \n\tf += dstepf;\n}","name":"","description":"","type":"image"}]}}