{"Shader":{"ver":"0.1","info":{"id":"MdlXWr","date":"1399648655","viewed":1339,"name":"Star Tunnel","username":"P_Malin","description":"Single pass starfield inspired by old school tunnel effects.<br\/>I wanted to try to render a starfield without any loops or iteration. Each angular segment of space around the viewer generates a random star xy radius from the viewer and z repeat distance.","likes":31,"published":3,"flags":0,"tags":["starfield"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Star Tunnel - @P_Malin\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/\n\/\/ Single pass starfield inspired by old school tunnel effects.\n\/\/ Each angular segment of space around the viewer selects a random star position radius and depth repeat rate.\n\n\/\/ Increase pass count for a denser effect\n#define PASS_COUNT 1\n\nfloat fBrightness = 2.5;\n\n\/\/ Number of angular segments\nfloat fSteps = 121.0;\n\nfloat fParticleSize = 0.015;\nfloat fParticleLength = 0.5 \/ 60.0;\n\n\/\/ Min and Max star position radius. Min must be present to prevent stars too near camera\nfloat fMinDist = 0.8;\nfloat fMaxDist = 5.0;\n\nfloat fRepeatMin = 1.0;\nfloat fRepeatMax = 2.0;\n\n\/\/ fog density\nfloat fDepthFade = 0.8;\n\nfloat Random(float x)\n{\n\treturn fract(sin(x * 123.456) * 23.4567 + sin(x * 345.678) * 45.6789 + sin(x * 456.789) * 56.789);\n}\n\nvec3 GetParticleColour( const in vec3 vParticlePos, const in float fParticleSize, const in vec3 vRayDir )\n{\t\t\n\tvec2 vNormDir = normalize(vRayDir.xy);\n\tfloat d1 = dot(vParticlePos.xy, vNormDir.xy) \/ length(vRayDir.xy);\n\tvec3 vClosest2d = vRayDir * d1;\n\t\n\tvec3 vClampedPos = vParticlePos;\n\t\n\tvClampedPos.z = clamp(vClosest2d.z, vParticlePos.z - fParticleLength, vParticlePos.z + fParticleLength);\n\t\n\tfloat d = dot(vClampedPos, vRayDir);\n\t\n\tvec3 vClosestPos = vRayDir * d;\n\t\n\tvec3 vDeltaPos = vClampedPos - vClosestPos;\t\n\t\t\n\tfloat fClosestDist = length(vDeltaPos) \/ fParticleSize;\n\t\n\tfloat fShade = \tclamp(1.0 - fClosestDist, 0.0, 1.0);\n\t\t\n\tfShade = fShade * exp2(-d * fDepthFade) * fBrightness;\n\t\n\treturn vec3(fShade);\n}\n\nvec3 GetParticlePos( const in vec3 vRayDir, const in float fZPos, const in float fSeed )\n{\n\tfloat fAngle = atan(vRayDir.x, vRayDir.y);\n\tfloat fAngleFraction = fract(fAngle \/ (3.14 * 2.0));\n\t\n\tfloat fSegment = floor(fAngleFraction * fSteps + fSeed) + 0.5 - fSeed;\n\tfloat fParticleAngle = fSegment \/ fSteps * (3.14 * 2.0);\n\n\tfloat fSegmentPos = fSegment \/ fSteps;\n\tfloat fRadius = fMinDist + Random(fSegmentPos + fSeed) * (fMaxDist - fMinDist);\n\t\n\tfloat tunnelZ = vRayDir.z \/ length(vRayDir.xy \/ fRadius);\n\t\n\ttunnelZ += fZPos;\n\t\n\tfloat fRepeat = fRepeatMin + Random(fSegmentPos + 0.1 + fSeed) * (fRepeatMax - fRepeatMin);\n\t\n\tfloat fParticleZ = (ceil(tunnelZ \/ fRepeat) - 0.5) * fRepeat - fZPos;\n\t\n\treturn vec3( sin(fParticleAngle) * fRadius, cos(fParticleAngle) * fRadius, fParticleZ );\n}\n\nvec3 Starfield( const in vec3 vRayDir, const in float fZPos, const in float fSeed )\n{\t\n\tvec3 vParticlePos = GetParticlePos(vRayDir, fZPos, fSeed);\n\t\n\treturn GetParticleColour(vParticlePos, fParticleSize, vRayDir);\t\n}\n\nvec3 RotateX( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n    \n    vec3 vResult = vec3( vPos.x, c * vPos.y + s * vPos.z, -s * vPos.y + c * vPos.z);\n    \n    return vResult;\n}\n\nvec3 RotateY( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n    \n    vec3 vResult = vec3( c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);\n    \n    return vResult;\n}\n\nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n    \n    vec3 vResult = vec3( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y, vPos.z);\n    \n    return vResult;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vScreenUV = fragCoord.xy \/ iResolution.xy;\n\t\n\tvec2 vScreenPos = vScreenUV * 2.0 - 1.0;\n\tvScreenPos.x *= iResolution.x \/ iResolution.y;\n\n\tvec3 vRayDir = normalize(vec3(vScreenPos, 1.0));\n\n\tvec3 vEuler = vec3(0.5 + sin(iGlobalTime * 0.2) * 0.125, 0.5 + sin(iGlobalTime * 0.1) * 0.125, iGlobalTime * 0.1 + sin(iGlobalTime * 0.3) * 0.5);\n\t\t\t\n\tif(iMouse.z > 0.0)\n\t{\n\t\tvEuler.x = -((iMouse.y \/ iResolution.y) * 2.0 - 1.0);\n\t\tvEuler.y = -((iMouse.x \/ iResolution.x) * 2.0 - 1.0);\n\t\tvEuler.z = 0.0;\n\t}\n\t\t\n\tvRayDir = RotateX(vRayDir, vEuler.x);\n\tvRayDir = RotateY(vRayDir, vEuler.y);\n\tvRayDir = RotateZ(vRayDir, vEuler.z);\n\t\n\tfloat fShade = 0.0;\n\t\t\n\tfloat a = 0.2;\n\tfloat b = 10.0;\n\tfloat c = 1.0;\n\tfloat fZPos = 5.0 + iGlobalTime * c + sin(iGlobalTime * a) * b;\n\tfloat fSpeed = c + a * b * cos(a * iGlobalTime);\n\t\n\tfParticleLength = 0.25 * fSpeed \/ 60.0;\n\t\n\tfloat fSeed = 0.0;\n\t\n\tvec3 vResult = mix(vec3(0.005, 0.0, 0.01), vec3(0.01, 0.005, 0.0), vRayDir.y * 0.5 + 0.5);\n\t\n\tfor(int i=0; i<PASS_COUNT; i++)\n\t{\n\t\tvResult += Starfield(vRayDir, fZPos, fSeed);\n\t\tfSeed += 1.234;\n\t}\n\t\n\tfragColor = vec4(sqrt(vResult),1.0);\n}","name":"","description":"","type":"image"}]}}