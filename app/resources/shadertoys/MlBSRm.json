{"Shader":{"ver":"0.1","info":{"id":"MlBSRm","date":"1442709684","viewed":941,"name":"Alien Landscape","username":"clayjohn","description":"Some weird alien planet landscape thing. Oddly pleased with how the sky turned out.","likes":3,"published":3,"flags":0,"tags":["terrain","raymarch","stars","moon","cosine","milkyway"],"hasliked":0},"renderpass":[{"inputs":[{"id":4,"src":"\/presets\/tex03.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/*\nThis started out as a testbed for playing with phong lighting. It was just a grid with a moving light \nand it slowly turned into this. I am fairly happy with the results, it's definitaly the best looking \nlandscape I've made. I hope you like!\n\nI was experimenting with sin based noise, but ended up stealing IQs from https:\/\/www.shadertoy.com\/view\/4sjXzG\nalso the ray marcher is based off of many other shaders from around shadertoy.\n\nDisclaimer: There will defintaly be artifacts in the code from experimenting with things from before. I'm sorry \nif it clutters things up too much. But I like to keep them so I can come back later and play around with ideas I came up with \nduring the process.\n\n*\/\n\n\nvec3 MOON = vec3(-200.0+sin(iGlobalTime*0.5)*400.0, 60.0, 207.0);\nconst vec3 SKY = vec3( 0.1, 0.2, 0.4 );\n\nfloat hash(vec2 p) {\n return fract(sin(dot(p*0.05, vec2(14.52, 76.38)))*43256.2895);   \n}\n\nfloat noise(vec2 pos) {\n  vec2 a = vec2(1.0, 0.0);\n  vec2 p = floor(pos);\n  vec2 f = fract(pos);\n  f = f*f*f*(3.0-2.0*f);\n    float h = mix(mix(hash(p+a.yy), hash(p+a.xy), f.x), \n                  mix(hash(p+a.yx), hash(p+a.xx), f.x), f.y);\n    return h;\n}\n   \n\nfloat snoise(vec2 p) {\n   float h = 0.0;\n    float a = 0.5;\n    for (float i=0.0;i<6.0;i++) {\n        h+=noise(p)*a;\n        p*=1.9;\n        a*=0.4;\n    } \n    return h;\n}\n\nfloat snoiser(vec2 p) {\n   float h = 0.0;\n    float a = 0.5;\n    for (float i=0.0;i<6.0;i++) {\n        h+= abs(noise(p)-0.5)*a*2.0;\n        p*=2.5;\n        a*=0.7;\n    } \n    return h;\n}\n\n\nconst mat2 m2 = mat2(1.8,-1.2,1.2,1.6);\n\n\nfloat fbm(vec2 p) {\n float h = 0.0;\n float a = 0.5;\n    for(float i = 0.0;i<3.0;i++) {\n        h+= a*texture2D(iChannel0, p).x;\n        p*=2.0;\n        a*=0.5;\n    }\n    return abs(h-0.5)*2.0;\n}\n\/\/low detail for ray tracing\nfloat f(vec2 p) {\n    p *= 0.13;\n    float h = 0.0;\n    float a = 1.0;\n    for (float i=0.0;i<4.0;i++) {\n        \/\/h+=noise(p)*a;\n        \/\/h+=sin(p.x)*sin(p.y)*a;\n        h+=0.5*(cos(6.2831*p.x) + cos(6.2831*p.y))*a;\n        p = 0.97*m2*p + (h-0.5)*0.2;\n        a*= 0.5 +0.1*h;\n    }\n    \/\/return sin(p.x)*sin(p.y)-1.0;\n    \/\/return noise(p*0.5)-1.0;\n    return  smoothstep(0.1, 2.0, (abs(h-0.5)))-2.0;\n    \n\n}\n\/\/high detail for shading\nfloat fh(vec2 p) {\n    p *= 0.13;\n    float h = 0.0;\n    float a = 1.0;\n    for (float i=0.0;i<6.0;i++) {\n        \/\/h+=noise(p)*a;\n        \/\/h+=sin(p.x)*sin(p.y)*a;\n        h+=0.5*(cos(6.2831*p.x) + cos(6.2831*p.y))*a;\n        p = 0.97*m2*p + (h-0.5)*0.2;\n        a*= 0.5 +0.1*h;\n    }\n    \/\/return sin(p.x)*sin(p.y)-1.0;\n    \/\/return noise(p*0.5)-1.0;\n    return  smoothstep(0.1, 2.0, (abs(h+fbm(p*0.01)*0.1-0.5)))-2.0;\n    \n\n}\n\nvec3 norm(vec3 p, float t) {\n    vec2 e = vec2(0.001*t, 0.0);\n    return normalize(vec3(fh(p.xz-e.xy)-fh(p.xz+e.xy), 2.0*e.x, fh(p.xz-e.yx)-fh(p.xz+e.yx)));\n}\n\nvec3 material(vec3 p, vec3 n) {\n    vec3 m = mix(vec3(0.3, 0.1, 0.0), vec3(1.0), smoothstep(0.7, 0.8, p.y+fbm(p.xz)+1.5));\n    m = mix(vec3(0.3, 0.5, 0.1), m, smoothstep(0.0, 0.1, p.y+2.0));\n    m = mix(vec3(0.5), m, smoothstep(0.1, 1.0, n.y));\n    \n    \/\/m = vec3(clamp(step(fract(p.x + 0.5 * step(0.5, fract(p.z))), 0.5), 0.1, 1.0));\n    return m;\n}\n\nvec3 get_col(vec3 p, float t, vec2 uv) {\n    vec3 n = norm(p, t);\n    \n    vec3 m = material(p, n);\n    \n    vec3 I = normalize(MOON);\n    float s = clamp(smoothstep(0.0, 0.5, dot(I, n)), 0.0, 1.0);\n    return mix(m*s, SKY*(abs(uv.y-1.2)*0.4), clamp(pow(t, 0.8)\/5.0, 0.0, 1.0));\n    \/\/return mix(m, SKY, clamp(pow(t, 0.8)\/5.0, 0.0, 1.0));\n    \n\n}\nfloat trace(out vec3 pos, vec3 dir) {\n    float delta = 0.01;\n    float j = 0.5;\n    vec3 p;\n    float lh = 0.0;\n    float ly = 0.0;\n    for (int i = 0;i<700;i++) {\n        p = pos+dir*j;\n        float h = f(p.xz);\n        if(p.y-h<0.02*j) {\n            pos = p;\n            return j;\n        }\n        \n    j+= delta;\n    delta = 0.005*j;\n    ly = p.y;\n    lh = h;\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iGlobalTime*0.2;\n\tvec2 uv = ( fragCoord.xy \/ iResolution.xy ) * 2.0 - 1.0;\n\tuv.x *= iResolution.x \/  iResolution.y;\n    \n    vec3 dir = normalize(vec3(uv, 1.0));\n    vec3 pos = vec3(0.0, f(vec2(0.0, time))+0.5, time);\n\n    vec3 col = vec3(0.0);\n    float t = trace(pos, dir);\n    \/\/t = -1.0;\n    if (t>=0.0) {\n    col = get_col(pos, t, uv);\n    \n    \n    } else {\n      \/\/stars  \n    col = vec3(smoothstep(0.7+0.3*smoothstep(0.0, 0.35, abs((uv.x*0.5-1.0)*iResolution.y\/iResolution.x+uv.y)), 1.0, hash(fragCoord))*hash(fragCoord*2.0));\n    \n\n    \n    vec2 moon = normalize(MOON).xy;\n    float l = length(moon-uv);\n    \/\/moon penumbra\n    col +=0.9*exp(-l*10.0);\n    \/\/sky gradient\n    col += SKY*(abs(uv.y-1.2)*0.4);\n        \/\/ save this effect for later\n    \/\/col+= (1.0-smoothstep(0.1, 0.15, l*snoise(uv)));\n    \/\/milky way\n        \/\/inner glow\n    col = mix(vec3(1.0, 1.0, 0.8), col,0.5+0.5*smoothstep(0.0, 0.07, abs((uv.x*0.5-1.0)*iResolution.y\/iResolution.x+uv.y)*snoise(5.0*(uv*vec2(iResolution.y\/iResolution.x, 0.0)-vec2(1.0, -uv.y)))));\n        \/\/outer shape\n    col = mix(SKY*1.2, col,0.8+0.2*smoothstep(0.0, 0.15, abs((uv.x*0.5-1.0)*iResolution.y\/iResolution.x+uv.y)*snoise(4.0*(uv*vec2(iResolution.y\/iResolution.x, 0.0)-vec2(1.0, -uv.y)))));\n    \/\/milky way clouds\n    col = mix(SKY*(abs(uv.y-1.2)*0.4), col, 0.1+0.5*smoothstep(0.0, 0.1, abs((uv.x*0.5-1.0)*iResolution.y\/iResolution.x+uv.y)*snoiser(15.0*(uv*vec2(iResolution.y\/iResolution.x, 0.0)-vec2(1.0, -uv.y)))));\n    col = mix(SKY*(abs(uv.y-1.2)*0.4), col, smoothstep(0.0, 0.03, abs((uv.x*0.5-1.0)*iResolution.y\/iResolution.x+uv.y)*0.02+0.03*snoiser(15.0*(uv*vec2(iResolution.y\/iResolution.x, 0.0)-vec2(1.0, -uv.y)))));\n\n        \/\/add nearby stars\n    col += vec3(smoothstep(0.95, 1.0, hash(fragCoord))*hash(fragCoord*2.0));\n    \/\/add moon\n    col= mix(col, vec3(0.6+0.2*smoothstep(0.25, 0.55, snoise((moon-uv+vec2(0.8))*12.0))), (1.0-smoothstep(0.15, 0.18, l)));\n\n    }\n    \n    col = pow( col, vec3(0.45) );\n    \/\/col = vec3 (smoothstep(0.0, 0.05, abs((uv.x-1.0)*iResolution.y\/iResolution.x+uv.y)*0.07+0.07*snoiser(15.0*(uv*vec2(iResolution.y\/iResolution.x, 0.0)-vec2(1.0, -uv.y)))));\n\t\/\/col = vec3 (smoothstep(0.0, 0.1, abs((uv.x-1.0)*iResolution.y\/iResolution.x+uv.y)*snoiser(15.0*(uv*vec2(iResolution.y\/iResolution.x, 0.0)-vec2(1.0, -uv.y)))));\n\n    fragColor = vec4(col,1.0);\n}","name":"","description":"","type":"image"}]}}