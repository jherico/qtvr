{"Shader":{"ver":"0.1","info":{"id":"lllGR2","date":"1423503571","viewed":775,"name":"Orbit Fractals","username":"eiffie","description":"A satellite orbiting a planet orbiting a sun orbiting a black hole would create interesting patterns if the scale was a bit more linear. The drawing code is based on <a href=\"https:\/\/www.shadertoy.com\/view\/XdSSRw\" class=\"regular\" target=\"_blank\">https:\/\/www.shadertoy.com\/view\/XdSSRw<\/a> from nimitz.","likes":5,"published":3,"flags":0,"tags":["fractal","orbit"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/Orbit Fractals by eiffie, based on Parametrics by nimitz https:\/\/www.shadertoy.com\/view\/XdSSRw\n\n\/\/This is related to rolling fractals - http:\/\/www.fractalforums.com\/new-theories-and-research\/rolling-fractals\/\n\/\/I did not expect to find the HEX and TRIANGLE shapes in \"planetary\" orbits and with such strange scales! \n\/\/I doubt they will work in your browser tho :(\n#define SIMP\n\/\/#define SIMP3D\n\/\/#define HEX\n\/\/#define TRI\n\/\/#define HASHTAG\n\n\n#define LOCAL_STEPS 6\n#define MIN_T 0.0\n#define SCALE_Z 0.0\n\n#ifdef SIMP\n\t#define GLOBAL_STEPS 99\n\t#define MAX_T 25.1\n\t#define ITERS 2\n\t#define SCALE -3.5\n#endif\n#ifdef SIMP3D\n\t#define GLOBAL_STEPS 99\n\t#define MAX_T 12.0\n\t#define ITERS 5\n\t#define SCALE -3.0\n\t#undef SCALE_Z\n\t#define SCALE_Z 2.0\n\t#define CAM_3D\n#endif\n#ifdef HEX\n\t#define GLOBAL_STEPS 1024\n\t#define MAX_T 150.0\n\t#define ITERS 3\n\t#define SCALE 3.4495\n#endif\n#ifdef TRI\n\t#define GLOBAL_STEPS 1024\n\t#define MAX_T 200.0\n\t#define ITERS 3\n\t#define SCALE 2.3028\n#endif\n#ifdef HASHTAG\n\t#define GLOBAL_STEPS 1024\n\t#define MAX_T 200.0\n\t#define ITERS 3\n\t#define SCALE -2.992\n#endif\n\n\n#define time iGlobalTime\n#define size iResolution\n\nvec3 orbit(float a, float r){return vec3(cos(SCALE_Z*a)*vec2(cos(a),sin(a)),sin(SCALE_Z*a))*r;}\nvec3 F(float t){\n\tfloat r=1.0;\n\tvec3 p=orbit(t,r);\n\tfor(int i=0;i<ITERS;i++){\n\t\tt*=SCALE,r\/=abs(SCALE);\n\t\tp+=orbit(t,r);\n\t}\n\treturn p;\n}\nfloat SegD(vec3 pa, vec3 ba, vec3 rd){\n\tfloat d=dot(rd,ba);\n\tfloat t=clamp((dot(rd,pa)*d-dot(pa,ba))\/(dot(ba,ba)-d*d),0.0,1.0);\n\tpa+=ba*t;\n\tfloat b=dot(pa,rd);\n\tfloat h=dot(pa,pa)-b*b;\n\treturn h;\n}\nfloat Arms(float t, vec3 ro, vec3 rd){\n\tfloat d=100.0;\n\tvec3 p1=vec3(0.0),p2;\n\tfloat r=1.0;\n\tfor(int i=0;i<ITERS+1;i++){\n\t\tp2=p1+orbit(t,r);\n\t\td=min(d,SegD(p1-ro,p2-p1,rd));\n\t\tt*=SCALE,r\/=abs(SCALE);\n\t\tp1=p2;\n\t}\n\treturn d;\n}\nvec4 D=vec4(1000.0),TF=vec4(0.0),TN=vec4(0.0);\/\/a stack of distances (from the curve, not to) and times\nvoid zStack(float d, float tf, float tn){\n\tif(d<D.x){D=vec4(d,D.xyz);TN=vec4(tn,TN.xyz);TF=vec4(tf,TF.xyz);}\n\telse if(d<D.y){D.yzw=vec3(d,D.yz);TN.yzw=vec3(tn,TN.yz);TF.yzw=vec3(tf,TF.yz);}\n\telse if(d<D.z){D.zw=vec2(d,D.z);TN.zw=vec2(tn,TN.z);TF.zw=vec2(tf,TF.z);}\n\telse if(d<D.w){D.w=d;TN.w=tn;TF.w=tf;}\n}\n\nvec3 scene( vec3 ro, vec3 rd )\n{\n\tfloat stride=2.0*(MAX_T-MIN_T)\/float(GLOBAL_STEPS);\n\tfloat t=MIN_T,ot=t,d=0.0;\n\tvec3 p1=F(t),p2;\n\tfor(int i=0;i<GLOBAL_STEPS;i++){\/\/stepping thru the whole curve to find possible roots\n\t\tt+=max(stride*0.2,stride*log(d+1.15));\n\t\tp2=F(t);\n\t\td=SegD(p1-ro,p2-p1,rd);\n\t\tzStack(d,t,ot);\n\t\tif(t>MAX_T)break;\n\t\tot=t;\n\t\tp1=p2;\n\t}\n\td=100.0;\n\tfor(int j=0;j<4;j++){\/\/stepping thru the possible roots\n\t\tfloat near=TN.x,far=TF.x;\n\t\tfor(int i=0;i<LOCAL_STEPS;i++){\/\/...and finding local minima\n\t\t\tfloat mid=(near+far)*0.5;\n\t\t\tp1=F(mid);\n\t\t\tfloat mdrv=SegD(p1-ro,F(far)-p1,rd)-SegD(p1-ro,F(near)-p1,rd);\n\t\t\tif(mdrv > 0.0)far=mid;else near=mid;\n\t\t}\n\t\tp1=F(near);p2=F(far);\n\t\td=min(d,SegD(p1-ro,p2-p1,rd));\n\t\tTN=TN.yzwx;TF=TF.yzwx;\n\t}\n\tvec3 col=vec3(smoothstep(0.0,0.0001,d));\n\td=Arms(time*0.5,ro,rd);\n\tcol=mix(vec3(0.0,0.75,0.0),col,smoothstep(0.0,0.0001,d));\n\treturn col;\n}\t \nmat3 lookat(vec3 fw){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0.0,1.0,0.0)));return mat3(rt,cross(rt,fw),fw);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv=(2.0*fragCoord.xy-iResolution.xy)\/iResolution.y;\n\tvec3 ro=vec3(0.0,0.0,3.0);\n#ifdef CAM_3D\n\tro=vec3(cos(time),0.05,sin(time))*3.0;\n#endif\n\tvec3 rd=lookat(-ro)*normalize(vec3(uv,2.0));\n\tfragColor = vec4(scene(ro,rd),1.0);\n}\n","name":"","description":"","type":"image"}]}}