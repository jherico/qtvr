{"Shader":{"ver":"0.1","info":{"id":"MtB3WW","date":"1429002992","viewed":723,"name":"filtered flickering","username":"hornet","description":"Quick mockup of filtered flickering instead of picking a random value per frame.<br\/>You could offset the values and interpolate between them instead, which is how you end up with value-noise. This is an example of pure bruteforce box-filtering.","likes":4,"published":3,"flags":0,"tags":["flicker"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"float sat( float x )\n{\n    return clamp( x, 0.0, 1.0 );\n}\nfloat trunc( float x, float l )\n{\n\treturn floor(x * l) \/ l;\n}\nfloat remap( float a, float b, float v ) {\n\treturn clamp( (v-a) \/ (b-a), 0.0, 1.0 );\n}\n\n\/\/ ====\n\nfloat hash11( float n )\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\n\/\/ ====\n\nconst float FLICKER_RATE = 13.0;\nconst float FLICKER_PHASE = 13.583;\n\nfloat flicker0( float t )\n{\n    float ft0 = trunc( t + FLICKER_PHASE, FLICKER_RATE );\n    \n    \/\/note: single sample\n    return hash11( ft0 );\n}\n\nfloat flicker1( float t )\n{\n    float ft0 = trunc( t + FLICKER_PHASE, FLICKER_RATE );\n    \n    const int NUM_SAMPLES = 8;\n    const float RCP_NUM_SAMPLES_F = 1.0 \/ float(NUM_SAMPLES);\n    const float diff_t = 1.0\/60.0; \/\/note: delta-time at 60Hz\n    const float FILTERWIDTH = 4.0 * diff_t;\n\n    \/\/note: box-filter => linear interpolations\n    float stepsiz = FILTERWIDTH * RCP_NUM_SAMPLES_F;\n    float sum = 0.0;\n    float st = t - 0.25*FILTERWIDTH; \/\/TODO: rnd offset...\n    for ( int i=0; i<NUM_SAMPLES; ++i )\n    {\n        float ft = trunc( st + FLICKER_PHASE, FLICKER_RATE );\n        sum += hash11( ft );\n\n        \/\/sum += fract( ft );\n        \n        st += stepsiz;\n    }\n    \n    return sum * RCP_NUM_SAMPLES_F;\n}\n\n\/\/ ====\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspect = vec2( iResolution.x \/ iResolution.y, 1.0 );\n    \n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec2 p = vec2( fract( 2.0 * uv.x ), 2.0 * uv.y );\n    \n    vec2 ctr = vec2(0.5,-0.25);\n\n    \n    int idx = int( floor(2.0*uv.x) );\n    \n    float dist = 1.0 - length( (ctr -  p + vec2(0.0, 1.5) ) * aspect  );\n\n    float circle = remap( 0.6125, 0.625, dist );\n    circle = smoothstep( 0.0, 1.0, circle );\n\n    float its = 0.0;\n    if ( idx == 0 )\n    \tits = flicker0( iGlobalTime );\n    else if ( idx == 1 )\n    \tits = flicker1( iGlobalTime );\n\n    its *= circle;\n\n    const float ysiz = 0.25;\n\t\/\/note: current is left\n    if ( uv.y < ysiz )\n    {\n        \/\/note: quantize to 60Hz\n        const float hztime_s = 2.0;\n        p.x = iGlobalTime - fract(2.0*uv.x) * hztime_s;\n        p.y = uv.y \/ (ysiz*0.9);\n        \n        float t = trunc( p.x, 60.0 * hztime_s );\n        float v = 0.0;\n\n        if ( uv.x < 1.0\/2.0 )\n        {\n            v = flicker0( t );\n        }\n        else \/*if ( uv.x < 2.0\/3.0 )*\/\n        {\n            v = flicker1( t );\n        }\n\n        its = step( p.y, v );\n        \n        if ( abs(fract(uv.x*2.0) - 0.49) > 0.5 )\n        {\n            fragColor = vec4(1.0);\n            return;\n        }\n    }\n    if ( abs( uv.y - ysiz ) < 1.0 \/ iResolution.y )\n    {\n        fragColor = vec4(1.0);\n\t\treturn;\n    }\n    \n\tfragColor = vec4( vec3(its), 1.0 );\n}\n","name":"","description":"","type":"image"}]}}