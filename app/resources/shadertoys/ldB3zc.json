{"Shader":{"ver":"0.1","info":{"id":"ldB3zc","date":"1391641775","viewed":1426,"name":"Voronoi - smooth","username":"iq","description":"Smooth Voronoi - avoiding aliasing, by replacing the usual min() function, which is discontinuous, with a smooth version. That can help preventing some aliasing, and also provides with more artistic control of the final procedural textures\/models.","likes":19,"published":3,"flags":0,"tags":["2d","voronoi","worley","smooth"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Smooth Voronoi - avoiding aliasing, by replacing the usual min() function, which is\n\/\/ discontinuous, with a smooth version. That can help preventing some aliasing, and also\n\/\/ provides with more artistic control of the final procedural textures\/models.\n\n\/\/ The parameter w controls the smoothness\n\nfloat hash1( float n ) { return fract(sin(n)*43758.5453); }\nvec2  hash2( vec2  p ) { p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) ); return fract(sin(p)*43758.5453); }\n\nvec4 voronoi( in vec2 x, float w )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec4 m = vec4( 8.0, 0.0, 0.0, 0.0 );\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n        vec2 o = hash2( n + g );\n\t\t\n\t\t\/\/ animate\n        o = 0.5 + 0.5*sin( iGlobalTime + 6.2831*o );\n\n        \/\/ distance to cell\t\t\n\t\tfloat d = length(g - f + o);\n\t\t\n        \/\/ do the smoth min for colors and distances\t\t\n\t\tvec3 col = 0.5 + 0.5*sin( hash1(dot(n+g,vec2(7.0,113.0)))*2.5 + 3.5 + vec3(2.0,3.0,0.0));\n\t\tfloat h = smoothstep( 0.0, 1.0, 0.5 + 0.5*(m.x-d)\/w );\n\t\t\n\t    m.x   = mix( m.x,     d, h ) - h*(1.0-h)*w\/(1.0+3.0*w); \/\/ distance\n\t\tm.yzw = mix( m.yzw, col, h ) - h*(1.0-h)*w\/(1.0+3.0*w); \/\/ color\n    }\n\t\n\treturn m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy\/iResolution.yy;\n\t\n\tfloat k = 2.0 + 70.0 * pow( 0.5 + 0.5*sin(0.25*6.2831*iGlobalTime), 4.0 );\n\tk = 0.5 - 0.5*cos(0.25*6.2831*iGlobalTime);\n    vec4 c = voronoi( 6.0*p, k );\n\n    vec3 col = c.yzw;\n\t\n\tcol *= 1.0 - 0.8*c.x*step(p.y,0.33);\n\tcol *= mix(c.x,1.0,step(p.y,0.66));\n\t\n\tcol *= smoothstep( 0.005, 0.007, abs(p.y-0.33) );\n\tcol *= smoothstep( 0.005, 0.007, abs(p.y-0.66) );\n\t\n    fragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}