{"Shader":{"ver":"0.1","info":{"id":"ldGGzR","date":"1453081803","viewed":339,"name":"LocalThickness","username":"ZigguratVertigo","description":"This shadertoy describes how one can compute \"Local Thickness\", the surface thickness approximation term described in [1] and [2]. Approximates how \"thick\" or \"thin\" various parts of an object are.","likes":6,"published":3,"flags":0,"tags":["sss","scattering","translucency","subsurface","thickness"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/\n\/\/ Local Thickness\n\/\/\n\/\/ This shadertoy describes how one can compute \"Local Thickness\", the surface thickness approximation term described\n\/\/ in [1] and [2]. \n\/\/\n\/\/ The general idea behind the technique is to use a computation similar to ambient occlusion (AO) to approximate how \n\/\/ \"thick\" or \"thin\" various parts of an object are. The trick behind this technique is to invert the surface normal \n\/\/ and calculate ambient occlusion from inside the surface. That's it ;)\n\/\/\n\/\/ This gives a rough approximation of how occluded part of an object is relative to its surroundings, therefore giving \n\/\/ a sense of thickness.  While this approximation is really not at all accurate - real thickness being relative to an entry \n\/\/ and exit point - the overall result still gives a good sense of thin vs thick. Also, it's possible to remap the value \n\/\/ to something that makes more sense to your needs. For example, if you need a big difference between thick and thin\n\/\/ objects, you can play with the contrasts. It's also recommended to have a base grey value for thickness, to show better\n\/\/ transitions, and not start from pure black. Otherwise, the transition might be too harsh.\n\/\/\n\/\/ I've created this shadertoy because a few people have implemented an interpretation of local thickness, and I didn't find\n\/\/ it complete. Then again, this wouldn't have been possible without the great many shadertoys I've used as reference, \n\/\/ which you can find below. I also have other ideas on how to improve this, and will keep updating it. :)\n\/\/\n\/\/ Just like for any AO calculation, results will vary depending on the scene, and distance-based tolerance factors. \n\/\/\n\/\/ A few parameters below are tweakable, THICKNESS_MAX_DISTANCE will give you the most control. Also, you can get away\n\/\/ with way less samples, especially if your surfaces are not super smooth. \n\/\/\n\/\/ References:\n\/\/\t[1] GDC 2011 \u2013 Approximating Translucency for a Fast, Cheap and Convincing Subsurface Scattering Look\n\/\/\t\thttp:\/\/colinbarrebrisebois.com\/2011\/03\/07\/gdc-2011-approximating-translucency-for-a-fast-cheap-and-convincing-subsurface-scattering-look\/\n\/\/\n\/\/  [2] [Barr\u00e9Brisebois11] Barr\u00e9-Brisebois, Colin and Bouchard, Marc.\u201dReal-Time Approximation of Light Transport in \n\/\/      Translucent Homogenous Media\u201d, GPU Pro 2, Wolfgang Engel, Ed. Charles River Media, 2011.\n\/\/\n\/\/  [3] Translucency in Frostbite 2 engine: https:\/\/www.youtube.com\/watch?v=t7Qw05BUuss\n\/\/\n\/\/ Shadertoy References:\n\/\/  [4] Raymarching - Primitives, by IQ\n\/\/\t    https:\/\/www.shadertoy.com\/view\/Xds3zN\n\/\/  \n\/\/  [5] Alien Coccoons, by XT95\n\/\/      https:\/\/www.shadertoy.com\/view\/MsdGz2\n\/\/  \n\/\/  [6] Shadeaday 6 \/ 4 \/ 2015 - a bunch of rods, by cabbibo\n\/\/      https:\/\/www.shadertoy.com\/view\/4tS3Dt\n\/\/ \n\n\/\/ Constants\nconst float PI = 3.14159265359;\nconst float MAX_TRACE_DISTANCE\t   = 50.0;\nconst int   NUM_TRACE_STEPS \t   = 128;\nconst float INTERSECTION_PRECISION = 0.0001;\nconst float THICKNESS_MAX_DISTANCE = 1.0;\nconst int \tNUM_THICKNESS_SAMPLES  = 128;\nconst float NUM_SAMPLES_INV \t   = 1.0 \/ float(NUM_THICKNESS_SAMPLES);    \n\n\/\/ Function Declarations\nvec2 Scene(vec3 p);\nfloat Hash(float n);\nvec3 RandomSphereDir(vec2 rnd);\nvec3 RandomHemisphereDir(vec3 dir, float i);\n\n\/\/---------------------------------------------------------------------------------------------------------\n\/\/ Local Thickness \n\/\/---------------------------------------------------------------------------------------------------------\nfloat CalculateThickness(vec3 p, vec3 n, float maxDist)\n{\n    float thickness = 0.0;\n    \n    for (int i=0; i < NUM_THICKNESS_SAMPLES; i++)\n    {\n        \/\/ Randomly sample along the hemisphere inside the surface\n        \/\/ To sample inside the surface, flip the normal\n        float l = Hash(float(i)) * maxDist;\n        vec3 rd = normalize(-n + RandomHemisphereDir(-n, l)) * l;\n        \n        \/\/ Accumulate\n        thickness += l + Scene(p + rd).x;\n    }\n\t\n    return clamp(thickness * NUM_SAMPLES_INV, 0.0, 1.0);\n}\n\n\/\/---------------------------------------------------------------------------------------------------------\n\/\/ SDF Functions\n\/\/---------------------------------------------------------------------------------------------------------\nfloat sdPlane(vec3 p)\n{\n\treturn p.y;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) \/ dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nfloat smin(float a, float b, float k)\n{\n    float res = exp(-k * a) + exp(-k * b);\n    return -log(res) \/ k;\n}\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat opBlend(vec2 d1, vec2 d2)\n{\n    return smin(d1.x, d2.x, 8.0);\n}\n\n\/\/---------------------------------------------------------------------------------------------------------\n\/\/ Helper Functions\n\/\/---------------------------------------------------------------------------------------------------------\nfloat Hash(float n)\n{\n    return fract(sin(n) * 3538.5453);\n}\n\nvec3 RandomSphereDir(vec2 rnd)\n{\n\tfloat s = rnd.x * PI * 2.0;\n\tfloat t = rnd.y * 2.0 - 1.0;\n\treturn vec3(sin(s), cos(s), t) \/ sqrt(1.0 + t * t);\n}\n\nvec3 RandomHemisphereDir(vec3 dir, float i)\n{\n\tvec3 v = RandomSphereDir(vec2(Hash(i + 1.0), Hash(i + 2.0)));\n\treturn v * sign(dot(v, dir));\n}\n\nmat3 LookAtMatrix(vec3 ro, vec3 ta, float roll)\n{\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll), 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    return mat3(uu, vv, ww);\n}\n\nvoid Camera(out vec3 camPos, out vec3 camTar, float time, float mouseX)\n{\n    float an = 0.3 + 10.0 * mouseX + PI * sin(time * 0.1);\n\tcamPos = vec3(3.5 * sin(an), 1.0, 3.5 * cos(an));\n    camTar = vec3(0.0, 0.0, 0.0);\n}\n\nfloat Random(vec2 co)\n{\n\treturn fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\/\/--------------------------------\n\/\/ Scene Functions \n\/\/--------------------------------\nvec2 Scene(vec3 p)\n{  \n    float time = 195.0 + 7.0 + iGlobalTime;\n   \tvec2 res = vec2(sdPlane(p - vec3(0.0, -1.0, 0.0)), 0.0);\n    \n    for (int i = 0; i < 15; i++)\n    {\n        vec3 sp = texture2D(iChannel0 , vec2(float(i) \/ 15.0, 0.2 + sin(time * .00001) * 0.1)).xyz;\n        vec3 ep = texture2D(iChannel0 , vec2(float(i) \/ 15.0, 0.4 + sin(time * .00001) * 0.1)).xyz;\n\n        sp.x = Random(sp.xy);\n        sp.y = Random(sp.zy);\n        sp.z = Random(sp.xz);\n        sp = sp * 2.0 - 1.0;\n       \n        ep.x = Random(ep.xy);\n        ep.y = Random(ep.zy);\n        ep.z = Random(ep.xz);\n\t\t\/\/ep = ep * 2.0 - 1.0; \/\/ slightly slanted, for style ;)\n\n    \tres.x = opBlend(res, vec2(sdCapsule(p, sp * 1.5, ep * 1.5, 0.20),  float( i ) + 1.));\n    }\n\n   \treturn res;\n}\n \nvec2 Raymarch(vec3 ro, vec3 rd)\n{\n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.0;\n    \n    for (int i=0; i< NUM_TRACE_STEPS ; i++)\n    {\n        if (h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE)\n            break;\n\t   \t\n        vec2 m = Scene(ro + rd * t);\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if (t < MAX_TRACE_DISTANCE) res = t;\n    if (t > MAX_TRACE_DISTANCE) id =-1.0;\n    \n    return vec2(res, id);\n    \n}\n\nvec3 Normal(vec3 p)\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n\tvec3 n \t = vec3(Scene(p + eps.xyy).x - Scene(p - eps.xyy).x,\n\t    \t\t\tScene(p + eps.yxy).x - Scene(p - eps.yxy).x,\n\t    \t\t\tScene(p + eps.yyx).x - Scene(p - eps.yyx).x);\n\t\n    return normalize(n);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) \/ iResolution.y;\n    vec2 m = 0.5 + iMouse.xy \/ iResolution.xy;\n    \n    \/\/ camera movement\n    vec3 ro, ta;\n    Camera(ro, ta, iGlobalTime, m.x);\n\n    mat3 camMat = LookAtMatrix(ro, ta, 0.0);\n\tvec3 rd = normalize(camMat * vec3(p.xy, 1.3));\n    vec2 res = Raymarch(ro, rd);\n    \n    vec3 col = vec3(0.0);\n        \n    if (res.y > -0.5)\n    {\n    \tvec3 p = ro + rd * res.x;\n        col = vec3(CalculateThickness(p, Normal(p), THICKNESS_MAX_DISTANCE));\n        \n        \/\/ For visualization purposes\n        \/\/ at the end of the day, you can remap this based on your needs\n        col = pow(col*col*col*7.0+0.0125, vec3(1.0 \/ 2.2));        \n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"","description":"","type":"image"}]}}