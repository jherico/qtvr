{"Shader":{"ver":"0.1","info":{"id":"lsBSzc","date":"1414331010","viewed":413,"name":"Minimalistic Clock","username":"4rknova","description":"A very simple clock.","likes":10,"published":3,"flags":0,"tags":["time","clock"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ by Nikos Papadopoulos, 4rknova \/ 2014\n\/\/ Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define DISCREET_SECONDS\n#define AA\t4.\n\n#define PI  3.14159265359\n#define EPS .01\n\nfloat df_disk(in vec2 p, in vec2 c, in float r)\n{\n    return clamp(length(p - c) - r, 0., 1.);\n}\n\nfloat df_circ(in vec2 p, in vec2 c, in float r)\n{\n    return abs(r - length(p - c));\n}\n\nfloat df_line(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) \/ dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\n\nfloat sharpen(in float d, in float w)\n{\n    float e = 1. \/ min(iResolution.y , iResolution.x);\n    return 1. - smoothstep(-e, e, d - w);\n}\n\nvec2 rotate(in vec2 p, in float t)\n{\n    t = t * 2. * PI;\n    return vec2(p.x * cos(t) - p.y * sin(t),\n                p.y * cos(t) + p.x * sin(t));\n}\n\nfloat df_scene(vec2 uv)\n{    \n\tfloat thrs = iDate.w \/ 3600.;\n\tfloat tmin = mod(iDate.w, 3600.) \/ 60.;\n    float tsec = mod(mod(iDate.w, 3600.), 60.);\n    \n    #ifdef DISCREET_SECONDS\n    \ttsec = floor(tsec);\n    #endif\n    \n    vec2 c = vec2(0), u = vec2(0,1);\n    float c1 = sharpen(df_circ(uv, c, .90), EPS * 1.5);\n    float c2 = sharpen(df_circ(uv, c, .04), EPS * 0.5);\n    float d1 = sharpen(df_disk(uv, c, .01), EPS * 1.5);\n    float l1 = sharpen(df_line(uv, c, rotate(u,-thrs \/ 12.) * .60), EPS * 1.7);\n    float l2 = sharpen(df_line(uv, c, rotate(u,-tmin \/ 60.) * .80), EPS * 1.0);\n    float l3 = sharpen(df_line(uv, c, rotate(u,-tsec \/ 60.) * .85), EPS * 0.5);\n    return max(max(max(max(max(l1, l2), l3), c1), c2), d1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy \/ iResolution.xy * 2. - 1.);\n    uv.x *= iResolution.x \/ iResolution.y;\n    vec3 col = vec3(0);\n    \n#ifdef AA\n    \/\/ Antialiasing via supersampling\n    float e = 1. \/ min(iResolution.y , iResolution.x);    \n    for (float i = -AA; i < AA; ++i) {\n        for (float j = -AA; j < AA; ++j) {\n    \t\tcol += df_scene(uv + vec2(i, j) * (e\/AA)) \/ (4.*AA*AA);\n        }\n    }\n#else\n    col += df_scene(uv);\n#endif \/* AA *\/\n    \n\tfragColor = vec4(col, 1);\n}","name":"","description":"","type":"image"}]}}