{"Shader":{"ver":"0.1","info":{"id":"Mtf3z2","date":"1423325395","viewed":297,"name":"Mandel City","username":"dr2","description":"On a faraway island where the architects are mathematicians...","likes":6,"published":3,"flags":0,"tags":["fractal","dda","architecture"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ \"Mandel City\" by dr2 - 2015\n\/\/ License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n\/\/ Branch-free swizzled DDA (Bresenham's algorithm in 3d) suggested\n\/\/ by fb39ca4 and iq; architecture by BBM.\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec3 i = floor (p);\n  vec3 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  float q = dot (i, cHashA3);\n  vec4 t1 = Hashv4f (q);\n  vec4 t2 = Hashv4f (q + cHashA3.z);\n  return mix (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n     mix (mix (t2.x, t2.y, f.x), mix (t2.z, t2.w, f.x), f.y), f.z);\n}\n\nfloat FbmS (vec2 p)\n{\n  float a = 1.;\n  float v = 0.;\n  for (int i = 0; i < 5; i ++) {\n    v += a * (sin (6. * Noisefv2 (p)) + 1.);\n    a *= 0.5;\n    p *= 2.;\n    p *= mat2 (0.8, -0.6, 0.6, 0.8);\n  }\n  return v;\n}\n\nfloat tCur;\nvec3 fcHit, gCel, sunDir, waterDisp, cloudDisp;\nconst float dstFar = 200.;\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col, skyCol, sunCol, p;\n  float ds, fd, att, attSum, d, dDotS;\n  p = ro + rd * (150. - ro.y) \/ rd.y;\n  ds = 0.1 * sqrt (distance (ro, p));\n  fd = 0.003 \/ (smoothstep (0., 10., ds) + 0.1);\n  p.xz *= fd;\n  p.xz += cloudDisp.xz;\n  att = FbmS (p.xz);\n  attSum = att;\n  d = fd;\n  ds *= fd;\n  for (int i = 0; i < 4; i ++) {\n    attSum += FbmS (p.xz + d * sunDir.xz);\n    d += ds;\n  }\n  attSum *= 0.27;\n  att *= 0.27;\n  dDotS = clamp (dot (sunDir, rd), 0., 1.);\n  skyCol = mix (vec3 (0.7, 1., 1.), vec3 (1., 0.4, 0.1), 0.25 + 0.75 * dDotS);\n  sunCol = vec3 (1., 0.8, 0.7) * pow (dDotS, 1024.) +\n     vec3 (1., 0.4, 0.2) * pow (dDotS, 256.);\n  col = mix (vec3 (0.5, 0.75, 1.), skyCol, exp (-2. * (3. - dDotS) *\n     max (rd.y - 0.1, 0.))) + sunCol;\n  attSum = 1. - smoothstep (1., 9., attSum);\n  col = mix (vec3 (0.4, 0., 0.2), mix (col, vec3 (0.2), att), attSum) +\n     vec3 (1., 0.4, 0.) * pow (attSum * att, 3.) * (pow (dDotS, 10.) + 0.5);\n  return col;\n}\n\nfloat WaterHt (vec3 p)\n{\n  p *= 0.05;\n  p += waterDisp;\n  float ht = 0.;\n  const float wb = 1.414;\n  float w = wb;\n  for (int j = 0; j < 7; j ++) {\n    w *= 0.5;\n    p = wb * vec3 (p.y + p.z, p.z - p.y, 2. * p.x) + 20. * waterDisp;\n    ht += w * abs (Noisefv3 (p) - 0.5);\n  }\n  return ht;\n}\n\nvec3 WaterNf (vec3 p, float d)\n{\n  vec2 e = vec2 (max (0.01, 0.001 * d * d), 0.);\n  float ht = WaterHt (p);\n  return normalize (vec3 (ht - WaterHt (p + e.xyy), e.x,\n     ht - WaterHt (p + e.yyx)));\n}\n\nfloat HtMand (vec3 p)\n{\n  vec3 q;\n  vec2 v, w;\n  float h;\n  h = 0.;\n  p.xz *= 0.03;\n  p.x -= 0.85;\n  q = 0.01 * floor (100. * p);\n  if (length (q.xz + vec2 (0.25, 0.)) > 0.45 &&\n     length (q.xz + vec2 (1., 0.)) > 0.2 &&\n     (q.x < 0. || abs (q.z) > 0.04)) {\n    v = q.xz;\n    h = 80.;\n    for (int j = 0; j < 80; j ++) {\n      w = v * v;\n      if (w.x + w.y > 4.) {\n        h = float (j + 1);\n        break;\n      } else v = q.xz + vec2 (w.x - w.y, 2. * v.x * v.y);\n    }\n  }\n  return step (0.3 * h, q.y);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 gDir, gv, s, cp, rdi;\n  float dHit;\n  bool hit;\n  gCel = floor (ro);\n  gDir = sign (rd);\n  gv = max (gDir, 0.) - ro;\n  rdi = 1. \/ rd;\n  for (int i = 0; i < 300; i ++) {\n    s = (gCel + gv) * rdi;\n    cp = step (s, s.yzx);\n    fcHit = cp * (1. - cp.zxy);\n    gCel += gDir * fcHit;\n    hit = (HtMand (gCel) == 0.);\n    if (hit) break;\n  }\n  dHit = hit ? dot ((gCel + gv - gDir) * rdi, fcHit) : dstFar;\n  if (length ((ro + rd * dHit).xz - vec2 (8., 0.)) > 50.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  vec2 fp;\n  float dstHit, fcFac, dw;\n  sunDir = normalize (vec3 (0., 0.05, 1.));\n  cloudDisp = -0.05 * tCur * vec3 (1., 0., 1.);\n  waterDisp = -0.005 * tCur * vec3 (-1., 0., 1.);\n  dstHit = ObjRay (ro, rd);\n  if (rd.y < 0. && dstHit >= dstFar) {\n    dw = - (ro.y - 1.) \/ rd.y;\n    ro += dw * rd;\n    rd = reflect (rd, WaterNf (ro, dw));\n    ro += 0.01 * rd;\n    dstHit = ObjRay (ro, rd);\n  }\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    vn = - fcHit * sign (rd);\n    if (fcHit.y == 0. && gCel.y > 1.) {\n      fp = fract ((fcHit.x != 0.) ? ro.yz : ro.yx);\n      fcFac = 1. - pow (2. * max (abs (fp.x - 0.5), abs (fp.y - 0.5)), 4.);\n      rd = reflect (rd, vn);\n      if (Noisefv3 (2. * gCel + 1. + \n         cos (tCur * vec3 (0.71, 0.87, 1.01))) < 0.5)\n         col = SkyCol (ro, rd);\n      else col = 1.3 * vec3 (0.9, 0.6, 0.);\n      col *= fcFac;\n    } else {\n      if (gCel.y == 0.) col = vec3 (0.05, 0.3, 0.) *\n         (0.7 + 0.3 * Noisefv2 (5. * ro.xz));\n      else if (fcHit.y == 0.) col = vec3 (0.3, 0.2, 0.);\n      else col = vec3 (0.5, 0.4, 0.2) * clamp (0.2 * gCel.y, 0., 1.);\n      col *= (0.3 + 0.7 * max (0., dot (sunDir, vn)));\n    }\n  } else col = SkyCol (ro, rd);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy \/ iResolution.xy - 1.;\n  uv.x *= iResolution.x \/ iResolution.y;\n  tCur = iGlobalTime;\n  mat3 vuMat;\n  vec3 ro, rd;\n  vec2 vEl, vAz;\n  float az, el;\n  az = -0.5 + 0.05 * tCur;\n  el = 0.34;\n  vEl = vec2 (cos (el), sin (el));\n  vAz = vec2 (cos (az), sin (az));\n  vuMat = mat3 (1., 0., 0., 0., vEl.x, - vEl.y, 0., vEl.y, vEl.x) *\n     mat3 (vAz.x, 0., vAz.y, 0., 1., 0., - vAz.y, 0., vAz.x);\n  rd = normalize (vec3 (uv, 3.)) * vuMat;\n  ro = vec3 (0., 0., -120.) * vuMat;\n  ro.xy += vec2 (8., 5.);\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n","name":"","description":"","type":"image"}]}}