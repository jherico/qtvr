{"Shader":{"ver":"0.1","info":{"id":"Msf3Dr","date":"1367701245","viewed":7676,"name":"Near miss!","username":"Dave_Hoskins","description":"This evolved from a 2D to a 3D effect, and is still a mixture of the two.<br\/>Note how it randomly eyeballs you as it swims past! ;)<br\/><br\/>Video of it:-<br\/>http:\/\/www.youtube.com\/watch?v=Dhbhzi5ouh4","likes":27,"published":3,"flags":0,"tags":["2d","3d","raymarch","underwater","bubbles","shark","vr"],"hasliked":0},"renderpass":[{"inputs":[{"id":2,"src":"\/presets\/tex01.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":4,"src":"\/presets\/tex03.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":7,"src":"\/presets\/tex06.jpg","ctype":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":8,"src":"\/presets\/tex07.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Near miss! -  by David Hoskins 2013\n\/\/ Agressive shark swagger.\n\/\/ Uses various inspirations from all over Shadertoy, thank-you folks!\n\/\/ https:\/\/www.shadertoy.com\/view\/Msf3Dr\n\n\/\/ v.1.4\n\/\/ Better front shape and teeth bend. Roving eye pupils.\n\/\/ Shadows.\n\/\/ V.1.3\n\/\/ Teeth!!!\n\/\/ V.1.2\n\/\/ Faster tracing by culling top and bottom rays early.\n\/\/ Bounding box for early distance estimations.\n\/\/ Speed up allows for finer distance field stepping.\n\/\/ Clearer bubbles\n\/\/ V.1.1\n\/\/ New tail and gills. Light on it's back is better. Eye's better positioned and traced.\n\/\/ Swim speed increased for more aggression. Vignette diving mask effect - sort of.\n\/\/ Added up and down lighting to mimic ambient reflections.\n\/\/ Mouth chomp!\n\nconst vec2 sun = vec2(-0.1, 0.6);\nfloat time = iGlobalTime+32.2;\nvec3 lightDir = normalize(vec3(.15,.4, .3));\nfloat swim = (time*.3+sin(time*.5+5.0)*.3)*3.0;\nfloat height;\nfloat pupilPos;\n#define csb(f, con, sat, bri) mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), f*bri)), f*bri, sat), con)\n\n\/\/--------------------------------------------------------------------------------------\n\/\/ Utilities....\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nvec3 Rotate_Y(vec3 v, float angle)\n{\n\tvec3 vo = v; float cosa = cos(angle); float sina = sin(angle);\n\tv.x = cosa*vo.x - sina*vo.z;\n\tv.z = sina*vo.x + cosa*vo.z;\n\treturn v;\n}\n\nvec3 Rotate_Z(vec3 v, float angle)\n{\n\tvec3 vo = v; float cosa = cos(angle); float sina = sin(angle);\n\tv.x = cosa*vo.x - sina*vo.y;\n\tv.y = sina*vo.x + cosa*vo.y;\n\treturn v;\n}\t\n\nfloat _union(float a, float b)\n{\n    return min(a, b);\n}\n\nfloat _union(float a, float b, inout float m, float nm)\n{\n\tbool closer = (a < b);\n\tm = closer ? m : nm;\n\treturn closer ? a : b;\n}\n\nfloat intersect(float a, float b)\n{\n    return max(a, b);\n}\n\nfloat difference(float a, float b)\n{\n    return max(a, -b);\n}\n\nfloat box(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat boxFin(vec3 p, vec3 b)\n{\n\tp=  Rotate_Y(p, -.8);\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat prism(vec3 p, vec2 h) \n{\n\tvec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n\/\/--------------------------------------------------------------------------------------\nvec2 Scene(vec3 p)\n{\n\tfloat f;\n\tp+=vec3(-0.5, 0.0, 3.0-swim);\n\tfloat d;\n\tfloat mat = 1.0;\n\tp.x += sin(p.z*2.0+swim * 5.33333 +2.1)*.07;\n\tp.x  = abs(p.x);\n\t\n\t\/\/ Bounding box early cull...\n\td = box(p+vec3(0.0, -0.14, .0), vec3(.92, .4, 1.3));\n\tif (d > .0) return vec2(d, 0.0);\n\t\n\t\/\/ Body\n\tfloat s = 4.0 + smoothstep(0.5, -1.0, p.z)*4.0;\n\ts = max(s, 4.0 + smoothstep(.3, .75, p.z\/2.0)*4.0);\n\td = sphere(p*vec3(s, s, 1.0), 1.0) \/ 6.0;\n\n\t\/\/ Eyes..\n\tfloat eye = sphere(p + vec3(-.138, 0.01, -0.77), 0.025);\n\tif (eye < 0.008)\n\t{\n\t\td = _union(d, eye);\n\t\tmat = 2.0;\n\t\teye = sphere(p + vec3(-.168+pupilPos, 0.01, -0.77-pupilPos), 0.01);\n\t\tif (eye < 0.008)\n\t\t{\n\t\t\tmat = 4.0;\n\t\t}\n\t}\n\t\n\t\/\/ Top\n\tvec3 fin = p+vec3(0.0, -.15, 0.2);\n\tf = box(fin, vec3(0.005, .3, 1.8));\n\tf = intersect(f, sphere(fin - vec3(0.0, -.29, -.4), .85));\n\tf = difference(f, sphere(fin- vec3(0, 0.5, -2.5), 2.7));\n\td = min(d, f);\n\t\n\t\/\/ Fins...\n\tfin = Rotate_Z(Rotate_Y(p, .4), 0.4)+vec3(-0.1, 0.05, -.4);\n\tf = box(fin, vec3(.5, .005, .082));\n\tf = intersect(f, sphere(fin - vec3(0.0, -.2, -.52), .65));\n\td = min(d, f);\n\n\t\/\/ Tail\n\tf = box(p + vec3(0.0, 0.0, 1.1), vec3(0.002, 0.28, 0.15));\n\tf = intersect(f, sphere(p*vec3(1.0, 1.0, 0.78)   + vec3(0, 0, 1.1), 0.34));\n\tf = difference(f, sphere(p*p*vec3(1.0, 1.0, 0.22) + vec3(0, -0.08, -.21), 0.084));\n\tf = difference(f, sphere(p + vec3(0, 0.0, 1.68), 0.54));\n\td = min(d, f);\n\n\t\/\/ Gills ... fiddly!\t\n\tf = boxFin(p + vec3(-0.223, 0.0, -.48), vec3(0.0004, 0.04, 0.005));\n\tf = min(f, boxFin(p + vec3(-0.219, 0.0, -.50), vec3(0.0004, 0.04, 0.005)));\n\tf = min(f, boxFin(p + vec3(-0.216, 0.0, -.52), vec3(0.0004, 0.04, 0.005)));\n\tf = min(f, boxFin(p + vec3(-0.214, 0.0, -.54), vec3(0.0004, 0.04, 0.005)));\n\td = mix(d, f, smoothstep(-0.006, .003, d-f));\n\n\t\/\/ Mouth difference box, done last to jump over the teeth detection...\t\n\tf = box(p+vec3(0.0, 0.11+height*.5, -1.), vec3(1.5, 0.0+height, 0.37));\n\tif (f > 0.0)\n\t\treturn vec2(d, mat);\n\t\/\/ Do in mouth stuff..\n\tmat = 3.0;\n\td = difference(d, f);\n\tif (p.x < .144 && p.x >-.144)\n\t{\n\t\tvec3 teeth = p;\n\t\tteeth.z += sin(p.x*p.x*7.6);\n\t\tteeth += vec3(0.05, .12+height, -.84+height*3.0);\n\t\tteeth.x = mod(p.x, .015);\n\t\tf = prism(teeth, vec2(.01, .005));\n\t\tif (f< 0.005) mat = 2.0;\n\t\td = min(d, f);\n\t\t\n\t\tteeth = p;\n\t\tteeth.z += sin(p.x*p.x*7.5);\n\t\tteeth += vec3(0.025, .11-height*.2, -.8);\n\t\tteeth.x = mod(teeth.x, .015);\n\t\tteeth.y = -teeth.y;\n\t\tf = prism(teeth, vec2(.01, .005));\n\t\tif (f< 0.005) mat = 2.0;\n\t\td = min(d, f);\n\t}\n\n\treturn vec2(d, mat);\n}\n\n\/\/--------------------------------------------------------------------------------------\nvec4 Trace(vec3 ro, vec3 rd, out float hit)\n{\n\tconst float minStep = 0.0001;\n    hit = 0.0;\n\tvec2 ret = vec2(0.0, 0.0);\n    vec3 pos = ro;\n\tfloat dist = 0.0;\n    for(int i=0; i < 118; i++)\n    {\n\t\tif (hit != 0.0 || pos.y < -.30 || pos.y > .46 || dist > 7.0)continue;\n\t\tpos = ro + dist * rd;\n\t\tret = Scene(pos);\n\t\tif (ret.x < 0.005) \n\t\t{\n\t\t\thit = ret.y;\n\t\t}\n\t\tif (ret.y >= 2.0)\n\t\t{\n\t\t\tdist += ret.x * .35;\n\t\t}else\n\t\t{\n\t\t\tdist += ret.x * .7;\n\t\t}\n    }\n    return vec4(pos, ret.y);\n}\n\n\/\/--------------------------------------------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tvec3 eps = vec3(0.001,0.0,0.0);\n\treturn normalize(vec3(Scene(p+eps.xyy).x-Scene(p-eps.xyy).x,\n\t\t\t\t\t\t  Scene(p+eps.yxy).x-Scene(p-eps.yxy).x,\n\t\t\t\t\t\t  Scene(p+eps.yyx).x-Scene(p-eps.yyx).x ));\n}\n\n\/\/--------------------------------------------------------------------------------------\nfloat Bubble(vec2 loc, vec2 pos, float size)\n{\n\tvec2 v2 = loc-pos;\n\tfloat d = dot(v2, v2)\/size;\n\tif (d > 1.0) return pow(max(0.0,1.5-d), 3.0) *5.0;\n\td = pow(d, 6.0)*.85;\n\t\n\t\/\/ Top bright spot...\n\tv2 = loc-pos+vec2(-size*7.0, +size*7.0);\n\td += .8 \/ max(sqrt((dot(v2, v2))\/size*8.0), .3);\n\t\/\/ Back spot...\n\tv2 = loc-pos+vec2(+size*7.0, -size*7.0);\n\td += .2 \/ max((dot(v2, v2)\/size*4.0), .3);\n\treturn d;\n}\n\n\/\/--------------------------------------------------------------------------------------\nfloat Shadow( in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float dt = 0.03;\n    float t = .01;\n    for( int i=0; i<10; i++ )\n    {\n\t\tif( t < .15)\n\t\t{\n\t\t\tfloat h = Scene(ro + rd * t).x;\n\t\t\tres = min( res, 2.2*h\/t );\n\t\t\tt += .005;\n\t\t}\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\/\/--------------------------------------------------------------------------------------\nvec3 GetColour(vec4 p, vec3 n, vec3 org, vec3 dir)\n{\n\tvec3 colour = vec3(0.0);\n\tfloat lum = clamp(dot(n, lightDir), 0.0, 1.0);\n\tif (p.w < 1.5)\n\t{\n\t\tfloat v = clamp(-(n.y-.1)*6.2, 0.3, 1.0);\n\t\tv+=.35;\n\t\tcolour = vec3(v*.8, v*.9, v*1.0) * lum;\n\t}else if (p.w < 2.5)\t\t\n\t{\n\t\t\/\/ Simple eye...\n\t\tcolour = vec3(.2) + vec3(.34, .34, .2) * lum;\n\t}else if (p.w < 3.5)\t\t\n\t{\t\n\t\t\/\/ Inside mouth..\n\t\tcolour = vec3(.5, .1, .0) * lum;\n\t}else\n\t{\t\/\/ Pupil...\n\t\tcolour = vec3(.15, .15, .15);\n\t}\n\n\tcolour += vec3(0.0, .01,.13) * abs(n.y);\n\tvec2 wat = p.xz*5.3;\n\twat +=  (texture2D(iChannel0, (wat*5.0+time*.04)*.1, 2.0).z -\n\t\t\t texture2D(iChannel1, wat*.3-time*.03, 2.0).y) * .4;\n\tfloat\ti = texture2D(iChannel0, wat* .025, 0.0).x;\n\n\ti = min(pow(max(0.0, i-.2), 1.0) * 1.0, .6)*.3;\n\tcolour += vec3(i*.5, i, i)*max(n.y, 0.0);\n\t\n\tfloat shad = Shadow(p.xyz, lightDir);\n\tcolour = mix(vec3(0.1),colour, min(shad+.4, 1.0));\n\n\tfloat dis = length(org-p.xyz);\n\tfloat fogAmount = clamp(max((dis-.5),0.0)*.15, 0.0, 1.0);\n\treturn mix(colour, vec3(.05, .31, .49), fogAmount );\n}\n\n\n\/\/--------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 col;\t\n\tvec2 uv = (fragCoord.xy \/ iResolution.xy) - vec2(.5);\n\tuv.x*=iResolution.x\/iResolution.y;\n\tvec3 dir = normalize(vec3(uv, -1.4));\n\t\n\tvec3 pos = vec3(1.3, sin(time+4.3)*.18-.05, sin(-time*.15)*5.0-1.35);\n\tfloat rot = max(-pos.z-.4, 0.0)*.4;\n\t\/\/ Get out of the way...\n\tfloat f = smoothstep(-2.9, -1.5, pos.z)*.046;\n\tf -= smoothstep(-1.5, 1.5, pos.z)*.05;\n\theight = max(f, sin(time*4.0 +1.4)*0.03);\n\n\tpupilPos = hash(floor(time*3.0)+1.0)*0.02;\n\tf = hash(floor(time*3.0)+2.0)*0.02;\n\tfloat s = pow(fract(time*3.0), 4.0);\n\tpupilPos = mix(pupilPos, f, s);\n\n\tpos.x -= smoothstep(-1.15, .0, pos.z);\n\trot = smoothstep(0.0, 1.5, rot)*2.9;\n\tdir = Rotate_Y(dir, -rot);\n\n\t\/\/ Keep up with the shark...\n\tpos.z += swim;\n\n\t\/\/ Sun...\n\tfloat i = max(0.0, 1.0-length(sun-uv));\n\tcol = vec3(pow(i, 1.9), pow(i, 1.0), pow(i, .8)) * 1.3;\n\t\n\t\/\/ Water depth colour...\n\tcol = mix(col, vec3(0.0, .25, .45), ((1.0-uv.y)*.45) * 1.8);\n\n\tif (uv.y >= 0.0)\n\t{\n\t\t\/\/ Add water ripples...\n\t\tfloat d = (3.0-pos.y) \/ -uv.y;\n\t\tvec2 wat = (dir * d).xz-pos.xz;\n\t\twat +=  (texture2D(iChannel2, (wat*.03+time*.01)*.1, 1.0).z -\n\t\t\t\t texture2D(iChannel3, wat*.02-time*.01, .0).y) * .4;\n\t\ti = texture2D(iChannel3, wat* .02, 0.0).x;\n\t\tcol += vec3(i) * max(abs(uv.y), 0.0);\n\t}\n\telse\t\t\n\t{\n\t\t\/\/ Do floor stuff...\n\t\tfloat d = (-1.0-pos.y) \/ uv.y;\n\t\tvec2 wat = (dir * d).xz+pos.xz;\n\t\tvec3 sand = texture2D(iChannel3, wat* .1).xyz * 1.5  + \n\t\t\t\t\ttexture2D(iChannel0, wat* .6).xyz;\n\t\t\/\/ Shadow blob...\n\t\tsand -= clamp(.5-length((wat+vec2(-0.5, 3.2-swim))*vec2(1.4, .6)), 0.0, 1.0)*3.;\n\t\t\n\t\tf = ((-uv.y-.1)*2.45) * .4;\n\t\tf = clamp(f, 0.0, 1.0);\n\t\t\n\t\tcol = mix(col, sand, f);\n\t}\n\n\tfloat hit = 0.0;\n\tvec4 loc = Trace(pos, dir, hit);\n\tif (hit > 0.0)\n\t{\n\t\tvec3 norm = GetNormal(loc.xyz);\n\t\tcol = GetColour(loc, norm, pos, dir);\n\t}\n\t\n\t\/\/ Light beams...\n\tvec2 beam = dir.xy;\t\n\tbeam.x *= (-beam.y-.6)*.8;\n\tfloat bright = \n\t\t\t\t- sin(beam.y * 12.0 + beam.x * 13.0 + time *.530) *.1 \n\t\t\t\t- sin(beam.y + beam.x * 17.0 + time *.60) *.1\n\t\t\t\t- cos(              + beam.x * 13.0 - time *.40) *.1 \n\t\t\t\t- sin(              - beam.x * 52.23 + time * 1.8) * .1;\n\tbright *= max(0.0, texture2D(iChannel2, (uv*.3-swim*.04), 5.0).y);\n\tcol += vec3(clamp(bright,0.0,1.0)) *.6;\n\t\n\t\/\/ Bubbles...\n\tfor (float i = 0.0; i < 50.0; i+=1.0)\n\t{\n\t\tfloat t = time+1.27;\n\t\tfloat f = floor((t+2.0) \/ 4.0);\n\t\tvec2 pos = vec2(.4, -.9) + vec2(0.0, mod(t+(i\/50.0)+hash(i+f)*.7, 4.0));\n\t\tpos.x += hash(i)*.7 * (uv.y+.6);\n\t\t\n\t\tpos += texture2D(iChannel3, (uv*.3-time*.1+(i\/80.0)), 4.0).z * .05;\n\t\tfloat d = Bubble(pos, uv, .002*hash(i-f)+.00015);\n\t\td *= hash(i+f+399.0) *.3+.08;\n\t\tcol = mix(col, vec3(.6+hash(f*323.1+i)*.4, 1.0, 1.0), d);\n\t}\n\t\/\/ Contrast, saturation and brightness...\n\tcol = csb(col, 1.1, 1.05, 1.22);\n\t\/\/ Vignette...\n\tuv = ((fragCoord.xy \/ iResolution.xy) * 2.0) - 1.0;\n\tcol = mix(col,vec3(.0), abs(uv.x)*abs(uv.y));\n\n\t\/\/ Fade in...\n\tcol *= smoothstep( 0.0, 2.5, iGlobalTime );\n\tfragColor = vec4(col, 1.0);\n}\n","name":"","description":"","type":"image"}]}}