{"Shader":{"ver":"0.1","info":{"id":"MsBGWm","date":"1389223076","viewed":2017,"name":"Spinner 3","username":"TekF","description":"Recreation of Matthew DiVito's animated gif design_takes_time: http:\/\/cargocollective.com\/matthewdivito","likes":39,"published":3,"flags":0,"tags":["conetracing"],"hasliked":0},"renderpass":[{"inputs":[{"id":2,"src":"\/presets\/tex01.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Ben Quantock 2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\n\/\/#define BLOB \/\/ alternate shape\n\n\nconst float tau = 6.28318530717958647692;\n\/\/ anti aliased \/ blurred distance field tracer\n\n\/\/ trace a cone vs the distance field\n\/\/ approximate pixel coverage with a direction and proportion\n\/\/ this will cope correctly with grazing the edge of a surface, which my focal blur trick didn't\n\n\/\/ Gamma correction\n#define GAMMA (2.2)\n\nvec3 ToGamma( in vec3 col )\n{\n\t\/\/ convert back into colour values, so the correct light will come out of the monitor\n\treturn pow( col, vec3(1.0\/GAMMA) );\n}\n\nvec3 viewSpaceRay;\n\n\/\/ Set up a camera looking at the scene.\n\/\/ origin - camera is positioned relative to, and looking at, this point\n\/\/ distance - how far camera is from origin\n\/\/ rotation - about x & y axes, by left-hand screw rule, relative to camera looking along +z\n\/\/ zoom - the relative length of the lens\nvoid CamPolar( out vec3 pos, out vec3 ray, in vec3 origin, in vec2 rotation, in float distance, in float zoom, in vec2 fragCoord )\n{\n\t\/\/ get rotation coefficients\n\tvec2 c = vec2(cos(rotation.x),cos(rotation.y));\n\tvec4 s;\n\ts.xy = vec2(sin(rotation.x),sin(rotation.y)); \/\/ worth testing if this is faster as sin or sqrt(1.0-cos);\n\ts.zw = -s.xy;\n\n\t\/\/ ray in view space\n\tray.xy = fragCoord.xy - iResolution.xy*.5;\n\tray.z = iResolution.y*zoom;\n\tray = normalize(ray);\n\t\n\tviewSpaceRay = ray;\n\t\n\t\/\/ rotate ray\n\tray.yz = ray.yz*c.xx + ray.zy*s.zx;\n\tray.xz = ray.xz*c.yy + ray.zx*s.yw;\n\t\n\t\/\/ position camera\n\tpos = origin - distance*vec3(c.x*s.y,s.z,c.x*c.y);\n}\n\n\nvec2 Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec4 rg = texture2D( iChannel0, (uv+0.5)\/256.0, -100.0 );\n\treturn mix( rg.yw, rg.xz, f.z );\n}\n\n\nfloat DistanceField( vec3 pos )\n{\n#ifdef BLOB\n\tfloat a = atan(pos.x,pos.z)+iGlobalTime*.5;\n\tpos.xz = length(pos.xz)*vec2(sin(a),cos(a));\n\treturn .5*(length(pos)-2.0+(Noise(pos).x+Noise(pos*2.0+iGlobalTime*vec3(0,1.0,0)).x\/2.0)*1.0);\n#else\n\t\/\/ rotational symmettry\n\tconst float slice = tau\/12.0;\n\tfloat a = abs(fract(atan(pos.x,pos.z)\/slice+iGlobalTime*2.5)-.5)*slice;\n\tpos.xz = length(pos.xz)*vec2(sin(a),cos(a));\n\t\n\t\/\/ symettry in y\n\tpos.y = abs(pos.y);\n\t\n\treturn dot(pos,normalize(vec3(1,1,1))) - 1.0;\n#endif\n}\n\n\nvec3 Normal( vec3 pos, float rad )\n{\n\tvec2 delta = vec2(0,rad);\n\tvec3 grad;\n\tgrad.x = DistanceField( pos+delta.yxx )-DistanceField( pos-delta.yxx );\n\tgrad.y = DistanceField( pos+delta.xyx )-DistanceField( pos-delta.xyx );\n\tgrad.z = DistanceField( pos+delta.xxy )-DistanceField( pos-delta.xxy );\n\treturn normalize(grad);\n}\n\n\nvec3 Sky( vec3 ray )\n{\n\t\/\/ combine some vague coloured shapes\n\tvec3 col = vec3(0);\n\t\n\tcol += vec3(.8,.1,.13)*smoothstep(.2,1.0,dot(ray,normalize(vec3(1,1,3))));\n\tcol += vec3(.1,.1,.05)*Noise(ray*2.0+vec3(0,1,5)*iGlobalTime).x;\n\tcol += 3.0*vec3(1,1.7,3)*smoothstep(.8,1.0,dot(ray,normalize(vec3(3,3,-2))));\n\tcol += 2.0*vec3(2,1,3)*smoothstep(.9,1.0,dot(ray,normalize(vec3(3,8,-2))));\n\t\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat zoom = 1.5;\n\tvec3 pos, ray;\n\tCamPolar( pos, ray, .04*vec3(Noise(vec3(3.0*iGlobalTime,0,0)).xy,0), vec2(.22,0)+vec2(.7,tau)*iMouse.yx\/iResolution.yx, 6.0, zoom, fragCoord );\n\n\t\/\/ radius of cone to trace, at 1m distance;\n\tfloat coneRad = .7071\/(iResolution.y*zoom);\n\t\n\tfloat coverage = -1.0;\n\tvec3 coverDir = vec3(0); \/\/ this could be a single angle, or a 2D vector, since it's perp to the ray\n\t\n\tfloat aperture = .05;\n\tfloat focus = 5.0;\n\t\n\tvec3 col = vec3(0);\n\tfloat t = .0;\n\tfor ( int i=0; i < 100; i++ )\n\t{\n\t\tfloat rad = t*coneRad + aperture*abs(t-focus);\n\n\t\tvec3 p = pos + t*ray;\n\t\tfloat h = DistanceField( p );\n\t\t\n\t\tif ( h < rad )\n\t\t{\n\t\t\t\/\/ shading\n\t\t\tvec3 normal = Normal(p, rad);\n\t\t\t\n\t\t\tvec3 albedo = vec3(.2);\n\t\t\t\n\t\t\t\/\/ lighting\n\t\t\tvec3 ambient = vec3(.1)*smoothstep(.7,2.0,length(p.xz)+abs(p.y));\n\t\t\tvec3 directional = 3.0*vec3(1,.1,.13)*max(dot(normal,normalize(vec3(-2,-2,-1))),.0);\n\t\t\tdirectional *= smoothstep(.5,1.5,dot(p,normalize(vec3(1,1,-1))));\n\n\t\t\tfloat fresnel = pow( 1.0-abs(dot( normal, ray )), 5.0 );\n\t\t\tfresnel = mix( .03, 1.0, fresnel );\n\t\t\t\n\t\t\tvec3 reflection = Sky( reflect(ray,normal) );\n\t\t\t\n\t\t\tvec3 sampleCol = mix( albedo*(ambient+directional), reflection, vec3(fresnel) );\n\t\t\t\n\t\t\t\/\/ compute new coverage\n\t\t\tfloat newCoverage = -h\/rad;\n\t\t\tvec3 newCoverDir = normalize(normal-dot(normal,ray)*ray);\n\n\t\t\t\/\/ allow for coverage at different angles\n\t\t\t\/\/ very dubious mathematics!\n\t\t\t\/\/ basically, coverage adds to old coverage if the angles mean they don't overlap\n\t\t\tnewCoverage += (1.0+coverage)*(.5-.5*dot(newCoverDir,coverDir));\n\t\t\tnewCoverage = min(newCoverage,1.0);\n\n\t\t\t\/\/ S-curve, to imitate coverage of circle\n\t\t\tnewCoverage = sin(newCoverage*tau\/4.0);\/\/smoothstep(-1.0,1.0,newCoverage)*2.0-1.0;\n\n\t\t\tif ( newCoverage > coverage )\n\t\t\t{\n\t\t\t\t\n\t\t\t\t\/\/ combine colour\n\t\t\t\tcol += sampleCol*(newCoverage-coverage)*.5;\n\t\t\t\t\n\t\t\t\tcoverDir = normalize(mix(newCoverDir,coverDir,(coverage+1.0)\/(newCoverage+1.0)));\n\t\t\t\tcoverage = newCoverage;\n\t\t\t}\n\t\t}\n\t\t\n\t\tt += max( h, rad*.5 ); \/\/ use smaller values if there are echoey artefacts\n\t\t\n\t\tif ( h < -rad || coverage > 1.0 )\n\t\t\tbreak;\n\t}\n\t\n\tcol += (1.0-coverage)*.5*Sky(ray);\n\n\t\/\/ grain\n\tvec3 grainPos = vec3(fragCoord.xy*.8,iGlobalTime*30.0);\n\tgrainPos.xy = grainPos.xy*cos(.75)+grainPos.yx*vec2(-1,1)*sin(.75);\n\tgrainPos.yz = grainPos.yz*cos(.5)+grainPos.zy*vec2(-1,1)*sin(.5);\n\tvec2 filmNoise = Noise(grainPos*.5);\n\tcol *= mix( vec3(1), mix(vec3(1,.5,0),vec3(0,.5,1),filmNoise.x), .1*pow(filmNoise.y,1.0) );\n\n\t\/\/ dust\n\tvec2 uv = fragCoord.xy\/iResolution.y;\n\tfloat T = floor( iGlobalTime * 60.0 );\n\tvec2 scratchSpace = mix( Noise(vec3(uv*8.0,T)).xy, uv.yx+T, .8 )*1.0;\n\tfloat scratches = texture2D( iChannel1, scratchSpace ).r;\n\t\n\tcol *= vec3(1.0)-.5*vec3(.3,.5,.7)*pow(1.0-smoothstep( .0, .1, scratches ),2.0);\n\t\n\tfragColor.rgb = ToGamma(col);\n\tfragColor.w = 1.0;\n}","name":"","description":"","type":"image"}]}}