{"Shader":{"ver":"0.1","info":{"id":"XtlGzN","date":"1419336794","viewed":485,"name":"Sprite Encoding Tutorial","username":"4rknova","description":"An attempt to explain sprite encoding in simple terms.","likes":9,"published":3,"flags":0,"tags":["tutorial","sprites","encoding"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ by Nikos Papadopoulos, 4rknova \/ 2014\n\/\/ Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/* Sprite Encoding Explained\n\nThe following is a simple, comprehensive guide that explains in\nplain terms how the technique works. I started writing the shader\nas a learning exercise for myself and later on realised that it \nmight help others as well. I made an attempt to break down the \ntechnique into simple steps and deal with each step separately.\nIf you find that I omitted something important, made an error or\nhaven't explained something in the best possible way, please do\ncomment and let me know.\n\nThe Bigger Picture\n------------------\nFor the time being we will limit our efforts to encoding monochrome\nsprites. A pixel in a monochrome bitmap can be either on or off \n(black or white) which means that we only require a single bit of \nmemory to store each pixel's value. The size of an signed integer\nin glsl 1.3 or later is 32-bits (ref. M1) which in theory means \nthat we can use a single integer to store 31 pixels in the form of\na literal. In practice since we are going to be using floats and due \nto the nature of the mathematical operations involved, we can only \nuse 24 bits (M3).\n\nEncoding\n--------\nOur goal here is to break the sprite into small blocks of 24 pixels\nand then encode each block with an integral value. There are a few\noptions regarding the exact dimensions of the blocks.\n\nConsider the following 4x6 bitmap which contains the character 'l' \nand is part of a very simple font sprite.\n\n  [Bitmap]     Binary Value\n   0100        010001000100010001000110\n   0100\n   0100        Int Literal\n   0100        4473926\n   0100\n   0110\n\nAn alternative way to deal with encoding is do it on the fly. The\nfollowing macro will encode a 1x16 block with 2bits per pixel. \n\nQ(i,a,b,c,d,e,f,g,h) if(y==i)m=(a+4.*(b+4.*(c+4.*(d+4.*(e+4.*(f+4.*(g+h*4.)))))));\n\nThe first argument (i) is the row index which selects the row to \nsample from when using multiple blocks, 'y' is the current row \nindex and 'm' contains the muxed row data.\n\nFor each pixel with index n we multiply by 4 (n times) to shift the\npixel data 2 bits to the left at a time and then blit the value in \nplace by summation.\n\nDecoding\n--------\nNow that we know how to encode the sprite blocks, we need to figure \nout how to decode them as well. Normally we would do this by shifting\nthe bits to the right and then using a bitwise AND operation along with\na mask to extract a single bit or a group of bits. In c that would look \nsomething like:\n\nint b = (v >> k) & 1;\n\nwhere v contains the literal that encodes the block data and k is the \nindex of the single bit we wish to extract. The problem with the above\nis that bitwise operators are not available in GLSL, so we need to find\nanother way of extracting the bit values.\n\nWe'll break the problem down to two steps.\n\na. Shifting: This is easy to solve as all we have to do is divide by 2\nto shift once to the right, or the nth power of 2 to shift by n bits.\n\nb. Masking: For positive values of x, the following is true (ref: M2): \n\nx % (2^n) == x & ((2^n) - 1)\n\nTherefore for n=1, we get:\n\nx % 2 == x & 1 \n\nwhich will extract the first bit.\n\nCombining the two together, we can retrieve the nth bit from the encoded \ndata using the following formula: (v\/(2^n))%2 \n\nThe Grid\n--------\nThe only thing that remains to be solved is how to determine which \nbit needs to be extracted for the pixel that is being shaded. The\nsolution to this problem is simple. We quantize the screen space to\na scalable grid and then use the cell coordinates to determine the \nindex of the bit to extract. As we are potentially dealing with \nmultidimensional arrays, the correct index should be calculated.\n\nThe Block Size\n--------------\nAs mentioned above, there are a few options regarding the dimensions\nof the sprite blocks. We could use 1x24, 4x6 or 6x4 blocks or even \nadd a 3rd dimension in a 4x3x2 arrangement to store a second frame \nas well for animation purposes. Equally, we could use a 4x5 block \nand reserve the remaining 4 bits to store some sort of metadata.\n\nAdding Color\n------------\nIn order to add colors we can use multiple bits per pixel to store \na palette index or a threshold value. The process is exactly the same\nwith the only difference that we now need to extract 2 or more bits \ninstead of a single one (ref: S1). Keep in mind that we can only use \npowers of 2 with modulo when masking.\n\nOther Tricks\n------------\n* For sprites that are symmetric, we can mirror the pixels. (ref: S4)\n\nExamples\n--------\nUse the EXAMPLE variable below to switch between the available examples.\n1. A single 4x6 monochrome block.\n2. Multiple 1x16 blocks with 2bits per pixel for palette indexing and\n   sprite mirroring.\n\nReferences\n----------\nM1. https:\/\/www.opengl.org\/wiki\/Data_Type_%28GLSL%29\nM2. http:\/\/en.wikipedia.org\/wiki\/Modulo_operation\nM3. http:\/\/en.wikipedia.org\/wiki\/IEEE_754-1985\nS1. https:\/\/www.shadertoy.com\/view\/4dfXWj Music - Mario\nS2. https:\/\/www.shadertoy.com\/view\/Msj3zD Super Mario Bros\nS3. https:\/\/www.shadertoy.com\/view\/ldjGzt FlappyBird\nS4. https:\/\/www.shadertoy.com\/view\/MsjGz1 Mario Mushroom\nS5. https:\/\/www.shadertoy.com\/view\/4sjGD1 The Legend of Zelda\nS6. https:\/\/www.shadertoy.com\/view\/4sXGDH Lemminvade\nS7. https:\/\/www.shadertoy.com\/view\/ldSGRW 25 Boxes and a Tunnel\nS8. https:\/\/www.shadertoy.com\/view\/lssGDj Ascii Art\nS9. https:\/\/www.shadertoy.com\/view\/ls2GRt Flappy Bird\n\n*\/\n\n#define DISPLAY_GRID 1\n#define EXAMPLE      2\n#define BACKGROUND   vec3(.15, .20, .25)\n\n#define _ 0. \/\/ Color Palette Index 0\n#define B 1. \/\/ Color Palette Index 1\n#define D 2. \/\/ Color Palette Index 2\n#define O 3. \/\/ Color Palette Index 3\n#define Q(i,a,b,c,d,e,f,g,h) if(y==i)m=(a+4.*(b+4.*(c+4.*(d+4.*(e+4.*(f+4.*(g+h*4.)))))));\n\nvec2 grid(vec2 p, vec2 sz)\n{\n    return floor(p * sz);    \n}\n\n\/\/ Sprite 1\nvec4 l(vec2 p, vec2 scale, vec3 color)\n{    \n    vec2  gv = grid(p, scale); \/\/ The grid guide\n    float dt = 4473926.;       \/\/ The encoded sprite\n    \n    vec4 res = vec4(0);\n    \n    if (gv.x >= 0. && gv.y >= 0. &&\n        gv.x <= 3. && gv.y <= 5.) {\n        \n        #if (DISPLAY_GRID == 1)\n        \tres = vec4(mod(gv.x + gv.y, 2.) * .05 + BACKGROUND, 1.);\n        #endif\n        \n        \tfloat idx = gv.y * 4. + 3. - gv.x;      \/\/ Calculate the bit index\n        \tfloat bit = mod(dt \/ pow(2., idx), 2.); \/\/ Decode\n        \tbit = floor(bit);                       \/\/ Sharpen\n        \tif (bit > 0.) res = vec4(color, 1.);\n    }\n\n    return res;\n}\n\n\n\/\/ Sprite 2\n\/\/ Artwork from Abstract_Algorithm's - Mario mushroom\n\/\/ https:\/\/www.shadertoy.com\/view\/MsjGz1\nvec3 mushroom(vec2 p, vec2 scale)\n{\n    vec3 res = BACKGROUND;\n\n    vec2 gv = grid(p, scale); \/\/ The grid guide\n    \n    if (gv.x >= 0. && gv.y >= 0. &&\n        gv.x <= 15. && gv.y <= 15.) {\n        \n        #if (DISPLAY_GRID == 1)\n        \tres = vec3(mod(gv.x + gv.y, 2.) * .05 + BACKGROUND);\n        #endif\n        \n        \/\/ Indexing is upside down.\n        int y = int(scale.y - gv.y - 5.);\n\n    \tfloat m = 0.;\n\t\tQ(0, _,_,_,_,_,B,B,B)\n\t\tQ(1, _,_,_,B,B,B,D,O)\n\t\tQ(2, _,_,B,B,D,D,D,O)\n\t\tQ(3, _,B,B,O,D,D,O,O)\n\t\tQ(4, _,B,D,O,O,O,O,O)\n\t\tQ(5, B,B,D,D,O,O,D,D)\n\t\tQ(6, B,D,D,D,O,D,D,D)\n\t\tQ(7, B,D,D,D,O,D,D,D)\n\t\tQ(8, B,D,D,O,O,D,D,D)\n\t\tQ(9, B,O,O,O,O,O,D,D)\n\t\tQ(10,B,O,O,B,B,B,B,B)\n        Q(11,B,B,B,B,D,D,B,D)\n\t\tQ(12,_,B,B,D,D,D,B,D)\n\t\tQ(13,_,_,B,D,D,D,D,D)\n\t\tQ(14,_,_,B,B,D,D,D,D)\n\t\tQ(15,_,_,_,B,B,B,B,B)\n        \n    \tfloat ldx = 15. - gv.x; \/\/ Calculate the left  bit index\n        float rdx = gv.x;       \/\/ Calculate the right bit index\n        float bit = 0.;\n        \n        if (gv.x >= 8.)\tbit = mod(m \/ pow(4., ldx), 4.); \/\/ Decode\n        else            bit = mod(m \/ pow(4., rdx), 4.); \/\/ Mirror\n    \tbit = floor(bit);                                \/\/ Sharpen    \n    \t\n        \/\/ Colorize\n             if (bit > 2.) res = vec3(1,0,0);\n        else if (bit > 1.) res = vec3(1);\n        else if (bit > 0.) res = vec3(0);\n    }\n    \n    return res;\n}\n\nvec3 example_1(vec2 p)\n{\n    vec4 r = l(p - vec2(0.35,.1), vec2(99.), vec3(1,0,0))\n           + l(p - vec2(0.44,.1), vec2(70.), vec3(1,1,0))\n           + l(p - vec2(0.55,.1), vec2(40.), vec3(0,1,0))\n           + l(p - vec2(0.70,.1), vec2(30.), vec3(0,1,1))\n    \t   + l(p - vec2(0.90,.1), vec2(20.), vec3(0,0,1))\n           + l(p - vec2(1.20,.1), vec2(10.), vec3(1,1,1));\n    \n    return r.w == 1. ? r.xyz : BACKGROUND;\n}\n\nvec3 example_2(vec2 p)\n{\n    return mushroom(p - vec2(.5, .1), vec2(20.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy \/ iResolution.xy \n            * vec2(iResolution.x \/ iResolution.y, 1.);\n    \n    vec3 res = BACKGROUND;\n    \n    \t if (EXAMPLE==1) res = example_1(uv);\n    else if (EXAMPLE==2) res = example_2(uv);\n    \n    fragColor = vec4(res, 1);\n}","name":"","description":"","type":"image"}]}}