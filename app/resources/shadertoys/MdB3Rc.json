{"Shader":{"ver":"0.1","info":{"id":"MdB3Rc","date":"1393409984","viewed":2621,"name":"Physics - no collisions","username":"iq","description":"My own version of some bouncing balls. Basic parabolic kinematics, as you learnt them at school as a kid: x(t) = xo + v\u00b7t + \u00bd\u00b7a\u00b7t\u00b2. I think mu6k did this before in Shadertoy, but this is my own quick take on it I guess.","likes":37,"published":3,"flags":0,"tags":["2d","physics"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat hash1( float p ) { return fract(sin(p)*43758.5453); }\nvec2  hash2( float p ) { vec2 q = vec2( p, p+123.123 ); return fract(sin(q)*43758.5453); }\nvec3  hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\n\n\/\/ draw a disk with motion blur\nvec3 diskWithMotionBlur( vec3 col, in vec2 uv, in vec3 sph, in vec2 cd, in vec3 sphcol, in float alpha )\n{\n\tvec2 xc = uv - sph.xy;\n\tfloat a = dot(cd,cd);\n\tfloat b = dot(cd,xc);\n\tfloat c = dot(xc,xc) - sph.z*sph.z;\n\tfloat h = b*b - a*c;\n\tif( h>0.0 )\n\t{\n\t\th = sqrt( h );\n\t\t\n\t\tfloat ta = max( 0.0, (-b - h)\/a );\n\t\tfloat tb = min( 1.0, (-b + h)\/a );\n\t\t\n\t\tif( ta < tb ) \/\/ we can comment this conditional, in fact\n\t\t    col = mix( col, sphcol, alpha*clamp(2.0*(tb-ta),0.0,1.0) );\n\t}\n\n\treturn col;\n}\n\nvec2 GetPos( in vec2 p, in vec2 v, in vec2 a, float t )\n{\n\treturn p + v*t + 0.5*a*t*t;\n}\nvec2 GetVel( in vec2 p, in vec2 v, in vec2 a, float t )\n{\n\treturn v + a*t;\n}\n\n\/\/ intersect a disk moving in a parabolic trajecgory with a line\/plane. \n\/\/ sphere is |x(t)|-R\u00b2=0, with x(t) = p + v\u00b7t + \u00bd\u00b7a\u00b7t\u00b2\n\/\/ plane is <x,n> + k = 0\nfloat iPlane( in vec2 p, in vec2 v, in vec2 a, float rad, vec3 pla )\n{\n\tfloat A = dot(a,pla.xy);\n\tfloat B = dot(v,pla.xy);\n\tfloat C = dot(p,pla.xy) + pla.z - rad;\n\tfloat h = B*B - 2.0*A*C;\n\tif( h>0.0 )\n\t\th = (-B-sqrt(h))\/A;\n\treturn h;\n}\n\nconst vec2 acc = vec2(0.01,-9.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = -1.0 + 2.0*fragCoord.xy \/ iResolution.xy;\n\tp.x *= iResolution.x\/iResolution.y;\n\tfloat w = iResolution.x\/iResolution.y;\n\n    vec3 pla0 = vec3( 0.0,1.0,1.0);\n    vec3 pla1 = vec3(-1.0,0.0,  w);\t\n    vec3 pla2 = vec3( 1.0,0.0,  w);\n\t\t\n\tvec3 col = vec3(0.0) + (0.15 + 0.05*p.y);\n\t\n\tfor( int i=0; i<8; i++ )\n    {\n        \/\/ start position\t\t\n\t\tfloat id = float(i);\n\n\t    float time = mod( iGlobalTime + id*0.5, 4.8 );\n\t    float sequ = floor( (iGlobalTime+id*0.5)\/4.8 );\n\t\tfloat life = time\/4.8;\n\n\t\tfloat rad = 0.05 + 0.1*hash1(id*13.0 + sequ);\n\t\tvec2 pos = vec2(-w,0.8) + vec2(2.0*w,0.2)*hash2( id + sequ );\n\t\tvec2 vel = (-1.0 + 2.0*hash2( id+13.76 + sequ ))*vec2(8.0,1.0);\n\n        \/\/ integrate\n\t\tfloat h = 0.0;\n\t\t\/\/ 10 bounces. \n        \/\/ after the loop, pos and vel contain the position and velocity of the ball\n        \/\/ after the last collision, and h contains the time since that collision.\n\t    for( int j=0; j<10; j++ )\n\t    {\n\t\t\tfloat ih = 100000.0;\n\t\t\tvec2 nor = vec2(0.0,1.0);\n\n\t\t\t\/\/ intersect planes\n\t\t\tfloat s;\n\t\t\ts = iPlane( pos, vel, acc, rad, pla0 ); if( s>0.0 && s<ih ) { ih=s; nor=pla0.xy; }\n\t\t\ts = iPlane( pos, vel, acc, rad, pla1 ); if( s>0.0 && s<ih ) { ih=s; nor=pla1.xy; }\n\t\t\ts = iPlane( pos, vel, acc, rad, pla2 ); if( s>0.0 && s<ih ) { ih=s; nor=pla2.xy; }\n\t\t\t\n            if( ih<1000.0 && (h+ih)<time )\t\t\n\t\t\t{\n\t\t\t\tvec2 npos = GetPos( pos, vel, acc, ih );\n\t\t\t\tvec2 nvel = GetVel( pos, vel, acc, ih );\n\t\t\t\tpos = npos;\n\t\t\t\tvel = nvel;\n\t\t\t\tvel = 0.75*reflect( vel, nor );\n\t\t\t\tpos += 0.01*vel;\n                h += ih;\n\t\t\t}\n        }\n\t\t\n        \/\/ last parabolic segment\n\t\th = time - h;\n\t\tvec2 npos = GetPos( pos, vel, acc, h );\n\t\tvec2 nvel = GetVel( pos, vel, acc, h );\n\t\tpos = npos;\n\t\tvel = nvel;\n\n        \/\/ render\n\t\tvec3 scol = 0.5 + 0.5*sin( hash1(id)*2.0 -1.0 + vec3(0.0,2.0,4.0) );\n\t\tfloat alpha = smoothstep(0.0,0.1,life)-smoothstep(0.8,1.0,life);\n\t\tcol = diskWithMotionBlur( col, p, vec3(pos,rad), vel\/24.0, scol, alpha );\n    }\n\n    col += (1.0\/255.0)*hash3(p.x+13.0*p.y);\n\n\tfragColor = vec4(col,1.0);\n}","name":"","description":"","type":"image"}]}}