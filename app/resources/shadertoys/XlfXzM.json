{"Shader":{"ver":"0.1","info":{"id":"XlfXzM","date":"1436473084","viewed":2959,"name":"Reactive Sphere","username":"glk7","description":"A reactive ray marched sphere. The typical sphere perturbed by a couple ceiled sin waves based on some frequencies of the music played.","likes":31,"published":3,"flags":64,"tags":["raymarch","reactive","sphere"],"hasliked":0},"renderpass":[{"inputs":[{"id":1030,"src":"https:\/\/soundcloud.com\/official-toska\/chalk-teeth-pre-release-version","ctype":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by genis sole - 2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Enable more representative frequency analysis.\n\/\/#define CF \n\n\/\/ Toggle non-reactive version.\n\/\/ #define S\n\nvec4 freqs = vec4(0.6, 0.7, 0.2, 0.2);\n\nvec4 FreqAnalysis() {\n#ifdef S\n    return freqs;\n#endif\n    \n    vec4 sy = vec4(0.0);    \n    \n#ifdef CF\n    \/\/ 0.25 \/ (512 \/ 4) = 0.001953125\n    for(float i = 0.0; i < 0.25; i += 0.001953125) {\n   \t\tsy.x += texture2D(iChannel0, vec2(i, 0.0)).x;\n    }\n    \n    for(float i = 0.25; i < 0.5; i += 0.001953125) {\n   \t\tsy.y += texture2D(iChannel0, vec2(i, 0.0)).x;\n    }\n    \n    for(float i = 0.5; i < 0.75; i += 0.001953125) {\n   \t\tsy.z += texture2D(iChannel0, vec2(i, 0.0)).x;\n    }\n    \n    for(float i = 0.75; i <= 1.0; i += 0.001953125) {\n   \t\tsy.w += texture2D(iChannel0, vec2(i, 0.0)).x;\n    }\n    sy *= vec4(0.0078125); \/\/ 1 \/ (512 \/ 4) = 0.0078125\n    \n#else\n    \n    sy.x = texture2D(iChannel0, vec2(0.0, 0.0)).x;\n\tsy.y = texture2D(iChannel0, vec2(0.33, 0.0)).x;\n    sy.z = texture2D(iChannel0, vec2(0.66, 0.0)).x;\n    sy.w = texture2D(iChannel0, vec2(1.0, 0.0)).x;\n    \n#endif\n    \n    return sy;\n    \/\/return step(0.01, iChannelTime[0])*sy + (1.0 - step(0.01, iChannelTime[0]))*freqs;\n}\n\n\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 \/ 3.0, 2.0 \/ 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) \/ (6.0 * d + e)), d \/ (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat sin3(in vec3 p) {\n\treturn (sin(p.x) + sin(p.y) + sin(p.z));\n}\n\nfloat noise(in vec3 p) {\n    float j = iGlobalTime * 0.045;\n    float v = (sin3((p+vec3(j*7.0, j*2.3, j*1.0)) * 10.0) * freqs.w +\n               sin3((p+vec3(j*3.0, j*1.2, j*0.4)) * 8.0) * freqs.z +\n               sin3((p+vec3(j*2.4, j*0.6, j*2.6)) * 6.0) * freqs.y +\n               sin3((p+vec3(j*1.4, j*5.8, j*1.9)) * 4.0) * freqs.x) * 0.25;\n    \/\/return 0.0;\n    \n    v = abs(v);\n    float f = floor(v*10.0);\n    \n    v = clamp((smoothstep(0.0, 1.0, mix(0.1, 0.2, v*10.0-f)) + f)* 0.1, 0.0, 1.0);\n    return v;\n}\n\n\/\/ Taken from http:\/\/iquilezles.org\/www\/articles\/palettes\/palettes.htm\nvec3 ColorPalette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nbool RaySphereIntersection(in vec3 ro, in vec3 rd, in vec3 c, in float r, out vec3 p0, out vec3 p1) {\n    p0 = vec3(0.0);\n    p1 = vec3(0.0);\n    \n   \tvec3 oc = ro - c;\n    float poc = dot(rd, oc);\n    \n    float sloc = dot(oc, oc);\n    float test = poc*poc - sloc + r*r;\n        \n    if (test < 0.0) return false;\n    \n    float sqt = sqrt(test);\n    float d0 = -poc - sqt;\n    float d1 = -poc + sqt;\n    \n\tp0 = ro + d0*rd;\n    p1 = ro + d1*rd;\n    return true;\n}\n\nvec3 SphereNormal(in vec3 d, in float r, in float e) {\n    float theta = atan(d.y,d.x) ;\n    float phy = acos(d.z);\n    \n    vec3 dy0 = vec3(cos(theta+e)*sin(phy), sin(theta+e)*sin(phy), cos(phy));\n    vec3 dy1 = vec3(cos(theta-e)*sin(phy), sin(theta-e)*sin(phy), cos(phy));\n\n    vec3 dx0 = vec3(cos(theta)*sin(phy+e), sin(theta)*sin(phy+e), cos(phy+e));\n    vec3 dx1 = vec3(cos(theta)*sin(phy-e), sin(theta)*sin(phy-e), cos(phy-e));\n    \n    float ny0 = noise(dy0*r);\n    float ny1 = noise(dy1*r);\n    float nx0 = noise(dx0*r);\n    float nx1 = noise(dx1*r);\n    \n    dy0 *= r + ny0;\n    dy1 *= r + ny1;\n    dx0 *= r + nx0;\n    dx1 *= r + nx1;\n    \n    return normalize(cross(dy0 - dy1, dx1 - dx0));\n}\n\nbool RayMarchPerturbedSphere(in vec3 ro, in vec3 rd, in vec3 c, in float r, in float br, \n                             out vec3 n, out vec3 sd) {\n    n = vec3(0.0);\n    sd = vec3(0.0);\n    \n    vec3 bp0 = vec3(0.0);\n    vec3 bp1 = vec3(0.0);\n    bool bres = RaySphereIntersection(ro, rd, c, br, bp0, bp1);\n    if (!bres) return false;\n    \n    vec3 p0 = vec3(0.0); \n    vec3 p1 = vec3(0.0);\n    bool res = RaySphereIntersection(ro, rd, c, r, p0, p1); \n    \n    float dist = float(res)*length(p0 - bp0) + (1.0-float(res)) * length(bp0 - bp1);\n\t\/\/float dist = length(bp0 - bp1);\n    const float sc = 128.0;\n    const float invsc = 1.0 \/ sc;\n    float s = dist * invsc;\n    \n    bool ret = false;\n    vec3 pn = vec3(0.0);\n    for (float d = 0.0; d < sc; ++d) {\n    \tpn = (bp0 + d*s*rd) - c;\n\t\t\n        sd = normalize(pn) * r;\n        float h = length(pn) - r - s;\n        \n        float h0 = noise(sd);\n        if (h0 > h) {\n            ret = true;\n            break;\n        } \n    }\n    \n    n = SphereNormal(normalize(pn), r, s);\n    return ret;\n}\n\n\n\/\/ Based on this: http:\/\/iquilezles.org\/www\/articles\/rmshadows\/rmshadows.htm        \nfloat ShadowFactor(in vec3 sd, in vec3 ld, in vec3 c, in float r, in float br) {\n    float w = noise(sd);\n    vec3 ro = c + (normalize(sd) * (w+r));\n    \n    vec3 bp0 = vec3(0.0);\n    vec3 bp1 = vec3(0.0);\n    bool bres = RaySphereIntersection(ro, -ld, c, br, bp0, bp1);\n    \n    vec3 p0 = vec3(0.0);\n    vec3 p1 = vec3(0.0);\n    bool res = RaySphereIntersection(ro, -ld, c, r, p0, p1);\n    \n    float dist = min(length(ro - bp0)+ float(!bres) * 10000.0, \n                     length(ro - p0) + float(!res) * 10000.0);\n    \n    const float sc = 128.0;\n    const float invsc = 1.0 \/ sc;\n    float s = dist * invsc;\n    \n    float dmin = 1.0;\n    \n    for (float d = 0.0; d < sc; ++d) {\n    \tvec3 pn = (ro + d*s*-ld) - c;\n\t\t\n        sd = normalize(pn) * r;\n        float h = length(pn) - r + s;\n        \n        float h0 = noise(sd);\n        if (h0 > h) {\n            dmin = 0.0;\n            break;\n        }\n        \n        dmin = min(dmin, 4.0*(h-h0)\/(d*s));\n    }\n    \n    return clamp(dmin, 0.0, 1.0);\n    \n}\n\n\nvec3 GetColor(vec3 sd) {\n    float n = noise(sd);\n    vec3 c = ColorPalette(n, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5),\n                             vec3(1.0, 1.0, 0.5), vec3(0.4, 0.3, 0.5));\n    \n    c = rgb2hsv(c);\n    c.y += 0.30;\n    c.z += 0.1;\n    c = hsv2rgb(c);\n    \n    return c;\n    \n}\n\nvec3 CameraRay(vec2 fragCoord, float n) {\n    float a = 1.0\/max(iResolution.x, iResolution.y);\n    \n    return normalize(vec3((fragCoord - iResolution.xy*0.5)*a, n));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rd = CameraRay(fragCoord, 1.0);\n    \n    vec3 sc = vec3(0.0, 0.0, 10.0);\n    float sr = 1.0;\n \n    vec3 n = vec3(0.0);\n    vec3 sd = vec3(0.0);\n    if (RaySphereIntersection(vec3(0.0), rd, sc, sr+1.0, n, sd)) {\n        freqs = FreqAnalysis();\n    }\n    \n    bool hit = RayMarchPerturbedSphere(vec3(0.0), rd, sc, sr, sr+1.0, n, sd);\n    \n    vec3 color = vec3(0.05);\n    if (hit) {\n        \n        float w = max(max(freqs.x,freqs.y) , max(freqs.z, freqs.w));\n        vec2 nM = vec2(sin(iGlobalTime*1.4), cos(iGlobalTime*1.2));\n        \n        vec3 l = normalize(vec3(-(nM.x*2.0 -1.0), -(nM.y*2.0 - 1.0), -0.9 + w*3.0));\n        \n        float sf = ShadowFactor(sd, l, sc, sr, sr+1.0);\n        \n        color = GetColor(sd);\n        vec3 diff = color * max(dot(-l, n), 0.0 ) * sf * 0.95;\n        vec3 amb = color * 0.05;\n        \n        color = diff;\n    \tcolor += amb;\n    }\n    \n    fragColor = vec4(pow(color, vec3(0.55)), 1.0);\n}","name":"","description":"","type":"image"}]}}