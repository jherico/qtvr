{"Shader":{"ver":"0.1","info":{"id":"4tsGzf","date":"1423916689","viewed":1321,"name":"Texture variation I","username":"iq","description":"Avoiding texture repetition by using <a href=\"https:\/\/www.shadertoy.com\/view\/Xd23Dh\"  class=\"regular\" target=\"_blank\">Voronoise<\/a>: a small texture can be used to generate infinite variety instead of tiled repetition. t doesn't work with automatic mipmapping though.","likes":15,"published":3,"flags":0,"tags":["2d","voronoi","texture","voronoise"],"hasliked":0},"renderpass":[{"inputs":[{"id":8,"src":"\/presets\/tex07.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ One way to avoid texture tile repetition one using one small texture to cover a huge area.\n\/\/ Based on Voronoise (https:\/\/www.shadertoy.com\/view\/Xd23Dh), a random offset is applied to\n\/\/ the texture UVs per Voronoi cell. Distance to the cell is used to smooth the transitions\n\/\/ between cells.\n\n\/\/ It doesn't work with automatic mipmapping - one should compute derivatives by hand.\n\nvec3 hash3( vec2 p ) { return fract(sin(vec3( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)), dot(p,vec2(419.2,371.9)) ))*43758.5453); }\n\nvec3 textureNoTile( in vec2 x, float v )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\t\n\tvec3 va = vec3(0.0);\n\tfloat wt = 0.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n\t\tvec3 o = hash3( p + g );\n\t\tvec2 r = g - f + o.xy;\n\t\tfloat d = dot(r,r);\n        float w = pow( 1.0 - smoothstep(0.0,2.0,dot(d,d)), 1.0 + 16.0*v );\n        vec3 c = texture2D( iChannel0, .2*x + v*o.zy, -16.0 ).xyz;\n\t\tva += w*c;\n\t\twt += w;\n    }\n\t\n    return va\/wt;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xx;\n\t\n\tfloat f = smoothstep( 0.4, 0.6, sin(iGlobalTime    ) );\n    float s = smoothstep( 0.4, 0.6, sin(iGlobalTime*0.5) );\n        \n\tvec3 col = textureNoTile( (18.0 + 60.0*s)*uv, f ).zyx;\n\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}