{"Shader":{"ver":"0.1","info":{"id":"ltlSzs","date":"1439147365","viewed":756,"name":"GoldenJCVD","username":"GrosPoulet","description":"Be warned: this is the biggest looting in history of Shadertoy!!!<br\/>90% of code come from aiekick's \"Mike Solo\":<br\/><a href=\"https:\/\/www.shadertoy.com\/view\/lls3Dr\" class=\"regular\" target=\"_blank\">https:\/\/www.shadertoy.com\/view\/lls3Dr<\/a><br\/>Remaining code stolen from IQ, as usual :-)","likes":3,"published":3,"flags":0,"tags":["raymarching"],"hasliked":0},"renderpass":[{"inputs":[{"id":36,"src":"\/presets\/vid03.webm","ctype":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Credits go to aiekick (\"Mike Solo\": https:\/\/www.shadertoy.com\/view\/lls3Dr) & IQ\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ defines\n\/\/ The higher, the more bumpy \n#define DISPLACEMENT 0.02\n\/\/ Time in second(s) \n#define ANIMATE_DURATION 10.0\n\/\/ Zoom level (1.0 = no zoom)\n#define ZOOM 1.0\n\/\/ Radius = 0 : flat box\n#define BORDER_RADIUS 0.1\n\/\/ 0.0 : dim colors 1 : brightful\n#define COLOR_STRENGTH 0.45\n\/\/ Material components (R G B )\n#define MATERIAL vec3(0.02,0.02,0.0) \/\/gold\n\/\/ Set > 0.0 to mix texture color with material color\n#define TEXTURE_MIX 0.0 \/\/0.0 means no mix at all\n\/\/ Light direction\n#define LIGHT_DIR vec3(0.65, 0.57, 1.0) \n\/\/Light components (R G B)\n#define LIGHT vec3(1.0, 1.0, 1.0) \/\/white\n\/\/ The higher, the more reflections\n#define SPECULAR 0.19\n#define GAMMA 4.6\n\n\n#define pi 3.1415926535897932384626433832795\n#define hfpi 1.5707963267948966192313216916398\n#define PI pi\n#define HFPI hfpi\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ methods\nfloat Animate()\n{\n\tfloat i = floor(iGlobalTime \/ ANIMATE_DURATION);\n    float r = (iGlobalTime - ANIMATE_DURATION * i) \/ ANIMATE_DURATION;\n    return ( mod(i, 2.0) == 0.0 ? r : 1.0 - r );\n}\n\nfloat AnimateDisplacement()\n{\n    return max(Animate()*DISPLACEMENT, 0.01);\n}\n\nvec3 AnimateLightDir()\n{\n\tfloat a = Animate();\n \treturn vec3(a, a, 1.0);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0 - h);\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n    return length(max(abs(p) - b, 0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p) - b, 0.0)) - r;\n}\n\nvec3 GetTex2D( vec2 p )\n{\n\treturn texture2D(iChannel0, 0.5*(vec2(1.0) + ZOOM*vec2(p.x, p.y))).rgb;\n}\n\n\/\/use texture's RGB to build map\nvec2 map( vec3 p )\n{\n    \/\/ displacement \n    float prec = AnimateDisplacement(); \/\/the higher, the more bumpy \n\tfloat disp = 1.0 - smoothstep(0.0, 1.0, dot(GetTex2D(p.xy), vec3(prec)));\n    p.z += disp;\n  \n    vec2 res = vec2(length(p));\n    \n    \/\/ box\n    \/\/float box = udBox(p, vec3(1.0, 1.0, 1.0));\n    float box = udRoundBox(p, (1.0 - BORDER_RADIUS)*vec3(1.0), BORDER_RADIUS);\n   \tres.x = smin(res.x, box, 1.0);\n    \n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.002, 0.0, 0.0);\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    float m = -1.0;\n\tfloat mint = 20.0;\n\n\tfloat maxd = min(20.0, mint);\n\tfloat precis = 0.0;\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat d = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        if( h<precis || t>maxd )\n\t\t\tbreak;\n\t\telse\n\t\t{\n\t\t\tt += h;\n\t\t\tvec2 res = map( ro + rd*t );\n\t\t\th = res.x;\n\t\t\td = res.y;\n\t\t}\n    }\n\n    if( t<maxd && t<mint )\n\t{\n\t\tmint = t;\n\t\tm = d;\n\t}\n\n    return vec3( mint, m, m );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n        h = map(ro + rd*t).x;\n        res = min( res, smoothstep(0.0, 1.0, k*h\/t) );\n\t\tt += clamp( h, 0.02, 2.0 );\n\t\tif( res<0.01 || t>10.0 ) \n\t\t\tbreak;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n\/\/main method\nvec3 GoldenFossil(vec2 uv)\n{\n\tvec2 p = 2.0*uv - vec2(1.0); \n    \n    \/\/-----------------------------------------------------\n    \/\/ camera\n    \/\/-----------------------------------------------------\n\n\tvec3 ro = vec3(0.0, 0.0, 0.99);\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n\n    \/\/ camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0, 1.0, 0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n\t\/\/ create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + ww );\n\n    \/\/-----------------------------------------------------\n\t\/\/ render\n    \/\/-----------------------------------------------------\n\n\t\/\/ light direction\n\tvec3 lightDir = normalize(LIGHT_DIR);\n\n\tvec3 col = COLOR_STRENGTH*vec3(1.0);\n\n\t\/\/ raymarch\n    vec3 tmat = intersect(ro,rd);\n    if( tmat.z > -0.5 )\n    {\n        \/\/ geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormal(pos);\n\t\tvec3 ref = reflect( rd, nor );\n\n\t\t\/\/ texture\n\t\tvec3 colTex = GetTex2D(pos.xy);\n\t\t\n        \/\/ materials\n\t\tvec4 mate = TEXTURE_MIX*vec4(colTex, 1.0) + vec4(MATERIAL, 1.0);\/\/*vec4(GetTex2D(SCALE*pos.xy),1.0);\n\t\tmate = min(mate, vec4(1.0));\n\t\tvec2 mate2 = vec2(1.0);\n\t\t        \n\t\t\/\/ lighting\n\t\tfloat occ = (0.5 + 0.5*nor.y)*mate2.y;\n        float amb = 0.10;\n\t\tfloat bou = clamp(-nor.y, 0.0, 1.0);\n\t\tfloat dif = max(dot(nor,lightDir), 0.0);\n        float bac = max(0.3 + 0.7*dot(nor,-lightDir),0.0);\n\t\tfloat sha = 0.0; if( dif>0.01 ) sha = softshadow( pos + 0.01*nor, lightDir, 0.0005, 32.0 );\n        float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 2.0 );\n        float spe = 1.0*max( 0.0, pow( clamp( dot(lightDir,reflect(rd,nor)), 0.0, 1.0), mate2.x*3.0 ) );\n\t\t\n\t\t\/\/ lights\n\t\tvec3 lin = LIGHT;\n        lin += 2.0*dif*vec3(1.00,1.00,1.00)*pow(vec3(sha, sha, sha),vec3(1.0,1.2,1.5));\n\t\tlin += 1.0*amb*vec3(0.30,0.30,0.30)*occ;\n\t\tlin += 2.0*bou*vec3(0.40,0.40,0.40)*mate2.y;\n\t\tlin += 4.0*bac*vec3(0.40,0.30,0.25)*occ;\n        lin += 1.0*fre*vec3(1.00,1.00,1.00)*2.0*mate.w*(0.5+0.5*dif*sha)*occ;\n\t\tlin += 1.0*spe*vec3(1.00,1.00,1.00)*occ*mate.w*dif*sha;\n\n\t\t\/\/ surface-light interaction\n\t\tcol = mix(col, 15.0*mate.xyz* lin + SPECULAR*vec3(2.5, 2.5, 2.5)*mate.w*pow(spe,8.0)*sha, 0.5);\n\t}\n\n\t\/\/-----------------------------------------------------\n\t\/\/ postprocessing\n    \/\/-----------------------------------------------------\n    \/\/ gamma\n\tcol = pow( clamp(col,0.0,1.0), GAMMA*vec3(0.45, 0.45, 0.45) );\n\n    return col;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;   \n    \n    \/\/pan\n  \tuv -= iMouse.xy \/ iResolution.xy;\n\t\t\n\tvec3 col = GoldenFossil( uv );\n\t\n    \/\/ Set the final fragment color.\n\tfragColor = vec4(col,1.0);\n}","name":"","description":"","type":"image"}]}}