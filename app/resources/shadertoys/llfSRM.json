{"Shader":{"ver":"0.1","info":{"id":"llfSRM","date":"1435164802","viewed":811,"name":"gamma detection test","username":"hornet","description":"A test for gamma-levels that includes three tests rather than just the usual 50% grey.<br\/>On most monitors, a power-function does not appear to be adequate correction.<br\/>(see also https:\/\/www.shadertoy.com\/view\/Xdl3DM )","likes":4,"published":3,"flags":0,"tags":["gamma","gammacorrection","brightness"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"float PrintValue(const in vec2 vStringCharCoords, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces);\n\n\/*\n\/\/note: uniform pdf rand [0;1[\nfloat hash12n(vec2 p)\n{\n\tp  = fract(p * vec2(5.3987, 5.4421));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4307);\n}\n\/\/noise\nfloat pattern( vec2 fc, float v )\n{\n    return step( hash12n(fc) \/ v, 1.0 );\n}\n*\/\n\n\n\/\/const float s=0.2;\n\/\/const vec3 bias=vec3(s,s,1.0);\nvec3 pattern( vec2 fc, float v )\n{\n    \/\/note: 2x2 ordered dithering, ALU-based (omgthehorror)\n\tvec2 ij = floor(mod( fc.xy, vec2(2.0,2.0) ));\n\tfloat idx = ij.x + 2.0*ij.y;\n\tvec4 m = step( abs(vec4(idx)-vec4(0.0,1.0,2.0,3.0)), vec4(0.5,0.5,0.5,0.5) ) * vec4(0.75,0.25,0.00,0.50);\n\tfloat d = m.x+m.y+m.z+m.w;\n\n    float ret = step(d,v);\n    return vec3( ret, ret, ret );  \/\/ * bias;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 outcol = vec4(0.0);\n\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n\n    \/\/rect\n    \/\/bool v0 = (fract(3.0 * uv.x) > 0.25) && (fract(3.0 * uv.x) < 0.75);\n    \/\/bool v1 = (uv.y > 0.3) && (uv.y < 0.6);\n    \/\/bool ref = v0 && v1;\n    \n    \/\/circle\n    vec2 aspect = vec2( 1.0, iResolution.y \/ iResolution.x );\n    bool ref = length((vec2(1.0\/6.0,0.5)-uv)*aspect) < 0.11 ||\n               length((vec2(3.0\/6.0,0.5)-uv)*aspect) < 0.11 || \n        \t   length((vec2(5.0\/6.0,0.5)-uv)*aspect) < 0.11;\n    \n    if ( uv.x < 1.0\/3.0 )\n\t\toutcol.rgb = ref ? vec3(0.25,0.25,0.25) : pattern(fragCoord,0.15);\n    else if ( uv.x < 2.0\/3.0 )\n        outcol.rgb = ref ? vec3(0.50,0.50,0.50) : pattern(fragCoord,0.30);\n    else\n        outcol.rgb = ref ? vec3(0.75,0.75,0.75) : pattern(fragCoord,0.60);\n\n    float gamma = 1.5 + iMouse.x\/iResolution.x;\n    outcol = pow( outcol, vec4(1.0 \/ (1.5 + iMouse.x\/iResolution.x)) );\n    \/\/outcol = pow( outcol, vec4(1.0 \/ 2.00) ); \/\/dell 2410\n    \/\/outcol = pow( outcol, vec4(1.0 \/ 2.15) ); \/\/NEC ps272w\n    \n    outcol.rgb = mix( outcol.rgb, vec3(0.0), PrintValue( (uv-vec2(0.43,0.9))*40.0, gamma, 1.0, 2.0) );\n    \n\tfragColor = outcol;\n}\n\n\n\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\n\n\/\/---------------------------------------------------------------\n\/\/ number rendering code below by P_Malin\n\/\/\n\/\/ https:\/\/www.shadertoy.com\/view\/4sf3RN\n\/\/---------------------------------------------------------------\n\n\nfloat InRect(const in vec2 vUV, const in vec4 vRect)\n{\n\tvec2 vTestMin = step(vRect.xy, vUV.xy);\n\tvec2 vTestMax = step(vUV.xy, vRect.zw);\t\n\tvec2 vTest = vTestMin * vTestMax;\n\treturn vTest.x * vTest.y;\n}\n\nfloat SampleDigit(const in float fDigit, const in vec2 vUV)\n{\n\tconst float x0 = 0.0 \/ 4.0;\n\tconst float x1 = 1.0 \/ 4.0;\n\tconst float x2 = 2.0 \/ 4.0;\n\tconst float x3 = 3.0 \/ 4.0;\n\tconst float x4 = 4.0 \/ 4.0;\n\t\n\tconst float y0 = 0.0 \/ 5.0;\n\tconst float y1 = 1.0 \/ 5.0;\n\tconst float y2 = 2.0 \/ 5.0;\n\tconst float y3 = 3.0 \/ 5.0;\n\tconst float y4 = 4.0 \/ 5.0;\n\tconst float y5 = 5.0 \/ 5.0;\n\n\t\/\/ In this version each digit is made of up to 3 rectangles which we XOR together to get the result\n\t\n\tvec4 vRect0 = vec4(0.0);\n\tvec4 vRect1 = vec4(0.0);\n\tvec4 vRect2 = vec4(0.0);\n\t\t\n\tif(fDigit < 0.5) \/\/ 0\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y1, x2, y4);\n\t}\n\telse if(fDigit < 1.5) \/\/ 1\n\t{\n\t\tvRect0 = vec4(x1, y0, x2, y5); vRect1 = vec4(x0, y0, x0, y0);\n\t}\n\telse if(fDigit < 2.5) \/\/ 2\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x0, y3, x2, y4); vRect2 = vec4(x1, y1, x3, y2);\n\t}\n\telse if(fDigit < 3.5) \/\/ 3\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x0, y3, x2, y4); vRect2 = vec4(x0, y1, x2, y2);\n\t}\n\telse if(fDigit < 4.5) \/\/ 4\n\t{\n\t\tvRect0 = vec4(x0, y1, x2, y5); vRect1 = vec4(x1, y2, x2, y5); vRect2 = vec4(x2, y0, x3, y3);\n\t}\n\telse if(fDigit < 5.5) \/\/ 5\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y3, x3, y4); vRect2 = vec4(x0, y1, x2, y2);\n\t}\n\telse if(fDigit < 6.5) \/\/ 6\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y3, x3, y4); vRect2 = vec4(x1, y1, x2, y2);\n\t}\n\telse if(fDigit < 7.5) \/\/ 7\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x0, y0, x2, y4);\n\t}\n\telse if(fDigit < 8.5) \/\/ 8\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y1, x2, y2); vRect2 = vec4(x1, y3, x2, y4);\n\t}\n\telse if(fDigit < 9.5) \/\/ 9\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y3, x2, y4); vRect2 = vec4(x0, y1, x2, y2);\n\t}\n\telse if(fDigit < 10.5) \/\/ '.'\n\t{\n\t\tvRect0 = vec4(x1, y0, x2, y1);\n\t}\n\telse if(fDigit < 11.5) \/\/ '-'\n\t{\n\t\tvRect0 = vec4(x0, y2, x3, y3);\n\t}\t\n\t\n\tfloat fResult = InRect(vUV, vRect0) + InRect(vUV, vRect1) + InRect(vUV, vRect2);\n\t\n\treturn mod(fResult, 2.0);\n}\n\nconst float kCharBlank = 12.0;\nconst float kCharMinus = 11.0;\nconst float kCharDecimalPoint = 10.0;\n\nfloat PrintValue(const in vec2 vStringCharCoords, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n\tfloat fAbsValue = abs(fValue);\n\t\n\tfloat fStringCharIndex = floor(vStringCharCoords.x);\n\t\n\tfloat fLog10Value = log2(fAbsValue) \/ log2(10.0);\n\tfloat fBiggestDigitIndex = max(floor(fLog10Value), 0.0);\n\t\n\t\/\/ This is the character we are going to display for this pixel\n\tfloat fDigitCharacter = kCharBlank;\n\t\n\tfloat fDigitIndex = fMaxDigits - fStringCharIndex;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.5))\n\t{\n\t\tif(fDigitIndex > fBiggestDigitIndex)\n\t\t{\n\t\t\tif(fValue < 0.0)\n\t\t\t{\n\t\t\t\tif(fDigitIndex < (fBiggestDigitIndex+1.5))\n\t\t\t\t{\n\t\t\t\t\tfDigitCharacter = kCharMinus;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\t\t\n\t\t\tif(fDigitIndex == -1.0)\n\t\t\t{\n\t\t\t\tif(fDecimalPlaces > 0.0)\n\t\t\t\t{\n\t\t\t\t\tfDigitCharacter = kCharDecimalPoint;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(fDigitIndex < 0.0)\n\t\t\t\t{\n\t\t\t\t\t\/\/ move along one to account for .\n\t\t\t\t\tfDigitIndex += 1.0;\n\t\t\t\t}\n\n\t\t\t\t\/\/ This is inaccurate - I think because I treat each digit independently\n\t\t\t\t\/\/ The value 2.0 gets printed as 2.09 :\/\n\t\t\t\tfloat fDigitValue = (fAbsValue \/ (pow(10.0, fDigitIndex)));\n\t\t\t\tfDigitCharacter = mod(floor(fDigitValue+0.0001), 10.0);\n\t\t\t}\t\t\n\t\t}\n\t}\n\n\tvec2 vCharPos = vec2(fract(vStringCharCoords.x), vStringCharCoords.y);\n\n\treturn SampleDigit(fDigitCharacter, vCharPos);\t\n}","name":"","description":"","type":"image"}]}}