{"Shader":{"ver":"0.1","info":{"id":"4tBGRm","date":"1427504885","viewed":969,"name":"true pinball physics","username":"archee","description":"Click on the shader-screen to define start location. <br\/>I actually coded this in my head during the long flight home from NVScene, California, 2015<br\/>","likes":24,"published":3,"flags":0,"tags":["2d","physics"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"int showSolution = 0; \/\/ set to one to show the final horizontal velocity of the ball et given starting locations\nfloat solution;\nint MotionBlur = 1; \nfloat bounceRatio = 0.5;\nfloat gravity = -0.5;\nfloat ti;\nvec2 sp;\nfloat aspect = 16.0\/9.0;\nvec3 color = vec3(0.0);\nfloat timeleft;\nfloat ballsize= 0.007; \/\/(the ball is actually a dot, has no radius to avoid having to check vertex collision)\nfloat newBallTiming = 10.0;\n\nfloat pixelsize = 1.0\/iResolution.x;\nfloat linethickness = pixelsize*2.0*aspect;\n\nvoid drawline(vec2 a,vec2 b,vec3 linecolor) \/\/ antialiased line\n{\n    vec2 s = sp;\n    if ( dot(b-a,s-a) < 0.0 || dot(b-a,s-a)>dot(b-a,b-a)  ) return;\n    float aaval = (1.0-(abs( (a.x-b.x)*(s.y-a.y)-(a.y-b.y)*(s.x-a.x)  )\/linethickness\/length(a-b)*2.0));\n    color = max(color, linecolor*aaval);\n}\n\n\/\/ draw a disk with motion blur\nvec3 diskWithMotionBlur( vec3 col, in vec2 uv, in vec3 sph, in vec2 cd, in vec3 sphcol, in float alpha )\n{\n\tvec2 xc = uv - sph.xy;\n\tfloat a = dot(cd,cd);\n\tfloat b = dot(cd,xc);\n\tfloat c = dot(xc,xc) - sph.z*sph.z;\n\tfloat h = b*b - a*c;\n\tif( h>0.0 )\n\t{\n\t\th = sqrt( h );\n\t\t\n\t\tfloat ta = max( 0.0, (-b - h)\/a );\n\t\tfloat tb = min( 1.0, (-b + h)\/a );\n\t\t\n\t\tif( ta < tb ) \/\/ we can comment this conditional, in fact\n\t\t    col = mix( col, sphcol, alpha*clamp(2.0*(tb-ta),0.0,1.0) );\n\t}\n\n\treturn col;\n}\n\n\nvoid drawdisk(vec2 center,vec2 vel,float radius) \n{\n    if (showSolution!=0) return;\n\n    if (MotionBlur!=0)\n    {\n    \tcolor = diskWithMotionBlur(color,sp,vec3(center,radius),vel\/24.0,vec3(1.0,1.0,1.0),1.0);\n    }\n    else\n    {   \/\/ antialiased disk\n\t    float val = clamp( -(length(center-sp)-radius)\/pixelsize,-0.5,0.5 )+0.5;\n\t    color = max(color, vec3(1.0,1.0,1.0)*val);\n    }\n}\n\nvec2 ballpos,ballvel;\nconst int LineCount = 6;\nvec2 lines[LineCount*2];\n\nvec2 getBallPosFly(float t)\n{\n    vec2 np = ballpos + ballvel*t;\n    np.y += gravity*t*t*0.5;\n    return np;\n}\n\nfloat bounceTime;\nfloat time0;\nfloat bounceTan;\nfloat bounceLineAX,bounceLineBX;\n\nvoid lineFlyIntersection(vec2 la,vec2 lb)\n{\n    float k = (lb.y - la.y) \/ (lb.x - la.x); \/\/ line tangent\n    float topT = -ballvel.y\/gravity;\n    float topX = ballpos.x + ballvel.x*topT;\n    float topY = ballpos.y - 0.5*gravity*topT*topT;\n    float topLineY = k*(topX-la.x)+la.y;\n    \n    float b = -(topY-topLineY);\n    float a = -k*ballvel.x;\n    float t0 = -a\/gravity+topT;\n    if (2.0*b*gravity + a*a<=0.0) return;\n    float td = -sqrt(2.0*b*gravity + a*a)\/gravity;\n    \n    \n    float t = t0-td;\n    if (t<0.001 || ballpos.x+ballvel.x*t<la.x || ballpos.x+ballvel.x*t>lb.x) t = t0+td;\n    \n    if (bounceTime>t && t>0.001 && ballpos.x+ballvel.x*t>=la.x && ballpos.x+ballvel.x*t<=lb.x) \n    {\n\/\/\t    drawdisk(getBallPosFly(t),ballsize); \/\/ mark bounces\n        bounceTime = t;\n        bounceTan = k;\n        bounceLineAX = la.x;\n        bounceLineBX = lb.x;\n        if (lb.y<0.1) solution = 1.0;\n    }\n}\n\nvoid showPathFly(float t)\n{\n    if (showSolution!=0) return;\n    float xt = (sp.x-ballpos.x)\/ballvel.x;\n    if (xt>0.0 && xt<t)\n    {\n        float py = ballpos.y + ballvel.y*xt + xt*xt*gravity*0.5;\n        vec2 vel = ballvel;\n        vel.y += xt*gravity;\n        float aa = 1.0-abs(sp.y-py)\/pixelsize\/1.5\/length(vec2(1.0,vel.y\/vel.x));\n        color = max(color,aa*vec3(0.1,0.4,0.9));\n    }\n}\n\nvec2 displayBallPos,displayBallVel;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    lines[0] =vec2(0.1,0.4);\n    lines[1] =vec2(0.35,0.25);\n    lines[2] =vec2(0.35,0.22);\n    lines[3] = vec2(0.5,0.21);\n    lines[4] = vec2(0.5,0.16);\n    lines[5] = vec2(0.7,0.3);\n    lines[6] = vec2(0.84,0.19);\n    lines[7] = vec2(0.90,0.34);\n    lines[8] = vec2(0.4,0.06);\n    lines[9] = vec2(1.0,0.2);\n    lines[10] = vec2(0.2,0.08);\n    lines[11] = vec2(0.5,0.01);\n    \n    ti = mod( iGlobalTime,newBallTiming);\n\tsp = fragCoord.xy \/ iResolution.xy;\n    sp.y \/= aspect;\n    \n    timeleft = ti;\n    time0 = 0.0;\n    \n    ballpos = iMouse.xy\/iResolution.xy\/vec2(1.0,aspect);\n    if (length(ballpos)==0.0)  \n        ballpos = vec2(0.19-mod(floor(iGlobalTime\/newBallTiming)*0.02211,0.12),0.57);\n\tif (showSolution!=0) ballpos = sp;    \n    \n    ballvel = vec2(0.08,-0.08);\/\/ initial velocity x must not be 0\n    \n    for(int i=0;i<LineCount;i++)\n    {\n        vec2 fakeshift = normalize(lines[i*2+1].yx-lines[i*2].yx)*vec2(ballsize,-ballsize);\n    \tdrawline(lines[i*2]+fakeshift,lines[i*2+1]+fakeshift,vec3(1.0,0.8,0.1));\n    }\n    \n\n    for(int pass=0;pass<50;pass++) \/\/ max bounce count\n    {\n    \n        bounceTime = 1e35;\n        \n        for(int i=0;i<LineCount;i++)\n        {\n            lineFlyIntersection(lines[i*2],lines[i*2+1]);\n        }\n        float timeToGo = bounceTime;\n        showPathFly(timeToGo);\n        if (bounceTime>timeleft && timeleft>0.0) \n        {\n            displayBallPos = getBallPosFly(timeleft);\n            displayBallVel = ballvel;\n            displayBallVel.y += timeleft*gravity;\n        }\n        ballpos = getBallPosFly(timeToGo);\n        ballvel.y += timeToGo*gravity;\n        timeleft -= timeToGo;\n        time0 += timeToGo;\n        \n        \n        if (timeleft==0.0 || bounceTime==1e35) break;\n        \n        \/\/ bounce or roll\n        vec2 norm = normalize(vec2(-bounceTan,1.0));\n        if (abs(dot(norm,ballvel))<0.02) \/\/ roll \n        {\n            ballvel -= norm*dot(norm,ballvel);\n            \n            \/\/ find rolling end\n            vec2 slope = vec2(1.0,bounceTan);\n            vec2 gravslope = gravity * slope*bounceTan\/dot(slope,slope);\n\/\/            float x = ballpos.x + ballvel.x*t + gravslope.x*t*t*0.5;\n            float A = 0.5*gravslope.x;\n            float B = ballvel.x;\n            float C1 = ballpos.x - bounceLineAX; \n            float C2 = ballpos.x - bounceLineBX; \n            \n            float tm = B\/-2.0\/A; \/\/ lines can't be horizontal\n            float rollendt = 99.0;\n            if (B*B-4.0*A*C1>0.0)\n            {\n            \tfloat td = abs(sqrt(B*B-4.0*A*C1)\/2.0\/A);\n                float t=tm-td;\n                if (t<=0.0) t = tm+td;\n                if (t>0.0) rollendt = t;\n            }\n            if (B*B-4.0*A*C2>0.0)\n            {\n            \tfloat td = abs(sqrt(B*B-4.0*A*C2)\/2.0\/A);\n                float t=tm-td;\n                if (t<=0.0) t = tm+td;\n                if (t>0.0)  rollendt = min(rollendt,t);\n            }\n            \n            float turnT = max(tm,0.0);\n            if (turnT > rollendt) turnT=0.0;\n            vec2 turnBallPos = ballpos + ballvel*turnT + turnT*turnT*0.5*gravslope;\n            \n            if (rollendt>timeleft && timeleft>0.0) \n            {\n                displayBallPos = ballpos + ballvel*timeleft + timeleft*timeleft*0.5*gravslope;\n                displayBallVel = ballvel;\n            }\n            \n            timeToGo = rollendt;\n            ballpos += ballvel*timeToGo + timeToGo*timeToGo*0.5*gravslope;\n            ballvel += gravslope * timeToGo;\n            \n            if (showSolution==0) drawline(ballpos,turnBallPos,vec3(0.1,0.4,0.9));\n            \n            time0 += timeToGo;\n            timeleft -= timeToGo;\n            \n            \n        }\n        else\n        {\n\t        ballvel -= norm*dot(norm,ballvel)*(1.0+bounceRatio); \/\/ just bounce\n        }\n        \n        if (ballpos.y<0.0) break;\n       \n    }\n    \n    \n    \n    \n    drawdisk(displayBallPos,displayBallVel,ballsize);\n    \n   if (showSolution!=0) \n   {\n       color = max(color,vec3(-ballvel.x*3.0,ballvel.x*3.0,0.0));\n\/\/       if (solution!=0.0) color = vec3(solution*0.5,0,solution);\n   }\n\tfragColor = vec4(color,1.0);\n}","name":"","description":"","type":"image"}]}}