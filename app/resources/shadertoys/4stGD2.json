{"Shader":{"ver":"0.1","info":{"id":"4stGD2","date":"1452254999","viewed":197,"name":"Everyday008-Cathedrale01","username":"Makio64","description":"First \"Cathedrale\" study <img src=\"\/img\/emoticonHappy.png\"\/>","likes":8,"published":3,"flags":0,"tags":["everyday008cathedrale01"],"hasliked":0},"renderpass":[{"inputs":[{"id":1,"src":"\/presets\/tex00.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Everyday008 - Cathedrale\n\/\/ By David Ronai \/ @Makio64\n\n\/\/------------------------------------------------------------------ VISUAL QUALITY\n#define POSTPROCESS\n#define RAYMARCHING_STEP 40\n#define RAYMARCHING_MIN 10.\n#define RAYMARCHING_MAX 400.\n#define RAYMARCHING_JUMP 1.\n\/\/------------------------------------------------------------------ DEBUG\n\/\/#define RENDER_DEPTH\n\/\/#define RENDER_NORMAL\n\/\/#define RENDER_AO\n\n#define PHI (sqrt(5.)*0.5 + 0.5)\nconst float PI = 3.14159265359;\nfloat snoise(vec3 v);\n\n\/\/-------------------------------------------------------  PPRIMITIVES \/ OPERATIONS\nvec3 orbit(float phi, float theta, float radius)\n{\n\treturn vec3(\n\t\tradius * sin( phi ) * cos( theta ),\n\t\tradius * cos( phi ),\n\t\tradius * sin( phi ) * sin( theta )\n\t);\n}\nfloat pyramid( vec3 p, float h) {\n\tvec3 q=abs(p);\n\treturn max(-p.y, (q.x*2.1+q.y+q.z*2.1-h)\/3.0 );\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\nfloat fOpIntersectionChamfer(float a, float b, float r) {\n\treturn max(max(a, b), (a + r + b)*sqrt(0.5));\n}\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r + a,r + b), vec2(0));\n\treturn min(-r, max (a, b)) + length(u);\n}\nvec2 pModMirror2(inout vec2 p, vec2 size) {\n\tvec2 halfsize = size*0.5;\n\tvec2 c = floor((p + halfsize)\/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\tp *= mod(c,vec2(2.))*2. - vec2(1.);\n\treturn c;\n}\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r\/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\n\/\/------------------------------------------------------------------ MAP\nfloat map( in vec3 pos ) {\n    \/\/arch\n    vec3 q = pos;\n    pModMirror2(q.xz,vec2(22.));\n    q.y -= 40.;\n    q.zx -= 21.;\n    pR(q.yz,PI\/2.);\n    pR45(q.xy);\n    float d = fTorus(q,1.3,44.);\n    q = pos;\n    pModMirror2(q.xz,vec2(500.));\n    d = max(-fBox(q-vec3(0.,10.5,0.),vec3(500.,30.,500.)),d);\n    \n    \/\/column\n    q = pos;\n    q.zx -= 22.;\n    q.zx += texture2D(iChannel0,pos.xy\/50.).x*.5;\n    vec2 idx = pModMirror2(q.xz,vec2(22.));\n    q.xz -= 9.5;\n    d = fOpUnionStairs(d, fCylinder(q,2.,40.),4.,10.);\n    \n    \/\/ground\n    d = fOpUnionStairs(d, pos.y+40.1+texture2D(iChannel0,pos.xz\/50.).x*.5, 5., 5.);\n    \n    \/\/pyramid on top of arch\n    q = pos;\n    q.y -= 80.;\n    q.zx += 11.;\n    pModMirror2(q.xz,vec2(44.));\n    pR45(q.xz);\n    float d2 = pyramid( q, 12. );\n    pR(q.xy,PI);\n    d2 = min(d2,pyramid( q, 12. ));\n    d = fOpUnionRound(d, d2,1.);\n    return d;\n}\n\n\n\n\/\/------------------------------------------------------------------ RAYMARCHING\n\nfloat castRay( in vec3 ro, in vec3 rd, inout float depth )\n{\n\tfloat t = RAYMARCHING_MIN;\n\tfloat res;\n\tfor( int i=0; i<RAYMARCHING_STEP; i++ )\n\t{\n\t\tvec3 pos = ro+rd*t;\n\t\tres = map( pos );\n\t\tif( res < 0.001 || t > RAYMARCHING_MAX ) break;\n\t\tt += res*RAYMARCHING_JUMP;\n\t\tdepth += 1.\/float(RAYMARCHING_STEP);\n\t}\n\treturn t;\n}\n\nvec3 calcNormal(vec3 p) {\n\tfloat eps = 0.01;\n\tconst vec3 v1 = vec3( 1.0,-1.0,-1.0);\n\tconst vec3 v2 = vec3(-1.0,-1.0, 1.0);\n\tconst vec3 v3 = vec3(-1.0, 1.0,-1.0);\n\tconst vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\treturn normalize( v1 * map( p + v1*eps ) +\n\t\t\t\t\t  v2 * map( p + v2*eps ) +\n\t\t\t\t\t  v3 * map( p + v3*eps ) +\n\t\t\t\t\t  v4 * map( p + v4*eps ) );\n}\n\nfloat hash( float n ){\n\treturn fract(sin(n)*3538.5453);\n}\n\nfloat calcAO( in vec3 p, in vec3 n, float maxDist, float falloff ){\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = n*l;\n\t\tao += (l - map( p + rd )) \/ pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao\/float(nbIte), 0., 1.);\n}\n\nfloat thickness( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = -n*l;\n\t\tao += (l + map( p + rd )) \/ pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao\/float(nbIte), 0., 1.);\n}\n\n\/\/------------------------------------------------------------------ POSTEFFECTS\nfloat random(vec2 n, float offset ){\n\treturn .5 - fract(sin(dot(n.xy + vec2( offset, 0. ), vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n#ifdef POSTPROCESS\nvec3 postEffects( in vec3 col, in vec2 uv, in float time )\n{\n\t\/\/ vigneting\n    float vignette = .8*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.8 );\n\tcol *= .2+vignette;\n\tcol += (1.-vignette)*vec3( .25 * random( uv, .001 * iGlobalTime ) );\n\treturn col;\n}\n#endif\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv )\n{\n\tvec3 col = vec3(.0,.0,1.2);\n\n\tfloat depth = 0.;\n\tfloat t = castRay(ro,rd,depth);\n\t#ifdef RENDER_DEPTH\n\treturn vec3(depth\/10.,depth\/5.,depth);\n\t#endif\n\tvec3 pos = ro + t * rd;\n\tvec3 nor = calcNormal(pos);\n\t#ifdef RENDER_NORMAL\n\treturn nor;\n\t#endif\n\tfloat ao = calcAO(pos,nor,10.,1.2);\n\t#ifdef RENDER_AO\n\treturn vec3(ao);\n\t#endif\n\n    float thi = thickness(pos, nor, 10., 1.4);\n\tcol = max(vec3(0.), dot(nor,vec3(.5)));\n    if(pos.y>-40.1){\n        col*=texture2D(iChannel0,pos.xy\/10.).ggg*.5;\n    }\n    col += vec3(depth\/10.,depth\/5.,depth);\n    col *= clamp(1.-smoothstep(250.,400.,t),0.,1.);\n    col *= ao*thi*1.3;\n\treturn col;\n}\n\n\/\/------------------------------------------------------------------ MAIN\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\treturn mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 coords )\n{\n\tvec2 uv = coords.xy \/ iResolution.xy;\n\tvec2 mouse = iMouse.xy \/ iResolution.xy;\n\tvec2 q = coords.xy\/iResolution.xy;\n\tvec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x\/iResolution.y;\n\n\t\/\/Camera\n\tfloat radius = 80.;\n\tvec3 ro = orbit(PI\/2.-.2,PI\/2.,radius);\n    ro.z-=30.*iGlobalTime;\n    ro.x-=11.;\n\tvec3 ta  = vec3(-11.0+sin(iGlobalTime)*40.,15., -30.*iGlobalTime);\n\tmat3 ca = setCamera( ro, ta, 0. );\n\tvec3 rd = ca * normalize( vec3(p.xy,1.3) );\n\n\t\/\/ Raymarching\n\tvec3 color = render( ro, rd, uv );\n\t#ifdef POSTPROCESS\n\tcolor = postEffects( color, uv, iGlobalTime );\n\t#endif\n\tfragColor = vec4(color,1.0);\n}\n\n\/\/------------------------------------------------------------------ NOISE\n\/\/AshimaOptim https:\/\/www.shadertoy.com\/view\/Xd3GRf\nvec4 permute(vec4 x){return mod(x*x*34.0+x,289.);}\nfloat snoise(vec3 v){\n  const vec2  C = vec2(0.166666667, 0.33333333333) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 = v - i + dot(i, C.xxx) ;\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n  i = mod(i,289.);\n  vec4 p = permute( permute( permute(\n\t  i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n\t+ i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n\t+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n  vec3 ns = 0.142857142857 * D.wyz - D.xzx;\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n  vec4 x_ = floor(j * ns.z);\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = floor(j - 7.0 * x_ ) *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n  vec4 norm = inversesqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m * m;\n  return .5 + 12.0 * dot( m, vec4( dot(p0,x0), dot(p1,x1),dot(p2,x2), dot(p3,x3) ) );\n}\n","name":"","description":"","type":"image"}]}}