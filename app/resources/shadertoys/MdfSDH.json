{"Shader":{"ver":"0.1","info":{"id":"MdfSDH","date":"1400139574","viewed":1081,"name":"SH - directional lights","username":"iq","description":"Testing 3-band SH encoding of directional lights. It compares the SH reconstruction to the ground truth.","likes":13,"published":3,"flags":0,"tags":["3d","sphericalharmonics","harmonic","sh"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Testing 3-band SH encoding for directional lights. \n\n\/\/ A lighting environment made of several directional lights is encoded in an SH\n\/\/ representation by incrementally accumulating incoming directional lighting with \n\/\/ SH_AddLightDirectional(). At render time, the normal's SH is doted with the SH\n\/\/ representation of the lighting to get the final color, by calling SH_Evalulate().\n\n\/\/ More info here at  dickyjim's blog: \n\/\/ https:\/\/dickyjim.wordpress.com\/2013\/09\/04\/spherical-harmonics-for-beginners\/\n\n#define OPTIMIZED\n\n\n\/\/--------------------------------------------------------------------------------\n\/\/ SH\n\/\/--------------------------------------------------------------------------------\n\n#ifndef OPTIMIZED\n#define PI 3.1415927\n\/\/\n\/\/ slow version, but true to the mathematical formulation\n\/\/\nvoid SH_AddLightDirectional( inout vec3 sh[9], in vec3 col, in vec3 v )\n{\n    #define NO  1.0        \/\/ for perfect overal brigthness match\n  \/\/#define NO (16.0\/17.0) \/\/ for normalizing to maximum = 1.0;\n    sh[0] += col * (NO*PI*1.000) * (0.50*sqrt( 1.0\/PI));\n    sh[1] += col * (NO*PI*0.667) * (0.50*sqrt( 3.0\/PI)) * v.x;\n    sh[2] += col * (NO*PI*0.667) * (0.50*sqrt( 3.0\/PI)) * v.y;\n    sh[3] += col * (NO*PI*0.667) * (0.50*sqrt( 3.0\/PI)) * v.z;\n    sh[4] += col * (NO*PI*0.250) * (0.50*sqrt(15.0\/PI)) * v.x*v.z;\n    sh[5] += col * (NO*PI*0.250) * (0.50*sqrt(15.0\/PI)) * v.z*v.y;\n    sh[6] += col * (NO*PI*0.250) * (0.50*sqrt(15.0\/PI)) * v.y*v.x;\n    sh[7] += col * (NO*PI*0.250) * (0.25*sqrt( 5.0\/PI)) * (3.0*v.z*v.z-1.0);\n    sh[8] += col * (NO*PI*0.250) * (0.25*sqrt(15.0\/PI)) * (v.x*v.x-v.y*v.y);\n}\n\nvec3 SH_Evalulate( in vec3 v, in vec3 sh[9] )\n{\n    return sh[0] * (0.50*sqrt( 1.0\/PI)) +\n           sh[1] * (0.50*sqrt( 3.0\/PI)) * v.x +\n           sh[2] * (0.50*sqrt( 3.0\/PI)) * v.y +\n           sh[3] * (0.50*sqrt( 3.0\/PI)) * v.z +\n           sh[4] * (0.50*sqrt(15.0\/PI)) * v.x*v.z +\n           sh[5] * (0.50*sqrt(15.0\/PI)) * v.z*v.y +\n           sh[6] * (0.50*sqrt(15.0\/PI)) * v.y*v.x +\n           sh[7] * (0.25*sqrt( 5.0\/PI)) * (3.0*v.z*v.z-1.0) +\n           sh[8] * (0.25*sqrt(15.0\/PI)) * (v.x*v.x-v.y*v.y);\n}\n\n#else\n\n\/\/\n\/\/ fast version, premultiplied components and simplified terms\n\/\/\nvoid SH_AddLightDirectional( inout vec3 sh[9], in vec3 col, in vec3 v )\n{\n     #define DI 64.0  \/\/ for perfect overal brigthness match\n   \/\/#define DI 68.0  \/\/ for normalizing to maximum = 1.0;\n\t\n\tsh[0] += col * (21.0\/DI);\n\tsh[0] -= col * (15.0\/DI) * v.z*v.z;\n\tsh[1] += col * (32.0\/DI) * v.x;\n\tsh[2] += col * (32.0\/DI) * v.y;\n\tsh[3] += col * (32.0\/DI) * v.z;\n\tsh[4] += col * (60.0\/DI) * v.x*v.z;\n\tsh[5] += col * (60.0\/DI) * v.z*v.y;\n\tsh[6] += col * (60.0\/DI) * v.y*v.x;\n\tsh[7] += col * (15.0\/DI) * (3.0*v.z*v.z-1.0);\n\tsh[8] += col * (15.0\/DI) * (v.x*v.x-v.y*v.y);\n}\n\nvoid SH_AddDome( inout vec3 sh[9], in vec3 colA, in vec3 colB )\n{\n\tsh[0] += 0.5*(colB + colA);\n\tsh[2] += 0.5*(colB - colA);\n}\n\n\nvec3 SH_Evalulate( in vec3 v, in vec3 sh[9] )\n{\n\treturn sh[0] +\n           sh[1] * v.x +\n           sh[2] * v.y +\n           sh[3] * v.z +\n           sh[4] * v.x*v.z +\n           sh[5] * v.z*v.y +\n           sh[6] * v.y*v.x +\n           sh[7] * v.z*v.z +\n           sh[8] *(v.x*v.x-v.y*v.y);\n}\n#endif\n\n\/\/--------------------------------------------------------------------------------\n\/\/ test\n\/\/--------------------------------------------------------------------------------\n\nvec3  lig1 = normalize( vec3(1.0, 1.0, 1.0) );\nvec3  lig2 = normalize( vec3(1.0,-1.0, 0.1) );\nvec3  lig3 = normalize( vec3(0.0, 0.2,-1.0) );\nvec3  lig4 = normalize( vec3(0.5, 0.8,-0.5) );\n\nvec3 lco1 = vec3(1.0,0.2,0.0);\nvec3 lco2 = vec3(0.0,1.0,0.0);\nvec3 lco3 = vec3(0.0,0.0,1.0);\nvec3 lco4 = vec3(1.0,0.9,0.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) \/ iResolution.y;\n\n     \/\/ camera movement\t\n\tfloat an = 0.2*iGlobalTime - 10.0*iMouse.x\/iResolution.x;\n\tvec3 ro = vec3( 2.5*sin(an), 0.0, 2.5*cos(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    \/\/ camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t\/\/ create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n\tvec3 col = vec3(0.4);\n\n    \/\/ Prec-encode the lighting as SH coefficients (you'd usually do this only once)\n\tvec3 sh[9];\n\tsh[0] = vec3(0.0);\n\tsh[1] = vec3(0.0);\n\tsh[2] = vec3(0.0);\n\tsh[3] = vec3(0.0);\n\tsh[4] = vec3(0.0);\n\tsh[5] = vec3(0.0);\n\tsh[6] = vec3(0.0);\n\tsh[7] = vec3(0.0);\n\tsh[8] = vec3(0.0);\n\tSH_AddLightDirectional( sh, lco1, lig1 );\n\tSH_AddLightDirectional( sh, lco2, lig2 );\n\tSH_AddLightDirectional( sh, lco3, lig3 );\n\tSH_AddLightDirectional( sh, lco4, lig4 );\n\n\t\/\/ raytrace-sphere\n\tvec3  ce = ro;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - 1.0;\n\tfloat h = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\th = -b - sqrt(h);\n\t\tvec3 pos = ro + h*rd;\n\t\tvec3 nor = normalize(pos); \n\t\t\n\t\t\/\/ compare regular lighting...\n\t\tif( sin(6.2831*iGlobalTime)>0.0 )\n        {\n\t\t\tcol  = lco1*clamp( dot(nor,lig1), 0.0, 1.0 );\n            col += lco2*clamp( dot(nor,lig2), 0.0, 1.0 );\n            col += lco3*clamp( dot(nor,lig3), 0.0, 1.0 );\n            col += lco4*clamp( dot(nor,lig4), 0.0, 1.0 );\n        }\n        \/\/ ... with SH lighting\n        else\t\t\t\n        {\n            col = SH_Evalulate( nor, sh );\n        }\n\t}\n\tcol *= 0.6;\n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}