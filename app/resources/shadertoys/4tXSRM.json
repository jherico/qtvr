{"Shader":{"ver":"0.1","info":{"id":"4tXSRM","date":"1435092267","viewed":771,"name":"Skyline Explanation","username":"gsingh93","description":"A fully commented version of this shader: http:\/\/glslsandbox.com\/e#22564.0","likes":5,"published":3,"flags":0,"tags":["tutorial","explanation","skyline"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define MAX_DEPTH 20\n\n\/\/ Magic noise function, described here:\n\/\/ https:\/\/stackoverflow.com\/questions\/12964279\/whats-the-origin-of-this-glsl-rand-one-liner\nfloat noise(vec2 p) {\n\treturn fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 456367.5453);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \/\/ Scale coordinates to [0, 1]\n\tvec2 p = fragCoord.xy \/ iResolution.xy;\n    \n    float col = 0.;\n    \/\/ Start from the back buildings and work forward, so buildings in the front cover the ones in the back\n\tfor (int i = 1; i < MAX_DEPTH; i++) {\n        \/\/ This is really \"inverse\" depth since we start from the back\n\t\tfloat depth = float(i);\n        \n        \/\/ Create a step function where the width of each step is constant at each depth, but increases as\n        \/\/ the depth increases (as we move forward). We will get the same step value for multiple p.x\n        \/\/ values, which will give our building width. iGlobalTime creates the scrolling effect.\n\t\tfloat step = floor(200. * p.x \/ depth + 50. * depth + iGlobalTime);\n        \n        \/\/ Use the noise function to get the y coordinate of the top of the building, and decrease this\n        \/\/ height the closer we are to the front. If our pixel is below this height, we set it's color\n        \/\/ depending on it's depth. \n\t\tif (p.y < noise(vec2(step)) - depth * .04) {\n\t\t\tcol = depth \/ 20.;\n\t\t}\n\t}\n    \n    fragColor = vec4(vec3(col), 1.);\n}","name":"","description":"","type":"image"}]}}