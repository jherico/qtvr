{"Shader":{"ver":"0.1","info":{"id":"MdKGRw","date":"1453808566","viewed":140,"name":"digits\/sliders\/kbd widgets - 2","username":"FabriceNeyret2","description":"Utils   ( updated version of old https:\/\/www.shadertoy.com\/view\/lsXXzN )","likes":5,"published":3,"flags":48,"tags":["font","keyboard","digits","sliders","widgets"],"hasliked":0},"renderpass":[{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ ---- digits\/sliders\/kbd widgets utilities ----------------------------\n\/\/ if you use it, please let a link to this shader in comments\n\/\/ for others can get the full set (possibly updated and expended).\n\n\/\/ updated version of old  https:\/\/www.shadertoy.com\/view\/lsXXzN\n\/\/ ----------------------------------------------------------------------\n\n\/\/ define your sliders in BufA.  value [0,1]  = UI(i).a    , i=1..16\n\/\/ define your buttons in BufA.  value {-1,1} = UI(i+16).a , i=1..16\n\/\/ get mouse position enriched by demo-mode in UI(33)\n\/\/ get prev mouse position in UI(34) (e.g.: detect move, get velocity, direction...)\n\n\/\/ see below functions for\n\/\/ - reading the keyboard\n\/\/ - drawing sliders and buttons\n\/\/ - drawing floats and digits\n\/\/ - demoing the mouse states\n\n\n\/\/ --- keyboard -----------------------------------------------------\n\n\/\/ FYI: LEFT:37  UP:38  RIGHT:39  DOWN:40   PAGEUP:33  PAGEDOWN:34  END : 35  HOME: 36\n\nbool keyToggle(int ascii) {\n\treturn (texture2D(iChannel2,vec2((.5+float(ascii))\/256.,0.75)).x > 0.);\n}\nbool keyClick(int ascii) {\n\treturn (texture2D(iChannel2,vec2((.5+float(ascii))\/256.,0.25)).x > 0.);\n}\n\n\n\n\/\/ --- Digit display ----------------------------------------------------\n\n\/\/ all functions return true or seg number if something was drawn -> caller can then exit the shader.\n\n\/\/     ... adapted from Andre in https:\/\/www.shadertoy.com\/view\/MdfGzf\n\nfloat segment(vec2 uv, bool On) {\n\treturn (On) ?  (1.-smoothstep(0.08,0.09+float(On)*0.02,abs(uv.x)))*\n\t\t\t       (1.-smoothstep(0.46,0.47+float(On)*0.02,abs(uv.y)+abs(uv.x)))\n\t\t        : 0.;\n}\n\nfloat digit(vec2 uv,int num) {\n\tfloat seg= 0.;\n    seg += segment(uv.yx+vec2(-1., 0.),num!=-1 && num!=1 && num!=4                    );\n\tseg += segment(uv.xy+vec2(-.5,-.5),num!=-1 && num!=1 && num!=2 && num!=3 && num!=7);\n\tseg += segment(uv.xy+vec2( .5,-.5),num!=-1 && num!=5 && num!=6                    );\n   \tseg += segment(uv.yx+vec2( 0., 0.),num!=-1 && num!=0 && num!=1 && num!=7          );\n\tseg += segment(uv.xy+vec2(-.5, .5),num==0 || num==2 || num==6 || num==8           );\n\tseg += segment(uv.xy+vec2( .5, .5),num!=-1 && num!=2                              );\n    seg += segment(uv.yx+vec2( 1., 0.),num!=-1 && num!=1 && num!=4 && num!=7          );\t\n\treturn seg;\n}\n\nfloat showNum(vec2 uv,int nr, bool zeroTrim) { \/\/ nr: 2 digits + sgn . zeroTrim: trim leading \"0\"\n\tif (abs(uv.x)>2.*1.5 || abs(uv.y)>1.2) return 0.;\n\n\tif (nr<0) {\n\t\tnr = -nr;\n\t\tif (uv.x>1.5) {\n\t\t\tuv.x -= 2.;\n\t\t\treturn segment(uv.yx,true); \/\/ minus sign.\n\t\t}\n\t}\n\t\n\tif (uv.x>0.) {\n\t\tnr \/= 10; if (nr==0 && zeroTrim) nr = -1;\n\t\tuv -= vec2(.75,0.);\n\t} else {\n\t\tuv += vec2(.75,0.); \n\t\tnr = int(mod(float(nr),10.));\n\t}\n\n\treturn digit(uv,nr);\n}\n\nfloat dots(vec2 uv, int dot) { \/\/ dot: bit 0 = bottom dot; bit 1 = top dot\n\tfloat point0 = float(dot\/2),\n\t\t  point1 = float(dot)-2.*point0; \n\tuv.y -= .5;\tfloat l0 = 1.-point0+length(uv); if (l0<.13) return (1.-smoothstep(.11,.13,l0));\n\tuv.y += 1.;\tfloat l1 = 1.-point1+length(uv); if (l1<.13) return (1.-smoothstep(.11,.13,l1));\n\treturn 0.;\n}\n\/\/    ... end of digits adapted from Andre\n\n#define STEPX .875\n#define STEPY 1.5\nfloat _offset=0.; \/\/ auto-increment useful for successive \"display\" call\n\n\/\/ 2digit int + sign\nfloat display_digit(vec2 uv, float scale, float offset, int number, int dot) { \/\/ dot: draw separator\n\n\tuv = (uv-0.)\/scale*2.; \n    uv.x = .5-uv.x + STEPX*offset;\n\tuv.y -= 1.;\n\t\n\tfloat seg = showNum(uv,number,false);\n\toffset += 2.;\n\t\n\tif (dot>0) {\n\t\tuv.x += STEPX*offset; \n\t\tseg += dots(uv,dot);\n\t\toffset += 2.;\n\t}\n\n\t_offset = offset;\n\treturn seg;\n}\n\n\/\/ 2.2 float + sign\nfloat display_float(vec2 pos, float scale, float offset, float val) { \/\/ dot: draw separator\n\tif (display_digit( pos, scale, 0., int(val), 1)>0.) return 1.;\n    if (display_digit( pos, scale, _offset, int(fract(abs(val))*100.), 0)>0.) return 1.;\n\treturn 0.;\n}\n\n\n\n\/\/ --- sliders and mouse widgets -------------------------------------------\n\nvec2 R = iResolution.xy;\n#define UI(x) texture2D(iChannel0,(vec2(x,0)+.5)\/R)\n#define Swidth  .004\n#define Sradius .02\n#define Bradius .04\n#define Mradius .02\n\nvec4 affMouse(vec2 uv)  { \/\/ display mouse states ( color )\n    vec4 mouse = UI(33);                       \/\/ current mouse pos\n    float k = length(mouse.xy\/R.y-uv)\/Mradius,\n          s = sign(mouse.z);\n\tif (k<1.) \n\t    if (k>.8) return vec4(1e-10);\n\t\t   else   return vec4(s,1.-s,0,1); \n\t\n    k = length( UI(34).xy\/R.y-uv)\/Mradius;     \/\/ prev mouse pos \n\tif (k<1.) \n\t    if (k>.8) return vec4(1e-10);\n\t\t   else   return vec4(0,0,1,1); \n            \n    k = length(abs(mouse.zw)\/R.y-uv)\/Mradius;  \/\/ drag start  mouse pos \n\tif (k<1.) \n\t    if (k>.8) return vec4(1e-10);\n\t\t   else   return vec4(0,.4,s,1); \n\t\n\treturn vec4(0);\n}\n\n\nfloat aff_sliders(vec2 U) { \/\/ display sliders ( grey level or 0.)\n    for (float i=0.; i<16.; i++) {\n        if (i>=UI(0).x) break;\n        vec4 S = UI(i+1.);\n        float l = abs(S.z);\n        if (S.z>0. && abs(U.y-S.y)<Swidth && abs(U.x-S.x-l\/2.)<l\/2. ) return 1.;\n        if (S.z<0. && abs(U.x-S.x)<Swidth && abs(U.y-S.y-l\/2.)<l\/2. ) return 1.;\n        if (S.z>0. && length(U-S.xy-vec2(S.a*l,0))<Sradius ) return 1.;\n        if (S.z<0. && length(U-S.xy-vec2(0,S.a*l))<Sradius ) return 1.;\n    }\n    return 0.;       \n}\n\nfloat aff_buttons(vec2 U) { \/\/ display buttons ( grey level or 0.)\n    for (float i=0.; i<16.; i++) {\n        if (i>=UI(0).y) break;\n        vec4 S = UI(i+17.);\n        float l = length(U-S.xy);\n        if (l < Bradius) \n            if (S.a>0.) return 1.; \n            else return .3+smoothstep(.7,1.,l\/Bradius);\n    }\n    return 0.;\n}        \n\n        \n\n\/\/ --------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy\/R.y;\n    vec4 mouse = UI(33)\/R.y;\n    \n\t\/\/ display sliders and buttons \n\t{ float s = aff_sliders(uv); if (s>0.) { fragColor = s*vec4(1,.2,0,1); return;}}\n    { float b = aff_buttons(uv); if (b>0.) { fragColor = b*vec4(0,0,1,1);  return;}}\n\n\t\n\t\/\/ display counters\n\tvec2 pos ; \n\tfloat scale = 0.1;\n\t\n\tpos = vec2(.2,.8);    if (display_float( uv-pos, scale, 0., mouse.x*100.)>0.) { fragColor=vec4(1); return;}\n\tpos.y -= STEPY*scale; if (display_float( uv-pos, scale, 0., mouse.y*100.)>0.) { fragColor=vec4(1); return;} \n\tpos.y -= STEPY*scale; if (display_float( uv-pos, scale, 0., UI(1).a*100.)>0.) { fragColor=vec4(1); return;}\n\tpos.y -= STEPY*scale; if (display_float( uv-pos, scale, 0., UI(2).a*100.)>0.) { fragColor=vec4(1); return;} \n\tpos.y -= STEPY*scale; if (display_float( uv-pos, scale, 0., mod(iGlobalTime,60.))>0.) { fragColor=vec4(1); return;} \n\n    \/\/ display mouse states\n    fragColor = affMouse(uv); if (fragColor!=vec4(0)) return; \n\t \t\n    fragColor= .3*vec4(uv,.5+.5*sin(iGlobalTime),1);\n}","name":"","description":"","type":"image"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ only line 0, pixels 0 to 33 of bufA are used\n\/\/ if you need the full buffer but the .a components, you might adapt this util to use only .a \n\n#define FAKE_MOUSE 1 \/\/ fake mouse motion if no user input\n#define Sradius .02  \/\/ influence radius for sliders\n#define Bradius .04  \/\/ influence radius for buttons\n\n#define HORIZ   1.\n#define VERTIC -1.\n\n\nvec2 R = iResolution.xy;\n#define UI(x) texture2D(iChannel0,(vec2(x,0)+.5)\/R)\n\n#define add_slider(x,y,d,l,v0) { nbS++; if (U==vec2(nbS,0.))    O = vec4(x,y,(l)*(d),v0); }\n#define add_button(x,y,v0)     { nbB++; if (U==vec2(nbB+16,0.)) O = vec4(x,y,0,v0);       }\n\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    O = texture2D(iChannel0,U\/R);\n    U -= .5;\n    \n    if (iFrame==0) {\n        int nbS = 0, nbB = 0;\n        \n        add_slider (.15,.05,HORIZ, .5,.3); \/\/ --- define your sliders here ---\n        add_slider (.15,.10,HORIZ, .5,.6); \/\/ read value [0,1] in UI(i).a  , i=1..16\n        add_slider (.05,.15,VERTIC,.5,.0);\n        add_slider (.10,.15,VERTIC,.5,.9);\n        \n        add_button ( .9,.2,  1.);          \/\/ --- define your buttons here ---\n        add_button ( .9,.1, -1.);          \/\/ read value {-1,1} in UI(i+16).a , i=1..16\n        add_button ( 1.,.2,  1.);          \n        add_button ( 1.,.1, -1.);          \n        \n        if (U==vec2(0,0)) O.xy = vec2(nbS, nbB);\n        return;\n    }\n    \n    if (U==vec2(33,0)) {  \/\/ previous mouse state (for BufA) our mouse state (other shaders)\n        vec4 m = iMouse;\n#if FAKE_MOUSE\n        if (length(m.xy)<10. && m.z<=0.) { \/\/ fake mouse motion if no user input\n\t        float t = iGlobalTime;         \/\/ you can reset this state by putting the mouse back in the corner\n\t        m.xy = (.5+.4*vec2(cos(t),sin(t)))*R;\n\t    }   \n#endif\n        O = m;\n        return; \n    }              \n    if (U==vec2(34,0)) { O = UI(33); return; } \/\/ previous mouse state (for other shaders)\n    \n    if (iMouse.z>0. && U.y==0.) {          \/\/ --- let mouse trigers the right slider or button\n       \tvec2 M = iMouse.xy\/iResolution.y;\n        if (U.x <= UI(0).x) {\n\t        vec4 S = UI(U.x);\n    \t    float l = abs(S.z);\n        \tvec2 m = iMouse.xy\/iResolution.y;\n\t        if (S.z>0. && abs(M.y-S.y)<Sradius && abs(M.x-S.x-l\/2.)<l\/2. ) O.a = (M.x-S.x)\/l;\n    \t    if (S.z<0. && abs(M.x-S.x)<Sradius && abs(M.y-S.y-l\/2.)<l\/2. ) O.a = (M.y-S.y)\/l;\n    \t}\n        else if (UI(33).z<0. &&  U.x>16. && U.x<=16.+UI(0).y ) {\n\t        vec4 S = UI(U.x);\n            if (length(M-S.xy)<Bradius) O.a *= -1.;\n        }\n    }\n        \n}","name":"","description":"","type":"buffer"}]}}