{"Shader":{"ver":"0.1","info":{"id":"4syGzw","date":"1453689513","viewed":157,"name":"SSTV Encoder WIP (Loud)","username":"Flyguy","description":" A WIP Martin M2 Slow Scan Television (SSTV) encoder. <br\/>The image can be decoded using software such as MMSSTV and should look something like this : http:\/\/i.imgur.com\/bY4sMMI.png (Quality may vary).","likes":2,"published":3,"flags":8,"tags":["sound","modulation","sstv","radio","encode"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"float tau = atan(1.0)*8.0;\n\nvec3 Image(vec2 uv)\n{\n    vec3 color = vec3(0);\n    \n    float split = 0.5 + sin(uv.y * tau * 2.0) * 0.25;\n    \n    if(uv.x > split)\n    {\n    \tcolor = mix(vec3(1,0,0), vec3(0,1,0), uv.y);\t   \n    }\n    else\n    {\n    \tcolor = mix(vec3(1,1,0), vec3(0,0,1), uv.y);   \n    }\n    \n    color = mix(color, vec3(1.0), 1.0-step(0.1, length(uv - 0.5)));\n    \n    if(uv.y < 0.1)\n    {\n    \tcolor = vec3(step(0.5,fract(uv.x*uv.x*32.0)));   \n    }\n    \n\treturn color;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy \/ iResolution.y;\n\tvec2 uv = fragCoord.xy \/ iResolution.y;\n    uv.x += (1.0-res.x)\/2.0;\n    \n    vec3 color = Image(uv);\n    \n    color *= step(0.0, uv.x) - step(1.0, uv.x);\n\tfragColor = vec4(color, 1.0);\n}","name":"","description":"","type":"image"},{"inputs":[{"id":5,"src":"\/presets\/tex04.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/Slow Scan Television (SSTV) Encoder WIP\n\/\/Currently encodes as Martin M2 (RGB, 58sec, 250 lines)\n\/\/The signal is frequency modulated with a carrier of 1.9kHz\n\/\/Image decoded with MMSSTV : http:\/\/i.imgur.com\/bY4sMMI.png\n\n\/*\nUsful Links:\n- Overview & timing info : https:\/\/en.wikipedia.org\/wiki\/Slow-scan_television\n- VIS codes & mode info : http:\/\/www.g0hwc.com\/sstv_modes.html\n- MMSSTV decoder software : http:\/\/hamsoft.ca\/pages\/mmsstv.php\n\nCurrent issues:\n- Horizonal gradients mess up the signal\n- Quality degrades towards the bottom of the image \n*\/\n\n\/\/Number of lines the image has (used for timing)\n#define LINES 250.0\n\n\/\/Frequencies (hz)\n\/\/Center carrier frequency\n#define F_CARRIER 1900.0\n\/\/Sync pulse \n#define F_SYNC 1200.0\n\/\/VIS bit low (0)\n#define F_VIS_LOW 1300.0\n\/\/VIS bit high (1)\n#define F_VIS_HIGH 1100.0\n\/\/Intensity range 0-100%\n#define F_SCAN_LOW 1500.0\n#define F_SCAN_HIGH 2300.0\n\n\/\/Timing (ms)\n\/\/Image transmission time\n#define T_IMAGE 58000.0\n\/\/Calibration pulse length\n#define T_CAL 300.0\n\/\/Calibration sync length\n#define T_CAL_SYNC 10.0\n\/\/VIS header bit length\n#define T_VIS_BIT 30.0\n\/\/Line sync length\n#define T_SYNC 5.0\n\n\n\/\/Derived timing (ms)\n\/\/Header length\n#define T_HEADER (2.0*T_CAL + T_CAL_SYNC + 10.0*T_VIS_BIT)\n\/\/Length of a color line\n#define T_COLOR ((((T_IMAGE - T_HEADER) \/ LINES - T_SYNC)\/3.0))\n\/\/Length of a line (3 color lines (RGB) per line)\n#define T_LINE (3.0*T_COLOR)\n\n\/\/VIS header length (7 bits + parity)\n#define VIS_BITS 7\n\n\/\/Martin M2 VIS code\n#define VIS 0xA8\n\n#define GREEN 0\n#define BLUE 1\n#define RED 2\n\nfloat tau = atan(1.0)*8.0;\n\nbool checkBit(float n, float b)\n{\n    n = floor(n);\n    b = floor(b);\n\treturn mod(floor(n \/ exp2(b)),2.0) == 0.0;    \n}\n\n\/\/Even parity\nbool calcParity(float n)\n{\n\tbool parity = checkBit(n,0.0);\n    \n    for(int i = 1;i < VIS_BITS;i++)\n    {\n    \tparity = parity ^^ checkBit(n, float(i));   \n    }\n    \n    return parity;\n}\n\n\/\/Output the frequency for the header for the given time.\nfloat Header(float ms)\n{\n\tfloat f = F_CARRIER;\n    \n    \/\/Initial calibration sync pulse\n    f = mix(f, F_SYNC, step(T_CAL, ms));\n    \/\/Carrier calibration\n    f = mix(f, F_CARRIER, step(T_CAL + T_CAL_SYNC, ms));\n    \n    \/\/Bit time\n    float tbit = max(0.0, ms - (2.0 * T_CAL + T_CAL_SYNC));\n    \/\/Current bit to send (-1 = start, 0-6 = VIS header, 7 = parity, 8 = end)\n    float bit = floor(tbit \/ T_VIS_BIT)-1.0;\n    \n    \/\/7-bit VIS header\n    float bitf = checkBit(float(VIS), bit) ? F_VIS_LOW : F_VIS_HIGH;\n    \n    \/\/Parity bit\n    if(bit == 7.0)\n    {\n    \tbitf = calcParity(float(VIS)) ? F_VIS_LOW : F_VIS_HIGH;   \n    }\n    \n    \/\/Start \/ Stop bits\n    if(bit == -1.0 || bit == 8.0)\n    {\n    \tbitf = F_SYNC;\n    }\n    \n    \/\/Mix VIS header into signal\n    f = mix(f, bitf, step(2.0 * T_CAL + T_CAL_SYNC, ms));\n    \n    return f;\n}\n\nvec3 Image(vec2 uv)\n{\n    vec3 color = vec3(0);\n    \n    float split = 0.5 + sin(uv.y * tau * 2.0) * 0.25;\n    \n    if(uv.x > split)\n    {\n    \tcolor = mix(vec3(1,0,0), vec3(0,1,0), uv.y);\t   \n    }\n    else\n    {\n    \tcolor = mix(vec3(1,1,0), vec3(0,0,1), uv.y);   \n    }\n    \n    color = mix(color, vec3(1.0), 1.0-step(0.1, length(uv - 0.5)));\n    \n    if(uv.y < 0.1)\n    {\n    \tcolor = vec3(step(0.5,fract(uv.x*uv.x*32.0)));   \n    }\n    \n\treturn color;   \n}\n\nvec2 mainSound( float time )\n{\n    \/\/Time in milliseconds.\n    float tms = time*1000.0;\n    \n    float f = F_CARRIER;\n    \n    \/\/Send the header.\n    if(tms < T_HEADER)\n    {\n    \tf = Header(tms);   \n    }\n    \/\/Send the image.\n    else\n    {\n        f = F_SCAN_LOW;\n        \n        float tline = mod(tms, T_LINE + T_SYNC);\n        \n        \/\/Current line (0-250)\n        float line = floor((tms - T_HEADER) \/ (T_LINE + T_SYNC));\n        \n        \/\/Current color component (0-2) (GREEN, BLUE, RED)\n\t\tint comp = int(tline \/ T_COLOR);\n        \n        vec2 uv = vec2(fract(tline\/T_COLOR), line\/LINES);\n        \n        \/\/flip Y because SSTV scans from top to bottom\n        uv.y = 1.0 - uv.y;\n        \n        if(comp == RED)\n        {\n        \tf = mix(F_SCAN_LOW, F_SCAN_HIGH, Image(uv).r);   \n        }\n        \n        if(comp == GREEN)\n        {\n        \tf = mix(F_SCAN_LOW, F_SCAN_HIGH, Image(uv).g);   \n        }\n        \n        if(comp == BLUE)\n        {\n        \tf = mix(F_SCAN_LOW, F_SCAN_HIGH, Image(uv).b);   \n        }\n        \n        \/\/Line sync pulse\n        if(tline > T_LINE)\n        {\n            f = F_SYNC;   \n        }\n    }\n    \n    float phase = tau * (F_CARRIER*time + (f-F_CARRIER)*time);\n    \n    \/\/The high frequencies seem to cause some precision issues. \n    \/\/Without mod(phase, tau) the signal will degrade very quickly. \n    return vec2(sin(mod(phase, tau)));\n}","name":"","description":"","type":"sound"}]}}