{"Shader":{"ver":"0.1","info":{"id":"MdBGWG","date":"1392906963","viewed":2067,"name":"Brushed Metal","username":"TekF","description":"My  with a voronoi pattern.","likes":28,"published":3,"flags":0,"tags":["anisotropic"],"hasliked":0},"renderpass":[{"inputs":[{"id":10,"src":"\/presets\/tex09.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Ben Quantock 2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nvec2 Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec4 rg = texture2D( iChannel0, (uv+0.5)\/256.0, -100.0 );\n\treturn mix( rg.yw, rg.xz, f.z );\n}\n\n\nfloat DistanceField( vec3 pos )\n{\n\t\/\/pos = abs(pos); return max( pos.x, max( pos.y, pos.z ) )-1.0;\n\t\n\tfloat p = 16.0; pos = pow(abs(pos),vec3(p\/2.0)); return pow( dot( pos, pos ), 1.0\/p )-1.0;\n\t\n\t\/\/return (length(pos-vec3(0,-1,0))-2.0 + sin(sqrt(pow(atan(length(pos.xz),pos.y),2.0)+1.0)*20.0\/*-iGlobalTime*\/)\/20.0)*.707;\n\t\n\t\/\/return (pos.y + sin(pos.x*1.0)*sin(pos.z*1.0)\/1.0)*.7;\n}\n\n\nvec3 Sky( vec3 ray )\n{\n\treturn mix( vec3(.8), vec3(0), exp2(-(1.0\/max(ray.y,.01))*vec3(.4,.6,1.0)) );\n}\n\n\nvec4 tap2( vec3 p )\n{\n\tvec2 uv = p.xy+vec2(37.0,17.0)*p.z;\n\treturn texture2D( iChannel0, (uv+0.5)\/256.0, -100.0 );\n}\n\nvec3 VoronoiNode( vec2 seed )\n{\n\t\/\/ position within an octahedron\n\t\/\/ input values are integers in [0,255]\/255.0, so only 65536 possible values\n\t\n\t\/\/ I can't see a nice way to put points inside the octahedron, so just put it on the edges\n\tseed = seed-.5;\n\tfloat z = abs(seed.x)+abs(seed.y)-.5;\n\tif ( z > 0.0 )\n\t{\n\t\t\/\/ fold the corners back in\n\t\tseed = fract(seed)-.5;\n\t\treturn vec3(seed,z);\n\t}\n\telse\n\t{\n\t\treturn vec3(seed,z);\n\t}\n}\n\n\nstruct VoronoiNeighbours {\n\tvec3 p0;\n\tfloat d0;\n\tvec3 p1;\n\tfloat d1;\n\tfloat d2;\n};\n\nvoid VoronoiTest( inout VoronoiNeighbours r, vec3 pos, vec3 node )\n{\n\tfloat l = length(node-pos);\n\tif ( l < r.d0 )\n\t{\n\t\tr.d2 = r.d1;\n\t\tr.p1 = r.p0; r.d1 = r.d0;\n\t\tr.p0 = node; r.d0 = l;\n\t}\n\telse if ( l < r.d1 )\n\t{\n\t\tr.d2 = r.d1;\n\t\tr.p1 = node; r.d1 = l;\n\t}\n\telse if ( l < r.d2 )\n\t{\n\t\tr.d2 = l;\n\t}\n}\n\n\nVoronoiNeighbours Voronoi( in vec3 x )\n{\n\tvec3 p = floor(x+.5);\n\tvec3 d = vec3(-1,0,1);\n\n\tvec4 _00 = tap2(p+d.xxx); vec2 _000 = _00.yw; vec2 _001 = _00.xz;\n\tvec4 _01 = tap2(p+d.xyx); vec2 _010 = _01.yw; vec2 _011 = _01.xz;\n\tvec4 _02 = tap2(p+d.xzx); vec2 _020 = _02.yw; vec2 _021 = _02.xz;\n\tvec4 _10 = tap2(p+d.yxx); vec2 _100 = _10.yw; vec2 _101 = _10.xz;\n\tvec4 _11 = tap2(p+d.yyx); vec2 _110 = _11.yw; vec2 _111 = _11.xz;\n\tvec4 _12 = tap2(p+d.yzx); vec2 _120 = _12.yw; vec2 _121 = _12.xz;\n\tvec4 _20 = tap2(p+d.zxx); vec2 _200 = _20.yw; vec2 _201 = _20.xz;\n\tvec4 _21 = tap2(p+d.zyx); vec2 _210 = _21.yw; vec2 _211 = _21.xz;\n\tvec4 _22 = tap2(p+d.zzx); vec2 _220 = _22.yw; vec2 _221 = _22.xz;\n\n\tvec2 _002 = tap2(p+d.xxz).yw;\n\tvec2 _012 = tap2(p+d.xyz).yw;\n\tvec2 _022 = tap2(p+d.xzz).yw;\n\tvec2 _102 = tap2(p+d.yxz).yw;\n\tvec2 _112 = tap2(p+d.yyz).yw;\n\tvec2 _122 = tap2(p+d.yzz).yw;\n\tvec2 _202 = tap2(p+d.zxz).yw;\n\tvec2 _212 = tap2(p+d.zyz).yw;\n\tvec2 _222 = tap2(p+d.zzz).yw;\n\n\tVoronoiNeighbours r;\n\tr.p0 = vec3(0); r.d0 = 10.0;\n\tr.p1 = vec3(0); r.d1 = 10.0;\n\n\tVoronoiTest( r, x, VoronoiNode(_000)+d.xxx+p );\n\tVoronoiTest( r, x, VoronoiNode(_001)+d.xxy+p );\n\tVoronoiTest( r, x, VoronoiNode(_002)+d.xxz+p );\n\tVoronoiTest( r, x, VoronoiNode(_010)+d.xyx+p );\n\tVoronoiTest( r, x, VoronoiNode(_011)+d.xyy+p );\n\tVoronoiTest( r, x, VoronoiNode(_012)+d.xyz+p );\n\tVoronoiTest( r, x, VoronoiNode(_020)+d.xzx+p );\n\tVoronoiTest( r, x, VoronoiNode(_021)+d.xzy+p );\n\tVoronoiTest( r, x, VoronoiNode(_022)+d.xzz+p );\n\tVoronoiTest( r, x, VoronoiNode(_100)+d.yxx+p );\n\tVoronoiTest( r, x, VoronoiNode(_101)+d.yxy+p );\n\tVoronoiTest( r, x, VoronoiNode(_102)+d.yxz+p );\n\tVoronoiTest( r, x, VoronoiNode(_110)+d.yyx+p );\n\tVoronoiTest( r, x, VoronoiNode(_111)+d.yyy+p );\n\tVoronoiTest( r, x, VoronoiNode(_112)+d.yyz+p );\n\tVoronoiTest( r, x, VoronoiNode(_120)+d.yzx+p );\n\tVoronoiTest( r, x, VoronoiNode(_121)+d.yzy+p );\n\tVoronoiTest( r, x, VoronoiNode(_122)+d.yzz+p );\n\tVoronoiTest( r, x, VoronoiNode(_200)+d.zxx+p );\n\tVoronoiTest( r, x, VoronoiNode(_201)+d.zxy+p );\n\tVoronoiTest( r, x, VoronoiNode(_202)+d.zxz+p );\n\tVoronoiTest( r, x, VoronoiNode(_210)+d.zyx+p );\n\tVoronoiTest( r, x, VoronoiNode(_211)+d.zyy+p );\n\tVoronoiTest( r, x, VoronoiNode(_212)+d.zyz+p );\n\tVoronoiTest( r, x, VoronoiNode(_220)+d.zzx+p );\n\tVoronoiTest( r, x, VoronoiNode(_221)+d.zzy+p );\n\tVoronoiTest( r, x, VoronoiNode(_222)+d.zzz+p );\n\n\treturn r;\n}\n\nvec3 Shade( vec3 pos, vec3 ray, vec3 normal, vec3 lightDir, vec3 lightCol )\n{\n\tfloat ndotl = dot(normal,lightDir);\n\tvec3 light = lightCol*max(.0,ndotl);\n\tlight += mix( vec3(.01,.04,.08), vec3(.1), (-normal.y+1.0) ); \/\/ ambient\n\t\n\tvec3 h = normalize(lightDir-ray);\n\n\tvec3 uvw = pos*4.0;\n\tVoronoiNeighbours v = Voronoi(uvw);\n\n\t\/\/ mix together - this gets sharp points where d2 is outside the voronoi's sample range, or where d3 would get close to d2\n\tfloat weight0 = max(.0,1.0-v.d0)*pow(v.d2-v.d0,2.0);\n\tfloat weight1 = max(.0,1.0-v.d1)*pow(v.d2-v.d1,2.0);\n\n\t\/\/ compute highlight for nearest 2 points, then blend highlights\n\tvec3 aniso0 = v.p0-uvw;\n\tvec3 aniso1 = v.p1-uvw;\n\taniso0 -= normal*dot(aniso0,normal);\n\taniso1 -= normal*dot(aniso1,normal);\n\taniso0 = normalize(aniso0);\n\taniso1 = normalize(aniso1);\n\t\n\tfloat anisotropy = .8;\n\n\tfloat nh = max(.0,dot(normal,h));\n\tfloat ah0 = abs(dot(h,aniso0)); \/\/ check if it's perpendicular to the striations\n\tfloat ah1 = abs(dot(h,aniso1));\n\t\n\tfloat q = exp2((1.0-anisotropy)*1.0);\n\tnh = pow( nh, q*10.0 );\n\tfloat nh0 = nh*pow( 1.0-ah0*anisotropy, 4.0 );\n\tfloat nh1 = nh*pow( 1.0-ah1*anisotropy, 4.0 );\n\tfloat specular0 = nh0*exp2((1.0-anisotropy)*4.0);\n\tfloat specular1 = nh1*exp2((1.0-anisotropy)*4.0);\n\n\tvec3 specular = lightCol*mix( specular0, specular1, weight1\/(weight0+weight1) );\n\n\t\n\t\/\/ fade specular near terminator, to fake gradual occlusion of the micronormals\n\tspecular *= smoothstep(.0,.5,ndotl);\n\t\n\tvec3 reflection = Sky( reflect(ray,normal) );\n\tfloat fresnel = pow( 1.0+dot(normal,ray), 5.0 );\n\tfresnel = mix( .0, .2, fresnel );\n\n\t\n\t\/\/vec3 albedo = mix( fract(v.p0), fract(v.p1), weight1\/(weight0+weight1) ); \/\/ show the brushed patches\n\tvec3 albedo = vec3(.2);\n\t\n\treturn mix( light*albedo, reflection, fresnel ) + specular;\n}\n\n\n\n\/\/ Isosurface Renderer\n\nfloat traceStart = .1; \/\/ set these for tighter bounds for more accuracy\nfloat traceEnd = 40.0;\nfloat Trace( vec3 pos, vec3 ray )\n{\n\tfloat t = traceStart;\n\tfloat h;\n\tfor( int i=0; i < 60; i++ )\n\t{\n\t\th = DistanceField( pos+t*ray );\n\t\tif ( h < .001 )\n\t\t\tbreak;\n\t\tt = t+h;\n\t}\n\t\n\tif ( t > traceEnd )\/\/|| h > .001 )\n\t\treturn 0.0;\n\t\n\treturn t;\n}\n\nvec3 Normal( vec3 pos, vec3 ray )\n{\n\tconst vec2 delta = vec2(0,.001);\n\tvec3 grad;\n\tgrad.x = DistanceField( pos+delta.yxx )-DistanceField( pos-delta.yxx );\n\tgrad.y = DistanceField( pos+delta.xyx )-DistanceField( pos-delta.xyx );\n\tgrad.z = DistanceField( pos+delta.xxy )-DistanceField( pos-delta.xxy );\n\t\n\t\/\/ prevent normals pointing away from camera (caused by precision errors)\n\tfloat gdr = dot ( grad, ray );\n\tgrad -= max(.0,gdr)*ray;\n\t\n\treturn normalize(grad);\n}\n\n\n\/\/ Camera\n\nvec3 Ray( float zoom, vec2 fragCoord )\n{\n\treturn vec3( fragCoord.xy-iResolution.xy*.5, iResolution.x*zoom );\n}\n\nvec3 Rotate( inout vec3 v, vec2 a )\n{\n\tvec4 cs = vec4( cos(a.x), sin(a.x), cos(a.y), sin(a.y) );\n\t\n\tv.yz = v.yz*cs.x+v.zy*cs.y*vec2(-1,1);\n\tv.xz = v.xz*cs.z+v.zx*cs.w*vec2(1,-1);\n\t\n\tvec3 p;\n\tp.xz = vec2( -cs.w, -cs.z )*cs.x;\n\tp.y = cs.y;\n\t\n\treturn p;\n}\n\n\n\/\/ Camera Effects\n\nvoid BarrelDistortion( inout vec3 ray, float degree )\n{\n\tray.z \/= degree;\n\tray.z = ( ray.z*ray.z - dot(ray.xy,ray.xy) ); \/\/ fisheye\n\tray.z = degree*sqrt(ray.z);\n}\n\nvec3 LensFlare( vec3 ray, vec3 light, vec2 fragCoord )\n{\n\tvec2 dirtuv = fragCoord.xy\/iResolution.x;\n\t\n\tfloat dirt = 1.0-texture2D( iChannel1, dirtuv ).r;\n\t\n\tfloat l = max(.0,dot(light,ray));\n\t\n\treturn (pow(l,20.0)*dirt*.1 + 1.0*pow(l,100.0))*vec3(1.05,1,.95);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 ray = Ray(1.0,fragCoord);\n\tBarrelDistortion( ray, .5 );\n\tray = normalize(ray);\n\tvec3 localRay = ray;\n\n\tvec3 pos = 6.0*Rotate( ray, vec2(.4,iGlobalTime*.1+.7)+vec2(1.6,-6.3)*(iMouse.yx\/iResolution.yx - .5) );\n\t\n\tvec3 col;\n\n\tvec3 lightDir = normalize(vec3(3,2,-1));\n\t\n\tfloat t = Trace( pos, ray );\n\tif ( t > .0 )\n\t{\n\t\tvec3 p = pos + ray*t;\n\t\t\n\t\t\/\/ shadow test\n\t\tfloat s = Trace( p, lightDir );\n\t\t\n\t\tvec3 n = Normal(p, ray);\n\t\tcol = Shade( p, ray, n, lightDir, (s>.0)?vec3(0):vec3(.98,.95,.92) );\n\t\t\n\t\t\/\/ fog\n\t\tfloat f = 100.0;\n\/\/\t\tcol *= exp2(-t*vec3(.1,.6,1.0)\/f);\n\t\tcol = mix( vec3(.8), col, exp2(-t*vec3(.4,.6,1.0)\/f) );\n\t}\n\telse\n\t{\n\t\tcol = Sky( ray );\n\t}\n\t\n\tfloat sun = Trace( pos, lightDir );\n\tif ( sun == .0 )\n\t{\n\t\tcol += LensFlare( ray, lightDir, fragCoord );\n\t}\n\t\n\t\/\/ vignetting:\n\tcol *= smoothstep( .5, .0, dot(localRay.xy,localRay.xy) );\n\n\t\/\/ compress bright colours, ( because bloom vanishes in vignette )\n\tvec3 c = (col-1.0);\n\tc = sqrt(c*c+.01); \/\/ soft abs\n\tcol = mix(col,1.0-c,.48); \/\/ .5 = never saturate, .0 = linear\n\t\n\n\t\/\/ grain\n\tvec2 grainuv = fragCoord.xy + floor(iGlobalTime*60.0)*vec2(37,41);\n\tvec2 filmNoise = texture2D( iChannel0, .5*grainuv\/iChannelResolution[0].xy ).rb;\n\tcol *= mix( vec3(1), mix(vec3(1,.5,0),vec3(0,.5,1),filmNoise.x), .1*filmNoise.y );\n\n\t\n\tfragColor = vec4(pow(col,vec3(1.0\/2.6)),1);\n}\n","name":"","description":"","type":"image"}]}}