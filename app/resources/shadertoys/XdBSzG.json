{"Shader":{"ver":"0.1","info":{"id":"XdBSzG","date":"1413008796","viewed":3942,"name":"Tentacle Thing","username":"iq","description":"Tentacle thingy. Inspired by a conversation with Dila and his tentacle shader","likes":42,"published":3,"flags":0,"tags":["procedural","3d","raymarching"],"hasliked":0},"renderpass":[{"inputs":[{"id":4,"src":"\/presets\/tex03.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat sdSegment( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1. );\t\n    return length( pa - ba*h ) - r;\n}\n\nconst float slab = 0.05;\n\nvec3 map( vec3 pos ) \n{\n    float an = 2.0*sin( 0.5*iGlobalTime - 0.5*length(pos) );\n    float co = cos(an);\n    float si = sin(an);\n    mat2 gRot = mat2( co, -si, si, co );\n    \n    pos.xz = gRot*pos.xz;\n    \n    pos.x -= 0.2*an;\n    \n    float rad = length(pos);\n    float the = atan(pos.x,pos.z)+3.1416;\n    float kid = floor(the\/6.2831\/slab);\n    float phi = acos(pos.y\/rad) + 3.0*kid;\n    \n    vec2 id = floor( vec2(the,phi)\/6.2831\/slab );\n\n    the = mod( the\/6.2831, slab ) - slab*0.5;\n    phi = mod( phi\/6.2831, slab ) - slab*0.5;\n\n    float anph = dot(id,vec2(3171.15,2317.34));\n    the += rad*0.002*cos(-rad*8.0 + 2.0*iGlobalTime + anph);\n    phi += rad*0.002*sin(-rad*8.0 + 2.0*iGlobalTime + anph);\n    \n    float len =      1.50 * (0.7+0.3*sin(dot(id,vec2(1213.15,1317.34))));\n    float thi = slab*0.25 * (0.6+0.4*sin(6.2831*rad\/len));\n\n    float d = sdSegment( vec3(the*8.0,phi*8.0,rad), \n                         vec3(0.0,0.0,0.0), \n                         vec3(0.0,0.0,len), thi*8.0 )\/8.0;\n    \n    return vec3( d, rad\/len, dot(id,vec2(217.2,311.3)) );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const vec2 e = vec2(1.0,-1.0)*0.001;\n\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nvec4 intersect( in vec3 ro, in vec3 rd, float tmin, float tmax )\n{\n    float t = tmin;\n\n    vec4 res = vec4(-1.0);\n    for( int i=0; i<200; i++ ) \n    {\n\t\tvec3 d = map( ro + t*rd );\n        \n\t\tif( d.x < 0.002 )\n        {\n            res = vec4( t, d.yz, float(i)\/200.0 );\n            break;\n        }\n        \n        t += d.x;\n\n        if( t>tmax ) break;\n    }\n    \n    return res;\n}\n\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n\treturn vec2( -b - h, -b + h );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec2  p = (-iResolution.xy+2.0*fragCoord.xy)\/iResolution.y;\n    vec2  q = fragCoord.xy\/iResolution.xy;\n\n    vec3 ta = vec3(-0.9,0.0,0.0);\n    vec3 ro = vec3(-0.9,0.0,2.5);        \n    \n    vec3  ww = normalize( ta - ro);\n    vec3  uu = normalize( cross( normalize(vec3(0.2,1.0,0.0)), ww ) );\n    vec3  vv = normalize( cross(ww,uu) );\n    vec3  rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n    \n    vec3 col = vec3( 0.15, 0.17, 0.15 ) + 0.1*p.y;\n    \n    col += 0.3*pow( texture2D(iChannel0, 0.05*p).yxx, vec3(4.0) );\n        \n    vec2 sp = iSphere( ro, rd, vec4(0.0,0.0,0.0,1.9) );\n    if( sp.y>0.0 )\n    {\n        vec4 res = intersect( ro, rd, max(sp.x,0.0), sp.y );\n\n        if( res.x>0.0 )\n        {\n            float t = res.x;\n            float m = res.z;\n            float g = res.y;\n            vec3  pos = ro + t*rd;\n            vec3  nor = calcNormal( pos );\n            float id = 0.5 + 0.5*sin(m);\n\n            col = 0.5 + 0.5*cos( 0.0 + id*6.2831*0.3 + vec3(0.0,1.0,1.5) );\n            col += vec3(0.3,0.2,0.1)*smoothstep(0.9,1.0,g);\n            col *= 1.3;\n            \n            col *= 0.05 + 0.95*smoothstep( -0.9, 0.0, smoothstep(0.9,1.0,g)+sin( 1.0 + g*30.0  ) );\n\n            col *= 0.5 + 0.5*nor.y;\n            col += col*vec3(3.0,2.0,1.0)*clamp(1.0+dot(rd,nor),0.0,1.0);\n            col *= g*g;\n            col *= 2.5*pow(1.0-res.w,4.0);\n        }\n    }\n    \n    col = pow( col, vec3(0.4545) );\n    \n    col *= vec3(1.0,1.2,1.4);\n\n    col = mix( col, vec3(dot(col,vec3(0.333))), -0.25 );\n    \n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n    \n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}