{"Shader":{"ver":"0.1","info":{"id":"lllSR7","date":"1435522792","viewed":760,"name":"Materials (Tutorial)","username":"janneasdf","description":"This shader demonstrates a way to handle shading different materials. Basically the map function returns also the material of the closest object (\"hitMaterial\"), which will be used to decide shading logic.","likes":3,"published":3,"flags":0,"tags":["3d","raymarching","tutorial"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Materials\nconst int MAT_BACKGROUND = 0;\nconst int MAT_SPHERE1 = 1;\nconst int MAT_SPHERE2 = 2;\n\n\/\/ Helper function for updating nearest scene hit material\nvoid distCheck(float newDist, inout float minDist, int newMaterial, inout int minMaterial)\n{\n    if (newDist < minDist)\n    {\n    \tminDist = newDist;\n        minMaterial = newMaterial;\n    }\n}\n\n\/\/ Distance closest distance from point to sphere\nfloat sdSphere(vec3 rayPos, vec3 spherePos, float sphereRadius)\n{\n\tfloat dist = length(rayPos - spherePos) - sphereRadius;\n    return dist;\n}\n\n\/\/ Distance to closest scene object. Also sets closest object material into \"hitMaterial\".\nfloat map(vec3 rayPos, out int hitMaterial)\n{\n    float minDist = 99999.0;\n    hitMaterial = MAT_BACKGROUND;\n    \n    float tempDist = sdSphere(rayPos, vec3(0.3, 0.0, 0.0), 0.2);\n    distCheck(tempDist, minDist, MAT_SPHERE1, hitMaterial);\n    tempDist = sdSphere(rayPos, vec3(-0.3, 0.0, 0.0), 0.2);\n    distCheck(tempDist, minDist, MAT_SPHERE2, hitMaterial);\n    \n    return minDist;\n}\n\n\/\/ Helper function for map that doesn't need to return hitMaterial.\nfloat map(vec3 rayPos)\n{\n\tint tempHitMaterial;\n    return map(rayPos, tempHitMaterial);\n}\n\n\/\/ Uses map function (smallest distance to scene) for\n\/\/ approximating normal at pos\nvec3 approxNormal(vec3 pos)\n{\n    float epsilon = 0.001;\n\tvec2 t = vec2(0.0, epsilon);\n    vec3 n = vec3(map(pos + t.yxx) - map(pos - t.yxx),\n           \t  map(pos + t.xyx) - map(pos - t.xyx),\n              map(pos + t.xxy) - map(pos - t.xxy));\n    return normalize(n);\n}\n\n\/\/ Computes background color\nvec3 shadeBackground(vec3 rayPos, vec3 normal)\n{\n    return vec3(0.2, 0.2, 0.2);\n}\n\n\/\/ Computes sphere1 color\nvec3 shadeSphere1(vec3 rayPos, vec3 normal)\n{\n    return vec3(1.0, 0.0, 0.0);\n}\n\n\/\/ Computes sphere2 color\nvec3 shadeSphere2(vec3 rayPos, vec3 normal)\n{\n    return vec3(0.0, 1.0, 0.0);\n}\n\n\/\/ Computes color for ray with origin \"rayPos\" and direction \"rayDir\"\nvec3 getColor(vec3 rayPos, vec3 rayDir)\n{\n    int hitMaterialTemp;\n    int hitMaterial = MAT_BACKGROUND;\n    for (int i = 0; i < 128; ++i)\n    {\n        float d = map(rayPos, hitMaterialTemp);\n        rayPos += d * rayDir;\n        if (d < 0.001)\n        {\n            hitMaterial = hitMaterialTemp;\n            break;\n        }\n    }\n    vec3 normal = approxNormal(rayPos);\n    vec3 color;\n    if (hitMaterial == MAT_BACKGROUND)\n        color = shadeBackground(rayPos, normal);\n    else if (hitMaterial == MAT_SPHERE1)\n        color = shadeSphere1(rayPos, normal);\n    else if (hitMaterial == MAT_SPHERE2)\n        color = shadeSphere2(rayPos, normal);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    float aspect = iResolution.x \/ iResolution.y;\n    \n    \/\/ Make uv go [-0.5, 0.5] and scale uv.x according to aspect ratio\n    uv -= .5;\n    uv.x = aspect * uv.x;\n    \n    \/\/ Initialize camera stuff\n    vec3 camPos = vec3(0., 0., -1.);\n    vec3 camTarget = vec3(0., 0., 0.);\n    vec3 camUp = vec3(0., 1., 0.);\n    vec3 camDir = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(camUp, camDir));\n    camUp = normalize(cross(camDir, camRight));\n    \n    vec3 rayPos = camPos;\n    vec3 rayDir = normalize(camDir + uv.x * camRight + uv.y * camUp);\n    \n    \/\/ Raymarch scene to get pixel color\n    vec3 color = getColor(rayPos, rayDir);\n    \n    \/\/ Set pixel color\n\tfragColor = vec4(color, 1.0);\n}","name":"","description":"","type":"image"}]}}