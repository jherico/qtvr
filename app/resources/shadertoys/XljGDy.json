{"Shader":{"ver":"0.1","info":{"id":"XljGDy","date":"1443741481","viewed":3944,"name":"Sphere - fog density","username":"iq","description":"Analytically integrating quadratically decaying participating media within a sphere. No raymarching involved.","likes":21,"published":3,"flags":0,"tags":["3d","sphere","fog","media","analytical"],"hasliked":0},"renderpass":[{"inputs":[{"id":6,"src":"\/presets\/tex05.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Analytically integrating quadratically decaying participating media within a sphere. \n\/\/ No raymarching involved.\n\/\/\n\/\/ Related info: http:\/\/iquilezles.org\/www\/articles\/spherefunctions\/spherefunctions.htm\n\n\n\/\/-------------------------------------------------------------------------------------------\n\/\/ sphere related functions\n\/\/-------------------------------------------------------------------------------------------\n\nfloat sphDensity( vec3  ro, vec3  rd,   \/\/ ray origin, ray direction\n                  vec3  sc, float sr,   \/\/ sphere center, sphere radius\n                  float dbuffer )       \/\/ depth buffer\n{\n    \/\/ normalize the problem to the canonical sphere\n    float ndbuffer = dbuffer \/ sr;\n    vec3  rc = (ro - sc)\/sr;\n\t\n    \/\/ find intersection with sphere\n    float b = dot(rd,rc);\n    float c = dot(rc,rc) - 1.0;\n    float h = b*b - c;\n\n    \/\/ not intersecting\n    if( h<0.0 ) return 0.0;\n\t\n    h = sqrt( h );\n    \n    \/\/return h*h*h;\n\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    \/\/ not visible (behind camera or behind ndbuffer)\n    if( t2<0.0 || t1>ndbuffer ) return 0.0;\n\n    \/\/ clip integration segment from camera to ndbuffer\n    t1 = max( t1, 0.0 );\n    t2 = min( t2, ndbuffer );\n\n    \/\/ analytical integration of an inverse squared density\n    float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1\/3.0);\n    float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2\/3.0);\n    return (i2-i1)*(3.0\/4.0);\n}\n\nvec3 sphNormal( in vec3 pos, in vec4 sph )\n{\n    return normalize(pos-sph.xyz);\n}\n\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n    h = sqrt( h );\n\treturn -b - h;\n}\n\nfloat sphOcclusion( in vec3 pos, in vec3 nor, in vec4 sph )\n{\n    vec3  di = sph.xyz - pos;\n    float l  = length(di);\n    float nl = dot(nor,di\/l);\n    float h  = l\/sph.w;\n    float h2 = h*h;\n    float k2 = 1.0 - h2*nl*nl;\n\n    \/\/ above\/below horizon: Quilez - http:\/\/iquilezles.org\/www\/articles\/sphereao\/sphereao.htm\n    float res = max(0.0,nl)\/h2;\n    \/\/ intersecting horizon: Lagarde\/de Rousiers - http:\/\/www.frostbite.com\/wp-content\/uploads\/2014\/11\/course_notes_moving_frostbite_to_pbr.pdf\n    if( k2 > 0.0 ) \n    {\n        #if 1\n            res = nl*acos(-nl*sqrt( (h2-1.0)\/(1.0-nl*nl) )) - sqrt(k2*(h2-1.0));\n            res = res\/h2 + atan( sqrt(k2\/(h2-1.0)));\n            res \/= 3.141593;\n        #else\n            \/\/ cheap approximation: Quilez\n            res = pow( clamp(0.5*(nl*h+1.0)\/h2,0.0,1.0), 1.5 );\n        #endif\n    }\n\n    return res;\n}\n\nfloat plnIntersect( in vec3 ro, in vec3 rd, vec4 pln )\n{\n    return (pln.w - dot(ro,pln.xyz))\/dot(rd,pln.xyz);\n}\n\n\/\/=====================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy) \/ iResolution.y;\n    \n\tvec3 ro = vec3(0.0, 0.2, 3.0 );\n\tvec3 rd = normalize( vec3(p,-3.0) );\n\t\n    \/\/ sphere\n    vec4 sph = vec4( cos( iGlobalTime*vec3(1.0,1.1,1.3) + vec3(2.0,1.5,1.5) + 0.0 )*vec3(1.5,0.3,0.7) + vec3(0.0,0.2,0.5), 1.4 );\n    \/\/ planes\n    vec4 pl1 = vec4(  0.0, 1.0, 0.0, 0.0 );\n    vec4 pl2 = vec4(  1.0, 0.0, 0.0, 1.0 );\n    vec4 pl3 = vec4( -1.0, 0.0, 0.0, 1.0 );\n    vec4 pl4 = vec4(  0.0, 0.0,-1.0, 1.0 );\n    \n    float th = (-1.0+2.0*smoothstep( 0.8, 0.9, sin( iGlobalTime*1.0 )));\n    th *= iResolution.x\/iResolution.y;\n    \n    vec3 lig = normalize( vec3(0.6,0.3,0.4) );\n\n\n    \n    float t1 = sphIntersect( ro, rd, sph );\n    float t2 = plnIntersect( ro, rd, pl1 );\n    float t3 = plnIntersect( ro, rd, pl2 );\n    float t4 = plnIntersect( ro, rd, pl3 );\n    float t5 = plnIntersect( ro, rd, pl4 );\n    \n    float tmin = 1000.0;\n    vec4  omin = vec4(0.0);\n    if( t2>0.0 && t2<tmin ) { tmin=t2; omin=pl1; }\n    if( t3>0.0 && t3<tmin ) { tmin=t3; omin=pl2; }\n    if( t4>0.0 && t4<tmin ) { tmin=t4; omin=pl3; }\n    if( t5>0.0 && t5<tmin ) { tmin=t5; omin=pl4; }\n\n    vec3 col = vec3(0.0);\n    \n    if( tmin<999.0 )\n    {    \n        vec3 pos = ro + tmin*rd;\n\n        col = vec3(0.1,0.15,0.2);\n        col *= 0.8 + 0.4*dot(omin.xyz,lig);\n        \n        vec3 w = abs(omin.xyz);\n        col = (texture2D( iChannel0, 0.5*pos.zx ).xyz*w.y+\n               texture2D( iChannel0, 0.5*pos.xy ).xyz*w.z+\n               texture2D( iChannel0, 0.5*pos.yz ).xyz*w.x)\/(w.x+w.y+w.z);\n        col *= 0.3;\n        float occ = 1.0;\n        occ *= smoothstep( 0.0, 0.5, length( pos.xy-vec2( 1.0, 0.0)));\n        occ *= smoothstep( 0.0, 0.5, length( pos.xy-vec2(-1.0, 0.0)));\n        occ *= smoothstep( 0.0, 0.5, length( pos.yz-vec2( 0.0,-1.0)));\n        occ *= smoothstep( 0.0, 0.5, length( pos.xz-vec2( 1.0,-1.0)));\n        occ *= smoothstep( 0.0, 0.5, length( pos.xz-vec2(-1.0,-1.0)));\n        col *= vec3(0.4,0.3,0.2) + vec3(0.6,0.7,0.8)*occ;\n        \n        \n        if( p.x<th )\n        col *= 1.0 - 0.6*sphOcclusion( pos, omin.xyz, sph );\n    }\n\n    if( p.x<th && t1>0.0 && t1<tmin )\n    {\n        vec3 pos = ro + t1*rd;\n        vec3 nor = sphNormal( pos, sph );\n        \n        col = vec3(0.3);\n        \n        float occ = 1.0;\n        occ *= clamp( ( pos.x+1.0)*3.0, 0.0, 1.0 );\n        occ *= clamp( (-pos.x+1.0)*3.0, 0.0, 1.0 );\n        occ *= clamp( ( pos.y-0.0)*3.0, 0.0, 1.0 );\n        occ *= clamp( ( pos.z+1.0)*3.0, 0.0, 1.0 );\n        col *= 0.5 + 0.5*occ;\n    }\n\n    if( p.x>th )\n    {\n        float h = sphDensity(ro, rd, sph.xyz, sph.w, tmin );\n        if( h>0.0 )\n        {\n            col = mix( col, vec3(0.2,0.5,1.0), h );\n            col = mix( col, 1.15*vec3(1.0,0.9,0.6), h*h*h );\n        }\n    }\n    \n    col = sqrt( col );\n    \n    col *= smoothstep( 0.010,0.011,abs(p.x-th));\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}