{"Shader":{"ver":"0.1","info":{"id":"MtlXR4","date":"1435001585","viewed":809,"name":"Golden Mandelbox","username":"LeWiZ","description":"A golden mandelbox !<br\/><br\/>But still too slow to visit inside... :-(","likes":4,"published":3,"flags":0,"tags":["raymarching","fractal","mandelbox"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Removing soft shadows improves FPS by a factor ~2.5, but it's less pretty\n#define SHADOWS\n\nvoid sphereFold(inout vec3 z, inout float dz)\n{\n\tfloat r2 = dot(z,z);\n\tif (r2 < 0.5)\n    { \n\t\tfloat temp = 2.0;\n\t\tz *= temp;\n\t\tdz*= temp;\n\t}\n    else if (r2 < 1.0)\n    { \n\t\tfloat temp = 1.0 \/ r2;\n\t\tz *= temp;\n\t\tdz*= temp;\n\t}\n}\n\nvoid boxFold(inout vec3 z, inout float dz)\n{\n\tz = clamp(z, -1.0, 1.0) * 2.0 - z;\n}\n\nfloat mandelbox(vec3 z)\n{\n    float scale = 2.0;\n\tvec3 offset = z;\n\tfloat dr = 1.0;\n\tfor (int n = 0; n < 10; n++)\n    {\n\t\tboxFold(z,dr);\n\t\tsphereFold(z,dr);\n        z = scale * z + offset;\n        dr = dr * abs(scale) + 1.0;\n\t}\n\tfloat r = length(z);\n\treturn r \/ abs(dr);\n}\n\nfloat plane(vec3 pos)\n{\n\treturn length(max(abs(pos)-vec3(12.0,0.5,12.0),0.0));\n}\n\nfloat scene(vec3 pos)\n{\n    return min(mandelbox(pos), plane(pos-vec3(0.0,-6.5,0.0)));\n}\n\nfloat raymarcher( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 50.0;\n\tconst float precis = 0.01;\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<100; i++ )\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = scene( ro+rd*t );\n        t += h * 1.0;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 normal( in vec3 pos )\n{\n    const float eps = 0.005;\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*scene( pos + v1*eps ) + \n\t\t\t\t\t  v2*scene( pos + v2*eps ) + \n\t\t\t\t\t  v3*scene( pos + v3*eps ) + \n\t\t\t\t\t  v4*scene( pos + v4*eps ) );\n}\n\nfloat softray( in vec3 ro, in vec3 rd , in float hn)\n{\n    float res = 1.0;\n    float t = 0.0005;\n\tfloat h = 1.0;\n    for( int i=0; i<40; i++ )\n    {\n        h = scene(ro + rd*t);\n        res = min( res, hn*h\/t );\n\t\tt += clamp( h, 0.02, 2.0 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat ambocc( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)\/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = scene( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 light( in vec3 lightdir, in vec3 lightcol, in vec3 tex, in vec3 norm, in vec3 camdir )\n{    \n    float cosa = pow(0.5 + 0.5*dot(norm, -lightdir),2.0);\n    float cosr = max(dot(-camdir, reflect(lightdir, norm)), -0.0);\n    \n    float diffuse = cosa;\n    float phong = pow(cosr, 8.0);\n    \n    return lightcol * (tex * diffuse + phong);\n}\n\nvec3 background( in vec3 rd )\n{\n\treturn vec3(1.0+2.0*rd.y);\n}\n\nvec3 material( in vec3 pos , in vec3 camdir )\n{    \n\tvec3 norm = normal(pos);\n    \n    vec3 d1 = -normalize(vec3(5.0,10.0,-20.0));\n    vec3 d2 = -normalize(vec3(-5,10.0,20.0));\n    vec3 d3 = -normalize(vec3(20,5.0,-5.0));\n    vec3 d4 = -normalize(vec3(-20.0,5.0,5.0));\n\t\n    vec3 tex = vec3(0.2);\n    if (pos.y > -5.95) tex = vec3(0.32,0.28,0.0);\n    \n    #ifdef SHADOWS\n    float sha = 0.7 * softray(pos, -d1, 32.0) + 0.3 * softray(pos, -d4, 16.0);\n    #else\n    float sha = 1.0;\n    #endif\n    float ao = ambocc(pos, norm);\n    \n    vec3 l1 = light(d1, vec3(1.0,0.9,0.8), tex, norm, camdir);\n    vec3 l2 = light(d2, vec3(0.8,0.7,0.6), tex, norm, camdir);\n    vec3 l3 = light(d3, vec3(0.3,0.3,0.4), tex, norm, camdir);\n    vec3 l4 = light(d4, vec3(0.5,0.5,0.5), tex, norm, camdir);\n    \n    #ifdef SHADOWS\n    return 0.2 * ao + 0.8 * (l1+l2+l3+l4)*sha;\n    #else\n    return 0.5 * ao + 0.5 * (l1+l2+l3+l4)*sha;\n    #endif\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvec3 rayrender(vec3 pos, vec3 dir)\n{\n   vec3 col = vec3(0.0);\n    \n   float dist = raymarcher(pos, dir);\n    \n    if (dist==-1.0) col = background(dir);\n    else\n    {\n    \tvec3 inters = pos + dist * dir;\n    \tcol = material(inters, dir);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iGlobalTime;\n    \n    vec2 xy = (fragCoord.xy - iResolution.xy\/2.0) \/ max(iResolution.xy.x, iResolution.xy.y);\n    \n    vec3 campos = vec3(35.0*cos(t\/5.0),10.0,35.0*sin(t\/5.0));\n    vec3 camtar = vec3(0.0,0.0,0.0);\n    \n    mat3 camMat = calcLookAtMatrix( campos, camtar, 0.0 );\n\tvec3 camdir = normalize( camMat * vec3(xy,0.9) );\n    \n    vec3 col = rayrender(campos, camdir);\n    \n    #ifdef SHADOWS\n    col = pow(col, vec3(1.0\/2.2));\n    #else\n    col = pow(col, vec3(1.0));\n    #endif\n    \n\tfragColor = vec4(col,1.0);\n}\n","name":"","description":"","type":"image"}]}}