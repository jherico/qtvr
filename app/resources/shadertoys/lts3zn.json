{"Shader":{"ver":"0.1","info":{"id":"lts3zn","date":"1418244445","viewed":1128,"name":"Cardboard Waves","username":"jimbo00000","description":"A set piece for a school play. Was aiming for Hokusai but landed in a Smashing Pumpkins video.","likes":13,"published":3,"flags":0,"tags":["2d","waves","flat","ocean","cardboard"],"hasliked":0},"renderpass":[{"inputs":[{"id":7,"src":"\/presets\/tex06.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\nconst float PI = 3.1415926535979;\n\n\/\/\/\/\/\/\/\/ Matrix math library\nvec2 rotate(vec2 p, float t)\n{\n    mat2 m = mat2(cos(t),-sin(t),sin(t),cos(t));\n    return m*p;\n}\n\n\/\/\/\/\/\/\/\/ Shape library\nfloat d_sphere( vec2 p, float radius )\n{\n    return length(p) - radius;\n}\n\nfloat d_sinewave( vec2 p )\n{\n    float time = iGlobalTime;\n    p.x -=\n        \/\/(.8+.25*sin(time))*\n        p.y; \/\/ bent forward\n    return p.y - sin(p.x);\n}\n\nfloat chopped_wave( vec2 p )\n{\n    p *= 8.0;\n    \n    vec2 pm = p;\n    pm += vec2(-3.3,0.1);\n    pm.x += 2.0;\n    pm.x = mod(pm.x, 2.*PI);\n    pm.x -= 2.0;\n    return\n        -min(\n            -d_sinewave(p),\n            d_sphere(pm*vec2(.5,1.), 0.95)\n    );\n}\n\nfloat dorky_dolphin( vec2 p, float radius, float rot )\n{\n    p.y += .75;\n    vec2 pp = vec2(length(p),atan(p.y,p.x));\n    float t = -rot+-2.2+2.*pp.y + 0.5*pp.x;\n    float r = radius\n        + 0.35*radius\n        * (1.-fract(t))\n        * (step(1.,t)-step(2.,t));\n    return max(pp.x-r, -p.y);\n}\n\n\n\/\/\/\/\/\/\/\/ Colorization\nvec3 wave_color( float d, float s, vec2 uv )\n{\n    float b = 0.001;\n    \/\/ border\n    float bw = 0.08;\n    float innergray =\n        mix(.5,0.,smoothstep(-0.01,0.01,d))\n      + mix(.0,1.,smoothstep(bw,2.*bw,d));\n    vec3 blue = vec3(\n        vec2(s)\n        + 0.2*length(texture2D(iChannel0, 0.2*uv))\n        , 1.);\n    vec3 white = vec3(1.);\n    return mix(white, blue, 2.*innergray);\n}\n\nvec2 getRoll(\n    in vec2 uv,\n    in float xscale, in float yoff,\n\tin vec2 bAmpl, in float bFreq )\n{\n    float time = iGlobalTime;\n    uv.x += bAmpl.x*sin(bFreq*time);\n    uv.y += bAmpl.y*cos(bFreq*time);\n    uv.x *= xscale;\n    uv.y += yoff;\n    return uv;\n}\n\nvec3 sunset( in vec2 uv )\n{\n    float time = iGlobalTime;\n    float sunh = sin(\n        0.005*\n        time);\n    vec2 sunpos = vec2(.5, .2-sunh);\n    vec3 hot = vec3(1.,1.,1.);\n    vec3 orange = vec3(1.,.65,0.);\n    vec3 red = vec3(.5,0.,0.);\n    float d = length(uv-sunpos);\n    float f = clamp(pow(1.3-d,3.),.0,1.);\n    return mix(orange, hot, f)\n         + mix(red, orange, uv.y-4.*sunh);\n}\n\nvec3 getColorFromUV( in vec2 uv )\n{\n    vec2 q = getRoll(uv,1.7, 0.5, vec2(0.3,0.1), 2.1);\n    float dist = chopped_wave(q);\n    float shade = 0.0;\n    if (dist > 0.1)\n    {\n        q = getRoll(1.5*uv,1.7, 0.35, vec2(0.1,0.05), 3.1);\n        dist = chopped_wave(q);\n        shade = 0.22;\n    }\n    if (dist > 0.1)\n    {\n    \tfloat time = iGlobalTime;\n        vec2 dof = vec2(4.*fract(0.1*time)-2.,0.2*sin(PI*time)+0.15);\n        dist = dorky_dolphin(uv+dof, 0.45,3.*fract(time)-1.6);\n        if (dist < 0.1)\n        \treturn vec3(0.5);\n    }\n    if (dist > 0.1)\n    {\n        q = getRoll(1.85*uv+vec2(.5,0.),1.7, 0.15, vec2(0.08,0.04), 4.1);\n        dist = chopped_wave(q);\n        shade = 0.35;\n    }\n    if (dist > 0.1)\n    {\n        q = getRoll(2.8*uv*vec2(1.,1.5)+vec2(.5,0.),2.2, -0.0, vec2(0.08,0.052), 3.1);\n        dist = chopped_wave(q);\n        shade = 0.5;\n    }\n    if (dist > 0.1)\n        return sunset(uv);\n    return wave_color(dist, shade, q);\n}\n\n\/\/\/\/\/\/\/\/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\n\t\/\/ Fit [-1,1] into screen and expand for aspect ratio\n\tvec2 uv11 = 2.0*uv - vec2(1.0,1.0);\n\tfloat aspect = iResolution.x \/ iResolution.y;\n\tif (aspect > 1.0) uv11.x *= aspect;\n\telse              uv11.y \/= aspect;\n    \n    vec2 center = vec2(0.0,0.0);\n    uv11 -= center;\n    vec3 col = getColorFromUV(uv11);\n    vec2 q = uv;\n\t\/\/col *= 0.3 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n\tfragColor = vec4(col, 1.0);\n}\n","name":"","description":"","type":"image"},{"inputs":[],"outputs":[{"channel":"0"}],"code":"float rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nvec2 mainSound(float time)\n{\n    float x = .4*time + 11.;\n    return \n        ((sin(x) * sin(1.2*x)) + 1.2) *\n        0.08 *\n        vec2(rand(vec2(300.*time)));\n}\n","name":"","description":"","type":"sound"}]}}