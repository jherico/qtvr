{"Shader":{"ver":"0.1","info":{"id":"XlfGzH","date":"1418333984","viewed":964,"name":"The evolution of motion","username":"xTr1m","description":"This is a prototype for the PC 8k \"The evolution of motion\" by Alcatraz, ranked 3rd at the Revision 2015 PC 8k compo.<br\/>Link: http:\/\/www.pouet.net\/prod.php?which=65381","likes":8,"published":3,"flags":0,"tags":["prototype"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"float pi = 3.141592;\n\nfloat hash(float n) \n{ \n    return fract(sin(n)*43758.5453123); \n}\n\nfloat noise2(in vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0;\n    return mix(mix(hash(n+0.0), hash(n+1.0),f.x), mix(hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nfloat noise3(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(\n        mix(mix(hash(n+  0.0), hash(n+  1.0),f.x), mix(hash(n+157.0), hash(n+158.0),f.x),f.y),\n        mix(mix(hash(n+113.0), hash(n+114.0),f.x), mix(hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nvec2 r(vec2 v,float y)\n{\n    return cos(y)*v+sin(y)*vec2(-v.y,v.x);\n}\n\nvec3 smin(vec3 a, vec3 b)\n{\n    if (a.x < b.x)\n        return a;\n    \n    return b;\n}\n\nvec3 smax(vec3 a, vec3 b)\n{\n\tif (a.x > b.x)\n        return a;\n    \n    return b;\n}\n\nvec3 sinv(vec3 a)\n{\n\treturn vec3(-a.x, a.y, a.z);    \n}\n\nfloat sdSphere(vec3 p, float s)\n{\n  return length(p)-s;\n}\n\nfloat sdBox(vec3 p, vec3 b, float r)\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0)) - r;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat smoothmax( float a, float b, float k )\n{\n    return -log(exp(k*a) + exp(k*b))\/-k;\n}\n\nfloat smoothmin( float a, float b, float k )\n{\n    return -log(exp(-k*a) + exp(-k*b))\/k;\n}\n\nfloat cylsphere(vec3 p)\n{\n    float d = max(sdCylinder(p, vec3(0.0, 0.0, 0.04)), sdBox(p, vec3(0.3), 0.0));\n    d = smoothmin(d, sdSphere(p+vec3(0.0, 0.35, 0.0), 0.08), 48.0);\n    d = smoothmin(d, sdSphere(p-vec3(0.0, 0.35, 0.0), 0.08), 48.0);\n    return d;\n}\n\nvec3 greeble0(vec3 p, float phase)\n{\n    float t = mod(phase + iGlobalTime * 0.5, 1.0);\n    float rotation = sign(phase-0.5) * min(1.0, max(0.0, -0.2 + 5.0 * t)) * pi \/ 2.0;\n    float translation = min(1.0, max(0.0, 2.0 * sin(min(t - 0.02, 0.5) * 10.0)));\n    \n    float d = sdBox(p, vec3(0.4), 0.075);\n    float e = sdSphere(p - vec3(0.0, 0.6, 0.0), 0.2);\n    d = smoothmax(d, -e, 32.0);\n    p.y -= translation * 0.3 - 0.1;\n    p.xz = r(p.xz, rotation);\n    e = max(sdCylinder(p, vec3(0.0, 0.0, 0.1)), sdBox(p, vec3(0.8), 0.0));\n    vec3 q = p;    \n    q.y -= 0.8;\n    q.yz = r(q.yz,pi\/2.0);\n    e = smoothmin(e, cylsphere(q), 16.0);\n    q.xy = r(q.xy,pi\/2.0);\n    e = smoothmin(e, cylsphere(q), 16.0);\n    return smin(vec3(d, 0.0, 0.0), vec3(e, 1.0, 0.0));\n}\n\nvec3 greeble1(vec3 p, float phase)\n{\n    float d = sdBox(p, vec3(0.425), 0.05);\n    d = smoothmax(d, -sdBox(p + vec3(0.0, 0.0, 0.3), vec3(0.3, 1.0, 0.01), 0.0), 32.0);\n    d = smoothmax(d, -sdBox(p - vec3(0.0, 0.0, 0.3), vec3(0.3, 1.0, 0.01), 0.0), 32.0);\n    d = smoothmax(d, -sdBox(p + vec3(0.3, 0.0, 0.0), vec3(0.01, 1.0, 0.3), 0.0), 32.0);\n    d = smoothmax(d, -sdBox(p - vec3(0.3, 0.0, 0.0), vec3(0.01, 1.0, 0.3), 0.0), 32.0);\n    \n    float t = mod(phase + sign(phase-0.5) * iGlobalTime * 0.5, 1.0);\n    float x = max(-1.0, min(1.0, 4.0*cos(t*2.0*pi)));\n    float y = max(-1.0, min(1.0, 4.0*sin(t*2.0*pi)));\n    x *= 0.3;\n    y *= 0.3;\n    vec3 q = p + vec3(x, 0, y);\n    float e = sdBox(q, vec3(0.03, 0.75, 0.03), 0.0);\n    q.y -= 0.75;\n    e = smoothmin(e, sdSphere(q, 0.1), 32.0);\n    return smin(vec3(d, 2.0, 0.0), vec3(e, 3.0, 0.0));\n}\n\nvec3 greeble2(vec3 p, float phase)\n{\n    float d = sdBox(p, vec3(0.425), 0.05);\n    d = smoothmax(d, -sdBox(p + vec3(0.2, 0.0, 0.0), vec3(0.01, 1.0, 0.3), 0.0), 32.0);\n    d = smoothmax(d, -sdBox(p - vec3(0.2, 0.0, 0.0), vec3(0.01, 1.0, 0.3), 0.0), 32.0);\n    \n    float x = pow(mod(phase + sign(phase-0.5) * iGlobalTime * 0.5, 1.0), 2.0) * 2.0 * pi;\n    float t = max(-0.5, min(0.5, sin(x)));\n    p.yz = r(p.yz, t);\n    vec3 q = p + vec3(0.0, 0.25, 0.0);\n    float e =  sdBox(q - vec3(0.2, 0.0, 0.0), vec3(0.02, 1.0, 0.02), 0.0);\n    e = min(e, sdBox(q + vec3(0.2, 0.0, 0.0), vec3(0.02, 1.0, 0.02), 0.0));\n    e = min(e, sdBox(q - vec3(0.0, 1.0, 0.0), vec3(0.175, 0.02, 0.02), 0.0));\n    e = smoothmin(e, sdSphere(q - vec3(0.2, 1.01, 0.0), 0.03), 32.0);\n    e = smoothmin(e, sdSphere(q - vec3(-0.2, 1.01, 0.0), 0.03), 32.0);\n    q.y -= 1.0;\n    q.xy = r(q.xy, pi \/ 2.0);\n    e = smoothmin(e, max(sdCylinder(q, vec3(0.0, 0.0, 0.03)), sdBox(q, vec3(0.1), 0.0)), 32.0);\n    return smin(vec3(d, 4.0, 0.0), vec3(e, 5.0, 0.0));\n}\n\nvec3 greeble3(vec3 p, float phase)\n{\n    float d = sdBox(p, vec3(0.4), 0.08);\n    ivec2 i = ivec2(p.xz \/ 0.15 + floor(phase * 815.0));\n    float phase2 = noise2(vec2(i));\n    vec3 q = p;\n    q.xz = mod(q.xz, 0.15);\n    q.xz -= 0.075;\n    q.y -= 0.5;\n    float hole = max(sdBox(q, vec3(0.05, 1.0, 0.05), 0.0), sdBox(p, vec3(0.3, 2.0, 0.3), 0.0));\n    d = smoothmax(d, -hole, 96.0);\n    \n    float t = phase2 * 2.0 * pi + iGlobalTime * 8.0;\n    q.y -= 0.1 * max(-0.5, min(0.5, sin(t)));\n    q.y += 0.5;\n    float e = sdBox(q, vec3(0.025, 0.6, 0.025), 0.0);\n    e = max(e, sdBox(p, vec3(0.3, 2.0, 0.3), 0.0));\n    return smin(vec3(d, 6.0, 0.0), vec3(e, 7.0, 0.0));\n}\n\nvec3 greeble4(vec3 p, float phase)\n{\n    float angle = floor(phase * 4.0) * 0.5 * pi;\n    p.xz = r(p.xz, angle);\n    float d = sdBox(p, vec3(0.4), 0.08);\n    d = smoothmax(d, -sdBox(p - vec3(0.2, 0.0, 0.1), vec3(0.1, 1.0, 0.2), 0.0), 32.0);\n    d = smoothmax(d, -sdBox(p + vec3(0.2, 0.0, -0.1), vec3(0.1, 1.0, 0.2), 0.0), 32.0);\n    vec3 q = p - vec3(0.0, 0.8, -0.3);\n    float e = sdBox(q + vec3(0.0, 0.2, 0.0), vec3(0.0, 0.15, 0.0), 0.1) \/ 0.6;\n    q \/= 0.6;\n    q.yz = r(q.yz,pi\/2.0);\n    \n    float t = phase + 0.2 * iGlobalTime;\n    angle = 0.45 * max(-1.0, min(1.0, 4.0*cos(t*2.0*pi)));\n    float y = 0.5 + 0.5 * max(-1.0, min(1.0, 4.0*sin(t*2.0*pi)));\n    y = pow(y, 1.25 + 0.75 * cos(t*2.0*pi));\n    q.xy = r(q.xy, angle);\n    q.y += 0.4;\n    \n    e = smoothmin(e, cylsphere(q), 16.0);\n    q += vec3(0.0, 0.35, 0.05);\n    e = min(e, sdBox(q, vec3(0.0, 0.0, -0.1), 0.2)) * 0.6;\n    float f = sdBox(q + vec3(0.0, 0.0, 1.2 - y), vec3(0.1), 0.0) * 0.6;\n    return smin(smin(vec3(d, 8.0, 0.0), vec3(e, 9.0, 0.0)), vec3(f, 10.0, 0.0));\n}\n\nvec3 greeble(vec3 p, float findex, float phase)\n{\n    const int indexCount = 6;\n    int index = int(findex * float(indexCount));\n    p.y -= phase * 0.2 - 0.2;\n    if (index == 0)\n        return greeble0(p, phase);\n    else if (index == 1)\n        return greeble1(p, phase);\n    else if (index == 2)\n        return greeble2(p, phase);\n    else if (index == 3)\n        return greeble3(p, phase);\n    else if (index == 4)\n        return greeble4(p, phase);\n        \n    return vec3(sdBox(p, vec3(0.4), 0.025), 10.0, 0.0);\n}\n\nvec3 f( vec3 p )\n{\n    ivec3 h = ivec3(p+1337.0);\n    float hash = noise2(vec2(h.xz));\n    h = ivec3(p+42.0);\n    float phase = noise2(vec2(h.xz));\n    vec3 q = p;\n    q.xz = mod(q.xz, 1.0);\n    q -= 0.5;\n\treturn greeble(q, hash, phase);\n}\n\nvec3 colorize(float index)\n{\n    if (index == 0.0)\n        return vec3(0.4, 0.6, 0.2);\n    \n    if (index == 1.0)\n        return vec3(0.6, 0.3, 0.2);\n    \n    if (index == 2.0)\n        return vec3(1.0, 0.8, 0.5);\n    \n    if (index == 3.0)\n        return vec3(0.9, 0.2, 0.6);\n    \n    if (index == 4.0)\n        return vec3(0.3, 0.6, 0.7);\n    \n    if (index == 5.0)\n        return vec3(1.0, 1.0, 0.3);\n    \n    if (index == 6.0)\n        return vec3(0.7, 0.5, 0.7);\n    \n    if (index == 7.0)\n        return vec3(0.4, 0.3, 0.4);\n    \n    if (index == 8.0)\n        return vec3(0.8, 0.3, 0.2);\n    \n    if (index == 9.0)\n        return vec3(0.5, 0.8, 0.2);\n    \n\treturn vec3(index \/ 10.0);\n}\n\nfloat ao(vec3 v, vec3 n) \n{\n    const int ao_iterations = 10;\n    const float ao_step = 0.2;\n    const float ao_scale = 0.75;\n    \n\tfloat sum = 0.0;\n\tfloat att = 1.0;\n\tfloat len = ao_step;\n    \n\tfor (int i = 0; i < ao_iterations; i++)\n    {\n\t\tsum += (len - f(v + n * len).x) * att;\t\t\n\t\tlen += ao_step;\t\t\n\t\tatt *= 0.5;\n\t}\n\t\n\treturn 1.0 - max(sum * ao_scale, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.xyz = vec3(0);\n    \n    vec3 q = vec3((fragCoord.xy \/ iResolution.xy - 0.5), 1.0);     \n    float vignette = 1.0 - length(q.xy);\n    q.x *= iResolution.x \/ iResolution.y;\n    q.y -= 0.5;\n    vec3 p = vec3(0, 0.0, -10.0);\n    q = normalize(q);\n    q.xz = r(q.xz, iGlobalTime * 0.1);\n    p.y += 2.5;\n\tp.z -= iGlobalTime*0.5;\n    \n    float t=0.0;\n    vec3 d = vec3(0);\n    float steps = 0.0;\n    const float maxSteps = 96.0;\n    for (float tt = 0.0; tt < maxSteps; ++tt)\n    {\n        d = f(p+q*t);\n        t += d.x*0.45;\n        if(!(t<=50.0)||d.x<=0.0001)\n        {\n            break;\n        }\n        steps = tt;\n    }\n\n    vec3 glow = vec3(1.1, 1.1, 1.0);\n    vec3 fog = vec3(0.7, 0.75, 0.8);\n    vec3 color = fog;\n\n    if (t <= 50.0)\n    {\n        vec3 hit = p+q*t;\n\n        vec2 e = vec2(0.001, 0.00);\n        vec3 normal= vec3( f(hit + e.xyy).x - f(hit - e.xyy).x, f(hit + e.yxy).x - f(hit - e.yxy).x, f(hit + e.yyx).x - f(hit - e.yyx).x) \/ (2.0 * e.x);\n\n        normal= normalize(normal);\n    \n        float fao = ao(hit, normal);\n        vec3 ldir = normalize(vec3(1.0, 1.0, -1.0));\n        vec3 light = (0.5 * fog.rgb + vec3(0.5 * fao * abs(dot(normal, ldir)))) * colorize(d.y); \/\/ diffuse\n        light += (1.0 - t \/ 50.0) * vec3(fao * pow(1.0 - abs(dot(normal, q)), 4.0)); \/\/ rim\n        q = reflect(q, normal);\n        light += fao * vec3(pow(abs(dot(q, ldir)), 16.0)); \/\/ specular\n        color = min(vec3(1), light);\n        color *= fao;\n    }\n    \n    float luma = dot(color.rgb, vec3(0.3, 0.5, 0.2));\n    color = mix(color, 1.0 * luma * vec3(1.0, 0.9, 0.5), 2.0 * max(0.0, luma-0.5)); \/\/ yellow highlights\n    color = mix(color, 1.0 * luma * vec3(0.2, 0.5, 1.0), 2.0 * max(0.0, 0.5-luma)); \/\/ blue shadows\n    \/\/color = mix(color, glow, 0.8 * pow(steps \/ 90.0, 8.0)); \/\/ glow\n    color = mix(color, fog, pow(min(1.0, t \/ 50.0), 0.5)); \/\/ fog\n    color = pow(color, vec3(0.8)); \/\/ gamma\n    color = smoothstep(0.0, 1.0, color); \/\/ contrast\n    color *= pow(vignette + 0.3, 0.5); \/\/ vignette\n    fragColor = vec4(color, 1.0);\n}","name":"","description":"","type":"image"}]}}