{"Shader":{"ver":"0.1","info":{"id":"4d33DN","date":"1449580203","viewed":133,"name":"Black Sea","username":"Kchplr","description":"A test refactoring cpu-bound javascript code to a fragment shader.<br\/>The original ( http:\/\/www.kchapelier.com\/blacksea\/ ) was using a WebWorker to produce a heightmap of fixed dimension.","likes":5,"published":3,"flags":0,"tags":["procedural","2d","noise","heightmap"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/\n\/\/ Description : Array and textureless GLSL 2D and 3D simplex noise function.\n\/\/      Author : Ian McEwan, Ashima Arts.\n\/\/  Maintainer : ijm\n\/\/     Lastmod : 20110822 (ijm)\n\/\/     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n\/\/               Distributed under the MIT License. See LICENSE file.\n\/\/               https:\/\/github.com\/ashima\/webgl-noise\n\/\/ \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 \/ 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 \/ 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 \/ 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0\/6.0, 1.0\/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n\/\/ First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n\/\/ Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  \/\/   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  \/\/   x1 = x0 - i1  + 1.0 * C.xxx;\n  \/\/   x2 = x0 - i2  + 2.0 * C.xxx;\n  \/\/   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; \/\/ 2.0*C.x = 1\/3 = C.y\n  vec3 x3 = x0 - D.yyy;      \/\/ -1.0+3.0*C.x = -0.5 = -D.y\n\n\/\/ Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n\/\/ Gradients: 7x7 points over a square, mapped onto an octahedron.\n\/\/ The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; \/\/ 1.0\/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  \/\/  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    \/\/ mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  \/\/vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  \/\/vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n\/\/Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n\/\/ Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  \/\/ (3.0-sqrt(3.0))\/6.0\n                      0.366025403784439,  \/\/ 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  \/\/ -1.0 + 2.0 * C.x\n                      0.024390243902439); \/\/ 1.0 \/ 41.0\n\/\/ First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n\/\/ Other corners\n  vec2 i1;\n  \/\/i1.x = step( x0.y, x0.x ); \/\/ x0.x > x0.y ? 1.0 : 0.0\n  \/\/i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  \/\/ x0 = x0 - 0.0 + 0.0 * C.xx ;\n  \/\/ x1 = x0 - i1 + 1.0 * C.xx ;\n  \/\/ x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n\/\/ Permutations\n  i = mod289(i); \/\/ Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n\/\/ Gradients: 41 points uniformly over a line, mapped onto a diamond.\n\/\/ The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n\/\/ Normalise gradients implicitly by scaling m\n\/\/ Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n\/\/ Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n\/\/ Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); \/\/ Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); \/\/ Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); \/\/ Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); \/\/ Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 \/ 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 \/ 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 \/ 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 \/ 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n\/\/ Classic Perlin noise, periodic variant\nfloat pnoise(vec3 P, vec3 rep)\n{\n  vec3 Pi0 = mod(floor(P), rep); \/\/ Integer part, modulo period\n  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); \/\/ Integer part + 1, mod period\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); \/\/ Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); \/\/ Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 \/ 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 \/ 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 \/ 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 \/ 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n\nvec2 fade(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n\/\/ Classic Perlin noise\nfloat cnoise(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289(Pi); \/\/ To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 \/ 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;  \n  g01 *= norm.y;  \n  g10 *= norm.z;  \n  g11 *= norm.w;  \n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n\/\/ Classic Perlin noise, periodic variant\nfloat pnoise(vec2 P, vec2 rep)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, rep.xyxy); \/\/ To create noise with explicit period\n  Pi = mod289(Pi);        \/\/ To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 \/ 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;  \n  g01 *= norm.y;  \n  g10 *= norm.z;  \n  g11 *= norm.w;  \n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n\n\n\n\n\/\/\n\/\/ Black Sea code starts here\n\/\/ The code in the comments is the original cpu-bound javascript code for each map\n\/\/\n\/\/ The original can be found here\n\/\/ http:\/\/www.kchapelier.com\/blacksea\/\n\/\/\n\n\nvec2 propensityDistortionMap(vec2 p, float distortionLevel) {\n    \/*\n    mapX.map(function (value, x, y) {\n        var dist = noise.perlin2(400 + x \/ 50, 400 + y \/ 50) \/ 40\n        + noise.simplex2(400 + x \/ 25, 400 + y \/ 25) \/ 60\n        + noise.simplex2(400 + x \/ 10, 400 + y \/ 10) \/ 130;\n        return dist * distortionLevel;\n    });\n\n    mapY.map(function (value, x, y) {\n        var dist = noise.perlin2(4000 + x \/ 50, 4000 + y \/ 50) \/ 40\n        + noise.simplex2(4000 + x \/ 25, 4000 + y \/ 25) \/ 60\n        + noise.simplex2(4000 + x \/ 10, 4000 + y \/ 10) \/ 130;\n        return dist * distortionLevel;\n    });\n\n    return {\n        x: mapX,\n        y: mapY\n    };\n    *\/\n    \n    vec2 dist = vec2(\n        cnoise(vec2(400. + p.x \/ 50., 400. + p.y \/ 50.)) \/ 40. +\n        snoise(vec2(400. + p.x \/ 25., 400. + p.y \/ 25.)) \/ 60. +\n        snoise(vec2(400. + p.x \/ 10., 400. + p.y \/ 10.)) \/ 130.,\n        cnoise(vec2(4000. + p.x \/ 50., 4000. + p.y \/ 50.)) \/ 40. +\n        snoise(vec2(4000. + p.x \/ 25., 4000. + p.y \/ 25.)) \/ 60. +\n        snoise(vec2(4000. + p.x \/ 10., 4000. + p.y \/ 10.)) \/ 130.\n    );\n    \n    return dist * distortionLevel;\n}\n\nfloat heightPropensityMap(vec2 p, vec2 propensityDistortion) {\n    \/*\n        \/\/ distortion\n        var dx = distortions.x.get(x, y),\n            dy = distortions.y.get(x, y);\n\n        var base = Math.abs(Math.min(1, Math.max(-1, Math.min(\n            noise.perlin3(x \/ 400 + dx, y \/ 400 + dy, 10),\n            noise.perlin3(x \/ 250, y \/ 250, 15)\n        ))));\n\n        \/\/ soften with large scale perlin cloud\n\n        var v = Math.min(\n            noise.perlin3(x \/ 300 + dx * 1.3, y \/ 300 + dy, 50),\n            noise.perlin3(x \/ 300 + dx, y \/ 300 + dy * 1.3, 50.30)\n        );\n\n        var increment = Math.pow(1 - Math.sqrt(Math.abs(v)), 3);\n\n        return Math.max(0, Math.min(1, (base * increment) * 2));\n\t*\/\n    \n    float dx = propensityDistortion.x;\n    float dy = propensityDistortion.y;\n    \n    float base = abs(min(\n        cnoise(vec3(p.x \/ 400. + dx, p.y \/ 400. + dy, 10.)),\n        cnoise(vec3(p.x \/ 250., p.y \/ 250., 15.))\n    ));\n    \n    float v = abs(min(\n        cnoise(vec3(p.x \/ 300. + dx * 1.3, p.y \/ 300. + dy, 50.)),\n        cnoise(vec3(p.x \/ 300. + dx, p.y \/ 300. + dy * 1.3, 50.30))\n    ));\n    \n    float increment = pow(1. - sqrt(v), 3.);\n    \n    return clamp(base * increment * 2., 0., 1.);\n}\n\nfloat altHeightPropensityMap(vec2 p, vec2 propensityDistortion) {\n    \/*\n        \/\/ distortion\n        var dx = distortions.x.get(x, y),\n            dy = distortions.y.get(x, y);\n\n        var base = Math.abs(Math.pow(0.2, Math.max(-1, Math.min(\n            noise.perlin3(x \/ 200 + dx, y \/ 200 + dy, 50),\n            noise.perlin3(x \/ 450, y \/ 450, 55)\n        ))));\n\n        base += Math.abs(Math.min(1, Math.max(-1, Math.min(\n            noise.perlin3(x \/ 400 + dx, y \/ 400 + dy, 10),\n            noise.perlin3(x \/ 250, y \/ 250, 15)\n        ))));\n\n        var v = Math.min(\n            noise.perlin3(x \/ 300 + dx * 1.3, y \/ 300 + dy, 50),\n            noise.perlin3(x \/ 300 + dx, y \/ 300 + dy * 1.3, 50.30)\n        );\n\n        var increment = Math.pow(1 - Math.sqrt(Math.abs(v)), 3);\n\n        return Math.max(0, Math.min(1, (base * increment) * 2));\n\t*\/\n    \n    float dx = propensityDistortion.x;\n    float dy = propensityDistortion.y;\n    \n    float base = abs(pow(0.2, max(-1., min(\n        cnoise(vec3(p.x \/ 200. + dx, p.y \/ 200. + dy, 50.)),\n        cnoise(vec3(p.x \/ 450., p.y \/ 450., 55.))\n    ))));\n    \n    base += abs(min(\n        cnoise(vec3(p.x \/ 400. + dx, p.y \/ 400. + dy, 10.)),\n        cnoise(vec3(p.x \/ 250., p.y \/ 250., 15.))\n    ));\n    \n    float v = abs(min(\n        cnoise(vec3(p.x \/ 300. + dx * 1.3, p.y \/ 300. + dy, 50.)),\n        cnoise(vec3(p.x \/ 300. + dx, p.y \/ 300. + dy * 1.3, 50.30))\n    ));\n    \n    float increment = pow(1. - sqrt(v), 3.);\n    \n    return clamp(base * increment * 2., 0., 1.);\n}\n\nfloat lerp(float a, float b, float w) {\n    return a + w * (b-a);\n}\n\nfloat heightMap(vec2 p, float propensity, float abyss) {\n    \/*\n    \tvalue = Math.abs(noise.perlin3(x \/ 1200, y \/ 1200, 300 + propensity * 0.4 + abyss * 0.2)) * (32 + propensity * 32) +\n        noise.simplex2(x \/ 600, y \/ 600) * (16 + propensity * 16) +\n        noise.perlin2(x \/ 300, y \/ 300) * (8 + propensity * 8) +\n        noise.perlin2(x \/ 150, y \/ 150) * (4 + propensity * 4) +\n        noise.perlin2(x \/ 75, y \/ 75) * (2 + propensity * 2) +\n        noise.simplex2(x \/ 75, y \/ 75) +\n        noise.perlin2(x \/ 35, y \/ 35) +\n        noise.perlin2(x \/ 17, y \/ 17) * (1 + propensity * propensity * propensity) +\n        noise.perlin2(x \/ 8, y \/ 8) * 0.5 +\n        noise.perlin2(x \/ 4, y \/ 4) * 0.2 + propensity;\n\n        value = Math.max(0, Math.min(1, (value + 31) \/ 100));\n\n        value = Mathp.wshaper(value - (abyss * Math.pow(0.5 - value \/ 2, 2)), 0, 1, [Math.max(0, value - abyss * 4), 0.5, 1]);\n        \n\t*\/\n    \n    float value = abs(cnoise(vec3(p.x \/ 1200., p.y \/ 1200., 300. + propensity * 0.4 + abyss * 0.2))) * (32. + propensity * 32.);\n    value += snoise(vec2(p.x \/ 600., p.y \/ 600.)) * (16. + propensity * 16.);\n    value += cnoise(vec2(p.x \/ 300., p.y \/ 300.)) * (8. + propensity * 8.);\n    value += cnoise(vec2(p.x \/ 150., p.y \/ 150.)) * (4. + propensity * 4.);\n    value += cnoise(vec2(p.x \/ 75., p.y \/ 75.)) * (2. + propensity * 2.);\n    value += snoise(vec2(p.x \/ 75., p.y \/ 75.));\n    value += cnoise(vec2(p.x \/ 35., p.y \/ 35.));\n    value += cnoise(vec2(p.x \/ 17., p.y \/ 17.)) * (1. + pow(propensity, 3.));\n    value += cnoise(vec2(p.x \/ 8., p.y \/ 8.)) * 0.5;\n    value += cnoise(vec2(p.x \/ 4., p.y \/ 4.)) * 0.2;\n    value += propensity;\n    \n    value = clamp((value + 31.) \/ 100., 0., 1.);\n    \n    value = value - (abyss * pow(0.5 - value * 0.5, 2.));\n    \n    \/\/ apply a lerp for values between 0. and 0.5\n    if (value > 0. && value <= 0.5) {\n        float minv = max(0., value - abyss * 4.);\n        value = lerp(minv, 0.5, value * 2.);\n    }\n    \n    return value;\n}\n\nfloat blackSea(float v, float seaLevel) {\n    \/*\n    \tvalue = Math.max(0, Math.min(255, continentMap.get(x, y) ? (value - 30) * 1.5 : value \/ 1.75));\n\n        if (highlightMap && !highlightMap.get(x, y)) {\n        \tvalue = value \/ 1.75;\n\t\t}\n\n\t\treturn value;\n\t*\/\n    \n    if (v >= seaLevel) {\n        return (v - 30. \/ 255.) * 1.5;\n    } else {\n        return v \/ 1.75;\n    }\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ could be shader attributes\n    float distortion = 1.,\n          seaLevel = 0.45,\n          movementX = iGlobalTime * 13.,\n          movementY = iGlobalTime * 50.,\n          scale = 650. \/ min(iResolution.x, iResolution.y);\n    \n    vec2 p = fragCoord * scale + vec2(movementX, movementY);\n    \n    vec2 propensityDistortion = propensityDistortionMap(p, distortion);\n    \n    float heightPropensity = heightPropensityMap(p, propensityDistortion),\n          altHeightPropensity = altHeightPropensityMap(p, propensityDistortion),\n          height = heightMap(p, heightPropensity, altHeightPropensity);\n    \n    height = blackSea(height, seaLevel);\n    \n\tfragColor = vec4(height, height, height,1.0);\n}","name":"","description":"","type":"image"}]}}