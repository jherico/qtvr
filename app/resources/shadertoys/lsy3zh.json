{"Shader":{"ver":"0.1","info":{"id":"lsy3zh","date":"1453239407","viewed":511,"name":"Coupled Turing Pattern Flow","username":"Flexi","description":"remake of http:\/\/www.cake23.de\/reaction-diffusion-fish-soup.html - drag with the mouse","likes":24,"published":3,"flags":32,"tags":["interactive","warp","feedback","reactiondiffusion"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":260,"src":"\/presets\/previz\/buffer03.png","ctype":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"vec2 lower_left(vec2 uv)\n{\n    return fract(uv * 0.5);\n}\n\nvec2 lower_right(vec2 uv)\n{\n    return fract((uv - vec2(1, 0.)) * 0.5);\n}\n\nvec2 upper_left(vec2 uv)\n{\n    return fract((uv - vec2(0., 1)) * 0.5);\n}\n\nvec2 upper_right(vec2 uv)\n{\n    return fract((uv - 1.) * 0.5);\n}\n\nvec4 BlurA(vec2 uv, int level)\n{\n    if(level <= 0)\n    {\n        return texture2D(iChannel0, fract(uv));\n    }\n\n    uv = upper_left(uv);\n    for(int depth = 1; depth < 8; depth++)\n    {\n        if(depth >= level)\n        {\n            break;\n        }\n        uv = lower_right(uv);\n    }\n\n    return texture2D(iChannel3, uv);\n}\n\nvec2 GradientA(vec2 uv, vec2 d, vec4 selector, int level){\n    vec4 dX = 0.5*BlurA(uv + vec2(1.,0.)*d, level) - 0.5*BlurA(uv - vec2(1.,0.)*d, level);\n    vec4 dY = 0.5*BlurA(uv + vec2(0.,1.)*d, level) - 0.5*BlurA(uv - vec2(0.,1.)*d, level);\n    return vec2( dot(dX, selector), dot(dY, selector) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelSize = 1. \/  iResolution.xy;\n    vec2 uv = fragCoord.xy * pixelSize;\n    fragColor = texture2D(iChannel0, uv);\n\n    vec2 uv_bg = uv\t+ (\t\n        GradientA(uv, pixelSize * 1.5, vec4(0.5, 1, 0, 0), 0)\n        + GradientA(uv, pixelSize * 3., vec4(1, 1, 0, 0), 1)\n    ) * pixelSize * 384.;\n\n    fragColor = mix(vec4(0), vec4(0.25,0.33,0.66,0), BlurA(uv_bg, 2).b*1.6);\n\n    fragColor = mix(fragColor, vec4(0.5,0.4,0.5,0), BlurA(uv, 0).r * (1.- BlurA(uv, 0).g));\n\n    fragColor = mix(fragColor, \n                    mix(vec4(2,2,0,0), vec4(1.,0,0.,0), pow(1.-BlurA(uv, 0).r,2.)), \n                    BlurA(uv + GradientA(uv, pixelSize * 2., vec4(0, 1, 0, 0), 0)*pixelSize*4., 0).g);\n    \n    \/\/fragColor = BlurA(uv, 0); \/\/ simple bypass\n    \n    \/\/fragColor = texture2D(iChannel3, uv); \/\/ raw Gaussian pyramid\n\n}","name":"","description":"","type":"image"},{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":260,"src":"\/presets\/previz\/buffer03.png","ctype":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define pi 3.141592653589793238462643383279\n#define pi_inv 0.318309886183790671537767526745\n#define pi2_inv 0.159154943091895335768883763372\n\nvec2 lower_left(vec2 uv)\n{\n    return fract(uv * 0.5);\n}\n\nvec2 lower_right(vec2 uv)\n{\n    return fract((uv - vec2(1, 0.)) * 0.5);\n}\n\nvec2 upper_left(vec2 uv)\n{\n    return fract((uv - vec2(0., 1)) * 0.5);\n}\n\nvec2 upper_right(vec2 uv)\n{\n    return fract((uv - 1.) * 0.5);\n}\n\nvec2 mouseDelta(){\n    vec2 pixelSize = 1. \/ iResolution.xy;\n    float eighth = 1.\/8.;\n    vec4 oldMouse = texture2D(iChannel3, vec2(7.5 * eighth, 2.5 * eighth));\n    vec4 nowMouse = vec4(iMouse.xy \/ iResolution.xy, iMouse.zw \/ iResolution.xy);\n    if(oldMouse.z > pixelSize.x && oldMouse.w > pixelSize.y && \n       nowMouse.z > pixelSize.x && nowMouse.w > pixelSize.y)\n    {\n        return nowMouse.xy - oldMouse.xy;\n    }\n    return vec2(0.);\n}\n\nvec4 BlurA(vec2 uv, int level)\n{\n    if(level <= 0)\n    {\n        return texture2D(iChannel0, fract(uv));\n    }\n\n    uv = upper_left(uv);\n    for(int depth = 1; depth < 8; depth++)\n    {\n        if(depth >= level)\n        {\n            break;\n        }\n        uv = lower_right(uv);\n    }\n\n    return texture2D(iChannel3, uv);\n}\n\t\nvec2 GradientA(vec2 uv, vec2 d, vec4 selector, int level){\n\tvec4 dX = 0.5*BlurA(uv + vec2(1.,0.)*d, level) - 0.5*BlurA(uv - vec2(1.,0.)*d, level);\n\tvec4 dY = 0.5*BlurA(uv + vec2(0.,1.)*d, level) - 0.5*BlurA(uv - vec2(0.,1.)*d, level);\n\treturn vec2( dot(dX, selector), dot(dY, selector) );\n}\n\nvec2 rot90(vec2 vector){\n\treturn vector.yx*vec2(1,-1);\n}\n\nvec2 complex_mul(vec2 factorA, vec2 factorB){\n    return vec2( factorA.x*factorB.x - factorA.y*factorB.y, factorA.x*factorB.y + factorA.y*factorB.x);\n}\n\nvec2 spiralzoom(vec2 domain, vec2 center, float n, float spiral_factor, float zoom_factor, vec2 pos){\n    vec2 uv = domain - center;\n    float d = length(uv);\n    return vec2( atan(uv.y, uv.x)*n*pi2_inv + d*spiral_factor, -log(d)*zoom_factor) + pos;\n}\n\nvec2 complex_div(vec2 numerator, vec2 denominator){\n    return vec2( numerator.x*denominator.x + numerator.y*denominator.y,\n                numerator.y*denominator.x - numerator.x*denominator.y)\/\n        vec2(denominator.x*denominator.x + denominator.y*denominator.y);\n}\n\nfloat circle(vec2 uv, vec2 aspect, float scale){\n    return clamp( 1. - length((uv-0.5)*aspect*scale), 0., 1.);\n}\n\nfloat sigmoid(float x) {\n    return 2.\/(1. + exp2(-x)) - 1.;\n}\n\nfloat smoothcircle(vec2 uv, vec2 aspect, float radius, float ramp){\n    return 0.5 - sigmoid( ( length( (uv - 0.5) * aspect) - radius) * ramp) * 0.5;\n}\n\nfloat conetip(vec2 uv, vec2 pos, float size, float min)\n{\n    vec2 aspect = vec2(1.,iResolution.y\/iResolution.x);\n    return max( min, 1. - length((uv - pos) * aspect \/ size) );\n}\n\nfloat warpFilter(vec2 uv, vec2 pos, float size, float ramp)\n{\n    return 0.5 + sigmoid( conetip(uv, pos, size, -16.) * ramp) * 0.5;\n}\n\nvec2 vortex_warp(vec2 uv, vec2 pos, float size, float ramp, vec2 rot)\n{\n    vec2 aspect = vec2(1.,iResolution.y\/iResolution.x);\n\n    vec2 pos_correct = 0.5 + (pos - 0.5);\n    vec2 rot_uv = pos_correct + complex_mul((uv - pos_correct)*aspect, rot)\/aspect;\n    float filter = warpFilter(uv, pos_correct, size, ramp);\n    return mix(uv, rot_uv, filter);\n}\n\nvec2 vortex_pair_warp(vec2 uv, vec2 pos, vec2 vel)\n{\n    vec2 aspect = vec2(1.,iResolution.y\/iResolution.x);\n    float ramp = 4.;\n\n    float d = 0.1;\n\n    float l = length(vel);\n    vec2 p1 = pos;\n    vec2 p2 = pos;\n\n    if(l > 0.){\n        vec2 normal = normalize(vel.yx * vec2(-1., 1.))\/aspect;\n        p1 = pos - normal * d \/ 2.;\n        p2 = pos + normal * d \/ 2.;\n    }\n\n    float w = l \/ d * 2.;\n\n    \/\/ two overlapping rotations that would annihilate when they were not displaced.\n    vec2 circle1 = vortex_warp(uv, p1, d, ramp, vec2(cos(w),sin(w)));\n    vec2 circle2 = vortex_warp(uv, p2, d, ramp, vec2(cos(-w),sin(-w)));\n    return (circle1 + circle2) \/ 2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec4 noise = texture2D(iChannel2, fragCoord.xy \/ iChannelResolution[2].xy + fract(vec2(42,56)*iGlobalTime));\n\n    if(iFrame<10)\n    {\n        fragColor = noise;\n        return;\n    }\n\n    vec2 mouseV = mouseDelta();\n    vec2 aspect = vec2(1.,iResolution.y\/iResolution.x);\n    vec2 pixelSize = 1. \/ iResolution.xy;\n\n    uv = vortex_pair_warp(uv, iMouse.xy*pixelSize, mouseV*aspect*1.4);\n\n    vec2 uvr = uv;\n\tfragColor.r = BlurA(uvr + GradientA(uv, pixelSize*8., vec4(-8.,0.,8.,0.), 2)*pixelSize + rot90(GradientA(uv, pixelSize*4., vec4(-0,0.,16.,0.), 1))*pixelSize, 0).r;\n\tfragColor.r += (BlurA(uv, 2).r - BlurA(uvr, 4).r)*24.\/256. + 2.5\/256. + noise.x*0.5\/256.;\n\n\tfragColor.g = BlurA(uvr + GradientA(uv, pixelSize*4., vec4(0.,-2.,-48.*BlurA(uv, 2).b,0.), 1)*pixelSize, 0).g ;\n\tfragColor.g += (BlurA(uv, 1).g - BlurA(uvr, 2).g)*32.\/256. + 5.\/256.*(BlurA(uv, 2).b - 0.5) + noise.y*0.\/256.;\n\n\tfragColor.b = BlurA(uvr + GradientA(uv, pixelSize*3., vec4(0.,0.,4.,0.), 1)*pixelSize, 0).b;\n\tfragColor.b += (BlurA(uv, 0).b - BlurA(uvr, 1).b)*11.\/256. - 2.\/256. + noise.z*1.\/256.;\n\n    fragColor = clamp(fragColor, 0., 1.);\n\n\/\/    fragColor = noise; \/\/ reset\n}","name":"","description":"","type":"buffer"},{"inputs":[],"outputs":[{"channel":"0"}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}","name":"","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":260,"src":"\/presets\/previz\/buffer03.png","ctype":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ resolution reduction and horizontal blur\n\nvec2 lower_left(vec2 uv)\n{\n    return fract(uv * 0.5);\n}\n\nvec2 lower_right(vec2 uv)\n{\n    return fract((uv - vec2(1, 0.)) * 0.5);\n}\n\nvec2 upper_left(vec2 uv)\n{\n    return fract((uv - vec2(0., 1)) * 0.5);\n}\n\nvec2 upper_right(vec2 uv)\n{\n    return fract((uv - 1.) * 0.5);\n}\n\nvec4 blur_horizontal(sampler2D channel, vec2 uv, float scale)\n{\n    float h = scale \/ iResolution.x;\n    vec4 sum = vec4(0.0);\n\n    sum += texture2D(channel, fract(vec2(uv.x - 4.0*h, uv.y)) ) * 0.05;\n    sum += texture2D(channel, fract(vec2(uv.x - 3.0*h, uv.y)) ) * 0.09;\n    sum += texture2D(channel, fract(vec2(uv.x - 2.0*h, uv.y)) ) * 0.12;\n    sum += texture2D(channel, fract(vec2(uv.x - 1.0*h, uv.y)) ) * 0.15;\n    sum += texture2D(channel, fract(vec2(uv.x + 0.0*h, uv.y)) ) * 0.16;\n    sum += texture2D(channel, fract(vec2(uv.x + 1.0*h, uv.y)) ) * 0.15;\n    sum += texture2D(channel, fract(vec2(uv.x + 2.0*h, uv.y)) ) * 0.12;\n    sum += texture2D(channel, fract(vec2(uv.x + 3.0*h, uv.y)) ) * 0.09;\n    sum += texture2D(channel, fract(vec2(uv.x + 4.0*h, uv.y)) ) * 0.05;\n\n    return sum\/0.98; \/\/ normalize\n}\n\nvec4 blur_horizontal_left_column(vec2 uv, int depth)\n{\n    float h = pow(2., float(depth)) \/ iResolution.x;    \n    vec2 uv1, uv2, uv3, uv4, uv5, uv6, uv7, uv8, uv9;\n\n    uv1 = fract(vec2(uv.x - 4.0 * h, uv.y) * 2.);\n    uv2 = fract(vec2(uv.x - 3.0 * h, uv.y) * 2.);\n    uv3 = fract(vec2(uv.x - 2.0 * h, uv.y) * 2.);\n    uv4 = fract(vec2(uv.x - 1.0 * h, uv.y) * 2.);\n    uv5 = fract(vec2(uv.x + 0.0 * h, uv.y) * 2.);\n    uv6 = fract(vec2(uv.x + 1.0 * h, uv.y) * 2.);\n    uv7 = fract(vec2(uv.x + 2.0 * h, uv.y) * 2.);\n    uv8 = fract(vec2(uv.x + 3.0 * h, uv.y) * 2.);\n    uv9 = fract(vec2(uv.x + 4.0 * h, uv.y) * 2.);\n\n    if(uv.y > 0.5)\n    {\n        uv1 = upper_left(uv1);\n        uv2 = upper_left(uv2);\n        uv3 = upper_left(uv3);\n        uv4 = upper_left(uv4);\n        uv5 = upper_left(uv5);\n        uv6 = upper_left(uv6);\n        uv7 = upper_left(uv7);\n        uv8 = upper_left(uv8);\n        uv9 = upper_left(uv9);\n    }\n    else{\n        uv1 = lower_left(uv1);\n        uv2 = lower_left(uv2);\n        uv3 = lower_left(uv3);\n        uv4 = lower_left(uv4);\n        uv5 = lower_left(uv5);\n        uv6 = lower_left(uv6);\n        uv7 = lower_left(uv7);\n        uv8 = lower_left(uv8);\n        uv9 = lower_left(uv9);\n    }\n\n    for(int level = 0; level < 8; level++)\n    {\n        if(level >= depth)\n        {\n            break;\n        }\n\n        uv1 = lower_right(uv1);\n        uv2 = lower_right(uv2);\n        uv3 = lower_right(uv3);\n        uv4 = lower_right(uv4);\n        uv5 = lower_right(uv5);\n        uv6 = lower_right(uv6);\n        uv7 = lower_right(uv7);\n        uv8 = lower_right(uv8);\n        uv9 = lower_right(uv9);\n    }\n\n    vec4 sum = vec4(0.0);\n\n    sum += texture2D(iChannel3, uv1) * 0.05;\n    sum += texture2D(iChannel3, uv2) * 0.09;\n    sum += texture2D(iChannel3, uv3) * 0.12;\n    sum += texture2D(iChannel3, uv4) * 0.15;\n    sum += texture2D(iChannel3, uv5) * 0.16;\n    sum += texture2D(iChannel3, uv6) * 0.15;\n    sum += texture2D(iChannel3, uv7) * 0.12;\n    sum += texture2D(iChannel3, uv8) * 0.09;\n    sum += texture2D(iChannel3, uv9) * 0.05;\n\n    return sum\/0.98; \/\/ normalize\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n\n    if(uv.x < 0.5)\n    {\n        vec2 uv_half = fract(uv*2.);\n        if(uv.y > 0.5)\n        {\n            fragColor = blur_horizontal(iChannel0, uv_half, 1.);\n        }\n        else\n        {\n            fragColor = blur_horizontal(iChannel1, uv_half, 1.);\n        }\n    }\n    else\n    {\n        for(int level = 0; level < 8; level++)\n        {\n            if((uv.x > 0.5 && uv.y > 0.5) || (uv.x <= 0.5))\n            {\n                break;\n            }\n            vec2 uv_half = fract(uv*2.);\n            fragColor = blur_horizontal_left_column(uv_half, level);\n            uv = uv_half;\n        }\n    }\n}","name":"","description":"","type":"buffer"},{"inputs":[{"id":259,"src":"\/presets\/previz\/buffer02.png","ctype":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ vertical blur (second pass)\n\nvec2 lower_left(vec2 uv)\n{\n    return fract(uv * 0.5);\n}\n\nvec2 lower_right(vec2 uv)\n{\n    return fract((uv - vec2(1, 0.)) * 0.5);\n}\n\nvec2 upper_left(vec2 uv)\n{\n    return fract((uv - vec2(0., 1)) * 0.5);\n}\n\nvec2 upper_right(vec2 uv)\n{\n    return fract((uv - 1.) * 0.5);\n}\n\nvec4 blur_vertical_upper_left(sampler2D channel, vec2 uv)\n{\n    float v = 1. \/ iResolution.y;\n    vec4 sum = vec4(0.0);\n    sum += texture2D(channel, upper_left(vec2(uv.x, uv.y - 4.0*v)) ) * 0.05;\n    sum += texture2D(channel, upper_left(vec2(uv.x, uv.y - 3.0*v)) ) * 0.09;\n    sum += texture2D(channel, upper_left(vec2(uv.x, uv.y - 2.0*v)) ) * 0.12;\n    sum += texture2D(channel, upper_left(vec2(uv.x, uv.y - 1.0*v)) ) * 0.15;\n    sum += texture2D(channel, upper_left(vec2(uv.x, uv.y + 0.0*v)) ) * 0.16;\n    sum += texture2D(channel, upper_left(vec2(uv.x, uv.y + 1.0*v)) ) * 0.15;\n    sum += texture2D(channel, upper_left(vec2(uv.x, uv.y + 2.0*v)) ) * 0.12;\n    sum += texture2D(channel, upper_left(vec2(uv.x, uv.y + 3.0*v)) ) * 0.09;\n    sum += texture2D(channel, upper_left(vec2(uv.x, uv.y + 4.0*v)) ) * 0.05;\n    return sum\/0.98; \/\/ normalize\n}\n\nvec4 blur_vertical_lower_left(sampler2D channel, vec2 uv)\n{\n    float v = 1. \/ iResolution.y;\n    vec4 sum = vec4(0.0);\n    sum += texture2D(channel, lower_left(vec2(uv.x, uv.y - 4.0*v)) ) * 0.05;\n    sum += texture2D(channel, lower_left(vec2(uv.x, uv.y - 3.0*v)) ) * 0.09;\n    sum += texture2D(channel, lower_left(vec2(uv.x, uv.y - 2.0*v)) ) * 0.12;\n    sum += texture2D(channel, lower_left(vec2(uv.x, uv.y - 1.0*v)) ) * 0.15;\n    sum += texture2D(channel, lower_left(vec2(uv.x, uv.y + 0.0*v)) ) * 0.16;\n    sum += texture2D(channel, lower_left(vec2(uv.x, uv.y + 1.0*v)) ) * 0.15;\n    sum += texture2D(channel, lower_left(vec2(uv.x, uv.y + 2.0*v)) ) * 0.12;\n    sum += texture2D(channel, lower_left(vec2(uv.x, uv.y + 3.0*v)) ) * 0.09;\n    sum += texture2D(channel, lower_left(vec2(uv.x, uv.y + 4.0*v)) ) * 0.05;\n    return sum\/0.98; \/\/ normalize\n}\n\nvec4 blur_vertical_left_column(vec2 uv, int depth)\n{\n    float v = pow(2., float(depth)) \/ iResolution.y;\n\n    vec2 uv1, uv2, uv3, uv4, uv5, uv6, uv7, uv8, uv9;\n\n    uv1 = fract(vec2(uv.x, uv.y - 4.0*v) * 2.);\n    uv2 = fract(vec2(uv.x, uv.y - 3.0*v) * 2.);\n    uv3 = fract(vec2(uv.x, uv.y - 2.0*v) * 2.);\n    uv4 = fract(vec2(uv.x, uv.y - 1.0*v) * 2.);\n    uv5 = fract(vec2(uv.x, uv.y + 0.0*v) * 2.);\n    uv6 = fract(vec2(uv.x, uv.y + 1.0*v) * 2.);\n    uv7 = fract(vec2(uv.x, uv.y + 2.0*v) * 2.);\n    uv8 = fract(vec2(uv.x, uv.y + 3.0*v) * 2.);\n    uv9 = fract(vec2(uv.x, uv.y + 4.0*v) * 2.);\n\n    if(uv.y > 0.5)\n    {\n        uv1 = upper_left(uv1);\n        uv2 = upper_left(uv2);\n        uv3 = upper_left(uv3);\n        uv4 = upper_left(uv4);\n        uv5 = upper_left(uv5);\n        uv6 = upper_left(uv6);\n        uv7 = upper_left(uv7);\n        uv8 = upper_left(uv8);\n        uv9 = upper_left(uv9);\n    }\n    else{\n        uv1 = lower_left(uv1);\n        uv2 = lower_left(uv2);\n        uv3 = lower_left(uv3);\n        uv4 = lower_left(uv4);\n        uv5 = lower_left(uv5);\n        uv6 = lower_left(uv6);\n        uv7 = lower_left(uv7);\n        uv8 = lower_left(uv8);\n        uv9 = lower_left(uv9);\n    }\n\n    for(int level = 0; level < 8; level++)\n    {\n        if(level > depth)\n        {\n            break;\n        }\n\n        uv1 = lower_right(uv1);\n        uv2 = lower_right(uv2);\n        uv3 = lower_right(uv3);\n        uv4 = lower_right(uv4);\n        uv5 = lower_right(uv5);\n        uv6 = lower_right(uv6);\n        uv7 = lower_right(uv7);\n        uv8 = lower_right(uv8);\n        uv9 = lower_right(uv9);\n    }\n\n    vec4 sum = vec4(0.0);\n\n    sum += texture2D(iChannel2, uv1) * 0.05;\n    sum += texture2D(iChannel2, uv2) * 0.09;\n    sum += texture2D(iChannel2, uv3) * 0.12;\n    sum += texture2D(iChannel2, uv4) * 0.15;\n    sum += texture2D(iChannel2, uv5) * 0.16;\n    sum += texture2D(iChannel2, uv6) * 0.15;\n    sum += texture2D(iChannel2, uv7) * 0.12;\n    sum += texture2D(iChannel2, uv8) * 0.09;\n    sum += texture2D(iChannel2, uv9) * 0.05;\n\n    return sum\/0.98; \/\/ normalize\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec2 uv_orig = uv;\n    vec2 uv_half = fract(uv*2.);\n    if(uv.x < 0.5)\n    {\n        if(uv.y > 0.5)\n        {\n            fragColor = blur_vertical_upper_left(iChannel2, uv_half);\n        }\n        else\n        {\n            fragColor = blur_vertical_lower_left(iChannel2, uv_half);\n        }\n    }\n    else\n    {\n        for(int level = 0; level < 8; level++)\n        {\n            if((uv.x > 0.5 && uv.y >= 0.5) || (uv.x < 0.5))\n            {\n                break;\n            }\n            vec2 uv_half = fract(uv*2.);\n            fragColor = blur_vertical_left_column(uv_half, level);\n            uv = uv_half;\n        }  \n    }\n    uv = uv_orig;\n    float eighth = 1.\/8.;\n    if(uv.x > 7.*eighth && uv.x < 8.*eighth && uv.y > 2.*eighth && uv.y < 3.*eighth)\n    {\n        fragColor = vec4(iMouse.xy \/ iResolution.xy, iMouse.zw \/ iResolution.xy);\n    }\n}","name":"","description":"","type":"buffer"}]}}