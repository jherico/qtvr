{"Shader":{"ver":"0.1","info":{"id":"Msc3zB","date":"1450543452","viewed":283,"name":"Palette Maker","username":"skaven","description":"A palette maker inspired from http:\/\/paletton.com Modify the parameters for luminance\/saturation variations. Lum\/sat mapping is crap: it should be mapped on an hemisphere instead of cropped planar values.","likes":15,"published":3,"flags":0,"tags":["mouse","gradient","palette"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ A palette generator shader heavily inspired by http:\/\/paletton.com\/#\n\nfloat pi = 3.14159265358979;\n\n\/\/ parameters\nconst float gradientAngle = 45.0; \/\/ degrees\nconst vec2 lumSatOffset = vec2(0.1,0.0); \/\/ range [-1..1]\nconst float lumSatAngle = 110.0; \/\/ degrees\nconst float lumSatFactor = 0.4;\/\/ range [0..1]\n\n    \nvec3 hsv2rgb (in vec3 hsv) \n{\n    return hsv.z * (1.0 + 0.5 * hsv.y * (cos (6.2832 * (hsv.x + vec3 (0.0, 0.6667, 0.3333))) - 1.0));\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 \/ 3.0, 2.0 \/ 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) \/ (6.0 * d + e)), d \/ (q.x + e), q.x);\n}\n\nvec3 baseColor(vec2 uv)\n{\n\tvec3 col = vec3(max(uv.y,0.0)+max(uv.x,0.0),max(-uv.y,0.0)+max(uv.x,0.0),max(-uv.x,0.0));\n    return col;\n}\n\nvec2 screenToWorld(vec2 screenPos)\n{\n    vec2 uv = screenPos.xy \/ iResolution.xy - vec2(0.5);\n    uv *= vec2(iResolution.x\/iResolution.y, 1.0);\n    uv += vec2(0.4, 0.0);\n    return uv;\n}        \n\nvec3 addBlackDot(vec3 col, vec2 worldUV, vec2 selection, vec3 dotcolor)\n{\n    vec2 difSelection = selection*0.27-worldUV;\n    col = mix(vec3(1.0), col, smoothstep(0.01,0.015,sqrt(dot(difSelection,difSelection))));\n    col = mix(dotcolor, col, smoothstep(0.008,0.01,sqrt(dot(difSelection,difSelection))));\n    return col;\n}\n\n\nvec3 addLumSatBlackDot(vec3 col, vec2 worldUV, vec2 selection)\n{\n    vec2 difSelection = selection*0.2-worldUV;\n    col = mix(vec3(1.0), col, smoothstep(0.007,0.01,sqrt(dot(difSelection,difSelection))));\n    col = mix(vec3(0.0), col, smoothstep(0.005,0.007,sqrt(dot(difSelection,difSelection))));\n    return col;\n}\n\nvec2 rotate(vec2 xy, float angle)\n{\n    float sn = sin(angle);\n    float cs = cos(angle);\n    return vec2(xy.x*cs-xy.y*sn, xy.y*cs + xy.x*sn);\n}\n\nfloat degToRad(float angle)\n{\n    return angle * pi * (1.0\/180.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = screenToWorld(fragCoord.xy);\n    vec2 hueSelection = screenToWorld(iMouse.xy);\n    \n    hueSelection = normalize(hueSelection);\n    vec2 worldUV = uv;\n    \n    \n    \n    float d = sqrt(dot(uv,uv));\n    uv = normalize(uv);\n    \n    \n    vec3 useCol = baseColor(hueSelection);\n    vec3 colHSV = rgb2hsv(useCol);\n    vec3 extremityCol = hsv2rgb(vec3(colHSV.r, uv*0.5+0.5));\n       \n      \n   \t\/\/ mix left\n    vec3 col = mix(mix(useCol, extremityCol, d*5.0), baseColor(uv), smoothstep(0.195,0.2,d)); \/\/ blend palette SV with round H\n    col = mix(col, vec3(0.0),  smoothstep(0.345,0.35,d));\n    \n    \/\/ palette position\n    vec2 paletteCenter = vec2(0.8,0.0);\n    vec2 dt = paletteCenter - worldUV;\n    \n    float angle = atan(dt.y, dt.x)\/(pi*2.0) + 0.5;\n    \n    vec3 colPalette=vec3(0.0);\n    \n    float angles[4];\n    angles[0] = 0.0;\n\tangles[1] = gradientAngle;\n    angles[2] = 180.0;\n    angles[3] = 180.0+gradientAngle;\n    \n    float distPalette = sqrt(dot(dt,dt));\n    for (int i=0;i<4;i++)\n    {\n        vec2 dir = rotate(hueSelection, degToRad(angles[i]));\n\t\tfloat ifl = float(i);\n        \n        \/\/ black dots\n        col = addBlackDot(col, worldUV, dir, vec3((i==0)?0.4:0.0));\n\n        \n        vec3 colPaletteBase = mix(colPalette, baseColor(dir), smoothstep(0.25*ifl, 0.25*ifl, angle));\n        float gradientH = rgb2hsv(colPaletteBase).r;\n        \/\/ LumSat\n        float lumSatAngleRad = degToRad(lumSatAngle);\n        for (int i=0;i<5;i++)\n        {\n            float ifl = float(i);\n            vec2 lumSatPos = lumSatOffset + vec2(cos(lumSatAngleRad),sin(lumSatAngleRad)) * lumSatFactor * (-1.0 + 0.5*ifl);\n            col = addLumSatBlackDot(col, worldUV, lumSatPos);\n            \n            \/\/ variation on gradient\n\n            vec3 variation = hsv2rgb(vec3(gradientH, lumSatPos+1.0));\n            colPalette = mix(colPalette, variation, smoothstep(0.19*ifl, 0.2*ifl, distPalette*(1.0\/0.345)));\n        }\n     \n    }    \n    \/\/ mix right\n    col = mix(colPalette, col, smoothstep(0.345,0.35, distPalette));\n    \n\tfragColor = vec4(col,1.0);\n}","name":"","description":"","type":"image"}]}}