{"Shader":{"ver":"0.1","info":{"id":"XdcGWS","date":"1452730410","viewed":3964,"name":"Shader Rally","username":"P_Malin","description":"Physics Hackery using the new mutipass things.<br\/>WASD to drive. Space = brake<br\/>Click mouse to orbit camera<br\/>G toggle gravity<br\/>V toggle wheels (vehicle forces)<br\/>. and , flip car","likes":59,"published":3,"flags":48,"tags":["physics","vehicle","truck"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":259,"src":"\/presets\/previz\/buffer02.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Shader Rally - @P_Malin\n\n\/\/ (Uncomment FAST_VERSION in \"Buf C\" for a framerate boost)\n\n\/\/ Physics Hackery using the new mutipass things.\n\n\/\/ WASD to drive. Space = brake\n\/\/ G toggle gravity\n\/\/ V toggle wheels (vehicle forces)\n\/\/ . and , flip car\n\n\/\/ Restart shader to reset car\n\n\/\/ I'll add more soon (including a fast version of the rendering code maybe :)\n\n\/\/ Image shader - final postprocessing\n\n#define MOTION_BLUR_TAPS 32\n\nvec2 addrVehicle = vec2( 0.0, 0.0 );\n\nvec2 offsetVehicleParam0 = vec2( 0.0, 0.0 );\n\nvec2 offsetVehicleBody = vec2( 1.0, 0.0 );\nvec2 offsetBodyPos = vec2( 0.0, 0.0 );\nvec2 offsetBodyRot = vec2( 1.0, 0.0 );\nvec2 offsetBodyMom = vec2( 2.0, 0.0 );\nvec2 offsetBodyAngMom = vec2( 3.0, 0.0 );\n\nvec2 offsetVehicleWheel0 = vec2( 5.0, 0.0 );\nvec2 offsetVehicleWheel1 = vec2( 6.0, 0.0 );\nvec2 offsetVehicleWheel2 = vec2( 7.0, 0.0 );\nvec2 offsetVehicleWheel3 = vec2( 8.0, 0.0 );\n\nvec2 addrCamera = vec2( 0.0, 1.0 );\nvec2 offsetCameraPos = vec2( 0.0, 0.0 );\nvec2 offsetCameraTarget = vec2( 1.0, 0.0 );\n\nvec2 addrPrevCamera = vec2( 0.0, 2.0 );\n\nvec4 LoadVec4( in vec2 vAddr )\n{\n    vec2 vUV = (vAddr + 0.5) \/ iChannelResolution[0].xy;\n    return texture2D( iChannel0, vUV, -100.0 );\n}\n\nvec3 LoadVec3( in vec2 vAddr )\n{\n    return LoadVec4( vAddr ).xyz;\n}\n\n\nvec3 ApplyPostFX( const in vec2 vUV, const in vec3 vInput );\n\n\/\/ CAMERA\n\nvec2 GetWindowCoord( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x \/ iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvec2 GetUVFromWindowCoord( const in vec2 vWindow )\n{\n\tvec2 vScaledWindow = vWindow;\n    vScaledWindow.x *= iResolution.y \/ iResolution.x;\n    \n\t return vScaledWindow * 0.5 + 0.5;\n}\n\n\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget )\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\t\t\t\t\t\t  \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * 2.0);\n\n\treturn vDir;\n}\n\nvec2 GetCameraWindowCoord(const in vec3 vWorldPos, const in vec3 vCameraPos, const in vec3 vCameraTarget)\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\n    vec3 vOffset = vWorldPos - vCameraPos;\n    vec3 vCameraLocal;\n    vCameraLocal.x = dot(vOffset, vRight);\n    vCameraLocal.y = dot(vOffset, vUp);\n    vCameraLocal.z = dot(vOffset, vForward);\n\n    vec2 vWindowPos = vCameraLocal.xy \/ (vCameraLocal.z \/ 2.0);\n    \n    return vWindowPos;\n}\n\nfloat GetCoC( float fDistance, float fPlaneInFocus )\n{\n\t\/\/ http:\/\/http.developer.nvidia.com\/GPUGems\/gpugems_ch23.html\n\n    float fAperture = 0.03;\n    float fFocalLength = 1.0;\n    \n\treturn abs(fAperture * (fFocalLength * (fDistance - fPlaneInFocus)) \/\n          (fDistance * (fPlaneInFocus - fFocalLength)));  \n}\n\n\n\/\/ Random\n\n#define MOD2 vec2(4.438975,3.972973)\n\nfloat Hash( float p ) \n{\n    \/\/ https:\/\/www.shadertoy.com\/view\/4djSRW - Dave Hoskins\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);    \n}\n\n\nfloat fGolden = 3.141592 * (3.0 - sqrt(5.0));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vUV = fragCoord.xy \/ iResolution.xy;\n\n    vec4 vSample = texture2D( iChannel1, vUV ).rgba;\n\t\n    float fDepth = abs(vSample.w);\n    \n\tvec3 vCameraPos = LoadVec3( addrCamera + offsetCameraPos );\n\tvec3 vCameraTarget = LoadVec3( addrCamera + offsetCameraTarget );\n    \n\tvec3 vRayOrigin = vCameraPos;\n\tvec3 vRayDir = GetCameraRayDir( GetWindowCoord(vUV), vCameraPos, vCameraTarget );\n        \n    vec3 vWorldPos = vRayOrigin + vRayDir * fDepth;\n    \n\tvec3 vPrevCameraPos = LoadVec3( addrPrevCamera + offsetCameraPos );\n\tvec3 vPrevCameraTarget = LoadVec3( addrPrevCamera + offsetCameraTarget );\n    vec2 vPrevWindow = GetCameraWindowCoord( vWorldPos, vPrevCameraPos, vPrevCameraTarget );\n    vec2 vPrevUV = GetUVFromWindowCoord(vPrevWindow);\n    \n    if( vSample.a < 0.0 ) \n    {\n        vPrevUV = vUV;\n    }\n        \n\tvec3 vResult = vec3(0.0);\n    \n    float fTot = 0.0;\n    \n    float fPlaneInFocus = length(vCameraPos - vCameraTarget);\n    \n    float fCoC = GetCoC( abs(fDepth), fPlaneInFocus );\n    \n    float r = 1.0;\n    vec2 vangle = vec2(0.0,fCoC); \/\/ Start angle\n    \n    vResult.rgb = vSample.rgb * fCoC;\n    fTot += fCoC;\n    \n    float fMotionBlurTaps = float(MOTION_BLUR_TAPS);\n    \n    float f = 0.0;\n    float fIndex = 0.0;\n    for(int i=1; i<MOTION_BLUR_TAPS; i++)\n    {\n        vec2 vTapUV = mix( vUV, vPrevUV, f - 0.5 );\n                \n        float fRand = Hash( iGlobalTime + fIndex + vUV.x + vUV.y * 12.345);\n        \n        \/\/ http:\/\/blog.marmakoide.org\/?p=1\n        \n        float fTheta = fRand * fGolden * fMotionBlurTaps;\n        float fRadius = fCoC * sqrt( fRand * fMotionBlurTaps ) \/ sqrt( fMotionBlurTaps );        \n        \n        \/\/float fTheta = fIndex * fGolden;\n        \/\/float fRadius = fCoC * sqrt( fIndex ) \/ sqrt( fMotionBlurTaps );\n        \n        vTapUV += vec2( sin(fTheta), cos(fTheta) ) * fRadius;\n        \n        vec4 vTapSample = texture2D( iChannel1, vTapUV ).rgba;\n        if( sign(vTapSample.a) == sign(vSample.a) )\n        {\n  \t\t  \tfloat fCurrCoC = GetCoC( abs(vTapSample.a), fPlaneInFocus );\n            \n            float fWeight = fCurrCoC + 1.0;\n            \n    \t\tvResult += vTapSample.rgb * fWeight;\n        \tfTot += fWeight;\n        }\n        f += 1.0 \/ fMotionBlurTaps;\n        fIndex += 1.0;\n    }\n    vResult \/= fTot;\n        \n\tvec3 vFinal = ApplyPostFX( vUV, vResult );\n\n    \/\/ Draw depth\n    \/\/vFinal = vec3(1.0) \/ abs(vSample.a);    \n    \n\tfragColor = vec4(vFinal, 1.0);\n}\n\n\/\/ POSTFX\n\nvec3 ApplyVignetting( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0);\n\t\n\tfloat fDist = dot(vOffset, vOffset);\n\t\n\tconst float kStrength = 0.75;\n\t\n\tfloat fShade = mix( 1.0, 1.0 - kStrength, fDist );\t\n\n\treturn vInput * fShade;\n}\n\nvec3 ApplyTonemap( const in vec3 vLinear )\n{\n\tconst float kExposure = 1.0;\n\t\n\treturn 1.0 - exp2(vLinear * -kExposure);\t\n}\n\nvec3 ApplyGamma( const in vec3 vLinear )\n{\n\tconst float kGamma = 2.2;\n\n\treturn pow(vLinear, vec3(1.0\/kGamma));\t\n}\n\nvec3 ApplyPostFX( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec3 vTemp = ApplyVignetting( vUV, vInput );\t\n\t\n\tvTemp = ApplyTonemap(vTemp);\n\t\n\treturn ApplyGamma(vTemp);\t\t\n}","name":"","description":"","type":"image"},{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Shader Rally - @P_Malin\n\n\/\/ Physics Hackery using the new mutipass things.\n\n\/\/ WASD to drive. Space = brake\n\/\/ G toggle gravity\n\/\/ V toggle wheels (vehicle forces)\n\/\/ . and , flip car\n\n\/\/ Simulation Shader\n\n\/\/#define ENABLE_DEBUG_FORCES\n#define ENABLE_GRAVITY_TOGGLE\n\nvec2 addrVehicle = vec2( 0.0, 0.0 );\n\nvec2 offsetVehicleParam0 = vec2( 0.0, 0.0 );\n\nvec2 offsetVehicleBody = vec2( 1.0, 0.0 );\nvec2 offsetBodyPos = vec2( 0.0, 0.0 );\nvec2 offsetBodyRot = vec2( 1.0, 0.0 );\nvec2 offsetBodyMom = vec2( 2.0, 0.0 );\nvec2 offsetBodyAngMom = vec2( 3.0, 0.0 );\n\nvec2 offsetVehicleWheel0 = vec2( 5.0, 0.0 );\nvec2 offsetVehicleWheel1 = vec2( 7.0, 0.0 );\nvec2 offsetVehicleWheel2 = vec2( 9.0, 0.0 );\nvec2 offsetVehicleWheel3 = vec2( 11.0, 0.0 );\n\nvec2 offsetWheelState = vec2( 0.0, 0.0 );\nvec2 offsetWheelContactState = vec2( 1.0, 0.0 );\n\n\nvec2 addrCamera = vec2( 0.0, 1.0 );\nvec2 offsetCameraPos = vec2( 0.0, 0.0 );\nvec2 offsetCameraTarget = vec2( 1.0, 0.0 );\n\nvec2 addrPrevCamera = vec2( 0.0, 2.0 );\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Constants\n\nfloat PI = acos(-1.0);\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Storage\n\nvec4 LoadVec4( in vec2 vAddr )\n{\n    vec2 vUV = (vAddr + 0.5) \/ iChannelResolution[0].xy;\n    return texture2D( iChannel0, vUV, -100.0 );\n}\n\nvec3 LoadVec3( in vec2 vAddr )\n{\n    return LoadVec4( vAddr ).xyz;\n}\n\nfloat IsInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\n\nvoid StoreVec4( in vec2 vAddr, in vec4 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( IsInside( fragCoord, vAddr ) > 0.0 ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in vec2 vAddr, in vec3 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ Keyboard \n\n\n\/\/ Keyboard constants definition\nconst float KEY_SPACE = 32.5\/256.0;\nconst float KEY_LEFT  = 37.5\/256.0;\nconst float KEY_UP    = 38.5\/256.0;\nconst float KEY_RIGHT = 39.5\/256.0;\nconst float KEY_DOWN  = 40.5\/256.0;\nconst float KEY_A     = 65.5\/256.0;\nconst float KEY_B     = 66.5\/256.0;\nconst float KEY_C     = 67.5\/256.0;\nconst float KEY_D     = 68.5\/256.0;\nconst float KEY_E     = 69.5\/256.0;\nconst float KEY_F     = 70.5\/256.0;\nconst float KEY_G     = 71.5\/256.0;\nconst float KEY_H     = 72.5\/256.0;\nconst float KEY_I     = 73.5\/256.0;\nconst float KEY_J     = 74.5\/256.0;\nconst float KEY_K     = 75.5\/256.0;\nconst float KEY_L     = 76.5\/256.0;\nconst float KEY_M     = 77.5\/256.0;\nconst float KEY_N     = 78.5\/256.0;\nconst float KEY_O     = 79.5\/256.0;\nconst float KEY_P     = 80.5\/256.0;\nconst float KEY_Q     = 81.5\/256.0;\nconst float KEY_R     = 82.5\/256.0;\nconst float KEY_S     = 83.5\/256.0;\nconst float KEY_T     = 84.5\/256.0;\nconst float KEY_U     = 85.5\/256.0;\nconst float KEY_V     = 86.5\/256.0;\nconst float KEY_W     = 87.5\/256.0;\nconst float KEY_X     = 88.5\/256.0;\nconst float KEY_Y     = 89.5\/256.0;\nconst float KEY_Z     = 90.5\/256.0;\nconst float KEY_COMMA = 188.5\/256.0;\nconst float KEY_PER   = 190.5\/256.0;\n\nbool KeyIsPressed(float key)\n{\n\treturn texture2D( iChannel1, vec2(key, 0.0) ).x > 0.0;\n}\n\nbool KeyIsToggled(float key)\n{\n\treturn texture2D( iChannel1, vec2(key, 1.0) ).x > 0.0;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Rotation\n\nvec2 Rotate( const in vec2 vPos, const in float t )\n{\n    float s = sin(t);\n    float c = cos(t);\n    \n    return vec2( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y);\n}\n\nvec3 RotX( const in vec3 vPos, float t )\n{\n    vec3 result;\n    result.x = vPos.x;\n  \tresult.yz = Rotate( vPos.yz, t );\n    return result;\n}\n\nvec3 RotY( const in vec3 vPos, float t )\n{\n    vec3 result;\n    result.y = vPos.y;\n  \tresult.xz = Rotate( vPos.xz, t );\n    return result;\n}\n\nvec3 RotZ( const in vec3 vPos, float t )\n{\n    vec3 result;\n    result.z = vPos.z;\n  \tresult.xy = Rotate( vPos.xy, t );\n    return result;\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Vec\n\nvec3 Vec3Parallel( vec3 x, vec3 n )\n{\n    float d = dot( x, n );\n    \n    return x - n * d;    \n}\n\nvec3 Vec3Perp( vec3 x, vec3 n )\n{\n    return x - Vec3Parallel( x, n );\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Quaternions\n\nvec4 QuatMul(const in vec4 lhs, const in vec4 rhs) \n{\n      return vec4( lhs.y*rhs.z - lhs.z*rhs.y + lhs.x*rhs.w + lhs.w*rhs.x,\n                   lhs.z*rhs.x - lhs.x*rhs.z + lhs.y*rhs.w + lhs.w*rhs.y,\n                   lhs.x*rhs.y - lhs.y*rhs.x + lhs.z*rhs.w + lhs.w*rhs.z,\n                   lhs.w*rhs.w - lhs.x*rhs.x - lhs.y*rhs.y - lhs.z*rhs.z);\n}\n\nvec4 QuatFromAxisAngle( vec3 vAxis, float fAngle )\n{\n\treturn vec4( normalize(vAxis) * sin(fAngle), cos(fAngle) );    \n}\n\nvec4 QuatFromVec3( vec3 vRot )\n{\n    float l = length( vRot );\n    if ( l <= 0.0 )\n    {\n        return vec4( 0.0, 0.0, 0.0, 1.0 );\n    }\n    return QuatFromAxisAngle( vRot, l );\n}\n\nmat3 QuatToMat3( const in vec4 q )\n{\n\tvec4 qSq = q * q;\n\tfloat xy2 = q.x * q.y * 2.0;\n\tfloat xz2 = q.x * q.z * 2.0;\n\tfloat yz2 = q.y * q.z * 2.0;\n\tfloat wx2 = q.w * q.x * 2.0;\n\tfloat wy2 = q.w * q.y * 2.0;\n\tfloat wz2 = q.w * q.z * 2.0;\n \n\treturn mat3 (\t\n     qSq.w + qSq.x - qSq.y - qSq.z, xy2 - wz2, xz2 + wy2,\n     xy2 + wz2, qSq.w - qSq.x + qSq.y - qSq.z, yz2 - wx2,\n     xz2 - wy2, yz2 + wx2, qSq.w - qSq.x - qSq.y + qSq.z );\n}\n\nvec3 QuatMul( vec3 v, vec4 q )\n{\n    \/\/ TODO Validate vs other quat code\n    vec3 t = 2.0 * cross(q.xyz, v);\n\treturn v + q.w * t + cross(q.xyz, t);\n}\n\nvec3 ObjToWorld( vec3 v, mat3 m )\n{\n    return v * m;\n}\n\nvec3 WorldToObj( vec3 v, mat3 m )\n{\n    return m * v;\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\n\/\/ RAYTRACE\n\nfloat kFarClip=10.0;\n\nstruct SurfaceInfo\n{\n    vec3 vUVW;\n    float fId;\n};\n\nstruct ClosestSurface\n{\n    float fDist;\n    SurfaceInfo surface;\n};\n    \nvoid ClosestSurfaceInit( inout ClosestSurface closest, float fId, vec3 vUVW )\n{\n    closest.fDist = 10000.0;\n    closest.surface.vUVW = vUVW;\n    closest.surface.fId = fId;\n}\n\n\nClosestSurface ClosestSurfaceUnion( const in ClosestSurface a, const in ClosestSurface b )\n{\n    if ( a.fDist < b.fDist )\n    {\n        return a;\n    }\n\n    return b;        \n}\n    \nstruct C_Intersection\n{\n\tvec3 vPos;\n\tfloat fDist;\t\n\tvec3 vNormal;\n    SurfaceInfo surface;\n};\n    \n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Random\n\n#define MOD2 vec2(4.438975,3.972973)\n#define MOD3 vec3(.1031,.11369,.13787)\n#define MOD4 vec4(.1031,.11369,.13787, .09987)\n\nfloat Hash( float p ) \n{\n    \/\/ https:\/\/www.shadertoy.com\/view\/4djSRW - Dave Hoskins\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);    \n}\n\nvec3 Hash31(float p)\n{\n    \/\/ https:\/\/www.shadertoy.com\/view\/4djSRW - Dave Hoskins\n   vec3 p3 = fract(vec3(p) * MOD3);\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat SmoothNoise(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = Hash(n+  0.0);\n\tfloat b = Hash(n+  1.0);\n\tfloat c = Hash(n+ 57.0);\n\tfloat d = Hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n    return res;\n}\n\nfloat FBM( vec2 p, float ps ) {\n\tfloat f = 0.0;\n    float tot = 0.0;\n    float a = 1.0;\n    for( int i=0; i<3; i++)\n    {\n        f += SmoothNoise( p ) * a;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f \/ tot;\n}\n    \n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Scene\n\n#define MAT_TERRAIN 1.0\n#define MAT_CAR_BODY 4.0\n#define MAT_CAR_WINDOW 3.0\n#define MAT_CHROME 3.0\n#define MAT_GRILL 2.0\n#define MAT_BLACK_PLASTIC 2.0\n#define MAT_AXLE 2.0\n#define MAT_WHEEL 5.0    \n#define MAT_REAR 2.0\n#define MAT_SUSPENSION 6.0    \n#define MAT_WOOD 7.0\n\nfloat GetTerrainDistance( const vec3 vPos )\n{    \n    float fbm = FBM( vPos.xz * vec2(0.5, 1.0), 0.5 );\n    float fTerrainHeight = fbm * fbm;\n    fTerrainHeight = fTerrainHeight * (sin(vPos.x * 0.1) + 1.0) * 0.5 + vPos.y + 3.0;    \n    \n    \/\/float h = 1.0 - exp(-abs(vPos.x + 15.0) * 0.01);\n    \n    \/\/fTerrainHeight += sin(vPos.x * 0.05) * 5.0 * h;\n    \/\/fTerrainHeight += sin(vPos.z * 0.05) * 5.0 * h;\n\n\treturn fTerrainHeight;\n}\n\nClosestSurface GetRampClosestSurface( const vec3 vPos, const float fRampSeed )\n{\n    ClosestSurface closest;\n    \n    vec3 vHash = Hash31( fRampSeed );\n    \n    closest.surface.fId = MAT_WOOD;\n    closest.surface.vUVW = vPos.xyz;\n    \n    float fHeight = 2.0 + vHash.x * 6.0;\n    float fRadius = 10.0 + vHash.y * 20.0;\n    float fLedge = 2.0 + vHash.z * 3.0;\n        \n    float h2 = fRadius - fHeight;\n    float fLength = sqrt(fRadius * fRadius - h2 * h2);\n    fLength = fLength + fLedge;\n    closest.fDist = sdBox( vPos - vec3( 0.0, fHeight * 0.5, fLength * 0.5 ), vec3(3.0, fHeight * 0.5, fLength * 0.5));\n    \n\n    vec3 vCylDomain = vPos - vec3( 0.0, fRadius, 0.0 );\n    float fCylDist = length(vCylDomain.yz) - fRadius;\n    \n    \/\/closest.fDist = fCylDist;\n    \n    closest.fDist = max( closest.fDist, -fCylDist);\n    \n    return closest;\n}\n\nClosestSurface GetEnvironmentClosestSurface( const vec3 vPos )\n{\n    ClosestSurface terrainClosest;\n    terrainClosest.surface.fId = MAT_TERRAIN;\n    terrainClosest.surface.vUVW = vec3(vPos.xz,0.0);\n    terrainClosest.fDist = GetTerrainDistance( vPos );\n\n    \/\/return terrainClosest;\n    \n    float fRepeat = 100.0;\n    vec3 vRampDomain = vPos - vec3(-15.0, -3.0, 0.0);\n    float fRampUnitZ = vRampDomain.z \/ fRepeat + 0.5;\n    float fRampSeed = floor( fRampUnitZ );\n    vRampDomain.z = (fract(fRampUnitZ) - 0.5) * fRepeat;\n    ClosestSurface rampClosest = GetRampClosestSurface( vRampDomain, fRampSeed );\n\n    return ClosestSurfaceUnion( terrainClosest, rampClosest );\n}\n\nClosestSurface GetSceneClosestSurface( const vec3 vPos )\n{    \n    ClosestSurface closest = GetEnvironmentClosestSurface( vPos );\n    \n    return closest;\n}\n\nvec3 GetSceneNormal( const in vec3 vPos )\n{\n    const float fDelta = 0.0001;\n\n    vec3 vDir1 = vec3( 1.0, -1.0, -1.0);\n    vec3 vDir2 = vec3(-1.0, -1.0,  1.0);\n    vec3 vDir3 = vec3(-1.0,  1.0, -1.0);\n    vec3 vDir4 = vec3( 1.0,  1.0,  1.0);\n\t\n    vec3 vOffset1 = vDir1 * fDelta;\n    vec3 vOffset2 = vDir2 * fDelta;\n    vec3 vOffset3 = vDir3 * fDelta;\n    vec3 vOffset4 = vDir4 * fDelta;\n\n    ClosestSurface c1 = GetSceneClosestSurface( vPos + vOffset1 );\n    ClosestSurface c2 = GetSceneClosestSurface( vPos + vOffset2 );\n    ClosestSurface c3 = GetSceneClosestSurface( vPos + vOffset3 );\n    ClosestSurface c4 = GetSceneClosestSurface( vPos + vOffset4 );\n\t\n    vec3 vNormal = vDir1 * c1.fDist + vDir2 * c2.fDist + vDir3 * c3.fDist + vDir4 * c4.fDist;\t\n\t\t\n    return normalize( vNormal );\n}\n\nvoid TraceScene( out C_Intersection outIntersection, const in vec3 vOrigin, const in vec3 vDir )\n{\t\n\tvec3 vPos = vec3(0.0);\n\t\n\tfloat t = 0.1;\n\tconst int kRaymarchMaxIter = 32;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\n\t\tfloat fClosestDist = GetSceneClosestSurface( vOrigin + vDir * t ).fDist;\n\t\tt += fClosestDist;\n\t\tif(abs(fClosestDist) < 0.01)\n\t\t{\n\t\t\tbreak;\n\t\t}\t\t\n\t\tif(t > kFarClip)\n\t\t{\n\t\t\tt = kFarClip;\n\t\t\tbreak;\n\t\t}\n\t}\n    \n\toutIntersection.fDist = t;\n\toutIntersection.vPos = vOrigin + vDir * t;\n    \n    if( t >= kFarClip )\n    {\n        outIntersection.surface.fId = 0.0;\n        outIntersection.surface.vUVW = vec3( 0.0 );\n        outIntersection.vNormal = vec3(0.0, 1.0, 0.0);\n    }\n    else\n    {\n\t\toutIntersection.vNormal = GetSceneNormal( outIntersection.vPos );\n        outIntersection.surface = GetSceneClosestSurface( outIntersection.vPos ).surface;\n    }\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nstruct Body\n{\n    \/\/ Persistent State\n    vec3 vPos;\n    vec4 qRot;\n    vec3 vMomentum;\n    vec3 vAngularMomentum;\n    \n    \/\/ Derived\n    mat3 mRot;\n    \n    \/\/ Constant\n    float fMass;\n    float fIT; \/\/ Hacky scalar for inertia tensor\n    \n    \/\/ Per frame\n    vec3 vForce;\n    vec3 vTorque;\n};\n\nvoid BodyLoadState( out Body body, vec2 addr )\n{\n    body.vPos = LoadVec3( addr + offsetBodyPos );\n    body.qRot = LoadVec4( addr + offsetBodyRot );\n    body.vMomentum = LoadVec3( addr + offsetBodyMom );\n    body.vAngularMomentum = LoadVec3( addr + offsetBodyAngMom );\n}\n\nvoid BodyStoreState( vec2 addr, const in Body body, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec3( addr + offsetBodyPos, body.vPos, fragColor, fragCoord );\n    StoreVec4( addr + offsetBodyRot, body.qRot, fragColor, fragCoord );\n    StoreVec3( addr + offsetBodyMom, body.vMomentum, fragColor, fragCoord );\n    StoreVec3( addr + offsetBodyAngMom, body.vAngularMomentum, fragColor, fragCoord );\n}\n\nvoid BodyResetForFrame( inout Body body )\n{\n    body.vForce = vec3(0.0);\n    body.vTorque = vec3(0.0);\n}\n\nvoid BodyCalculateDerivedState( inout Body body )\n{\n    body.mRot = QuatToMat3( body.qRot );    \n}\n\nvoid BodyApplyGravity( inout Body body, float dT )\n{\n    float fAccel_MpS = -9.81;\n    body.vForce.y += body.fMass * fAccel_MpS;\n}\n\nvoid BodyIntegrate( inout Body body, float dT )\n{\n#ifdef ENABLE_GRAVITY_TOGGLE    \n    if( !KeyIsToggled( KEY_G ) )\n#endif \/\/ ENABLE_GRAVITY_TOGGLE        \n    {\n    \tBodyApplyGravity( body, dT );\n    }\n    \n    body.vMomentum += body.vForce * dT;\n    body.vAngularMomentum += body.vTorque * dT;\n    \n    vec3 vVel = body.vMomentum \/ body.fMass;\n    vec3 vAngVel = body.vAngularMomentum \/ body.fIT;\n\n    body.vPos += vVel * dT;\n    vec4 qAngDelta = QuatFromVec3( vAngVel * dT );\n    body.qRot = QuatMul( qAngDelta, body.qRot );\n\n    body.qRot = normalize( body.qRot );\n}\n\nvoid BodyApplyForce( inout Body body, vec3 vPos, vec3 vForce )\n{    \n    body.vForce += vForce;\n    body.vTorque += cross(vPos - body.vPos, vForce);     \n}\n\nvoid BodyApplyImpulse( inout Body body, vec3 vPos, vec3 vImpulse )\n{    \n    body.vMomentum += vImpulse;\n    body.vAngularMomentum += cross(vPos - body.vPos, vImpulse);     \n}\n\nvec3 BodyPointVelocity( const in Body body, vec3 vWorldPos )\n{\n    vec3 vVel = body.vMomentum \/ body.fMass;\n    vec3 vAngVel = body.vAngularMomentum \/ body.fIT;\n    \n    return vVel + cross( vAngVel, vWorldPos - body.vPos );\n}\n\n\nvoid BodyApplyDebugForces( inout Body body )\n{\n#ifdef ENABLE_DEBUG_FORCES    \n    float debugForceMag = 20000.0;\n    if ( KeyIsPressed( KEY_LEFT ) )\n    {\n        vec3 vForcePos = body.vPos;\n        vec3 vForce = vec3(-debugForceMag, 0.0, 0.0);\n        BodyApplyForce( body, vForcePos, vForce );\n    }\n    if ( KeyIsPressed( KEY_RIGHT ) )\n    {\n        vec3 vForcePos = body.vPos;\n        vec3 vForce = vec3(debugForceMag, 0.0, 0.0);\n        BodyApplyForce( body, vForcePos, vForce );\n    }\n    if ( KeyIsPressed( KEY_UP ) )\n    {\n        vec3 vForcePos = body.vPos;\n        vec3 vForce = vec3(0.0, 0.0, debugForceMag);\n        BodyApplyForce( body, vForcePos, vForce );\n    }\n    if ( KeyIsPressed( KEY_DOWN ) )\n    {\n        vec3 vForcePos = body.vPos;\n        vec3 vForce = vec3(0.0, 0.0, -debugForceMag);\n        BodyApplyForce( body, vForcePos, vForce );\n    }\n#endif \/\/ ENABLE_DEBUG_FORCES                \n    \n    float debugTorqueMag = 4000.0;\n    if ( KeyIsPressed( KEY_COMMA ) )\n    {\n        vec3 vForcePos = body.vPos;\n        vec3 vForce = vec3(0.0, -debugTorqueMag, 0.0);\n\t\tvForcePos.x += 2.0;\n        BodyApplyForce( body, vForcePos, vForce );\n\t\t\/\/vForcePos.x -= 4.0;\n        \/\/vForce = -vForce;\n        \/\/BodyApplyForce( body, vForcePos, vForce );\n    }\n    if ( KeyIsPressed( KEY_PER ) )\n    {\n        vec3 vForcePos = body.vPos;\n        vec3 vForce = vec3(0.0, debugTorqueMag, 0.0);\n\t\tvForcePos.x += 2.0;\n        BodyApplyForce( body, vForcePos, vForce );\n\t\t\/\/vForcePos.x -= 4.0;\n        \/\/vForce = -vForce;\n        \/\/BodyApplyForce( body, vForcePos, vForce );\n    }        \n}\n\nvoid BodyCollideShapeSphere( inout Body body, vec3 vSphereOrigin, float fSphereRadius, float dT )\n{    \n    vec3 vSphereWorld = ObjToWorld( vSphereOrigin, body.mRot) + body.vPos;\n    \n    ClosestSurface closest = GetSceneClosestSurface( vSphereWorld );\n    \n    float fDepth = fSphereRadius - closest.fDist;\n    \n    if ( fDepth < 0.0 )\n        return;\n    \n    vec3 vNormal = GetSceneNormal( vSphereWorld );\n    vec3 vHitPos = vSphereWorld - vNormal * closest.fDist;    \n    vec3 vPointVel = BodyPointVelocity( body, vHitPos );\n    \n    float fDot = dot( vPointVel, vNormal );\n    \n    if( fDot >= 0.0 )\n        return;\n    \n    float fRestitution = 0.1;\n    \n    float fRcpEffectivepMass = (1.0\/body.fMass );\n    float fCr = length(cross( vNormal, vHitPos - body.vPos ));\n    fRcpEffectivepMass += fCr * fCr \/ body.fIT;\n    \n    float fImpulse = -((1.0 + fRestitution) * fDot) \/ fRcpEffectivepMass;\n    \n    fImpulse += fDepth \/ fRcpEffectivepMass;\n    \n    BodyApplyImpulse( body, vHitPos, vNormal * fImpulse );\n    \n    vec3 vFriction = Vec3Perp( vPointVel, vNormal ) * body.fMass;\n    float fLimit = 100000.0;\n    float fMag = length(vFriction);\n    if( fMag > 0.0 )\n    {\t        \n        vFriction = normalize( vFriction );\n    }\n    else\n    {\n        vFriction = vec3(0.0);\n    }\n    fMag = min( fMag, fLimit );\n    vFriction = vFriction * fMag;\n\n    BodyApplyForce( body, vHitPos, vFriction );\n}\n    \nvoid BodyCollide( inout Body body, float dT )\n{\n    vec4 vSpheres[6];\n    vSpheres[0] = vec4(0.7, 0.7, 1.5, 0.5 );\n    vSpheres[1] = vec4(-0.7, 0.7, 1.5, 0.5 );\n    vSpheres[2] = vec4(0.7, 0.7, -1.5, 0.5 );\n    vSpheres[3] = vec4(-0.7, 0.7, -1.5, 0.5 );\n    vSpheres[4] = vec4(0.5, 1.0, 0.0, 0.7 );\n    vSpheres[5] = vec4(-0.5, 1.0, 0.0, 0.7 );   \n    \n    for( int s=0; s<6; s++ )\n    {\n\t    BodyCollideShapeSphere( body, vSpheres[s].xyz, vSpheres[s].w, dT );\n    }\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nstruct Engine\n{\n    float fAngularMomentum;\n};\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nstruct Wheel\n{\n    \/\/ Persistent State\n    float fSteer;\n    float fRotation;\n    float fExtension;\n    float fAngularVelocity;\n    \n    \/\/ Results\n    vec2 vContactPos;\n    float fOnGround;\n    float fSkid;    \n    \n    \/\/ Constant\n\tvec3 vBodyPos;    \n    float fRadius;\n    bool bIsDriven;\n    bool bSteering;   \n};\n    \nvoid WheelLoadState( out Wheel wheel, vec2 addr )\n{    \n    vec4 vState = LoadVec4( addr + offsetWheelState );\n    \n    wheel.fSteer = vState.x;\n    wheel.fRotation = vState.y;\n    wheel.fExtension = vState.z;\n    wheel.fAngularVelocity = vState.w;\n    \n    \/\/ output data\n    wheel.vContactPos = vec2( 0.0 );\n    wheel.fOnGround = 0.0;\n    wheel.fSkid = 0.0;\n}\n    \nvoid WheelStoreState( vec2 addr, const in Wheel wheel, inout vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 vState = vec4( wheel.fSteer, wheel.fRotation, wheel.fExtension, wheel.fAngularVelocity );\n    StoreVec4( addr + offsetWheelState, vState, fragColor, fragCoord );\n\n    vec4 vState2 = vec4( wheel.vContactPos.xy, wheel.fOnGround, wheel.fSkid );\n    StoreVec4( addr + offsetWheelContactState , vState2, fragColor, fragCoord );\n}\n\nC_Intersection WheelTrace( vec3 vPos, vec3 vDir, Wheel wheel )\n{\n    C_Intersection intersection;\n\tTraceScene( intersection, vPos - vDir * wheel.fRadius, vDir );\n    \n    return intersection;\n}\n\n\nfloat ClampTyreForce( inout vec3 vVel, float fLimit )\n{\n    \/\/ Square clamp\n    \/\/vVelWheel.x = clamp( vVelWheel.x, -fLimit, fLimit);\n    \/\/vVelWheel.z = clamp( vVelWheel.z, -fLimit, fLimit);\n\tfloat fSkid = 0.0;\n    \n    \/\/ Circluar clamp\n    float fMag = length(vVel);\n    if( fMag > 0.0 )\n    {\t        \n        vVel = normalize( vVel );\n    }\n    else\n    {\n        vVel = vec3(0.0);\n    }\n    if ( fMag > fLimit )\n    {\n        fSkid = fMag - fLimit;\n\t    fMag = fLimit;        \n    }\n    vVel = vVel * fMag;\n    \n    return fSkid;\n}\n\nvoid WheelUpdate( inout Engine engine, inout Body body, inout Wheel wheel, float dT )\n{\n    vec3 vWheelWorld = ObjToWorld( wheel.vBodyPos, body.mRot) + body.vPos;\n    vec3 vWheelDown = ObjToWorld( vec3(0.0, -1.0, 0.0), body.mRot);\n    \n    float fSuspensionTravel = 0.25;\n    C_Intersection intersection = WheelTrace( vWheelWorld, vWheelDown, wheel );\n    \n    float fTravel = clamp( intersection.fDist - wheel.fRadius, 0.0, fSuspensionTravel);\n        \n    \/\/ Apply suspension force\n    \/\/ Simple spring-damper\n    \/\/ (No anti-roll bar)\n    float fWheelExt = fTravel \/ fSuspensionTravel;\n\n    wheel.fOnGround = 1.0 - fWheelExt;\n    \n    float delta = (wheel.fExtension - fTravel) \/ fSuspensionTravel;\n\n    float fForce = (1.0 - fWheelExt) * 5000.0 + delta * 15000.0;\n\n    vec3 vForce = Vec3Perp( intersection.vNormal, vWheelDown) * fForce;\n    BodyApplyForce( body, vWheelWorld, vForce );                \n\n    \/\/ Apply Tyre force\n\n    \/\/ Super simplification of wheel \/ drivetrain \/ engine \/ tyre contact\n    \/\/ ignoring engine \/ wheel angular momentum       \n\n    \/\/ Figure out how contact patch is moving in world space\n    vec3 vIntersectWorld = intersection.vPos;\n    wheel.vContactPos = vIntersectWorld.xz;\n    vec3 vVelWorld = BodyPointVelocity( body, vIntersectWorld );\n\n    \/\/ Transform to body space\n    vec3 vVelBody = WorldToObj( vVelWorld, body.mRot );\n\n    \/\/ Transform to wheel space\n    vec3 vVelWheel = RotY( vVelBody, wheel.fSteer );\n\n    float fWScale = wheel.fRadius;\n\n    float fWheelMOI = 20.0;\n    if ( wheel.bIsDriven )\n    {\n        fWheelMOI = 30.0;\n\n        \/\/ consta-torque mega engine\n        if( KeyIsPressed( KEY_W ) )\n        {\n            wheel.fAngularVelocity += 2.0;\n        }        \n\n        if( KeyIsPressed( KEY_S ) )\n        {\n            wheel.fAngularVelocity -= 2.0;\n        }        \n    }\n\n    if( KeyIsPressed( KEY_SPACE ) )\n    {\n        wheel.fAngularVelocity = 0.0; \/\/ insta-grip super brake\n    }        \n\n    vVelWheel.z -= wheel.fAngularVelocity * fWScale;\n\n    vec3 vForceWheel = vVelWheel * body.fMass;\n\n    \/\/ Hacked 'slip angle'\n    \/\/vForceWheel.x \/=  1.0 + abs(wheel.fAngularVelocity * fWScale) * 0.1;\n\n    float fLimit = 9000.0 * (1.0 - fWheelExt);\n\n    wheel.fSkid = ClampTyreForce( vForceWheel, fLimit );    \n    \n    \/\/vVelWheel.z += wheel.fAngularVelocity * fWScale;\n    vec3 vForceBody = RotY( vForceWheel, -wheel.fSteer );\n\n    \/\/ Apply force back on wheel\n\n    wheel.fAngularVelocity += ((vForceWheel.z \/ fWScale) \/ fWheelMOI) * dT;\n\n    vec3 vForceWorld = ObjToWorld( vForceBody, body.mRot );\n\n    \/\/ cancel in normal dir\n    vForceWorld = Vec3Parallel( vForceWorld, intersection.vNormal );\n\n    BodyApplyForce( body, vIntersectWorld, -vForceWorld );        \n\n    wheel.fExtension = fTravel;\n    wheel.fRotation += wheel.fAngularVelocity * dT;    \n}\n\nvoid WheelUpdateSteerAngle( float fSteerAngle, inout Wheel wheel )\n{\n    if ( !wheel.bSteering )\n    {\n        wheel.fSteer = 0.0;\n    }\n    else\n    {\n        \/\/ figure out turning circle if wheel was central\n        float turningCircle = wheel.vBodyPos.z \/ tan( fSteerAngle );\n        float wheelTurningCircle = turningCircle - wheel.vBodyPos.x;\n        wheel.fSteer = atan( abs(wheel.vBodyPos.z) \/ wheelTurningCircle);\n    }\n}\n\nstruct Vechicle\n{\n    Body body;    \n    Engine engine;\n    Wheel wheel[4];\n    \n    float fSteerAngle;\n};\n\nvoid VehicleLoadState( out Vechicle vehicle, vec2 addr )\n{    \n    BodyLoadState( vehicle.body, addr + offsetVehicleBody );\n    WheelLoadState( vehicle.wheel[0], addr + offsetVehicleWheel0 );\n    WheelLoadState( vehicle.wheel[1], addr + offsetVehicleWheel1 );\n    WheelLoadState( vehicle.wheel[2], addr + offsetVehicleWheel2 );\n    WheelLoadState( vehicle.wheel[3], addr + offsetVehicleWheel3 );\n    \n    vec4 vParam0;\n    vParam0 = LoadVec4( addr + offsetVehicleParam0 );\n    vehicle.fSteerAngle = vParam0.x;\n}\n\nvoid VehicleStoreState( vec2 addr, const in Vechicle vehicle, inout vec4 fragColor, in vec2 fragCoord )\n{\n    BodyStoreState( addr + offsetVehicleBody, vehicle.body, fragColor, fragCoord );\n    WheelStoreState( addr + offsetVehicleWheel0, vehicle.wheel[0], fragColor, fragCoord );\n    WheelStoreState( addr + offsetVehicleWheel1, vehicle.wheel[1], fragColor, fragCoord );\n    WheelStoreState( addr + offsetVehicleWheel2, vehicle.wheel[2], fragColor, fragCoord );\n    WheelStoreState( addr + offsetVehicleWheel3, vehicle.wheel[3], fragColor, fragCoord );\n\n    vec4 vParam0 = vec4( vehicle.fSteerAngle, 0.0, 0.0, 0.0 );\n    StoreVec4( addr + offsetVehicleParam0, vParam0, fragColor, fragCoord);\n}\n\nvoid VehicleResetForFrame( inout Vechicle vehicle )\n{\n    BodyResetForFrame( vehicle.body );\n}\n\nvoid VehicleSetup( inout Vechicle vehicle )\n{\n    vehicle.body.fMass = 1000.0;\n    vehicle.body.fIT = 1000.0;\n\n    vehicle.engine.fAngularMomentum = 0.0; \/\/ TODO : Move to state\n    \n    vehicle.wheel[0].vBodyPos = vec3( -0.9, -0.1, 1.25 );\n    vehicle.wheel[1].vBodyPos = vec3(  0.9, -0.1, 1.25 );\n    vehicle.wheel[2].vBodyPos = vec3( -0.9, -0.1, -1.25 );\n    vehicle.wheel[3].vBodyPos = vec3(  0.9, -0.1, -1.25 );\n    \n    vehicle.wheel[0].fRadius = 0.45;\n    vehicle.wheel[1].fRadius = 0.45;\n    vehicle.wheel[2].fRadius = 0.45;\n    vehicle.wheel[3].fRadius = 0.45; \n    \n    vehicle.wheel[0].bIsDriven = false;\n    vehicle.wheel[1].bIsDriven = false;\n    vehicle.wheel[2].bIsDriven = true;\n    vehicle.wheel[3].bIsDriven = true;    \n    \n    vehicle.wheel[0].bSteering = true;\n    vehicle.wheel[1].bSteering = true;\n    vehicle.wheel[2].bSteering = false;\n    vehicle.wheel[3].bSteering = false;   \n}\n\n\nstruct Camera\n{\n    vec3 vPos;\n    vec3 vTarget;\n};\n\nvoid CameraLoadState( out Camera cam, in vec2 addr )\n{\n\tcam.vPos = LoadVec3( addr + offsetCameraPos );\n\tcam.vTarget = LoadVec3( addr + offsetCameraTarget );\n}\n\nvoid CameraStoreState( Camera cam, in vec2 addr, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec3( addr + offsetCameraPos, cam.vPos, fragColor, fragCoord );\n    StoreVec3( addr + offsetCameraTarget, cam.vTarget, fragColor, fragCoord );    \n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if ( fragCoord.x > 13.0 ) discard;\n    if ( fragCoord.y > 3.0 ) discard;\n    \n    Vechicle vehicle;\n    \n    VehicleLoadState( vehicle, addrVehicle );\n    VehicleSetup( vehicle );\n    VehicleResetForFrame( vehicle );\n\n    if ( iFrame < 1 )\n    {        \n        vehicle.body.vPos = vec3( 0.0, -2.5, 0.0 );\n        vehicle.body.vMomentum = vec3( 0.0 );\n        vehicle.body.qRot = vec4( 0.0, 0.0, 0.0, 1.0 );\n        vehicle.body.vAngularMomentum = vec3( 0.0, 0.5, 0.0 );        \n        \n        vehicle.fSteerAngle = 0.0;\n    }\n\n    BodyCalculateDerivedState( vehicle.body );\n    \n    \/\/ TODO: dT for steering\n    if ( KeyIsPressed( KEY_A ) )\n    {\n        vehicle.fSteerAngle += 0.05;\n    }    \n    if ( KeyIsPressed( KEY_D ) )\n    {\n        vehicle.fSteerAngle -= 0.05;\n    }    \n    \n    vehicle.fSteerAngle *= 0.9;\n    \n    float fSteerAngle = vehicle.fSteerAngle \/ ( 1.0 + length(vehicle.body.vMomentum) * 0.0001 );\n    \n    for( int w=0; w<4; w++ )\n    {\n\t    WheelUpdateSteerAngle( fSteerAngle, vehicle.wheel[w] );\n    }\n    \n    float dT = 1.0 \/ 60.0;\n\n\tif ( !KeyIsToggled( KEY_V ) )\n    {\n\t    for( int w=0; w<4; w++ )\n    \t{\n        \tWheelUpdate( vehicle.engine, vehicle.body, vehicle.wheel[w], dT );\n        }\n    }\n    \n\tBodyApplyDebugForces( vehicle.body );\n    BodyCollide( vehicle.body, dT );\n    BodyIntegrate( vehicle.body, dT );\n\n    fragColor = vec4( 0.0 );\n    \n    VehicleStoreState( addrVehicle, vehicle, fragColor, fragCoord );\n    \n  \n    Camera prevCam;\n    \n    \/\/ load old camera data\n    CameraLoadState( prevCam, addrCamera );\n\n    \/\/ store in addrPrevCamera\n    CameraStoreState( prevCam, addrPrevCamera, fragColor, fragCoord );\n    \n    Camera cam;\n    \n\tvec2 vMouse = iMouse.xy \/ iResolution.xy;\n\tfloat fAngle = (-vMouse.x * 2.0 + 1.0) * 3.14;\n   \tfloat fDistance = 8.0 - vMouse.y * 6.0;\n    \n    cam.vTarget = vec3( 0.0, 1.0, 0.0 ) * vehicle.body.mRot + vehicle.body.vPos;\n    cam.vPos = vec3( 0.0, 0.0, -fDistance ) * vehicle.body.mRot + vehicle.body.vPos + vec3(0.0, 2.0, 0.0);\n    \n    cam.vPos -= cam.vTarget;\n    cam.vPos = RotY( cam.vPos, fAngle );\n    cam.vPos += cam.vTarget;\n            \n    CameraStoreState( cam, addrCamera, fragColor, fragCoord );\n}","name":"","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Tyre track buffer rendering shader\n\nvec2 addrVehicle = vec2( 0.0, 0.0 );\n\nvec2 offsetVehicleParam0 = vec2( 0.0, 0.0 );\n\nvec2 offsetVehicleBody = vec2( 1.0, 0.0 );\nvec2 offsetBodyPos = vec2( 0.0, 0.0 );\nvec2 offsetBodyRot = vec2( 1.0, 0.0 );\nvec2 offsetBodyMom = vec2( 2.0, 0.0 );\nvec2 offsetBodyAngMom = vec2( 3.0, 0.0 );\n\nvec2 offsetVehicleWheel0 = vec2( 5.0, 0.0 );\nvec2 offsetVehicleWheel1 = vec2( 7.0, 0.0 );\nvec2 offsetVehicleWheel2 = vec2( 9.0, 0.0 );\nvec2 offsetVehicleWheel3 = vec2( 11.0, 0.0 );\n\nvec2 offsetWheelState = vec2( 0.0, 0.0 );\nvec2 offsetWheelContactState = vec2( 1.0, 0.0 );\n\nvec2 addrCamera = vec2( 0.0, 1.0 );\nvec2 offsetCameraPos = vec2( 0.0, 0.0 );\nvec2 offsetCameraTarget = vec2( 1.0, 0.0 );\n\nvec2 addrPrevCamera = vec2( 0.0, 2.0 );\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Storage\n\nvec4 LoadVec4( in vec2 vAddr )\n{\n    vec2 vUV = (vAddr + 0.5) \/ iChannelResolution[0].xy;\n    return texture2D( iChannel0, vUV, -100.0 );\n}\n\nvec3 LoadVec3( in vec2 vAddr )\n{\n    return LoadVec4( vAddr ).xyz;\n}\n\nfloat IsInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\n\nvoid StoreVec4( in vec2 vAddr, in vec4 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( IsInside( fragCoord, vAddr ) > 0.0 ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in vec2 vAddr, in vec3 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n\n\nstruct Camera\n{\n    vec3 vPos;\n    vec3 vTarget;\n};\n\nvoid CameraLoadState( out Camera cam, in vec2 addr )\n{\n\tcam.vPos = LoadVec3( addr + offsetCameraPos );\n\tcam.vTarget = LoadVec3( addr + offsetCameraTarget );\n}\n\n\n\n\nvoid UpdateTyreTracks( vec3 vCamPosPrev, vec3 vCamPos, inout vec4 fragColor, in vec2 fragCoord )\n{\n    float fRange = 20.0;\n    vec2 vPrevOrigin = floor( vCamPosPrev.xz );\n    vec2 vCurrOrigin = floor( vCamPos.xz );\n\n    vec2 vFragOffset = ((fragCoord \/ iResolution.xy) * 2.0 - 1.0) * fRange;\n    vec2 vFragWorldPos = vFragOffset + vCurrOrigin;\n\t\n    vec2 vPrevFragOffset = vFragWorldPos - vPrevOrigin;\n\tvec2 vPrevUV = ( (vPrevFragOffset \/ fRange) + 1.0 ) \/ 2.0;\n    vec4 vPrevSample = texture2D( iChannel1, vPrevUV );\n    \n    vec4 vWheelContactState[4];\n    vWheelContactState[0] = LoadVec4( addrVehicle + offsetVehicleWheel0 + offsetWheelContactState );\n    vWheelContactState[1] = LoadVec4( addrVehicle + offsetVehicleWheel1 + offsetWheelContactState );\n    vWheelContactState[2] = LoadVec4( addrVehicle + offsetVehicleWheel2 + offsetWheelContactState );\n    vWheelContactState[3] = LoadVec4( addrVehicle + offsetVehicleWheel3 + offsetWheelContactState );\n    \n    fragColor = vPrevSample;\n    \n    if ( vPrevUV.x < 0.0 || vPrevUV.x >= 1.0 || vPrevUV.y < 0.0 || vPrevUV.y >= 1.0 )\n    {\n        fragColor = vec4(0.0);\n    }\n    \n    for ( int w=0; w<4; w++ )\n    {        \n        vec2 vContactPos = vWheelContactState[w].xy;\n        \n        float fDist = length( vFragWorldPos - vContactPos );\n        \n        if ( vWheelContactState[w].z > 0.01 )\n        {\n            float fAmount = smoothstep( 0.25, 0.1, fDist );\n            fragColor.x = max(fragColor.x, fAmount * vWheelContactState[w].z );\n            \n            fragColor.y = max(fragColor.y, fAmount * vWheelContactState[w].w * 0.01);\n        }\t\t\n    }\n    \n    \n    fragColor.x = clamp( fragColor.x, 0.0, 1.0);\n    fragColor.y = clamp( fragColor.y, 0.0, 1.0);\n    \n    if( iFrame < 1 )\n    {\n    \tfragColor.x = 0.0;  \n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0, 0.0, 1.0);\n    \n    Camera cam;\n    CameraLoadState( cam, addrCamera );\n\n    Camera prevCam;    \n    CameraLoadState( prevCam, addrPrevCamera );\n    \n    UpdateTyreTracks( prevCam.vPos, cam.vPos, fragColor, fragCoord );        \n}","name":"","description":"","type":"buffer"},{"inputs":[{"id":6,"src":"\/presets\/tex05.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":45,"src":"\/presets\/tex17.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Shader Rally - @P_Malin\n\n\/\/ Main HDR scene shader\n\n\/\/ Uncomment the next line to speed things up a bit\n\/\/#define FAST_VERSION\n\/\/#define SHOW_PHYSICS_SHAPE\n\n#define RAYTRACE_COUNT 2\n\nvec2 addrVehicle = vec2( 0.0, 0.0 );\n\nvec2 offsetVehicleParam0 = vec2( 0.0, 0.0 );\n\nvec2 offsetVehicleBody = vec2( 1.0, 0.0 );\nvec2 offsetBodyPos = vec2( 0.0, 0.0 );\nvec2 offsetBodyRot = vec2( 1.0, 0.0 );\nvec2 offsetBodyMom = vec2( 2.0, 0.0 );\nvec2 offsetBodyAngMom = vec2( 3.0, 0.0 );\n\nvec2 offsetVehicleWheel0 = vec2( 5.0, 0.0 );\nvec2 offsetVehicleWheel1 = vec2( 7.0, 0.0 );\nvec2 offsetVehicleWheel2 = vec2( 9.0, 0.0 );\nvec2 offsetVehicleWheel3 = vec2( 11.0, 0.0 );\n\nvec2 offsetWheelState = vec2( 0.0, 0.0 );\nvec2 offsetWheelContactState = vec2( 1.0, 0.0 );\n\nvec2 addrCamera = vec2( 0.0, 1.0 );\nvec2 offsetCameraPos = vec2( 0.0, 0.0 );\nvec2 offsetCameraTarget = vec2( 1.0, 0.0 );\n\nvec2 addrPrevCamera = vec2( 0.0, 2.0 );\n\nvec4 LoadVec4( in vec2 vAddr )\n{\n    vec2 vUV = (vAddr + 0.5) \/ iChannelResolution[0].xy;\n    return texture2D( iChannel0, vUV, -100.0 );\n}\n\nvec3 LoadVec3( in vec2 vAddr )\n{\n    return LoadVec4( vAddr ).xyz;\n}\n\nmat3 QuatToMat3( const in vec4 q )\n{\n\tvec4 qSq = q * q;\n\tfloat xy2 = q.x * q.y * 2.0;\n\tfloat xz2 = q.x * q.z * 2.0;\n\tfloat yz2 = q.y * q.z * 2.0;\n\tfloat wx2 = q.w * q.x * 2.0;\n\tfloat wy2 = q.w * q.y * 2.0;\n\tfloat wz2 = q.w * q.z * 2.0;\n \n\treturn mat3 (\t\n     qSq.w + qSq.x - qSq.y - qSq.z, xy2 - wz2, xz2 + wy2,\n     xy2 + wz2, qSq.w - qSq.x + qSq.y - qSq.z, yz2 - wx2,\n     xz2 - wy2, yz2 + wx2, qSq.w - qSq.x - qSq.y + qSq.z );\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Rotation\n\nvec2 Rotate( const in vec2 vPos, const in float t )\n{\n    float s = sin(t);\n    float c = cos(t);\n    \n    return vec2( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y);\n}\n\nvec2 Rotate( const in vec2 vPos, const in vec2 sc )\n{\n    return vec2( sc.y * vPos.x + sc.x * vPos.y, -sc.x * vPos.x + sc.y * vPos.y);\n}\n\nvec3 RotX( const in vec3 vPos, float t )\n{\n    vec3 result;\n    result.x = vPos.x;\n  \tresult.yz = Rotate( vPos.yz, t );\n    return result;\n}\n\nvec3 RotY( const in vec3 vPos, float t )\n{\n    vec3 result;\n    result.y = vPos.y;\n  \tresult.xz = Rotate( vPos.xz, t );\n    return result;\n}\n\nvec3 RotZ( const in vec3 vPos, float t )\n{\n    vec3 result;\n    result.z = vPos.z;\n  \tresult.xy = Rotate( vPos.xy, t );\n    return result;\n}\n\nvec3 RotX( const in vec3 vPos, vec2 sc )\n{\n    vec3 result;\n    result.x = vPos.x;\n  \tresult.yz = Rotate( vPos.yz, sc );\n    return result;\n}\n\nvec3 RotY( const in vec3 vPos, vec2 sc )\n{\n    vec3 result;\n    result.y = vPos.y;\n  \tresult.xz = Rotate( vPos.xz, sc );\n    return result;\n}\n\nvec3 RotZ( const in vec3 vPos, vec2 sc )\n{\n    vec3 result;\n    result.z = vPos.z;\n  \tresult.xy = Rotate( vPos.xy, sc );\n    return result;\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\n\n\nfloat kFarClip=1000.0;\n\nvec2 GetWindowCoord( const in vec2 vUV );\nvec2 GetUVFromWindowCoord( const in vec2 vWindow );\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget );\nvec2 GetCameraWindowCoord(const in vec3 vWorldPos, const in vec3 vCameraPos, const in vec3 vCameraTarget);\nvec3 GetSceneColour( in vec3 vRayOrigin,  in vec3 vRayDir, out float fDepth );\nvec3 ApplyPostFX( const in vec2 vUV, const in vec3 vInput );\n\nvec2 g_TyreTrackOrigin;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vUV = fragCoord.xy \/ iResolution.xy;\n\n\tvec3 vCameraPos = LoadVec3( addrCamera + offsetCameraPos );\n\tvec3 vCameraTarget = LoadVec3( addrCamera + offsetCameraTarget );\n    \n    g_TyreTrackOrigin = floor(vCameraPos.xz);\n    \n\tvec3 vRayOrigin = vCameraPos;\n\tvec3 vRayDir = GetCameraRayDir( GetWindowCoord(vUV), vCameraPos, vCameraTarget );\n\t\n    float fDepth;\n\tvec3 vResult = GetSceneColour(vRayOrigin, vRayDir, fDepth);\n    vResult = max( vResult, vec3(0.0));\n\t    \n\tfragColor = vec4(vResult, fDepth);\n}\n\n\/\/ CAMERA\n\nvec2 GetWindowCoord( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x \/ iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvec2 GetUVFromWindowCoord( const in vec2 vWindow )\n{\n\tvec2 vScaledWindow = vWindow;\n    vScaledWindow.x *= iResolution.y \/ iResolution.x;\n    \n\t return vScaledWindow * 0.5 + 0.5;\n}\n\n\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget )\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\t\t\t\t\t\t  \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * 2.0);\n\n\treturn vDir;\n}\n\nvec2 GetCameraWindowCoord(const in vec3 vWorldPos, const in vec3 vCameraPos, const in vec3 vCameraTarget)\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\n    vec3 vOffset = vWorldPos - vCameraPos;\n    vec3 vCameraLocal;\n    vCameraLocal.x = dot(vOffset, vRight);\n    vCameraLocal.y = dot(vOffset, vUp);\n    vCameraLocal.z = dot(vOffset, vForward);\n\n    vec2 vWindowPos = vCameraLocal.xy \/ (vCameraLocal.z \/ 2.0);\n    \n    return vWindowPos;\n}\n\n\/\/ RAYTRACE\n\nstruct SurfaceInfo\n{\n    vec3 vUVW;\n    float fId;\n};\n\nstruct ClosestSurface\n{\n    float fDist;\n    SurfaceInfo surface;\n};\n    \nvoid ClosestSurfaceInit( inout ClosestSurface closest, float fId, vec3 vUVW )\n{\n    closest.fDist = kFarClip;\n    closest.surface.vUVW = vUVW;\n    closest.surface.fId = fId;\n}\n\n\nClosestSurface ClosestSurfaceUnion( const in ClosestSurface a, const in ClosestSurface b )\n{\n    if ( a.fDist < b.fDist )\n    {\n        return a;\n    }\n\n    return b;        \n}\n    \nstruct C_Intersection\n{\n\tvec3 vPos;\n\tfloat fDist;\t\n\tvec3 vNormal;\n    SurfaceInfo surface;\n};\n\nvec2 Segment( vec3 vPos, vec3 vP0, vec3 vP1 )\n{\n\tvec3 pa = vPos - vP0;\n\tvec3 ba = vP1 - vP0;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn vec2( length( pa - ba*h ), h );\n}\n\nfloat SdCapsule( vec3 vPos, vec3 vP0, vec3 vP1, float r0, float r1 )\n{\n    vec2 vC = Segment( vPos, vP0, vP1 );\n    \n    return vC.x - mix(r0, r1, vC.y);\n}\n\nfloat SdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat SdSphere( vec3 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat UdRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)\/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Scene State\n\nstruct VehicleState\n{\n    vec3 vPos;\n    \n    vec4 qRot;\n    mat3 mRot;\n    \n\tvec4 vWheelState0;\n\tvec4 vWheelState1;\n\tvec4 vWheelState2;\n\tvec4 vWheelState3;\n    \n    vec4 vWheelSC0;\n    vec4 vWheelSC1;\n    vec4 vWheelSC2;\n    vec4 vWheelSC3;\n};\n\nstruct SceneState\n{\n    VehicleState vehicleState;\n};\n    \nSceneState SetupSceneState()\n{\n    SceneState sceneState;\n    \n    sceneState.vehicleState.vPos = LoadVec3( addrVehicle + offsetVehicleBody + offsetBodyPos );\n    \n    sceneState.vehicleState.qRot = LoadVec4( addrVehicle + offsetVehicleBody + offsetBodyRot );\n    sceneState.vehicleState.mRot = QuatToMat3( sceneState.vehicleState.qRot );\n\n    vec4 vWheelState0 = LoadVec4( addrVehicle + offsetVehicleWheel0 );\n    vec4 vWheelState1 = LoadVec4( addrVehicle + offsetVehicleWheel1 );\n    vec4 vWheelState2 = LoadVec4( addrVehicle + offsetVehicleWheel2 );\n    vec4 vWheelState3 = LoadVec4( addrVehicle + offsetVehicleWheel3 );\n    \n    sceneState.vehicleState.vWheelState0 = vWheelState0;\n    sceneState.vehicleState.vWheelState1 = vWheelState1;\n    sceneState.vehicleState.vWheelState2 = vWheelState2;\n    sceneState.vehicleState.vWheelState3 = vWheelState3;\n    \n    sceneState.vehicleState.vWheelSC0 = vec4( sin(vWheelState0.x), cos(vWheelState0.x), sin(vWheelState0.y), cos(vWheelState0.y) );\n    sceneState.vehicleState.vWheelSC1 = vec4( sin(vWheelState1.x), cos(vWheelState1.x), sin(vWheelState1.y), cos(vWheelState1.y) );\n    sceneState.vehicleState.vWheelSC2 = vec4( sin(vWheelState2.x), cos(vWheelState2.x), sin(vWheelState2.y), cos(vWheelState2.y) );\n    sceneState.vehicleState.vWheelSC3 = vec4( sin(vWheelState3.x), cos(vWheelState3.x), sin(vWheelState3.y), cos(vWheelState3.y) );\n    \n    return sceneState;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Random\n\n#define MOD2 vec2(4.438975,3.972973)\n#define MOD3 vec3(.1031,.11369,.13787)\n#define MOD4 vec4(.1031,.11369,.13787, .09987)\n\nfloat Hash( float p ) \n{\n    \/\/ https:\/\/www.shadertoy.com\/view\/4djSRW - Dave Hoskins\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);    \n}\n\nvec3 Hash31(float p)\n{\n    \/\/ https:\/\/www.shadertoy.com\/view\/4djSRW - Dave Hoskins\n   vec3 p3 = fract(vec3(p) * MOD3);\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat SmoothNoise(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = Hash(n+  0.0);\n\tfloat b = Hash(n+  1.0);\n\tfloat c = Hash(n+ 57.0);\n\tfloat d = Hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n    return res;\n}\n\nfloat FBM( vec2 p, float ps ) {\n\tfloat f = 0.0;\n    float tot = 0.0;\n    float a = 1.0;\n#ifndef FAST_VERSION\n    for( int i=0; i<3; i++)\n#endif\n    {\n        f += SmoothNoise( p ) * a;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f \/ tot;\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Scene\n\n#define MAT_TERRAIN 1.0\n#define MAT_WOOD 2.0\n\n#define MAT_CAR_BODY 3.0\n#define MAT_CHROME 4.0\n#define MAT_GRILL 5.0\n#define MAT_BLACK_PLASTIC 5.0\n#define MAT_AXLE 5.0\n#define MAT_REAR 5.0\n#define MAT_WHEEL 6.0    \n#define MAT_SUSPENSION 7.0\n\n\/\/ Motion blur mask\n#define MAT_FIRST_VEHICLE MAT_CAR_BODY\n\nfloat GetTerrainDistance( const vec3 vPos )\n{    \n    float fbm = FBM( vPos.xz * vec2(0.5, 1.0), 0.5 );\n    float fTerrainHeight = fbm * fbm;\n    fTerrainHeight = fTerrainHeight * (sin(vPos.x * 0.1) + 1.0) * 0.5 + vPos.y + 3.0;    \n    \n    \/\/float h = 1.0 - exp(-abs(vPos.x + 15.0) * 0.01);\n    \n    \/\/fTerrainHeight += sin(vPos.x * 0.05) * 5.0 * h;\n    \/\/fTerrainHeight += sin(vPos.z * 0.05) * 5.0 * h;\n    \n    #ifndef FAST_VERSION\n    {\n\t\t\/\/ Apply Tyre Track to Terrain\n        float fRange = 20.0;\n        vec2 vPrevFragOffset = vPos.xz - g_TyreTrackOrigin;\n        vec2 vPrevUV = ( (vPrevFragOffset \/ fRange) + 1.0 ) \/ 2.0;\n\n        vec4 vTrackSample = texture2D( iChannel3, vPrevUV );\n        float fDepth = vTrackSample.x * (1.0 + vTrackSample.y);\n        \n        fTerrainHeight += fDepth * 0.05;        \n    }\n\t#endif\n    \n\treturn fTerrainHeight;\n}\n\nClosestSurface GetRampClosestSurface( const vec3 vPos, const float fRampSeed )\n{\n    ClosestSurface closest;\n    \n    vec3 vHash = Hash31( fRampSeed );\n    \n    closest.surface.fId = MAT_WOOD;\n    closest.surface.vUVW = vPos.xyz;\n    \n    float fHeight = 2.0 + vHash.x * 6.0;\n    float fRadius = 10.0 + vHash.y * 20.0;\n    float fLedge = 2.0 + vHash.z * 3.0;\n        \n    float h2 = fRadius - fHeight;\n    float fLength = sqrt(fRadius * fRadius - h2 * h2);\n    fLength = fLength + fLedge;\n    closest.fDist = sdBox( vPos - vec3( 0.0, fHeight * 0.5, fLength * 0.5 ), vec3(3.0, fHeight * 0.5, fLength * 0.5));\n    \n\n    vec3 vCylDomain = vPos - vec3( 0.0, fRadius, 0.0 );\n    float fCylDist = length(vCylDomain.yz) - fRadius;\n    \n    \/\/closest.fDist = fCylDist;\n    \n    if ( -fCylDist > closest.fDist )\n    {\n        closest.fDist = -fCylDist;\n        closest.surface.fId = MAT_WOOD;\n    }\n    \/\/closest.fDist = max( closest.fDist, -fCylDist);\n    \n    return closest;\n}\n\nClosestSurface GetEnvironmentClosestSurface( const vec3 vPos )\n{\n    ClosestSurface terrainClosest;\n    terrainClosest.surface.fId = MAT_TERRAIN;\n    terrainClosest.surface.vUVW = vec3(vPos.xz,0.0);\n    terrainClosest.fDist = GetTerrainDistance( vPos );\n#ifdef FAST_VERSION\n    return terrainClosest;\n#else\n    float fRepeat = 100.0;\n    vec3 vRampDomain = vPos - vec3(-15.0, -3.0, 0.0);\n    float fRampUnitZ = vRampDomain.z \/ fRepeat + 0.5;\n    float fRampSeed = floor( fRampUnitZ );\n    vRampDomain.z = (fract(fRampUnitZ) - 0.5) * fRepeat;\n    ClosestSurface rampClosest = GetRampClosestSurface( vRampDomain, fRampSeed );\n\n    return ClosestSurfaceUnion( terrainClosest, rampClosest );\n#endif\n}\n\nfloat PlaneDist( const in vec3 vPos, const in vec3 vNormal, float fDist )\n{\n    return dot(vNormal.xyz, vPos) - fDist;\n}\n\nfloat PlaneDist( const in vec3 vPos, const in vec4 vPlane )\n{\n    return PlaneDist(vPos, vPlane.xyz, vPlane.w);\n}\n\n\n\n\nfloat CarBodyMin( float a, float b, float k )\n{\n    return smin(a, b, k);\n}\n  \nfloat CarBodyMax( float a, float b, float k )\n{\n    return -CarBodyMin(-a, -b, k);\n}\n\nfloat WheelArchCombine( float a, float b )\n{\n    float size = 0.1;\n    float r= clamp( 1.0 - abs(b) \/ size, 0.0, 1.0);\n    a -= r * r * size;\n    \n    return CarBodyMax(a, b, 0.1);\n}\n\nfloat GetWheelArchDist( vec3 vPos )\n{\n    vPos.y = max( vPos.y, 0.0 );\n    return  0.45 - length( vec2( length( vPos.zy ), vPos.x ));\n    \/\/return  0.45 - length( vPos.zy );\n}\n\nvec4 GetPlaneCoeffs( vec3 a, vec3 b, vec3 c )\n{\n    vec3 n = normalize( cross(a-b, b-c) );\n    float d = -dot( n, a );\n    \n    return vec4( n, d );\n}\n\n\nClosestSurface GetCarBodyClosestSurface( const in vec3 vCarPos )\n{\n    ClosestSurface closest;\n    \n#ifdef SHOW_PHYSICS_SHAPE\n    vec4 vSpheres[6];\n    vSpheres[0] = vec4(0.7, 0.7, 1.5, 0.5 );\n    vSpheres[1] = vec4(-0.7, 0.7, 1.5, 0.5 );\n    vSpheres[2] = vec4(0.7, 0.7, -1.5, 0.5 );\n    vSpheres[3] = vec4(-0.7, 0.7, -1.5, 0.5 );\n    vSpheres[4] = vec4(0.5, 1.0, 0.0, 0.7 );\n    vSpheres[5] = vec4(-0.5, 1.0, 0.0, 0.7 );    \n\n\tclosest.surface.vUVW = vCarPos.xyz;\n    closest.surface.fId = MAT_CAR_BODY;\n    closest.fDist = kFarClip;\n    \n    for (int s=0; s<6; s++)\n    {\n        float d = length( vCarPos.xyz - vSpheres[s].xyz) - vSpheres[s].w;\n        \n        closest.fDist = min( closest.fDist, d );\n    }\n#else    \n    \n    vec3 vAbsBodyPos = vCarPos - vec3(0.0, 0.3, 0.0);\n\n    vec3 vBodyPos = vAbsBodyPos;\n    vBodyPos.x = abs(vBodyPos.x);\n\tclosest.surface.vUVW = vAbsBodyPos.xyz;\n    closest.surface.fId = MAT_CAR_BODY;\n   \n    \/\/closest.fDist = SdBox( vBodyPos - vec3(0.0, 0.5, 0.0), vec3(0.7, 0.2, 1.5)-0.2)  -0.2;\n    \n    vec3 vFrontWheelPos = -vec3( 0.0, -0.1, -1.25 ) ;\n    vec3 vRearWheelPos = -vec3( 0.0, -0.1, 1.25 ) ;\n\n    vec3 vWheelPos = vBodyPos - vFrontWheelPos;\n    \n    float fSeparation = (vFrontWheelPos.z - vRearWheelPos.z) * 0.5;\n    vWheelPos.z = abs(vWheelPos.z + fSeparation ) - fSeparation;\n    vWheelPos.x = abs(vWheelPos.x) - 0.8;\n    \n    float fWheelArchDist = GetWheelArchDist( vWheelPos );\n    \n\n    \n    float fBodyBaseDist = kFarClip;\n\n    {\n        float fTopDist = PlaneDist( vBodyPos, normalize(vec3(0.0, 1.0, 0.0)), 0.8 );\n        float fFrontDist = PlaneDist( vBodyPos, normalize(vec3(0.0, 0.2, 1.0)), 1.9 );    \n        float fSideDist = PlaneDist( vBodyPos, normalize(vec3(1.0, -0.1, 0.0)), 0.85 );\n        float fBaseDist = PlaneDist( vBodyPos, normalize(vec3(0.0, -1.0, 0.0)), -0.1 );\n        float fBackDist = PlaneDist( vBodyPos, normalize(vec3(0.0, 0.0, -1.0)), 2.0 );\n\n        float fX = abs(vBodyPos.x);\n        fTopDist += fX * fX * 0.05;\n        fFrontDist += fX * fX * 0.1;\n        \n        float fSmooth = 0.2;\n\n        float fFrontTopDist = CarBodyMax( fTopDist, fFrontDist, 0.2 );\n\n        fBodyBaseDist = fFrontTopDist;\n        fBodyBaseDist = CarBodyMax( fBodyBaseDist, fSideDist, 0.3 );\n\n        float fBaseBackDist = CarBodyMax( fBaseDist, fBackDist, 0.1 );\n        fBodyBaseDist = CarBodyMax( fBodyBaseDist, fBaseBackDist, 0.1 );\n    }\n\n    fBodyBaseDist = WheelArchCombine( fBodyBaseDist, fWheelArchDist );   \n            \n    float fBodyTopDist = kFarClip;\n\n    {\n        float fTopDist = PlaneDist( vBodyPos, normalize(vec3(0.0, 1.0, 0.0)), 1.3 );\n        float fFrontDist = PlaneDist( vBodyPos, normalize(vec3(0.0, 1.0, 0.7)), 1.1 );    \n        float fSideDist = PlaneDist( vBodyPos, normalize(vec3(1.0, 0.4, 0.0)), 1.03 );\n        float fBaseDist = PlaneDist( vBodyPos, normalize(vec3(0.0, -1.0, 0.0)), -0.7);\n        float fBackDist = PlaneDist( vBodyPos, normalize(vec3(0.0, 0.0, -1.0)), 0.55 );\n\n        float fX = abs(vBodyPos.x);\n        fTopDist += fX * fX * 0.1;\n        \n        float fFrontTopDist = CarBodyMax( fTopDist, fFrontDist, 0.1 );\n\n        fBodyTopDist = fFrontTopDist;\n        fBodyTopDist = CarBodyMax( fBodyTopDist, fSideDist, 0.1 );\n\n        float fBaseBackDist = CarBodyMax( fBaseDist, fBackDist, 0.1 );\n        fBodyTopDist = CarBodyMax( fBodyTopDist, fBaseBackDist, 0.1 );\n    }\n        \n    \/\/fBodyTopDist = SdBox( vBodyPos - vec3(0.0, 0.5, -0.5), vec3(0.7, 0.5, 1.0)-0.2)  -0.2;\n    \n    \/\/float fDistDome = SdSphere( vBodyPos - vec3(0.0, -0.5, -0.5), 2.0 );\n    \/\/float fDistBase = -vBodyPos.y;\n    \n    \/\/closest.fDist = max( fDistDome, fDistBase );\n    \n    closest.fDist = fBodyBaseDist;\n    \n    closest.fDist = smin( closest.fDist, fBodyTopDist, 0.1);\n    \n#ifndef FAST_VERSION    \n    float fRearSpace = SdBox( vBodyPos - vec3(0.0, 0.8, -1.3), vec3(0.7, 0.35, 0.65) - 0.05) - 0.05 ;\n    \n    fRearSpace = -min(-fRearSpace, -(fWheelArchDist + 0.02) );\n    \n    if( fRearSpace < -closest.fDist )\n    {\n        closest.fDist = -fRearSpace;\n        closest.surface.fId = MAT_REAR;\n    }\n    \n    \n   \tClosestSurface mirrorClosest;\n    vec3 vMirrorDomain = vBodyPos - vec3(0.875, 0.9, 0.55);\n    vMirrorDomain.z += vMirrorDomain.x * 0.1;\n    mirrorClosest.fDist = SdBox( vMirrorDomain, vec3(0.125, 0.1, 0.06)-0.05)  -0.05;\n\tmirrorClosest.surface.vUVW = vBodyPos.xyz - vec3(0.5);\n    mirrorClosest.surface.fId = MAT_CAR_BODY;    \n    if ( mirrorClosest.fDist < -vMirrorDomain.z )\n    {                \n        if ( mirrorClosest.fDist < -0.01 )\n        {\n    \t\tmirrorClosest.surface.fId = MAT_CHROME;    \n        }\n        \n        mirrorClosest.fDist = -vMirrorDomain.z;        \n    }\n    \n    closest = ClosestSurfaceUnion( closest, mirrorClosest );\n\n    \n   \t\/*ClosestSurface grillClosest;\n    vec3 vGrillDomain = vBodyPos - vec3(0.0, 0.55, 1.85);\n    vGrillDomain.z += vGrillDomain.y * 0.2;\n    float fGrillDist = UdRoundBox( vGrillDomain, vec3(0.85, 0.05, 0.0), 0.1);\n    if ( fGrillDist < closest.fDist )\n    {\n        closest.surface.fId = MAT_GRILL;\n    }*\/\n    \n    \/*ClosestSurface lightClosest;\n    vec3 vLightDomain = vBodyPos - vec3(0.5, 0.5, 2.0);\n    if( vBodyPos.z < 0.5 )\n    {\n        vLightDomain = vBodyPos - vec3(0.3, 1.5, -0.2);\n    }\n    lightClosest.fDist = length(vLightDomain) - 0.15;\n    float fFrontDist = length(vLightDomain + vec3(0.0, 0.0, 0.52)) - 0.5;\n    lightClosest.fDist = -min( -lightClosest.fDist, -fFrontDist );\n\tlightClosest.surface.vUVW = vAbsBodyPos.xyz;\n    lightClosest.surface.fId = MAT_CHROME; \n\n    closest = ClosestSurfaceUnion( closest, lightClosest );*\/\n\t\n#endif    \n#endif\n    return closest;\n}\n\nfloat g_fWheelR = 0.45;\nfloat g_fWheelW = 0.25;\nClosestSurface GetWheelClosestSurface( vec3 vPos )\n{   \n    float theta = atan( vPos.z, vPos.y );\n    float r = length( vPos.zy );    \n    float x = vPos.x;\n        \n    float fr = r * ( 1.0 \/ g_fWheelR );\n    \n    if( fr < 0.5 )\n    {\n        x += 0.01 * clamp((0.5 - fr) * 30.0, 0.0, 1.0);\n        \n        if( fr < 0.3 )\n        {\n            float unitr = fr \/ 0.3;\n            x = x + sqrt(1.0 - unitr * unitr) * 0.05;\n            \/\/x = x + 0.01;\n        }    \n    }\n    else\n    {\n#ifndef FAST_VERSION    \n        \n        float fX = x * (1.0 \/ g_fWheelW);\n        float tread = sin(theta * 15.0 + abs(fX) * 4.0);\n        \n        float treadThickness = 1.0 - clamp( 0.9 - fX * fX * 0.3, 0.0, 1.0 );\n\t    \n        r = -min( -r, -(r + abs(tread) * treadThickness * 0.05 + 0.025));\n#endif\n    }\n    \n    float fRound = 0.1;\n    \n    float fWheelR = g_fWheelR - fRound;\n    float fWheelW = g_fWheelW - fRound;       \n    \n    vec2 rx = vec2( r,x );\n\n    ClosestSurface closest;\n    closest.surface.fId = MAT_WHEEL;\n    closest.surface.vUVW = vPos.yzx;\n    closest.fDist = length( max( abs(rx) - vec2(fWheelR, fWheelW), 0.0)) - fRound;\n        \n    return closest;\n}\n\nClosestSurface GetVehicleClosestSurface( const in VehicleState vehicleState, const vec3 vPos )\n{\n    ClosestSurface closest;\n    \n    \/*\n    float fCullDist = length( vPos - vVehPos );\n    if ( fCullDist > 3.5 ) \n    {\n        closest.fDist = fCullDist - 1.0;\n        closest.surface.fId = 0.0;\n        closest.surface.vUVW = vec3(0.0);\n        return closest;\n    }\n\t*\/        \n    \n    \n    vec3 vLocalPos = vehicleState.mRot * (vPos - vehicleState.vPos);\n    \n    \n    \/\/closest.fDist = 10000.0;\n    \/\/closest.surface.fId = 0.0;\n    \/\/closest.surface.vUVW = vec3(0.0);    \n    closest = GetCarBodyClosestSurface( vLocalPos );\n    \n\tvec3 vWheelPos0 = vec3( -0.9, -0.1, 1.25 );\n\tvec3 vWheelPos1 = vec3(  0.9, -0.1, 1.25 );\n\tvec3 vWheelPos2 = vec3( -0.9, -0.1, -1.25 );\n\tvec3 vWheelPos3 = vec3(  0.9, -0.1, -1.25 );        \n        \n    \n    vec3 vWheelOrigin;\n    vec4 vWheelState;\n    vec4 vWheelSC;\n\n    if ( vLocalPos.z > 0.0 )\n    {\n        if ( vLocalPos.x < 0.0 )\n        {\n            vWheelOrigin = vWheelPos0;\n            vWheelState = vehicleState.vWheelState0;\n            vWheelSC = vehicleState.vWheelSC0;\n        }\n        else\n        {\n            vWheelOrigin = vWheelPos1;\n            vWheelState = vehicleState.vWheelState1;\n            vWheelSC = vehicleState.vWheelSC1;\n        }\n    }\n    else\n    {\n        if ( vLocalPos.x < 0.0 )\n        {\n            vWheelOrigin = vWheelPos2;\n            vWheelState = vehicleState.vWheelState2;\n            vWheelSC = vehicleState.vWheelSC2;\n        }\n        else\n        {\n            vWheelOrigin = vWheelPos3;\n            vWheelState = vehicleState.vWheelState3;\n            vWheelSC = vehicleState.vWheelSC3;\n        }\n    }\n    \n    vec3 vWheelPos = vWheelOrigin;\n    float fWheelSide = sign(vWheelOrigin.x);\n    \n    vWheelPos.y -= vWheelState.z - g_fWheelR;\n    vec3 vWheelLocalPos = vWheelPos - vLocalPos;\n    vWheelLocalPos = RotY( vWheelLocalPos, vWheelSC.xy );        \n    vWheelLocalPos = RotX( vWheelLocalPos, vWheelSC.zw );    \n    vWheelLocalPos.x *= -fWheelSide;\n    closest = ClosestSurfaceUnion( closest, GetWheelClosestSurface( vWheelLocalPos ) );\n    \n#ifndef FAST_VERSION    \n    vec3 vAxleOrigin = vWheelOrigin;\n    vAxleOrigin.x = 0.0;\n    vAxleOrigin.y = 0.25;\n    vec3 vAxleEnd = vWheelPos;\n    vAxleEnd.x = 0.9 * fWheelSide;\n    float cDist0 = SdCapsule(vLocalPos, vAxleOrigin, vAxleEnd, 0.05, 0.05);\n    if( cDist0 < closest.fDist )\n    {\n        closest.surface.fId = MAT_AXLE;\n        closest.fDist = cDist0;\n    }\n    \n    float fSuspensionTop = 0.6;\n    \n    vec3 vSuspensionOrigin = vWheelOrigin;\n    vSuspensionOrigin.x -= 0.4 * fWheelSide;\n    vSuspensionOrigin.y = fSuspensionTop;\n    \/\/vSuspensionOrigin.z *= 0.9;\n\n    vec3 vSuspensionDomain = vLocalPos - vSuspensionOrigin;\n    vSuspensionDomain.z = abs(vSuspensionDomain.z) - 0.1;    \n    \n    vec3 vSuspensionEnd = vec3(0.03 * fWheelSide, -fSuspensionTop + (vWheelPos.y - vWheelOrigin.y) * 0.8, 0.0);\n    \/\/vec3 vSuspensionEnd = vWheelPos;\n    \/\/vSuspensionEnd.x = 0.5 * fWheelSide;\n    \/\/vSuspensionEnd.y += 0.05;\n    \/\/vec3 vSuspensionDomain = vLocalPos - vSuspensionOrigin;\n    float cDist1 = SdCapsule(vSuspensionDomain, vec3(0.0), vSuspensionEnd, 0.05, 0.05);\n    if( cDist1 < closest.fDist )\n    {\n        closest.surface.fId = MAT_SUSPENSION;\n        closest.fDist = cDist1;\n        closest.surface.vUVW = vSuspensionDomain;\n        closest.surface.vUVW.y = closest.surface.vUVW.y \/ vSuspensionEnd.y;\n    }\n#endif \n    \n    return closest;\n}\n\n\n\nClosestSurface GetSceneClosestSurface( const in SceneState sceneState, const vec3 vPos )\n{    \n    ClosestSurface closest;\n    \n    ClosestSurfaceInit( closest, MAT_TERRAIN, vec3( 0.0 ) );\n        \n    ClosestSurface terrainClosest = GetEnvironmentClosestSurface( vPos );\n    ClosestSurface vehicleClosest = GetVehicleClosestSurface( sceneState.vehicleState, vPos );\n    closest = ClosestSurfaceUnion( terrainClosest, vehicleClosest );\n    \n    return closest;\n}\n\nvec3 GetSceneNormal( const in SceneState sceneState, const in vec3 vPos )\n{\n    const float fDelta = 0.0005;\n\n    vec3 vDir1 = vec3( 1.0, -1.0, -1.0);\n    vec3 vDir2 = vec3(-1.0, -1.0,  1.0);\n    vec3 vDir3 = vec3(-1.0,  1.0, -1.0);\n    vec3 vDir4 = vec3( 1.0,  1.0,  1.0);\n\t\n    vec3 vOffset1 = vDir1 * fDelta;\n    vec3 vOffset2 = vDir2 * fDelta;\n    vec3 vOffset3 = vDir3 * fDelta;\n    vec3 vOffset4 = vDir4 * fDelta;\n\n    ClosestSurface c1 = GetSceneClosestSurface( sceneState, vPos + vOffset1 );\n    ClosestSurface c2 = GetSceneClosestSurface( sceneState, vPos + vOffset2 );\n    ClosestSurface c3 = GetSceneClosestSurface( sceneState, vPos + vOffset3 );\n    ClosestSurface c4 = GetSceneClosestSurface( sceneState, vPos + vOffset4 );\n\t\n    vec3 vNormal = vDir1 * c1.fDist + vDir2 * c2.fDist + vDir3 * c3.fDist + vDir4 * c4.fDist;\t\n\t\t\n    return normalize( vNormal );\n}\n\nvoid TraceScene( const in SceneState sceneState, out C_Intersection outIntersection, const in vec3 vOrigin, const in vec3 vDir )\n{\t\n\tvec3 vPos = vec3(0.0);\n\t\n\tfloat t = 0.1;\n\tconst int kRaymarchMaxIter = 64;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\n\t\tfloat fClosestDist = GetSceneClosestSurface( sceneState, vOrigin + vDir * t ).fDist;\n\t\tt += fClosestDist;\n\t\tif(abs(fClosestDist) < 0.01)\n\t\t{\n\t\t\tbreak;\n\t\t}\t\t\n\t\tif(t > kFarClip)\n\t\t{\n\t\t\tt = kFarClip;\n\t\t\tbreak;\n\t\t}\n\t}\n    \n\toutIntersection.fDist = t;\n\toutIntersection.vPos = vOrigin + vDir * t;\n    \n    if( t >= kFarClip )\n    {\n        outIntersection.surface.fId = 0.0;\n        outIntersection.surface.vUVW = vec3( 0.0 );\n        outIntersection.vNormal = vec3(0.0, 1.0, 0.0);\n    }\n    else\n    {\n\t\toutIntersection.vNormal = GetSceneNormal( sceneState, outIntersection.vPos );\n        outIntersection.surface = GetSceneClosestSurface( sceneState, outIntersection.vPos ).surface;\n    }\n}\n\n#define SOFT_SHADOW\n\nfloat TraceShadow( const in SceneState sceneState, const in vec3 vOrigin, const in vec3 vDir, const in float fDist )\n{\n#ifndef SOFT_SHADOW\n\tC_Intersection shadowIntersection;\n\tTraceScene(sceneState, shadowIntersection, vOrigin, vDir);\n\tif(shadowIntersection.fDist < fDist) \n\t{\n\t\treturn 0.0;\t\t\n\t}\n\t\n\treturn 1.0;\n#else\t\n\t#define kShadowIter 32\n\t#define kShadowFalloff 10.0\n\tfloat fShadow = 1.0;\n\tfloat t = 0.01;\n\tfloat fDelta = 2.5 \/ float(kShadowIter);\n\tfor(int i=0; i<kShadowIter; i++)\n\t{\n\t\tvec4 vUnused;\n\t\tClosestSurface closest = GetSceneClosestSurface( sceneState, vOrigin + vDir * t );\n\t\t\n\t\tfShadow = min( fShadow, kShadowFalloff * closest.fDist \/ t );\n\t\t\n\t\tt = t + fDelta;\n\t}\n\n\treturn clamp(fShadow, 0.0, 1.0);\n#endif\n}\n\n\/\/ AMBIENT OCCLUSION\n\nfloat GetAmbientOcclusion( const in SceneState sceneState, const in vec3 vPos, const in vec3 vNormal )\n{\n\tfloat fAmbientOcclusion = 0.0;\n#ifndef FAST_VERSION    \n\t\n\tfloat fStep = 0.1;\n\tfloat fDist = 0.0;\n\tfor(int i=0; i<=5; i++)\n\t{\n\t\tfDist += fStep;\n\t\t\n\t\tvec4 vUnused;\n        \n\t\tClosestSurface closest = GetSceneClosestSurface( sceneState, vPos + vNormal * fDist );\n\t\t\n\t\tfloat fAmount = (fDist - closest.fDist);\n\t\t\n\t\tfAmbientOcclusion += max(0.0, fAmount * fDist );                                  \n\t}\n#endif\t\n\treturn max(1.0 - fAmbientOcclusion, 0.0);\n}\n\n\/\/ LIGHTING\n\nvoid AddLighting(inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightColour)\n{\n\tfloat fNDotL = clamp(dot(vLightDir, vNormal), 0.0, 1.0);\n\tvec3 vHalfAngle = normalize(-vViewDir + vLightDir);\n    float fNDotH = clamp(dot(vHalfAngle, vNormal), 0.0, 1.0);\n\t\n\tvDiffuseLight += vLightColour * fNDotL;\n\t\n\tfloat fSpecularPower = exp2(4.0 + 6.0 * fSmoothness);\n\tfloat fSpecularIntensity = (fSpecularPower + 2.0) * 0.125;\n\tvSpecularLight += vLightColour * fSpecularIntensity * clamp(pow(fNDotH, fSpecularPower), 0.0, 1.0) * fNDotL;\n}\n\nvoid AddPointLight(const in SceneState sceneState, inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vPos, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightPos, const in vec3 vLightColour)\n{\n\tvec3 vToLight = vLightPos - vPos;\t\n\tfloat fDistance2 = dot(vToLight, vToLight);\n\tfloat fAttenuation = 100.0 \/ (fDistance2);\n\tvec3 vLightDir = normalize(vToLight);\n\t\n\tvec3 vShadowRayDir = vLightDir;\n\tvec3 vShadowRayOrigin = vPos + vShadowRayDir * 0.01;\n\tfloat fShadowFactor = TraceShadow( sceneState, vShadowRayOrigin, vShadowRayDir, length(vToLight));\n\t\n\tAddLighting(vDiffuseLight, vSpecularLight, vViewDir, vLightDir, vNormal, fSmoothness, vLightColour * fShadowFactor * fAttenuation);\n}\n\nvoid AddPointLightFlare(inout vec3 vEmissiveGlow, const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fIntersectDistance, const in vec3 vLightPos, const in vec3 vLightColour)\n{\n    vec3 vToLight = vLightPos - vRayOrigin;\n    float fPointDot = dot(vToLight, vRayDir);\n    fPointDot = clamp(fPointDot, 0.0, fIntersectDistance);\n\n    vec3 vClosestPoint = vRayOrigin + vRayDir * fPointDot;\n    float fDist = length(vClosestPoint - vLightPos);\n\tvEmissiveGlow += sqrt(vLightColour * 0.05 \/ (fDist * fDist));\n}\n\nvoid AddDirectionalLight(const in SceneState sceneState, inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vPos, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightDir, const in vec3 vLightColour)\n{\t\n\tfloat fAttenuation = 1.0;\n\n\tvec3 vShadowRayDir = -vLightDir;\n\tvec3 vShadowRayOrigin = vPos + vShadowRayDir * 0.01;\n\tfloat fShadowFactor = TraceShadow(sceneState, vShadowRayOrigin, vShadowRayDir, 10.0);\n\t\n\tAddLighting(vDiffuseLight, vSpecularLight, vViewDir, -vLightDir, vNormal, fSmoothness, vLightColour * fShadowFactor * fAttenuation);\t\n}\n\nvoid AddDirectionalLightFlareToFog(inout vec3 vFogColour, const in vec3 vRayDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fDirDot = clamp(dot(-vLightDir, vRayDir) * 0.5 + 0.5, 0.0, 1.0);\n\tfloat kSpreadPower = 5.0;\n\tvFogColour += vLightColour * pow(fDirDot, kSpreadPower) * 0.5;\n}\n\n\/\/ SCENE MATERIALS\n\nvec3 ProjectedTexture( vec3 pos, vec3 normal )\n{\n    vec3 vWeights = normal * normal;\n    vec3 col = vec3(0.0);\n    vec3 sample;\n    sample = texture2D( iChannel1, pos.xz ).rgb;\n    col += sample * sample * vWeights.y;\n    sample = texture2D( iChannel1, pos.xy ).rgb;\n    col += sample * sample * vWeights.z;\n    sample = texture2D( iChannel1, pos.yz ).rgb;\n    col += sample * sample * vWeights.x;\n    col \/= vWeights.x + vWeights.y + vWeights.z;\n    return col;    \n}\n\nvoid GetSurfaceInfo( out vec3 vOutAlbedo, out float fOutR0, out float fOutSmoothness, out vec3 vOutBumpNormal, const in C_Intersection intersection )\n{\n\tvOutBumpNormal = intersection.vNormal;\n    \n    float fRange = 20.0;\n    vec2 vPrevFragOffset = intersection.vPos.xz - g_TyreTrackOrigin;\n    vec2 vPrevUV = ( (vPrevFragOffset \/ fRange) + 1.0 ) \/ 2.0;\n\n    vec4 vTrackSample = texture2D( iChannel3, vPrevUV );            \n    \n    if ( vPrevUV.x < 0.0 || vPrevUV.x >=1.0 || vPrevUV.y < 0.0 || vPrevUV.y >= 1.0 )\n    {\n        vTrackSample = vec4(0.0);\n    }\n\t\n\tfOutR0 = 0.02;\n\n    if(intersection.surface.fId == MAT_TERRAIN)\n\t{\n\t\tvec2 vUV = intersection.surface.vUVW.xy * 0.1;\n\t\tvOutAlbedo = texture2D(iChannel1, vUV).rgb;\n\t\t\n        #ifndef FAST_VERSION\n        float fBumpScale = 1.0;\n\t\t\n\t\tvec2 vRes = iChannelResolution[0].xy;\n\t\tvec2 vDU = vec2(1.0, 0.0) \/ vRes;\n\t\tvec2 vDV = vec2(0.0, 1.0) \/ vRes;\n\t\t\n\t\tfloat fSampleW = texture2D(iChannel1, vUV - vDU).r;\n\t\tfloat fSampleE = texture2D(iChannel1, vUV + vDU).r;\n\t\tfloat fSampleN = texture2D(iChannel1, vUV - vDV).r;\n\t\tfloat fSampleS = texture2D(iChannel1, vUV + vDV).r;\n\t\t\n\t\tvec3 vNormalDelta = vec3(0.0);\n\t\tvNormalDelta.x += \n\t\t\t( fSampleW * fSampleW\n\t\t\t - fSampleE * fSampleE) * fBumpScale;\n\t\tvNormalDelta.z += \n\t\t\t(fSampleN * fSampleN\n\t\t\t - fSampleS * fSampleS) * fBumpScale;\n\t\t\n\t\tvOutBumpNormal = normalize(vOutBumpNormal + vNormalDelta);\n\t\t#endif\n        \n\t\tvOutAlbedo = vOutAlbedo * vOutAlbedo;\t\n\t\tfOutSmoothness = vOutAlbedo.r * 0.3;\n\t\t        \n        \/\/if(false)\n\t\t{       \n            \/\/ Tyre tracks\n            float fDepth = vTrackSample.x * (1.0 + vTrackSample.y);\n            \n            \/\/vec3 vTex2 = texture2D(iChannel2, vUV).rgb;\n            vec3 vTex2 = mix( vOutAlbedo, vec3( 0.9, 0.3, 0.01 ), 0.5);\n            vOutAlbedo = mix( vOutAlbedo, vTex2, fDepth );\n            \n            \/\/vOutAlbedo *= 1.0 - 0.2 * vTrackSample.r;\n            \n            vOutAlbedo *= 1.0 - 0.6 * vTrackSample.g;\n            fOutSmoothness = mix( fOutSmoothness, fOutSmoothness * 0.75 + 0.25, fDepth );                        \n        }  \n\t}\n\telse if(intersection.surface.fId == MAT_BLACK_PLASTIC)\n\t{\n\t\tvec2 vUV = intersection.surface.vUVW.xy;\n\t\tvOutAlbedo = texture2D(iChannel1, vUV).rgb;\n\t\tvOutAlbedo = vOutAlbedo * vOutAlbedo;\t\n        vOutAlbedo *= 0.01;\n\t\tfOutSmoothness = 0.1;\/\/vOutAlbedo.r;\t\t\t\n        \n        vec3 vDirt = (texture2D(iChannel1, intersection.surface.vUVW.zy).rgb + texture2D(iChannel1, intersection.surface.vUVW.xy).rgb) * 0.5;\n        float fDirt = vDirt.r;\n        \n        float fMix = clamp( fDirt - intersection.surface.vUVW.y * 2.5 + 0.8, 0.0, 1.0 );\n        \n        vDirt = vDirt * vDirt * 0.1;\n\n        vOutAlbedo = mix( vOutAlbedo, vDirt, fMix );\n        fOutSmoothness = mix( fOutSmoothness, 0.01, fMix );        \n\n\t}\n\telse if(intersection.surface.fId == MAT_CHROME)\n\t{\n\t\tvOutAlbedo = vec3(0.1);\n\t\tfOutSmoothness = 1.0;\t\t\t\n\t\tfOutR0 = 0.9;\n\t}\n\telse if(intersection.surface.fId == MAT_CAR_BODY)\n\t{\n\t\tvOutAlbedo = vec3(0.0, 0.0, 1.0);\n        \n        float fAbsX = abs( intersection.surface.vUVW.x );\n\n        fOutSmoothness = 1.0;\n        \n        float fStripe = abs(fAbsX - (0.15));\n        fStripe = smoothstep( 0.1 + 0.01, 0.1 - 0.01, fStripe);\n\n\t\tvOutAlbedo = mix( vOutAlbedo, vec3(1.0, 1.0, 1.0), fStripe);\n\n        if ( intersection.surface.vUVW.y < 0.85 )\n        {\n            float fLine = abs(intersection.surface.vUVW.z - 0.7);\n            fLine = min( fLine, abs(intersection.surface.vUVW.z + 0.6) );\n            fLine = min( fLine, abs(fAbsX - 0.65) );\n            fLine = min( fLine, abs(intersection.surface.vUVW.y - 0.2) );\n            fLine = clamp( (fLine - 0.005) \/ 0.01, 0.0, 1.0);\n            vOutAlbedo *= fLine;\n            fOutR0 *= fLine;\n            fOutSmoothness *= fLine;\n\n        }\n        \n        if(fAbsX > 0.92 )\n        {\n\t\t\tvOutAlbedo = vec3(0.02, 0.02, 0.02);\n            fOutSmoothness = 0.2;\n        }\n                \n        if( intersection.surface.vUVW.y > 0.85 && intersection.surface.vUVW.y < 1.2)\n        {\n            bool bFront = (intersection.surface.vUVW.z + intersection.surface.vUVW.y * 1.25 )  > 1.6;\n            bool bRear = (intersection.surface.vUVW.z)  < -0.45;\n            bool bSide = (fAbsX +intersection.surface.vUVW.y * 0.3) > 0.9;\n            \n            if ( !(bFront && bSide) && !(bRear && bSide))\n            {\n\t\t\t\tvOutAlbedo = vec3(0.0, 0.0, 0.0);\n\t\t\t\tfOutR0 = 0.02;\n            \tfOutSmoothness = 0.9;\n            }\n        }\n        \n        vec3 vGrillDomain = intersection.surface.vUVW - vec3(0.0, 0.55, 1.85);\n        float fGrillDist = UdRoundBox( vGrillDomain, vec3(0.85, 0.05, 0.0), 0.1);\n        if ( fGrillDist < 0.0 )\n        {\n\t\t\tvOutAlbedo = vec3(0.0, 0.0, 0.0);\n\t\t\tfOutR0 = 0.02;\n        }        \n\n        vec3 vLightDomain = intersection.surface.vUVW;\n        vLightDomain.x = abs( vLightDomain.x );\n        vLightDomain -= vec3(0.6, 0.56, 1.85);\n        float fLightDist = UdRoundBox( vLightDomain, vec3(0.1, 0.04, 0.5), 0.05);\n        if ( fLightDist < 0.0 )\n        {\n\t\t\tvOutAlbedo = vec3(0.5);\n\t\t\tfOutR0 = 1.0;\n            fOutSmoothness = 0.8;\n        }\n        \n        \n        vec3 vDirt = (texture2D(iChannel1, intersection.surface.vUVW.zy).rgb + texture2D(iChannel1, intersection.surface.vUVW.xy).rgb) * 0.5;\n        float fDirt = vDirt.r;\n        \n        float fMix = clamp( fDirt - intersection.surface.vUVW.y * 1.5 + 0.8, 0.0, 1.0 );\n        \n        vDirt = vDirt * vDirt * 0.1;\n\n        vOutAlbedo = mix( vOutAlbedo, vDirt, fMix );\n        fOutR0 = mix( fOutR0, 0.01, fMix );\n        fOutSmoothness = mix( fOutSmoothness, 0.01, fMix );\n        \n\t\t\/\/vOutR0 = vec3(0.7, 0.5, 0.02);\n        \/\/vOutAlbedo = vOutR0 * 0.01;\n        \n\t}\n\telse if(intersection.surface.fId == MAT_WHEEL)\n\t{\n\t\tvec2 vUV = intersection.surface.vUVW.xy;\n\t\tvOutAlbedo = texture2D(iChannel2, vUV).rgb;\n\t\tvOutAlbedo = vOutAlbedo * vOutAlbedo;\t\n        vOutAlbedo *= 0.01;\n        float len = length(vUV);\n        float fR = len * (1.0 \/ g_fWheelR);\n        if ( fR < 0.5 )\n        {\n\t\t\tfOutSmoothness = 1.0;        \n\t\t\tfOutR0 = 1.0;\n        }\n        else\n        {\n\t\t\tfOutSmoothness = 0.1;\n        }\n\n        vec3 vDirt = (texture2D(iChannel1, intersection.surface.vUVW.zy).rgb + texture2D(iChannel1, intersection.surface.vUVW.xy).rgb) * 0.5;\n        \n        float fDirt = vDirt.r;\n        fDirt = sqrt(fDirt);\n        \n        float fMix = clamp( fDirt - (1.0 - fR) * 1.0 + 0.8, 0.0, 1.0 );\n        \n        vDirt = vDirt * vDirt * 0.1;\n\n        vOutAlbedo = mix( vOutAlbedo, vDirt, fMix );\n        fOutR0 = mix( fOutR0, 0.01, fMix );\n        fOutSmoothness = mix( fOutSmoothness, 0.01, fMix );\n        \n    }\n    else if(intersection.surface.fId == MAT_SUSPENSION )\n    {\n\t\tvOutAlbedo = vec3(0.1);\n\t\tfOutSmoothness = 1.0;\t\t\t\n\t\tfOutR0 = 0.9;\n\n        float fY = intersection.surface.vUVW.y;\n        \n        float fAngle = atan(intersection.surface.vUVW.x, intersection.surface.vUVW.y);        \n        fAngle -= fY * 30.0;\n        float fFAngle = fract(fAngle \/ (3.1415 * 2.0));\n        if ( fFAngle < 0.5 )\n        {\n            fOutR0 = 0.0;\n        \tvOutAlbedo = vec3(0.0);            \n        }\n\n        vec3 vDirt = (texture2D(iChannel1, intersection.surface.vUVW.zy).rgb + texture2D(iChannel1, intersection.surface.vUVW.xy).rgb) * 0.5;\n        \n        float fDirt = vDirt.r;\n        fDirt = sqrt(fDirt);\n        \n        float fMix = clamp( fDirt + 0.1, 0.0, 1.0 );\n        \n        vDirt = vDirt * vDirt * 0.1;\n\n        vOutAlbedo = mix( vOutAlbedo, vDirt, fMix );\n        fOutR0 = mix( fOutR0, 0.01, fMix );\n        fOutSmoothness = mix( fOutSmoothness, 0.01, fMix );\n        \n    }\n    else if(intersection.surface.fId == MAT_WOOD)\n\t{\n\t\tvec2 vUV = intersection.surface.vUVW.xz * 0.1;\n\t\tvOutAlbedo = texture2D(iChannel2, vUV).rgb;\n        vOutAlbedo = vOutAlbedo * vOutAlbedo;\n\t\tfOutSmoothness = vOutAlbedo.r;\n\t\t\n        vOutAlbedo *= 1.0 - vTrackSample.g * 0.6;\n   \t}\n\t\n\t\/\/vOutR0 = vec3(0.9);\n\t\/\/fOutSmoothness = 0.5;\n}\n\nvec3 vSkyTop = vec3(0.1, 0.5, 0.8);\nvec3 vSkyBottom = vec3(0.02, 0.04, 0.06);\n\nvec3 GetSkyColour( const in vec3 vDir )\n{\n\tvec3 vResult = vec3(0.0);\n\t\n    vResult = mix(vSkyBottom, vSkyTop, abs(vDir.y)) * 30.0;\n\t\n#ifndef FAST_VERSION    \n    float fCloud = texture2D( iChannel1, vDir.xz * 0.01 \/ vDir.y ).r;\n    fCloud = clamp( fCloud * fCloud * 3.0 - 1.0, 0.0, 1.0);\n    vResult = mix( vResult, vec3(8.0), fCloud );\n#endif \n    \n\treturn vResult;\t\n}\n\nfloat GetFogFactor(const in float fDist)\n{\n\tfloat kFogDensity = 0.0025;\n\treturn exp(fDist * -kFogDensity);\t\n}\n\nvec3 GetFogColour(const in vec3 vDir)\n{\n\treturn (vSkyBottom) * 25.0;\n}\n\n\nvec3 vSunLightColour = vec3(1.0, 0.9, 0.6) * 10.0;\nvec3 vSunLightDir = normalize(vec3(0.4, -0.3, -0.5));\n\t\nvoid ApplyAtmosphere(inout vec3 vColour, const in float fDist, const in vec3 vRayOrigin, const in vec3 vRayDir)\n{\t\t\n\tfloat fFogFactor = GetFogFactor(fDist);\n\tvec3 vFogColour = GetFogColour(vRayDir);\t\t\t\n\tAddDirectionalLightFlareToFog(vFogColour, vRayDir, vSunLightDir, vSunLightColour);\n\t\n\tvec3 vGlow = vec3(0.0);\n\t\/\/AddPointLightFlare(vGlow, vRayOrigin, vRayDir, fDist, vLightPos, vLightColour);\t\t\t\t\t\n\t\n\tvColour = mix(vFogColour, vColour, fFogFactor) + vGlow;\t\n}\n\n\/\/ TRACING LOOP\n\n\t\nvec3 GetSceneColour( in vec3 vRayOrigin,  in vec3 vRayDir, out float fDepth )\n{\n\tvec3 vColour = vec3(0.0);\n\tfloat fRemaining = 1.0;\n\t\n    SceneState sceneState = SetupSceneState();\n    \n    fDepth = 0.0;\n    float fFirstTrace = 1.0;\n    \n#ifndef FAST_VERSION    \n\tfor(int i=0; i<RAYTRACE_COUNT; i++)\n#endif\n    {\t\n        \/\/ result = reflection\n        \/\/vColour = vec3(0.0);\n\t\t\/\/vRemaining = vec3(1.0);\n        \n\t\tfloat fCurrRemaining = fRemaining;\n\t\tfloat fShouldApply = 1.0;\n\t\t\n\t\tC_Intersection intersection;\t\t\t\t\n\t\tTraceScene( sceneState, intersection, vRayOrigin, vRayDir );\n\n        float fHitDepth = intersection.fDist;\n\t\tif(intersection.surface.fId >= MAT_FIRST_VEHICLE)\n\t\t{\n            fHitDepth = -fHitDepth;\n        }\n\t\t\n        fDepth = ( fFirstTrace > 0.0 ) ? fHitDepth : fDepth;\n        fFirstTrace = 0.0;\n        \n\t\tvec3 vResult = vec3(0.0);\n\t\tfloat fBlendFactor = 0.0;\n\t\t\t\t\t\t\n\t\tif(intersection.surface.fId == 0.0)\n\t\t{\n\t\t\tfBlendFactor = 1.0;\n\t\t\tfShouldApply = 0.0;\n\t\t}\n\t\telse\n\t\t{\t\t\n\t\t\tvec3 vAlbedo;\n\t\t\tfloat fR0;\n\t\t\tfloat fSmoothness;\n\t\t\tvec3 vBumpNormal;\n\t\t\t\n\t\t\tGetSurfaceInfo( vAlbedo, fR0, fSmoothness, vBumpNormal, intersection );\t\t\t\n\t\t\n\t\t\tvec3 vDiffuseLight = vec3(0.0);\n\t\t\tvec3 vSpecularLight = vec3(0.0);\n\n\t\t\t\/\/AddPointLight(sceneState, vDiffuseLight, vSpecularLight, vRayDir, intersection.vPos, vBumpNormal, fSmoothness, vLightPos, vLightColour);\t\t\t\t\t\t\t\t\n\n\t\t\tAddDirectionalLight(sceneState, vDiffuseLight, vSpecularLight, vRayDir, intersection.vPos, vBumpNormal, fSmoothness, vSunLightDir, vSunLightColour);\t\t\t\t\t\t\t\t\n\t\t\t\n\t\t\tvDiffuseLight += 0.2 * GetAmbientOcclusion(sceneState, intersection.vPos, vBumpNormal);\n\n\t\t\tfloat fSmoothFactor = pow(fSmoothness, 5.0);\n\t\t\tfloat fFresnel = fR0 + (1.0 - fR0) * pow(1.0 - dot(-vBumpNormal, vRayDir), 5.0) * fSmoothFactor;\n\t\t\t\n\t\t\tvResult = mix(vAlbedo * vDiffuseLight, vSpecularLight, fFresnel);\t\t\n\t\t\tfBlendFactor = fFresnel;\n\t\t\t\n\t\t\tApplyAtmosphere(vResult, intersection.fDist, vRayOrigin, vRayDir);\t\t\n\t\t\t\n\t\t\tfRemaining *= fBlendFactor;\t\t\t\n            \n            #ifndef FAST_VERSION\n            float fRoughness = 1.0 - fSmoothness;\n            fRoughness = pow(fRoughness, 5.0);\n            vBumpNormal = normalize(vBumpNormal + normalize(Hash31(intersection.vPos.x * 10.0 + intersection.vPos.z * 11.0 + intersection.vPos.y )) * (fRoughness) * 0.5);\n\t\t\t#endif\n            vRayDir = normalize(reflect(vRayDir, vBumpNormal));\n\t\t\tvRayOrigin = intersection.vPos;\/\/ + intersection.vNormal;\n\t\t}\t\t\t\n\n\t\tvColour += vResult * fCurrRemaining * fShouldApply;\n\t\t\n\t\t\n\t}\n\n\tvec3 vSkyColor = GetSkyColour(vRayDir);\n\t\n\tApplyAtmosphere(vSkyColor, kFarClip, vRayOrigin, vRayDir);\t\t\n\t\n\tvColour += vSkyColor * fRemaining;\n\t\n\treturn vColour;\n}\n","name":"","description":"","type":"buffer"}]}}