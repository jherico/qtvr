{"Shader":{"ver":"0.1","info":{"id":"ltBGzc","date":"1431070645","viewed":659,"name":"DF car","username":"yaro_b","description":"My first experiment with ray marching of distance fields.<br\/>Target: nice car on the ground, with PBS BRDF shading & materials, soft shadows, AO, AA, and gamma-correction.","likes":0,"published":3,"flags":0,"tags":["raymarching","distancefields"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\n\/\/ sd - signed distance\n\/\/ ud - unsigned distance\n\nfloat dot2(vec3 v)\n{\n    return dot(v,v);\n}\n\nfloat length_n(vec2 v, float n)\n{\n    return pow(pow(v.x, n) + pow(v.y, n), 1.0 \/ n);\n}\n\n\/\/ polynomial smooth min (k = 0.1);\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (b - a) \/ k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n\/\/ Schlick's approximation\nvec3 fresnel(vec3 f0, vec3 l, vec3 h)\n{\n    return f0 + (1.0 - f0) * pow(1.0 - max(0.0, dot(l, h)), 5.0);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nstruct DistanceField\n{\n    float distance;\n    int id;\n};\n\nstruct Material\n{\n    vec3 ambient;\n    vec3 specular;\n    vec3 diffuse;\n    float m;\n};\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ primitives\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat sd_sphere(vec3 p, float radius)\n{\n    return length(p) - radius;\n}\n\nfloat sd_box(vec3 p, vec3 b)\n{\n    vec3 diff = abs(p) - b;\n    return min(max(diff.x,max(diff.y, diff.z)), 0.0) + length(max(diff, 0.0));\n}\n\nfloat ud_box(vec3 p, vec3 box)\n{\n    return length(max(abs(p) - box, 0.0));\n}\n\nfloat ud_round_box(vec3 p, vec3 box, float radius)\n{\n    return length(max(abs(p) - box, 0.0)) - radius;\n}\n\nfloat sd_plane(vec3 p, vec4 n)\n{\n    \/\/ n must be normalized\n    return dot(p, n.xyz) + n.w;\n}\n\nfloat sd_torus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sd_torus82(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length_n(q, 8.0) - t.y;\n}\n\nfloat sd_torus82_z(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xy) - t.x, p.z);\n    return length_n(q, 8.0) - t.y;\n}\n\nfloat sd_cylinder(vec3 p, vec3 c)\n{\n    return length(p.xz - c.xy) - c.z;\n}\n\nfloat sd_capped_cylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sd_capped_cylinder_z(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xy), p.z)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sd_cone(vec3 p, vec2 c)\n{\n    \/\/ c must be normalized\n    float q = length(p.xy);\n    return dot(c, vec2(q, p.z));\n}\n\nfloat sd_capped_cone(vec3 p, vec3 c)\n{\n    vec2 q = vec2(length(p.xz), p.y );\n    vec2 v = vec2(c.z * c.y \/ c.x, -c.z);\n\n    vec2 w = v - q;\n\n    vec2 vv = vec2(dot(v,v), v.x * v.x);\n    vec2 qv = vec2(dot(v,w), v.x * w.x);\n\n    vec2 d = max(qv,0.0) * qv \/ vv;\n\n    return sqrt(dot(w,w) - max(d.x, d.y)) * sign(max(q.y * v.x - q.x * v.y, w.y));\n}\n\nfloat sd_hex_prism(vec3 p, vec2 h)\n{\n    vec3 q = abs(p);\n    return max(q.z - h.y, max((q.x * 0.866025 + q.y * 0.5), q.y) - h.x);\n}\n\nfloat sd_tri_prism(vec3 p, vec2 h)\n{\n    vec3 q = abs(p);\n    return max(q.z - h.y, max(q.x * 0.866025 + p.y * 0.5, -p.y) - h.x * 0.5);\n}\n\nfloat sd_capsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba) \/ dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nfloat ud_triangle(vec3 p, vec3 a, vec3 b, vec3 c)\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n            (sign(dot(cross(ba, nor), pa)) +\n             sign(dot(cross(cb, nor), pb)) +\n             sign(dot(cross(ac, nor), pc)) < 2.0)\n            ?\n            min(min(\n                    dot2(ba * clamp(dot(ba, pa) \/ dot2(ba), 0.0, 1.0) - pa),\n                    dot2(cb * clamp(dot(cb, pb) \/ dot2(cb), 0.0, 1.0) - pb)),\n                dot2(ac * clamp(dot(ac, pc) \/ dot2(ac), 0.0, 1.0) - pc))\n            :\n            dot(nor, pa) * dot(nor, pa) \/ dot2(nor));\n}\n\nfloat ud_quad(vec3 p, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross( ba, ad );\n\n    return sqrt(\n            (sign(dot(cross(ba,nor),pa)) +\n             sign(dot(cross(cb,nor),pb)) +\n             sign(dot(cross(dc,nor),pc)) +\n             sign(dot(cross(ad,nor),pd)) < 3.0)\n            ?\n            min(min(min(\n                        dot2(ba * clamp(dot(ba, pa) \/ dot2(ba), 0.0, 1.0) - pa),\n                        dot2(cb * clamp(dot(cb, pb) \/ dot2(cb), 0.0, 1.0) - pb)),\n                    dot2(dc * clamp(dot(dc, pc) \/ dot2(dc), 0.0, 1.0) - pc)),\n                dot2(ad * clamp(dot(ad, pd) \/ dot2(ad), 0.0, 1.0) - pd))\n            :\n            dot(nor, pa) * dot(nor, pa) \/ dot2(nor));\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ operations\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nDistanceField df_union(DistanceField d1, DistanceField d2)\n{\n    return (d1.distance <= d2.distance) ? d1 : d2;\n}\n\nfloat op_union(float d1, float d2)\n{\n    return min(d1, d2);\n}\n\nfloat op_smooth_union(float d1, float d2, float r)\n{\n    return smin(d1, d2, r);\n}\n\nfloat op_subtraction(float d1, float d2)\n{\n    \/\/ return (d1.distance >= -d2.distance) ? d1 : d2;\n    return max(d1, -d2);\n}\n\nfloat op_intersection(float d1, float d2)\n{\n    \/\/ return (d1.distance >= d2.distance) ? d1 : d2;\n    return max(d1, d2);\n}\n\n\/*\nfloat op_repeat(vec3 p, vec3 c)\n{\n    vec3 q = mod(p, c) - 0.5 * c;\n    return primitve(q);\n}\n\n\/\/ rotation\/translation\nvec3 op_transform(vec3 p, mat4 m)\n{\n    vec3 q = invert(m) * p;\n    return primitive(q);\n}\n\nfloat op_scale(vec3 p, float s)\n{\n    return primitive(p \/ s) * s;\n}\n\nfloat op_displace(vec3 p)\n{\n    float d1 = primitive(p);\n    float d2 = displacement(p);\n    return d1 + d2;\n}\n\nfloat op_blend(vec3 p)\n{\n    float d1 = primitiveA(p);\n    float d2 = primitiveB(p);\n    return smin(d1, d2);\n}\n*\/\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ scene\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define SCENE_WHITE_PLASTIC 1\n#define SCENE_RED_PLASTIC 2\n#define SCENE_GOLD 3\n#define SCENE_FLOOR 4\n\nvoid df_material(vec3 pos, int id, inout Material mtl)\n{\n    if (id == SCENE_WHITE_PLASTIC)\n    {\n        mtl.ambient = vec3(0.0625, 0.0625, 0.0625);\n        mtl.specular = vec3(0.05, 0.05, 0.05);\n        mtl.diffuse = vec3(1.0, 1.0, 1.0) - mtl.specular;\n        mtl.m = 128.0;\n    }\n    else if (id == SCENE_RED_PLASTIC)\n    {\n        mtl.ambient = vec3(0.0625, 0.0625, 0.0625);\n        mtl.specular = vec3(0.05, 0.05, 0.05);\n        mtl.diffuse = vec3(1.0, 0.0, 0.0) - mtl.specular;\n        mtl.m = 128.0;\n    }\n    else if (id == SCENE_GOLD)\n    {\n        mtl.ambient = vec3(0.0625, 0.0625, 0.0625);\n        mtl.specular = vec3(1.022, 0.782, 0.344);\n        mtl.diffuse = vec3(0.0, 0.0, 0.0);\n        mtl.m = 8.0;\n    }\n    else if (id == SCENE_FLOOR)\n    {\n        float checker_size = 0.5;\n        float alpha = floor(pos.x \/ checker_size) + floor(pos.z \/ checker_size);\n        alpha = abs(alpha);\n        alpha -= 2.0 * floor(alpha \/ 2.0);\n\n        mtl.ambient = vec3(0.0625, 0.0625, 0.0625);\n        mtl.specular = vec3(0.05, 0.05, 0.05);\n        \/* mtl.diffuse = mix(vec3(0.95, 0.95, 0.95), vec3(0.25, 0.25, 0.25), alpha); *\/\n        mtl.diffuse = mix(vec3(0.25, 0.25, 0.95), vec3(0.95, 0.95, 0.25), alpha);\n        mtl.m = 128.0;\n    }\n    else\n    {\n        mtl.ambient = vec3(0.0625, 0.0625, 0.0625);\n        mtl.specular = vec3(0.05, 0.05, 0.05);\n        mtl.diffuse = vec3(1.0, 0.0, 1.0) - mtl.specular;\n        mtl.m = 128.0;\n    }\n}\n\nDistanceField df_scene(vec3 p)\n{\n    \/\/ Base chassis.\n    float chassis = op_smooth_union(\n        sd_sphere(p - vec3(0.0, 0.25, 0.0), 0.5),\n        \/\/sd_box(p, vec3(1.0, 0.2, 0.4)),\n        ud_round_box(p, vec3(1.0, 0.2, 0.6), 0.05),\n        0.1);\n    \/\/ Cut out wheel arcs.\n    chassis = op_subtraction(\n        chassis,\n        sd_capped_cylinder_z(p - vec3(-0.75, -0.2,  0.5), vec2(0.4, 0.2)));\n    chassis = op_subtraction(\n        chassis,\n        sd_capped_cylinder_z(p - vec3(-0.75, -0.2, -0.5), vec2(0.4, 0.2)));\n    chassis = op_subtraction(\n        chassis,\n        sd_capped_cylinder_z(p - vec3( 0.75, -0.2,  0.5), vec2(0.4, 0.2)));\n    chassis = op_subtraction(\n        chassis,\n        sd_capped_cylinder_z(p - vec3( 0.75, -0.2, -0.5), vec2(0.4, 0.2)));\n\n    float wheels = op_union(\n        op_union(\n            sd_torus82_z(p - vec3(-0.75, -0.2,  0.5), vec2(0.2, 0.1)),\n            sd_torus82_z(p - vec3(-0.75, -0.2, -0.5), vec2(0.2, 0.1))),\n        op_union(\n            sd_torus82_z(p - vec3( 0.75, -0.2,  0.5), vec2(0.2, 0.1)),\n            sd_torus82_z(p - vec3( 0.75, -0.2, -0.5), vec2(0.2, 0.1))));\n\n    DistanceField d1 = DistanceField(chassis, SCENE_WHITE_PLASTIC);\n    DistanceField d2 = DistanceField(wheels, SCENE_GOLD);\n\n    DistanceField d3 = DistanceField(sd_sphere(p - vec3(0.75, 0.25, 0.0), 0.25), SCENE_RED_PLASTIC);\n    DistanceField d4 = DistanceField(sd_plane(p, vec4(0.0, 1.0, 0.0, 0.5)), SCENE_FLOOR);\n\n    return df_union(df_union(df_union(d1, d2), d3), d4);\n}\n\nint raymarch(vec3 ray_pos, vec3 ray_dir, out vec3 pos, out vec3 normal)\n{\n    float t = 0.0;\n    for (int i = 0; i < 64; ++i)\n    {\n        vec3 pt = ray_pos + ray_dir * t;\n        DistanceField df = df_scene(pt);\n        float h = df.distance;\n        if (h < 0.001)\n        {\n            vec3 x_axis = 0.001 * vec3(1.0, 0.0, 0.0);\n            vec3 y_axis = 0.001 * vec3(0.0, 1.0, 0.0);\n            vec3 z_axis = 0.001 * vec3(0.0, 0.0, 1.0);\n            normal.x = df_scene(pt + x_axis).distance - df_scene(pt - x_axis).distance;\n            normal.y = df_scene(pt + y_axis).distance - df_scene(pt - y_axis).distance;\n            normal.z = df_scene(pt + z_axis).distance - df_scene(pt - z_axis).distance;\n            normal = normalize(normal);\n            pos = pt;\n            return df.id;\n        }\n\n        t += h;\n    }\n\n    return 0;\n}\n\nfloat raymarch_shadow(vec3 ray_pos, vec3 ray_dir, float t_min, float t_max, float resolution)\n{\n    float result = 1.0;\n    float t = t_min;\n    for (int i = 0; i < 64; ++i)\n    {\n        if (t >= t_max) break;\n\n        vec3 pt = ray_pos + ray_dir * t;\n        float h = df_scene(pt).distance;\n        if (h < 0.001)\n        {\n            return 0.0;\n        }\n\n        result = min(result, resolution * h \/ t);\n        t += h;\n    }\n\n    return result;\n}\n\n#define PI 3.14159265359\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    float x_angle = PI \/ 6.0;\n    vec3 camera_pos = vec3(0.0, cos(-PI \/ 2.0 + x_angle), sin(-PI \/ 2.0 + x_angle));\n    vec3 camera_dir = vec3(0.0, cos(PI \/ 2.0 + x_angle), sin(PI \/ 2.0 + x_angle));\n    vec3 camera_up = vec3(0.0, cos(x_angle), sin(x_angle));\n\n    \/\/ vec3 light_pos = vec3(1.0, 1.0, -1.0);\n    \/\/ vec3 light_pos = vec3(cos(2.0 * PI * iGlobalTime), sin(2.0 * PI * iGlobalTime), -1.0);\n    vec3 light_pos = 2.0 * vec3(cos(2.0 * PI * iGlobalTime \/ 2.0), 1.0, sin(2.0 * PI * iGlobalTime \/ 2.0));\n\n    \/\/ 2x2 anti-aliasing.\n    const int aa_count = 2;\n    for (int aa_x = 0; aa_x < aa_count; ++aa_x)\n    {\n        for (int aa_y = 0; aa_y < aa_count; ++aa_y)\n        {\n            vec2 aa_sample_offset = vec2(aa_x, aa_y) \/ float(aa_count);\n            vec2 uv = (fragCoord.xy + aa_sample_offset) \/ iResolution.xy;\n            uv = 2.0 * uv - 1.0;\n            uv.x *= iResolution.x \/ iResolution.y;\n\n            vec3 ray_pos = camera_pos + uv.x * cross(camera_up, camera_dir) + uv.y * camera_up;\n            vec3 ray_dir = camera_dir;\n            vec3 pos, normal;\n            float t;\n\n            int id = raymarch(ray_pos, ray_dir, pos, normal);\n            if (id > 0)\n            {\n                Material mtl;\n                df_material(pos, id, mtl);\n\n                vec3 l = normalize(light_pos - pos);\n                vec3 v = normalize(camera_pos - pos);\n                vec3 h = normalize(v + l);\n                float n_l = max(0.0, dot(normal, l));\n                float n_h = max(0.0, dot(normal, h));\n\n                float shadow = raymarch_shadow(light_pos, -l, 0.0, 0.9 * distance(light_pos, pos), 32.0);\n\n                \/\/ Lambertian BRDF diffuse + Blinn-Phong BRDF specular\n                fragColor.rgb += mtl.ambient + shadow * n_l * (mtl.diffuse + (mtl.m + 2.0) \/ 8.0 * pow(n_h, mtl.m) * fresnel(mtl.specular, l, h));\n            }\n            \/\/ else\n            \/\/ {\n            \/\/     fragColor.rgb += vec3(0.0, 0.0, 0.0);\n            \/\/ }\n        }\n    }\n\n    fragColor.rgb \/= float(aa_count * aa_count);\n\n    \/\/ Linear to gamma (sRGB) color space conversion (approximated).\n    float inv_gamma = 1.0 \/ 2.2;\n    fragColor.rgb = pow(fragColor.rgb, vec3(inv_gamma, inv_gamma, inv_gamma));\n}\n","name":"","description":"","type":"image"}]}}