{"Shader":{"ver":"0.1","info":{"id":"lt23DR","date":"1428292559","viewed":824,"name":"FastBlur & Gamma","username":"jocopa3","description":"Just a really terrible fast blur function with options for adding gamma.","likes":0,"published":3,"flags":0,"tags":["blur","gamma","fastblur"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/*\n * Not supposed to be anything fancy, just a demonstration of a horrible\n * blur function with and without using gamma.\n *\/\n\n\/\/ Set useGamma to 1 to use gamma, and 0 to not use gamma\n#define useGamma 1\n#define gammaAmount 2.2\n\nvec2 p = vec2(1.0 \/ iResolution.x, 1.0 \/ iResolution.y); \/\/ Size of 1 pixel\nconst float s = 0.8660254037844; \/\/ sqrt(3)\/2\n\n\/\/ Basic gamma correction function\nvec3 gamma(vec3 color, float amount)\n{\n    return pow(color, vec3(1.0 \/ amount));\n}\n\n\/\/ Creates the image on the screen\nvec3 map(vec2 pos)\n{\n    \/\/ I'm too lazy to change the coordinates, so I just invert the position\n    pos.y = 1.0 - pos.y;\n    \n    \/\/ Using some hacky dot-product magic to drop the costly sqrt for speed gains\n    vec2 aa = vec2(pos.x - 0.5, pos.y + 0.54);\n    float a = dot(aa, aa);\n    vec2 bb = vec2(pos.x - (-s + 0.5), pos.y - (1.0 - s));\n    float b = dot(bb, bb);\n    vec2 cc = vec2(pos.x - (s + 0.5), pos.y - (1.0 - s));\n    float c = dot(cc, cc);\n    \n    \/\/ Next three lines detect which region the given pos falls in\n    vec2 abc = max(sign(vec2(a, a) - vec2(b, c)), 0.0);\n    vec2 bac = max(sign(vec2(b, b) - vec2(a, c)), 0.0);\n    vec2 cab = max(sign(vec2(c, c) - vec2(a, b)), 0.0);\n    \n    \/\/ Returns blue, red, or green depending on the region the given pos falls in\n    return abc.x * abc.y * vec3(0.0, 0.0, 1.0) + \n        bac.x * bac.y * vec3(1.0, 0.0, 0.0) + \n        cab.x * cab.y * vec3(0.0, 1.0, 0.0);\n}\n\n\/* \n * An un-wrapped horizontal\/vertical blur method\n * The reason I have it un-wrapped is because normal blurring with a\n * for-loop runs at 1 FPS on my PC, whereas this runs at a more respectible 17 FPS\n * (My GPU is very old, from about 2009; recently saving up for a newer rig)\n *\n * My lazyness is apparent here too, as this function is adapted from this\n * article: \n * http:\/\/xissburg.com\/faster-gaussian-blur-in-glsl\/\n *\/\nvec3 blur(vec2 uv, float scale)\n{\n    vec3 Color = vec3(0.0);\n    \n    \/\/ Horizontal Blur\n    Color += map(vec2(uv.x - 7.0 * scale * p.x, uv.y)) * 0.0044299121055113265;\n\tColor += map(vec2(uv.x - 6.0 * scale * p.x, uv.y)) * 0.00895781211794;\n\tColor += map(vec2(uv.x - 5.0 * scale * p.x, uv.y)) * 0.0215963866053;\n\tColor += map(vec2(uv.x - 4.0 * scale * p.x, uv.y)) * 0.0443683338718;\n\tColor += map(vec2(uv.x - 3.0 * scale * p.x, uv.y)) * 0.0776744219933;\n\tColor += map(vec2(uv.x - 2.0 * scale * p.x, uv.y)) * 0.115876621105;\n\tColor += map(vec2(uv.x - 1.0 * scale * p.x, uv.y)) * 0.147308056121;\n\tColor += map(uv) * 0.159576912161;\n\tColor += map(vec2(uv.x + 1.0 * scale * p.x, uv.y)) * 0.147308056121;\n\tColor += map(vec2(uv.x + 2.0 * scale * p.x, uv.y)) * 0.115876621105;\n\tColor += map(vec2(uv.x + 3.0 * scale * p.x, uv.y)) * 0.0776744219933;\n\tColor += map(vec2(uv.x + 4.0 * scale * p.x, uv.y)) * 0.0443683338718;\n\tColor += map(vec2(uv.x + 5.0 * scale * p.x, uv.y)) * 0.0215963866053;\n\tColor += map(vec2(uv.x + 6.0 * scale * p.x, uv.y)) * 0.00895781211794;\n\tColor += map(vec2(uv.x + 7.0 * scale * p.x, uv.y)) * 0.0044299121055113265;\n    \n    \/\/ Vertical Blur\n    Color += map(vec2(uv.x, uv.y - 7.0 * scale * p.y)) * 0.0044299121055113265;\n\tColor += map(vec2(uv.x, uv.y - 6.0 * scale * p.y)) * 0.00895781211794;\n\tColor += map(vec2(uv.x, uv.y - 5.0 * scale * p.y)) * 0.0215963866053;\n\tColor += map(vec2(uv.x, uv.y - 4.0 * scale * p.y)) * 0.0443683338718;\n\tColor += map(vec2(uv.x, uv.y - 3.0 * scale * p.y)) * 0.0776744219933;\n\tColor += map(vec2(uv.x, uv.y - 2.0 * scale * p.y)) * 0.115876621105;\n\tColor += map(vec2(uv.x, uv.y - 1.0 * scale * p.y)) * 0.147308056121;\n\tColor += map(uv) * 0.159576912161;\n\tColor += map(vec2(uv.x, uv.y + 1.0 * scale * p.y)) * 0.147308056121;\n\tColor += map(vec2(uv.x, uv.y + 2.0 * scale * p.y)) * 0.115876621105;\n\tColor += map(vec2(uv.x, uv.y + 3.0 * scale * p.y)) * 0.0776744219933;\n\tColor += map(vec2(uv.x, uv.y + 4.0 * scale * p.y)) * 0.0443683338718;\n\tColor += map(vec2(uv.x, uv.y + 5.0 * scale * p.y)) * 0.0215963866053;\n\tColor += map(vec2(uv.x, uv.y + 6.0 * scale * p.y)) * 0.00895781211794;\n\tColor += map(vec2(uv.x, uv.y + 7.0 * scale * p.y)) * 0.0044299121055113265;\n\n\treturn Color;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    float sc = abs(sin(iGlobalTime)) * 15.0; \/\/ Scale for the blur\n\n#if (useGamma == 1)\n    fragColor.rgb = gamma(blur(uv, sc), gammaAmount);\n#else\n\tfragColor.rgb = blur(uv, sc);\n#endif\n}","name":"","description":"","type":"image"}]}}