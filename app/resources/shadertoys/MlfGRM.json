{"Shader":{"ver":"0.1","info":{"id":"MlfGRM","date":"1436652916","viewed":1148,"name":"sampler","username":"w23","description":"missed solskogen 2015 deadline <img src=\"\/img\/emoticonSad.png\"\/>","likes":39,"published":3,"flags":8,"tags":["raymarch","voxels","audio"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"const vec2 E=vec2(1.,0.);\nconst float BPM = 140.;\nconst float QL = 60. \/ (BPM * 4.);\nconst float END = 60. \/ QL;\nfloat hash(float x){return fract(sin(x)*265871.1723);}\nfloat hash(vec2 x){return hash(dot(x,vec2(11.,313.)));}\nfloat hash(vec3 x){return hash(dot(x,vec3(3.2,57.55,117.234)));}\nvec3 hash3(vec3 x) {\n    return vec3(hash(x),hash(x.yz),hash(x.x));\n}\n\nfloat noise(vec2 v) {\n    vec2 V = floor(v);v-=V;\n    return mix(mix(hash(V),hash(V+E.xy),v.x),mix(hash(V+E.yx),hash(V+E.xx),v.x),v.y);\n}\n\nfloat noise(vec3 v) {\n    vec3 V = floor(v);v-=V;\n    return mix(mix(\n    \tmix(hash(V),      hash(V+E.xyy),v.x),\n        mix(hash(V+E.yxy),hash(V+E.xxy),v.x),v.y),\n        mix(mix(hash(V+E.yyx),hash(V+E.xyx),v.x),\n        mix(hash(V+E.yxx),hash(V+E.xxx),v.x),v.y),v.z);\n}\n\n\nfloat time = iGlobalTime;\nfloat line = floor(time \/ QL);\nconst vec3 SZ = vec3(24.);\nvec3 SUND = normalize(vec3(1.,.8,.3));\nconst vec3 SUNC = vec3(1.,.9,.7);\nconst vec3 SKYC = vec3(.22, .43, .76);\n\/\/const vec3 SUNC = vec3(1., .9, .5);\/\/vec3(1.,.9,.7);\n\/\/const vec3 SKYC = vec3(101.,133.,162.) \/ 255.;\/\/vec3(.22, .43, .76);\n\nvec3 SKYD = reflect(-SUND, E.yxy);\n#define STEPS 64\n\nfloat max3(vec3 v){return max(v.x,max(v.y,v.z));}\n\nmat3 m_orient(vec3 fwd, vec3 up) {\n    fwd = normalize(fwd);\n    vec3 right = normalize(cross(fwd, up));\n    up = normalize(cross(right, fwd));\n    return mat3(right, up, -fwd);\n}\n\nfloat d_box(vec3 a, vec3 sz){return max3(abs(a)-sz);}\nvec3 o_rpt(vec3 a, vec3 sp){return mod(a, sp) - sp*.5;}\n\nfloat w_gnd(vec3 a) {\n    float d = 0.;\n    if (time < 192. * QL) d = d_box(a-vec3(0.,.5,0.), vec3(SZ.x,1.,SZ.z));\n    if (time > 160. * QL)\n        d = mix(d, 3. + a.y -\n                noise(.08*(a.xz+vec2(.3,.7)*time))*3., smoothstep(160.*QL,192.*QL,time));\n    return d;\n}\n\nmat3 rotX(float a) {\n    float c = cos(a), s = sin(a);\n    return mat3(1.,0.,0.,0.,c,s,0.,-s,c);\n}\nmat3 rotY(float a) {\n    float c = cos(a), s = sin(a);\n    return mat3(c,0.,-s,0.,1.,0.,s,0.,c);\n}\n\nfloat smtime(float la, float lb, float t) {\n    return smoothstep(la * QL, lb * QL, t);\n}\n\nfloat hc(vec3 C) {\n    vec3 ndc = normalize(C);\n    return pow(noise(ndc*7.),4.);\n}\n\nfloat w_cube(vec3 a) {\n    float size =\n        mix(22.,16.,smtime(190.,194.,time));\n    float d = d_box(a, vec3(size));\n    if (line > 262.) {\n        float h = hc(a);\n        d += mix(1., h*8., step(h,.1)) *\n                smtime(262.,266.,time);\n        \n    }\n    return d;\n}\n\nfloat w_clouds(vec3 a) {\n    if (time < 62. * QL)\n        return 2.;\n    float t = line * .125;\n    mat3 m = rotX(t*.17) * rotY(t*.23);\n    float nz = pow(noise(vec3(a*m*.29)), 5.);\n    return mix(2.,\n               max(max(-d_box(a, vec3(19.)),d_box(a, vec3(24.))), .16 - nz),\n               smtime(62.,66.,time));\n}\n\nvec3 ga(vec3 a) {\n    if (line > 308.) {\n        \/\/vec3 na = a * .125 + vec3(0., 16., -24.+3.*(time - 308.*QL));\n        float t = time * .26 - 6.;\n        vec3 na = a * .25 + vec3(sin(t*.9)*11., 16., 12.*cos(t));\n        return mix(a, na, smtime(308.,324.,time));\n    }\n    return a;\n}\n\nfloat w(vec3 a) {\n    vec3 oa = a;\n    float d;\n    \n    a = ga(a);\n    \n    d = w_cube(a);\n    d = min(d, w_clouds(a));\n    \n    \/\/d += .001;\n    return max(d, d_box(oa, vec3(SZ-1.)));\n}\n\n\nconst vec3 CGRASS = vec3(.23,.81,.31);\nconst vec3 CWATER = vec3(.13,.48,.83);\nconst vec3 CNOISE = vec3(.8);\n\nconst float MGROUND = 0.;\nconst float MGRASS = 1.;\nconst float MNOISE = 2.;\nconst float MBLD0 = 3.;\n\nvoid mat(in vec3 C, in vec3 p, inout vec3 n, out vec3 c, out vec3 e) {\n    p = ga(p);\n    vec3 CC = C;\n    C = ga(C);\n    c = vec3(.5);\n    e = vec3(.0);\n    if (time < 190. * QL) {\n        c = vec3(.5);\n        return;\n    }\n    \n    float wcb = w_cube(C);\n    float wcl = w_clouds(C);\n    \n    if (wcb < wcl) {\n        if (max3(abs(C)) < 14.) {\n            c = vec3(.8,.7,.3) * (.77 + .23 * noise(floor(p*16.)));\n            return;\n        }\n        float tk = smtime(216.,218.,time);\n        float kn = .77 + .23 * noise(floor(p*16.));\n        c = mix(c, CGRASS * kn, tk);\n        tk = smtime(232.,234.,time);\n        float h = hc(C);\n        c = mix(c, CWATER * kn, tk * step(.1,h));\n    } else {\n        float tk = smtime(200.,202.,time);\n        c = mix(c, vec3(1.) * (.8 + .2 * noise(floor(p*4.)+line*17.)), tk);\n        e = mix(e, vec3(.5), tk);\n    }\n}\n\nvec3 vminc(vec3 v){return step(v.xyz,v.yzx)*step(v.xyz,v.zxy);}\nvec3 vmaxc(vec3 v){return step(v.yzx,v.xyz)*step(v.zxy,v.xyz);}\n\nvec4 tracegrid(in vec3 O, in vec3 D, out vec3 N, out vec3 PCI){\n    vec3 ci = floor(O);\n    PCI = ci;\n\tvec3 Di = 1. \/ D, Ds = sign(D);\n    vec3 sd = (ci - O + .5 + Ds * .5) * Di;\n\t\n    vec3 n = vec3(0.);\n    vec4 ret = vec4(-1.);\n\tfor (int i = 0; i < STEPS; i++) {\n        float ww = w(ci + .5);\n        if (ww < 0.) {            \n\t\t    N = - n * Ds;\n\t\t    sd = (ci - O + .5 - Ds * .5) * Di;\n            ret.xyz = ci + .5;\n            ret.w = max(sd.x,max(sd.y,sd.z));\n            break;\n        }\n        PCI = ci;\n\t\tn = vminc(sd);\n        sd += n * Ds * Di;\n        ci += n * Ds;\n        if (any(greaterThan(abs(ci),SZ))) break;\n\t}\n    \n    return ret;\n}\n\nfloat occlude(vec3 pci, vec3 p, vec3 n) {\n    vec3 nc = sign(n)*vmaxc(abs(n));\n    \/\/vec3 nc = abs(n);\n    vec3 P = pci + .5;\n    p = 2.*(P-p);\n    float o = 0.;\n    vec3 s1 = nc.yzx, s2 = nc.zxy;\n    vec2 uv = vec2(dot(p,s1),dot(p,s2));\n    \/\/if (max(abs(uv.x),abs(uv.y))>.97) return vec3(0.);\n    vec4 s = step(vec4(w(P+s1),w(P+s2),w(P-s1),w(P-s2)),E.yyyy),\n         c = step(vec4(w(P+s1+s2),w(P+s1-s2),w(P-s1+s2),w(P-s1-s2)),E.yyyy);\n    \n    o += c.x * (1. - uv.x) * (1. - uv.y) * (1. - s.x) * (1. - s.y);\n    o += c.y * (1. - uv.x) * (1. + uv.y) * (1. - s.x) * (1. - s.w);\n    o += c.z * (1. + uv.x) * (1. - uv.y) * (1. - s.z) * (1. - s.y);\n    o += c.w * (1. + uv.x) * (1. + uv.y) * (1. - s.z) * (1. - s.w);\n    o *= .5;\n\n    o += s.x * (1. - uv.x);\n    o += s.y * (1. - uv.y);\n    o += s.z * (1. + uv.x);\n    o += s.w * (1. + uv.y);\n        \n    \/\/return 1. - o \/ 6.;\n    return clamp(o * .125,0.,1.);\n}\n\nvec3 shade(\n    in vec3 n,\n\tin vec3 e,\n\tin vec3 mc,\n\tin vec3 ld,\n    in vec3 lc)\n{\n    return max(0.,dot(n,ld)) * mc * lc;\n}\n\nvec4 bg(vec3 D) {\n    float sk = max(0.,dot(SUND,D));\n    return vec4(SKYC + SUNC * pow(sk,180.), sk*.9);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    \/\/   0 -  64 D\n    \/\/  64 - 192 D P\n    \/\/ 192 - 320 D P B\n    \/\/ 320 - 448   P B L\n    \/\/ 448 - 560 D P B L\n    \n#if 0\n    \/\/const float LA = 192., LB = 336.;\n    const float LA = 304., LB = 368.;\n    time = (LA + mod(time \/ QL, LB-LA)) * QL;\n    line = floor(time \/ QL);\n#endif\n    \n    #define LN(a,b) (b > line && line >= a)\n    if LN(512.,516.) {\n        float t = time - QL * 512.;\n      \ttime = QL * 512. + mod(t,QL*.5);\n    }\n    \n    if LN(524.,532.) {\n        float t = time - QL * 524.;\n      \ttime = QL * 524. - t;\n    }\n    \n    if LN(536.,540.) {\n        float t = time - QL * 536.;\n      \ttime = QL * 536. - mod(t,QL*.5);\n    }\n    \n    time = clamp(time, 0., 560. * QL);\n    line = clamp(line, 0., 560.);\n    \n    if (line > 544.) {\n        float dl = 560. - 544.;\n        float t = time - QL*544.;\n        float T = dl * QL;\n        time = QL * 544. + t * (1. - t \/ (2. * T));\n    }\n\n    if (time > 532. * QL) time -= 16. * QL;\n    \n    line = floor(time \/ QL);\n    \n\tvec2 uv = fragCoord.xy \/ iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x\/iResolution.y;\n    \n    float R = mix(200.,64.,smoothstep(0.,QL*64.,time));\n    float RF = R + 23.;\n    \n    \n    float a = 2.*sin(time*.3), b = sin(time*.2+3.);\n    if (iMouse.z > 0.) {\n        a = iMouse.x \/ iResolution.x * 9.;\n        b = (.5 - iMouse.y \/ iResolution.y) * 64.;\n    }\n    float htk = smtime(192.,320.,time);\n    \n    vec3 O = vec3(R*cos(a),\n                  SZ.y * 2. * (htk - 1.) + 16. * (b + htk),\n                  R*sin(a));\n    vec3 D = m_orient(-O, vec3(0.,.9+.1*sin(time*.3),cos(time*.7)*.1)) * normalize(vec3(uv,-2.));\n    float ls = 0.;\n    \n    if (O.x > SZ.x && D.x < 0.) ls = max(ls, (SZ.x - O.x) \/ D.x);\n    if (O.y > SZ.y && D.y < 0.) ls = max(ls, (SZ.y - O.y) \/ D.y);\n    if (O.z > SZ.z && D.z < 0.) ls = max(ls, (SZ.z - O.z) \/ D.z);\n    if (O.x < -SZ.x && D.x > 0.) ls = max(ls, (- SZ.x - O.x) \/ D.x);\n    if (O.y < -SZ.y && D.y > 0.) ls = max(ls, (- SZ.y - O.y) \/ D.y);\n    if (O.z < -SZ.z && D.z > 0.) ls = max(ls, (- SZ.z - O.z) \/ D.z);\n    \n    vec4 bc = bg(D);\n    vec3 color = bc.rgb;\n    \n    vec3 N, CI;\n    vec4 x = tracegrid(O+D*ls, D, N, CI);\n    if (x.w > 0.)\n    {\n        ls += x.w;\n        vec3 p = O + D * ls;\n        vec3 mc, me;\n        mat(x.xyz, p, N, mc, me);\n        \/\/mc = vec3(.5);\n        float o = occlude(CI,p,N);\n        \/\/o = 1. - o*o;\n        o = 1. - o;\n        \n        color = me;\n        \/\/color += .5 * mc * o;\n        color += o * mc * bg(N).rgb;\/\/normalize(N+.1*hash3(N+time))).rgb;\n        \/\/color += occlude(CI,p,N) * shade(N,D,mc,SKYD,SKYC);\n        \n        vec3 _n, _c;\n        vec4 shd = tracegrid(p + N * .1, SUND, _n, _c);\n        color += step(shd.w, 0.) * shade(N,D,mc,SUND,SUNC);\n        \n        color = mix(color, bc.rgb, clamp(pow(ls\/RF, 2.),0.,1.));\n    }\n    \n    color += SUNC * pow(bc.a,8.);\n    \n    fragColor = vec4(sqrt(color), 1.);\n}","name":"","description":"","type":"image"},{"inputs":[],"outputs":[{"channel":"0"}],"code":"const float BPM = 140.;\nconst float QL = 60. \/ (BPM * 4.);\nconst float END = 60. \/ QL;\nfloat hash(float x){return fract(sin(x)*265871.1723);}\n\nconst float pi2 = 3.1415926 * 2.;\nfloat p212 = pow(2., 1.\/12.);\nfloat ntof(float n){return 440.*pow(p212,n-48.);}\n\nfloat osc_noise(float p) {\n    p *= 20000.;\n    float F = floor(p), f = fract(p);\n    return mix(hash(F), hash(F+1.), f);\n}\nfloat osc_sine(float p){return sin(p*pi2);}\nfloat osc_saw(float p){return p*2.-1.;}\nfloat osc_square(float p,float x){return -1.+2.*step(x,p);}\nfloat osc_sinefm(float pc, float pm, float b){return sin(pc*pi2+b*sin(pm*pi2));}\nfloat osc_tri(float p, float x) {\n    float a = smoothstep(0., x, p), b = smoothstep(1., x, p);\n    return (a * b) * 2. - 1.;\n}\n\nfloat phase_freq(float t, float f){return fract(f*t);}\n\nfloat env_ar(float t, float a, float r){return smoothstep(0.,a,t)*smoothstep(r,0.,t-a);}\nfloat env_asr(float t, float ts, float a, float r) {\n    return smoothstep(0.,a,t)*smoothstep(r,0.,t-a-ts);\n}\n\n\nfloat kick(float t) {\n    float S = 0.;\n    {\n    \tfloat kf = smoothstep(.13, .0, t);kf *= kf * kf;\n    \tfloat s = osc_sine(phase_freq(t, (30. + kf * 200.)));\n    \tfloat ka = smoothstep(.3, .0, t);\n    \tfloat a = ka;\/\/(ka * ka);\n        S += s * a;\n    }\n    {\n    \tfloat s = osc_sine(phase_freq(t,ntof(12.)));\n    \tfloat ka = smoothstep(.3, .0, t);\n    \tfloat a = ka;\/\/(ka * ka);\n        S += s * a * .3;\n    }\n    {\n    \tfloat kf = smoothstep(.015, .0, t);kf *= kf * kf;\n    \tfloat s = osc_noise(t*phase_freq(t, (40. + kf * 200.)));\n    \tfloat ka = smoothstep(.02, .0, t);\n    \tfloat a = .3 * (ka * ka);\n        S += s * a;\n    }\n    return S;\n}\n\nfloat hh(float gt, float t) {\n    float S = 0.;\n    {\n    \tfloat s = osc_square(phase_freq(t,sin(gt) + ntof(36.)),.5);\n    \tfloat ka = smoothstep(.23, .0, t);\n    \tfloat a = (ka * ka);\n        S += s * a * .5;\n    }\n    {\n    \tfloat s = osc_noise(t*(.1 + hash(floor(gt*8.))));\n    \tfloat ka = smoothstep(.06, .0, t);\n    \tfloat a = (ka * ka);\n        S += s * a;\n    }\n    return 1.32 * pow(S, 3.);\n}\n\nfloat snare(float gt, float t) {\n    float S = 0.;\n    {\n    \tfloat s = osc_saw(phase_freq(t,sin(gt) + ntof(23.)));\n    \tfloat ka = smoothstep(.3, .0, t);\n    \tfloat a = (ka * ka);\n        S += s * a * .2;\n    }\n    {\n    \tfloat s = osc_noise(t*(.1 + hash(floor(gt*3.))));\n    \tfloat ka = smoothstep(.3, .0, t);\n    \tfloat a = (ka * ka);\n        S += s * a;\n    }\n    return 4. * pow(S, 3.);\n}\n\n#define PTDECL(l) const float PT=QL*l;float pn=floor(t\/PT),pt=mod(t,PT),s=0.;\n#define QTT(n) (float(n)*QL)\n\nfloat note1(float gt, float t, float PT, float b, float n) {\n    t -= b;\n    if (t < 0.) t += PT;\n    float p = phase_freq(t,ntof(n));\n    float s = 0.;\n\t\/\/s += (.03+.02*sin(gt*1.7)) * osc_square(p, .5+.4*sin(gt));\n\ts += .3 * osc_sine(p);\n    s += .503 * osc_tri(p, .5+.3*sin(gt));\n    return s * env_ar(t,.001,1.);\n}\n\nfloat ptr0(float t) {\n    PTDECL(32.);\n#define NOTE(p,n) s+=note1(t,pt,PT,QTT(p),n+12.);\n    NOTE(0, 48.);\n    NOTE(6, 43.);\n    NOTE(8, 46.);\n    NOTE(12, 41.);\n    NOTE(15, 46.);\n#undef NOTE\n    return s;\n}\n\n\nfloat ptr1(float t) {\n    PTDECL(32.);\n#define NOTE(p,n) s+=note1(t,pt,PT,QTT(p),n+12.);\n    NOTE(0, 48.);\n    NOTE(6, 43.);\n    NOTE(8, 46.);\n    NOTE(12, 41.);\n    NOTE(15, 46.);\n    NOTE(16, 48.);\n    NOTE(22, 43.);\n    NOTE(24, 46.);\n    NOTE(28, 41.);\n    NOTE(30, 46.);\n#undef NOTE\n    return s;\n}\n\nfloat note2(float gt, float t, float PT, float b, float n) {\n    t -= b;\n    if (t < 0.) t += PT;\n    float p = phase_freq(t,ntof(n));\n    float s = 0.;\n\t\/\/s += .3 * osc_sine(p);\n    s += .3 * osc_sinefm(phase_freq(t,ntof(n-12.)), p, 3.+sin(gt*4.));\n    s += .4 * osc_tri(p, .15);\/\/.5 + .4 * sin(gt*.9));\n    return .7*s * env_ar(t,.04,2.);\n}\n\nfloat pat_v2(float t) {\n    PTDECL(64.);\n#define NOTE(p,n) s+=note2(t,pt,PT,QTT(p*2),n);\n    NOTE(0, 48.);\n    NOTE(8, 46.);\n    NOTE(15, 51.);\n    NOTE(22, 43.);\n    NOTE(28, 41.);\n#undef NOTE\n    return s;\n\n}\n\nfloat pat_snare0(float t) {\n    PTDECL(32.);\n#define SN(p) {float tt=pt-QTT(p);if(tt>=0.)s+=snare(t,tt);}\n    SN(8);\n    SN(24);\n#undef SN    \n    return s;\n}\n\n#define HH(p) {float tt=pt-QTT(p);if(tt>=0.)s+=hh(t,tt);}\nfloat pat_hh0(float t){PTDECL(2.);HH(0);return s;}\nfloat pat_hh1(float t) {\n    PTDECL(32.); HH(11); HH(15); HH(25); HH(29);\n    return s;\n}\n#undef HH\n\n#define KICK(p) {float tt=pt-QTT(p);if(tt>=0.)s+=kick(tt);}\nfloat pat_kick0(float t) {\n    PTDECL(32.);\n    KICK(0);\n    KICK(6);\n    KICK(13);\n    KICK(16);\n    KICK(22);\n    return s;\n}\n\nfloat pat_kick1(float t) {\n    PTDECL(32.);\n    KICK(27);\n    KICK(30);\n    return s;\n}\n#undef KICK\n\nfloat busn(float gt, float t, float PT, float b, float e, float n) {\n    t -= b; e -= b;\n    if (t < 0.) {t += PT;}\n    float p = phase_freq(t,ntof(n));\n    float s = 0.;\n    s += osc_tri(p, .5 + .4 * sin(gt*3.));\n    s += 2.*osc_tri(phase_freq(t,ntof(n-12.)), .2 + .1 * sin(gt*2.3));\n    s += 2.*osc_sine(phase_freq(t,ntof(n-12.)));\n    s += osc_sinefm(p, phase_freq(t+313.,ntof(n-12.)), 5.+3.3*sin(gt*4.));\n    return s * env_asr(t,e,.01,.1);\n}\n\n\nfloat bus(float t) {\n\tPTDECL(64.)\n#define NOTE(p,pe,n) s+=busn(t,pt,PT,QTT(p),QTT(pe),n-12.);\n    NOTE( 0, 16, 32.);\n    NOTE(16, 32, 34.);\n    NOTE(32, 64, 29.);\n#undef NOTE\n    return s;\n}\n\nvec2 pptr0(float t) {\n  \tfloat doff = QL*12., dk = .5;\n  \treturn .4 *\n      \t( vec2(ptr0(t),        ptr0(t+.001*sin(1.3*t)))\n       \t+ vec2(ptr0(t-doff),   ptr0(t+.001*sin(2.1*(t-doff)))) * dk\n       \t+ vec2(ptr0(t-doff*2.),ptr0(t+.003*sin(3.7*(t-doff*2.)))).yx * dk * dk\n    );\n}\n\nvec2 pptr1(float t) {\n  \tfloat doff = QL*12., dk = .5;\n  \treturn .4 *\n      \t( vec2(ptr1(t),        ptr1(t+.001*sin(1.3*t)))\n       \t+ vec2(ptr1(t-doff),   ptr1(t+.001*sin(2.1*(t-doff)))) * dk\n       \t+ vec2(ptr1(t-doff*2.),ptr1(t+.003*sin(3.7*(t-doff*2.)))).yx * dk * dk\n    );\n}\n\nvec2 synth(float t) {\n    float line = floor(t \/ QL);\n    vec2 s = vec2(0.);\n    float tt = t;\n    \n#define LN(a,b) (b > line && line >= a)\n    if LN(0.,16.) {\n        s += pptr0(t);\n    }\n    if (LN(16.,320.) || LN(448.,560.)) {\n        s += pptr1(t);\n    }\n        \n    if LN(432.,448.) {\n        float dt = t - QL*432.;\n        tt = QL*448. - dt;\n        s += smoothstep(0.,QL*16.,dt) * pptr1(t);\n    }\n    \n    if LN(320.,560.) {\n        s += .8*vec2(pat_v2(tt),pat_v2(tt+.003));\n    }\n\n    \/*if LN(60.,64.) {\n        float dt = t - QL*60.;\n        tt = QL*64. - dt;\n        s += 1.4 * vec2(pat_kick0(tt-.002*sin(t*1.11)),pat_kick0(tt));\n    }*\/\n    if LN(64.,560.) {\n        s += .23 * vec2(pat_hh0(t-.002*sin(t*1.11)),pat_hh0(t));\n        s += .23 * vec2(pat_hh1(t-.002*sin(2.+t*1.11)),pat_hh1(t));\n    \ts += .23 * vec2(pat_snare0(t-.002*sin(3.+t*1.11)),pat_snare0(t));\n    \ts += 1.4 * vec2(pat_kick0(t-.002*sin(t*1.11)),pat_kick0(t));\n    }\n    \n    if LN(160.,560.) {\n        s += 1.4 * vec2(pat_kick1(t-.002*sin(t*1.11)),pat_kick1(t));\n    }\n    \n    if LN(192.,560.) {\n    \ts += .27 * vec2(bus(t));\n    }\n\n    return s;\n}\n\nvec2 mainSound(float time) {\n    float line = floor(time \/ QL);\n    float a = 1.;\n    \n#if 0\n    const float LA = 304., LB = 368.;\n    time = (LA + mod(time \/ QL, LB-LA)) * QL;\n    line = floor(time \/ QL);\n#endif\n\n    \n    if LN(316.,320.) {\n        float t = time - QL*316.;\n        time = QL*316. - t;\n    }\n    \n    if LN(512.,516.) {\n        float t = time - QL * 512.;\n      \ttime = QL * 512. + mod(t,QL*.5);\n    }\n    \n    if LN(524.,532.) {\n        float t = time - QL * 524.;\n      \ttime = QL * 524. - t;\n    }\n    \n    if LN(536.,540.) {\n        float t = time - QL * 536.;\n      \ttime = QL * 536. - mod(t,QL*.5);\n    }\n    \n    if (line > 544.) {\n        float dl = 560. - 544.;\n        float t = time - QL*544.;\n        float T = dl * QL;\n        time = QL * 544. + t * (1. - t \/ (2. * T));\n        \n        a = smoothstep(T, 0., t);\n    }\n    \n    vec2 s = a * synth(time);\n    return .39 * s;\n}","name":"","description":"","type":"sound"}]}}