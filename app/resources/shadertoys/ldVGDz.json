{"Shader":{"ver":"0.1","info":{"id":"ldVGDz","date":"1454187575","viewed":68,"name":"Simple Klein Bottle","username":"elias","description":"No 4D calculations involved. (lame, I know)","likes":4,"published":3,"flags":0,"tags":["mobius","klein","bottle"],"hasliked":0},"renderpass":[{"inputs":[{"id":14,"src":"\/presets\/tex14.png","ctype":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define S 512    \/\/ Steps\n#define P 0.001  \/\/ Precision\n#define R 10.    \/\/ Marching substeps\n#define D 100.   \/\/ Max distance\n\n#define T iGlobalTime\n#define PI 3.1415926\n#define TAU (PI*2.0)\n\n#define PERSPECTIVE\n\nstruct Ray { vec3 o, d; };\nstruct Camera { vec3 p, t; };\nstruct Hit { vec3 p; float t, d; };\n\nRay _ray;\nCamera _cam = Camera(vec3(0,0,4), vec3(0,0,0));\n\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\n\nfloat scene(vec3 p)\n{\n    p.y = p.y*-1.0-0.5;\n    \n    float y = sin((1.-p.y)\/3.*PI\/2.); y *= y;\n    \n    vec3 s = vec3(1,-1,0);\n    vec3 q = p+(1.-cos((1.-p.y)\/3.*PI))*s.xzz;\n    \n    \/\/ tube (hollow and solid)\n    float d1 = max(max(abs(length(q.xz)-0.5+0.25*y),q.y-1.0),-q.y-2.0);\n    float d2 = max(max(length(q.xz)-0.5+0.25*y,q.y-1.0),-q.y-2.0);\n    \n    q = p-s.zxz;\n    \n    \/\/ top\n    float d3 = max(abs(length(vec2(length(q.xz)-1.0,q.y))-0.5),-q.y);\n    \n    q = p;\n    \n    \/\/ middle\n    float d4 = max(max(max(abs(length(q.xz)-1.5+1.25*y),q.y-1.0),-q.y-2.0),-d2);\n    \n    q = p+s.xxz*vec3(1,2,0);\n    \n    \/\/ bottom\n    float d5 = max(abs(length(vec2(length(q.xy)-1.0,q.z))-0.25),q.y);\n\n    return min(d1,min(d3,min(d4,d5)));\n}\n\nvec3 getNormal(vec3 p)\n{\n\tvec2 e = vec2(P,0);\n    \n\treturn normalize(vec3(\n\t\tscene(p+e.xyy)-scene(p-e.xyy),\n\t\tscene(p+e.yxy)-scene(p-e.yxy),\n\t\tscene(p+e.yyx)-scene(p-e.yyx)\n\t));\n}\n\nHit march(Ray r)\n{\n    float t = 0.0, d;\n    \n    for(int i = 0; i < S; i++)\n    {\n        d = scene(r.o+r.d*t);\n        t += d\/R;\n        \n        if (d < P || t > D) { break; }\n    }\n    \n    return Hit(r.o+r.d*t, t, d);\n}\n\nRay lookAt(Camera cam, vec2 uv)\n{\n    vec3 dir = normalize(cam.t-cam.p);\n    vec3 right = normalize(cross(dir, vec3(0,1,0)));\n    vec3 up = cross(right, dir);\n\t\n    #ifdef PERSPECTIVE\n    return Ray(cam.p,normalize(right*uv.x + up*uv.y + dir));\n    #else\n    return Ray(cam.p+4.*(right*uv.x + up*uv.y), dir);\n    #endif\n}\n\nvec3 getColor(Hit h)\n{\n    if (h.d > P) { return vec3(0.9); }\n    \n    vec3 col = vec3(0);\n    vec3 col2 = vec3(0);\n    vec3 light = _cam.p;\n    vec3 n = getNormal(h.p);\n    \n    Hit _h = h;\n\n    for(int i = 0; i < 3; i++)\n    {\n        float diff = max(dot(normalize(light-h.p),n),0.0);\n        float spec = pow(max(dot(normalize(reflect(h.p-_cam.p,n)),n),0.0),100.)*0.2;\n        \n        _ray.d = normalize(refract(h.p-_cam.p,n,1.5));\n        _ray.o = h.p+_ray.d*P*10.0;\n        h = march(_ray);\n        \n        col += (vec3(1)*diff+spec)\/3.;\n        \n        n = getNormal(h.p);\n    }\n    \n    h = _h; n = getNormal(h.p);\n    \n    for(int i = 0; i < 3; i++)\n    {\n        _ray.d = normalize(reflect(h.p-_cam.p,n));\n        _ray.o = h.p+_ray.d*P*10.0;\n        \n        h = march(_ray);\n        n = getNormal(h.p);\n    \n        float diff = max(dot(normalize(light-h.p),n),0.0);\n        float spec = pow(max(dot(normalize(reflect(h.p-_cam.p,n)),n),0.0),100.)*0.2;\n        \n        col2 += (vec3(1)*diff+spec)\/3.;\n    }\n    \n    h = _h; n = getNormal(h.p);\n    \n    col = mix(col,col2,0.5)*2.0 + normalize(n+1.0)*0.5;\n    \n    return col;\/\/*texture2D(iChannel0,vec2((mod(h.p.x-T,1.)+mod(floor(T*10.),6.))*0.15625,h.p.z+0.5)).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy)\/iResolution.yy;\n    vec2 uvm = (2.0*iMouse.xy-iResolution.xy)\/iResolution.yy;\n    \n    if (iMouse.y < 10.) { uvm.y = -0.1; }\n    if (iMouse.x < 10.) { uvm.x = 0.0; }\n    \n    _cam.p.yz *= rot(-uvm.y*PI);\n    _cam.p.xz *= rot(uvm.x*PI);\n    \n    _ray = lookAt(_cam,uv);\n    \n    float f = 1.-length((2.0*fragCoord.xy-iResolution.xy)\/iResolution.xy)*0.5;\n    fragColor = vec4(getColor(march(_ray)), 1.0)*f;\n}","name":"","description":"","type":"image"}]}}