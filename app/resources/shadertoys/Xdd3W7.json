{"Shader":{"ver":"0.1","info":{"id":"Xdd3W7","date":"1450114905","viewed":215,"name":"Flame Ascending","username":"dr2","description":"Great balls of fire are born here","likes":7,"published":3,"flags":0,"tags":["raymarching","fire","architecture"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ \"Flame Ascending\" by dr2 - 2015\n\/\/ License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + cHashA4.xy) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  const vec3 cHashVA3 = vec3 (37.1, 61.7, 12.4);\n  const vec3 e = vec3 (1., 0., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Noisefv3a (vec3 p)\n{\n  vec4 t1, t2;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t1 = Hashv4v3 (ip);\n  t2 = Hashv4v3 (ip + vec3 (0., 0., 1.));\n  return mix (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n              mix (mix (t2.x, t2.y, fp.x), mix (t2.z, t2.w, fp.x), fp.y), fp.z);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat Fbm3 (vec3 p)\n{\n  const mat3 mr = mat3 (0., 0.8, 0.6, -0.8, 0.36, -0.48, -0.6, -0.48, 0.64);\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 6; i ++) {\n    f += a * Noisefv3a (p);\n    a *= 0.5;\n    p *= 4. * mr;\n  }\n  return f;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  p.z -= h * clamp (p.z \/ h, -1., 1.);\n  return length (p) - r;\n}\n\nfloat PrCapsShDf (vec3 p, float rIn, float rEx, float h)\n{\n  float s;\n  p.z -= h * clamp (p.z \/ h, -1., 1.);\n  s = length (p);\n  return max (s - rEx, rIn - s);\n}\n\nfloat PrFlatDiskDf (vec3 p, float w, float r)\n{\n  p.x -= w * clamp (p.x \/ w, -1., 1.);\n  return length (p.xy) - r;\n}\n\nfloat PrFlatCylShDf (vec3 p, float w, float rIn, float rEx, float h)\n{\n  float s;\n  p.x -= w * clamp (p.x \/ w, -1., 1.);\n  s = length (p.xy);\n  return max (max (s - rEx, rIn - s), abs (p.z) - h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nint idObj;\nvec3 sunDir, fBallPos, qHit;\nfloat dmRad, dmLen, dmUpRad, dmUpLen, psgLen, psgWid, psgHt, capRad, wThk, udBase,\n   fBallRad, tCur, tCyc, capPos, ltFac, qLenH, qAngH;\nconst float dstFar = 20.;\nconst int idDm = 1, idDmUp = 2, idPsg = 3, idFlor = 4, idCol = 5, idHot = 6,\n  idArch = 7;\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d, dc, dm, dr;\n  dMin = dstFar;\n  q = p;\n  qLenH = length (q.xz);\n  qAngH = atan (q.z, - q.x) \/ (2. * pi);\n  dr = (q.y > dmLen) ? abs (fract (18. * (atan (q.y - dmLen, qLenH) \/\n     (2. * pi) - 0.25)) - 0.5) : 2. * abs (abs (q.y \/ dmLen - 0.5) - 0.5);\n  dr = wThk * clamp (4. * min (dr, abs (fract (8. * qAngH) - 0.5)) - 0.1, 0., 0.25);\n  dm = max (PrCapsShDf (q.xzy, dmRad - wThk + dr, dmRad - dr, dmLen),\n     max (0.14 * dmRad - length (p.xz), - q.y));\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (4. * qAngH) + 0.5) \/ 4.);\n  qq = q;\n  q.x += dmRad - wThk;\n  d = max (PrFlatCylShDf (q.yzx, psgHt, psgWid - 1.3 * wThk,\n     psgWid - 0.9 * wThk, wThk), - q.y); \n  if (d < dMin) { dMin = d;  idObj = idArch;  qHit = q; }\n  q.x += psgLen;\n  dc = PrFlatDiskDf (q.yzx, psgHt, psgWid - wThk);\n  dr = wThk * clamp (min (4. * abs (fract ((q.x - 0.5 * psgLen) \/\n     (0.95 * psgLen)) - 0.5),\n     8. * abs (fract ((q.y + psgHt) \/ (1.95 * psgHt)) - 0.5)) - 0.2, 0., 0.25);\n  d = max (max (PrFlatCylShDf (q.yzx, psgHt, psgWid - wThk, psgWid - dr, psgLen),\n     dmRad - 0.5 * wThk - qLenH), - q.y);\n  if (d < dMin) { dMin = d;  idObj = idPsg;  qHit = q; }\n  q = p;\n  d = max (dm, - dc);\n  if (d < dMin) { dMin = d;  idObj = idDm;  qHit = q; }\n  q.y -= udBase;\n  d = max (max (PrCapsShDf (q.xzy, dmUpRad - wThk, dmUpRad, dmUpLen), - q.y),\n     0.05 * dmRad - qLenH);\n  if (d < dMin) { dMin = d;  idObj = idDmUp;  qHit = q; }\n  q = p;\n  d = PrCylDf (q.xzy, 6. * dmRad, 0.01 * dmLen);\n  d = max (d, capRad - qLenH);\n  q.y -= capPos;\n  d = min (d, PrCylDf (q.xzy, capRad, 0.05 * dmLen));\n  if (d < dMin) { dMin = d;  idObj = idFlor;  qHit = qq; }\n  q = p;\n  q.y -= - 0.2 * dmLen;\n  d = max (PrCylDf (q.xzy, capRad, 0.2 * dmLen), 0.99 * capRad - qLenH);\n  if (d < dMin) { dMin = d;  idObj = idHot; }\n  q = p;\n  q.y -= dmLen;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (8. * qAngH) + 0.5) \/ 8.);\n  q.xy -= - vec2 (dmRad - 2. * wThk, 0.5 * dmLen);\n  d = PrCapsDf (q.xzy, 0.035 * dmRad, 0.5 * dmLen);\n  if (d < dMin) { dMin = d;  idObj = idCol;  qHit = q; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.0001, -0.0001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat FBallHit (vec3 ro, vec3 rd, vec3 p, float s)\n{\n  vec3 v;\n  float b, d;\n  v = ro - p;\n  b = dot (rd, v);\n  d = b * b + s * s - dot (v, v);\n  return (d >= 0.) ? - b - sqrt (d) : dstFar;\n}\n\nfloat FBallLum (vec3 ro, vec3 rd, float dHit)\n{\n  vec3 p, q, dp;\n  float g, s, f, ri, t;\n  p = ro + dHit * rd - fBallPos;\n  dp = 0.033 * fBallRad * rd;\n  ri = 0.9 \/ fBallRad;\n  t = 3. * tCur;\n  g = 0.;\n  for (int i = 0; i < 30; i ++) {\n    p += dp;\n    q = 20. * p;   q.y -= t;\n    f = Fbm3 (q);\n    q = 35. * p;   q.y -= 1.9 * t;\n    f += Fbm3 (q);\n    s = length (p);\n    g += max (0.075 * max (1. - s * ri, 0.) * (f - 1.1), 0.);\n    if (s > fBallRad || g > 1.) break;\n  }\n  return g;\n}\n\nbool ChkInside ()\n{\n  vec3 q;\n  bool isIn;\n  isIn = false;\n  if (idObj == idDm) {\n    q = qHit;\n    q.y -= dmLen;\n    isIn = (((q.y < 0.) ? qLenH : length (q)) < dmRad - 0.3 * wThk);\n  } else if (idObj == idDmUp) {\n    q = qHit;\n    q.y -= dmUpLen;\n    isIn = (((q.y < 0.) ? qLenH : length (q)) < dmUpRad - 0.01 * wThk);\n  } else if (idObj == idPsg) {\n    q = qHit;\n    q.y -= psgHt;\n    isIn = (((q.y < 0.) ? abs (qHit.z) : length (q.yz)) < psgWid - 0.9 * wThk);\n  } else if (idObj == idFlor) {\n    isIn = (abs (qHit.z) < psgWid &&\n       abs (qHit.x) < dmRad + 2. * psgLen - wThk || qLenH < dmRad);\n  } else if (idObj == idCol || idObj == idHot || idObj == idArch) isIn = true;\n  return isIn;\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 50; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, 10. * h \/ d);\n    d += 0.021;\n    if (h < 0.001) break;\n  }\n  return max (sh, 0.5);\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (int j = 0; j < 8; j ++) {\n    d = 0.1 + float (j) \/ 8.;\n    ao += max (0., d - 3. * ObjDf (ro + rd * d));\n  }\n  return 0.3 + 0.7 * clamp (1. - 0.1 * ao, 0., 1.);\n}\n\nvec4 ObjCol (vec3 ro, bool inside)\n{\n  vec3 col, colEx, colIn, colFrmIn, colFrmEx;\n  vec2 u;\n  float spec, d, f;\n  spec = 0.7;\n  col = vec3 (0.);\n  colEx = vec3 (0.8, 0.8, 0.85);\n  colIn = vec3 (0.1, 0.1, 0.4);\n  colFrmIn = vec3 (0.8, 0.8, 0.5);\n  colFrmEx = vec3 (1., 1., 0.);\n  if (idObj == idDm) {\n    if (inside) {\n      d = ((qHit.y < dmLen) ? qLenH :\n\t length (qHit - vec3 (0., dmLen, 0.))) - dmRad + 0.77 * wThk;\n      col = colIn;\n      if (d > 0.) {\n        if (qHit.y < dmLen) {\n\t  u = vec2 (1.5 * (fract (4. * qAngH + 0.5) - 0.5), qHit.y \/ dmLen - 0.6);\n\t  u *= u;\n\t  col = mix (col, vec3 (0.5, 0.7, 0.1), SmoothBump (0.01, 0.025, 0.005,\n\t     abs (80. * dot (u, u) - 0.14) - 0.005));\n\t}\n      } else col = colFrmIn;\n    } else col = colEx;\n  } else if (idObj == idDmUp) {\n    if (inside) col = colIn;\n  } else if (idObj == idPsg) {\n    if (inside) col = vec3 (0.3, 0.3, 1.);\n    else col = colEx;\n  } else if (idObj == idFlor) {\n    if (inside) {\n      f = SmoothBump (0.7, 1.1, 0.1, Fbm2 (17. * ro.xz));\n      col = mix (vec3 (0.3, 0.4, 0.8), vec3 (0.2, 0.3, 0.6), f);\n      spec = 1. - 0.95 * f;\n    }\n  } else if (idObj == idHot) {\n    col = vec3 (1., 0., 0.) * (0.3 + 0.7 * Noiseff (50. * tCur));\n  } else if (idObj == idCol) {\n    col = vec3 (0.5, 0.7, 0.1) * (0.7 +\n       0.3 * sin (pi * mod (20. * (atan (qHit.x, qHit.z) \/ (2. * pi) + 0.5 +\n         qHit.y \/ dmLen), 1.)));\n  } else if (idObj == idArch) {\n    col = vec3 (0.5, 0.7, 0.1);\n  }\n  return vec4 (col, spec);\n}\n\nvec3 GrndCol (vec3 ro, vec3 rd)\n{\n  vec3 vn, col;\n  vec2 w;\n  float f;\n  vec2 e = vec2 (0.01, 0.);\n  w = 0.5 * ro.xz;\n  f = Fbm2 (w);\n  vn = normalize (vec3 (f - Fbm2 (w + e.xy), 0.1, f - Fbm2 (w + e.yx)));\n  col = mix (vec3 (0.4, 0.3, 0.1), vec3 (0.4, 0.5, 0.2), f) *\n       (1. - 0.1 * Noisefv2 (31. * w));\n  col *= 0.1 + 0.9 * max (dot (vn, sunDir), 0.);\n  col = mix (col, vec3 (0.1, 0.2, 0.4) + 0.25, pow (1. + rd.y, 32.));\n  return col;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float sd, f;\n  if (rd.y > 0.) {\n    ro.xz += 2. * tCur;\n    sd = max (dot (rd, sunDir), 0.);\n    col = vec3 (0.1, 0.2, 0.4) + 0.2 * pow (1. - max (rd.y, 0.), 8.) +\n       0.35 * pow (sd, 6.) + 0.65 * min (pow (sd, 256.), 0.3);\n    f = Fbm2 (0.05 * (ro.xz + rd.xz * (50. - ro.y) \/ rd.y));\n    col = mix (col, vec3 (1.), clamp (0.1 + 0.8 * f * rd.y, 0., 1.));\n  } else {\n    sd = - ro.y \/ rd.y;\n    ro += sd * rd;\n    col = GrndCol (ro, rd);\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 roo, col, vn, flmCol, ltDir, ltVec;\n  vec4 objCol;\n  float dstHit, dstFbHit, fIntens, f, ltDist;\n  int idObjT;\n  bool isIn, isRefl;\n  dstFbHit = FBallHit (ro, rd, fBallPos, fBallRad);\n  roo = ro;\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  if (idObj < 0) dstHit = dstFar;\n  isRefl = false;\n  if (dstHit < dstFar) {\n    idObjT = idObj;\n    ro += rd * dstHit;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    isIn = ChkInside ();\n    objCol = ObjCol (ro, isIn);\n    if (isIn) {\n      if (idObj == idFlor) {\n        f = fract (5. * qLenH \/ dmRad) - 0.15;\n\tif (abs (f) < 0.04) {\n          vn.xz -= 20. * f * ro.xz \/ qLenH;\n\t  vn = normalize (vn);\n\t}\n      }\n      ltVec = fBallPos - ro;\n      ltDist = length (ltVec);\n      ltDir = (fBallPos - ro) \/ ltDist;\n      f = max (dot (vn, ltDir), 0.);\n      col = objCol.rgb * (0.1 + vec3 (1., 0.8, 0.8) * f * (0.1 + 0.9 * f) +\n\t vec3 (1., 0., 0.7) * objCol.a *\n\t pow (max (0., dot (ltDir, reflect (rd, vn))), 128.));\n      if (idObj != idHot) col *= (0.01 + 0.99 * ltFac) \/\n         (1. + 0.5 * pow (ltDist, 4.));\n    } else {\n      if (idObj == idDm && qHit.y > dmLen &&\n         length (qHit - vec3 (0., dmLen, 0.)) - dmRad < -0.23 * wThk ||\n\t idObj == idDmUp) {\n\tisRefl = true;\n\tcol = BgCol (ro, reflect (rd, vn));\n      } else if (idObj == idFlor) {\n\tcol = GrndCol (ro, rd);\n      } else {\n\tcol = objCol.rgb * (0.3 +\n\t   0.2 * max (dot (vn, sunDir * vec3 (-1., 1., -1.)), 0.) +\n\t   0.7 * max (0., max (dot (vn, sunDir), 0.)) +\n\t   objCol.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.));\n      }\n    }\n  } else col = BgCol (ro, rd);\n  col *= ObjAO (ro, vn);\n  if (! isIn && ! isRefl && dstHit < dstFar) col *= ObjSShadow (ro, sunDir);\n  if (dstFbHit < min (dstHit, dstFar)) {\n    fIntens = (dstFbHit < dstFar) ? FBallLum (roo, rd, dstFbHit) : 0.;\n    f = clamp (0.7 * fIntens, 0., 1.);\n    f *= f;\n    flmCol = 1.5 * (0.7 + 0.3 * Noiseff (20. * tCur)) *\n       mix (vec3 (1., 0.1, 0.1), vec3 (1., 1., 0.5), f * f);\n    col = mix (col, flmCol, ltFac * min (fIntens * fIntens, 1.));\n  }\n  col = sqrt (clamp (col, 0., 1.));\n  return col;\n}\n\nvoid SetConfig ()\n{\n  float tIn, tm;\n  dmRad = 1.2;\n  dmLen = 1.3;\n  dmUpRad = 0.17 * dmRad;\n  dmUpLen = 0.08 * dmLen;\n  psgLen = 0.4 * dmRad;\n  psgHt = 0.55 * dmLen;\n  psgWid = 0.22 * dmLen;\n  capRad = 0.3 * dmRad;\n  wThk = 0.06;\n  udBase = dmLen + sqrt (dmRad * dmRad - dmUpRad * dmUpRad) - wThk;\n  fBallRad = 0.25;\n  tCyc = 15.;\n  tIn = mod (tCur \/ tCyc, 1.);\n  capPos = -0.04 * dmLen - 0.3 * dmLen * SmoothBump (0.05, 0.15, 0.05, tIn);\n  ltFac = SmoothBump (0.15, 0.95, 0.05, tIn);\n  fBallPos = vec3 (0.);\n  tm = 0.07;\n  fBallPos.y = fBallRad + capPos + (dmLen + dmRad - fBallRad) *\n     ((tIn > tm) ? (tIn - tm) \/ (1. - tm) : (tm - tIn) \/ tm);\n}\n\nvec3 TrackPath (float t)\n{\n  vec3 p;\n  float ti[6], a, rHi, rLo, trkCyc;\n  ti[0] = 0.;\n  ti[1] = ti[0] + 0.05;\n  ti[2] = ti[1] + 0.2;\n  ti[3] = ti[2] + 0.5;\n  ti[4] = ti[3] + 0.2;\n  ti[5] = ti[4] + 0.05;\n  trkCyc = 4. * tCyc;\n  a = floor (t \/ trkCyc);\n  t = fract (t \/ trkCyc);\n  if      (t < ti[1]) a += 0.25 * (t - ti[0]) \/ (ti[1] - ti[0]);\n  else if (t < ti[2]) a += 0.25;\n  else if (t < ti[3]) a += 0.25 + 0.5 * (t - ti[2]) \/ (ti[3] - ti[2]);\n  else if (t < ti[4]) a += 0.75;\n  else if (t < ti[5]) a += 0.75 + 0.25 * (t - ti[4]) \/ (ti[5] - ti[4]);\n  rHi = 3.5 * dmRad;\n  rLo = 0.8 * dmRad;\n  p = vec3 (0., 0.8 * psgHt, - rHi + (rHi - rLo) * SmoothBump (0.15, 0.85, 0.1, t));\n  p.xz = Rot2D (p.xz, pi * a);\n  return p;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec2 canvas, uv;\n  vec3 ro, rd, vd, u;\n  float f, a;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy \/ canvas - 1.;\n  uv.x *= canvas.x \/ canvas.y;\n  tCur = iGlobalTime;\n  SetConfig ();\n  ro = TrackPath (tCur);\n  vd = mix (vec3 (- ro.x, 0.3 * dmLen, - ro.z), fBallPos - ro, \n    smoothstep (-0.5, 0., 1. - length (ro.xz) \/ dmRad));\n  vd = normalize (vd);\n  u = - vd.y * vd;\n  f = 1. \/ sqrt (1. - vd.y * vd.y);\n  vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n  rd = vuMat * normalize (vec3 (uv, 2.));\n  a = 0.011 * 2. * pi * tCur;\n  sunDir = normalize (vec3 (cos (a), 3. + cos (0.55 * a), sin (a)));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\n","name":"","description":"","type":"image"}]}}