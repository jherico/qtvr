{"Shader":{"ver":"0.1","info":{"id":"Xss3DH","date":"1374068681","viewed":3426,"name":"Candlestick","username":"P_Malin","description":"Playing with iterative raymarching and cubemap materials.","likes":40,"published":3,"flags":0,"tags":["raymarch","flame","iterative","candle"],"hasliked":0},"renderpass":[{"inputs":[{"id":6,"src":"\/presets\/tex05.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":24,"src":"\/presets\/cube02_0.jpg","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"id":25,"src":"\/presets\/cube03_0.png","ctype":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Candlestick - @P_Malin\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ \n\/\/ Playing with iterative raymarching and cubemap materials.\n\/\/\n\/\/ Try commenting out LOW_QUALITY and uncommmenting ENABLE_MIRROR below.\n\n\/\/#define LOW_QUALITY\n\n#ifdef LOW_QUALITY\n\n\t#define kRaymarchMaxIter 32\n\t#define kMaxIter 3\n\t#define kShadowIter 8\n\n#else\n\n\t#define kRaymarchMaxIter 64\n\t#define kMaxIter 4\n\t#define kShadowIter 16\n\n#endif \n\n\/\/#define ENABLE_MIRROR\n\n\/\/#define BURN_DOWN\n\nfloat fSceneIntensity = 0.5;\n\nvec3 vFlameLightColour = vec3(1.0, 0.5, 0.1) * 10.0;\nvec3 vFlameColour1 = vec3(1.0, 0.5, 0.1);\nvec3 vFlameColour2 = vec3(1.0, 0.05, 0.01);\n\nvec3 vFlameWander = vec3(0.0, 0.0, 0.0);\n\nfloat fWaxExtinction = 5.0;\n\nfloat kExposure = 1.5;\n\nvec3 vCandlestickPos = vec3(-3.0, 0.0, 2.0);\n\n#ifndef BURN_DOWN\n\tfloat fCandleTop = max(2.2, 3.8);\n#else\n\tfloat fCandleTop = max(2.2, 3.8 - iGlobalTime * 0.005);\n#endif\n\nvec3 vLightPos = vCandlestickPos + vec3(0.0, fCandleTop + 0.35, 0.0);\t\n\n#define kMaterialWood   0.0\n#define kMaterialGold \t1.0\n#define kMaterialWax \t2.0\n#define kMaterialWick\t3.0\n#define kMaterialChrome\t4.0\n#define kMaterialPaper\t5.0\n\nvec3 RotateX( const in vec3 vPos, const in float s, const in float c )\n{\n\tvec3 vResult = vec3( vPos.x, c * vPos.y + s * vPos.z, -s * vPos.y + c * vPos.z);\n\n\treturn vResult;\n}\n\nvec3 RotateY( const in vec3 vPos, const in float s, const in float c )\n{\n\tvec3 vResult = vec3( c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);\n\n\treturn vResult;\n}\n\nvec2 GetDistanceFloor( const in vec3 vPos )\n{\n\treturn vec2(vPos.y, kMaterialWood);\n}\n\nvec2 GetDistanceCandlestick( const in vec3 vPos )\n{\n\tvec2 vProfilePos = vec2( length(vPos.xz), vPos.y );\n\n\tfloat fTop = 2.0;\n\tfloat fBottom = 0.0;\n\t\n\tfloat fOutside = -1.0;\n\t\n\tfloat fDist = vProfilePos.x;\t\n\tfloat fVerticalPos = vProfilePos.y;\n\t\n\tif(fVerticalPos > fTop)\n\t{\n\t\tfVerticalPos = fTop;\n\t\tfOutside = 1.0;\n\t}\n\n\tif(fVerticalPos < fBottom)\n\t{\n\t\tfVerticalPos = fBottom;\t\t\n\t\tfOutside = 1.0;\n\t}\n\n\tfloat t = fVerticalPos;\n\tfloat a = 3.14 * 2.0;\n\tfloat b = 0.15;\n\tfloat fHorizontalPos = 0.4 + sin(t * a) * b;\n\tfloat fHorizontalPosDelta = (cos(t * a) * a * b) \/ a;\n\t\n\tfloat fHorizontalDist = vProfilePos.x - fHorizontalPos;\n\t\n\tif(fOutside > 0.0)\n\t{\n\t\tvec2 vClosest = vec2(min(fHorizontalPos, vProfilePos.x), fVerticalPos);\n\t\t\n\t\tfDist = length(vClosest - vProfilePos);\t\t\n\t}\n\telse\n\t{\n\t\t\n\t\tif(fHorizontalDist > 0.0)\n\t\t{\n\t\t\tfOutside = 1.0;\n\t\t}\n\n\t\tif(fOutside < 0.0)\n\t\t{\t\t\n\t\t\tfloat fTopDist = fTop - fVerticalPos;\n\t\t\tfloat fBottomDist = fVerticalPos - fBottom;\n\t\t\tfDist = min(fTopDist, fBottomDist);\n\t\t\tfDist = min(fDist, -fHorizontalDist);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfDist = fHorizontalDist \/ sqrt(1.0 + fHorizontalPosDelta * fHorizontalPosDelta);\t\n\t\t}\n\t}\n\t\n\tfloat fBevel = 0.1;\n\tfloat fStickDistance = fOutside * fDist -fBevel;\n\t\n\tfloat fBaseTop = 0.1;\n\tfloat fBaseRadius = 1.0;\n\tvec2 vBaseClosest = vProfilePos;\n\tvBaseClosest.y = min(vBaseClosest.y, fBaseTop);\n\tvBaseClosest.x = min(vBaseClosest.x, fBaseRadius);\n\n\tfloat fBaseDistance = length(vProfilePos - vBaseClosest) - fBevel;\n\t\n\treturn vec2( min(fStickDistance, fBaseDistance), kMaterialGold);\n}\n\nfloat GetDistanceWaxTop( const in vec3 vPos )\n{\n\tvec2 vProfilePos = vec2( length(vPos.xz), vPos.y );\n\n\tfloat fCurve = 1.0;\n\t\n\treturn vProfilePos.y - fCandleTop - vProfilePos.x * vProfilePos.x * fCurve;\t\n}\n\nvec2 GetDistanceCandle( const in vec3 vPos )\n{\n\tvec2 vProfilePos = vec2( length(vPos.xz), vPos.y );\n\t\n\tfloat fDistance = vProfilePos.x - 0.2;\n\t\t\n\tfloat fDistanceTop = GetDistanceWaxTop(vPos);\n\t\n\tif(fDistanceTop > fDistance)\n\t{\n\t\tfDistance = fDistanceTop;\n\t}\n\t\n\treturn vec2(fDistance, kMaterialWax);\n}\n\n\nvec2 GetDistanceWick( const in vec3 vPos )\n{\n\tvec2 vProfilePos = vec2( length(vPos.xz), vPos.y );\n\t\n\tfloat fDistance = vProfilePos.x - 0.015;\n\t\n\tfloat fDistanceTop = vProfilePos.y - (fCandleTop + 0.2);\n\tif(fDistanceTop > fDistance)\n\t{\n\t\tfDistance = fDistanceTop;\n\t}\n\t\n\treturn vec2(fDistance, kMaterialWick);\n}\n\nvec2 GetDistanceSphere( const in vec3 vPos )\n{\n\tfloat fDistance = length(vPos - vec3(1.3, 0.75, 1.0)) - 0.75;\n\n\treturn vec2(fDistance, kMaterialChrome);\n}\n\nfloat GetDistanceBox( const in vec3 vPos, const in vec3 vDimension )\n{\n\tvec3 vDist = abs(vPos) - vDimension;\n  \tfloat fDistance =  min(max(vDist.x,max(vDist.y,vDist.z)),0.0) + length(max(vDist,0.0));\n\n\treturn fDistance;\t\n}\n\nvec3 vMirrorGlassSize = vec3(2.5, 2.0, 0.1);\nfloat fMirrorFrameSize = 0.2;\n\nvec3 vMirrorStandSize = vec3(2.8, 1.5, 0.5);\nfloat fMirrorStandWidth = 0.2;\n\nfloat g_MirrorRotSin = sin(-0.3);\nfloat g_MirrorRotCos = cos(-0.3);\n\nfloat g_MirrorTiltSin = sin(0.1);\nfloat g_MirrorTiltCos = cos(0.1);\n\nvec2 GetDistanceMirrorGlass( const in vec3 vPos )\n{\t\n\tfloat fDistance = GetDistanceBox(vPos, vMirrorGlassSize);\n\treturn vec2(fDistance, kMaterialChrome);\n}\n\nvec2 GetDistanceMirrorFrame( const in vec3 vPos )\n{\n\tfloat fDistanceOuterFrame = GetDistanceBox(vPos, vMirrorGlassSize + vec3(fMirrorFrameSize)) - 0.2;\n\tfloat fDistanceFrameHole = GetDistanceBox(vPos + vec3(0.0, 0.0, fMirrorFrameSize * 2.0), vMirrorGlassSize + vec3(0.0, 0.0, fMirrorFrameSize * 2.0));\n\t\n\tfloat fDistance = max(fDistanceOuterFrame, -fDistanceFrameHole);\n\t\n\treturn vec2(fDistance, kMaterialWood);\n}\n\n\nvec2 GetDistanceMirror( const in vec3 vPos )\n{\n\tvec2 vResult = GetDistanceMirrorFrame(vPos);\n\t\n\tvec2 vGlass = GetDistanceMirrorGlass(vPos);\n\t\n\tif(vGlass.x < vResult.x)\n\t{\n\t\tvResult = vGlass;\n\t}\n\t\t\n\treturn vResult;\n}\n\n\nvec2 GetDistanceMirrorStand( const in vec3 vPos )\n{\n\tfloat fDistanceOuter = GetDistanceBox(vPos - vec3(0.0, 1.5, 0.0), vMirrorStandSize + vec3(fMirrorStandWidth));\n\tfloat fDistanceInner = GetDistanceBox(vPos - vec3(0.0, 1.5 + fMirrorStandWidth * 2.0, 0.0), vMirrorStandSize + vec3(0.0, fMirrorStandWidth ,1.0));\n\t\t\n\tfloat fDistance = max(fDistanceOuter, -fDistanceInner);\n\n\treturn vec2(fDistance, kMaterialWood);\n}\n\nvec2 GetDistancePaper( const in vec3 vPos )\n{\n\tfloat fDistance = GetDistanceBox(vPos, vec3(1.05, 0.01, 1.485));\n\n\treturn vec2(fDistance, kMaterialPaper);\n}\n\nfloat g_PaperRotSin = sin(-0.1);\nfloat g_PaperRotCos = cos(-0.1);\n\nvec2 GetDistanceShadowCasters( const in vec3 vPos )\n{\n\tvec2 vResult = vec2(1000.0, -1.0);\n\n\tvec3 vCandlestickLocalPos = vPos - vCandlestickPos;\t\n\n\tvec2 vCandlestick = GetDistanceCandlestick(vCandlestickLocalPos);\n\tif(vCandlestick.x < vResult.x)\n\t{\n\t\tvResult = vCandlestick;\n\t}\n\t\n\tvec2 vSphere = GetDistanceSphere(vPos);\n\tif(vSphere.x < vResult.x)\n\t{\n\t\tvResult = vSphere;\n\t}\n\t\n\t\n\tvec3 vPapereLocalPos = RotateY(vPos, g_PaperRotSin, g_PaperRotCos);\n\t\n\tvec2 vPaper = GetDistancePaper(vPapereLocalPos);\n\tif(vPaper.x < vResult.x)\n\t{\n\t\tvResult = vPaper;\n\t}\n\n\t\n\t#ifdef ENABLE_MIRROR\n\t\n\tvec3 vMirrorLocalPos = vPos - vec3(0.0, 0.0, 3.5);\n\tvMirrorLocalPos = RotateY(vMirrorLocalPos, g_MirrorRotSin, g_MirrorRotCos);\n\t\n\tvec2 vMirrorStand = GetDistanceMirrorStand(vMirrorLocalPos);\n\tif(vMirrorStand.x < vResult.x)\n\t{\n\t\tvResult = vMirrorStand;\n\t}\n\t\n\t\n\tvec3 vMirrorPaneLocalPos = vMirrorLocalPos - vec3(0.0, 2.7, 0.0);\t\n\tvMirrorPaneLocalPos = RotateX(vMirrorPaneLocalPos, g_MirrorTiltSin, g_MirrorTiltCos);\n\t\n\tvec2 vMirror = GetDistanceMirror(vMirrorPaneLocalPos);\n\tif(vMirror.x < vResult.x)\n\t{\n\t\tvResult = vMirror;\n\t}\n\t#endif\t\n\n\treturn vResult;\n}\n\nvec2 GetSceneDistance( const in vec3 vPos )\n{\n\tvec3 vCandlestickLocalPos = vPos - vCandlestickPos;\t\n\n\tvec2 vResult = vec2(1000.0, -1.0);\n\t\t\t\n\tvec2 vFloor = GetDistanceFloor(vPos);\n\tif(vFloor.x < vResult.x)\n\t{\n\t\tvResult = vFloor;\n\t}\n\t\n\tvec2 vCandle = GetDistanceCandle(vCandlestickLocalPos);\n\tif(vCandle.x < vResult.x)\n\t{\n\t\tvResult = vCandle;\n\t}\n\t\n\t\n\tvec2 vWick = GetDistanceWick(vCandlestickLocalPos);\n\tif(vWick.x < vResult.x)\n\t{\n\t\tvResult = vWick;\n\t}\t\n\n\tvec2 vSolids = GetDistanceShadowCasters(vPos);\n\tif(vSolids.x < vResult.x)\n\t{\n\t\tvResult = vSolids;\n\t}\t\n\n\treturn vResult;\n}\n\nvec2 Raycast( const in vec3 vOrigin, const in vec3 vDir )\n{\n\tvec2 d = vec2(0.0, -1.0);\n\tfloat t = 0.01;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\n\t\td = GetSceneDistance(vOrigin + vDir * t);\n\t\tif(abs(d.x) < 0.0001)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tt += d.x;\n\t\tif(t > 100.0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn vec2(t, d.y);\n}\n\nfloat RaycastShadow( const in vec3 vOrigin, const in vec3 vDir, const in float k )\n{\n\tfloat fShadow = 1.0;\n\tfloat t = 0.01;\n\tfloat fDelta = 1.0 \/ float(kShadowIter);\n\tfor(int i=0; i<kShadowIter; i++)\n\t{\n\t\tfloat d = GetDistanceShadowCasters(vOrigin + vDir * t).x;\n\t\t\n\t\tfShadow = min( fShadow, k * d \/ t );\n\t\t\n\t\tt = t + fDelta;\n\t}\n\t\n\treturn clamp(fShadow, 0.0, 1.0);\n}\n\nfloat GetAmbientOcclusion( const in vec3 vPos, const in vec3 vNormal)\n{\t\n\tfloat fAmbientOcclusion = 0.0;\n\t\n\tfloat fStep = 0.1;\n\tfloat fDist = 0.0;\n\tfor(int i=0; i<=5; i++)\n\t{\n\t\tfDist += fStep;\n\t\t\n\t\tvec2 vSceneDist = GetSceneDistance(vPos + vNormal * fDist);\n\t\t\n\t\tfloat fAmount = (fDist - vSceneDist.x);\n\t\t\n\t\tfAmbientOcclusion += max(0.0, fAmount * fDist );                                  \n\t}\n\t\n\treturn max(1.0 - fAmbientOcclusion, 0.0);\n}\n\nvec3 GetSceneNormal( const in vec3 vPos )\n{\n    const float fDelta = 0.0005;\n\n    vec3 vOffset1 = vec3( fDelta, -fDelta, -fDelta);\n    vec3 vOffset2 = vec3(-fDelta, -fDelta,  fDelta);\n    vec3 vOffset3 = vec3(-fDelta,  fDelta, -fDelta);\n    vec3 vOffset4 = vec3( fDelta,  fDelta,  fDelta);\n\n    float f1 = GetSceneDistance( vPos + vOffset1 ).x;\n    float f2 = GetSceneDistance( vPos + vOffset2 ).x;\n    float f3 = GetSceneDistance( vPos + vOffset3 ).x;\n    float f4 = GetSceneDistance( vPos + vOffset4 ).x;\n\n    vec3 vNormal = vOffset1 * f1 + vOffset2 * f2 + vOffset3 * f3 + vOffset4 * f4;\n\n    return normalize( vNormal );\n}\n\nvec3 HackHDR( const in vec3 vCol )\n{\t\n\treturn (-log(1.0 - min(vCol, 0.98)));\n}\n\nvec3 SampleEnvironment( const in vec3 vDir )\n{\n\tvec3 vSample = textureCube(iChannel0, vDir).rgb;\n\treturn (HackHDR(vSample * vSample)) * fSceneIntensity;\n}\n\nvec3 SampleDiffuse( const in vec3 vDir )\n{\n\tvec3 vSample = textureCube(iChannel1, vDir).rgb;\n\tvSample = vSample * vSample;\n\t\n\t\/\/ hack bright spots out of blurred environment\n\tfloat fMag = length(vSample);\t\n\tvSample = mix(vSample, vec3(0.15, 0.06, 0.03), smoothstep(0.1, 0.25, fMag));\n\t\n\treturn vSample * fSceneIntensity;\n}\n\nvec3 GetFlameIntensity( const in vec3 vOrigin, const in vec3 vDir, const in float fDistance )\n{\n\tvec3 vFlamePos = vec3(0.0, fCandleTop + 0.25, 0.0) + vCandlestickPos;\n\tvec3 vToFlame = vFlamePos - vOrigin;\n\t\n\tfloat fClosestDot = dot(vDir, vToFlame);\n\tfClosestDot = clamp(fClosestDot, 0.0, fDistance);\n\t\n\tvec3 vClosestPos = vOrigin + vDir * fClosestDot;\n\tvec3 vClosestToFlame = vClosestPos - vFlamePos;\n\t\n\tvClosestToFlame.xz *= (vClosestToFlame.y + 1.0) * 1.5;\n\tvClosestToFlame.y *= 0.5;\n\tvClosestToFlame *= 8.0;\n\n\tfloat fSwayAmount = (1.0 + vClosestToFlame.y ) * 0.05;\n\tvClosestToFlame += vFlameWander * fSwayAmount;\n\t\n\tfloat fClosestDist = length(vClosestToFlame);\n\t\t\n\tfloat fBrightness = smoothstep(1.0, 0.5, fClosestDist);\n\t\t\t\n\tfloat fHeightFade = (vClosestToFlame.y * 0.5 + 0.5);\n\tfBrightness *= clamp(dot(vClosestToFlame.xz, vClosestToFlame.xz) + fHeightFade, 0.0, 1.0);\n\n\treturn mix(vFlameColour1 * 32.0, vFlameColour2, 1.0 - fBrightness) * fBrightness;\n}\n\nvec3 GetFlareIntensity( const in vec3 vOrigin, const in vec3 vDir )\n{\n\tvec3 vToFlame = vLightPos - vOrigin;\n\n\t\n\tfloat fClosestDot = dot(vDir, vToFlame);\n\tfClosestDot = max(fClosestDot, 0.0);\n\t\n\tvec3 vClosestPos = vOrigin + vDir * fClosestDot;\n\tvec3 vClosestToFlame = vClosestPos - vLightPos;\n\t\n\tfloat fClosestDist = length(vClosestToFlame);\n\t\t\n\tfloat fBrightness = (1.0 \/ (fClosestDist + 1.0));\t\n\n\treturn vFlameColour1 * pow(fBrightness, 5.0);\n}\n\nvoid TraceRay( inout vec3 vOrigin, inout vec3 vDir, out vec3 vColour, inout vec3 vRemaining )\n{\t\n\tvec2 vHit = Raycast(vOrigin, vDir);\n\t\n\tvec3 vHitPos = vOrigin + vDir * vHit.x;\n\tvec3 vHitNormal = GetSceneNormal(vHitPos);\n\t\n\tvec3 vAlbedo = vec3(0.0);\n\tvec3 vSpecR0 = vec3(0.0);\n\tfloat fSmoothness = 0.0;\n\n\tvec3 vEmissive = vec3(0.0);\n\tvec3 vGlow = GetFlameIntensity(vOrigin, vDir, vHit.x);\n\n\tif(vHit.x > 20.0)\n\t{\n\t\tvColour = vGlow + GetFlareIntensity(vOrigin, vDir);\n\t\tvColour *= vRemaining;\n\t\tvOrigin = vHitPos;\n\t}\n\telse\n\t{\n\t\tfloat fAmbientOcclusion = GetAmbientOcclusion(vHitPos, vHitNormal);\n\t\n\t\t\n\t\tif(vHit.y <= kMaterialWood)\n\t\t{\n\t\t\tvAlbedo = texture2D(iChannel2, vHitPos.xz * 0.25).rgb;\n\t\t\tvAlbedo = vAlbedo * vAlbedo;\t\n\t\t\t\n\t\t\tfSmoothness = vAlbedo.r * vAlbedo.r * 0.1;\n\t\t}\n\t\telse\n\t\tif(vHit.y <= kMaterialGold)\n\t\t{\n\t\t\tvAlbedo = vec3(0.3, 0.1, 0.05);\n\t\t\tvSpecR0 = vec3(0.9, 0.5, 0.05);\n\t\t\tfSmoothness = 1.0;\n\t\t}\n\t\telse\n\t\tif(vHit.y <= kMaterialWax)\n\t\t{\n\t\t\tvAlbedo = vec3(0.9);\n\t\t\tvSpecR0 = vec3(0.01);\n\t\t\t\n\t\t\tfloat fDistanceThroughWax = GetDistanceWaxTop(vHitPos - vCandlestickPos - vFlameWander * 0.025);\n\t\t\tvEmissive = vFlameLightColour * (exp(fWaxExtinction * fDistanceThroughWax));\n\t\t}\n\t\telse\n\t\tif(vHit.y <= kMaterialWick)\t\t\t\n\t\t{\n\t\t\tvAlbedo = vec3(0.01);\n\t\t}\n\t\telse\n\t\tif(vHit.y <= kMaterialChrome)\t\t\t\n\t\t{\n\t\t\tvAlbedo = vec3(0.3);\n\t\t\tvSpecR0 = vec3(0.85);\n\t\t\tfSmoothness = 1.0;\n\t\t}\n\t\telse\n\t\tif(vHit.y <= kMaterialPaper)\t\t\t\n\t\t{\n\t\t\tvAlbedo = vec3(0.9);\n\t\t\tvSpecR0 = vec3(0.0);\n\t\t\tfSmoothness = 0.0;\n\t\t}\n\n\t\t\t\t\n\t\tvec3 vDiffuseLight = SampleDiffuse(vHitNormal) * fAmbientOcclusion;\n\t\t\t\n\t\tvec3 vToLight = vLightPos - vHitPos;\n\t\tfloat fDistToLight = length(vToLight);\n\t\tvec3 vNormToLight = normalize(vToLight);\n\t\t\n\t\tfloat fDot = clamp(dot(vNormToLight, vHitNormal), 0.0, 1.0);\n\t\t\n\t\tfloat fShadow = RaycastShadow(vHitPos, vToLight, 1.0);\n\t\n\t\t\/\/ Fake shadow from candle\n\t\tfShadow *= smoothstep(0.4, 0.6, length(vToLight.xz) \/ max(vToLight.y, 0.01));\n\n\t\tfShadow = mix(0.1 + 0.15 * fAmbientOcclusion, 1.0, fShadow);\n\t\n\t\tvec3 vLightIntensity = vFlameLightColour * fDot * fShadow;\n\t\tvLightIntensity \/= fDistToLight * fDistToLight;\n\t\tvDiffuseLight += vLightIntensity;\n\t\t\n\t\tvec3 vReflectDir = normalize(reflect(vDir, vHitNormal));\n\t\t\n\t\tvec3 vHalf = normalize(vReflectDir + -vDir);\n\t\tfloat fFresnelDot = clamp(1.0 - dot(vHalf, -vDir), 0.0, 1.0);\t\n\t\tfloat fFresnel = pow(fFresnelDot, 5.0);\n\t\t\t\t\n\t\tvec3 vReflectFraction = vSpecR0 + (vec3(1.0) - vSpecR0) * fFresnel * fSmoothness;\n\t\n\t\tvColour = (vDiffuseLight * vAlbedo + vEmissive) * (vec3(1.0) - vReflectFraction);\n\t\tvColour += GetFlareIntensity(vOrigin, vDir);\n\t\tvColour += vGlow;\n\t\tvColour *= vRemaining;\n\t\tvRemaining *= vReflectFraction;\n\t\tvOrigin = vHitPos;\n\t\tvDir = vReflectDir;\n\t}\n\t\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vUV = fragCoord.xy \/ iResolution.xy;\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x \/ iResolution.y;\n\t\n\tvec2 vMouse = iMouse.xy \/ iResolution.xy;\n\t\n\tfloat fHeading = 3.14 + (vMouse.x - 0.5) * 3.0;\n\tfloat fElevation = (vMouse.y - 0.5) + 0.15;\n\tfloat fCameraDistance = 3.0;\n\t\n\tif(iMouse.y <= 0.0)\n\t{\n\t\tfHeading = 3.0;\n\t\tfElevation = 0.25;\n\t}\n\t\n\tfloat fSinElevation = sin(fElevation);\n\tfloat fCosElevation = cos(fElevation);\n\tfloat fSinHeading = sin(fHeading);\n\tfloat fCosHeading = cos(fHeading);\n\t\n\tvec3 vCameraOffset;\n\tvCameraOffset.x = fSinHeading * fCosElevation;\n\tvCameraOffset.y = fSinElevation;\n\tvCameraOffset.z = fCosHeading * fCosElevation;\n\t\n\tvec3 vCameraPos = vec3(0.0, 2.5, -2.0);\n\tvCameraPos += vCameraOffset * fCameraDistance;\n\n\tvec3 vCameraTarget = vec3(-1.0, 2.0, 0.0);\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\t\t\t\t\t\t  \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * 2.0);\n\n\tvFlameWander.x = sin(iGlobalTime * 20.0);\n\tvFlameWander.z = sin(iGlobalTime * 10.0) * 2.0;\n\n\tvLightPos -= vFlameWander * 0.01;\n\t\n\tvec3 vResult = vec3(0.0);\n\t\n\tvec3 vRemaining = vec3(1.0);\n\tfor(int i=0; i<kMaxIter; i++)\n\t{\n\t\tvec3 vColour = vec3(0.0);\n\t\t\n\t\tTraceRay(vCameraPos, vDir, vColour, vRemaining);\n\t\t\n\t\tvResult += vColour;\n\t}\n\t\n\t{\n\t\tvec3 vColour = (SampleEnvironment(vDir));\t\t\n\t\t\/\/vColour += GetFlareIntensity(vOrigin, vDir);\n\t\t\n\t\tvResult += vColour * vRemaining;\n\t}\t\n\t\n\tvec2 vCentreOffset = (vUV - 0.5) * 2.0;\n\tvResult.xyz *= 1.0 - dot(vCentreOffset, vCentreOffset) * 0.3;\n\n\tvResult.xyz = sqrt(1.0 - exp2(-vResult.xyz * kExposure));\n\t\n\tfragColor = vec4(vResult,1.0);\n}","name":"","description":"","type":"image"}]}}