{"Shader":{"ver":"0.1","info":{"id":"MtSXRm","date":"1442421176","viewed":1164,"name":"Luminescent Tiles","username":"Shane","description":"Using BeyondTheStatic's \"Box Divide\" formula to tile a square tunnel. Normal wrapping is used to give the tiles a cheap, fake, subsurface, luminescent glow.","likes":11,"published":3,"flags":0,"tags":["tunnel","normal","wrap","luminescence"],"hasliked":0},"renderpass":[{"inputs":[{"id":4,"src":"\/presets\/tex03.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/*\n\n\tUsing BeyondTheStatic's \"Box Divide\" formula to tile a square tunnel. Normal wrapping is \n\tused to give the tiles a cheap, fake, subsurface, luminescent glow.\n\n\tFor anyone interested, the \"texCol\" function contains some cylindrical mapping examples.\n\n\tThere looks like there's more code here than there is. Most of it is optional 2D functions.\n\tIf you keep only the stuff you want, there's not much code at all.\n\n\tBox Divide - BeyondTheStatic\n\thttps:\/\/www.shadertoy.com\/view\/Xl2XRh\n\n*\/\n\n\n\n\/\/ 2D rotation. Always handy.\nmat2 rot(float th){ float cs = cos(th), si = sin(th); return mat2(cs, -si, si, cs); }\n\n\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(41, 289)))* 43758.5453);}\n\n\n\/\/ Box Divide\n\/\/ 2015 BeyondTheStatic\n\/\/ Original function: https:\/\/www.shadertoy.com\/view\/Xl2XRh\n\/\/ Function with changes applied: https:\/\/www.shadertoy.com\/view\/4l2XR1\nvec3 boxDivide(in vec2 p) {\n    \n    p = fract(p);\n    \n    vec2 l = vec2(1);\n\n    bool flip=false;\n    \n    for(int i=0; i<8; i++) {\n \n        float r = hash21(l)*0.5 + 0.25;\n        \n        if(l.x>l.y) { p=p.yx; l=l.yx; flip=true; }\n        \n        if(p.x<r) { l.x \/= r; p.x \/= r; }\n        else { l.x \/= (1.-r); p.x = (p.x-r)\/(1.-r); }\n        \n        if(flip){ p=p.yx; l=l.yx; flip=false; }\n        \n    }\n    \n    \/\/ Making a basic rounded box.\n    \/\/float f = max(1.- dot(pow(abs(p - .5), vec2(6)), vec2(64)), 0.);\n   \n    float f = pow(16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y), 0.33);\n    \n    \/\/float f = pow(abs(sin(p.x*3.14159)*sin(p.y*3.14159)), 0.3);\n    \n    \/\/return vec3(min(p*f*1.5, 1.), f);\n    return vec3(f);\n}\n\nfloat tiles(in vec2 p){\n\n    float c = abs(sin(p.x*3.14159) * cos(p.y*3.14159));\n    \n    return pow(c*0.5, 0.125)*clamp( 1. + hash21(floor(p*16.))*0.05-0.025, 0., 1.);\n\n}\n\nfloat tiles2(vec2 p){\n\t\n\n    p = fract(p);\n    \n    \/\/p*=p;\n    \n    float s = pow( 16.*p.x*p.y*(1.0-p.x)*(1.0-p.y), 0.25);\n    float s2 = (sin(p.x*3.14159)*sin(p.y*3.14159)*0.5+0.5);\n    \n    s = (s - s2*0.5)*2.;\n    \n    return clamp(s, 0., 1.);\/\/*c;\n\n}\n\nvec3 texCol( in vec3 p, in vec3 n){\n    \n    \/\/ Cylindrical mapping. Note the divide by 8. It's an arbitrary value,\n    \/\/ and controls the stretch in the z-direction.\n    \/\/vec2 uv = vec2(atan(p.y, p.x)\/6.2832, p.z\/8.);\n    \n    \/\/ Using box mapping (I made that up) for this particular example.\n    vec2 uv = (p.xz*n.y + p.yz*n.x)*vec2(2, 2)\/16.;\n    \n    vec3 col = boxDivide(uv*1.);\n    vec3 tex = texture2D(iChannel0, uv*4.).zyx;\n    return (1.-tex)*col;\n    \n    \/\/float c = tiles2(uv*10.); \n    \/\/return (texture2D(iChannel0, uv*2.).xyz*0.5+0.5)*c;    \n    \n    \/\/ Cylindrical texture mapping.\n    \/\/return texture2D(iChannel0, uv*3.).xyz;\n    \n    \/\/float c = tiles2(uv*24.); \n    \/\/return texture2D(iChannel0, uv*4.).xyz*c; \n    \n    \/\/ etc.\n}\n\nfloat texShade(vec3 p, in vec3 n){\n    \n    vec3 col = texCol(p, n);\n    return dot(col, vec3(0.299, 0.587, 0.114));\n}\n\nvec3 blackbodyPalette(float t){\n\n    t = t*2200.; \/\/ Temperature. Hardcoded to 4000, in this case.\n    \n\n    float cx = (0.860117757 + 1.54118254e-4*t + 1.28641212e-7*t*t)\/(1.0 + 8.42420235e-4*t + 7.08145163e-7*t*t);\n    float cy = (0.317398726 + 4.22806245e-5*t + 4.20481691e-8*t*t)\/(1.0 - 2.89741816e-5*t + 1.61456053e-7*t*t);\n    \n    \/\/ Converting the chromacity coordinates to XYZ tristimulus color space.\n    float d = (2.*cx - 8.*cy + 4.);\n    vec3 XYZ = vec3(3.*cx\/d, 2.*cy\/d, 1. - (3.*cx + 2.*cy)\/d);\n    \n    vec3 RGB = mat3(3.240479, -0.969256, 0.055648, \n                    -1.537150, 1.875992, -0.204043, \n                    -0.498535, 0.041556, 1.057311) * vec3(1.\/XYZ.y*XYZ.x, 1., 1.\/XYZ.y*XYZ.z);\n\n    return max(RGB, 0.)*pow(t*0.0004, 4.); \n}\n\nvec3 firePalette(float i){\n\n    float T = 1400. + 1300.*i; \/\/ Temperature range (in Kelvin).\n    vec3 L = vec3(7.4, 5.6, 4.4); \/\/ Red, green, blue wavelengths (in hundreds of nanometers).\n    L = pow(L,vec3(5.0)) * (exp(1.43876719683e5\/(T*L))-1.0);\n    L = (1.0-exp(-5e8\/L)); \/\/ Exposure level. Set to \"50.\" For \"70,\" change the \"5\" to a \"7,\" etc.\n    \n    return (L.xyy + L.xzz)*0.5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \/\/ Screen coordinates, plus some movement about the center.\n    vec2 uv = (fragCoord - iResolution.xy*0.5)\/iResolution.y + vec2(0.5*cos(iGlobalTime*0.5), 0.25*sin(iGlobalTime*0.5));\n    \n    \/\/ Camera turbulence.\n    \/\/uv.x += smoothstep(0.4, 0.7, sin(iGlobalTime*2.)*0.5+0.5)*cos(iGlobalTime*48.)*.003;\n    \/\/uv.y += smoothstep(0.4, 0.7, cos(iGlobalTime*2.)*0.5+0.5)*sin(iGlobalTime*64.)*.003;\n    \n    \/\/ Unit direction ray.\n    vec3 rd = normalize(vec3(uv, 1.));\n    \/\/rd.xy *= rot(sin(iGlobalTime*0.25)*0.5); \/\/ Very subtle look around, just to show it's a 3D effect.\n    \/\/rd.xz *= rot(sin(iGlobalTime*0.25)*0.5);\n    \n \n    rd.xy *= rot(smoothstep(0.0, 1., sin(iGlobalTime*0.5)*0.5+0.5)*3.14159); \/\/ Look around, just to show it's a 3D effect.\n    rd.xz *= rot(smoothstep(0.2, 0.8, sin(iGlobalTime*0.25)*0.5+0.5)*3.14159);    \n    \n    \n    \/\/ Screen color. Initialized to black.\n    vec3 col = vec3(0);\n    \n    \/*\n    \/\/ Ray intersection of a cylinder (radius one) - centered at the origin - from a ray-origin that has XY coordinates \n    \/\/ also centered at the origin.    \n    float sDist = max(dot(rd.xy, rd.xy), 1e-16); \/\/ Analogous to the surface function.\n    sDist = 1.4142\/sqrt(sDist); \/\/ Ray origin to surface distance.\n\t*\/\n    \n    \/*\n    \/\/ Same as above, but using a Minkowski distance and scaling factor.\n    vec2 scale = vec2(1., 1.);\n    float power = 6.;\n    float sDist = max(dot( pow(abs(rd.xy)*scale, vec2(power)), vec2(1.) ), 1e-16); \/\/ Analogous to the surface function.\n    sDist = 1.\/pow( sDist, 1.\/power ); \/\/ Ray origin to surface distance.\n\t*\/\n    \n    \n    \/\/ Square tube.\n    vec2 scale = vec2(0.75, 1.);\n    float sDist = max(max(abs(rd.x)*scale.x, abs(rd.y)*scale.y), 1e-16); \/\/ Analogous to the surface function.\n    sDist = 1.\/(sDist); \/\/ Ray origin to surface distance.\n\t\n    \n    \/\/if(sDist>1e-8){\n        \n        \/\/ Surface position.\n        vec3 sp = vec3(0.0, 0.0, iGlobalTime*4.) + rd*sDist;\n \n        \/\/ Surface normal.\n        \/\/vec3 sn = normalize(vec3(-sp.xy, 0.)); \/\/ Cylinder normal.\n        \/\/vec3 sn = normalize(-sign(sp)*vec3(pow(abs(sp.xy)*scale, vec2(power-1.)), 0.)); \/\/ Minkowski normal.\n    \tvec3 sn =  normalize(-sign(sp)*vec3(abs(rd.x*scale.x)>abs(rd.y*scale.y) ? vec2(1., 0.) : vec2(0., 1.), 0.)); \/\/ Square normal.\n    \t\n    \n        \/\/ Coloring the surface.\n        vec3 objCol = texCol(sp, sn);\n        \n        \/\/ Bump mapping.\n        \n        const vec2 eps = vec2(0.015, 0.);\n        float c = dot(objCol, vec3(0.299, 0.587, 0.114)); \/\/ Base value. Saving an extra lookup.\n        \/\/float c = texShade(sp); \/\/ Base value. Used below to color the surface.\n        \/\/ 3D gradient vector... of sorts. Based on the bump function. In this case, Voronoi.                \n        vec3 gr = (vec3(texShade(sp-eps.xyy, sn), texShade(sp-eps.yxy, sn), texShade(sp-eps.yyx, sn))-c)\/eps.x;\n        gr -= sn*dot(sn, gr); \/\/ There's a reason for this... but I need more room. :)\n        sn = normalize(sn + gr*0.1); \/\/ Combining the bump gradient vector with the object surface normal.\n\n    \n    \tfloat wrap = 0.2;\n        float scatWidth = 0.35;\n        \/\/ Lighting.\n        \/\/\n    \t\/\/ Light 1\n        \/\/\n        \/\/ The light is hovering just in front of the viewer.\n        vec3 lp = vec3(0.0, 0.0, iGlobalTime*4. + 2.5);\n        vec3 ld = lp - sp; \/\/ Light direction.\n        float dist = max(length(ld), 0.001); \/\/ Distance from light to the surface.\n        ld \/= dist; \/\/ Use the distance to normalize \"ld.\"\n\n        \/\/ Light attenuation, based on the distance above.\n        float atten = min(1.0\/max(0.75 + dist*0.5 + dist*dist*0.1, 0.001), 1.0);\n        \n       \n        float diff = max((dot(sn, ld) + wrap)\/((1.+wrap)), 0.); \/\/ Diffuse light value.\n        float spec = pow(max(dot(reflect(-ld, sn), -rd), 0.), 16.); \/\/ Specular highlighting.\n    \n    \tfloat scatter = smoothstep(0.0, scatWidth, diff) * smoothstep(scatWidth * 2.0, scatWidth, diff);\n        scatter = pow(scatter, 1.);\n\n    \t\/\/ Light 2\n        \/\/        \n        \/\/ The light is hovering just beind the viewer.\n        vec3 lp2 = vec3(0.0, 0.0, iGlobalTime*4. - 2.5);\n        vec3 ld2 = lp2 - sp; \/\/ Light direction.\n        float dist2 = max(length(ld2), 0.001); \/\/ Distance from light to the surface.\n        ld2 \/= dist2; \/\/ Use the distance to normalize \"ld.\"\n\n        \/\/ Light attenuation, based on the distance above.\n        float atten2 = min(1.0\/max(0.75 + dist2*0.5 + dist2*dist2*0.1, 0.001), 1.0);\n        \n       \n        float diff2 = max((dot(sn, ld2) + wrap)\/((1.+wrap)), 0.); \/\/ Diffuse light value.\n        float spec2 = pow(max(dot(reflect(-ld2, sn), -rd), 0.), 16.); \/\/ Specular highlighting.\n    \n    \tfloat scatter2 = smoothstep(0.0, scatWidth, diff2) * smoothstep(scatWidth * 2.0, scatWidth, diff2);\n    \tscatter2 = pow(scatter2, 1.);\n    \n\n\n        \/\/ Using the values above to produce the final color.\n        col = (objCol*(diff*0.5 + 0.05 + firePalette(scatter\/1.)) + spec*vec3(0.5, 0.85, 1.))*atten;\n    \tcol += (objCol*(diff2*0.5 + 0.05 + firePalette(scatter2\/1.)) + spec2*vec3(0.5, 0.85, 1.))*atten2;\n        \n        \n    \/\/}\n    \n    fragColor = vec4(min(col, 1.), 1.);\n}\n\n    ","name":"","description":"","type":"image"}]}}