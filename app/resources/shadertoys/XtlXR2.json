{"Shader":{"ver":"0.1","info":{"id":"XtlXR2","date":"1438098662","viewed":868,"name":"Pyroclastic sun","username":"Duke","description":"Noise was changed to this http:\/\/www.csee.umbc.edu\/~olano\/papers\/index.html#mNoise one.<br\/>Upd.: Switched to iq's noise from here https:\/\/www.shadertoy.com\/view\/XslGRr <br\/>Previous had some bugs on different browsers.","likes":6,"published":3,"flags":0,"tags":["sun","star","solar","fireball","pyroclastic"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ based on this https:\/\/www.shadertoy.com\/view\/MtXSzS port\n\/\/ iq's noise from here https:\/\/www.shadertoy.com\/view\/XslGRr\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#define saturate(oo) clamp(oo, 0.0, 1.0)\n\n\/\/ Quality Settings\n#define MarchSteps 16\n\/\/ Scene Settings\n#define ExpPosition vec3(0.0)\n#define Radius 1.8\n#define Background vec4(0.1, 0.0, 0.0, 1.0)\n\/\/ Noise Settings\n#define NoiseSteps 4\n#define NoiseAmplitude 0.06\n#define NoiseFrequency 48.0\n#define Animation vec3(0.0, -3.0, 0.5)\n\/\/ Colour Gradient\n#define Color1 vec4(1.0, 1.0, 1.0, 1.0)\n#define Color2 vec4(1.0, 0.8, 0.2, 1.0)\n#define Color3 vec4(1.0, 0.03, 0.0, 1.0)\n#define Color4 vec4(0.5, 0.2, 0.2, 1.0)\n\n\/* noise from here http:\/\/webgl-fire.appspot.com\/html\/fire.html (based on this http:\/\/www.csee.umbc.edu\/~olano\/papers\/index.html#mNoise work)\n\/\/ Pregenerated noise texture.\n  const float modulus = 80.0;  \/\/ Value used in pregenerated noise texture.\n\n\/\/ Modified Blum Blum Shub pseudo-random number generator.\nvec2 mBBS(vec2 val, float modulus) {\n    val = mod(val, modulus); \/\/ For numerical consistancy.\n    return mod(val * val, modulus);\n  }\n\nfloat mnoise(vec3 pos) {\n    float intArg = floor(pos.z);\n    float fracArg = fract(pos.z);\n    vec2 hash = mBBS(intArg * 3.0 + vec2(0, 3), modulus);\n    vec4 g = vec4(\n        texture2D(iChannel0, vec2(pos.x, pos.y + hash.x) \/ modulus).xy,\n        texture2D(iChannel0, vec2(pos.x, pos.y + hash.y) \/ modulus).xy) * 2.0 - 1.0;\n    return mix(g.x + g.y * fracArg,\n               g.z + g.w * (fracArg - 1.0),\n               smoothstep(0.0, 1.0, fracArg));\n  }\n*\/\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D( iChannel0, (uv+ 0.5)\/256.0, -100.0 ).yx;\n\treturn -1.0+1.7*mix( rg.x, rg.y, f.z );\n}\n    \nfloat Turbulence(vec3 position, float minFreq, float maxFreq, float qWidth)\n{\n float value = 0.0;\n float cutoff = clamp(0.5\/qWidth, 0.0, maxFreq);\n float fade;\n float fOut = minFreq;\n for(int i=NoiseSteps ; i>=0 ; i--)\n {\n  if(fOut >= 0.5 * cutoff) break;\n  fOut *= 2.0;\n  value += abs(noise(position * fOut))\/fOut;\n }\n fade = clamp(2.0 * (cutoff-fOut)\/cutoff, 0.0, 1.0);\n value += fade * abs(noise(position * fOut))\/fOut;\n return 1.0-value;\n}\n\nfloat SphereDist(vec3 position)\n{\n return length(position - ExpPosition) - Radius;\n}\n\nvec4 Shade(float distance)\n{\n float c1 = saturate(distance*5.0 + 0.5);\n float c2 = saturate(distance*5.0);\n float c3 = saturate(distance*3.4 - 0.5);\n vec4 a = mix(Color1,Color2, c1);\n vec4 b = mix(a,     Color3, c2);\n return   mix(b,     Color4, c3);\n}\n\n\/\/ Draws the scene\nfloat RenderScene(vec3 position, out float distance)\n{\n float noise = Turbulence(position * NoiseFrequency + Animation*iGlobalTime*0.24, 0.1, 1.5, 0.03) * NoiseAmplitude;\n noise = saturate(abs(noise));\n distance = SphereDist(position) - noise;\n return noise;\n}\n\n\/\/ Basic ray marching method.\nvec4 March(vec3 rayOrigin, vec3 rayStep)\n{\n vec3 position = rayOrigin;\n float distance;\n float displacement;\n for(int step = MarchSteps; step >=0  ; --step)\n {\n  displacement = RenderScene(position, distance);\n  if(distance < 0.05) break;\n  position += rayStep * distance;\n }\n return mix(Shade(displacement), Background, float(distance >= 0.5));\n}\n\nbool IntersectSphere(vec3 ro, vec3 rd, vec3 pos, float radius, out vec3 intersectPoint)\n{\n vec3 relDistance = (ro - pos);\n float b = dot(relDistance, rd);\n float c = dot(relDistance, relDistance) - radius*radius;\n float d = b*b - c;\n intersectPoint = ro + rd*(-b - sqrt(d));\n return d >= 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 p = (gl_FragCoord.xy \/ iResolution.xy) * 2.0 - 1.0;\n p.x *= iResolution.x\/iResolution.y;\n float rotx = iMouse.y * 0.01;\n float roty = -iMouse.x * 0.01+iGlobalTime*0.1;\n float zoom = 5.0;\n \/\/ camera\n vec3 ro = zoom * normalize(vec3(cos(roty), cos(rotx), sin(roty)));\n vec3 ww = normalize(vec3(0.0, 0.0, 0.0) - ro);\n vec3 uu = normalize(cross( vec3(0.0, 1.0, 0.0), ww));\n vec3 vv = normalize(cross(ww, uu));\n vec3 rd = normalize(p.x*uu + p.y*vv + 1.5*ww);\n vec4 col = Background;\n vec3 origin;\n if(IntersectSphere(ro, rd, ExpPosition, Radius + NoiseAmplitude*14.0, origin))\n {\n  col = March(origin, rd);\n }\n fragColor = col;\n}","name":"","description":"","type":"image"}]}}