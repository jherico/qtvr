{"Shader":{"ver":"0.1","info":{"id":"MtsXRX","date":"1439066444","viewed":1274,"name":"[SIG15] Earthbound VR","username":"RavenWorks","description":"Based partly on work I did before the compo was announced, but now with greatly expanded content!<br\/>I always wondered what it would be like to be 'in' these scenes...<br\/>Kind of a mishmash of scenes throughout the game because I couldn't pick just one :P","likes":10,"published":3,"flags":9,"tags":["game","raymarch","retro","snes","vr","compo","earthbound","rpg","sig15"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/sync with sound\nconst float encounterStart = 9.2;\nconst float transitionStart = encounterStart+0.25;\nconst float transitionEnd = transitionStart+3.0;\n\n\n\n\n\n\n\n\n\nvec3 diamondShine(float i){\n    float shine = abs(mod(i,2.0)-1.0);\n    shine *= 7.0;\n    return vec2(32.0+shine*24.0,4.0+shine*20.0).xxy\/255.0;\n}\n\nvec3 bgTexture(vec2 tileCoord)\n{\n\t\n    tileCoord.y += iGlobalTime*0.1;\n    tileCoord.y += pow(sin(tileCoord.y+iGlobalTime*0.75),2.0);\n    \n    vec2 withinTile = mod(tileCoord,1.0);\n    vec2 tileStep = floor(tileCoord);\n    \n    bool inDiamond = (abs(withinTile.x-0.5) + abs(withinTile.y-0.5)) < 0.5;\n    \n    vec3 color;\n    if (inDiamond) {\n        return diamondShine( tileStep.x*1.1 + tileStep.y*1.6 + iGlobalTime*0.5 );\n    } else {\n        return vec3(80.0\/255.0,96.0\/255.0,72.0\/255.0);\n    }\n\t\n}\n\n\n\n\n\n\n\n\n\n\nconst float PI =3.141592;\nconst float PI2=6.2831853;\n\n\n\n\nfloat smooth( float a, float b, float k ){\n    float h = clamp(0.5+0.5*(b-a)\/k,0.0,1.0);\n    return mix(b,a,h) - k*h*(1.0-h);\n}\n\nvoid hardAdd(inout int curMaterial, inout float curD, int newMaterial, float newD){\n    if (newD < curD) {\n        curD = newD;\n        curMaterial = newMaterial;\n    }\n}\nvoid hardSubtract(inout float curD, float newD) {\n    curD = max( -newD, curD );\n}\nvoid smoothAdd(inout float curD, float newD, float blendPower){\n    curD = smooth( newD, curD, blendPower );\n}\nvoid smoothSubtract(inout float curD, float newD, float blendPower){\n    curD = -smooth( newD , -curD , blendPower );\n}\n\n\nfloat obj_ball(vec3 p, vec3 center, float radius){\n    return length(p-center)-radius;\n}\nfloat obj_cylinder(vec3 p, vec3 center, vec2 size, float roundness){\n    vec3 tp = p-center;\n    vec2 d = abs(vec2(length(tp.yz),tp.x)) - (size-roundness);\n    return min(max(d.x,d.y)+roundness,0.0) + length(max(d,0.0))-roundness;\n}\nfloat obj_cylForever(vec2 p, vec2 middle, float radius){\n    return abs(length(p-middle)) - radius;\n}\nfloat obj_roundline( vec3 p, vec3 a, vec3 b, float r ){\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nfloat obj_box(vec3 p, vec3 center, vec3 size, float roundness){\n    vec3 d = abs(p-center) - (size-roundness);\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - roundness;\n}\nfloat obj_torus( vec3 p, vec3 center, vec2 t ){\n    vec3 tp = p-center;\n\tvec2 q = vec2(length(tp.xy)-t.x,tp.z);\n\treturn length(q)-t.y;\n}\nfloat obj_quartertorus( vec3 p, vec3 center, vec2 t ){\n    vec3 tp = p-center;\n    tp.x = max(tp.x,0.0);\n    tp.y = max(tp.y,0.0);\n    \/\/ okay that honestly isn't what I set out to make, but it saves me several other shapes..!\n\tvec2 q = vec2(length(tp.xy)-t.x,tp.z);\n\treturn length(q)-t.y;\n}\n\nfloat obj_repeatPebble(vec3 p, vec2 period, float radius){\n    vec3 mp = p;\n    const float offset = 1000.0;\n    mp.x = mod(p.x+offset,period.x);\n    mp.z = mod(p.z+offset,period.y);\n    float stepX = floor((p.x+offset)\/period.x);\n    float stepZ = floor((p.z+offset)\/period.y);\n    vec3 c = vec3(period.x*0.5,0.0,period.y*0.5);\n    c.x += (sin(stepX) + sin(stepZ))*0.125*period.x;\n    c.z += (sin(stepX*2.0) + sin(stepZ))*0.125*period.y;\n    float r = radius * (1.0 + (sin(stepX) + sin(stepZ))*0.25);\n    return obj_ball(mp,c,r);\n}\n\n\n\/\/ I should probably make a way to bundle materials into shapes\n\/\/ rather than being redundant with hardAdd like this\n\/\/ oh well\nvoid obj_ufo(vec3 p, vec3 center, float eyeOff, inout int curMaterial, inout float curD){\n    \n    float distance = 9999.9;\n    int material = 0;\n    \n    vec3 ufoRotP = p;\n    \n    vec3 ufoBodyP = ufoRotP;\n    ufoBodyP.y -= center.y+0.3;\n    ufoBodyP.y = abs(ufoBodyP.y);\n    \n    hardAdd(material,distance,5,\n\t\tobj_ball(ufoBodyP,vec3(center.x,-1.0,center.z),1.1)\n\t);\n    smoothAdd(distance,\n\t\tobj_ball(ufoBodyP,vec3(center.x,0.03,center.z),0.2),\n    0.1);\n    \n    vec3 ufoEyeP = ufoRotP;\n    ufoEyeP.x -= center.x+eyeOff;\n    ufoEyeP.x = abs(ufoEyeP.x);\n    \n    hardAdd(material,distance,6,\n\t\tobj_ball(ufoEyeP,vec3(0.045,center.y+0.41,center.z+0.25),0.025)\n\t);\n    \n    \n    \n    \n    if (distance < curD) {\n        curD = distance;\n        curMaterial = material;\n    }\n    \n    \n}\n\n\n\n\n\nconst float fadeSpd = 1.0;\n\n\nfloat ufoX = 0.0;\nfloat ufoZ = 0.0;\n\n\nfloat caveDistance(vec3 p, inout int material){\n    \n    float distance = 9999.9;\n    material = 0;\n    \n    \n    \n    \n    \n    \n    \n    const float wallLumpDist = 4.0;\n    const float lumpsBeforeMod = 4.0;\n    \n    vec3 wallP = p;\n    wallP.x = abs(p.x);\n    for(float i=0.0; i<lumpsBeforeMod; i++){\n        \n        float subOff = (i\/lumpsBeforeMod)*wallLumpDist;\n        float wallStep = (floor((p.z+subOff)\/wallLumpDist)-(i\/lumpsBeforeMod))*wallLumpDist + ((p.x<0.0)?60.0:0.0);\n        wallP.z = mod(p.z+subOff,wallLumpDist);\n        \n        float wallDist = 6.0;\n        wallDist += sin(wallStep*10.0)*0.1;\n        wallDist += sin(wallStep*17.0)*0.1;\n        wallDist += sin(wallStep*0.5)*1.0;\n        wallDist += sin(wallStep*0.87)*0.25;\n        if (p.y > 5.0) wallDist += 6.0;\/\/safe because we're looking up\n        \n        float curD = obj_cylinder(wallP.yxz,vec3(0.0,wallDist,wallLumpDist*0.5),vec2(0.6,12.0),0.0);\n        \n        if (i==0.0) {\n            hardAdd(material,distance,2,curD);\n        } else {\n            smoothAdd(distance,curD,0.3);\n        }\n    }\n    \n    \n    \n    hardAdd(material,distance,1,\n\t\tp.y-0.0\n    );\n    \n    smoothAdd(distance,\n\t\tobj_repeatPebble(p,vec2(0.65,2.01),0.05)\n\t,0.05);\n    smoothAdd(distance,\n\t\tobj_repeatPebble(p,vec2(0.47,1.51),0.04)\n\t,0.04);\n    smoothAdd(distance,\n\t\tobj_repeatPebble(p,vec2(0.81,1.01),0.03)\n\t,0.03);\n    \n    \n    \n    \n    \n    vec3 ufoPos = vec3(ufoX,1.1,ufoZ);\n    obj_ufo(p,ufoPos,0.0,material,distance);\n    \n    \n    \n    return distance;\n    \n}\n\n\n\n\n\n\nconst float bgDist = 10.0;\nconst float enemyDist = -2.0;\nconst float enemyHeight = 0.9;\nconst float enemyOffX = 0.6;\nconst float healthDist = -0.75;\nconst float healthModX = 0.35;\n\n\nfloat sceneDistance(vec3 p, inout int material){\n    \n    float distance = 9999.9;\n    material = 0;\n    \n    \n    \n    hardAdd(material,distance,1,\n    \t-obj_cylForever(p.xz, vec2(0.0),bgDist)\n    );\n    \n    \n    const float outlineRad = 0.02;\n    vec2 healthSize = vec2(0.25,0.3)\/2.0;\n    if (abs(p.x)<healthModX*2.0) {\n        \n        vec3 healthP = p;\n        healthP.y -= 0.85;\n        \n        healthP.x = mod(healthP.x,healthModX);\n        healthP.x -= healthModX\/2.0;\n        \n        vec3 healthFrameP = healthP;\n        healthFrameP.y = abs(healthFrameP.y);\n        healthFrameP.x = abs(healthFrameP.x);\n        \n        \n        const float boxThickness = 0.03;\n        hardAdd(material,distance,3,\n\t\t\tobj_box(healthFrameP,vec3(0.0,0.0,healthDist-boxThickness+0.01),vec3(healthSize.xy,boxThickness),0.0)\n\t\t);\n        \n        const float healthInset = 0.01;\n        smoothSubtract(distance,\n            obj_box(healthP,vec3(0.05,-0.075,healthDist),vec3(0.075,0.125,healthInset),0.0),\n        \t0.01\n        );\n\n        \n        hardAdd(material,distance,2,\n            obj_quartertorus(healthFrameP,vec3(healthSize.xy,healthDist),vec2(outlineRad,outlineRad-0.001))\n        );\n        \n        \n        \n        vec3 wheelP = healthP;\n        wheelP.x -= 0.05;\n        wheelP.x = abs(wheelP.x);\n\n\n        wheelP.y += 0.05;\n        wheelP.y = abs(wheelP.y);\n\n        hardAdd(material,distance,2,\n        \tobj_cylinder(wheelP,vec3(0.0,0.05,healthDist-healthInset),vec2(0.05,0.025),0.0075)\n        );\n        hardAdd(material,distance,2,\n        \tobj_cylinder(wheelP,vec3(0.05,0.05,healthDist-healthInset),vec2(0.05,0.025),0.0075)\n        );\n\n    }\n    \n    vec3 statusP = p;\n    statusP.y -= 2.1;\n    statusP.y = abs(statusP.y);\n    \n    statusP.x += 0.6;\n    statusP.x = abs(statusP.x);\n    \n    const float statusW = 1.2;\n    const float statusH = 0.3;\n    const float statusDist = -3.0;\n    const float innerRad = 0.025;\n    \n    hardAdd(material,distance,2,\n    \tobj_quartertorus(statusP,vec3(statusW,statusH,statusDist),vec2(innerRad*2.0,innerRad))\n    );\n    hardAdd(material,distance,4,\n    \tobj_box(statusP,vec3(0.0,0.0,statusDist-0.005),vec3(statusW+innerRad,statusH+innerRad,0.01),0.0)\n    );\n    \n    \n    \n    \n    float ufoHeight = enemyHeight+sin(iGlobalTime*2.5)*0.02;\n    obj_ufo(p,vec3(-enemyOffX,ufoHeight,enemyDist),0.05,material,distance);\n    \n    \n    \n    \n    const float foppyWidth = 0.1;\n    float foppyBob = pow(1.0-(sin(iGlobalTime*4.0)*0.5+0.5),1.1);\n    float foppyHeight = enemyHeight+0.3 + foppyBob*0.03;\n    hardAdd(material,distance,7,\n    \tobj_ball(p,vec3(enemyOffX+foppyWidth,foppyHeight,enemyDist),0.2)\n\t);\n    smoothAdd(distance,\n    \tobj_ball(p,vec3(enemyOffX-foppyWidth,foppyHeight,enemyDist),0.2),\n\t0.3);\n    \n    float legOff = 0.25 - foppyBob*0.02;\n    float legSize = 0.09 - foppyBob*0.01;\n    hardAdd(material,distance,7,\n    \tobj_ball(p,vec3(enemyOffX-legOff,enemyHeight+0.1,enemyDist+0.2),legSize)\n\t);\n    hardAdd(material,distance,7,\n    \tobj_ball(p,vec3(enemyOffX+legOff,enemyHeight+0.08,enemyDist-0.1),legSize)\n\t);\n    \n    \n    vec3 foppyEyeP = p;\n    foppyEyeP.x -= enemyOffX-0.05;\n    foppyEyeP.x = abs(foppyEyeP.x);\n    \n    hardAdd(material,distance,8,\n    \tobj_ball(foppyEyeP,vec3(0.1,foppyHeight+0.07,enemyDist+0.26),0.015)\n\t);\n    \n    \n    \n    return distance;\n    \n}\n\n\n\n\n\n\/\/\n\/\/ https:\/\/gist.github.com\/num3ric\/4408481\n\/\/\nstruct Ray {\n    vec3 o; \/\/origin\n    vec3 d; \/\/direction (should always be normalized)\n};\nstruct Sphere {\n    vec3 pos;   \/\/center of sphere position\n    float rad;  \/\/radius\n};\nfloat intersectSphere(in Ray ray, in Sphere sphere){\n    vec3 oc = ray.o - sphere.pos;\n    float b = 2.0 * dot(ray.d, oc);\n    float c = dot(oc, oc) - sphere.rad*sphere.rad;\n    float disc = b * b - 4.0 * c;\n\n    if (disc < 0.0)\n        return -1.0;\n\n    \/\/ compute q as described above\n    float q;\n    if (b < 0.0)\n        q = (-b - sqrt(disc))\/2.0;\n    else\n        q = (-b + sqrt(disc))\/2.0;\n\n    float t0 = q;\n    float t1 = c \/ q;\n\n    \/\/ make sure t0 is smaller than t1\n    if (t0 > t1) {\n        \/\/ if t0 is bigger than t1 swap them around\n        float temp = t0;\n        t0 = t1;\n        t1 = temp;\n    }\n\n    \/\/ if t1 is less than zero, the object is in the ray's negative direction\n    \/\/ and consequently the ray misses the sphere\n    if (t1 < 0.0)\n        return -1.0;\n\n    \/\/ if t0 is less than zero, the intersection point is at t1\n    if (t0 < 0.0) {\n        return t1;\n    } else {\n        return t0; \n    }\n}\n\n\n\n\n\/\/ uuuuuuuugh\nint getBit(int bitnum){\n    if (bitnum == 0) return 1;\n    if (bitnum == 1) return 2;\n    if (bitnum == 2) return 4;\n    if (bitnum == 3) return 8;\n    if (bitnum == 4) return 16;\n    if (bitnum == 5) return 32;\n    if (bitnum == 6) return 64;\n    if (bitnum == 7) return 128;\n    if (bitnum == 8) return 256;\n    if (bitnum == 9) return 512;\n    if (bitnum == 10) return 1024;\n    if (bitnum == 11) return 2048;\n    if (bitnum == 12) return 4096;\n    if (bitnum == 13) return 8192;\n    if (bitnum == 14) return 16384;\n    return 0;\n}\n\nbool bitLit(int readfrom, int bitnum){\n    int divideBy = getBit(bitnum);\n    int divided = readfrom\/divideBy;\n    int wipedFirstBit = divided\/2;\n    wipedFirstBit *= 2;\n    return (divided != wipedFirstBit);\n}\n\n\nint getStatusMsg1a(int x){\n\tif (x == 0 || x == 2) return 0x18;\n\tif (x == 1) return 0x3c;\n\tif (x == 5 || x == 9) return 0x1;\n\tif (x == 6 || x == 8) return 0x6;\n\tif (x == 7 || x == 31) return 0xf8;\n\tif (x == 11 || x == 14 || x == 23 || x == 41 || x == 49) return 0x78;\n\tif (x == 12 || x == 13) return 0x84;\n\tif (x == 16) return 0x7c;\n\tif (x == 17 || x == 18 || x == 42) return 0x80;\n\tif (x == 19 || x == 28) return 0xfc;\n\tif (x == 24 || x == 25 || x == 39 || x == 40 || x == 50 || x == 51) return 0x94;\n\tif (x == 26 || x == 52) return 0x58;\n\tif (x == 29 || x == 30) return 0x4;\n\tif (x == 33 || x == 44) return 0x278;\n\tif (x == 34 || x == 35 || x == 45 || x == 46) return 0x484;\n\tif (x == 36 || x == 47) return 0x3fc;\n\tif (x == 38) return 0x60;\n    return 0;\n}\nint getStatusMsg1b(int x){\n    if (x == 0 || x == 5 || x == 6 || x == 34 || x == 35 || x == 37 || x == 38) return 0x4;\n\tif (x == 1) return 0x7f;\n\tif (x == 2) return 0x84;\n\tif (x == 4 || x == 16) return 0xff;\n\tif (x == 7 || x == 36 || x == 39) return 0xf8;\n\tif (x == 9 || x == 25 || x == 44) return 0x78;\n\tif (x == 10 || x == 11 || x == 23 || x == 24 || x == 42 || x == 43) return 0x94;\n\tif (x == 12) return 0x58;\n\tif (x == 17 || x == 18) return 0x9;\n\tif (x == 19) return 0x39;\n\tif (x == 20) return 0xc6;\n\tif (x == 22 || x == 41) return 0x60;\n\tif (x == 26 || x == 45) return 0x80;\n\tif (x == 28) return 0x27c;\n\tif (x == 29 || x == 30) return 0x480;\n\tif (x == 31) return 0x3fc;\n\tif (x == 33) return 0xfc;\n    return 0;\n}\nint getStatusMsg1c(int x){\n    if (x == 0) return 0xfc;\n\tif (x == 1) return 0x8;\n\tif (x == 2 || x == 10 || x == 11) return 0x4;\n\tif (x == 4 || x == 14 || x == 19) return 0x78;\n\tif (x == 5 || x == 6 || x == 20 || x == 21) return 0x84;\n\tif (x == 7) return 0x48;\n\tif (x == 9 || x == 22 || x == 32) return 0xff;\n\tif (x == 12) return 0xf8;\n\tif (x == 15 || x == 16) return 0x94;\n\tif (x == 17) return 0x58;\n\tif (x == 26 || x == 30) return 0x7f;\n\tif (x == 27 || x == 28 || x == 29) return 0x80;\n\tif (x == 33 || x == 34) return 0x9;\n\tif (x == 35) return 0x1;\n\tif (x == 37 || x == 41) return 0x7e;\n\tif (x == 38 || x == 39 || x == 40) return 0x81;\n    return 0;\n}\nint getStatusMsg2(int x){\n\tif (x == 5 || x == 32) return 0x60;\n\tif (x == 6 || x == 7 || x == 30 || x == 31) return 0x94;\n\tif (x == 8 || x == 16 || x == 36 || x == 41 || x == 44 || x == 51 || x == 54) return 0x78;\n\tif (x == 9 || x == 64) return 0x80;\n\tif (x == 11 || x == 56) return 0xfc;\n\tif (x == 12 || x == 13 || x == 25 || x == 47 || x == 48 || x == 58 || x == 60) return 0x4;\n\tif (x == 14 || x == 49) return 0xf8;\n\tif (x == 17 || x == 18 || x == 27 || x == 37 || x == 38 || x == 42 || x == 43 || x == 52 || x == 53 || x == 62) return 0x84;\n\tif (x == 19 || x == 46) return 0xff;\n\tif (x == 23) return 0xfd;\n\tif (x == 26 || x == 61) return 0x7f;\n\tif (x == 29) return 0x88;\n\tif (x == 39) return 0x48;\n\tif (x == 57) return 0x8;\n    return 0;\n}\n\n\n\n\n\nconst vec3 e=vec3(0.00007,0,0);\nconst float maxd=256.0; \/\/Max depth\nfloat nearestD = maxd;\nvec3 color;\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ) {\n    \n    \n    \n    vec3 scrCoord = fragRayOri;\n    vec3 curCameraRayUnit = fragRayDir;\n    \n    \n    color = vec3(0.0);\n    \n    \n    const float headHeight = 1.5;\n    scrCoord.y += headHeight;\n    \n    \n    \n    \n    \n    \n    \n    \n    if (iGlobalTime < transitionEnd) {\n        \n        \n        float fwd = (encounterStart-iGlobalTime)*1.0;\n        fwd = max(0.0,fwd);\n        scrCoord.z += fwd;\n        \n        \n        \n        \n        \n        float straightUfoDist = (encounterStart - iGlobalTime)*4.0;\n        straightUfoDist = max(0.0,straightUfoDist);\n        const float ufoStepDist = 12.0;\n        float ufoStep = floor(straightUfoDist\/ufoStepDist);\n        float withinStep = mod(straightUfoDist\/ufoStepDist,1.0);\n        const float ufoDuty = 0.5;\n        withinStep \/= ufoDuty;\n        withinStep = min(1.0,withinStep);\n        float stutterUfoDist = (ufoStep+withinStep)*ufoStepDist;\n\n        ufoX = 0.0;\n        ufoX += sin(stutterUfoDist*0.5)*1.0;\n        ufoX += sin(stutterUfoDist*0.9)*1.0;\n        \n        ufoZ = -1.5-stutterUfoDist;\n\n        \n        \n        \n        \n        \n        \n        float f=0.0;\n        float d=0.01;\n        int mat=0;\n        int dummyMat;\n        vec3 p;\n        for(int i=0;i<72;i++){\n            if ((abs(d) < .001) || (f > maxd)) break;\n            f+=d;\n            p=scrCoord + curCameraRayUnit*f;\n            d = caveDistance(p,mat);\n        }\n\n        if (f < nearestD) {\n\n            nearestD = f;\n\n            vec3 n = normalize(vec3(d-caveDistance(p-e.xyy,dummyMat),\n                                    d-caveDistance(p-e.yxy,dummyMat),\n                                    d-caveDistance(p-e.yyx,dummyMat)));\n\n\n            \n            float specP = 1.0;\n            float specA = 0.0;\n            float diffMin = 0.0;\n            vec3 lightCol = vec3(1.0);\n            vec3 darkCol = vec3(0.0);\n\n            \/\/ floor\n            if (mat == 1) {\n                lightCol = vec3(160.0,144.0,96.0)\/255.0;\n                darkCol = vec3(144.0,128.0,88.0)\/255.0;\n                diffMin = -1.5;\n            \/\/ wall\n            } else if (mat == 2) {\n                if (mod(p.y+pow(sin((p.z+abs(p.x))*8.0),4.0)*0.08+0.9,0.4)<0.1) {\n                    lightCol = vec3(192.0,200.0,152.0)\/255.0;\n                    darkCol = vec3(120.0,120.0,104.0)\/255.0;\n                } else {\n                \tlightCol = vec3(152.0,160.0,128.0)\/255.0;\n                    darkCol = vec3(80.0)\/255.0;\n                }\n                diffMin = -1.5;\n                \n            \/\/UFO skin\n            } else if (mat == 5) {\n                lightCol = vec3(0.7);\n                specA = 1.0;\n                specP = 6.0;\n                \n            \/\/UFO eyes\n            } else if (mat == 6) {\n                lightCol = vec3(0.2);\n                specA = 0.65;\n                specP = 16.0;\n                \n            }\n            \n            \n            \n            \n            vec3 pointLightPos = vec3(0.0,2.0,scrCoord.z-1.5);\n            vec3 L = normalize(pointLightPos-p);\n\n            float diffuse=max(dot(n,L),0.0);\n            diffuse = diffMin + (1.0-diffMin)*diffuse;\n            vec3 H = normalize(L-curCameraRayUnit);\n            float specular = max(dot(H,n),0.0);\n            color = mix(darkCol,lightCol,diffuse) + pow(specular,specP)*specA;\n\n            float lightDist = (length(pointLightPos-p)) * 0.02;\n            lightDist = max(0.0,min(1.0,lightDist));\n            color *= 1.0-lightDist;\/\/a little faker without a square falloff but I think I like it like that\n            \n            \n            if (p.y < 0.5) {\/\/ if NOT the ufo!\n                float occlusion = length(p.xz-vec2(ufoX,ufoZ));\n                occlusion = pow(occlusion,0.5);\n                occlusion = max(0.0,min(1.0,(occlusion*1.8)));\n                occlusion = 0.7+occlusion*0.3;\n                color *= occlusion;\n            }\n            \n            \n        }\n        \n        if (iGlobalTime > encounterStart) {\n            \n            if (mat < 5) {\n                \n                color = vec3(color.r*0.2126+color.g*0.7152+color.b*0.0722);\n                const float blackLevel = 0.2;\n                color = blackLevel + color*(1.0-blackLevel);\n                \n                vec3 headSphereMiddle = vec3(0.0,headHeight,0.0);\n                float headSphereRad = headHeight;\n                float swirlSphereDist = intersectSphere(Ray(scrCoord,curCameraRayUnit),Sphere(headSphereMiddle,headSphereRad));\n                vec3 swirlSpherePt = scrCoord+curCameraRayUnit*swirlSphereDist;\n                swirlSpherePt -= headSphereMiddle;\n                swirlSpherePt \/= headSphereRad;\n                \n                float swirlDist = -swirlSpherePt.z;\n                swirlDist = acos(swirlDist);\n            \tswirlDist \/= (PI\/2.0);\n                swirlDist = pow(swirlDist,0.22);\n                \n                float swirlAng = atan(swirlSpherePt.y,swirlSpherePt.x);\n                swirlAng = swirlAng\/(PI*2.0)+0.5;\n                \n                const float stripeWidth = 0.04;\n                \n                swirlDist += swirlAng*stripeWidth*2.0;\n                \n                float stripeProgress = floor(swirlDist\/stripeWidth)-swirlAng*2.0;\n                \n                float swirlOff = (0.5\/stripeWidth)+(iGlobalTime-transitionStart)*10.0;\n                if (mod(swirlDist,stripeWidth*2.0) < stripeWidth) swirlOff -= 1.5;\n                \n                float greenAmt = (stripeProgress-swirlOff)*16.0;\n                greenAmt = max(0.0,min(1.0,1.0-greenAmt));\n                \n                color *= vec3(1.0-greenAmt,1.0,1.0-greenAmt);\n            }\n            \n        }\n\n\n\n        float fadeOutAmt = min(1.0,(transitionEnd-iGlobalTime)*fadeSpd);\n        color *= pow(fadeOutAmt,2.0);\n        \n        \n        \n    } else {\n        \n        \n        vec3 p = scrCoord;\n\n        float f=0.0;\n        float d=0.01;\n        int mat, dummyMat;\n        for(int i=0;i<64;i++){\n            if ((abs(d) < .001) || (f > maxd)) break;\n            f+=d;\n            p=scrCoord + curCameraRayUnit*f;\n            d = sceneDistance(p,mat);\n        }\n\n        if (f < nearestD) {\n\n            nearestD = f;\n\n            vec3 n = normalize(vec3(d-sceneDistance(p-e.xyy,dummyMat),\n                                    d-sceneDistance(p-e.yxy,dummyMat),\n                                    d-sceneDistance(p-e.yyx,dummyMat)));\n\n\n\n            vec3 lightDir = normalize(vec3(0.0,0.25,1.0));\n            float specP = 1.0;\n            float specA = 0.0;\n\n            float diffMin = 0.0;\n            \n            \n            \n            bool bit = false;\n            if (mat == 2 || mat == 3) {\n                int statusNum = int(floor(p.x\/healthModX))+2;\n                vec2 perStatusP = vec2(mod(p.x,healthModX),p.y);\n                perStatusP.x -= 0.05;\n                perStatusP.y -= 1.025;\n                perStatusP *= 160.0;\n                perStatusP.y *= -1.0;\n                perStatusP -= vec2(2.0,8.0);\n                \n                int byte1 = 0;\n                int byte2 = 0;\n                int byte3 = 0;\n                \n                int charX;\n                int charY;\n                \n                if (perStatusP.y >= 0.0 && perStatusP.y < 9.0) {\n                    int char = int(floor(perStatusP.x\/6.0));\n                    charX = int(floor(mod(perStatusP.x,6.0)));\n                    charY = int(floor(perStatusP.y));\n                    if (statusNum == 0) {\n                        if (char == 0) {\n\t\t\t\t\t\t\t\/\/ R\n\t\t\t\t\t\t\tbyte1 = 0x6de0;\n\t\t\t\t\t\t\tbyte2 = 0x3dfb;\n\t\t\t\t\t\t\tbyte3 = 0x1b;\n                        } else if (char == 1) {\n                            \/\/ a\n\t\t\t\t\t\t\tbyte1 = 0x3800;\n\t\t\t\t\t\t\tbyte2 = 0x6fd8;\n\t\t\t\t\t\t\tbyte3 = 0x1e;\n                        } else if (char == 2) {\n                            \/\/ v\n\t\t\t\t\t\t\tbyte1 = 0x6c00;\n\t\t\t\t\t\t\tbyte2 = 0x39db;\n\t\t\t\t\t\t\tbyte3 = 0x4;\n                        } else if (char == 3) {\n                            \/\/ e\n\t\t\t\t\t\t\tbyte1 = 0x3800;\n\t\t\t\t\t\t\tbyte2 = 0xdfb;\n\t\t\t\t\t\t\tbyte3 = 0xe;\n                        } else if (char == 4) {\n                            \/\/ n\n\t\t\t\t\t\t\tbyte1 = 0x3400;\n\t\t\t\t\t\t\tbyte2 = 0x6f7b;\n\t\t\t\t\t\t\tbyte3 = 0x1b;\n                        }\n                    } else if (statusNum == 1) {\n                        if (char == 0) {\n                            \/\/ P\n\t\t\t\t\t\t\tbyte1 = 0x6de0;\n\t\t\t\t\t\t\tbyte2 = 0xdfb;\n\t\t\t\t\t\t\tbyte3 = 0x3;\n                        } else if (char == 1 || char == 4) {\n                            \/\/ a\n\t\t\t\t\t\t\tbyte1 = 0x3800;\n\t\t\t\t\t\t\tbyte2 = 0x6fd8;\n\t\t\t\t\t\t\tbyte3 = 0x1e;\n                        } else if (char == 2) {\n                            \/\/ u\n\t\t\t\t\t\t\tbyte1 = 0x6c00;\n\t\t\t\t\t\t\tbyte2 = 0x6f7b;\n\t\t\t\t\t\t\tbyte3 = 0x16;\n                        } else if (char == 3) {\n                            \/\/ l\n\t\t\t\t\t\t\tbyte1 = 0x18c6;\n\t\t\t\t\t\t\tbyte2 = 0x18c6;\n\t\t\t\t\t\t\tbyte3 = 0x6;\n                        }\n                    } else if (statusNum == 2) {\n                        if (char == 0) {\n                            \/\/ J\n\t\t\t\t\t\t\tbyte1 = 0x18c0;\n\t\t\t\t\t\t\tbyte2 = 0x18c6;\n\t\t\t\t\t\t\tbyte3 = 0xcc6;\n                        } else if (char == 1) {\n                            \/\/ e\n\t\t\t\t\t\t\tbyte1 = 0x3800;\n\t\t\t\t\t\t\tbyte2 = 0xdfb;\n\t\t\t\t\t\t\tbyte3 = 0xe;\n                        } else if (char == 2 || char == 3) {\n                            \/\/ f\n\t\t\t\t\t\t\tbyte1 = 0x3ccc;\n\t\t\t\t\t\t\tbyte2 = 0x18c6;\n\t\t\t\t\t\t\tbyte3 = 0xcc6;\n                        }\n                    } else if (statusNum == 3) {\n                        if (char == 0) {\n                            \/\/ P\n\t\t\t\t\t\t\tbyte1 = 0x6de0;\n\t\t\t\t\t\t\tbyte2 = 0xdfb;\n\t\t\t\t\t\t\tbyte3 = 0x3;\n                        } else if (char == 1 || char == 2) {\n                            \/\/ o\n\t\t\t\t\t\t\tbyte1 = 0x3800;\n\t\t\t\t\t\t\tbyte2 = 0x6f7b;\n\t\t\t\t\t\t\tbyte3 = 0xe;\n                        }\n                    }\n                }\n                perStatusP.y -= 15.0;\n                if (perStatusP.y > 0.0) {\n                    int pY = int(floor(mod(perStatusP.y,16.0)));\n                    int row = int(floor(perStatusP.y\/16.0));\n                    int leftX = int(floor(mod(perStatusP.x,6.0)));\n                    int letter = int(floor(perStatusP.x\/6.0));\n                    if (row == 0 && letter == 0 && leftX > 2 && pY != 4) leftX -= 3;\n                    if (letter >= 0 && row < 2) {\n                        if (pY < 9 && leftX < 3 && letter < 2) {\n                            if (pY == 0 || pY == 8) bit = true;\n                            if (leftX == 0) bit = !bit;\n                        }\n                        if (row != 0 || letter != 0) {\n                            if (letter < 2) {\n                                if (leftX == 3) {\n                                    if (pY < 8 && pY != 1 && pY != 5) bit = true;\n                                } else if (leftX > 3) {\n                                    if (pY == 0+(leftX-4) || pY == 6-(leftX-4)) bit = true;\n                                }\n                            }\n                            if (letter == 2 && leftX == 0 && pY > 1 && pY < 5) bit = true;\n                        }\n                    }\n                }\n                \n                perStatusP.x -= 15.5;\n                int wheelNum = int(floor(perStatusP.x\/8.0));\n                int wheelRow = int(floor(perStatusP.y\/16.0));\n                int pX = int(floor(mod(perStatusP.x,8.0)));\n                int pY = int(floor(mod(perStatusP.y,16.0)));\n                \n                if (wheelNum >= 0 && wheelRow >= 0 && pY<9) {\n                    charX = pX;\n                    charY = pY;\n                    if (wheelRow == 0) {\n                        if (statusNum == 0) {\n                            if (wheelNum == 0) {\n                                \/\/ 3\n                                byte1 = 0x6f6e;\n                                byte2 = 0x61d8;\n                                byte3 = 0x3b7b;\n                            } else if (wheelNum == 1) {\n                                \/\/ 1\n\t\t\t\t\t\t\t\tbyte1 = 0x31cc;\n\t\t\t\t\t\t\t\tbyte2 = 0x318c;\n\t\t\t\t\t\t\t\tbyte3 = 0x798c;\n                            } else if (wheelNum == 2) {\n                                \/\/ 4\n\t\t\t\t\t\t\t\tbyte1 = 0x7b98;\n\t\t\t\t\t\t\t\tbyte2 = 0x6f7b;\n\t\t\t\t\t\t\t\tbyte3 = 0x631f;\n                            }\n                        } else if (statusNum == 1) {\n                            if (wheelNum == 0) {\n                                \/\/ 1\n\t\t\t\t\t\t\t\tbyte1 = 0x31cc;\n\t\t\t\t\t\t\t\tbyte2 = 0x318c;\n\t\t\t\t\t\t\t\tbyte3 = 0x798c;\n                            } else if (wheelNum == 1) {\n                                \/\/ 5\n\t\t\t\t\t\t\t\tbyte1 = 0xf7f;\n\t\t\t\t\t\t\t\tbyte2 = 0x630f;\n\t\t\t\t\t\t\t\tbyte3 = 0x3b7b;\n                            } else if (wheelNum == 2) {\n                                \/\/ 9\n\t\t\t\t\t\t\t\tbyte1 = 0x6f6e;\n\t\t\t\t\t\t\t\tbyte2 = 0x63db;\n\t\t\t\t\t\t\t\tbyte3 = 0x3b7b;\n                            }\n                        } else if (statusNum == 2) {\n                            if (wheelNum == 0) {\n                                \/\/ 2\n\t\t\t\t\t\t\t\tbyte1 = 0x6f6e;\n\t\t\t\t\t\t\t\tbyte2 = 0x1998;\n\t\t\t\t\t\t\t\tbyte3 = 0x7f63;\n                            } else if (wheelNum == 1) {\n                                \/\/ 6\n\t\t\t\t\t\t\t\tbyte1 = 0x6f6e;\n\t\t\t\t\t\t\t\tbyte2 = 0x6de3;\n\t\t\t\t\t\t\t\tbyte3 = 0x3b7b;\n                            } else if (wheelNum == 2) {\n                                \/\/ 5\n\t\t\t\t\t\t\t\tbyte1 = 0xf7f;\n\t\t\t\t\t\t\t\tbyte2 = 0x630f;\n\t\t\t\t\t\t\t\tbyte3 = 0x3b7b;\n                            }\n                        } else if (statusNum == 3) {\n                            if (wheelNum == 0) {\n                                \/\/ 3\n\t\t\t\t\t\t\t\tbyte1 = 0x6f6e;\n\t\t\t\t\t\t\t\tbyte2 = 0x61d8;\n\t\t\t\t\t\t\t\tbyte3 = 0x3b7b;\n                            } else if (wheelNum == 1) {\n                                \/\/ 5\n\t\t\t\t\t\t\t\tbyte1 = 0xf7f;\n\t\t\t\t\t\t\t\tbyte2 = 0x630f;\n\t\t\t\t\t\t\t\tbyte3 = 0x3b7b;\n                            } else if (wheelNum == 2) {\n                                \/\/ 9\n\t\t\t\t\t\t\t\tbyte1 = 0x6f6e;\n\t\t\t\t\t\t\t\tbyte2 = 0x63db;\n\t\t\t\t\t\t\t\tbyte3 = 0x3b7b;\n                            }\n                        }\n                    } else if (wheelRow == 1) {\n                        if (statusNum == 0) {\n                            if (wheelNum == 1) {\n                                \/\/ 2\n\t\t\t\t\t\t\t\tbyte1 = 0x6f6e;\n\t\t\t\t\t\t\t\tbyte2 = 0x1998;\n\t\t\t\t\t\t\t\tbyte3 = 0x7f63;\n                            } else if (wheelNum == 2) {\n                                \/\/ 7\n\t\t\t\t\t\t\t\tbyte1 = 0x637f;\n\t\t\t\t\t\t\t\tbyte2 = 0x19dc;\n\t\t\t\t\t\t\t\tbyte3 = 0x18c6;\n                            }\n                        } else if (statusNum == 1) {\n                            if (wheelNum == 1) {\n                                \/\/ 1\n\t\t\t\t\t\t\t\tbyte1 = 0x31cc;\n\t\t\t\t\t\t\t\tbyte2 = 0x318c;\n\t\t\t\t\t\t\t\tbyte3 = 0x798c;\n                            } else if (wheelNum == 2) {\n                                \/\/ 8\n\t\t\t\t\t\t\t\tbyte1 = 0x6f6e;\n\t\t\t\t\t\t\t\tbyte2 = 0x6ddb;\n\t\t\t\t\t\t\t\tbyte3 = 0x3b7b;\n                            }\n                        } else if (statusNum == 2) {\n                            if (wheelNum == 2) {\n                                \/\/ 0\n\t\t\t\t\t\t\t\tbyte1 = 0x6f6e;\n\t\t\t\t\t\t\t\tbyte2 = 0x6f7b;\n\t\t\t\t\t\t\t\tbyte3 = 0x3b7b;\n                            }\n                        } else if (statusNum == 3) {\n                            if (wheelNum == 1) {\n                                \/\/ 2\n\t\t\t\t\t\t\t\tbyte1 = 0x6f6e;\n\t\t\t\t\t\t\t\tbyte2 = 0x1998;\n\t\t\t\t\t\t\t\tbyte3 = 0x7f63;\n                            } else if (wheelNum == 2) {\n                                \/\/ 8\n\t\t\t\t\t\t\t\tbyte1 = 0x6f6e;\n\t\t\t\t\t\t\t\tbyte2 = 0x6ddb;\n\t\t\t\t\t\t\t\tbyte3 = 0x3b7b;\n                            }\n                        }\n                    }\n                }\n                \n                \n                \n                if (byte1 > 0 || byte2 > 0 || byte3 > 0) {\n                    if (charX < 5) {\n                        int readfrom;\n                        if (charY < 3) {\n                            readfrom = byte1;\n                        } else if (charY < 6) {\n                            readfrom = byte2;\n                            charY -= 3;\n                        } else {\n                            readfrom = byte3;\n                            charY -= 6;\n                        }\n                        \n                        if (bitLit(readfrom,charY*5 + charX)) bit = true;\n                    }\n                }\n                \n            }\n            \n            \n            if (mat == 4) {\n                vec2 statusOrigin = vec2(p.x+1.75,p.y-2.35);\n                statusOrigin *= 70.0;\n                statusOrigin.y *= -1.0;\n                \n                int pX = int(floor(statusOrigin.x));\n                int pY = int(floor(statusOrigin.y));\n                \n                int readfrom;\n                int rownum = 0;\n                if (pY < 16) {\n                    if (pX < 56) {\n                        readfrom = getStatusMsg1a(pX);\n                    } else if (pX < 102) {\n                        readfrom = getStatusMsg1b(pX-56);\n                    } else {\n                        readfrom = getStatusMsg1c(pX-102);\n                    }\n                } else {\n                    readfrom = getStatusMsg2(pX);\n                    rownum = 1;\n                    pY -= 16;\n                }\n                \n                if (pY >= 0 && pY < 11) {\n                \tif (bitLit(readfrom,pY)) bit = true;\n                }\n                \n                if ( (pX + 150*rownum) > int((iGlobalTime-(transitionEnd+2.0))*300.0) ) {\n                    bit = false;\n                }\n                \n            }\n            \n            \n            \n            \n            \n            \/\/ BG\n            if (mat == 1) {\n                color = bgTexture(vec2(atan(p.x,p.z)\/PI2*32.0,p.y\/bgDist*4.0));\n                color *= 1.0-pow(min((abs(p.y)\/30.0),1.0),2.0);\/\/1.0- should be inside, but it looks cooler this way~\n\n            \/\/frame outline\n            } else if (mat == 2) {\n                color = vec3(1.0);\n                if (bit) color = vec3(0.0);\n\n            \/\/health pattern\n            } else if (mat == 3) {\n                const float checkerSize = 0.05;\n                if ( (mod(p.x,checkerSize)<checkerSize*0.5) != (mod(p.y,checkerSize)<checkerSize*0.5) ) {\n                    color = vec3(144.0,128.0,168.0)\/255.0;\n                } else {\n                    color = vec3(144.0,144.0,232.0)\/255.0;\n                }\n                if (bit) color = vec3(1.0);\n                \n            \/\/status pattern\n            } else if (mat == 4) {\n                color = vec3(0.0);\n                if (bit) color = vec3(1.0);\n\n            \/\/UFO skin\n            } else if (mat == 5) {\n                color = vec3(0.7);\n                specA = 1.0;\n                specP = 6.0;\n                lightDir = normalize(vec3(0.25,0.5,1.0));\n\n            \/\/UFO eyes\n            } else if (mat == 6) {\n                color = vec3(0.2);\n                specA = 0.65;\n                specP = 16.0;\n                lightDir = normalize(vec3(0.25,0.5,1.0));\n\n            \/\/Foppy skin\n            } else if (mat == 7) {\n\n                float normGap = pow(dot(-curCameraRayUnit,n),1.7);\n                color = mix(\n                    vec3(144.0\/255.0,0.0,48.0\/255.0)*0.75,\n                    vec3(240.0\/255.0,0.0,96.0\/255.0),\n                normGap);\n\n                specA = 0.75;\n                specP = 12.0;\n                lightDir = normalize(vec3(1.0,1.0,0.0));\n                diffMin = 1.0;\n\n\n\n\n\n            \/\/Foppy eyes\n            } else if (mat == 8) {\n                color = vec3(0.2);\n                specA = 0.3;\n                specP = 48.0;\n            }\n\n            color *= dot(n,lightDir)*(1.0-diffMin)+diffMin;\n\n            float specular = max(0.0,dot(normalize(lightDir-curCameraRayUnit),n));\n            color += pow(specular,specP)*specA;\n\n\n\n            const float shadowPlane = enemyHeight;\n            float stepsToPlane = (shadowPlane-scrCoord.y)\/curCameraRayUnit.y;\n            vec3 planePt = scrCoord+curCameraRayUnit*stepsToPlane;\n            planePt.x = abs(planePt.x);\n\n            if (planePt.z < 0.0 && planePt.z > -3.0 && planePt.z > p.z) {\n                float occlusion = length(planePt.xz-vec2(enemyOffX,enemyDist));\n                occlusion = pow(occlusion,0.5);\n                occlusion = max(0.0,min(1.0,(occlusion*1.7)));\n                occlusion = 0.3+occlusion*0.7;\n                color *= occlusion;\n            }\n\n\t\t\tfloat fadeInAmt = min(1.0,(iGlobalTime-transitionEnd)*fadeSpd);\n    \t\tcolor *= pow(fadeInAmt,2.0);\n\n        }\n\n\n\n    }\n\n\n    \n    \n    \n    fragColor = vec4(color,1.0);\n    \n    \n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    vec2 mouseFrac = iMouse.xy\/iResolution.xy;\n    mouseFrac -= 0.5;\n    mouseFrac *= 2.0;\n    \n    vec3 cameraPos;\n    vec3 cameraFwd;\n    vec3 cameraUp;\n    vec3 cameraRight;\n    if (iGlobalTime < transitionEnd) {\n        cameraPos = vec3(0.0);\n        if (iMouse.z > 0.0) {\n            \n            float camLookX = PI - mouseFrac.x * PI * 0.5;\n            float camLookY = -mouseFrac.y*0.15*PI;\n            \n            cameraRight = -vec3(cos(camLookX),0.0,sin(camLookX));\n            cameraFwd = vec3(cos(camLookX+PI*0.5)*cos(camLookY),sin(camLookY),sin(camLookX+PI*0.5)*cos(camLookY));\n            cameraUp = cross(cameraRight,cameraFwd);\n            \n        } else {\n\t\t\tcameraFwd = vec3(0.0,0.0,-1.0);\n            cameraUp = vec3(0.0,1.0,0.0);\n            cameraRight = normalize(-cross(cameraUp,cameraFwd));\n        }\n    } else {\n        cameraPos = vec3(0.0,0.06,0.75);\n        if (iMouse.z > 0.0) {\n\n            cameraPos.x -= mouseFrac.x*0.7;\n            cameraPos.y -= mouseFrac.y*0.75;\n\n        } else {\n\n            float waveTime = iGlobalTime;\n            cameraPos.x += sin(waveTime*0.5)*0.4;\n            cameraPos.y += sin(waveTime*1.0)*-0.05;\n\n        }\n        cameraFwd = normalize(vec3(0.0,-0.4,-2.0)-cameraPos);\n        cameraUp = vec3(0.0,1.0,0.0);\n        cameraRight = normalize(-cross(cameraUp,cameraFwd));\n    }\n    \n    \n    \n    \n    \n    \/\/ all this stuff with working from FOVs is for the sake of WebVR compatibility,\n    \/\/ which is redundant for shadertoy, but handy for my personal site\n\n    float vertFov = 50.0;\n    float horizFov = 2.0*atan(tan((vertFov\/180.0*PI)\/2.0)*(iResolution.x\/iResolution.y))*180.0\/PI;\n    vec4 fovAngsMono = vec4(horizFov\/2.0, horizFov\/2.0, vertFov\/2.0, vertFov\/2.0);\n\n\n\n    vec2 fragFrac = fragCoord.xy\/iResolution.xy;\n\n    vec2 eyeRes = iResolution.xy;\n    vec4 fovAngs = fovAngsMono;\n\n\n\n\n\n\n\n\n\n    float fovL = -fovAngs.x\/180.0*PI;\n    float fovR =  fovAngs.y\/180.0*PI;\n    float fovU = -fovAngs.z\/180.0*PI;\n    float fovD =  fovAngs.w\/180.0*PI;\n\n    float fovMiddleX = (fovR + fovL) * 0.5;\n    float fovMiddleY = (fovU + fovD) * 0.5;\n    float fovHalfX = (fovR - fovL) * 0.5;\n    float fovHalfY = (fovD - fovU) * 0.5;\n\n\n\n    float scrWorldHalfX = sin(fovHalfX)\/sin(PI*0.5 - fovHalfX);\n    float scrWorldHalfY = sin(fovHalfY)\/sin(PI*0.5 - fovHalfY);\n\n\n    \/\/ determine screen plane size from FOV values, then interpolate to find current pixel's world coord\n\n    vec2 vPos = fragFrac;\/\/0 to 1\n    vPos.x -= (-fovL\/(fovHalfX*2.0));\n    vPos.y -= (-fovU\/(fovHalfY*2.0));\n\n    vec3 screenPlaneCenter = cameraPos+cameraFwd;\n    vec3 scrCoord = screenPlaneCenter + vPos.x*cameraRight*scrWorldHalfX*2.0 + vPos.y*cameraUp*scrWorldHalfY*2.0;\n    vec3 curCameraRayUnit = normalize(scrCoord-cameraPos);\n\n\n\n    mainVR(fragColor,fragCoord,cameraPos,curCameraRayUnit);\n\n\n\n    \n    \n    \n}","name":"","description":"","type":"image"},{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/sync with image\nconst float encounterStart = 9.2;\nconst float transitionStart = encounterStart+0.25;\nconst float transitionEnd = transitionStart+3.0;\n\n\n\nconst float pi = 3.14159;\nconst float pi2 = pi*2.0;\n\nvec2 pan(float panAmt){\n    return vec2(0.5-panAmt*0.5,0.5+panAmt*0.5);\n}\n\nfloat noteFreq(int note){\n    float oct = 1.0;\n    for(int octrange = 0; octrange<3; octrange++){\n        if (note >= 12) {\n            note -= 12;\n            oct *= 2.0;\n        }\n        if (note < 0) {\n            note += 12;\n            oct *= 0.5;\n        }\n    }\n    if (note ==  0) return oct*440.000;\n    if (note ==  1) return oct*466.164;\n    if (note ==  2) return oct*493.883;\n    if (note ==  3) return oct*523.251;\n    if (note ==  4) return oct*554.365;\n    if (note ==  5) return oct*587.330;\n    if (note ==  6) return oct*622.254;\n    if (note ==  7) return oct*659.255;\n    if (note ==  8) return oct*698.456;\n    if (note ==  9) return oct*739.989;\n    if (note == 10) return oct*391.995*2.0;\n    if (note == 11) return oct*415.305*2.0;\n    return 0.0;\n}\n\n\nfloat introHorn(int note, float time){\n    \n    float glissandoTime = time - 0.5;\n    if (glissandoTime < 0.0) {\n        glissandoTime = -pow(1.0-glissandoTime,1.0-glissandoTime*0.4);\n    } else {\n        glissandoTime = -(1.0-glissandoTime);\n    }\n    \n    float baseFreq = 6.2831*noteFreq(note)*glissandoTime*0.5;\n    \n    float mix = 0.0;\n    \n    mix += sin(baseFreq*1.0)*1.0;\n    mix += sin(baseFreq*2.0)*0.75;\n    mix += sin(baseFreq*3.0)*0.75;\n    mix += sin(baseFreq*4.0)*0.5;\n    mix += sin(baseFreq*5.0)*0.75;\n    mix += sin(baseFreq*6.0)*0.5;\n    \n    mix *= 0.25;\n    \n    return mix;\n    \n}\n\n\nconst float beatLength = 1.0\/7.5;\n\nfloat krakenSynth(int note, float time, float octave, float sawTweak){\n    \n    float baseFreq = noteFreq(note);\n    \n    float sinFreq = baseFreq*pow(2.0,octave+2.0);\n    float sawFreq = baseFreq*pow(2.0,octave-3.0-sawTweak);\n    \n    float sinWave = cos(6.2831*time*sinFreq);\n    float sawWave = 1.0-mod(time*sawFreq,1.0);\n    sawWave = pow(sawWave,8.0);\n    \n    return sawWave*sinWave - sawWave;\n    \n}\n\nfloat krakenLead(float songTime){\n    \n    float beatNum = songTime\/beatLength;\n    float beatStep = mod(floor(beatNum),32.0);\n    float barStep = floor(beatNum\/32.0);\n\n\n    if (mod(beatNum,1.0)<0.68){\n\n        float triplet = floor(beatStep\/3.0);\n        float withinTriplet = mod(beatStep,3.0);\n        if (beatStep >= 16.0) {\n            triplet = 5.0-floor((beatStep-16.0)\/3.0);\n            withinTriplet = mod(beatStep-16.0,3.0);\n        }\n        if (beatStep >= 29.0) {\n            withinTriplet++;\n        }\n\n\n\n        int curNote = 3;\n        if ((barStep > 0.0) && (mod(barStep,2.0)==0.0)) curNote += 4;\n\n        float octave = -triplet;\n        if (withinTriplet == 2.0) octave++;\n\n        return krakenSynth(curNote,mod(songTime,beatLength),octave,-triplet);\n\n    } else {\n        \n        return 0.0;\n        \n    }\n    \n}\n\n\nfloat bassSynth(int note, float time){\n    \n    const float noteLength = 0.5;\n    \n    if (time > noteLength) return 0.0;\n    \n    float baseFreq = 6.2831*time*noteFreq(note);\n    \n    float fadeIn = 1.0-pow(1.0-(time\/noteLength),32.0);\n    float fadeOut = 1.0-pow(time\/noteLength,8.0);\n    \n    return (\n        sin(baseFreq*pow(2.0,-6.0))*1.5 +\n        sin(baseFreq*pow(2.0,-5.0))*0.5 + \n        sin(baseFreq*pow(2.0,-4.0))*0.05\n    )*fadeIn*fadeOut;\n    \n}\n\nfloat krakenBass(float songTime){\n    \n    \/\/ this redundancy isn't great but whatev\n    float beatNum = songTime\/beatLength;\n    float beatStep = mod(floor(beatNum),8.0);\/\/DIFFERENT BAR LENGTH FOR BASSLINE\n    float barStep = mod(floor(beatNum\/8.0),4.0);\n    \n    if ( beatStep == 3.0 && barStep < 2.0) return 0.0;\n    if ( beatStep == 6.0 && barStep < 3.0) return 0.0;\n    if ( beatStep == 7.0 && barStep == 3.0) return 0.0;\n    \n    int bassNote = (mod(floor(beatNum\/32.0),2.0) == 0.0) ? 8 : 4 ;\n    \n    return bassSynth(bassNote, mod(beatNum,1.0));\n    \n}\n\n\nfloat wailSynth(int note, float time){\n    \n    const float noteEnd = 32.0;\n    const float noteStart = 4.0;\n    \n    float noteFrac = max(0.0,min(1.0,(time-noteStart)\/(noteEnd-noteStart)));\n    float fadeIn = pow(noteFrac,2.0);\n    float fadeOut = 1.0-(pow(noteFrac,2.0));\n    \n    float baseFreq = 6.2831*time*noteFreq(note)*0.25;\n    baseFreq += sin(time*4.5)*3.0;\n    \n    return (\n        sin(baseFreq)+\n        sin(baseFreq*3.0)+\n        sin(baseFreq*4.0)*0.75\n    )*fadeIn*fadeOut*0.5;\n    \n}\n\nfloat krakenWail(float songTime){\n    \n    float beatNum = songTime\/beatLength;\n    \n    int wailNote = (mod(floor(beatNum\/32.0),2.0) == 0.0) ? 2 : 3;\n    \n    return wailSynth(wailNote, mod(beatNum,32.0));\n    \n}\n\n\nfloat noise(float time){\n    return sin( time*200034.2666 * sin(time*600078.6576) );\n}\n\nfloat kick(float time) {\n    \n    float sinWave = sin(pow(time*1000.0,0.6));\n    \n    const float fadeInTime = 0.00015;\n    float fadeIn = max(0.0,min(1.0,(time\/fadeInTime)));\n    \n    const float fadeOutTime = 1.0;\n    float fadeOut = max(0.0,min(1.0,((fadeOutTime-time)\/fadeOutTime)));\n    \n    return sinWave*fadeIn*fadeOut;\n    \n}\n\nfloat snare(float time) {\n    \n    float sinWave = sin(pow(time*1000.0,0.7));\n    float sineFadeIn = max(0.0,min(1.0,(time\/0.00015)));\n    float sineFadeOut = max(0.0,min(1.0,(1.0-(time\/0.25))));\n    \n    float noiseWave = noise(time);\n    float noiseFadeIn = max(0.0,min(1.0,(time\/0.00015)));\n    float noiseFadeOut = max(0.0,min(1.0,(1.0-(time\/0.25))));\n    \n    return noiseWave*noiseFadeIn*noiseFadeOut*0.75 + sinWave*sineFadeIn*sineFadeOut*0.5;\n    \n}\n\nfloat hihatClosed(float time){\n    \n    float sinWaveA = sin(pow(time*8700.0,0.99));\n    float sinWaveB = sin(pow(time*7200.0,0.99));\n    float sineFadeIn = max(0.0,min(1.0,(time\/0.15)));\n    float sineFadeOut = max(0.0,min(1.0,(1.0-(time))));\n    \n    float noiseWave = noise(time);\n    float noiseFadeOut = max(0.0,min(1.0,(1.0-(time\/0.75))));\n    noiseFadeOut = pow(noiseFadeOut,2.0);\n    \n    return noiseWave*noiseFadeOut*0.5 + (sinWaveA+sinWaveB)*sineFadeIn*sineFadeOut*0.05;\n    \n}\n\nfloat hihatOpen(float time){\n    \n    float noiseVol;\n    float sineVolA;\n    float sineVolB;\n    \n    if (time < 0.125) {\n    \t\n        noiseVol = 2.0;\n        \n        sineVolA = 0.1;\n        sineVolB = 0.15;\n        \n    } else if (time < 1.0) {\n        \n        noiseVol = 0.6;\n        \n        sineVolA = 0.1;\n        sineVolB = 0.15;\n        \n    } else if (time < 2.0) {\n        \n        noiseVol = max(0.0,min(1.0,(2.0-(time*1.0))));\n        noiseVol = pow(1.0-noiseVol,1.0);\n        noiseVol *= 0.1;\n        \n        sineVolA = max(0.0,min(1.0,(2.0-(time*0.5))));\n        sineVolA = 1.0-pow(1.0-sineVolA,1.0);\n        sineVolA *= 0.0125;\n        \n        sineVolB = sineVolA*1.5;\n        \n    } else {\n        \n        return 0.0;\n        \n    }\n    \n    float mix = 0.0;\n    \n    mix += noise(time)*noiseVol;\n    \n    mix += sin(time*6300.0) * sineVolA;\n    mix += sin(time*7200.0) * sineVolB;\n    \n    return mix;\n    \n}\n\n\n\nstruct portaTone {\n    float startFreq;\n    float endFreq;\n    \n    float startTime;\n    float endTime;\n};\n\nportaTone portaNote(int startNote, int endNote, float startTime, float endTime){\n    return portaTone(noteFreq(startNote)*pi2,noteFreq(endNote)*pi2,startTime,endTime);\n}\n\nfloat portaMiddleTime(float x, portaTone note){\n    \n    float newX = x-note.startTime;\n    float withinFrac = newX\/(note.endTime-note.startTime);\n    \n    newX \/= note.startFreq;\n    newX *= mix(note.startFreq,note.endFreq,withinFrac*0.5);\n\n    newX += note.startTime;\n\n    return newX;\n    \n}\nfloat playPortamento(float x, portaTone note){\n    \n    if (x < note.startTime) {\n        return sin(x*note.startFreq);\n    } else if (x > note.endTime) {\n        return sin( (portaMiddleTime(note.endTime,note)\/note.endFreq*note.startFreq + x-note.endTime) * note.endFreq );\n    } else {\n        return sin(portaMiddleTime(x,note)*note.startFreq);\n    }\n    \n}\n\n\n\n\n\n\n\nfloat spookyLead(float time){\n    \n    const float bps = 3.25;\n    float beatTime = (time*bps);\n    \n    if (beatTime<0.0) return 0.0;\n    if (beatTime>=16.0) return 0.0;\n    \n    float barTime = mod(beatTime,4.0);\n    int barNum = int(floor(beatTime\/4.0));\n    int startNote, endNote;\n    float startBeat, endBeat;\n    float inBeat, outBeat;\n    float vol = 1.0;\n    \n    if (beatTime<12.0){\n        if (barTime < 3.0) {\n            startBeat = 0.0;\n            endBeat = 3.0;\n            if (barNum == 0) {\n                startNote = 16;\n                endNote = 4;\n            } else if (barNum == 1) {\n                startNote = 22;\n                endNote = 27;\n            } else if (barNum == 2) {\n                startNote = 1;\n                endNote = 6;\n            }\n        } else {\n            startBeat = 3.0;\n            endBeat = 4.0;\n            if (barNum == 0) {\n                startNote = 9;\n                endNote = 10;\n            } else if (barNum == 1) {\n                startNote = -8;\n                endNote = -7;\n                vol = 1.5;\n            } else if (barNum == 2) {\n                startNote = 23;\n                endNote = 26;\n            }\n        }\n        inBeat = startBeat;\n        outBeat = endBeat;\n    } else {\n        if (beatTime<14.0){\n            inBeat = startBeat = 0.0;\n            endBeat = 1.0;\n            outBeat = 2.0;\n            startNote = -23;\n            endNote = 17;\n        } else {\n            inBeat = startBeat = 2.0;\n            outBeat = endBeat = 4.0;\n            startNote = 4;\n            endNote = -4;\n        }\n    }\n    \n    float tone = playPortamento(mod(time,4.0\/bps),portaNote(startNote,endNote,startBeat\/bps,endBeat\/bps));\n    float fade = 1.0;\n    fade *= min(1.0,(barTime-inBeat)*80.0);\n    fade *= min(1.0,(outBeat-barTime)*80.0);\n    return tone*fade*vol;\n    \n}\n\nconst float heartbeat = 0.63;\nconst float dronebar = heartbeat*4.0;\nconst float muteStart = dronebar*0.98;\nfloat spookyDrone(float time){\n    \n    float fund = noteFreq(-8)*time*pi2 + (1.0-(pow(sin(time*22.0)*0.5+0.5,3.0)))*5.0;\n    \n    return\n        sin(fund)*0.5 +\n        sin(fund*3.0)*0.25 + \n    \tsin(fund*4.0)*0.025;\n}\nfloat spookyBass(float time){\n    \n    const float noteSpace = heartbeat;\n    const float noteLength = noteSpace*0.7;\n    float noteTime = mod(time,noteSpace);\n    float noteNum = floor(time\/noteSpace);\n    \n    if (noteTime>noteLength) return 0.0;\n    \n    float tone = sin(noteFreq(-27)*time*pi2);\n    float vol = (mod(noteNum,2.0) < 1.0) ? 1.0 : 0.25;\n    vol *= min(1.0,noteTime*80.0);\n    vol *= min(1.0,(noteLength-noteTime)*80.0);\n    \n    return tone*vol;\n    \n}\n\n\n\n\n\nvec2 caveMusic(float songTime){\n    \n    vec2 mix = vec2(0.0);\n    \n    if (songTime > 0.0) {\n\n        mix += spookyLead(songTime-2.5)*pan(1.0)*0.15;\n        mix += spookyLead(songTime-2.9)*pan(-1.0)*0.15;\n\n        float droneTime = mod(songTime,dronebar);\n        if (droneTime < muteStart) {\n            float droneMute = 1.0;\n            droneMute *= min(1.0,droneTime*80.0);\n            droneMute *= min(1.0,(muteStart-droneTime)*80.0);\n            mix += spookyDrone(droneTime)*pan(1.0)*0.2*droneMute;\n            mix += spookyDrone(droneTime*1.04)*pan(-1.0)*0.2*droneMute;\n        }\n\n        mix += spookyBass(songTime)*pan(0.0)*0.5;\n\n    }\n    \n    return mix;\n    \n}\nvec2 transitionMusic(float introTime){\n    \n    vec2 mix = vec2(0.0);\n    \n    const float numEchos = 3.0;\n    for(float i=0.0; i<numEchos; i++){\n\n        float echoTime = introTime - i*0.03;\n        float echoVol = 1.0-(i\/numEchos);\n\n        const float hornOffset = 0.0;\n\n        mix += (\n            (introHorn(-4,echoTime)*1.0*pan(-0.6))+\n            (introHorn( 3,echoTime)*1.0*pan(-0.2))+\n            (introHorn( 5,echoTime)*1.0*pan( 0.2))+\n            (introHorn(10,echoTime)*1.0*pan( 0.6))+\n            (introHorn(14,echoTime)*0.5*pan( 0.0))\n        )*0.5*echoVol;\n    }\n\n\n    float volEnv = cos(pow(introTime*0.5,0.8)*6.2831)*0.5+0.5;\n    const float volEnvMin = 0.3;\n    volEnv = volEnv*(1.0-volEnvMin)+volEnvMin;\n\n\n    float fadeIn = max(0.0,min(1.0,introTime\/0.3));\n    fadeIn = 1.0-pow(1.0-fadeIn,2.0);\n\n    const float fadeOutStart = (transitionEnd-transitionStart) - 0.45;\n    const float fadeOutEnd = (transitionEnd-transitionStart) - 0.1;\n    float fadeOut = max(0.0,min(1.0,(introTime-fadeOutStart)\/(fadeOutEnd-fadeOutStart)));\n    fadeOut = 1.0-pow(fadeOut,4.0);\n\n    return mix*volEnv*fadeOut*fadeIn;\n    \n}\nvec2 battleMusic(float songTime){\n    \n    float mix = 0.0;\n\n\n    float beatNum = songTime\/beatLength;\n    float beatStep = mod(floor(beatNum),32.0);\n    float barStep = floor(beatNum\/32.0);\n\n\n    if (barStep == 0.0) {\n        mix += krakenLead(songTime);\n    } else {\n        mix += krakenLead(songTime);\n        mix += krakenLead(songTime-0.1)*0.3;\n    }\n\n\n    if (barStep > 0.0) {\n        if (barStep == 1.0) {\n            if (beatStep < 28.0) {\n                mix += kick(mod(beatNum,4.0))*1.5;\n            } else {\n                mix += kick(mod(beatNum,1.0))*1.5;\n            }\n            float snareHatBeat;\n            float snareHatVol;\n            if (beatStep < 24.0) {\n                snareHatBeat = mod(beatNum,2.0);\n                if (mod(beatStep,8.0) > 4.0) snareHatBeat = mod(beatNum+1.0,2.0);\n                snareHatVol = 1.0;\n            } else {\n                snareHatBeat = mod(beatNum,1.0);\n                snareHatVol = 1.25 + 0.5*((beatStep-24.0)\/8.0);\n            }\n            mix += snare(snareHatBeat)*snareHatVol;\n            mix += hihatClosed(snareHatBeat)*0.5*snareHatVol;\n        } else {\n\n            float beatStepHalf = mod(beatStep,16.0);\n\n            if (\n                beatStepHalf ==  0.0 ||\n                beatStepHalf ==  8.0 ||\n                beatStepHalf == 10.0 ||\n                beatStepHalf == 14.0 ||\n                beatStep == 21.0\n            ) {\n                mix += kick(mod(beatNum,1.0))*1.5;\n            }\n\n            if (\n                beatStepHalf ==  4.0 ||\n                beatStepHalf ==  7.0 ||\n                beatStepHalf ==  9.0 ||\n                beatStepHalf == 12.0 \n            ){\n                mix += snare(mod(beatNum,1.0))*1.5;\n            }\n            if (\n                beatStepHalf ==  3.0 ||\n                beatStepHalf == 11.0 ||\n                beatStepHalf == 13.0 \n            ){\n                mix += snare(mod(beatNum,1.0))*0.5;\n            }\n\n            float hihatBeatNum = beatNum-2.0;\n            if (mod(floor(beatStep\/2.0),8.0)==4.0) hihatBeatNum += 2.0;\n            mix += hihatOpen(mod(hihatBeatNum,4.0))*0.3;\n\n\n            mix += krakenBass(songTime)*1.15;\n\n            mix += krakenWail(songTime)*0.8;\n            mix += krakenWail(songTime-0.1)*0.4;\n\n\n        }\n    }\n\n\n    const float fadeStart = 128.0;\n    const float fadeEnd = fadeStart+64.0;\n    float fadeOut = max(0.0,min(1.0,(beatNum-fadeStart)\/(fadeEnd-fadeStart)));\n    fadeOut = (1.0-fadeOut);\n    fadeOut = 1.0-pow(1.0-fadeOut,2.0);\n\n\n    return vec2(mix)*0.3*fadeOut;\n    \n}\n\n\n\nvec2 mainSound(float time){\n    \n    \n    if (time < encounterStart) {\n        \n        return caveMusic(time);\n        \n    } else if (time < transitionStart) {\n        \n        return vec2(0.0);\n        \n    } else if (time < transitionEnd) {\n        \n        return transitionMusic(time - transitionStart);\n        \n    } else {\n        \n        return battleMusic(time - transitionEnd);\n        \n    }\n    \n    \n}","name":"","description":"","type":"sound"}]}}