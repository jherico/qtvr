{"Shader":{"ver":"0.1","info":{"id":"ldBGDh","date":"1390081184","viewed":1826,"name":"Rose","username":"Dave_Hoskins","description":"I had to use an X wrapped 2D noise, so the atan result would repeat properly when passing through 360 degrees.<br\/>","likes":24,"published":3,"flags":0,"tags":["3d","raymarching","flower","rose"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Rose. By David Hoskins. Jan 2014.\n\/\/ https:\/\/www.shadertoy.com\/view\/ldBGDh\n\n#define PI 3.14159265359\n#define MOD3 vec3(.1143,.12369,.13787)\n\nvec3 sunLight  = normalize( vec3(  .8, .7,  -0.5 ) );\nfloat gTime = 0.0;\nvec2 coord;\n\n\/\/--------------------------------------------------------------------------\nfloat Hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract(p3.x * p3.y * p3.z);\n}\n\n\/\/--------------------------------------------------------------------------\nfloat HashWrap(in vec2 p)\n{\n\tp.x = mod(p.x, 10.0);\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract(p3.x * p3.y * p3.z);\n}\n\n\/\/--------------------------------------------------------------------------\nfloat Noise(in vec2 p)\n{\n\tvec2 f = fract(p);\n    p = floor(p);\n    f = f*f*(3.0-2.0*f);\n    float res = mix(mix(Hash(p),\n\t\t\t\t\t\tHash(p + vec2(1.0, 0.0)), f.x),\n\t\t\t\t\tmix(Hash(p + vec2(0.0, 1.0)),\n\t\t\t\t\t\tHash(p + vec2(1.0, 1.0)), f.x), f.y);\n    return res;\n}\n\n\/\/--------------------------------------------------------------------------\nfloat NoiseWrap(in vec2 p)\n{\n\tvec2 f = fract(p);\n    p = floor(p);\n    f = f*f*(3.0-2.0*f);\n    float res = mix(mix(HashWrap(p),\n\t\t\t\t\t\tHashWrap(p + vec2(1.0, 0.0)), f.x),\n\t\t\t\t\tmix(HashWrap(p + vec2(0.0, 1.0)),\n\t\t\t\t\t\tHashWrap(p + vec2(1.0, 1.0)), f.x), f.y);\n    return res;\n}\n\n\/\/--------------------------------------------------------------------------\nfloat Cylinder( vec3 p, vec2 h )\n{\n  return max( length(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n\/\/--------------------------------------------------------------------------\nvec2 Rotate2D( vec2 p, float a)\n{\n\tfloat si = sin(a);\n\tfloat co = cos(a);\n\treturn mat2(co, si, -si, co) * p;\n}\n\n\/\/--------------------------------------------------------------------------\nvec2 Map(in vec3 p)\n{\n\tvec2 a;\n\tfloat mat = 0.0;\n\tfloat anim = min(sqrt(iGlobalTime*.1+0.01) +.2, 1.);\n\t\n\t\/\/ Tilt depending on height...\n\tfloat t = -.9+smoothstep(-50.0, -400.0, p.y*2.2);\n\tp.zy = Rotate2D(p.zy, t);\n\tfloat f = length(p*vec3(1.0, 2.5, 1.0))-50.0;\n\t\n\t\/\/ Spin faster around centre...\n\tfloat l = dot(p.xz, p.xz) * .0162+.5;\n\tt = sqrt(50.0 \/ (l+.5));\n\tp.xz = Rotate2D(p.xz, t*anim*anim);\n\t\n\t\/\/ arctan needs to wrap in the noise function...\n\ta.x = (atan(p.x, p.z)+PI)\/ (2.0 * PI) * 10.0;\n\ta.y  = pow(l, .35)*11.3;\n\ta.y *= smoothstep(15.0\/(anim*anim), 0.0, (p.y*.2+2.3)*anim);\n    float n = NoiseWrap(a)*40.0-23.0;\n\tn = n * smoothstep(85.0, 50.0, l);\n\tf = f + n;\n\tf = mix(dot(p, p)-2380.0, f, pow(anim, .05));\n\t\n\t\/\/ Stem...\n\tn = Cylinder(p-vec3(0.0, -100, 0.0), vec2(4.0, 100.0));\n\tif (n < f)\n\t{\n\t\tmat = 1.0;\n\t\tf = n;\n\t}\n\treturn vec2(f, mat);\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 GetSky(in vec3 rd)\n{\n\tfloat a = pow(1.0-max(rd.y, 0.0), 2.0);\n\tvec3 c1 = mix(vec3(0.52, .65, .65),vec3(.8), a);\n\tvec3 c2 = vec3(.26, .29, .24);\n\tfloat f = Noise(rd.xy*4.0)*.3 + Noise(rd.xy*10.0)*.1;\n\tfloat r = smoothstep(0.0, .2, -rd.y-f+.2);\n\treturn mix(c1, c2, clamp(r, 0.0, 1.0));\n}\n\n\/\/--------------------------------------------------------------------------\nfloat Shadow(in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 2.0;\n\tfloat h = 0.0;\n    \n\tfor (int i = 0; i < 20; i++)\n\t{\n\t\th = Map(ro + rd * t).x;\n\t\tres = min(h \/ t, res);\n\t\tt += h*.02+.35;\n\t}\n\t\n    return clamp(res, 0.0, 1.0);\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 Normal(in vec3 pos, in float t)\n{\n\tvec2  eps = vec2(.25,0.0);\n\tvec3 nor = vec3(Map(pos+eps.xyy).x - Map(pos-eps.xyy).x,\n\t\t\t\t\tMap(pos+eps.yxy).x - Map(pos-eps.yxy).x,\n\t\t\t\t\tMap(pos+eps.yyx).x - Map(pos-eps.yyx).x);\n\treturn normalize(nor);\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 DoLighting(in vec3 pos, in vec3 ray, in vec3 nor, in vec2 t)\n{\n\tfloat sha = Shadow(pos, sunLight)*.9 + .1;\n\tvec3 mat;\n\tif (t.y < 0.5) \n\t{\n\t\t\/\/pos.y *= 2.5;\n\t\tfloat anim = min(sqrt(iGlobalTime*.1+0.01) +.2, 1.);\n\t\tmat = vec3(.8, .0, .0);\n\t\tfloat t = -.9+smoothstep(-50.0, -400.0, pos.y*2.2);\n\t\tpos.zy = Rotate2D(pos.zy, t);\n\t\tfloat l = dot(pos.xz, pos.xz) * .0162+14.5;\n\t\tt = (50.0 \/ (l+.5));\n\t\tpos.xz = Rotate2D(pos.xz, t*anim);\n\t\tpos \/= pow(anim, 1.0);\n\t\tmat += vec3(.3,.3,.3)*Noise(pos.xz*1.5) * anim*anim * .35;\n\t\tmat += vec3(.8,.5,.3)*Noise(pos.xz*.25) * clamp(l*.2-13., 0.0, 1.0);\n\n\t}else\n\t{\n\t\tmat = mix(vec3(.1, .4, .05), vec3(.0,.2, 0.0), Noise(pos.xy*vec2(1.0, .3)));\n\t}\n\t\n\tvec3 col = mat * max(dot(sunLight, nor), 0.0) * sha + mat*.05;\n\tvec3 ref = reflect(ray, nor);\n\tfloat spec = pow(max(dot(sunLight, ref), 0.0), 10.0);\n\tcol += vec3(.3, 0.15, .05) * spec * sha;\n\treturn clamp(col, 0.0, 1.0);\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec2 RayMarch( in vec3 ro, in vec3 rd )\n{\n    float h;\n    float t\t\t = 53.0 - 3.5* Hash(coord * iGlobalTime);\n\tvec2 res\t = vec2(200.0, -1.0);\n\tbool hit\t = false;\n\n\tfor( int i = 0; i < 220; i++ )\n    {\n\t\tif (!hit && t < 220.0)\n\t\t{\n\t\t\tvec2 h = Map(ro + rd * t);\n\t\t\tif (h.x < 0.0)\n\t\t\t{\n\t\t\t\tres = vec2(t, h.y);\n\t\t\t\thit = true;\n\t\t\t}\n\t\t\tt += h.x * .036 + t * .001;\n\t\t}\n    }\n    return res;\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 CameraPath( float t )\n{\n    vec2 p = vec2(200.0 * sin(3.54*t), 200.0 * cos(2.0*t) );\n\treturn vec3(p.x+420.0,  0.0, -655.0+p.y);\n} \n\n\/\/--------------------------------------------------------------------------\nvec3 PostEffects(vec3 rgb, vec2 xy)\n{\n\t\/\/ Gamma first...\n\trgb = pow(rgb, vec3(0.45));\n\t\/\/ Then saturation...\n\trgb = clamp(mix(  vec3(dot(vec3(.2125, .7154, .0721), rgb)), rgb, 1.3), 0.0, 1.0);\n\t\n\t\/\/ Vignette...\n\trgb *= .4+0.4*pow(60.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.3 );\t\n\treturn rgb;\n}\n\n\/\/--------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat gTime = -iGlobalTime-2.3;\n    vec2 xy = fragCoord.xy \/ iResolution.xy;\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x\/iResolution.y,1.0);\n    coord = fragCoord;\n\t\n\tfloat hTime = mod(gTime+1.85, 2.0);\n\t\n\tvec3 camPos = vec3(sin(gTime*.3)*50.0, -10.0, -102.0);\n\tvec3 camTar  = vec3(0.0, -10.0, 0.0);\n\n\tfloat roll = .2*sin(gTime*.13+1.2);\n\tvec3 cw = normalize(camTar-camPos);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = cross(cw,cp);\n\tvec3 cv = cross(cu,cw);\n\tvec3 ray = normalize(uv.x*cu + uv.y*cv + 1.3*cw);\n\n\tvec3 col;\n\n\tvec2 t = RayMarch(camPos, ray);\n\tif(t.y >= 0.0)\n\t{\n\t\tvec3 pos = camPos + t.x * ray;\n\t\tvec3 nor = Normal(pos, t.x);\n\t\tcol = DoLighting(pos, ray, nor, t);\n\t}else\n\t{\n\t\tcol = GetSky(ray);\n\t}\n\n\tcol = PostEffects(col, xy);\t\n\t\n\tfragColor=vec4(col,1.0);\n}\n\n\/\/--------------------------------------------------------------------------","name":"","description":"","type":"image"}]}}