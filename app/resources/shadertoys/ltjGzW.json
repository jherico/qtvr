{"Shader":{"ver":"0.1","info":{"id":"ltjGzW","date":"1432078613","viewed":793,"name":"Confetti Attempt 1","username":"Craxic","description":"My attempt at some confetti. On the shitty laptop I wrote this on I get 56.5 FPS. But on my powerful computer, I can get a solid 60FPS even with 25+ explosions at once.","likes":5,"published":3,"flags":0,"tags":["2d"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Copyright (C) 2015 Matthew Ready\n\/\/ Licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Australia license.\n\/\/ http:\/\/creativecommons.org\/licenses\/by-nc-sa\/3.0\/au\n\n#define N_POPS 5\n#define TIME_BETWEEN_POPS 1.2\n#define TIME_BETWEEN_POPS_RANDOM 0.6\n#define N_CONFETTI 16\n#define PI 3.1415926535\n#define SQUARE_HARDNESS 10.0\n#define GLOW_INTENSITY 0.8\n#define HUE_VARIANCE 0.2\n\n#define V_INITIAL 600.0\n#define V_RANDOM 300.0\n#define GRAVITY 17.81\n#define TERMINAL_VELOCITY 60.0\n#define TERMINAL_VELOCITY_RANDOM 10.0\n\n#define GLOW_WHITENESS 0.56\n#define SQUARE_WHITENESS 0.86\n\n\/\/ From my other shader https:\/\/www.shadertoy.com\/view\/4tB3zD\nfloat trapezium(float x)\n{\n    \/\/            __________\n    \/\/ 1.0 -     \/          \\\n    \/\/          \/            \\                .\n    \/\/ 0.5 -   \/              \\              .  --> Repeating\n    \/\/        \/                \\            . \n    \/\/ 0.0 - \/                  \\__________\/\n    \/\/\n    \/\/       |    |    |    |    |    |    |\n    \/\/      0.0  1\/6  2\/6  3\/6  4\/6  5\/6  6\/6\n    \/\/\n\treturn min(1.0, max(0.0, 1.0 - abs(-mod(x, 1.0) * 3.0 + 1.0)) * 2.0);\n}\n\nvec3 colFromHue(float hue)\n{\n    \/\/ https:\/\/en.wikipedia.org\/wiki\/Hue#\/media\/File:HSV-RGB-comparison.svg\n\treturn vec3(trapezium(hue - 1.0\/3.0), trapezium(hue), trapezium(hue + 1.0\/3.0));\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\/\/ Gets a random value for the most recent explosion at the specified time.\nfloat getPopRandom(float time, float random) {\n    time = floor(time \/ TIME_BETWEEN_POPS);\n    return rand(vec2(time, random));\n}\n\n\/\/ Gets a random value for the most recent explosion at the specified time.\nfloat getPopTime(float time) {\n    float pop_start_time = floor(time \/ TIME_BETWEEN_POPS) * TIME_BETWEEN_POPS\n        + (getPopRandom(time, 2.2)) * TIME_BETWEEN_POPS_RANDOM;\n    return iGlobalTime - pop_start_time;\n}\n\nfloat xposition(float time, float angle, float v_initial, float terminal_v) {\n    float g = GRAVITY;\n    float v = v_initial;\n    float t = time;\n    float sin_amp = 20.0 * (1.0 - exp(-pow(time \/ 7.0, 2.0)));\n    float x_t = sin(time \/ 5.0) * sin_amp + time * 3.0;\n    return v * terminal_v \/ g * (1.0 - exp(-g*t\/terminal_v)) * cos(angle) + x_t;\n}\n\nfloat yposition(float time, float angle, float v_initial, float terminal_v) {\n    float g = GRAVITY;\n    float v = v_initial;\n    float t = time;\n    return v * terminal_v \/ g * (1.0 - exp(-g*t\/terminal_v)) * sin(angle) - terminal_v * t;\n}\n\n\/\/ This function from http:\/\/www.blackpawn.com\/texts\/pointinpoly\/\n\/\/ Own modifications added.\nfloat isInExtendedTriangle(vec2 b, vec2 a, vec2 c, vec2 p)\n{\n    \/\/ Compute vectors        \n    vec2 v0 = c - a;\n    vec2 v1 = b - a;\n    vec2 v2 = p - a;\n\n    \/\/ Compute dot products\n    float dot00 = dot(v0, v0);\n    float dot01 = dot(v0, v1);\n    float dot02 = dot(v0, v2);\n    float dot11 = dot(v1, v1);\n    float dot12 = dot(v1, v2);\n\n    \/\/ Compute barycentric coordinates\n    float denom = (dot00 * dot11 - dot01 * dot01);\n    if (denom < 0.001) {\n     \treturn 0.0;   \n    }\n    float invDenom = 1.0 \/ denom;\n    float u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    float v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n\n    \/\/ Check if point is in triangle\n    return clamp(u * SQUARE_HARDNESS, 0.0, 1.0) *\n           clamp(v * SQUARE_HARDNESS, 0.0, 1.0);\/\/ * \n         \/\/  clamp((1.0 - (u + v)) * 100.0, 0.0, 1.0); \/\/ (u >= 0) && (v >= 0) && (u + v < 1)   \n}\n\nfloat isInQuad(vec2 a, vec2 b, vec2 c, vec2 d, vec2 p)\n{\n    return isInExtendedTriangle(a, b, c, p) * isInExtendedTriangle(c, d, a, p);\n}\n\nvec4 rotate(float phi, float theta, float psi) {\n    float cosPhi = cos(phi), sinPhi = sin(phi);\n    float cosTheta = cos(theta), sinTheta = sin(theta);\n    float cosPsi = cos(psi), sinPsi = sin(psi);\n    mat3 matrix;\n    \n    vec3 row0 = vec3(cosTheta * cosPsi, -cosTheta * sinPsi, sinTheta);\n    \n    vec3 row1 = vec3(cosPhi * sinPsi + sinPhi * sinTheta * cosPsi, \n                     cosPhi * cosPsi - sinPhi * sinTheta * sinPsi, \n                     -sinPhi * cosTheta);\n    \n    vec3 a = row0 - row1;\n    \n    vec3 b = row0 + row1;\n    \n    return vec4(a, b);\n}\n\nfloat isInRotatedQuad(vec4 offsets, vec2 center, vec2 p)\n{\n    return isInQuad(center + offsets.xy, \n                    center + offsets.zw, \n                    center - offsets.xy,\n                    center - offsets.zw, p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 scaledFragCoord = fragCoord \/ iResolution.xy * vec2(800.0, 450.0);\n\tconst float size = 6.0;\n    const float max_square_dist = size * size * 128.0;\n    float max_dist = sqrt(max_square_dist);\n    const float confettiRotateTimeScale = 2.0;\n    \n    float t = iGlobalTime * confettiRotateTimeScale \/ 5.0 + 1.3;\n    vec4 matrix1 = rotate(t * 8.0, sin(t) * 0.5, t \/ 4.0) * size;\n    t = iGlobalTime * confettiRotateTimeScale \/ 5.1 + 92.2;\n    vec4 matrix2 = rotate(t * 8.0, sin(t) * 0.5, t \/ 4.0) * size;\n    t = iGlobalTime * confettiRotateTimeScale \/ 5.5 + 7.1;\n    vec4 matrix3 = rotate(t * 8.0, sin(t) * 0.5, t \/ 4.0) * size;\n    t = iGlobalTime * confettiRotateTimeScale \/ 4.3 + 1.0;\n    vec4 matrix4 = rotate(t * 8.0, sin(t) * 0.5, t \/ 4.0) * size;\n    \n    vec4 col = vec4(0.0, 0.0, 0.0, 0.0);\n    for (int i=0; i<N_POPS; i++) {\n        float sampleTime = iGlobalTime - float(i) * TIME_BETWEEN_POPS;\n        float popTime = getPopTime(sampleTime);\n        vec2 point = vec2(getPopRandom(sampleTime, 3.1) * 800.0, 0);\n        float baseHue = getPopRandom(sampleTime, 3.5);\n        \n        if (abs(scaledFragCoord.x - point.x) > 300.0) {\n            continue;\n        }\n        \n        \n        for (int j=0; j<N_CONFETTI; j++) {\n            float angle = PI \/ 2.0 + PI \/ 4.0 * (getPopRandom(sampleTime, float(j)) - 0.5);\n            float v_initial =  V_INITIAL + V_RANDOM * getPopRandom(sampleTime, float(j - 5));\n            float terminal_v = TERMINAL_VELOCITY + TERMINAL_VELOCITY_RANDOM * (getPopRandom(sampleTime, float(j - 10)) - 0.5);\n                \n            float alterTime = popTime * 10.0;\n            float x = xposition(alterTime, angle, v_initial, terminal_v) \/ 5.0;\n            float y = yposition(alterTime, angle, v_initial, terminal_v) \/ 5.0;\n            \n            vec2 confettiLocation = vec2(point.x + x, y);\n            vec2 delta = confettiLocation - scaledFragCoord;\n            float dist = dot(delta, delta);\n            if (dist > max_square_dist) {\n             \tcontinue;   \n            }\n            \/\/dist = sqrt(dist);\n            float glowIntensity = (clamp(1.0 - pow(dist \/ max_square_dist, 0.05), 0.0, 1.0) \/ 1.0) * GLOW_INTENSITY;\n            float f = getPopRandom(sampleTime, float(j - 2));\n            vec4 matrix;\n            float matrixIndex = mod(f * 4.0, 4.0);\n            if (matrixIndex < 1.0) {\n                matrix = matrix1;\n            } else if (matrixIndex < 2.0) {\n                matrix = matrix2;\n            } else if (matrixIndex < 3.0) {\n                matrix = matrix3;\n            } else {\n                matrix = matrix4;\n            }\n            float squareIntensity = isInRotatedQuad(matrix,\n                                  \t\t\t        confettiLocation, \n                                                    scaledFragCoord);\n            vec3 pastelColour = colFromHue(baseHue + getPopRandom(sampleTime, float(j - 15)) * HUE_VARIANCE);\n            vec3 pastelGlowColour = glowIntensity * (pastelColour * (1.0 - GLOW_WHITENESS) + vec3(GLOW_WHITENESS, GLOW_WHITENESS, GLOW_WHITENESS));\n            vec3 pastelSqColour = squareIntensity * (pastelColour * (1.0 - SQUARE_WHITENESS) + vec3(SQUARE_WHITENESS, SQUARE_WHITENESS, SQUARE_WHITENESS));\n            col += vec4(pastelGlowColour + pastelSqColour, 0.0);\n        }\n    }\n    col.a = 1.0;\n    \n\tfragColor = col;\n}","name":"","description":"","type":"image"}]}}