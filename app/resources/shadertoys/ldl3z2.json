{"Shader":{"ver":"0.1","info":{"id":"ldl3z2","date":"1374943219","viewed":1545,"name":"lava drip","username":"FabriceNeyret2","description":"heightfield = interferences between 2 drips, +noise, + shader + 2D smoke<br\/><br\/>mouse to rotate camera","likes":4,"published":3,"flags":0,"tags":["perlin","fluid"],"hasliked":0},"renderpass":[{"inputs":[{"id":10,"src":"\/presets\/tex09.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":25,"src":"\/presets\/cube03_0.png","ctype":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define ANIM true\n#define PI 3.1415927\n\nfloat time = iGlobalTime;\n\n\/\/ --- noise functions from https:\/\/www.shadertoy.com\/view\/XslGRr\n\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\/\/ --- End of Created by inigo quilez\n\nvec2 noise2_2( vec2 p )     \/\/ 2 noise channels from 2D position\n{\n\tvec3 pos = vec3(p,.5);\n\tif (ANIM) pos.z += time;\n\tpos *= m;\n    float fx = noise(pos);\n    float fy = noise(pos+vec3(1345.67,0,45.67));\n    return vec2(fx,fy);\n}\n\n#define snoise(p)  (2.*noise(p)-1.)\n#define snoise2_2(p)  (2.*noise2_2(p)-1.)\n#define fbm2(p)  ((noise(p)+.5*noise(m*(p)))\/1.5)\n\nvec2 advfbm( vec2 p )\n{\t\n    float l=1.;\n\tvec2 dp;\t\n    dp  =   snoise2_2(p+dp); l*=.5;\n    dp += l*snoise2_2(p+dp); l*=.5;\n    dp += l*snoise2_2(p+dp); l*=.5;\n    dp += l*snoise2_2(p+dp); l*=.5;\n    dp += l*snoise2_2(p+dp); \n\n    return dp;\n}\n\nfloat _h, _n,_d;\nfloat scene(vec3 p)\n{\n\tfloat d1 = length(p.xz);\n\tfloat d2 = length(p.xz-vec2(1.,0.));\n\tfloat h; \n\t\n\t\/\/ main shape\n\th =  .4*sin(5.*d1-time       )\/(.4+d1*d1)\n\t   + .4*sin(5.*d2-.71234*time)\/(.4+d2*d2);\n\n\t\/\/ add details\n\tvec3 pp = 15.*p+4.*time*vec3(.5,.4,.8);\n\tfloat n;\n\tif (p.y-h < .2) n = fbm(pp); \/\/ details only if close\n\telse n = 0.; \/\/.5*noise(pp); \/\/ detail approx\n\t_h = h; _n = n; _d=d1;\n\th += .2*n; \n\t\n\treturn  .1*max(p.y-h,0.);\n\t\t\/\/ length(advfbm(10.*p.xy));\n}\n\nvec2 rotate(vec2 k,float t)\n{   return vec2(cos(t)*k.x-sin(t)*k.y,sin(t)*k.x+cos(t)*k.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tfloat speed = 0.;\n\tvec2 pos=(fragCoord.xy\/iResolution.y-vec2(.8,.5))*2.;\n\tvec2 mouse = vec2(0.,.16);\n\tif (iMouse.x > 0.) mouse = (iMouse.xy\/iResolution.xy-.5)*2.;\n    vec3 col;\n\t\/\/ec3 sky = vec3(.6,.8,1.);\n\tvec3 sky = vec3(.1,.2,0.);\n\t\/\/vec3 light = vec3(.2,.8,-.2);\n\tvec3 light = vec3(.1,.1,.9);\n\n\t\/\/ camera, ray-marching & shading  inspired by rez\n\t\/\/ https:\/\/www.shadertoy.com\/view\/MsXGR2\n\t\n\tfloat fov = .5;\n\tvec3 dir=normalize(vec3(fov*pos,1.0));\t\/\/ ray dir\n\tdir.yz=rotate(dir.yz, PI*mouse.y);\t\t\/\/ rotation up\/down\n\tdir.zx=rotate(dir.zx,-PI*mouse.x);\t\t\/\/ rotation left\/right\n\t\/\/dir.xy=rotate(dir.xy,0.);\t       \t\t\/\/ twist\n\tvec3 ray=vec3(0.,2.,-4.);         \t\t\/\/ pos along ray\n\t\n\tfloat l=0.,dl;\n#define eps 1.e-3\n\tconst int ray_n=128;\n\tfor(int i=0; i<ray_n; i++)\n\t{\n\t\tl += dl = scene(ray+dir*l);\n\t\tif (dl<=eps) break;\n\t}\n\tif (true) \/\/ dl<=eps) \n\t{\n\tvec3 hit = ray+dir*l;\n\tfloat H=_h, dH=_n;\n\t\t\n\t\/\/ shading ( -> eval normals)\n\tvec2 h = vec2(.005,-.005); \n\tvec3 N = normalize(vec3(scene(hit+h.xyy),\n\t\t\t\t\t\t    scene(hit+h.yxx),\n\t\t\t\t\t\t    scene(hit+h.yyx)));\n    \/\/float c = textureCube(iChannel1,N.xzy).x;\n\tfloat c = dot(N,light);\n\n\t\/\/ fog\n\tfloat a = 1.-exp(-.15*l); \/\/ optical thickness\n\n\t\/\/ lava\n\tcol = 1.*c*vec3(1.,.3,0.); \/\/ shading\n\tcol += pow(1.-dH,2.)*vec3(1.,.6,.1)*2.5\/(.4+.2*_d*_d);\n\n\tfloat gaz = 1.5*fbm2(vec3(5.*(pos.x-PI*mouse.x),2.*pos.y-6.*time,.5));\n\tcol = a*sky*gaz+(1.-a)*col;\n\t}\n\telse\n\t\tcol = sky;\n\t\n#if 0\n\tvec2 disp = advfbm(15.*+mouse.x*uv);\n\tvec2 p = uv+mouse.x*disp;\n\t\/\/col = texture2D(iChannel0,p).rgb;\n\tcol = vec3(length(disp));\n\t\/\/col = vec3(.5+.5*disp,.5);\n#endif\n\t\n\tfragColor = vec4(col,1.0);\n}","name":"","description":"","type":"image"}]}}