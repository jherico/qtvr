{"Shader":{"ver":"0.1","info":{"id":"Xl2XRW","date":"1442094288","viewed":3055,"name":"Where the River Goes","username":"P_Malin","description":"What started as a hacked flow and advection experiment turned into something nice.<br\/>Lots still to do...<br\/>If you have a (very) fast GPU, try uncommenting #define ENABLE_ULTRA_QUALITY","likes":54,"published":3,"flags":0,"tags":["water","flow","advection"],"hasliked":0},"renderpass":[{"inputs":[{"id":7,"src":"\/presets\/tex06.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Where the River Goes\n\/\/ @P_Malin\n\n\/\/ What started as a hacked flow and advection experiment turned into something nice.\n\n\/\/ Placeholder audio https:\/\/www.youtube.com\/watch?v=gmar4gh5nIw suggested by @qthund on twitter\n\n\/\/#define ENABLE_ULTRA_QUALITY\n\n#define ENABLE_WATER\n#define ENABLE_FOAM\n#define ENABLE_WATER_RECEIVE_SHADOW\n#define ENABLE_CONE_STEPPING\n\n\/\/#define ENABLE_LANDSCAPE_RECEIVE_SHADOW\n\n\/\/#define ENABLE_SCREENSHOT_MODE\nconst float k_screenshotTime = 13.0;\n\n#if defined(ENABLE_SCREENSHOT_MODE) || defined(ENABLE_ULTRA_QUALITY)\n#define ENABLE_SUPERSAMPLE_MODE\n#endif\n\n#ifndef ENABLE_SCREENSHOT_MODE\n#ifdef ENABLE_ULTRA_QUALITY\nconst int k_raymarchSteps = 96;\nconst int k_fmbSteps = 6;\nconst int k_superSampleCount = 6;\n#else\nconst int k_raymarchSteps = 64;\nconst int k_fmbSteps = 3;\n#endif\n#else\nconst int k_raymarchSteps = 96;\nconst int k_fmbSteps = 5;\nconst int k_superSampleCount = 10;\n#endif\n\nconst int k_fmbWaterSteps = 4;\n\n#define OBJ_ID_SKY 0.0\n#define OBJ_ID_GROUND 1.0\n\nfloat g_fTime;\n\nconst vec3 g_vSunDir = vec3( -1.0, 0.7, 0.25 );\nvec3 GetSunDir() { return normalize( g_vSunDir ); }\n\nconst vec3 g_sunColour = vec3( 1.0, 0.85, 0.5 ) * 5.0;\nconst vec3 g_skyColour = vec3( 0.1, 0.5, 1.0 ) * 1.0;\n\nconst vec3 k_bgSkyColourUp = g_skyColour * 4.0;\nconst vec3 k_bgSkyColourDown = g_skyColour * 6.0;\n\nconst vec3 k_envFloorColor = vec3(0.3, 0.2, 0.2);\n\nconst vec3 k_vFogExt = vec3(0.01, 0.015, 0.015) * 3.0;\nconst vec3 k_vFogIn = vec3(1.0, 0.9, 0.8) * 0.015;\n\n\nconst float k_fFarClip = 20.0;\n\n#define MOD2 vec2(4.438975,3.972973)\n\nfloat Hash( float p ) \n{\n    \/\/ https:\/\/www.shadertoy.com\/view\/4djSRW - Dave Hoskins\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);    \n\t\/\/return fract(sin(n)*43758.5453);\n}\n\nfloat SmoothNoise(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = Hash(n+  0.0);\n\tfloat b = Hash(n+  1.0);\n\tfloat c = Hash(n+ 57.0);\n\tfloat d = Hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n    return res;\n}\n\nfloat FBM( vec2 p, float ps ) {\n\tfloat f = 0.0;\n    float tot = 0.0;\n    float a = 1.0;\n    for( int i=0; i<k_fmbSteps; i++)\n    {\n        f += SmoothNoise( p ) * a;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f \/ tot;\n}\n\nfloat FBM_Simple( vec2 p, float ps ) {\n\tfloat f = 0.0;\n    float tot = 0.0;\n    float a = 1.0;\n    for( int i=0; i<3; i++)\n    {\n        f += SmoothNoise( p ) * a;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f \/ tot;\n}\n\nvec3 SmoothNoise_DXY(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = Hash(n+  0.0);\n\tfloat b = Hash(n+  1.0);\n\tfloat c = Hash(n+ 57.0);\n\tfloat d = Hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\tvec2 dt = 6.0 * f - 6.0 * f2;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\tfloat du = dt.x;\t\n\tfloat dv = dt.y;\t\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n\tfloat dx = (b-a)*du + (a-b+d-c)*du*v;\n\tfloat dy = (c-a)*dv + (a-b+d-c)*u*dv;    \n    \n    return vec3(dx, dy, res);\n}\n\nvec3 FBM_DXY( vec2 p, vec2 flow, float ps, float df ) {\n\tvec3 f = vec3(0.0);\n    float tot = 0.0;\n    float a = 1.0;\n    \/\/flow *= 0.6;\n    for( int i=0; i<k_fmbWaterSteps; i++)\n    {\n        p += flow;\n        flow *= -0.75; \/\/ modify flow for each octave - negating this is fun\n        vec3 v = SmoothNoise_DXY( p );\n        f += v * a;\n        p += v.xy * df;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f \/ tot;\n}\n\nfloat GetRiverMeander( const float x )\n{\n    return sin(x * 0.3) * 1.5;\n}\n\nfloat GetRiverMeanderDx( const float x )\n{\n    return cos(x * 0.3) * 1.5 * 0.3;\n}\n\nfloat GetRiverBedOffset( const vec3 vPos )\n{\n    float fRiverBedDepth = 0.3 + (0.5 + 0.5 * sin( vPos.x * 0.001 + 3.0)) * 0.4;\n    float fRiverBedWidth = 2.0 + cos( vPos.x * 0.1 ) * 1.0;;\n    \n    float fRiverBedAmount = smoothstep( fRiverBedWidth, fRiverBedWidth * 0.5, abs(vPos.z - GetRiverMeander(vPos.x)) );\n        \n    return fRiverBedAmount * fRiverBedDepth;    \n}\n\nfloat GetTerrainHeight( const vec3 vPos )\n{    \n    float fbm = FBM( vPos.xz * vec2(0.5, 1.0), 0.5 );\n    float fTerrainHeight = fbm * fbm;\n    \n    fTerrainHeight -= GetRiverBedOffset(vPos);\n        \n    return fTerrainHeight;\n}\n\nfloat GetTerrainHeightSimple( const vec3 vPos )\n{    \n    float fbm = FBM_Simple( vPos.xz * vec2(0.5, 1.0), 0.5 );\n    float fTerrainHeight = fbm * fbm;\n    \n    fTerrainHeight -= GetRiverBedOffset(vPos);\n        \n    return fTerrainHeight;\n}\n\n\nfloat GetSceneDistance( const vec3 vPos )\n{\n    return vPos.y - GetTerrainHeight( vPos );\n}\n\nfloat GetFlowDistance( const vec2 vPos )\n{\n    return -GetTerrainHeightSimple( vec3( vPos.x, 0.0, vPos.y ) );\n}\n\nvec2 GetBaseFlow( const vec2 vPos )\n{\n    return vec2( 1.0, GetRiverMeanderDx(vPos.x) );\n}\n\nvec2 GetGradient( const vec2 vPos )\n{\n    vec2 vDelta = vec2(0.01, 0.00);\n    float dx = GetFlowDistance( vPos + vDelta.xy ) - GetFlowDistance( vPos - vDelta.xy );\n    float dy = GetFlowDistance( vPos + vDelta.yx ) - GetFlowDistance( vPos - vDelta.yx );\n    return vec2( dx, dy );\n}\n\nvec3 GetFlowRate( const vec2 vPos )\n{\n    vec2 vBaseFlow = GetBaseFlow( vPos );\n\n    vec2 vFlow = vBaseFlow;\n    \n    float fFoam = 0.0;\n\n\tfloat fDepth = -GetTerrainHeightSimple( vec3(vPos.x, 0.0, vPos.y) );\n    float fDist = GetFlowDistance( vPos );\n    vec2 vGradient = GetGradient( vPos );\n    \n    vFlow += -vGradient * 40.0 \/ (1.0 + fDist * 1.5);\n    vFlow *= 1.0 \/ (1.0 + fDist * 0.5);\n\n#if 1\n    float fBehindObstacle = 0.5 - dot( normalize(vGradient), -normalize(vFlow)) * 0.5;\n    float fSlowDist = clamp( fDepth * 5.0, 0.0, 1.0);\n    fSlowDist = mix(fSlowDist * 0.9 + 0.1, 1.0, fBehindObstacle * 0.9);\n    \/\/vFlow += vGradient * 10.0 * (1.0 - fSlowDist);\n    fSlowDist = 0.5 + fSlowDist * 0.5;\n    vFlow *= fSlowDist;\n#endif    \n    \n    float fFoamScale1 =0.5;\n    float fFoamCutoff = 0.4;\n    float fFoamScale2 = 0.35;\n    \n    fFoam = abs(length( vFlow )) * fFoamScale1;\/\/ - length( vBaseFlow ));\n\tfFoam += clamp( fFoam - fFoamCutoff, 0.0, 1.0 );\n    \/\/fFoam = fFoam* fFoam;\n    fFoam = 1.0 - pow( fDist, fFoam * fFoamScale2 );\n    \/\/fFoam = fFoam \/ fDist;\n    return vec3( vFlow * 0.6, fFoam  );\n}\n\nvec4 SampleWaterNormal( vec2 vUV, vec2 vFlowOffset, float fMag, float fFoam )\n{    \n    vec2 vFilterWidth = max(abs(dFdx(vUV)), abs(dFdy(vUV)));\n  \tfloat fFilterWidth= max(vFilterWidth.x, vFilterWidth.y);\n    \n    float fScale = (1.0 \/ (1.0 + fFilterWidth * fFilterWidth * 2000.0));\n    float fGradientAscent = 0.25 + (fFoam * -1.5);\n    vec3 dxy = FBM_DXY(vUV * 20.0, vFlowOffset * 20.0, 0.75 + fFoam * 0.25, fGradientAscent);\n    fScale *= max(0.25, 1.0 - fFoam * 5.0); \/\/ flatten normal in foam\n    vec3 vBlended = mix( vec3(0.0, 1.0, 0.0), normalize( vec3(dxy.x, fMag, dxy.y) ), fScale );\n    return vec4( normalize( vBlended ), dxy.z * fScale );\n}\n\nfloat SampleWaterFoam( vec2 vUV, vec2 vFlowOffset, float fFoam )\n{\n    float f =  FBM_DXY(vUV * 30.0, vFlowOffset * 50.0, 0.8, -0.5 ).z;\n    float fAmount = 0.2;\n    f = max( 0.0, (f - fAmount) \/ fAmount );\n    return pow( 0.5, f );\n}\n    \n\nvec4 SampleFlowingNormal( const vec2 vUV, const vec2 vFlowRate, const float fFoam, const float time, out float fOutFoamTex )\n{\n    float fMag = 2.5 \/ (1.0 + dot( vFlowRate, vFlowRate ) * 5.0);\n    float t0 = fract( time );\n    float t1 = fract( time + 0.5 );\n    \n    float o0 = t0 - 0.5;\n    float o1 = t1 - 0.5;\n    \n    vec4 sample0 = SampleWaterNormal( vUV, vFlowRate * o0, fMag, fFoam );\n    vec4 sample1 = SampleWaterNormal( vUV, vFlowRate * o1, fMag, fFoam );\n\n    float weight = abs( t0 - 0.5 ) * 2.0;\n    \/\/weight = smoothstep( 0.0, 1.0, weight );\n\n    float foam0 = SampleWaterFoam( vUV, vFlowRate * o0 * 0.25, fFoam );\n    float foam1 = SampleWaterFoam( vUV, vFlowRate * o1 * 0.25, fFoam );\n    \n    vec4 result=  mix( sample0, sample1, weight );\n    result.xyz = normalize(result.xyz);\n\n    fOutFoamTex = mix( foam0, foam1, weight );\n\n    return result;\n}\n\nvec2 GetWindowCoord( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x \/ iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget )\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\t\t\t\t\t\t  \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * 2.0);\n\n\treturn vDir;\n}\n\nvec3 ApplyVignetting( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0);\n\t\n\tfloat fDist = dot(vOffset, vOffset);\n\t\n\tconst float kStrength = 0.8;\n\t\n\tfloat fShade = mix( 1.0, 1.0 - kStrength, fDist );\t\n\n\treturn vInput * fShade;\n}\n\nvec3 ApplyTonemap( const in vec3 vLinear )\n{\n    float fExposure = clamp( g_fTime * 0.25, 0.0, 1.0 );\n    \n    fExposure *= 1.25;\n    \n\treturn 1.0 - exp2(vLinear * -fExposure);\t\n}\n\nvec3 ApplyGamma( const in vec3 vLinear )\n{\n\tconst float kGamma = 2.2;\n\n\treturn pow(vLinear, vec3(1.0\/kGamma));\t\n}\n\nstruct Intersection\n{\n    float m_dist;\n    float m_objId;\n    vec3 m_pos;\n};\n    \nvoid RaymarchScene( vec3 vRayOrigin, vec3 vRayDir, out Intersection intersection )\n{\n    float stepScale = 1.0;\n#ifdef ENABLE_CONE_STEPPING\n    vec2 vRayProfile = vec2( sqrt(dot(vRayDir.xz, vRayDir.xz) ), vRayDir.y );\n    vec2 vGradVec = normalize( vec2( 1.0, 2.0 ) ); \/\/ represents the biggest gradient in our heightfield\n    vec2 vGradPerp = vec2( vGradVec.y, -vGradVec.x );\n\n    float fRdotG = dot( vRayProfile, vGradPerp );\n    float fOdotG = dot( vec2(0.0, 1.0), vGradPerp );\n\n    stepScale = -fOdotG \/ fRdotG;\n\n    if ( stepScale < 0.0 )\n    {\n        intersection.m_objId = OBJ_ID_SKY;\n        intersection.m_dist = k_fFarClip;\n        return;\n    }\n#endif\n    \n    intersection.m_dist = 0.01;\n    intersection.m_objId = OBJ_ID_SKY;\n    \n    float fSceneDist = 0.0;\n    \n    float oldT = 0.01;\n    for( int iter = 0; iter < k_raymarchSteps; iter++ )\n    {\n        vec3 vPos = vRayOrigin + vRayDir * intersection.m_dist;\n      \n        \/\/ into sky - early out\n        if ( vRayDir.y > 0.0 )\n        {\n            if( vPos.y > 1.0 )\n            {\n                intersection.m_objId = OBJ_ID_SKY;\n                intersection.m_dist = k_fFarClip;\n                break;\n            }\n        }\n\n      \n        fSceneDist = GetSceneDistance( vPos );\n\n        oldT = intersection.m_dist;\n        intersection.m_dist += fSceneDist * stepScale;\n                \n        intersection.m_objId = OBJ_ID_GROUND;\n        if ( fSceneDist <= 0.01 )\n        {\n            break;\n        }\n\n        if ( intersection.m_dist > k_fFarClip )\n        {\n            intersection.m_objId = OBJ_ID_SKY;\n            intersection.m_dist = k_fFarClip;\n            break;\n        }        \n\n        \n    }    \n    \n    intersection.m_pos = vRayOrigin + vRayDir * intersection.m_dist;\n}\n\nvec3 GetSceneNormal(const in vec3 vPos)\n{\n    const float fDelta = 0.001;\n\n    vec3 vDir1 = vec3( 1.0, 0.0, -1.0);\n    vec3 vDir2 = vec3(-1.0, 0.0,  1.0);\n    vec3 vDir3 = vec3(-1.0, 0.0, -1.0);\n\t\n    vec3 vOffset1 = vDir1 * fDelta;\n    vec3 vOffset2 = vDir2 * fDelta;\n    vec3 vOffset3 = vDir3 * fDelta;\n\n    vec3 vPos1 = vPos + vOffset1;\n    vec3 vPos2 = vPos + vOffset2;\n    vec3 vPos3 = vPos + vOffset3;\n \n    float f1 = GetSceneDistance( vPos1 );\n    float f2 = GetSceneDistance( vPos2 );\n    float f3 = GetSceneDistance( vPos3 );\n    \n    vPos1.y -= f1;\n    vPos2.y -= f2;\n    vPos3.y -= f3;\n    \n    vec3 vNormal = cross( vPos1 - vPos2, vPos3 - vPos2 );\n    \n    return normalize( vNormal );\n}\n\n\nvoid TraceWater( vec3 vRayOrigin, vec3 vRayDir, out Intersection intersection )\n{\n \tintersection.m_dist = k_fFarClip;\n    \n    float t = -vRayOrigin.y \/ vRayDir.y;\n    if ( t > 0.0 )\n    {\n        intersection.m_dist = t;\n    }\n    \n    intersection.m_pos = vRayOrigin + vRayDir * intersection.m_dist;\n}\n\nstruct Surface\n{\n    vec3 m_pos;\n    vec3 m_normal;\n    vec3 m_albedo;\n    vec3 m_specR0;\n    float m_gloss;\n    float m_specScale;\n};\n    \nvoid GetSurfaceInfo( Intersection intersection, out Surface surface )\n{\n    surface.m_pos = intersection.m_pos;\n    surface.m_normal = GetSceneNormal(intersection.m_pos);\n\n    #if 0\n    surface.m_albedo = texture2D( iChannel0, intersection.m_pos.xz ).rgb;\n    surface.m_albedo = surface.m_albedo * surface.m_albedo;\n    #else\n    vec3 vWeights = surface.m_normal * surface.m_normal;\n    vec3 col = vec3(0.0);\n    vec3 sample;\n    sample = texture2D( iChannel0, intersection.m_pos.xz ).rgb;\n    col += sample * sample * vWeights.y;\n    sample = texture2D( iChannel0, intersection.m_pos.xy ).rgb;\n    col += sample * sample * vWeights.z;\n    sample = texture2D( iChannel0, intersection.m_pos.yz ).rgb;\n    col += sample * sample * vWeights.x;\n    col \/= vWeights.x + vWeights.y + vWeights.z;\n    surface.m_albedo = col;\n    #endif\n    \n    surface.m_specR0 = vec3(0.001);\n    surface.m_gloss = 0.0;\n    surface.m_specScale = 1.0;\n}\n   \nfloat GIV( float dotNV, float k)\n{\n\treturn 1.0 \/ ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\nfloat GetSunShadow( const vec3 vPos )\n{\n    vec3 vSunDir = GetSunDir();\n\n    Intersection shadowInt;\n    float k_fShadowDist = 2.0;\n    RaymarchScene( vPos + vSunDir * k_fShadowDist, -vSunDir, shadowInt );\n    \n    float fShadowFactor = 1.0;\n    if( shadowInt.m_dist < (k_fShadowDist - 0.1) )\n    {\n        fShadowFactor = 0.0;\n    }\n\n    return fShadowFactor;\n}\n\nvoid AddSunLight( Surface surf, const vec3 vViewDir, const float fShadowFactor, inout vec3 vDiffuse, inout vec3 vSpecular )\n{\n    vec3 vSunDir = GetSunDir();\n\n\tvec3 vH = normalize( vViewDir + vSunDir );\n\tfloat fNdotL = clamp(dot(GetSunDir(), surf.m_normal), 0.0, 1.0);\n\tfloat fNdotV = clamp(dot(vViewDir, surf.m_normal), 0.0, 1.0);\n\tfloat fNdotH = clamp(dot(surf.m_normal, vH), 0.0, 1.0);\n    \n    float diffuseIntensity = fNdotL;\n    \n    vDiffuse += g_sunColour * diffuseIntensity * fShadowFactor;\n\t\/\/vDiffuse = fShadowFactor * vec3(100.0);\n\t\n\tfloat alpha = 1.0 - surf.m_gloss;\n\t\/\/ D\n\n\tfloat alphaSqr = alpha * alpha;\n\tfloat pi = 3.14159;\n\tfloat denom = fNdotH * fNdotH * (alphaSqr - 1.0) + 1.0;\n\tfloat d = alphaSqr \/ (pi * denom * denom);\n\n\tfloat k = alpha \/ 2.0;\n\tfloat vis = GIV(fNdotL, k) * GIV(fNdotV, k);\n\n\tfloat fSpecularIntensity = d * vis * fNdotL;\n\tvSpecular += g_sunColour * fSpecularIntensity * fShadowFactor;\n}\n    \nvoid AddSkyLight( Surface surf, inout vec3 vDiffuse, inout vec3 vSpecular )\n{\n    float skyIntensity = max( 0.0, surf.m_normal.y * 0.3 + 0.7 );\n    vDiffuse += g_skyColour * skyIntensity;       \n}\n\nvec3 GetFresnel( vec3 vView, vec3 vNormal, vec3 vR0, float fGloss )\n{\n    float NdotV = max( 0.0, dot( vView, vNormal ) );\n\n    return vR0 + (vec3(1.0) - vR0) * pow( 1.0 - NdotV, 5.0 ) * pow( fGloss, 20.0 );\n}\n\nvec3 GetWaterExtinction( float dist )\n{\n    float fOpticalDepth = dist * 6.0;\n\n    vec3 vExtinctCol = 1.0 - vec3(0.5, 0.4, 0.1);           \n    vec3 vExtinction = exp2( -fOpticalDepth * vExtinctCol );\n    \n    return vExtinction;\n}\n\nvec3 GetSkyColour( vec3 vRayDir )\n{    \n\tvec3 vSkyColour = mix( k_bgSkyColourDown, k_bgSkyColourUp, clamp( vRayDir.y, 0.0, 1.0 ) );\n    float fSunDotV = dot(GetSunDir(), vRayDir);    \n    float fDirDot = clamp(fSunDotV * 0.5 + 0.5, 0.0, 1.0);\n    vSkyColour += g_sunColour * (1.0 - exp2(fDirDot * -0.5)) * 2.0;\n    \n    return vSkyColour;\n}\n\nvec3 GetEnvColour( vec3 vRayDir, float fGloss )\n{\n\treturn mix( k_envFloorColor, k_bgSkyColourUp, clamp( vRayDir.y * (1.0 - fGloss * 0.5) * 0.5 + 0.5, 0.0, 1.0 ) );\n}\n\n\nvec3 GetRayColour( const in vec3 vRayOrigin, const in vec3 vRayDir, out Intersection intersection )\n{\n    RaymarchScene( vRayOrigin, vRayDir, intersection );        \n\n    if ( intersection.m_objId == OBJ_ID_SKY )\n    {\n        return GetSkyColour( vRayDir );\n    }\n    \n    Surface surface;\n    GetSurfaceInfo( intersection, surface );\n\n    vec3 vIgnore = vec3(0.0);\n    vec3 vResult = vec3(0.0);\n    float fSunShadow = 1.0;\n    AddSunLight( surface, -vRayDir, fSunShadow, vResult, vIgnore );\n    AddSkyLight( surface, vResult, vIgnore);\n    return vResult * surface.m_albedo;\n}\n\nvec3 GetRayColour( const in vec3 vRayOrigin, const in vec3 vRayDir )\n{\n\tIntersection intersection;\n    return GetRayColour( vRayOrigin, vRayDir, intersection );\n}\n\nvec3 GetSceneColour( const in vec3 vRayOrigin,  const in vec3 vRayDir )\n{\n\tIntersection primaryInt;\n    RaymarchScene( vRayOrigin, vRayDir, primaryInt );\n\n     float fFogDistance = 0.0;\n    vec3 vResult = vec3( 0.0 );\n    \n    float fSunDotV = dot(GetSunDir(), vRayDir);    \n\n    if ( primaryInt.m_objId == OBJ_ID_SKY )\n    {\n        vResult = GetSkyColour( vRayDir );\n        fFogDistance = k_fFarClip;\n    }\n    else\n    {\n        Intersection waterInt;\n        TraceWater( vRayOrigin, vRayDir, waterInt );\n\n        vec3 vReflectRayOrigin;\n        vec3 vSpecNormal;\n        vec3 vTransmitLight;\n\n        Surface specSurface;\n        vec3 vSpecularLight = vec3(0.0);\n\n    #ifdef ENABLE_WATER\n        vec3 vFlowRateAndFoam = GetFlowRate( waterInt.m_pos.xz );\n        vec2 vFlowRate = vFlowRateAndFoam.xy;\n        #ifdef ENABLE_FOAM\n        float fFoam = vFlowRateAndFoam.z;\n        float fFoamScale = 1.5;\n        float fFoamOffset = 0.2;\n        fFoam = clamp( (fFoam - fFoamOffset) * fFoamScale, 0.0, 1.0 );\n        fFoam = fFoam * fFoam * 0.5;\n        #else\n        float fFoam = 0.0;\n        #endif            \n\n        float fWaterFoamTex = 1.0;\n        vec4 vWaterNormalAndHeight = SampleFlowingNormal( waterInt.m_pos.xz, vFlowRate, fFoam, g_fTime, fWaterFoamTex );\n        \n        if( vRayDir.y < -0.01 )\n        {\n            \/\/ lie about the water intersection depth\n            waterInt.m_dist -= (0.04 * (1.0 - vWaterNormalAndHeight.w) \/ vRayDir.y);\n        }\n        \n        if( waterInt.m_dist < primaryInt.m_dist )\n        {\n            fFogDistance = waterInt.m_dist;\n            vec3 vWaterNormal = vWaterNormalAndHeight.xyz;\n\n            vReflectRayOrigin = waterInt.m_pos;\n            vSpecNormal = vWaterNormal;\n\n            vec3 vRefractRayOrigin = waterInt.m_pos;\n            vec3 vRefractRayDir = refract( vRayDir, vWaterNormal, 1.0 \/ 1.3333 );\n\n            Intersection refractInt;\n            vec3 vRefractLight = GetRayColour( vRefractRayOrigin, vRefractRayDir, refractInt ); \/\/ note : dont need sky\n\n            float fEdgeAlpha = clamp( (1.0 + vWaterNormalAndHeight.w * 0.25) - refractInt.m_dist * 10.0, 0.0, 1.0 );\n            fFoam *= 1.0 - fEdgeAlpha;\n            \n            \/\/ add extra extinction for the light travelling to the point underwater\n            vec3 vExtinction = GetWaterExtinction( refractInt.m_dist + abs( refractInt.m_pos.y ) );\n\n            specSurface.m_pos = waterInt.m_pos;\n            specSurface.m_normal = normalize( vWaterNormal + GetSunDir() * fFoam ); \/\/ would rather have SSS for foam\n            specSurface.m_albedo = vec3(1.0);\n            specSurface.m_specR0 = vec3( 0.01, 0.01, 0.01 );\n\n            vec2 vFilterWidth = max(abs(dFdx(waterInt.m_pos.xz)), abs(dFdy(waterInt.m_pos.xz)));\n  \t\t\tfloat fFilterWidth= max(vFilterWidth.x, vFilterWidth.y);\n            float fGlossFactor = exp2( -fFilterWidth * 0.3 );\n            specSurface.m_gloss = 0.99 * fGlossFactor;            \n            specSurface.m_specScale = 1.0;\n            \n            vec3 vSurfaceDiffuse = vec3(0.0);\n\n            float fSunShadow = 1.0;\n        #ifdef ENABLE_WATER_RECEIVE_SHADOW\n            fSunShadow = GetSunShadow( waterInt.m_pos );\n        #endif\n            AddSunLight( specSurface, -vRayDir, fSunShadow, vSurfaceDiffuse, vSpecularLight);\n            AddSkyLight( specSurface, vSurfaceDiffuse, vSpecularLight);\n\n            vec3 vInscatter = vSurfaceDiffuse * (1.0 - exp( -refractInt.m_dist * 0.1 )) * (1.0 + fSunDotV);\n            vTransmitLight = vRefractLight.rgb;\n            vTransmitLight += vInscatter;\n            vTransmitLight *= vExtinction;   \n\n\n    #ifdef ENABLE_FOAM\n            float fFoamBlend = 1.0 - pow( fWaterFoamTex, fFoam * 5.0);\/\/ * (1.0 - fWaterFoamTex));\n            vTransmitLight = mix(vTransmitLight, vSurfaceDiffuse * 0.8, fFoamBlend );\n            specSurface.m_specScale = clamp(1.0 - fFoamBlend * 4.0, 0.0, 1.0);\n    #endif\n        }\n        else\n    #endif \/\/ #ifdef ENABLE_WATER\n        {\n            fFogDistance = primaryInt.m_dist;\n\n            Surface primarySurface;\n            GetSurfaceInfo( primaryInt, primarySurface );\n\n            vSpecNormal = primarySurface.m_normal;\n            vReflectRayOrigin = primaryInt.m_pos;\n            \n            float fWetness = 1.0 - clamp( (vReflectRayOrigin.y + 0.025) * 5.0, 0.0, 1.0);\n            primarySurface.m_gloss = mix( primarySurface.m_albedo.r, 1.0, fWetness );\n            primarySurface.m_albedo = mix( primarySurface.m_albedo, primarySurface.m_albedo * 0.8, fWetness );\n\n            vTransmitLight = vec3(0.0);\n            float fSunShadow = 1.0;\n       #ifdef ENABLE_LANDSCAPE_RECEIVE_SHADOW\n            fSunShadow = GetSunShadow( primaryInt.m_pos );\n       #endif\n            AddSunLight( primarySurface, -vRayDir, fSunShadow, vTransmitLight, vSpecularLight);\n            AddSkyLight( primarySurface, vTransmitLight, vSpecularLight);\n            vTransmitLight *= primarySurface.m_albedo;\n            specSurface = primarySurface;\n        }\n\n        vec3 vReflectRayDir = reflect( vRayDir, vSpecNormal );\n        vec3 vReflectLight = GetRayColour( vReflectRayOrigin, vReflectRayDir );\n\n        vReflectLight = mix( GetEnvColour(vReflectRayDir, specSurface.m_gloss), vReflectLight, pow( specSurface.m_gloss, 40.0) );\n        \n        vec3 vFresnel = GetFresnel( -vRayDir, vSpecNormal, specSurface.m_specR0, specSurface.m_gloss );\n\n        vSpecularLight += vReflectLight;\n        vResult = mix(vTransmitLight, vSpecularLight, vFresnel * specSurface.m_specScale );\n    }\n    \n    \n    if ( fFogDistance >= k_fFarClip )\n    {\n        fFogDistance = 100.0;\n        vResult = smoothstep( 0.9975, 0.999, fSunDotV ) * g_sunColour * 200.0;\n    }    \n    \n    vec3 vFogColour = GetSkyColour(vRayDir);\n    \n    vec3 vFogExtCol = exp2( k_vFogExt * -fFogDistance );\n    vec3 vFogInCol = exp2( k_vFogIn * -fFogDistance );\n    vResult = vResult*(vFogExtCol) + vFogColour*(1.0-vFogInCol);\n    \n    return vResult;\n}\n\n\/\/ Code from https:\/\/www.shadertoy.com\/view\/ltlSWf \nvoid BlockRender(in vec2 fragCoord)\n{\n    const float blockRate = 15.0;\n    const float blockSize = 64.0;\n    float frame = floor(iGlobalTime * blockRate);\n    vec2 blockRes = floor(iResolution.xy \/ blockSize) + vec2(1.0);\n    float blockX = fract(frame \/ blockRes.x) * blockRes.x;\n    float blockY = fract(floor(frame \/ blockRes.x) \/ blockRes.y) * blockRes.y;\n    \/\/ Don't draw anything outside the current block.\n    if ((fragCoord.x - blockX * blockSize >= blockSize) ||\n    \t(fragCoord.x - (blockX - 1.0) * blockSize < blockSize) ||\n    \t(fragCoord.y - blockY * blockSize >= blockSize) ||\n    \t(fragCoord.y - (blockY - 1.0) * blockSize < blockSize))\n    {\n        discard;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    g_fTime = iGlobalTime;\n\n#ifdef ENABLE_SCREENSHOT_MODE\n    BlockRender( fragCoord.xy );\n    float fBaseTime = k_screenshotTime;\n#else\n    float fBaseTime = iGlobalTime;\n#endif\n    g_fTime = fBaseTime;\n    \n    float fCameraTime = g_fTime;\n    \n\t\/\/ Static camera locations\n    \/\/fCameraTime = 146.0; \/\/ some rocks\n    \n    vec2 vUV = fragCoord.xy \/ iResolution.xy;\n\n\tvec3 vCameraTarget = vec3(0.0, -0.5, 0.0);\n\n    vCameraTarget.x -= fCameraTime * 0.5;\n    \n    vec3 vCameraPos = vCameraTarget + vec3(0.0, 0.0, 0.0);\n    \n    float fHeading = fCameraTime * 0.1;\n    float fDist = 1.5 - cos(fCameraTime * 0.1 + 2.0) * 0.8;\n    \n    if( iMouse.z > 0.0 )\n    {\n        fHeading = iMouse.x * 10.0 \/ iResolution.x;\n        fDist = 5.0 - iMouse.y * 5.0 \/ iResolution.y;\n    }\n    \n    vCameraPos.y += 1.0 + fDist * fDist * 0.01;\n        \n    vCameraPos.x += sin( fHeading ) * fDist;\n    vCameraPos.z += cos( fHeading ) * fDist;\n    \n    vCameraTarget.z += GetRiverMeander( vCameraTarget.x );\n    vCameraPos.z += GetRiverMeander( vCameraPos.x );\n\n    vCameraPos.y = max( vCameraPos.y, GetTerrainHeightSimple( vCameraPos ) + 0.2 );\n    \n    vec3 vRayOrigin = vCameraPos;\n\tvec3 vRayDir = GetCameraRayDir( GetWindowCoord(vUV), vCameraPos, vCameraTarget );\n\t\n#ifndef ENABLE_SUPERSAMPLE_MODE\n\tvec3 vResult = GetSceneColour(vRayOrigin, vRayDir);\n#else\n\tvec3 vResult = vec3(0.0);\n    float fTot = 0.0;\n    for(int i=0; i<k_superSampleCount; i++)\n    {\n        g_fTime = fBaseTime + (fTot \/ 10.0) \/ 30.0;\n        vec3 vCurrRayDir = vRayDir;\n        vec3 vRandom = vec3( SmoothNoise( fragCoord.xy + fTot ), \n                        SmoothNoise( fragCoord.yx + fTot + 42.0 ),\n                        SmoothNoise( fragCoord.xx + fragCoord.yy + fTot + 42.0 ) ) * 2.0 - 1.0;\n        vRandom = normalize( vRandom );\n        vCurrRayDir += vRandom * 0.001;\n        vCurrRayDir = normalize(vCurrRayDir);\n    \tvResult += GetSceneColour(vRayOrigin, vCurrRayDir);\n        fTot += 1.0;\n    }\n    vResult \/= fTot;\n#endif    \n    \n\tvResult = ApplyVignetting( vUV, vResult );\t\n\t\n\tvec3 vFinal = ApplyGamma(ApplyTonemap(vResult));\n\t\n    vFinal = vFinal * 1.1 - 0.1;\n    \n\tfragColor = vec4(vFinal, 1.0);\n}\n","name":"","description":"","type":"image"}]}}