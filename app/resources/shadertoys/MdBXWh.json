{"Shader":{"ver":"0.1","info":{"id":"MdBXWh","date":"1411333881","viewed":859,"name":"Gray move","username":"FabriceNeyret2","description":"How to memorize a position and move it from keyboard.<br\/>2x4 keys (Horiz: ABCD Vertic: GHIJ) = 16x16 possible locations.<br\/>Based on Greycode (inspired from https:\/\/www.shadertoy.com\/view\/XdS3RV )","likes":4,"published":3,"flags":0,"tags":["graycode"],"hasliked":0},"renderpass":[{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ use of Gray code inspired from https:\/\/www.shadertoy.com\/view\/XdS3RV\n\n\/\/ keyboard control\nint  keyToggle(int ascii) {\treturn (texture2D(iChannel2,vec2((.5+float(ascii))\/256.,0.75)).x > 0.) ?1:0; }\nint ikeyToggle(int ascii) { return 1-keyToggle(ascii); }\n\n\/\/ bitwise operations\nint xor(int a, int b) { \/\/ a XOR b\n    int x=0, bit=1;\n    for (int i=0; i<6; i++) {\n        if (((a-b)\/2)*2 != a-b) x += bit;\n        a \/= 2; b \/= 2; bit *= 2;\n    }\n    return x;\n}\nint bpos(int a) {\t\t\/\/ MSb of a\n    if (a<=0) return -1;\n    for (int i=0; i<6; i++) {\n        if (a==1) return i;\n        a \/= 2;\n    }\n    return 6;\n}\nint bitn(int a, int n) { \/\/ bit N of a, with n=2^N \n    a \/= n;\n    return ((a\/2)*2==a) ? 0 : 1;\n}\n\n\/\/ graycode - from http:\/\/en.wikipedia.org\/wiki\/Gray_code#Converting_to_and_from_Gray_code\nint grayToBinary(int num) {\n    if (num<0) return 0;\n    int mask = num\/2;\n    for (int i=0; i<6; i++)\n        if (mask != 0) {\n            num = xor(num,mask);\n    \t\tmask = mask\/2;\n \t   }\n    return num;  \n}\nint gray(int n) { return (n>=0)? xor(n, n \/ 2) : 0;  }\n\n\/\/ letters display ( ABCD GHIJ only ) - adapted from https:\/\/www.shadertoy.com\/view\/lsXXzN\nfloat segment(vec2 uv, bool On) {\n\treturn (On) ?  (1.-smoothstep(0.08,0.09+float(On)*0.02,abs(uv.x)))*\n\t\t\t       (1.-smoothstep(0.46,0.47+float(On)*0.02,abs(uv.y)+abs(uv.x)))\n\t\t        : 0.;\n}\nfloat digit(vec2 uv,int num) { \/\/ 1..4 = ABCD, 7..10 = GHIJ\n\tfloat seg= 0.;\n    seg += segment(uv.yx+vec2(-1., 0.), num!=8 && num!=9  && num!=10\t);\n\tseg += segment(uv.xy+vec2( .5,-.5), num!=9 && num!=10       \t\t);\n\tseg += segment(uv.xy+vec2(-.5,-.5), num!=3 && num!=7     \t\t    );\n   \tseg += segment(uv.yx+vec2( 0., 0.), num==1 || num==2 || num==8  \t);\n\tseg += segment(uv.xy+vec2( .5, .5), num!=9 && num!=10    \t        );\n\tseg += segment(uv.xy+vec2(-.5, .5), num!=3           \t\t        );\n    seg += segment(uv.yx+vec2( 1., 0.), num!=1 && num!=8 && num!=9 \t    );\t\n    return seg;\n}\t\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \/\/ ==========================================================\n{\n\tvec2 uv = 2.*(fragCoord.xy \/ iResolution.y - vec2(.9,.5));\n    \n    \/\/ grid position from the mask of active keys. NB: ikeyToggle = init pos \n    int hkeys = keyToggle(64+1)+2*keyToggle(64+2)+4*ikeyToggle(64+3)+8*keyToggle(64+4),\n        vkeys = keyToggle(70+1)+2*keyToggle(70+2)+4*ikeyToggle(70+3)+8*keyToggle(70+4);\n    int xr = grayToBinary(hkeys), yu = grayToBinary(vkeys);               \n    \n    \/\/ --- display --- \n    \n#define SCALE 10. \/\/ 6.\n  \n    \/\/ key letters to move around\n    int cr = bpos(xor(gray(xr),gray(xr+1))); if (cr>3) cr=3;\n    int cl = bpos(xor(gray(xr),gray(xr-1))); if (cl<0) cl=3; \n    int cu = bpos(xor(gray(yu),gray(yu+1))); if (cu>3) cu=3;\n    int cd = bpos(xor(gray(yu),gray(yu-1))); if (cd<0) cd=3;\n          \n    \/\/ --- draw cursor\n    vec2 p = vec2(float(xr)-7.5,float(yu)-7.5)\/SCALE;                  \n\tfragColor = vec4(smoothstep(.5,.66,SCALE*length(p-uv)));\n    \n    \/\/ draw letters to move around\n#define drawKey(c,dx,dy,col) {float l= digit(8.*(uv-p)-vec2(dx,dy),c); fragColor*=1.-l; col+=l ; }\n\t\n    drawKey(cr+1,  1.5, 0. ,  fragColor.r);\n    drawKey(cl+1, -1.5, 0. ,  fragColor.g);\n    drawKey(cu+7,    0, 1.4,  fragColor.bg);\n    drawKey(cd+7,    0,-1.4,  fragColor.b);\n    \n    \/\/ --- draw grid    \n    for (int y=-7; y<=8; y++) \n      for (int x=-7; x<=8; x++) {\n        float r = SCALE*length(uv-vec2(float(x)-.5,float(y)-.5)\/SCALE);\n        if (r<1.) fragColor *= smoothstep(0.,.06, abs(r-.033));\n      }\n\n    \/\/ --- draw top pannel\n#define dist(ix,x0) 6.*length(uv-vec2((float(ix)-x0)\/6.,.9))\n    \n    \/\/ pressed letters \n#define Pdraw(kmask,dx) {float r= dist(i,dx); if (r<1.) fragColor *= .7+.3*((bitn(kmask,bit)==1)? smoothstep(.24,.3,r) : smoothstep(0.,.03, abs(r-.33)) ); }\n\n    int bit = 1;\n    for (int i=1; i<=4; i++) {\n        Pdraw(hkeys,5.5);\n        Pdraw(vkeys,-.5);\n        bit *= 2;\n    }\n    \/\/ letters to go around \n#define PdrawKey(c,dx,col) {float r= dist(c,dx); if (r<1.){ float v=smoothstep(.02,.05, abs(r-.33)); fragColor*=v; col+=1.-v;} }\n\n    PdrawKey(cr+1, 5.5, fragColor.r);\n    PdrawKey(cl+1, 5.5, fragColor.g);\n    PdrawKey(cu+1,-0.5, fragColor.bg);\n    PdrawKey(cd+1,-0.5, fragColor.b);\n}","name":"","description":"","type":"image"}]}}