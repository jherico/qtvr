{"Shader":{"ver":"0.1","info":{"id":"ltXSDX","date":"1440091983","viewed":825,"name":"Ray Marching Experiment n\u00b030","username":"aiekick","description":"based on pattern from BeyondTheStatic shader <a href=\"https:\/\/www.shadertoy.com\/view\/XlXSWf\"  class=\"regular\" target=\"_blank\">Poincar\u00e9 Disk<\/a>  displaced on ball<br\/>Control Bump With mouse axis Y","likes":6,"published":3,"flags":0,"tags":["ray","experiment","marching","30"],"hasliked":0},"renderpass":[{"inputs":[{"id":27,"src":"\/presets\/cube05_0.png","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Stephane Cuillerdier - Aiekick\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/*\nbased on pattern from BeyondTheStatic shader https:\/\/www.shadertoy.com\/view\/XlXSWf  displaced on ball\nControl Bump With mouse axis Y\n*\/\n\nfloat dstepf = 0.0;\n    \nconst vec2 RMPrec = vec2(0.2, 0.05); \nconst vec3 DPrec = vec3(1e-3, 12., 1e-8); \n\nvec2 Params; \/\/ y => Elevation\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ pattern based on BeyondTheStatic shader https:\/\/www.shadertoy.com\/view\/XlXSWf\nconst int N\t\t= 7;\t\/\/ number of polygon vertices\nconst int P\t\t= 3;\t\/\/ number of polygons meeting at a vertex\nconst int Iters\t= 4;\t\/\/ number of iterations\n#define HALFPI\t1.57079633\n#define PI\t\t3.14159265\n#define TWOPI\t6.28318531\nfloat s, c;\n#define rotate(p, a) mat2(c=cos(a), s=-sin(a), -s, c) * p\nvec4 poincareGetStuff(int n_, int p_) {\n    float n = PI \/ float(n_), p = PI \/ float(p_);\n\tvec2 r1 = vec2(cos(n), -sin(n));\n    vec2 r2 = vec2(cos(p+n-HALFPI), -sin(p+n-HALFPI));\n    float dist = (r1.x - (r2.x\/r2.y) * r1.y);\n    float rad = length(vec2(dist, 0.)-r1);\n    float d2 = dist*dist - rad*rad;\n    float s = (d2<0. ? 1. : sqrt(d2));\n\treturn vec4(vec3(dist, rad, 1.)\/s, float(d2<0.));\n}\nvec2 radialRepeat(vec2 p, vec2 o, int n) {return rotate(vec2(o.x, o.y), floor(atan(p.x, p.y)*(float(n)\/TWOPI)+.5)\/(float(n)\/TWOPI));}\nvec2 cInvert(vec2 p, vec2 o, float r) {return (p-o) * pow(r, 2.) \/ dot(p-o, p-o) + o;}\nvec2 cInvertMirror(vec2 p, vec2 o, float r, float flip){return (length(p-o)<r ^^ flip==1. ? cInvert(p, o, r) : p);}\nvec2 poincareCreateUVs(vec2 p, vec4 pI) {return cInvertMirror(p, radialRepeat(p, vec2(0., pI.x), N), pI.y, pI.w);}\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nvec4 map(vec3 p)\n{\n    vec2 uv = p.xz\/3.;\n    \n\t\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ pattern based on BeyondTheStatic shader https:\/\/www.shadertoy.com\/view\/XlXSWf\n    vec2 rot = vec2(sin(.3*iGlobalTime), cos(.3*iGlobalTime));\n    uv = cInvert(uv, rot, 1.);\n    uv = cInvert(uv+vec2(rot.y, -rot.x), rot, 1.);\n    vec4 pI = poincareGetStuff(N, P);\n    for(int i=0; i<Iters; i++)\n        uv = poincareCreateUVs(uv, pI);\n    float f = 1. - dot(uv, uv) \/ pow(pI.z, 2.);\n    vec4 col = vec4(vec3(f)*vec3(1.7, 1.1, .8), 1.);\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \n    dstepf += 0.015;\n\n    float disp = dot(col,vec4(Params.y));                            \n    float dist = length(p) -2.5 - smoothstep(0., 1., disp);\n    return vec4(dist, col.rgb);\n}\n\nvec3 nor( vec3 pos, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n    map(pos+e.xyy).x - map(pos-e.xyy).x,\n    map(pos+e.yxy).x - map(pos-e.yxy).x,\n    map(pos+e.yyx).x - map(pos-e.yyx).x );\n    return normalize(n);\n}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cu, vec3 cv)\n{\n\tvec3 rov = normalize(cv-ro);\n    vec3 u =  normalize(cross(cu, rov));\n    vec3 v =  normalize(cross(rov, u));\n    vec3 rd = normalize(rov + u*uv.x + v*uv.y);\n    return rd;\n}\n\nvoid mainImage( out vec4 f, in vec2 g )\n{\n    vec2 si = iResolution.xy;\n   \tfloat t = iGlobalTime;\n    Params.y = (sin(t*.5)*.5+.5)*.1;\n    if (iMouse.z>0.) Params = iMouse.xy \/ si * vec2(1., 0.15);\n    f = vec4(0.);\n    float ca = t*.2; \/\/ angle z\n    float ce = 3.5; \/\/ elevation\n    float cd = 0.5; \/\/ distance to origin axis\n    vec3 cu=vec3(0,1,0);\/\/Change camere up vector here\n    vec3 cv=vec3(0,0,0); \/\/Change camere view here\n    float refl_i = .6; \/\/ reflexion intensity\n    float refr_a = 1.2; \/\/ refraction angle\n    float refr_i = .8; \/\/ refraction intensity\n    float bii = 0.6; \/\/ bright init intensity\n    vec2 uv = (g+g-si)\/min(si.x, si.y);\n    vec3 ro = vec3(sin(ca)*cd, ce+1., cos(ca)*cd); \/\/\n    vec3 rd = cam(uv, ro, cu, cv);\n    float b = bii;\n    vec3 d = vec3(0.);\n    vec3 p = ro+rd*d.x;\n    float s = DPrec.y;\n    float rmd = sign(map(p).x);\n    for(int i=0;i<200;i++)\n    {      \n\t\tif(s<DPrec.x||s>DPrec.y) break;\n        s = map(p).x*(s>DPrec.x?RMPrec.x:RMPrec.y);\n        if (sign(s) != rmd) break;\n        d.y = d.x;\n        d.x += s;\n        p = ro+rd*d.x;\n   \t}\n\n    float countIter = 0.;\n    if (sign(s) == rmd)\n    {\n    \tp = ro+rd*d.x;\n        rmd = map(p).x;\n        for (int i = 0; i < 20; i++)\n        {\n        \tcountIter += 10.;\n            d.z = (d.x + d.y)*.5;\n            p = ro+rd*d.z;\n            s = map(p).x*RMPrec.y;\n            d.x += abs(s);\n            if (abs(s) < DPrec.z)break;\n            (d.x*rmd < 0. )? (d.x = d.z ): (d.y = d.z);\n       \t}\n        d.x = (d.x+d.y) * .5;\n   \t}\n\n    f += pow(b,15.);\n    \n    if (d.x<DPrec.y)\n    {\n    \tfloat nPrec = 10.\/countIter;\n        vec3 n = nor(p, nPrec);\n        vec3 ray = reflect(rd, n);\n        f += textureCube(iChannel0, ray) * refl_i; \n        ray = refract(rd, n, refr_a);\n        f += textureCube(iChannel0, rd) * refr_i; \n        f.rgb = mix( f.rgb, map(p).yzw,0.5);                \n   \t}\n    else\n    {\n    \tf = textureCube(iChannel0, rd);\n    }\n\n    f *= dstepf;\n}\n\n","name":"","description":"","type":"image"}]}}