{"Shader":{"ver":"0.1","info":{"id":"4ts3DB","date":"1424918616","viewed":1829,"name":"Distance - PN Continuous","username":"iq","description":"Subdivision \/ Tesselation of a piecewise linear shape into a cubic, by means of PN-Triangle like tesselation\/. I implemented a a cheap but inaccurate (in short distances) way to compute distances, and a brute force one for comparison.","likes":26,"published":3,"flags":0,"tags":["2d","cubic","subdivision","tesselation","pntriangles"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\/\/ Subdividing a piecewise linear shape into a cubic shape with continuity, ala PN-Triangles,\n\/\/ but in 2D (or in other words, with bezier curves)\n\n\/\/ I have implemented two different version of the distance to the cubic. One is cheap and only\n\/\/ works for concave shapes. It fails at short distances, but is good enough in the distance. The\n\/\/ other one is a brute force one, for comparison.\n\n\/\/ Linear segments in red, cheap approximation in green, brute force in blue\n\n\/\/ Every other cycle derivatives are shown to judge the quality of the field.\n\n\n\nfloat length2( in vec2 v ) { return dot(v,v); }\n\nfloat sdLine2( vec2 p, vec2 a, vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\treturn length2( pa - ba*h );\n}\n\nvec2 cubic( in vec2 a, in vec2 b, in vec2 c, in vec2 d, float v1 )\n{\n    float u1 = 1.0 - v1;\n    float u2 = u1*u1;\n    float v2 = v1*v1;\n    float u3 = u2*u1;\n    float v3 = v2*v1;\n    return a*u3 + d*v3 + b*3.0*u2*v1 + c*3.0*u1*v2;\n}\n\n\/\/----------------------------------------------------------\n\nfloat sdSegment_Cheap( vec2 p, vec2 a, vec2 b, vec2 na, vec2 nb )\n{\n    \/\/ secondary points\n    vec2 k1 = (a*2.0+b)\/3.0; k1 = a + na*dot(na,k1-a)\/dot(na,na);\n    vec2 k2 = (b*2.0+a)\/3.0; k2 = b + nb*dot(nb,k2-b)\/dot(nb,nb);\n\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\n    return sqrt( sdLine2( p, cubic( a, k1, k2, b, clamp( h-0.1, 0.0, 1.0) ), \n                             cubic( a, k1, k2, b, clamp( h+0.1, 0.0, 1.0) ) ) );\n}\n\nfloat sdSegment_Expensive( vec2 p, vec2 a, vec2 b, vec2 na, vec2 nb )\n{\n    \/\/ secondary points\n    vec2 k1 = (a*2.0+b)\/3.0; k1 = a + na*dot(na,k1-a)\/dot(na,na);\n    vec2 k2 = (b*2.0+a)\/3.0; k2 = b + nb*dot(nb,k2-b)\/dot(nb,nb);\n    \n    float md = length2(p-a);\n    vec2 ov = a;\n    for( int i=1; i<32; i++ )\n    {\n        vec2 v = cubic( a, k1, k2, b, float(i+0)\/31.0 );\n        float di = sdLine2( p, v, ov ); ov = v;\n        md = min( di, md );\n    }\n\n    return sqrt(md);\n}\n\n\n\/\/======================================================\n\n\/\/ shape points\n\nvec2 p0 = vec2( 0.6, 0.1)*1.3;\nvec2 p1 = vec2( 0.4, 0.3)*1.3;\nvec2 p2 = vec2(-0.2, 0.5)*1.3;\nvec2 p3 = vec2(-0.6, 0.4)*1.3;\nvec2 p4 = vec2(-0.8, 0.1)*1.3;\nvec2 p5 = vec2(-0.7,-0.1)*1.3;\nvec2 p6 = vec2( 0.0,-0.2)*1.3;\nvec2 p7 = vec2( 0.7,-0.2)*1.3;\n\n#if 0\n\n\/\/ bad shape tangents\n\nvec2 t0 = p1-p7;\nvec2 t1 = p2-p0;\nvec2 t2 = p3-p1;\nvec2 t3 = p4-p2;\nvec2 t4 = p5-p3;\nvec2 t5 = p6-p4;\nvec2 t6 = p7-p5;\nvec2 t7 = p0-p6;\n\n#else\n\n\/\/ shape normals\n\nvec2 n01 = normalize(p1-p0);\nvec2 n12 = normalize(p2-p1);\nvec2 n23 = normalize(p3-p2);\nvec2 n34 = normalize(p4-p3);\nvec2 n45 = normalize(p5-p4);\nvec2 n56 = normalize(p6-p5);\nvec2 n67 = normalize(p7-p6);\nvec2 n70 = normalize(p0-p7);\n\n\/\/ good shape tangents\n\nvec2 t0 = n70+n01;\nvec2 t1 = n01+n12;\nvec2 t2 = n12+n23;\nvec2 t3 = n23+n34;\nvec2 t4 = n34+n45;\nvec2 t5 = n45+n56;\nvec2 t6 = n56+n67;\nvec2 t7 = n67+n70;\n\n#endif\n\n\/\/======================================================\n\n\/\/ distance to linear segments\nfloat cDistance( in vec2 v )\n{\n    float d0 = sdLine2( v, p0, p1 );\n    float d1 = sdLine2( v, p1, p2 );\n    float d2 = sdLine2( v, p2, p3 );\n    float d3 = sdLine2( v, p3, p4 );\n    float d4 = sdLine2( v, p4, p5 );\n    float d5 = sdLine2( v, p5, p6 );\n    float d6 = sdLine2( v, p6, p7 );\n    float d7 = sdLine2( v, p7, p0 );\n    return sqrt( min(d0,min(d1,min(d2,min(d3,min(d4,min(d5,min(d6,d7))))))) );\n}\n\n\/\/ distance to cubic segment\nfloat dDistance_Cheap( in vec2 v )\n{\n    float d0 = sdSegment_Cheap( v, p0, p1, t0, t1 );\n    float d1 = sdSegment_Cheap( v, p1, p2, t1, t2 );\n    float d2 = sdSegment_Cheap( v, p2, p3, t2, t3 );\n    float d3 = sdSegment_Cheap( v, p3, p4, t3, t4 );\n    float d4 = sdSegment_Cheap( v, p4, p5, t4, t5 );\n    float d5 = sdSegment_Cheap( v, p5, p6, t5, t6 );\n    float d6 = sdSegment_Cheap( v, p6, p7, t6, t7 );\n    float d7 = sdSegment_Cheap( v, p7, p0, t7, t0 );\n\n    return min(d0,min(d1,min(d2,min(d3,min(d4,min(d5,min(d6,d7)))))));\n}\n\n\/\/ distance to cubic segment\nfloat dDistance_Expensive( in vec2 v )\n{\n    float d0 = sdSegment_Expensive( v, p0, p1, t0, t1 );\n    float d1 = sdSegment_Expensive( v, p1, p2, t1, t2 );\n    float d2 = sdSegment_Expensive( v, p2, p3, t2, t3 );\n    float d3 = sdSegment_Expensive( v, p3, p4, t3, t4 );\n    float d4 = sdSegment_Expensive( v, p4, p5, t4, t5 );\n    float d5 = sdSegment_Expensive( v, p5, p6, t5, t6 );\n    float d6 = sdSegment_Expensive( v, p6, p7, t6, t7 );\n    float d7 = sdSegment_Expensive( v, p7, p0, t7, t0 );\n\n    return min(d0,min(d1,min(d2,min(d3,min(d4,min(d5,min(d6,d7)))))));\n}\n\n\/\/====================================================================================\n\nvec3 profile( vec3 x )\n{\n    x = mod( x, 12.0 );\n    return clamp(x,0.0,1.0) - clamp(x-4.0,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float m = min(iResolution.x,iResolution.y);\n    vec2  p = (-iResolution.xy+2.0*fragCoord.xy) \/ m;\n\n    float c = cDistance( p );\n    float d = dDistance_Cheap( p );\n    float e = dDistance_Expensive( p );\n    \n    float t = iGlobalTime + 4.0;\n    \n    vec3  w = profile( 2.0*t + 12.0 - vec3(0.0,4.0,8.0) );\n    float a = smoothstep(5.5,6.5,mod(t,12.0));\n    \n    float f = c*w.x + d*w.y + e*w.z;\n    \n    \n    vec3 col = vec3(1.0,1.0,1.0)*clamp( 0.75*f, 0.0, 1.0 ) + 0.02*smoothstep(0.8,0.9,sin(100.0*f));\n    \n    col = mix( col, (0.5+0.25*m*vec3(dFdx(f),dFdy(f),0.0))*exp(-f), a );\n\n        \n    col = mix( col, (0.25 + 0.75*w)*(1.0-a), 1.0-smoothstep(0.0,0.01,f) );\n    \n    \n    col = mix( col, vec3(1.0,1.0,0.0)*(1.0-a), 1.0-smoothstep(0.017,0.02,length(p-p0)) );\n    col = mix( col, vec3(1.0,1.0,0.0)*(1.0-a), 1.0-smoothstep(0.017,0.02,length(p-p1)) );\n    col = mix( col, vec3(1.0,1.0,0.0)*(1.0-a), 1.0-smoothstep(0.017,0.02,length(p-p2)) );\n    col = mix( col, vec3(1.0,1.0,0.0)*(1.0-a), 1.0-smoothstep(0.017,0.02,length(p-p3)) );\n    col = mix( col, vec3(1.0,1.0,0.0)*(1.0-a), 1.0-smoothstep(0.017,0.02,length(p-p4)) );\n    col = mix( col, vec3(1.0,1.0,0.0)*(1.0-a), 1.0-smoothstep(0.017,0.02,length(p-p5)) );\n    col = mix( col, vec3(1.0,1.0,0.0)*(1.0-a), 1.0-smoothstep(0.017,0.02,length(p-p6)) );\n    col = mix( col, vec3(1.0,1.0,0.0)*(1.0-a), 1.0-smoothstep(0.017,0.02,length(p-p7)) );\n\n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}