{"Shader":{"ver":"0.1","info":{"id":"Xd23Dh","date":"1389822885","viewed":16740,"name":"Voronoise","username":"iq","description":"Patterns such as cell-noise, perlin noise and voronoi can be seen as particular cases of a more general pattern, which I call \"voronoise\". More info <a href=\" http:\/\/iquilezles.org\/www\/articles\/voronoise\/voronoise.htm\"  class=\"regular\" target=\"_blank\">in this article<\/a>. ","likes":70,"published":3,"flags":0,"tags":["procedural","2d","voronoi","noise","perlin","worley"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\/\/ This is a procedural pattern that has 2 parameters, that generalizes cell-noise, \n\/\/ perlin-noise and voronoi, all of which can be written in terms of the former as:\n\/\/\n\/\/ cellnoise(x) = pattern(0,0,x)\n\/\/ perlin(x) = pattern(0,1,x)\n\/\/ voronoi(x) = pattern(1,0,x)\n\/\/\n\/\/ From this generalization of the three famouse patterns, a new one (which I call \n\/\/ \"Voronoise\") emerges naturally. It's like perlin noise a bit, but within a jittered \n\/\/ grid like voronoi):\n\/\/\n\/\/ voronoise(x) = pattern(1,1,x)\n\/\/\n\/\/ Not sure what one would use this generalization for, because it's slightly slower \n\/\/ than perlin or voronoise (and certainly much slower than cell noise), and in the \n\/\/ end as a shading TD you just want one or another depending of the type of visual \n\/\/ features you are looking for, I can't see a blending being needed in real life.  \n\/\/ But well, if only for the math fun it was worth trying. And they say a bit of \n\/\/ mathturbation can be healthy anyway!\n\n\n\/\/ Use the mouse to blend between different patterns:\n\n\/\/ ell noise    u=0,v=0\n\/\/ voronoi      u=1,v=0\n\/\/ perlin noise u=0,v1=\n\/\/ voronoise    u=1,v=1\n\n\/\/ More info here: http:\/\/iquilezles.org\/www\/articles\/voronoise\/voronoise.htm\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat iqnoise( in vec2 x, float u, float v )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\t\t\n\tfloat k = 1.0+63.0*pow(1.0-v,4.0);\n\t\n\tfloat va = 0.0;\n\tfloat wt = 0.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n\t\tvec3 o = hash3( p + g )*vec3(u,u,1.0);\n\t\tvec2 r = g - f + o.xy;\n\t\tfloat d = dot(r,r);\n\t\tfloat ww = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n\t\tva += o.z*ww;\n\t\twt += ww;\n    }\n\t\n    return va\/wt;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xx;\n\n    vec2 p = 0.5 - 0.5*sin( iGlobalTime*vec2(1.01,1.71) );\n\t\n\tif( iMouse.w>0.001 ) p = vec2(0.0,1.0) + vec2(1.0,-1.0)*iMouse.xy\/iResolution.xy;\n\t\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n\t\n\tfloat f = iqnoise( 24.0*uv, p.x, p.y );\n\t\n\tfragColor = vec4( f, f, f, 1.0 );\n}","name":"","description":"","type":"image"}]}}