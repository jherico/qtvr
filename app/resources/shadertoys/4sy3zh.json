{"Shader":{"ver":"0.1","info":{"id":"4sy3zh","date":"1453166965","viewed":248,"name":"Last Incandescent","username":"eiffie","description":"Playing with depth maps for shadow and marching.","likes":20,"published":3,"flags":32,"tags":["volumelight"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/Last Incandescent by eiffie\n\/\/buf A is used for a shadow map and also to jump start the ray march similar to\n\/\/... Dave Hoskins' https:\/\/www.shadertoy.com\/view\/4tfXDN\n\n#define PI 3.14159\n#define LIGHT_FALLOFF 1.0\n\nfloat rand(vec3 co){\/\/ implementation found at: lumina.sourceforge.net\/Tutorials\/Noise.html\n\treturn fract(sin(dot(co*0.123,vec3(12.9898,78.233,112.166))) * 43758.5453);\n}\n\nvec3 Tile(vec3 p, float a){return abs(mod(p+a,a*4.0)-a*2.0)-a;}\nconst int iters=5,iter2=3;\nfloat scale=3.48;vec3 offset=vec3(1.9,0.0,2.56);\nfloat psni=pow(scale,-float(iters)),psni2=pow(scale,-float(iter2));\nint obj;\nfloat DE(in vec3 z){\n\tz=Tile(z,3.0);\n\tvec3 z2;\n\tfor (int n = 0; n < iters; n++) {\n\t\tif(n==iter2)z2=z;\n\t\tz = abs(z);\n\t\tif (z.x<z.y)z.xy = z.yx;\n\t\tz.xz = z.zx;\n\t\tz = z*scale - offset*(scale-1.0);\n\t\tif(z.z<-0.5*offset.z*(scale-1.0))z.z+=offset.z*(scale-1.0);\n\t}\n    float d1=(length(z.xy)-1.0)*psni;\n    float d2=length(max(abs(z2)-vec3(0.2,5.1,1.3),0.0))*psni2;\n    obj=(d1<d2)?0:1;\n\treturn min(d1,d2);\n}\n\nmat3 lookat(vec3 fw){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0.0,1.0,0.0)));return mat3(rt,cross(rt,fw),fw);\n}\n\nfloat isInShadow(vec3 p, vec3 posLight, float eps){\n    vec3 L=(p-posLight);\/\/light direction for shadow lookup\n\tfloat d=length(L);\n\tif(d<LIGHT_FALLOFF){\/\/ignore if light is too far away\n\t\tL\/=d;\/\/normalize\n\t\tfloat phi=asin(L.y);\/\/transform back to 2d\n\t\tvec2 pt=vec2(asin(L.z\/cos(phi)),phi);\n        pt\/=vec2(PI*2.0,PI);\n\t\tpt+=0.5;\/\/uncenter\n\t\tpt*=vec2(0.5,1.0);\/\/left side of texture only\n\t\tif(d-2.0*eps*d<texture2D(iChannel0,pt).r*LIGHT_FALLOFF)return d;\n\t}\n    return -1.0;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec2 pt=uv*0.5+vec2(0.5,0.0);\n\t\/\/fragColor = texture2D(iChannel0,uv);return;\n    uv-=0.5;\n    uv*=vec2(iResolution.x\/iResolution.y,1.0);\n    vec3 posLight=vec3(iGlobalTime,sin(iGlobalTime*0.4),1.25);\n\tvec3 ro=vec3(iGlobalTime-1.0+sin(iGlobalTime*0.24)*0.25,sin(iGlobalTime*0.3),0.88+0.5*sin(iGlobalTime*0.34));\n\tvec3 rd=normalize(vec3(uv,1.0));\n\trd=lookat(posLight-vec3(0.0,sin(iGlobalTime*0.3)*0.4,sin(iGlobalTime*0.2)*0.3)-ro)*rd;\n    \n    float maxdepth=10.0,eps=1.0\/iResolution.y,d,t=texture2D(iChannel0,pt).r*maxdepth;\n    vec4 ts=vec4(0.0),ds=vec4(0.0);\n    for(int i=0;i<48;i++){\n        t+=d=DE(ro+rd*t);\n        if(d<eps*t){ts=vec4(t,ts.xyz);ds=vec4(d,ds.xyz);}\/\/push\n        if(ts.w>0.0 || t>maxdepth)break;\n    }\n    vec3 col=vec3(clamp(0.5*t\/maxdepth,0.0,1.0));\n    for(int i=0;i<4;i++){\n        if(ts.x<0.001)break;\n    \tvec3 scol=vec3(clamp(0.4999*ts.x\/maxdepth,0.0,1.0));\n   \t\tvec3 p=ro+ts.x*rd;\n    \tfloat d2=isInShadow(ro+rd*ts.x,posLight,eps);\n    \tif(d2>=0.0){\n\t\t\tvec3 L=normalize(p-posLight);\n        \tfloat d3=DE(ro+rd*ts.x-L*ds.x);\/\/test in the direction of the light\n\t\t\tscol+=clamp((d3-ds.x*0.75)\/ds.x,0.0,1.0)*vec3(1.0,0.9,0.8)\/(1.0+4.0*d2*d2);\n            if(obj==1)scol+=vec3(0.0,0.12,0.1);\n\t\t}\n        col=mix(scol,col,clamp(ds.x\/(eps*ts.x),0.0,1.0));\n        ts=ts.yzwx;ds=ds.yzwx;\/\/pop\n    }\n\tfloat dt=2.0*LIGHT_FALLOFF\/32.0;\n    maxdepth=t;\n\tt=max(0.0,length(ro-posLight)-LIGHT_FALLOFF)+dt*rand(rd);\n\tfor(int i=0;i<32;i++){\n        d=isInShadow(ro+rd*t,posLight,eps);\n        if(d>=0.0){\n\t\t\tcol+=vec3(1.0,0.9,0.6)\/(1.0+300.0*d*d);\n\t\t}\n\t\tt+=dt;\n        if(t>maxdepth)break;\n    }\n\tclamp(col,0.0,1.0);\n    \n\tfragColor=vec4(col,maxdepth);\/\/maxdepth is actually scene depth\n}","name":"","description":"","type":"image"},{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define PI 3.14159\n#define LIGHT_FALLOFF 1.0\n\nfloat rand(vec3 co){\/\/ implementation found at: lumina.sourceforge.net\/Tutorials\/Noise.html\n\treturn fract(sin(dot(co*0.123,vec3(12.9898,78.233,112.166))) * 43758.5453);\n}\n\nvec3 Tile(vec3 p, float a){return abs(mod(p+a,a*4.0)-a*2.0)-a;}\nconst int iters=5,iter2=3;\nfloat scale=3.48;vec3 offset=vec3(1.9,0.0,2.56);\nfloat psni=pow(scale,-float(iters)),psni2=pow(scale,-float(iter2));\nfloat DE(in vec3 z){\n\tz=Tile(z,3.0);\n\tvec3 z2;\n\tfor (int n = 0; n < iters; n++) {\n\t\tif(n==iter2)z2=z;\n\t\tz = abs(z);\n\t\tif (z.x<z.y)z.xy = z.yx;\n\t\tz.xz = z.zx;\n\t\tz = z*scale - offset*(scale-1.0);\n\t\tif(z.z<-0.5*offset.z*(scale-1.0))z.z+=offset.z*(scale-1.0);\n\t}\n\treturn min((length(z.xy)-1.0)*psni,length(max(abs(z2)-vec3(0.2,5.1,1.3),0.0))*psni2);\n}\n\nmat3 lookat(vec3 fw){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0.0,1.0,0.0)));return mat3(rt,cross(rt,fw),fw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv=fragCoord.xy\/iResolution.xy;\n\tuv*=vec2(2.0,1.0);\/\/stretch to 2x1\n\tvec3 ro,rd,posLight=vec3(iGlobalTime,sin(iGlobalTime*0.4),1.25);\n\tfloat maxdepth=10.0,eps=1.0\/iResolution.y;\n\tbool bShadMap=(uv.x<1.0);\n\tif(bShadMap){\/\/left side\n\t\tuv-=0.5;\/\/center left side at 0\n\t\tuv*=vec2(PI*2.0,PI);\/\/for spherical projection\n\t\tro=posLight;\n\t\trd=vec3(cos(uv.y)*cos(uv.x),sin(uv.y),cos(uv.y)*sin(uv.x));\n\t\tmaxdepth=LIGHT_FALLOFF;\n\t}else{\/\/right side\n\t\tif(uv.y>0.5)discard;\n\t\tuv-=vec2(1.5,0.25);\/\/center right side at 0\n\t\tuv*=vec2(iResolution.x\/iResolution.y,2.0);\n\t\tro=vec3(iGlobalTime-1.0+sin(iGlobalTime*0.24)*0.25,sin(iGlobalTime*0.3),0.88+0.5*sin(iGlobalTime*0.34));\n\t\trd=normalize(vec3(uv,1.0));\n\t\trd=lookat(posLight-vec3(0.0,sin(iGlobalTime*0.3)*0.4,sin(iGlobalTime*0.2)*0.3)-ro)*rd;\n\t\teps*=2.0;\n\t}\n\t\n\tfloat t=0.0,d; \/\/march to surface\n\tfor(int i=0;i<32;i++){\n\t\tt+=d=DE(ro+t*rd);\n\t\tif(d<eps*t || t>maxdepth)break;\n\t}\n\t\n\t\n\tt=clamp(t\/maxdepth,0.0,0.99); \/\/this isn't needed for our unclamped float buffer\n\tfragColor=vec4(vec3(t),1.0);\n\t\n}","name":"","description":"","type":"buffer"}]}}