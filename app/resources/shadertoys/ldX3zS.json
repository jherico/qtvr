{"Shader":{"ver":"0.1","info":{"id":"ldX3zS","date":"1373670641","viewed":3728,"name":"Wavy","username":"iq","description":"3d animated noise!","likes":45,"published":3,"flags":0,"tags":["procedural","3d","raymarching","noise","distancefield"],"hasliked":0},"renderpass":[{"inputs":[{"id":10,"src":"\/presets\/tex09.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define FASTNOISE\n\n#ifdef FASTNOISE\nfloat noise( in vec3 x )\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D( iChannel0, (uv+0.5)\/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n#else\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n    \n\tvec2 uv = p.xy + vec2(37.0,17.0)*p.z;\n\n\tvec2 rgA = texture2D( iChannel0, (uv+0.5+vec2(0.0,0.0))\/256.0, -100.0 ).yx;\n    vec2 rgB = texture2D( iChannel0, (uv+0.5+vec2(1.0,0.0))\/256.0, -100.0 ).yx;\n    vec2 rgC = texture2D( iChannel0, (uv+0.5+vec2(0.0,1.0))\/256.0, -100.0 ).yx;\n    vec2 rgD = texture2D( iChannel0, (uv+0.5+vec2(1.0,1.0))\/256.0, -100.0 ).yx;\n\n    vec2 rg = mix( mix( rgA, rgB, f.x ),\n                   mix( rgC, rgD, f.x ), f.y );\n    return mix( rg.x, rg.y, f.z );\n}\n#endif\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec4 x = texture2D( sam, p.yz );\n\tvec4 y = texture2D( sam, p.zx );\n\tvec4 z = texture2D( sam, p.xy );\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\n\/\/=====================================================================\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n\t\t\t\t\t-0.80,  0.36, -0.48,\n\t\t\t\t\t-0.60, -0.48,  0.64 );\n\nfloat mocc;\nvec4 mapTerrain( in vec3 pos )\n{\n\tvec3 q = pos*0.5;\n    \n    vec3  dir = vec3(0.0,1.0,0.0);\n\tfloat spe = 0.04;\n\tfloat time = 5.0 + (iGlobalTime-10.0)*0.5;\n\t\n\tq.xyz += 2.0*noise( 2.0*q )*vec3(1.0,3.0,1.0);\n\t\n\tfloat f;\n\tq *= vec3(1.0,2.0,1.0);\n\tq += dir*time*8.0*spe; f  = 0.50000*noise( q ); q = q*2.02;\n\tq += dir*time*4.0*spe; f += 0.25000*noise( q ); q = q*2.03;\n\tq += dir*time*2.0*spe; f += 0.12500*noise( q ); q = q*2.01;\n    q += dir*time*1.0*spe; f += 0.06250*noise( q );\n    \n\tfloat d =  pos.y + 0.9 - 2.0*f;\n    mocc = f;\n\treturn vec4(q,d);\n}\n\nvec4 raymarchTerrain( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 20.0;\n    float precis = 0.0001;\n\tfloat h = 1.0;\n\tfloat t = 0.1;\n\t\n\tvec4 res = vec4(0.0);\n\tfor( int i=0; i<200; i++ )\n\t{\n\t\tif( abs(h)<precis||t>maxd ) break;\n\n\t\tres = mapTerrain( ro+rd*t );\n\t\th = res.w*0.08;\n\t\tt += h;\n\t}\n\tif( t>maxd ) t=-1.0;\n\treturn vec4(res.xyz,t);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3(0.015,0.0,0.0);\n\t\n\treturn normalize( vec3(\n\t\tmapTerrain(pos+eps.xyy).w - mapTerrain(pos-eps.xyy).w,\n\t\tmapTerrain(pos+eps.yxy).w - mapTerrain(pos-eps.yxy).w,\n\t\tmapTerrain(pos+eps.yyx).w - mapTerrain(pos-eps.yyx).w ) );\n\n}\n\nvec3 lig = normalize( vec3(0.0,0.2,0.7) );\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor( int i=0; i<48; i++ )\n\t{\n\t\tfloat h = mapTerrain(ro + rd*t).w;\n\t\th = max( h*0.08, 0.0 );\n\t\tres = min( res, k*h\/t );\n\t\tt += clamp( h, 0.02, 0.5 );\n\t\tif( h<0.0001 ) break;\n\t}\n\treturn clamp(res,0.0,1.0);\n}\n\nvec3 path( float time )\n{\n\treturn vec3( 2.5*cos(0.03*time), 1.5, 2.5*sin(0.03*time) );\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy)\/iResolution.y;\n\t\n\t\/\/ camera\n\tfloat time = 125.0-iGlobalTime+10.0;\n\tvec3 ro = path( time+0.0 );\n\tvec3 ta = vec3(0.0,-0.5,0.0);\n\tfloat roll = 0.15*cos(0.07*time);\n\t\n\t\/\/ camera tx\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n\tfloat r2 = p.x*p.x*0.32 + p.y*p.y;\n\tp *= (7.0-sqrt(37.5-11.5*r2))\/(r2+1.0);\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 1.3*cw );\n\t\n\t\/\/ sky\n\tvec3 col = vec3(0.25,0.36,0.36)*1.3 - rd.y*0.5;\n\tfloat sun = clamp( dot(rd,lig), 0.0, 1.0 );\n\tcol += vec3(1.0,0.8,0.4)*0.2*pow( sun, 6.0 );\n\tvec3 bcol = col;\n\t\n\t\/\/ terrain\n\tvec4 res = raymarchTerrain(ro, rd);\n\tfloat t = res.w;\n\tif( t>0.0 )\n    {\n        float occ = pow( clamp(mocc*2.2-0.6,0.0,1.0), 1.5 );\n\t\tvec3 pos = ro + t*rd;\n\t\tvec3 nor = calcNormal( pos );\n\t\t\n\t\t\/\/ lighting\n\t\tfloat dif = sqrt(clamp( dot( nor, lig ), 0.0, 1.0 ));\n\t\tfloat sha = 0.0; if( dif>0.01) sha=softshadow(pos,lig,0.01, 40.0);\n\t\tfloat bac = clamp( dot( nor, normalize(lig*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\n\t\tfloat sky = 0.5 + 0.5*nor.y;\n\t\tfloat amb = 1.0;\n\t\t\n\t\tvec3 brdf  = 1.5*dif*vec3(1.2,0.70,0.50)*sha*(0.8+0.2*occ);\n\t\t     brdf += 0.6*amb*vec3(0.4,0.28,0.10)*occ;\n             brdf += 0.7*bac*vec3(0.7,0.35,0.15)*occ;\n             brdf += 0.8*sky*vec3(0.2,0.35,0.40)*occ;\n\t\t\n\t\t\/\/ surface shading\/material\n\t\tcol  = texcube( iChannel1, 0.005*res.xyz, nor ).xyz;\n\t\tcol *= texcube( iChannel1, 0.050*res.xyz, nor ).xyz;\n\t\tcol = sqrt(sqrt(col));\n\t\tcol *= vec3(1.2,1.1,1.0);\n\t\tcol = mix( col, col*vec3(2.0,0.4,0.4), 0.8*clamp( 1.0-2.0*occ,0.0,1.0) );\n\t\t\n\t\t\/\/ light\/surface interaction\n\t\tcol = brdf * col;\n\t\tcol = mix( col, vec3(dot(col,vec3(0.33))), 0.5*dif-0.2 );\n\t\t\n\t\t\/\/ atmospheric\n\t\tfloat hh = 1.0 - smoothstep( -2.0, 1.0, pos.y );\n\t\tcol = mix( col, (1.0-0.7*hh)*bcol, 1.0-exp(-0.002*t*t*t) );\n\t}\n\t\n\t\/\/ sun glow\n\tcol += vec3(1.2,0.7,0.2)*0.53*pow( sun, 3.0 )*clamp( (rd.y+0.4)\/(0.0+0.4),0.0,1.0);\n\t\n\t\/\/ gamma\n\tcol = pow( clamp( col, 0.0, 1.0 ), vec3(0.45) );\n\t\n\t\/\/ contrast, desat, tint and vignetting\n\tcol = col*col*(3.0-2.0*col);\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15 );\n\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}