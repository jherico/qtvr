{"Shader":{"ver":"0.1","info":{"id":"4dKGR1","date":"1453289719","viewed":236,"name":"Visual Hierarchy","username":"eiffie","description":"Testing the difference in speed\/quality between standard march and the hierarchical method explored by Dave. After testing on several machines all I can say is its VERY machine dependent.<br\/>","likes":10,"published":3,"flags":32,"tags":["hierarchy"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/The hierarchy test is in buf A\n\/\/the original is from Dave Hoskins https:\/\/www.shadertoy.com\/view\/4tfXDN\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\tfragColor = vec4(texture2D(iChannel0,uv).rgb,1.0);\n}","name":"","description":"","type":"image"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define USE_HIER\n\n\/\/Preset 6 from kali's amazing surface for Fragmentarium - based on tglad's amazing box\n#define Iterations 30\n#define FoldValues vec2(1.51315,0.78945)\n#define RotVector vec3(0.84,-0.30666,1.)\n#define RotAngle -31.2444\n#define Scale 1.26066\n#define MinRad2 1e-05\n#define PreTranslation vec3(-1,-0.7082,0.)\n#define FOV 0.4878\n#define Eye vec3(-2.53692,-0.465105,-0.00992148)\n#define Target vec3(-2.53692,-1.466,-0.00992148)\n\/\/#define Target vec3(-2.51804,-3.61506,-0.288198)\n#define Up vec3(0.0322806,-0.0877623,0.995618)\n#define MAX_DEPTH 3.\n\nmat3 rot;\n\nfloat DE(vec3 pos) {\n\tvec4 p = vec4(pos,1.);\n\tvec4 c = p;  \n\tfor (int i=0; i<Iterations; i++) {\n\t\tp.xy=abs(p.xy+FoldValues);\n\t\tp.xyz+=PreTranslation;\n\t\tfloat r2 = dot(p.xyz, p.xyz);\n\t\tp*=Scale\/clamp(r2,MinRad2,1.0);\n\t\tp+=c;\n\t\tp.xyz*=rot;\n\t\tif(r2>3600.)break;\n\t}\n\treturn (length(p.xyz) - 1.) \/ p.w;\n}\n\n\/\/from Syntopia's Fragmentarium MathUtils.frag\n\/\/ Return rotation matrix for rotating around vector v by angle\nmat3  rotationMatrix3(vec3 v, float angle)\n{\n\tfloat c = cos(radians(angle));\n\tfloat s = sin(radians(angle));\n\t\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\nmat3 lookat(vec3 fw,vec3 up){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,normalize(up)));return mat3(rt,cross(rt,fw),fw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tif(iFrame==0){fragColor=vec4(0.0);return;}\n\tvec2 ms=(iMouse.x>0.0)?iMouse.xy\/iResolution.xy-0.5:vec2(0.0);\n\tvec2 coord,rez,uv;\/\/new coordinate,resolution and lookup\n\tif(fragCoord.x<iResolution.x*2.\/3.){\n\t\trez=iResolution.xy*vec2(2.\/3.,1.);\n\t\tcoord=fragCoord.xy;\n\t\tuv=iResolution.xy*vec2(2.\/3.,0.);\n\t}\n#ifdef USE_HIER\n\telse if(fragCoord.y<iResolution.y*.5){\n\t\trez=iResolution.xy*vec2(1.\/3.,.5);\n\t\tcoord=fragCoord.xy-vec2(iResolution.x*2.\/3.,0.);\n\t\tuv=iResolution.xy*vec2(2.\/3.,.5);\n\t}else if(fragCoord.y<iResolution.y*0.75){\n\t\tif(fragCoord.x>iResolution.x*(1.-1.\/6.))discard;\n\t\trez=iResolution.xy*vec2(1.\/6.,.25);\n\t\tcoord=fragCoord.xy-vec2(iResolution.x*2.\/3.,iResolution.y*.5);\n\t\tuv=iResolution.xy*vec2(2.\/3.,.75);\n\t}else if(fragCoord.y<iResolution.y*.875){\n\t\tif(fragCoord.x>iResolution.x*(1.-1.\/4.))discard;\n\t\trez=iResolution.xy*vec2(1.\/12.,.125);\n\t\tcoord=fragCoord.xy-vec2(iResolution.x*2.\/3.,iResolution.y*.75);\n\t\tuv=iResolution.xy*vec2(2.\/3.,.875);\/\/points nowhere\n\t}\n#endif\n    else {fragColor=vec4(0.0);return;}\n\n\trot=rotationMatrix3(RotVector,RotAngle);\n\tvec3 ro=Eye+vec3(ms.x,0.0,ms.y);\n\tvec3 rd=lookat(Target-ro,Up)*normalize(vec3((2.0*coord.xy-rez.xy)\/rez.y,1.0\/FOV));\n\t\n\tfloat eps=1.\/rez.y,t,d;\n\tt=texture2D(iChannel0,(uv+coord*0.5)\/iResolution.xy).w*MAX_DEPTH;\n\tfor(int i=0;i<64;i++){\n\t\td=0.1*DE(ro+rd*t);\n\t\tif(d<eps*t || t>MAX_DEPTH)break;\n\t\tt+=d;\n\t}\n\tt=clamp(t\/MAX_DEPTH,0.0,1.0);\n\tfragColor=vec4(t);\n}\n\n\n\n","name":"","description":"","type":"buffer"}]}}