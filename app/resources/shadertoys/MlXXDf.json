{"Shader":{"ver":"0.1","info":{"id":"MlXXDf","date":"1440161865","viewed":920,"name":"adder","username":"FabriceNeyret2","description":"Simulates a N bits adder. Top: the 2 numbers to add (tuned by mouse.xy).<br\/>Try 11111111 + 1 :-)  <br\/>Each adder is made of 2 and\/xor gates: A,B -> AND,XOR","likes":10,"published":3,"flags":0,"tags":["simulation","boolean","logic"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Simulation of a N bits adder. \n\n#define N 8                   \/\/ number of bits\n\nbool a0[N],b0[N],             \/\/ bits of the two numbers to be added\n      s[N+1],                 \/\/ bits of the result\n      a[2*N],b[2*N],c[2*N+1], \/\/ input of binary half-adders\n      X[2*N],A[2*N];          \/\/ output of binary half-adders \n\n\n\/\/ --- utilities\n\n#define rnd(x) fract(4e4*sin((x)*7654.23+17.34))\n\nvec2 mymin(vec2 l,float l2,bool p) { return l.x < l2 ? l : vec2(l2,p); }\n\n\/\/ --- draw line (indeed, distance to line. -> l = min(l, line() ). )\n\nfloat line(vec2 uv, vec2 p0, vec2 p1) {\n    uv -= p0; p1 -= p0;\n    float lp = length(p1), luv = length(uv), l = dot(uv,p1\/lp);\n    if (l<0. || l>lp) return 1e8;\n\n    return length(uv - l*(p1\/lp));\n}\n\nvoid mainImage( out vec4 fragColor, vec2 uv ) {    \n    float t = iGlobalTime*1., T = float(N+4),\n          nt= floor(t\/T); t = mod(t,T); \n    vec2 R = iResolution.xy, \n         m = iMouse.xy\/R; \n    uv \/= R;\n    \n\t\/\/ --- init\n    \n    \/\/ all registers at false\n    for (int i=0; i<N; i++) \n        a0[i]=b0[i]=s[i]=   a[i]=b[i]=c[i]=X[i]=A[i]=  a[i+N]=b[i+N]=c[i+N]=X[i+N]=A[i+N]=  false;\n    s[N]=false;\n \n    \/\/ the two numbers to be added (from mouse.xy or rnd)\n\n    if (m.x+m.y<1e-5)   m.x = rnd(nt), m.y = rnd(nt+.5);\n                    \/\/  m.x = 0.96413, m.y = 0.71234;\n\n    for (int i=N-1; i>=0; i--) { \/\/ a0,b0 = float2bin(inputs)\n        float b; \/\/ vec2 b=floor(m*=2); m -= b; \n        m *= 2.;\n        a0[i] = bool(b=floor(m.x)); m.x -=b;\n        b0[i] = bool(b=floor(m.y)); m.y -=b;\n    }\n    \n\n    \n    \/\/ --- simulation steps (finite state automata)\n    \n    for (float it=2.; it<40.; it++) {\n        if (it >= t) break;\n        \n\t    \/\/ process connections\n        for (int i=0; i<N; i++) {\n             a[2*i]   = a0[i];  b[2*i]   = b0[i];  \/\/ input(even adder) = entry\n             a[2*i+1] = X[2*i]; b[2*i+1] = c[2*i]; \/\/ input(odd adder) = XOR(even),carry\n             c[2*i+2] = A[2*i+1]||A[2*i];          \/\/ carry(i+1) = OR(AND(even),AND(odd))\n             c[2*i+1] = A[2*i+1];                  \/\/ (for display wire)\n             s[i]     = X[2*i+1];                  \/\/ XOR(odd) -> result \n           }\n       s[N] = c[2*N]; \/\/ last carry provide an extra bit to the sum.\n        \n        \/\/ process gates xor\/and\n        for (int i=0; i<2*N; i++)  \n           { X[i] = a[i]^^b[i]; A[i] = a[i]&&b[i]; }\n    }\n\n    \n    \/\/ --- display\n    \n    uv *= float(N)+2.2;\n    int  ix = int(uv.x),  iy = int(uv.y);\n    float x = fract(uv.x), y = fract(uv.y);\n    float v=0.;\n\n#define col(b) ( b ? 1. : .2 ) \/\/ registers aspect \n\n    \/\/ display registers (adders and general inputs and outputs)\n     for (int i=0; i<N+1; i++)\n         if (N+1-ix==i) {\n    \t\tif (iy==N+1 && i<N) \/\/ top row: input numbers\n                v = y>.6       ? (x>.1 && x<.6 ? col(a0[i]): 0.) \n                  : y>.1&&y<.5 ? (x>.4 && x<.9 ? col(b0[i]): 0.)\n                  : 0. ;\n\n    \t    else if (iy==0) \/\/ bottom row: output numbers\n                v = y>.25 && y<.75 && x<.9 ? col(s[i]): 0.;\n                                 \n           else if (iy==N-i) \/\/ registers a,b,A,X of all half-adders\n               if (y>.5) { x=2.*x; y = 2.*y-1.;\n               v =  y>.5&&y<.9 ? ( x>.2&&x<.45 ? col(a[2*i  ]) : x>.55&&x<.8 ? col(b[2*i  ]) : 0. )\n                  : y>.0&&y<.4 ? ( x>.2&&x<.45 ? col(A[2*i  ]) : x>.55&&x<.8 ? col(X[2*i  ]) : 0. )\n                  : 0.;\n                      }\n             else {        x = 2.*x-1.; y = 2.*y;\n               v =  y>.5&&y<.9 ? ( x>.2&&x<.45 ? col(a[2*i+1]) : x>.55&&x<.8 ? col(b[2*i+1]) : 0. )\n                  : y>.0&&y<.4 ? ( x>.2&&x<.45 ? col(A[2*i+1]) : x>.55&&x<.8 ? col(X[2*i+1]) : 0. )\n                  : 0.;\n                  }        \n         }\n    \n    \/\/ display connections\n\n    vec2 l=vec2(1e8,0.); float y0;\n \n    for (int i=0; i<N; i++) {\n        x = float(N+1-i), y = float(N-i), y0=float(N+1); bool c2i=c[2*i+2]&&!c[2*i+1];\n        l = mymin(l,line(uv, vec2(x+.25, y0+.7), vec2(x+.15, y+.9)   ), a[2*i]);  \/\/ a0 -> a2i\n        l = mymin(l,line(uv, vec2(x+.65, y0+.2), vec2(x+.35, y+.9)   ), b[2*i]);  \/\/ b0 -> b2i\n        l = mymin(l,line(uv, vec2(x+.5, .75  ),  vec2(x+.85, y+0.)   ), s[i]  );  \/\/ A2i+1-> si\n        l = mymin(l,line(uv, vec2(x+.35, y+.6),  vec2(x+.65, y+.4)   ), a[2*i+1]);\/\/ X2i -> a2i+1\n        l = mymin(l,line(uv, vec2(x+.15, y+.5),  vec2(x+.15, y+.7-1.)), c2i);     \/\/ carry1\n        l = mymin(l,line(uv, vec2(x+.65, y   ),  vec2(x+.15, y+.7-1.)), c[2*i+1]);\/\/ carry2\n        l = mymin(l,line(uv, vec2(x+.15, y+.7-1.),vec2(x+.8-1., y+.45-1.)),c[2*i+2]);\/\/ carryT\n   }\n    \n    \/\/ combine registers and connections\n\tfragColor = mix(vec4(v),vec4(0,.75*l.y,1,1),smoothstep(20.,5.,l.x*R.x));\n}","name":"","description":"","type":"image"}]}}