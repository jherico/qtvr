{"Shader":{"ver":"0.1","info":{"id":"Xd2GR3","date":"1394360615","viewed":6848,"name":"Hexagons - distance","username":"iq","description":"Very dirty maths for computing the distance to hexagon borders","likes":121,"published":3,"flags":0,"tags":["2d","hexagons"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ { 2d cell id, distance to border, distnace to center )\nvec4 hexagon( vec2 p ) \n{\n\tvec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\t\n\tvec2 pi = floor(q);\n\tvec2 pf = fract(q);\n\n\tfloat v = mod(pi.x + pi.y, 3.0);\n\n\tfloat ca = step(1.0,v);\n\tfloat cb = step(2.0,v);\n\tvec2  ma = step(pf.xy,pf.yx);\n\t\n    \/\/ distance to borders\n\tfloat e = dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) );\n\n\t\/\/ distance to center\t\n\tp = vec2( q.x + floor(0.5+p.y\/1.5), 4.0*p.y\/3.0 )*0.5 + 0.5;\n\tfloat f = length( (fract(p) - 0.5)*vec2(1.0,0.85) );\t\t\n\t\n\treturn vec4( pi + ca - cb*ma, e, f );\n}\n\nfloat hash1( vec2  p ) { float n = dot(p,vec2(127.1,311.7) ); return fract(sin(n)*43758.5453); }\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D( iChannel0, (uv+0.5)\/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec2 uv = fragCoord.xy\/iResolution.xy;\n\tvec2 pos = (-iResolution.xy + 2.0*fragCoord.xy)\/iResolution.y;\n\t\n    \/\/ distort\n\tpos *= 1.0 + 0.3*length(pos);\n\t\n    \/\/ gray\n\tvec4 h = hexagon(8.0*pos + 0.5*iGlobalTime);\n\tfloat n = noise( vec3(0.3*h.xy+iGlobalTime*0.1,iGlobalTime) );\n\tvec3 col = 0.15 + 0.15*hash1(h.xy+1.2)*vec3(1.0);\n\tcol *= smoothstep( 0.10, 0.11, h.z );\n\tcol *= smoothstep( 0.10, 0.11, h.w );\n\tcol *= 1.0 + 0.15*sin(40.0*h.z);\n\tcol *= 0.75 + 0.5*h.z*n;\n\t\n\n\t\/\/ red\n\th = hexagon(6.0*pos + 0.6*iGlobalTime);\n\tn = noise( vec3(0.3*h.xy+iGlobalTime*0.1,iGlobalTime) );\n\tvec3 colb = 0.9 + 0.8*sin( hash1(h.xy)*1.5 + 2.0 + vec3(0.0,1.0,1.0) );\n\tcolb *= smoothstep( 0.10, 0.11, h.z );\n\tcolb *= 1.0 + 0.15*sin(40.0*h.z);\n\tcolb *= 0.75 + 0.5*h.z*n;\n\n\th = hexagon(6.0*(pos+0.1*vec2(-1.3,1.0)) + 0.6*iGlobalTime);\n    col *= 1.0-0.8*smoothstep(0.45,0.451,noise( vec3(0.3*h.xy+iGlobalTime*0.1,iGlobalTime) ));\n\n\tcol = mix( col, colb, smoothstep(0.45,0.451,n) );\n\n\t\n\tcol *= pow( 16.0*uv.x*(1.0-uv.x)*uv.y*(1.0-uv.y), 0.1 );\n\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}