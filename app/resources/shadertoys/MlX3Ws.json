{"Shader":{"ver":"0.1","info":{"id":"MlX3Ws","date":"1426117299","viewed":759,"name":"Silly Blob Shader","username":"Craxic","description":"Just a simple blob shader. I remember reading about this technique in a DirectX SDK many years ago. I thought it was awesome and I still do!","likes":7,"published":3,"flags":0,"tags":["blob"],"hasliked":0},"renderpass":[{"inputs":[{"id":24,"src":"\/presets\/cube02_0.jpg","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ This is the cut off point for the specular. \n#define SPECULAR_THRESHOLD 0.5\n\n\/\/ This gives the specular its soft edge. Lower = softer\n#define SPECULAR_PRE_CLAMP_MULTIPLIER 50.0\n\n\/\/ The specular will never be brighter than this.\n#define SPECULAR_MULTIPLIER 0.5\n\n\/\/ If this gets smaller, the white specular gets \n\/\/ bigger.\n#define SPECULAR_POWER 5.0\n\n\/\/ Amount of reflection at edge of blob\n\/\/ Simulates fresnel I guess.\n#define MAX_REFLECTION 0.95\n\n\/\/ Amount of reflection at center of blob. \n\/\/ Simulates fresnel I guess.\n#define MIN_REFLECTION 0.0\n\n#define REFLECTION_POWER 1.5\n\n\/\/ Circles are generated by calculating the \n\/\/ distance from the pixel to the center of \n\/\/ the circle. This is then normalized to [0-1]\n\/\/ with 0 being at the EDGE and 1 being at the\n\/\/ center. Circle fall represents the threshold\n\/\/ value that defines the boundaries of the goo\n\/\/ The name just comes from the fact that we're\n\/\/ making the \"heightmap\" fall down this many \n\/\/ units.\n#define CIRCLE_FALL 0.6\n\n\/\/ This is the height of each blob. Too much and \n\/\/ you'll lose the soft edges.\n#define CIRCLE_HEIGHT 37.0\n#define CIRCLE_RADIUS (iResolution.x \/ 10.0)\n#define CIRCLE_DISTANCE (iResolution.x \/ 5.0)\n#define CIRCLE_COLOUR_A vec3(1.2, 0.4, 0.2)\n#define CIRCLE_COLOUR_B vec3(1.0, 0.7, 0.3)\n\nvec4 sampleOneCircle(vec2 circlePos, vec2 fragPos, vec3 colour)\n{\n    float circle = distance(fragPos, circlePos);\n    circle = circle \/ CIRCLE_RADIUS;\n    circle *= circle;\n    circle = max(0.0, min(1.0, 1.0 - circle));\n    circle *= circle;\n    return vec4(colour, circle);\n}\n\nvec2 noise(int xInt, float time)\n{\n    float t = time;\n    float x = float(xInt + 1);\n    \n    float d = sin(t * x * 0.2852231);\n    float r = t * (x * 0.123652);\n    \n    return vec2(cos(r) * d, sin(r) * d);\n}\n\nvec4 sampleOneMovingCircle(int i, vec2 fragPos)\n{\n    vec2 n = noise(i, iGlobalTime) * CIRCLE_DISTANCE;\n    float x = iResolution.x \/ 2.0 + n.x;\n    float y = iResolution.y \/ 2.0 + n.y;\n    vec2 n2 = noise(i * 3, iGlobalTime \/ 10.0);\n    vec3 col = CIRCLE_COLOUR_A + n2.x * (CIRCLE_COLOUR_B - CIRCLE_COLOUR_A);\n    return sampleOneCircle(vec2(x, y), fragPos, col);\n}\n\n\/\/ return[0].r = Red colour of circle.\n\/\/ return[0].g = Green colour of circle.\n\/\/ return[0].b = Blue colour of circle.\n\/\/ return[0].a = Height of circle (0 to 1)\n\/\/ return[1].xy = fragCoord\n\/\/ return[1].z = Height of circle (0 to CIRCLE_HEIGHT)\nmat4 sampleCircle(vec2 fragCoord)\n{\n    float circle = 0.0;\n    vec4 circleColour = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    for (int i = 0; i < 10; i++) {\n        vec4 c = sampleOneMovingCircle(i, fragCoord);\n        circle = circle * (1.0 - c.a) + c.a;\n        circleColour += vec4(c.rgb * c.a, c.a);\n    }\n    circleColour \/= circleColour.a;\n    \n    circle -= CIRCLE_FALL;\n    circle \/= (1.0 - CIRCLE_FALL);\n    circle = sqrt(circle + 0.3) - 0.25;\n    circle = clamp(circle, 0.0, 1.0);\n    \n    mat4 retn;\n    retn[0] = vec4(circleColour.rgb, circle);\n    retn[1] = vec4(fragCoord, circle * CIRCLE_HEIGHT, 0.0);\n    return retn;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat4 circle = sampleCircle(fragCoord);\n    float circleMask = max(0.0, min(1.0, (circle[1].z)));\n    \n    vec3 circleTL = sampleCircle(fragCoord + vec2(-0.5, 0.0))[1].xyz;\n    vec3 circleTR = sampleCircle(fragCoord + vec2(0.0, 0.0))[1].xyz;\n    vec3 circleBL = sampleCircle(fragCoord + vec2(-0.5, -0.5))[1].xyz;\n    vec3 circleBR = sampleCircle(fragCoord + vec2(0.0, -0.5))[1].xyz;\n    \n    vec3 xgrad = (circleTL - circleTR);\n    vec3 ygrad = (circleTL - circleBL);\n    vec3 normal_bias = vec3(1.0,1.0,1.0);\n    vec3 normal = -cross(xgrad * normal_bias, ygrad * normal_bias);\n    normal = normalize(normal);\n    \n    vec3 lightDir = normalize(vec3(cos(iGlobalTime), sin(iGlobalTime), 0.1));\n    \n    \/\/ I wasn't sure how this was done, so Google to the rescue! \n   \t\/\/ https:\/\/en.wikibooks.org\/wiki\/GLSL_Programming\/GLUT\/Specular_Highlights\n    \/\/ I've noticed that sometimes I get black lines here though...\n    float specularReflectionRaw;\n    if (dot(normal, lightDir) < 0.0) {\n        specularReflectionRaw = 0.0;\n    } else {\n        specularReflectionRaw = pow(dot(reflect(-lightDir, normal), vec3(0.0, 0.0, 1.0)), SPECULAR_POWER);\n    }\n    float specularReflection = specularReflectionRaw;\n    specularReflection -= SPECULAR_THRESHOLD;\n    specularReflection *= SPECULAR_PRE_CLAMP_MULTIPLIER;\n    specularReflection = clamp(specularReflection, 0.0, 1.0);\n    vec4 spec = vec4(1, 1, 1, 0.0) * specularReflection * SPECULAR_MULTIPLIER;\n\n    \/\/ Sample the cube map!\n    vec4 tex = textureCube(iChannel0, normal);\n    \n    \/\/ Get the colour of the blob as a vec4.\n    vec4 col = vec4(circle[0].rgb, 1.0);\n    \n    \/\/ SSS Multiplier. \n    float lighting = dot(lightDir, normal);\n    float sss = (lighting * 0.3 + 0.7) * (1.0 - circle[0].a * 0.6);\n    \n    \/\/ k mixes texure and a solid colour\n    \/\/ If k is 0.0, then the texture is a solid colour.\n    float k = MIN_REFLECTION + pow(1.0 - circle[0].a, REFLECTION_POWER) * (MAX_REFLECTION - MIN_REFLECTION);\n    float ik = 1.0 - k; \/\/ \"Inverse\" of k, just to save letters!\n    col = (tex * k + vec4(ik, ik, ik, ik) * sss) * col;\n    \n    \/\/ Calculate final output\n    fragColor = (spec + col) * circleMask;\n\tfragColor.a = 1.0;\n    \/\/ fragColor = vec4(h, h, h, 1.0);\n    \n    \/\/ fragColor = vec4(normal, 1.0);\n}","name":"","description":"","type":"image"}]}}