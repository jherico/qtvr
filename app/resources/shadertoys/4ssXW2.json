{"Shader":{"ver":"0.1","info":{"id":"4ssXW2","date":"1407004040","viewed":3782,"name":"Alps","username":"Dave_Hoskins","description":"Uses a ridged fractal noise with corrosion effects for higher altitudes. I tried to remove as many artefacts as possible and still have a long draw distance. Now includes fractal wind. <img src=\"\/img\/emoticonHappy.png\"\/>","likes":68,"published":3,"flags":8,"tags":["alps"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Alps.\n\/\/ by David Hoskins.\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ https:\/\/www.shadertoy.com\/view\/4ssXW2\n\/\/ Uses a ridged fractal noise with corrosion effects for higher altitudes.\n\n\/\/#define STEREO   \/\/ RED left eye.\n\/\/#define SHADOWS  \/\/ fake shadows.\n#define MOD3 vec3(.0631,.07369,.08787)\n\/\/#define MOD4 vec4(.0631,.07369,.08787, .09987)\nvec3 sunLight  = normalize( vec3(  -0.2, 0.2,  -1.0 ) );\nvec3 sunColour = vec3(1.0, .88, .75);\nfloat specular = 0.0;\nvec3 cameraPos;\nfloat ambient;\nconst vec2 add = vec2(1.0,0.0);\n\n\/\/ This peturbs the fractal positions for each iteration down...\n\/\/ Helps make nice twisted landscapes...\nconst mat2 rotate2D = mat2(1.6623, 1.850, -1.7131, 1.4623);\n\n\/\/--------------------------------------------------------------------------\n\/\/ Noise functions...\n\/\/----------------------------------------------------------------------------------------\nfloat Hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract(p3.x * p3.y * p3.z);\n}\n\/\/--------------------------------------------------------------------------\nfloat Noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(1.5-f)*2.0;\n    \n    float res = mix(mix( Hash12(p), Hash12(p + add.xy),f.x),\n                    mix( Hash12(p + add.yx), Hash12(p + add.xx),f.x),f.y);\n    return res;\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 NoiseD( in vec2 x )\n{\n\tx+=4.2;\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    vec2 u = f*f*(1.5-f)*2.0;;\n    \n    float a = Hash12(p);\n    float b = Hash12(p + add.xy);\n    float c = Hash12(p + add.yx);\n    float d = Hash12(p + add.xx);\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(f-1.0)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nfloat Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(1.5-f)*2.0;\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D( iChannel0, (uv+ 0.5)\/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n#define WARP  .15\n#define SCALE  .0023\n#define HEIGHT 55.\n#define LACUNARITY 2.13\n\/\/--------------------------------------------------------------------------\n\/\/ Low-def version for ray-marching through the height field...\nfloat Terrain( in vec2 p)\n{\n\tp *= SCALE;\n\tfloat sum = 0.0;\n\tfloat freq = 1.;\n\tfloat amp = 3.5;\n\tvec2 dsum = vec2(0,0);\n\tfor(int i=0; i < 5; i++)\n\t{\n\t\tvec3 n = NoiseD(p + (WARP * dsum * freq));\n\t\tsum += amp * (1.0 - abs(n.x-.5)*2.0);\n\t\tdsum += amp * n.yz * -n.x;\n\t\tfreq *= LACUNARITY;\n\t\tamp = amp*.4 * min(sum*.22, 1.0);\n\t\tp = rotate2D * p;\n\t}\n\treturn sum * HEIGHT;\t\n}\n\n\/\/--------------------------------------------------------------------------\n\/\/ High-def version only used for grabbing normal information....\nfloat Terrain2( in vec2 p, in float d)\n{\n    int stop = 1+int(9.0-d*.000004);\n\tp *= SCALE;\n\tfloat sum = 0.0;\n\tfloat freq = 1.;\n\tfloat amp = 3.5;\n\tvec2 dsum = vec2(0,0);\n    vec3 n;\n\tfor(int i=0; i < 9; i++)\n\t{\n        if (i > stop) break;\n\t\tn = NoiseD(p + (WARP * dsum * freq));\n\t\tsum += amp * (1.0 - abs(n.x-.5)*2.0);\n\t\tdsum += amp * n.yz * -n.x;\n\t\tfreq *= LACUNARITY;\n\t\tamp = amp*.4 * min(sum*.22, 1.0);\n        sum += n.x\/(222.5+dot(dsum, dsum));\n\t\tp = rotate2D * p;\n\t}\n\treturn sum * HEIGHT;\n}\n\n\/\/ Low detailed camera version... \nfloat TerrainCam( in vec2 p)\n{\n    \n\tp *= SCALE;\n\tfloat sum = 0.0;\n\tfloat freq = 1.;\n\tfloat amp = 3.5;\n\tvec2 dsum = vec2(0,0);\n\tfor(int i=0; i < 2; i++)\n\t{\n\t\tvec3 n = NoiseD(p + (WARP * dsum * freq));\n\t\tsum += amp * (1.0 - abs(n.x-.5)*2.0);\n\t\tdsum += amp * n.yz * -n.x;\n\t\tfreq *= LACUNARITY;\n\t\tamp = amp*.4 * min(sum*.22, 1.0);\n\t\tp = rotate2D * p;\n\t}\n\treturn sum * HEIGHT;\n\t\n}\n\nfloat FBM( vec3 p )\n{\n    \n    p *= .015;\n    p.xz *= .3;\n    \/\/p.zy -= iGlobalTime * .04;\n    \n    float f;\n\tf  = 0.5000\t * Noise(p); p = p * 3.02; \/\/p.y -= gTime*.2;\n\tf += 0.2500\t * Noise(p); p = p * 3.03; \/\/p.y += gTime*.06;\n\tf += 0.1250\t * Noise(p); p = p * 4.01;\n    f += 0.0625\t * Noise(p); p = p * 4.023;\n    \/\/f += 0.03125 * Noise(p);\n    return f;\n}\n\n\n\/\/--------------------------------------------------------------------------\n\/\/ Map to lower resolution for height field mapping for Scene function...\nfloat Map(in vec3 p)\n{\n\tfloat h = Terrain(p.xz);\n    return p.y - h;\n}\n\n\/\/--------------------------------------------------------------------------\nfloat MapClouds(vec3 p)\n{\n\tfloat h = FBM(p)*1.0;\n\treturn (-h+.6);\/\/ + (p.y)*.0002);\n}\n\/\/--------------------------------------------------------------------------\n\/\/ Grab all sky information for a given ray from camera\nvec3 GetSky(in vec3 rd)\n{\n\tfloat v = pow(1.0-max(rd.y,0.0),10.);\n\tvec3  sky = vec3(v*sunColour.x*0.42+.04, v*sunColour.y*0.4+0.09, v*sunColour.z*0.4+.17);\n\treturn sky;\n}\n\n\/\/--------------------------------------------------------------------------\n\/\/ Merge mountains into the sky background for correct disappearance...\nvec3 ApplyFog( in vec3  rgb, in float dis, in vec3 dir)\n{\n\treturn mix(GetSky(dir), rgb, exp(-.000001*dis) );\n}\n\n\/\/--------------------------------------------------------------------------\n\/\/ Calculate sun light...\nvoid DoLighting(inout vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float dis)\n{\n    float h = dot(sunLight,normal);\n\n#ifdef SHADOWS\n   \tvec3  eps = vec3(1.0,0.0,0.0);\n    vec3 nor;\n\tnor.x = Terrain(pos.xz-eps.xy) - Terrain(pos.xz+eps.xy);\n    nor.y = 1.0*eps.x;\n    nor.z = Terrain(pos.xz-eps.yx) - Terrain(pos.xz+eps.yx);\n\tnor = normalize(nor);\n\tfloat shad = clamp(1.0*dot(nor,sunLight), 0.0, 1.0 );\n    float c = max(h, 0.0) * shad;\n#else\n    float c = max(h, 0.0);\n#endif    \n\tvec3 R = reflect(sunLight, normal);\n\tmat = mat * sunColour * c * vec3(.9, .9, 1.0) +  GetSky(R)*ambient;\n\t\/\/ Specular...\n\tif (h > 0.0)\n\t{\n\t\tfloat specAmount = pow( max(dot(R, normalize(eyeDir)), 0.0), 34.0)*specular;\n\t\tmat += sunColour * specAmount;\n\t}\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 TerrainColour(vec3 pos, vec3 normal, float dis)\n{\n\tvec3 mat;\n\tspecular = .0;\n\tambient = .4 * abs(normal.y);\n\tvec3 dir = normalize(pos-cameraPos);\n\t\n\tfloat disSqrd = dis * dis;\/\/ Squaring it gives better distance scales.\n\n\tfloat f = clamp(Noise(pos.xz*.001), 0.0,1.0);\/\/*10.8;\n\tf *= Noise(pos.zx*.2+normal.xz*1.5);\n\t\/\/f *= .5;\n\tmat = mix(vec3(.1), vec3(.1, .07, .01), f);\n\n\t\/\/ Snow...\n\tif (pos.y > 75.0 && normal.y > .2)\n\t{\n\t\tfloat snow = smoothstep(0.0, 1.0, (pos.y - 75.0 - Noise(pos.xz * .3)*Noise(pos.xz * .027)*83.0) * 0.2 * (normal.y));\n\t\tmat = mix(mat, vec3(.8,.9,1.0), min(snow, 1.0));\n\t\tspecular += snow*.7;\n\t\tambient+=snow *.05;\n\t}\n\n\tDoLighting(mat, pos, normal,dir, disSqrd);\n\t\n\tmat = ApplyFog(mat, disSqrd, dir);\n\treturn mat;\n}\n\n\/\/--------------------------------------------------------------------------\nfloat BinarySubdivision(in vec3 rO, in vec3 rD, vec2 dist)\n{\n\t\/\/ Home in on the surface by dividing by two and split...\n\tfor (int n = 0; n < 6; n++)\n\t{\n\t\tfloat halfwayT = (dist.x + dist.y) * .5;\n\t\tvec3 p = rO + halfwayT*rD;\n\t\tMap(p) < .5 ? dist.x = halfwayT : dist.y = halfwayT;\n\t}\n\treturn dist.x;\n}\n\n\/\/--------------------------------------------------------------------------\nbool Scene(in vec3 rO, in vec3 rD, in vec2 uv, out float resT, out vec2 cloud)\n{\n    float t = 10.0 + Hash12(uv*3333.0)* 13.0;\n\tfloat oldT = 0.0;\n\tfloat delta = 0.0;\n\tbool fin = false;\n\tvec2 distances;\n    vec2 shade = cloud = vec2(0.0, 0.0);\n    vec3 p = vec3(0.0);\n\tfor( int j=0; j< 105; j++ )\n\t{\n\t\tif (p.y > 650.0 || t > 1300.0) break;\n\t\tp = rO + t*rD;\n\t\tfloat h = Map(p); \/\/ ...Get this positions height mapping.\n\t\t\/\/ Are we inside, and close enough to fudge a hit?...\n\t\tif( h < .5)\n\t\t{\n\t\t\tfin = true;\n\t\t\tdistances = vec2(t, oldT);\n\t\t\tbreak;\n\t\t}\n        \t\t\n\t\tdelta = clamp(0.5*h, .002, 20.0) + (t*0.004);\n\t\toldT = t;\n\t\tt += delta;\n\n   \t\th = MapClouds(p);\n        \n\t\tshade.y = max(-h, 0.0); \n\t\tshade.x = smoothstep(.03, 1.5, shade.y);\n        \/\/shade.x = shade.x*shade.x;\n\t\tcloud += shade * (1.0 - cloud.y);\n\n\n\t}\n\tif (fin) resT = BinarySubdivision(rO, rD, distances);\n    \n    cloud.x = 1.0-(cloud.x*5.3);\/\/cloud.x = min(pow(max(cloud.x, 0.05), .3), 1.0);\n \n\n\treturn fin;\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 CameraPath( float t )\n{\n\tfloat m = 1.0+(iMouse.x\/iResolution.x)*300.0;\n\tt =((iGlobalTime*2.0)+m+4005.0)*.004 + t;\n    vec2 p = 1500.0*vec2( sin(4.5*t), cos(4.0*t) );\n\treturn vec3(-4800.0+p.x, 0.6, -200.0+p.y);\n}\n\n\/\/--------------------------------------------------------------------------\n\/\/ Some would say, most of the magic is done in post! :D\nvec3 PostEffects(vec3 rgb, vec2 uv)\n{\n\n    rgb = mix( rgb, vec3(dot(rgb,vec3(0.333))), -1. );\n    rgb = sqrt(rgb);\n   \trgb *= .5+0.5*pow(70.0*uv.x*(uv.y-.12)*(1.0-uv.x)*(.88-uv.y), 0.2 );\n    \/\/rgb = clamp(rgb+Hash12(rgb.rb+uv*iGlobalTime)*.1, 0.0, 1.0);\n\treturn rgb;\n}\n\n\/\/--------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord.xy \/ iResolution.xy;\n\tvec2 uv = (-1.0 + 2.0*xy) * vec2(iResolution.x\/iResolution.y,1.0);\n\tvec3 camTar;\n    \n    if (xy.y < .12 || xy.y >= .88)\n\t{\n\t\t\/\/ Top and bottom cine-crop - what a waste! :)\n\t\tfragColor=vec4(vec4(0.0));\n\t\treturn;\n\t}\n\n\t#ifdef STEREO\n\tfloat isCyan = mod(fragCoord.x + mod(fragCoord.y,2.0),2.0);\n\t#endif\n\n\t\/\/ Use several forward heights, of decreasing influence with distance from the camera.\n\n\tcameraPos.xz = CameraPath(0.0).xz;\n\tcamTar.xz\t = CameraPath(.05).xz;\n\tcamTar.y = cameraPos.y = TerrainCam(CameraPath(0.0).xz) + 85.0;\n    cameraPos.y +=  smoothstep(5.0, 0.0, iGlobalTime)*180.0;\n    camTar.y -= camTar.y * .005;\n\t\n\tfloat roll = 0.2*sin(iGlobalTime*.3);\n\tvec3 cw = normalize(camTar-cameraPos);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = (cross(cw,cp));\n\tvec3 cv = (cross(cu,cw));\n\tvec3 rd = normalize( uv.x*cu + uv.y*cv + 1.4*cw );\n\n\t#ifdef STEREO\n\tcameraPos += 6.*cu*isCyan; \/\/ move camera to the right - the rd vector is still good\n\t#endif\n\n\tvec3 col;\n\tfloat distance;\n    vec2 cloud;\n\tif( !Scene(cameraPos,rd, uv, distance, cloud) )\n\t{\n\t\t\/\/ Missed scene, now just get the sky value...\n\t\tcol = GetSky(rd);\n        float sunAmount = max( dot( rd, sunLight), 0.0 );\n       \tcol = col + sunColour * pow(sunAmount, 8.0)*.8;\n\t\tcol = col+ sunColour * min(pow(sunAmount, 800.0), .4);\n\t} \n\telse\n\t{\n\t\t\/\/ Get world coordinate of landscape...\n\t\tvec3 pos = cameraPos + distance * rd;\n\t\t\/\/ Get normal from sampling the high definition height map\n\t\t\/\/ Use the distance to sample larger gaps to help stop aliasing...\n        float d = distance*distance;\n\t\tfloat p = min(4.0, .0001+.00002 * d);\n        \n\t\tvec3 nor  \t= vec3(0.0,\t\t    Terrain2(pos.xz, d), 0.0);\n\t\tvec3 v2\t\t= nor-vec3(p,\t\tTerrain2(pos.xz+vec2(p,0.0), d), 0.0);\n\t\tvec3 v3\t\t= nor-vec3(0.0,\t\tTerrain2(pos.xz+vec2(0.0,-p), d), -p);\n\t\tnor = cross(v2, v3);\n\t\tnor = normalize(nor);\n\n\t\t\/\/ Get the colour using all available data...\n\t\tcol = TerrainColour(pos, nor, distance);\n\t}\n    float bri = pow(max(dot(rd, sunLight), 0.0), 24.0)*2.0;\n    bri = ((cloud.y)) * bri;\n    col = mix(col, vec3(min(bri+cloud.x * vec3(1.,.95, .9), 1.0)), min(cloud.y*(bri+1.0), 1.0));\n\n\tcol = PostEffects(min(col, 1.0), xy);\n\t\n\t#ifdef STEREO\t\n\tcol *= vec3( isCyan, 1.0-isCyan, 1.0-isCyan );\t\n\t#endif\n\t\n\tfragColor=vec4(col*smoothstep(0.0, 2.0, iGlobalTime) ,1.0);\n}\n\n\/\/--------------------------------------------------------------------------","name":"","description":"","type":"image"},{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\nvec2 Hash( vec2 n)\n{\n\tvec4 p = texture2D( iChannel0, n*vec2(.78271, .32837), -100.0 );\n    return (p.xy + p.zw) * .5; \n}\n\n\/\/--------------------------------------------------------------------------\nvec2 Noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 res = mix(mix( Hash(p + 0.0), Hash(p + vec2(1.0, 0.0)),f.x),\n                   mix( Hash(p + vec2(0.0, 1.0) ), Hash(p + vec2(1.0, 1.0)),f.x),f.y);\n    return res-.5;\n}\n\n\/\/--------------------------------------------------------------------------\nvec2 FBM( vec2 p )\n{\n    vec2 f;\n\tf  = 0.5000\t * Noise(p); p = p * 2.32;\n\tf += 0.2500  * Noise(p); p = p * 2.23;\n\tf += 0.1250  * Noise(p); p = p * 2.31;\n    f += 0.0625  * Noise(p); p = p * 2.28;\n    f += 0.03125 * Noise(p);\n    return f;\n}\n\n\/\/--------------------------------------------------------------------------\nvec2 Wind(float n)\n{\n    vec2 pos = vec2(n * (162.017331), n * (132.066927));\n    vec2 vol = Noise(vec2(n*23.131, -n*42.13254))*1.0 + 1.0;\n    \n    vec2 noise = vec2(FBM(pos*33.313))* vol.x *.5 + vec2(FBM(pos*4.519)) * vol.y;\n    \n\treturn noise;\n}\n\n\/\/--------------------------------------------------------------------------\nvec2 mainSound(float time)\n{\n    vec2 audio = Wind(time*.1) * 6.0;\n    return clamp(audio, -1.0, 1.0) * (smoothstep(0.0, 2.0, time) * smoothstep(60.0, 50.0, time));;\n}","name":"","description":"","type":"sound"}]}}