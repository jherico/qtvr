{"Shader":{"ver":"0.1","info":{"id":"XsjXzt","date":"1414983953","viewed":1026,"name":"Sincos approximation","username":"iq","description":"Improving boundary values for cos (and sin) approximation with some extra normalization. The magic number is sqrt(2)\u00b78\/11. True sin\/cos in yellow, approximate sin\/cos (with and without normalization) in red.","likes":5,"published":3,"flags":0,"tags":["2d","approximation","cos","sincos","trigonometry"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\/\/ When approximating sine and cosine with a cubic polynomial as in\n\/\/ \n\/\/ float f = abs(fract(x)-0.5);\n\/\/ return -1.0 + f*f*(24.0-32.0*f;\n\/\/\n\/\/ the modulo of a rotating vector sqrt(sin\u00b2(x) + cos\u00b2(x)) is not 1, but \n\/\/ m(x) = sqrt( 1 - 12x^2 + 64x^3 + 192x^4 - 1536x^5 + 2048x^6). This means it\n\/\/ gets shorter on its way. The minimum peaks halfway the approximation, at x=1\/8,\n\/\/ where h(x) = 11\u00b7sqrt(2)\/16.\n\/\/\n\/\/ This means we can improve the results of the smoothstep(fract())) approximation\n\/\/ by scaling it by a linear appoximation of 1\/m(x). This is the second term in the\n\/\/ product in line 34 (and 45).\n\/\/\n\/\/ In this shader, real cos(x) in yellow, approximate cosine with and without \n\/\/ normalization approximation in red.\n\/\/\n\/\/ Note, this approximation strategy is a pure exercise, there's no evidence that\n\/\/ it is any faster than the native cos() implementation of the GPU (it's actually\n\/\/ most probably slower)\n\n#if 0\n\nvec2 mySinCos( in float x )\n{\n    vec2  f = abs(fract(x-vec2(0.25,0.0))-0.5);\n    float h = abs(fract(x*4.0)-0.5);\n    \n    \/\/     approx sin\/cos             * approx renormalization (sqrt(2)\u00b78\/11)\n    return (-1.0 + f*f*(24.0-32.0*f)) * (1.028519 - 0.0570379*h); \n}\n\n#else\n\nvec2 mySinCos( in float x )\n{\n    vec2  f = abs(fract(x-vec2(0.25,0.0))-0.5);\n    float h = abs(fract(4.0*x)-0.5);\n    \n    vec2 res = -1.0 + f*f*(24.0-32.0*f);\n    if( mod(floor(iGlobalTime),2.0)>0.5 ) res *= (1.028519 - 0.0570379*h);\n\n    return res;\n}\n\n#endif    \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2  p = fragCoord.xy \/ iResolution.x;\n    float m = 0.5*iResolution.y\/iResolution.x;\n    \n    vec3 col = vec3( 0.25 );\n    \n    \/\/ axis    \n    float d = abs( p.y - m );\n    col = mix( col, vec3(0.0,0.0,0.0), 1.0 - smoothstep( 0.0, 1.0\/iResolution.x, d ) );\n\n    \/\/ cosine\n    float y = m + m*sin( 6.2831*p.x );\n    d = abs( p.y - y );\n    col = mix( col, vec3(1.0,1.0,0.0), 1.0 - smoothstep( 0.0, 2.0\/iResolution.x, d ) );\n        \n    \/\/ approx cosines (with and without normalization)    \n    y = m + m*mySinCos( p.x ).x;\n    d = abs( p.y - y );\n    col = mix( col, vec3(1.0,0.0,0.0), 1.0 - smoothstep( 0.0, 2.0\/iResolution.x, d ) );\n    \n\n    \/\/ circle, and approx circles (with and without normalization)    \n    float d1 = 1.0;\n    float d2 = 1.0;\n    for( int i=0; i<256; i++ )\n    {\n        float h = float(i)\/256.0;\n        vec2 x1 = vec2(0.5,m) + 0.5*m*mySinCos( h );\n        d1 = min( d1, dot(x1-p,x1-p) );\n        vec2 x2 = vec2(0.5,m) + 0.5*m*vec2( sin(6.2831*h), cos(6.2831*h) );\n        d2 = min( d2, dot(x2-p,x2-p) );\n    }\n    col = mix( col, vec3(1.0,1.0,0.0), 1.0 - smoothstep( 0.0, 2.0\/iResolution.x, sqrt(d2) ) );\n    col = mix( col, vec3(1.0,0.0,0.0), 1.0 - smoothstep( 0.0, 2.0\/iResolution.x, sqrt(d1) ) );\n\n    fragColor = vec4( col, 1.0 );\n}\n","name":"","description":"","type":"image"}]}}