{"Shader":{"ver":"0.1","info":{"id":"llBGW1","date":"1428514740","viewed":815,"name":"First ray-marching fun","username":"archee","description":"I never made any demo scene release, that uses ray-marching. (preferred immediate ray casting)<br\/>Let's make up the fun that I had missed out.","likes":8,"published":3,"flags":0,"tags":["raymarching"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/#define AUTOCAM\n\nvec3 campos;\nvec3 dir;\nfloat time;\n\n\/\/ rotate camera\n#define pee (acos(0.0)*2.0)\n\nfloat anglex,angley; \/\/ camera\n\n\nvec3 rotatex(vec3 v,float anglex)\n{\n\tfloat t;\n\tt =   v.y*cos(anglex) - v.z*sin(anglex);\n\tv.z = v.z*cos(anglex) + v.y*sin(anglex);\n\tv.y = t;\n\treturn v;\n}\n\nvec3 rotcam(vec3 v)\n{\n\tfloat t;\n\tv = rotatex(v,anglex);\n\t\n\tt = v.x * cos(angley) - v.z*sin(angley);\n\tv.z = v.z*cos(angley) + v.x*sin(angley);\n\tv.x = t;\n\treturn v;\n}\n\n\nvec3 pos;\nfloat mat;\n\nfloat blob()\n{\n    vec3 p = pos;\n    float f=0.0;\n    f += 1.0\/dot(p,p);\n    p -= vec3(2.0+sin(time)*2.0,0.0,0.0);\n    f += 1.0\/dot(p,p);\n    p = pos;\n    p -= vec3(2.0,2.0+cos(time*1.2)*2.0,0.0);\n    f += 1.0\/dot(p,p);\n    return sqrt(1.0\/f)-1.0;\n}\n\nfloat maxfade(float a,float b)\n{\n    return max( (a+b)*0.5, max(a,b-0.2));\n}\n\nfloat asteroid()\n{\n    vec3 p = pos;\n    float d=0.0;\n    \n    float rad = 1.0;\n    \n    p = rotatex(p,time);\n    \n    rad += clamp(sin(p.x*8.0)*2.0,-1.0,1.0)*0.05;\n    rad += clamp(sin(p.y*8.0)*2.0,-1.0,1.0)*0.05;\n    rad += clamp(sin(p.z*8.0)*2.0,-1.0,1.0)*0.05;\n    d = (length(p)-rad)*0.5;\n    \n    \n    return d;\n}\n\n\nfloat cube()\n{\n    float d;\n    vec3 p = rotatex(pos,time); \/\/ cube\n    vec3 p2 = p;\n\/\/    p=  (fract(p\/8.0+0.5)-0.5)*8.0;\n\/\/    p.y = pos.y;\n    p = abs(p);\n    p = max(p-vec3(1.0),vec3(0.0));\n    d =  length(p)-0.2;\n    d = maxfade( d,   0.8+sin(time*3.0)*0.0-length(p2.xy) );\n    d = max( d,   0.7-length(p2.xz) );\n    d = max( d,   0.7-length(p2.yz) );\n    return d;\n}\n\nfloat toroid()\n{\n    float d=0.0;\n    vec3 p = pos;\n\/\/    p=  (fract(p\/8.0+0.5)-0.5)*8.0;\n    \n    vec2 tp;\n    tp = vec2(p.y\/2.0,(dot(p.xz,p.xz))-1.0);\n\/\/    return (length(tp)-0.4)\/1.0;\n    d += 1.0\/(length(tp));\n    \n    \n    p.x += sin(time)*2.0+1.0;\n    p.y += cos(time*1.2)*1.0+0.5;\n    tp = vec2(p.z,length(p.xy)-1.0);\n    d += 1.0\/(length(tp));\n    return (1.0\/d-0.3)*0.5;\n}\n\nfloat dist2(float scene)\n{\n    scene = mod(scene,4.0);\n    if (scene==0.0) return cube();\n    if (scene==1.0) return toroid();\n    if (scene==2.0) return asteroid();\n\/\/    if (scene==3.0) \n        return blob();\n}\n\nfloat dist()\n{\n\/*    float d = mix(asteroid(),cube(),sin(time)*0.5+0.5);\n\/\/    d = cube();\n    d = toroid();*\/\n    \n    float tscene = (time\/8.0);\n    float iscene = floor(tscene);\n    float d = mix( dist2(iscene), dist2(iscene+1.0), max(fract(tscene)*3.0-2.0,0.0));\n    \n    d = min(d,pos.y+3.0);\n    return d;\n}\n\n\nfloat dist2(vec3 p)\n{\n    pos = p;\n    return dist();\n}\n\nvec3 calcnormal(vec3 pos)\n{\n    float dd = 0.001;\n    float mv = dist2(pos);\n    return normalize(vec3( dist2(pos+vec3(dd,0.0,0.0))-mv, dist2(pos+vec3(0.0,dd,0.0))-mv, dist2(pos+vec3(0.0,0.0,dd))-mv));\n}\n\nvec3  trace_normal()\n{\n    float st = 0.5;\n    pos = campos;\n    mat = 0.0;\n    \n    float lastst=0.0;\n    for(int p=0;p<250;p++)\n    {\n    \tst = dist();\n        if (st<0.002) \n        {\n            return calcnormal(pos);\n        }\n        if (length(pos)>20.0) return vec3(0.0);\n    \tpos += dir*st;\n        lastst = st;\n    }\n    return vec3(0.0);\n}\n\nfloat trace_shadow()\n{\n    float lastst=0.0;\n    float st = 0.02;\n    pos += dir*st;\n    float travel = st\/99.0;\n    float shadow = 1.0;\n    for(int p=0;p<250;p++)\n    {\n    \tst = dist();\n        shadow = min(shadow,st\/travel*90.0);\n        if (st<0.002) \n        {\n            return 0.0;\n        }\n        if (length(pos)>20.0) return shadow;\n    \tpos += dir*st;\n        travel += st;\n        lastst = st;\n    }\n    return shadow;\n    \n}\n\nvec3 sundir = normalize(vec3(0.7,1.0,0.2));\n\nvec3 backGround(vec3 dir)\n{\n    return mix(vec3(0.3,0.2,0.1),vec3(0.6,0.8,1.0)*0.5,clamp(dir.y*10.0,0.0,1.0));\n}\n\nvec3 trace()\n{\n    vec3 norm = trace_normal();\n    vec3 ambientLight = vec3(0.6,0.8,1.0);\n    vec3 sunLight = vec3(1.0,0.8,0.6);\n\n    if (length(norm)==0.0)\n    {\n        return backGround(dir);\n    }\n    \n    vec3 refdir = reflect(dir,norm);\n    float f = 1.0-max(-dot(dir,norm),0.0);\n    float fresnel = 0.1+0.9*f*f*f*f*f;\n    \n    float spec = pow(max(dot(sundir,refdir),0.0),8.0)*4.0;\n    \n    dir = sundir;\n\tfloat shadow = trace_shadow();                    \n    \n   \n    \n    return (mix(ambientLight * (norm.y*0.5+0.5) + shadow*(sunLight*max(dot(norm,dir),0.0)),backGround(refdir)+shadow * vec3(spec),fresnel  ))*0.7;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ set camera\n    if (iMouse.x!=0.0)\n    {\n    anglex = ( iMouse.y\/iResolution.y*-0.6+0.3)*pee*1.2; \/\/ mouse cam\n    angley = -iMouse.x\/iResolution.x*pee*2.0;\n    }\n    else\n    {\n    anglex = sin(iGlobalTime*0.3)*-0.6+0.6;\n    angley = pee + sin(iGlobalTime*0.2);\n    }\n\n    \n    time = iGlobalTime+2.0;\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\tcampos = vec3(0,0,0);\n\tdir = vec3(uv*2.0-1.0,1);\n\tdir.y *= 9.0\/16.0; \/\/ wide screen\n\t\n\tdir = normalize(rotcam(dir));\n\tcampos -= rotcam(vec3(0,0,4.0 + 0.0*exp(iGlobalTime*-0.8))); \/\/ back up from subject\n    \n \n    fragColor = vec4(trace(),0.0);\n    \n    \n\/\/    fragColor = vec4(dot(pos-campos,dir)*vec3(0.1,0.01,0.001),0);\n}","name":"","description":"","type":"image"}]}}