{"Shader":{"ver":"0.1","info":{"id":"4l2XWK","date":"1446729264","viewed":733,"name":"Bumped Sinusoidal Warp","username":"Shane","description":"Point lit, bump mapped, sinusoidal warp.","likes":37,"published":3,"flags":0,"tags":["specular","warp","bump","sinusoidal"],"hasliked":0},"renderpass":[{"inputs":[{"id":3,"src":"\/presets\/tex02.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/*\n\tBumped Sinusoidal Warp\n\t----------------------\n\n\tSinusoidal planar deformation, or the 2D sine warp effect to people \n\tlike me. The effect has been around for years, and there are\n\tcountless examples on the net. IQ's \"Sculpture III\" is basically a \n\tmuch more sophisticated, spherical variation.\n\n    This particular version was modified from Fabrice's \"Plop 2,\" which in \n\tturn was a simplified version of Fantomas's \"Plop.\" I simply reduced \n\tthe frequency and iteration count in order to make it less busy.\n\n\tI also threw in a texture, added point-lit bump mapping, speckles... \n\tand that's pretty much it. As for why a metallic surface would be \n\tdefying\tthe laws of physics and moving like this is anyone's guess. :)\n\n\tBy the way, I have a 3D version, similar to this, that I'll put up at \n\ta later date.\n\n\n\tRelated examples:\n\n    Fantomas - Plop\n    https:\/\/www.shadertoy.com\/view\/ltSSDV\n\n    Fabrice - Plop 2\n    https:\/\/www.shadertoy.com\/view\/MlSSDV\n\n\tIQ - Sculpture III (loosely related)\n\thttps:\/\/www.shadertoy.com\/view\/XtjSDK\n\n\tShane - Lit Sine Warp (far less code)\n\thttps:\/\/www.shadertoy.com\/view\/Ml2XDV\n\n*\/\n\n\n\/\/ Warp function. Variations have been around for years. This is\n\/\/ almost the same as Fabrice's version:\n\/\/ Fabrice - Plop 2\n\/\/ https:\/\/www.shadertoy.com\/view\/MlSSDV\nvec2 W(vec2 p){\n    \n    p = (p+3.)*4.;\n\n    float t = iGlobalTime\/2.;\n\n    \/\/ Layered, sinusoidal feedback, with time component.\n    for (int i=0; i<3; i++){\n        p += cos( p.yx*3. + vec2(t,1.57))\/3.;\n        p += sin( p.yx + t + vec2(1.57,0))\/2.;\n        p *= 1.3;\n    }\n\n    \/\/ A bit of jitter to counter the high frequency sections.\n    p +=  fract(sin(p+vec2(13, 7))*5e5)*.03-.015;\n\n    return mod(p,2.)-1.; \/\/ Range: [vec2(-1), vec2(1)]\n    \n}\n\n\/\/ Bump mapping function. Put whatever you want here. In this case, \n\/\/ we're returning the length of the sinusoidal warp function.\nfloat bumpFunc(vec2 p){ \n\n\treturn length(W(p))*.7071; \/\/ Range: [0, 1]\n\n}\n\n\/*\n\/\/ Standard ray-plane intersection.\nvec3 rayPlane(vec3 p, vec3 o, vec3 n, vec3 rd) {\n    \n    float dn = dot(rd, n);\n\n    float s = 1e8;\n    \n    if (abs(dn) > 0.0001) {\n        s = dot(p-o, n) \/ dn;\n        s += float(s < 0.0) * 1e8;\n    }\n    \n    return o + s*rd;\n}\n*\/\n\n\/\/vec3 smoothFract(vec3 x){ x = fract(x); return min(x, x*(1.-x)*12.); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \/\/ Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)\/iResolution.y;\n    \n    \n    \/\/ PLANE ROTATION\n    \/\/\n    \/\/ Rotating the canvas back and forth. I don't feel it adds value, in this case,\n    \/\/ but feel free to uncomment it.\n    \/\/float th = sin(iGlobalTime*0.1)*sin(iGlobalTime*0.12)*4.;\n    \/\/float cs = cos(th), si = sin(th);\n    \/\/uv *= mat2(cs, -si, si, cs);\n  \n\n    \/\/ VECTOR SETUP - surface postion, ray origin, unit direction vector, and light postion.\n    \/\/\n    \/\/ Setup: I find 2D bump mapping more intuitive to pretend I'm raytracing, then lighting a bump mapped plane \n    \/\/ situated at the origin. Others may disagree. :)  \n    vec3 sp = vec3(uv, 0); \/\/ Surface posion. Hit point, if you prefer. Essentially, a screen at the origin.\n    vec3 rd = normalize(vec3(uv, 1.)); \/\/ Unit direction vector. From the origin to the screen plane.\n    vec3 lp = vec3(cos(iGlobalTime)*0.5, sin(iGlobalTime)*0.2, -1.); \/\/ Light position - Back from the screen.\n\tvec3 sn = vec3(0., 0., -1); \/\/ Plane normal. Z pointing toward the viewer.\n \n     \n\/*\n\t\/\/ I deliberately left this block in to show that the above is a simplified version\n\t\/\/ of a raytraced plane. The \"rayPlane\" equation is commented out above.\n\tvec3 rd = normalize(vec3(uv, 1.));\n\tvec3 ro = vec3(0., 0., -1);\n\n\t\/\/ Plane normal.\n\tvec3 sn = normalize(vec3(cos(iGlobalTime)*0.25, sin(iGlobalTime)*0.25, -1));\n    \/\/vec3 sn = normalize(vec3(0., 0., -1));\n\t\n\tvec3 sp = rayPlane(vec3(0., 0., 0.), ro, sn, rd);\n    vec3 lp = vec3(cos(iGlobalTime)*0.5, sin(iGlobalTime)*0.25, -1.); \n*\/    \n    \n    \n    \/\/ BUMP MAPPING - PERTURBING THE NORMAL\n    \/\/\n    \/\/ Setting up the bump mapping variables. Normally, you'd amalgamate a lot of the following,\n    \/\/ and roll it into a single function, but I wanted to show the workings.\n    \/\/\n    \/\/ f - Function value\n    \/\/ fx - Change in \"f\" in in the X-direction.\n    \/\/ fy - Change in \"f\" in in the Y-direction.\n    vec2 eps = vec2(4.\/iResolution.y, 0.);\n    \n    float f = bumpFunc(sp.xy); \/\/ Sample value multiplied by the amplitude.\n    float fx = bumpFunc(sp.xy-eps.xy); \/\/ Same for the nearby sample in the X-direction.\n    float fy = bumpFunc(sp.xy-eps.yx); \/\/ Same for the nearby sample in the Y-direction.\n   \n \t\/\/ Controls how much the bump is accentuated.\n\tconst float bumpFactor = 0.05;\n    \n    \/\/ Using the above to determine the dx and dy function gradients.\n    fx = (fx-f)\/eps.x; \/\/ Change in X\n    fy = (fy-f)\/eps.x; \/\/ Change in Y.\n    \/\/ Using the gradient vector, \"vec3(fx, fy, 0),\" to perturb the XY plane normal \",vec3(0, 0, -1).\"\n    \/\/ By the way, there's a redundant step I'm skipping in this particular case, on account of the \n    \/\/ normal only having a Z-component. Normally, though, you'd need the commented stuff below.\n    \/\/vec3 grad = vec3(fx, fy, 0);\n    \/\/grad -= sn*dot(sn, grad);\n    \/\/sn = normalize( sn + grad*bumpFactor ); \n    sn = normalize( sn + vec3(fx, fy, 0)*bumpFactor );           \n   \n    \n    \/\/ LIGHTING\n    \/\/\n\t\/\/ Determine the light direction vector, calculate its distance, then normalize it.\n\tvec3 ld = lp - sp;\n\tfloat lDist = max(length(ld), 0.001);\n\tld \/= lDist;\n\n    \/\/ Light attenuation.    \n    float atten = min(1.\/(0.25 + lDist*0.5 + lDist*lDist*0.05), 1.);\n\t\/\/float atten = min(1.\/(lDist*lDist*1.), 1.);\n    \n    \/\/ Using the bump function, \"f,\" to darken the crevices. Completely optional, but I\n    \/\/ find it gives extra depth.\n    atten *= f*.85 + .15; \/\/ Or... f*f*.5 + .5; \/\/  pow(f, .75); \/\/ etc.\n\n\t\n\n\t\/\/ Diffuse value.\n\tfloat diff = max(dot(sn, ld), 0.);  \n    \/\/ Enhancing the diffuse value a bit. Made up.\n    diff = pow(diff, 2.)*0.66 + pow(diff, 4.)*0.34; \n    \/\/ Specular highlighting.\n    float spec = pow(max(dot( reflect(-ld, sn), -rd), 0.), 8.); \n\n\t\n    \/\/ TEXTURE COLOR\n    \/\/\n\t\/\/ Combining the surface postion with a fraction of the warped surface position to index \n    \/\/ into the texture. The result is a slightly warped texture, as a opposed to a completely \n    \/\/ warped one. By the way, the warp function is called above in the \"bumpFunc\" function,\n    \/\/ so it's kind of wasteful doing it again here, but the function is kind of cheap, and\n    \/\/ it's more readable this way.\n    vec3 texCol = texture2D(iChannel0, sp.xy + W(sp.xy)\/8.).xyz;\n    \/\/\n    \/*\n    \/\/ Textureless. Simple and elegant... so it clearly didn't come from me. Thanks Fabrice. :)\n    vec3 texCol = smoothFract( W(sp.xy).xyy )*.1 + .4;\n\t*\/\n    \n    \/\/ FINAL COLOR\n    \/\/ Using the values above to produce the final color.   \n    vec3 col = (texCol * (diff*vec3(1, .97, .92)*1.3 + 0.5) + vec3(1., 0.6, .2)*spec*1.3)*atten;\n\n\n    \/\/ Done. \n\tfragColor = vec4(min(col, 1.), 1.);\n}","name":"","description":"","type":"image"}]}}