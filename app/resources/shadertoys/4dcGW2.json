{"Shader":{"ver":"0.1","info":{"id":"4dcGW2","date":"1452112877","viewed":1379,"name":" expansive reaction-diffusion","username":"Flexi","description":"featuring a two-pass 9x9 Gaussian Blur pipeline for the diffusion, gradient lookup for morphological expansion, and a simple differential \"Turing Pattern\" reaction. Lookout, there are 3 more diffused channels ","likes":55,"published":3,"flags":32,"tags":["gaussianblur","reactiondiffusion"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":259,"src":"\/presets\/previz\/buffer02.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec2 pixelSize = 1. \/ iResolution.xy;\n    vec2 aspect = vec2(1.,iResolution.y\/iResolution.x);\n\n    vec4 noise = texture2D(iChannel3, fragCoord.xy \/ iChannelResolution[3].xy + fract(vec2(42,56)*iGlobalTime));\n    \n\tvec2 lightSize=vec2(4.);\n\n    \/\/ get the gradients from the blurred image\n\tvec2 d = pixelSize*2.;\n\tvec4 dx = (texture2D(iChannel2, uv + vec2(1,0)*d) - texture2D(iChannel2, uv - vec2(1,0)*d))*0.5;\n\tvec4 dy = (texture2D(iChannel2, uv + vec2(0,1)*d) - texture2D(iChannel2, uv - vec2(0,1)*d))*0.5;\n\n\t\/\/ add the pixel gradients\n\td = pixelSize*1.;\n\tdx += texture2D(iChannel0, uv + vec2(1,0)*d) - texture2D(iChannel0, uv - vec2(1,0)*d);\n\tdy += texture2D(iChannel0, uv + vec2(0,1)*d) - texture2D(iChannel0, uv - vec2(0,1)*d);\n\n\tvec2 displacement = vec2(dx.x,dy.x)*lightSize; \/\/ using only the red gradient as displacement vector\n\tfloat light = pow(max(1.-distance(0.5+(uv-0.5)*aspect*lightSize + displacement,0.5+(iMouse.xy*pixelSize-0.5)*aspect*lightSize),0.),4.);\n\n\t\/\/ recolor the red channel\n\tvec4 rd = vec4(texture2D(iChannel0,uv+vec2(dx.x,dy.x)*pixelSize*8.).x)*vec4(0.7,1.5,2.0,1.0)-vec4(0.3,1.0,1.0,1.0);\n\n    \/\/ and add the light map\n    fragColor = mix(rd,vec4(8.0,6.,2.,1.), light*0.75*vec4(1.-texture2D(iChannel0,uv+vec2(dx.x,dy.x)*pixelSize*8.).x)); \n\t\n\t\/\/gl_FragColor = texture2D(sampler_prev, pixel); \/\/ bypass    \n}","name":"","description":"","type":"image"},{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":259,"src":"\/presets\/previz\/buffer02.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":260,"src":"\/presets\/previz\/buffer03.png","ctype":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ main reaction-diffusion loop\n\n\/\/ actually the diffusion is realized as a separated two-pass Gaussian blur kernel and is stored in buffer C\n\n#define pi2_inv 0.159154943091895335768883763372\n\nvec2 complex_mul(vec2 factorA, vec2 factorB){\n    return vec2( factorA.x*factorB.x - factorA.y*factorB.y, factorA.x*factorB.y + factorA.y*factorB.x);\n}\n\nvec2 spiralzoom(vec2 domain, vec2 center, float n, float spiral_factor, float zoom_factor, vec2 pos){\n    vec2 uv = domain - center;\n    float d = length(uv);\n    return vec2( atan(uv.y, uv.x)*n*pi2_inv + d*spiral_factor, -log(d)*zoom_factor) + pos;\n}\n\nvec2 complex_div(vec2 numerator, vec2 denominator){\n    return vec2( numerator.x*denominator.x + numerator.y*denominator.y,\n                numerator.y*denominator.x - numerator.x*denominator.y)\/\n        vec2(denominator.x*denominator.x + denominator.y*denominator.y);\n}\n\nfloat circle(vec2 uv, vec2 aspect, float scale){\n    return clamp( 1. - length((uv-0.5)*aspect*scale), 0., 1.);\n}\n\nfloat sigmoid(float x) {\n    return 2.\/(1. + exp2(-x)) - 1.;\n}\n\nfloat smoothcircle(vec2 uv, vec2 aspect, float radius, float ramp){\n    return 0.5 - sigmoid( ( length( (uv - 0.5) * aspect) - radius) * ramp) * 0.5;\n}\n\nfloat conetip(vec2 uv, vec2 pos, float size, float min)\n{\n    vec2 aspect = vec2(1.,iResolution.y\/iResolution.x);\n    return max( min, 1. - length((uv - pos) * aspect \/ size) );\n}\n\nfloat warpFilter(vec2 uv, vec2 pos, float size, float ramp)\n{\n    return 0.5 + sigmoid( conetip(uv, pos, size, -16.) * ramp) * 0.5;\n}\n\nvec2 vortex_warp(vec2 uv, vec2 pos, float size, float ramp, vec2 rot)\n{\n    vec2 aspect = vec2(1.,iResolution.y\/iResolution.x);\n\n    vec2 pos_correct = 0.5 + (pos - 0.5);\n    vec2 rot_uv = pos_correct + complex_mul((uv - pos_correct)*aspect, rot)\/aspect;\n    float filter = warpFilter(uv, pos_correct, size, ramp);\n    return mix(uv, rot_uv, filter);\n}\n\nvec2 vortex_pair_warp(vec2 uv, vec2 pos, vec2 vel)\n{\n    vec2 aspect = vec2(1.,iResolution.y\/iResolution.x);\n    float ramp = 5.;\n\n    float d = 0.2;\n\n    float l = length(vel);\n    vec2 p1 = pos;\n    vec2 p2 = pos;\n\n    if(l > 0.){\n        vec2 normal = normalize(vel.yx * vec2(-1., 1.))\/aspect;\n        p1 = pos - normal * d \/ 2.;\n        p2 = pos + normal * d \/ 2.;\n    }\n\n    float w = l \/ d * 2.;\n\n    \/\/ two overlapping rotations that would annihilate when they were not displaced.\n    vec2 circle1 = vortex_warp(uv, p1, d, ramp, vec2(cos(w),sin(w)));\n    vec2 circle2 = vortex_warp(uv, p2, d, ramp, vec2(cos(-w),sin(-w)));\n    return (circle1 + circle2) \/ 2.;\n}\n\nvec2 mouseDelta(){\n    vec2 pixelSize = 1. \/ iResolution.xy;\n    float eighth = 1.\/8.;\n    vec4 oldMouse = texture2D(iChannel2, vec2(7.5 * eighth, 2.5 * eighth));\n    vec4 nowMouse = vec4(iMouse.xy \/ iResolution.xy, iMouse.zw \/ iResolution.xy);\n    if(oldMouse.z > pixelSize.x && oldMouse.w > pixelSize.y && \n       nowMouse.z > pixelSize.x && nowMouse.w > pixelSize.y)\n    {\n        return nowMouse.xy - oldMouse.xy;\n    }\n    return vec2(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec2 pixelSize = 1. \/ iResolution.xy;\n    \n\n    vec2 mouseV = mouseDelta();\n    vec2 aspect = vec2(1.,iResolution.y\/iResolution.x);\n    uv = vortex_pair_warp(uv, iMouse.xy*pixelSize, mouseV*aspect*1.4);\n\n    vec4 blur1 = texture2D(iChannel1, uv);\n    \n    vec4 noise = texture2D(iChannel3, fragCoord.xy \/ iChannelResolution[3].xy + fract(vec2(42,56)*iGlobalTime));\n\n    \/\/ get the gradients from the blurred image\n\tvec2 d = pixelSize*4.;\n\tvec4 dx = (texture2D(iChannel1, fract(uv + vec2(1,0)*d)) - texture2D(iChannel1, fract(uv - vec2(1,0)*d))) * 0.5;\n\tvec4 dy = (texture2D(iChannel1, fract(uv + vec2(0,1)*d)) - texture2D(iChannel1, fract(uv - vec2(0,1)*d))) * 0.5;\n    \n    vec2 uv_red = uv + vec2(dx.x, dy.x)*pixelSize*8.; \/\/ add some diffusive expansion\n    \n    float new_red = texture2D(iChannel0, fract(uv_red)).x + (noise.x - 0.5) * 0.0025 - 0.002; \/\/ stochastic decay\n\tnew_red -= (texture2D(iChannel1, fract(uv_red + (noise.xy-0.5)*pixelSize)).x -\n\t\t\t\ttexture2D(iChannel0, fract(uv_red + (noise.xy-0.5)*pixelSize))).x * 0.047; \/\/ reaction-diffusion\n        \n    if(iFrame<10)\n    {\n        fragColor = noise; \n    }\n    else\n    {\n        fragColor.x = clamp(new_red, 0., 1.);\n    }\n\n\/\/    fragColor = noise; \/\/ need a restart?\n}","name":"","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ horizontal Gaussian blur pass\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelSize = 1.\/ iChannelResolution[0].xy;\n    vec2 uv = fragCoord.xy * pixelSize;\n    \n    float h = pixelSize.x;\n\tvec4 sum = vec4(0.0);\n\tsum += texture2D(iChannel0, fract(vec2(uv.x - 4.0*h, uv.y)) ) * 0.05;\n\tsum += texture2D(iChannel0, fract(vec2(uv.x - 3.0*h, uv.y)) ) * 0.09;\n\tsum += texture2D(iChannel0, fract(vec2(uv.x - 2.0*h, uv.y)) ) * 0.12;\n\tsum += texture2D(iChannel0, fract(vec2(uv.x - 1.0*h, uv.y)) ) * 0.15;\n\tsum += texture2D(iChannel0, fract(vec2(uv.x + 0.0*h, uv.y)) ) * 0.16;\n\tsum += texture2D(iChannel0, fract(vec2(uv.x + 1.0*h, uv.y)) ) * 0.15;\n\tsum += texture2D(iChannel0, fract(vec2(uv.x + 2.0*h, uv.y)) ) * 0.12;\n\tsum += texture2D(iChannel0, fract(vec2(uv.x + 3.0*h, uv.y)) ) * 0.09;\n\tsum += texture2D(iChannel0, fract(vec2(uv.x + 4.0*h, uv.y)) ) * 0.05;\n    \n    fragColor.xyz = sum.xyz\/0.98; \/\/ normalize\n\tfragColor.a = 1.;\n}","name":"","description":"","type":"buffer"},{"inputs":[{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ vertical Gaussian blur pass\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelSize = 1.\/ iChannelResolution[0].xy;\n    vec2 uv = fragCoord.xy * pixelSize;\n\n    float v = pixelSize.y;\n\tvec4 sum = vec4(0.0);\n\tsum += texture2D(iChannel0, fract(vec2(uv.x, uv.y - 4.0*v)) ) * 0.05;\n\tsum += texture2D(iChannel0, fract(vec2(uv.x, uv.y - 3.0*v)) ) * 0.09;\n\tsum += texture2D(iChannel0, fract(vec2(uv.x, uv.y - 2.0*v)) ) * 0.12;\n\tsum += texture2D(iChannel0, fract(vec2(uv.x, uv.y - 1.0*v)) ) * 0.15;\n\tsum += texture2D(iChannel0, fract(vec2(uv.x, uv.y + 0.0*v)) ) * 0.16;\n\tsum += texture2D(iChannel0, fract(vec2(uv.x, uv.y + 1.0*v)) ) * 0.15;\n\tsum += texture2D(iChannel0, fract(vec2(uv.x, uv.y + 2.0*v)) ) * 0.12;\n\tsum += texture2D(iChannel0, fract(vec2(uv.x, uv.y + 3.0*v)) ) * 0.09;\n\tsum += texture2D(iChannel0, fract(vec2(uv.x, uv.y + 4.0*v)) ) * 0.05;\n    \n    fragColor.xyz = sum.xyz\/0.98; \/\/ normalize\n\tfragColor.a = 1.;\n}","name":"","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ not used (yet), but hooray for 8 channel feedback\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec2 pixelSize = 1. \/ iResolution.xy;\n    float eighth = 1.\/8.;\n    if(uv.x > 7.*eighth && uv.x < 8.*eighth && uv.y > 2.*eighth && uv.y < 3.*eighth)\n    {\n        fragColor = vec4(iMouse.xy \/ iResolution.xy, iMouse.zw \/ iResolution.xy);\n    }\n}","name":"","description":"","type":"buffer"}]}}