{"Shader":{"ver":"0.1","info":{"id":"ldXGDr","date":"1367327090","viewed":2648,"name":"Flatland","username":"P_Malin","description":"An optical illusion to make a regular grid appear distorted. Click to remove the spots.","likes":33,"published":3,"flags":0,"tags":["2d","illusion"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\n#define ENABLE_SPOTS\n\n\/\/#define ENABLE_MONOCHROME\n#define ENABLE_SHADING\n\/\/#define SIMPLE_HEIGHT\n\n#define MOUSE_BUTTON_REMOVES_SPOTS\n\nfloat fTileSize = 24.0;\n\n#ifndef ENABLE_MONOCHROME\nfloat kContrast = 0.5;\n#else\nfloat kContrast = 1.0;\n#endif\n\nfloat fBlobOffset = 0.35;\nfloat fBlobSize = 0.1;\n\nfloat hash( const in float f )\n{\n\treturn fract( sin(f * 4001.0) * 101.0 );\n}\n\nfloat smoothnoise(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = hash(n+  0.0);\n\tfloat b = hash(n+  1.0);\n\tfloat c = hash(n+ 57.0);\n\tfloat d = hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\t\n\treturn mix(mix( a, b, t.x ), mix(c, d, t.x), t.y);\n}\n\nfloat GetHeight( const in vec2 vUV )\n{\t\n\t#ifdef SIMPLE_HEIGHT\n\treturn clamp(1.0 - length((vUV) * 0.15), 0.0, 1.0);\n\t#else\t\n\tvec2 p = vUV * 0.1;\n\n\tfloat m = 0.5;\n\tfloat h = 0.0;\n\th += m * smoothnoise(p); p *= 2.0; m *= 0.5;\n\th += m * smoothnoise(p); p *= 2.0; m *= 0.5;\n\th += m * smoothnoise(p); p *= 2.0; m *= 0.5;\n\th += m * smoothnoise(p);\n\t\t\n\treturn h;\n\t#endif\t\n}\n\nvec3 GetColour( const in vec2 vPos )\n{\n\tvec2 vTilePos = floor(vPos);\n\tvec2 vTileFrac = fract(vPos);\n\t\n\tfloat h = GetHeight(vPos);\n\tfloat fDelta = 0.1;\n\tfloat dx = GetHeight(vPos + vec2(fDelta, 0.0)) - GetHeight(vPos - vec2(fDelta, 0.0));\n\tfloat dy = GetHeight(vPos + vec2(0.0, fDelta)) - GetHeight(vPos - vec2(0.0, fDelta));\n\tdx = dx \/ fDelta;\n\tdy = dy \/ fDelta;\t\n\t\n\tfloat tdx = GetHeight(vTilePos + vec2(1.0, 0.0)) - GetHeight(vTilePos - vec2(1.0, 0.0));\n\tfloat tdy = GetHeight(vTilePos + vec2(0.0, 1.0)) - GetHeight(vTilePos - vec2(0.0, 1.0));\n\t\t\n\tvec2 vDelta = vec2(tdx, tdy);\n\t\t\n\t\/\/ co-ords to put the corner blobs for this tile in -1 to 1 range\n\tvec2 o1 = vec2(0.0);\n\tvec2 o2 = vec2(0.0);\n\n\t\/\/ There will be a simpler way to do this but I'm too lazy to figure out what it is...\n\tfloat fAngle = atan(vDelta.x, vDelta.y);\n\tfloat fSegment = (fAngle \/ (3.141592 * 2.0)) * 16.0;\n\t\n\tfSegment = mod(fSegment + 32.0, 16.0);\n\t\n\tif(fSegment < 1.0)\n\t{\n\t\to1 = vec2(1.0, -1.0);\n\t\to2 = vec2(-1.0, -1.0);\n\t}\n\telse if(fSegment < 3.0)\n\t{\n\t\to1 = vec2( 1.0,-1.0);\n\t\to2 = vec2(-1.0, 1.0);\n\t}\n\telse if(fSegment < 5.0)\n\t{\n\t\to1 = vec2(-1.0,-1.0);\n\t\to2 = vec2(-1.0, 1.0);\n\t}\n\telse if(fSegment < 7.0)\n\t{\n\t\to1 = vec2(-1.0,-1.0);\n\t\to2 = vec2(1.0,  1.0);\n\t}\n\telse if(fSegment < 9.0)\n\t{\n\t\to1 = vec2(1.0,  1.0);\n\t\to2 = vec2(-1.0, 1.0);\n\t}\n\telse if(fSegment < 11.0)\n\t{\n\t\to1 = vec2(1.0, -1.0);\n\t\to2 = vec2(-1.0, 1.0);\n\t}\n\telse if(fSegment < 13.0)\n\t{\n\t\to1 = vec2( 1.0,  1.0);\n\t\to2 = vec2( 1.0, -1.0);\n\t}\n\telse if(fSegment < 15.0)\n\t{\n\t\to1 = vec2(-1.0,-1.0);\n\t\to2 = vec2(1.0,  1.0);\n\t}\n\telse\n\t{\n\t\to1 = vec2(1.0, -1.0);\n\t\to2 = vec2(-1.0, -1.0);\n\t}\t\n\t\t\t\n\tfloat fEffect = 0.0;\n\n\t#ifdef ENABLE_SPOTS\n\t\n\t#ifdef MOUSE_BUTTON_REMOVES_SPOTS\n\tif(iMouse.z <= 0.0)\n\t#endif\n\t{\n\t\tif( length(vDelta) > 0.025 )\n\t\t{\n\t\t\tif( (abs(vTileFrac.x - 0.5 + o1.x * fBlobOffset) < fBlobSize) &&\n\t\t\t\t(abs(vTileFrac.y - 0.5 + o1.y * fBlobOffset) < fBlobSize)  )\n\t\t\t\tfEffect = 1.0;\n\t\t\t\n\t\t\tif( (abs(vTileFrac.x - 0.5 + o2.x * fBlobOffset) < fBlobSize) &&\n\t\t\t\t(abs(vTileFrac.y - 0.5 + o2.y * fBlobOffset) < fBlobSize)  )\n\t\t\t\tfEffect = 1.0;\n\t\t}\n\t}\n\t#endif\n\t\n\tfloat fInverse = mod(vTilePos.x + vTilePos.y, 2.0);\n\tif(fInverse > 0.5)\n\t{\n\t\tfEffect = 1.0 - fEffect;\n\t}\n\n\t\/\/ Terrain colours\t\n\tvec3 vBase =  vec3(0.01, 0.2, 0.6);\n\tvBase = mix( vBase, vec3(0.01, 0.5, 0.1), smoothstep(0.19, 0.2, h) );\n\tvBase = mix( vBase, vec3(0.5, 0.3, 0.1), smoothstep(0.4, 0.5, h) );\n\tvBase = mix( vBase, vec3(1.0, 1.0, 1.0), smoothstep(0.7, 0.8, h) );\n\n\t#ifdef ENABLE_MONOCHROME\n\tvBase = vec3(1.0);\n\t#endif\n\n\tvec3 n = normalize(vec3(dx, dy, 0.1));\n\tvec3 l = normalize(vec3(1.0, -0.5, 1.0));\n\n\t#ifdef ENABLE_SHADING\n\tfloat fShade = clamp( dot(n,l), 0.0, 1.0);\n\tvBase = mix(0.3, 1.0, fShade) * vBase;\n\t#endif\n\t\t\n\treturn mix( vBase*(1.0 - kContrast), vBase, fEffect);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vPos = fragCoord.xy;\n\n\tvec2 vOffset = vec2(0.0);\n\n\tvOffset.x += floor(cos(iGlobalTime * 0.15234) * 500.0);\n\tvOffset.y += floor(sin(iGlobalTime * 0.17312) * 500.0);\t\t\n\n\tvOffset.x -= iMouse.x * 4.0;\n\tvOffset.y -= iMouse.y * 4.0;\n\t\t\n\tvPos += vOffset;\n\t\t\n\tvec3 vColour = GetColour(vPos \/ fTileSize);\n\t\n\tvColour =sqrt(vColour);\n\tfragColor = vec4(vColour,1.0);\n}","name":"","description":"","type":"image"}]}}