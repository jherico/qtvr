{"Shader":{"ver":"0.1","info":{"id":"XsKGRW","date":"1453904549","viewed":315,"name":"Full Scene Radial Blur","username":"Shane","description":"Applying some God rays, post process, to a simple raymarched scene. Inspired by Passion's \"Blue Dream\" ... and a lot of old demos. <img src=\"\/img\/emoticonHappy.png\"\/>","likes":27,"published":3,"flags":32,"tags":["raymarching","blur","radial","godrays"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/*\n\tFull Scene Radial Blur\n\t----------------------\n\n\tRadial blur - as a postprocessing effect - is one of the first things I considered doing \n\twhen the multipass system came out. I've always loved this effect. Reminds me of the early \n\tdemos from Aardbei et al. \n\n\tAnyway, Shadertoy user, Passion, did a really cool radial blur on a field of spheres that\n\tinspired me to do my own. Radial blurs are pretty straight forward, but it was still\n    helpful to have Passion's version as a guide. \n\n    As for the radial blur process, there's not much to it. Start off at the pixel position, \n    then radiate outwards gathering up pixels with decreased weighting. The result is a\n\tblurring of the image in a radial fashion, strangely enough. :)\n\n\tInspired by:\n\n\tBlue Dream - Passion\n\thttps:\/\/www.shadertoy.com\/view\/MdG3RD\n\n\tRadial Blur - IQ\n\thttps:\/\/www.shadertoy.com\/view\/4sfGRn\n\n\tRays of Blinding Light - mu6k\n\thttps:\/\/www.shadertoy.com\/view\/lsf3Dn\n\n*\/\n\n\/\/ The radial blur section. Shadertoy user, Passion, did a good enough job, so I've used a\n\/\/ slightly trimmed down version of that. By the way, there are accumulative weighting \n\/\/ methods that do a slightly better job, but this method is good enough for this example.\n\n\n\/\/ Radial blur samples. More is always better, but there's frame rate to consider.\nconst float SAMPLES = 24.; \n\n\n\/\/ 2x1 hash. Used to jitter the samples.\nfloat hash( vec2 p ){ return fract(sin(dot(p, vec2(41, 289)))*45758.5453); }\n\n\n\/\/ Light offset.\n\/\/\n\/\/ I realized, after a while, that determining the correct light position doesn't help, since \n\/\/ radial blur doesn't really look right unless its focus point is within the screen boundaries, \n\/\/ whereas the light is often out of frame. Therefore, I decided to go for something that at \n\/\/ least gives the feel of following the light. In this case, I normalized the light position \n\/\/ and rotated it in unison with the camera rotation. Hacky, for sure, but who's checking? :)\nvec3 lOff(){    \n    \n    vec2 u = sin(vec2(1.57, 0) - iGlobalTime\/2.);\n    mat2 a = mat2(u, -u.y, u.x);\n    \n    vec3 l = normalize(vec3(1.5, 1., -0.5));\n    l.xz = a * l.xz;\n    l.xy = a * l.xy;\n    \n    return l;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \/\/ Screen coordinates.\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n\n    \/\/ Radial blur factors.\n    \/\/\n    \/\/ Falloff, as we radiate outwards.\n    float decay = 0.97; \n    \/\/ Controls the sample density, which in turn, controls the sample spread.\n    float density = 0.5; \n    \/\/ Sample weight. Decays as we radiate outwards.\n    float weight = 0.09; \n    \n    \/\/ Light offset. Kind of fake. See above.\n    vec3 l = lOff();\n    \n    \/\/ Offset texture position (uv - .5), offset again by the fake light movement.\n    \/\/ It's used to set the blur direction (a direction vector of sorts), and is used \n    \/\/ later to center the spotlight.\n    \/\/\n    \/\/ The range is centered on zero, which allows the accumulation to spread out in\n    \/\/ all directions. Ie; It's radial.\n    vec2 tuv =  uv - .5 - l.xy*.45;\n    \n    \/\/ Dividing the direction vector above by the sample number and a density factor\n    \/\/ which controls how far the blur spreads out. Higher density means a greater \n    \/\/ blur radius.\n    vec2 dTuv = tuv*density\/SAMPLES;\n    \n    \/\/ Grabbing a portion of the initial texture sample. Higher numbers will make the\n    \/\/ scene a little clearer, but I'm going for a bit of abstraction.\n    vec4 col = texture2D(iChannel0, uv.xy)*0.25;\n    \n    \/\/ Jittering, to get rid of banding. Vitally important when accumulating discontinuous \n    \/\/ samples, especially when only a few layers are being used.\n    uv += dTuv*(hash(uv.xy + fract(iGlobalTime))*2. - 1.);\n    \n    \/\/ The radial blur loop. Take a texture sample, move a little in the direction of\n    \/\/ the radial direction vector (dTuv) then take another, slightly less weighted,\n    \/\/ sample, add it to the total, then repeat the process until done.\n    for(float i=0.; i < SAMPLES; i++){\n    \n        uv -= dTuv;\n        col += texture2D(iChannel0, uv) * weight;\n        weight *= decay;\n        \n    }\n    \n    \/\/ Multiplying the final color with a spotlight centered on the focal point of the radial\n    \/\/ blur. It's a nice finishing touch... that Passion came up with. If it's a good idea,\n    \/\/ it didn't come from me. :)\n    col *= (1. - dot(tuv, tuv)*.75);\n    \n    \/\/ Smoothstepping the final color, just to bring it out a bit.\n    fragColor = smoothstep(0., 1., col);\n    \n    \/\/ Bypassing the radial blur to show the raymarched scene on its own.\n    \/\/fragColor = texture2D(iChannel0, fragCoord.xy \/ iResolution.xy);\n}\n\n","name":"","description":"","type":"image"},{"inputs":[{"id":3,"src":"\/presets\/tex02.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ The scene itself. Not much commenting, since this is mainly about the radial blur,\n\/\/ plus a lot of it is rudimentary.\n\n#define FAR 20.\n\n\/\/ Hash.\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\n\n\/\/ Tri-Planar blending function. Based on an old Nvidia writeup:\n\/\/ GPU Gems 3 - Ryan Geiss: http:\/\/http.developer.nvidia.com\/GPUGems3\/gpugems3_ch01.html\nvec3 tpl( sampler2D t, in vec3 p, in vec3 n ){\n   \n    n = max(n*n, 0.001);\n    n \/= (n.x + n.y + n.z );  \n\treturn (texture2D(t, p.yz)*n.x + texture2D(t, p.zx)*n.y + texture2D(t, p.xy)*n.z).xyz;\n}\n\n\/\/ A simple, cheap but visually effective sinusoid based lattice. The downside to building\n\/\/ a scene with transcendentals is the honing difficulty, but the logarithmic based\n\/\/ \"Logarithmmic Bisection\" tracing method counters that.\nfloat map(in vec3 p){\n   \n    \/\/ A few small bumps to put on the surface.\n    float bump = (dot(sin(p*24. - cos(p.yzx*36.)), vec3(.015)));\n    \n    \/\/ Perturbing the surface slightly, prior to construction.\n    p += sin(p*8. + 3.14159)*.1;\n    \n    \/\/ The main surface. A weird, molecular looking lattice.\n    float n = dot(sin(p*2.), cos(p.yzx*2.));\n    \n \t\/\/ Clamping the surface value, and adding the bumps.\n    \/\/return (clamp(0., -1.1, n) + 1.1)\/1.1 + bump;\n    return (min(n, 0.) + 1.1)\/1.1 + bump;\n    \n}\n\n \n\/\/ Ambient occlusion, for that self shadowed look.\n\/\/ XT95 came up with this particular version. Very nice.\n\/\/\n\/\/ Hemispherical SDF AO - https:\/\/www.shadertoy.com\/view\/4sdGWN\n\/\/ Alien Cocoons - https:\/\/www.shadertoy.com\/view\/MsdGz2\nfloat cao( in vec3 p, in vec3 n, float maxDist )\n{\n\tfloat ao = 0.0, l;\n\tconst float nbIte = 6.0;\n\tconst float falloff = 1.5;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i + hash(i))*.5\/nbIte*maxDist;\n        ao += (l - map( p + n*l ))\/ pow(1. + l, falloff);\n    }\n\t\n    return clamp( 1.-ao\/nbIte, 0., 1.);\n}\n\n\/\/ Tetrahedral normal, courtesy of IQ.\nvec3 nr(in vec3 p)\n{  \n    vec2 e = vec2(-1, 1)*.001;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n\/\/ A trimmed down version of Nimitz's \"Log Bisecion\" method. Very effective on\n\/\/ difficult to hone in on things like weird, transcendental surfaces.\n\/\/ Worth studying, if you're not familiar with it.\n\/\/\n\/\/ Log-Bisection Tracing - Nimitz\n\/\/ https:\/\/www.shadertoy.com\/view\/4sSXzD\nfloat logBisectTrace( in vec3 ro, in vec3 rd){\n\n\n    float t = 0., told = 0., mid, dn;\n    float d = map(rd*t + ro);\n    float sgn = sign(d);\n\n    for (int i=0; i<64; i++){\n\n        \/\/ If the threshold is crossed with no detection, use the bisection method.\n        \/\/ Also, break for the usual reasons. Note that there's only one \"break\"\n        \/\/ statement in the loop. I heard GPUs like that... but who knows?\n        if (sign(d) != sgn || d < 0.001 || t > FAR) break;\n \n        told = t;\n        \n        \/\/ Branchless version of the following:  \n        \/\/ if(d>1.) t += d*.5; else t += log(abs(d) + 1.1)*.5;\n        t += step(d, 1.)*(log(abs(d) + 1.1)*.5 - d*.5) + d*.5;\n       \n        d = map(rd*t + ro);\n    }\n    \n    \/\/ If a threshold was crossed without a solution, use the bisection method.\n    if (sign(d) != sgn){\n    \n        \/\/ Based on suggestions from CeeJayDK, with some minor changes.\n\n        dn = sign(map(rd*told + ro));\n        \n        vec2 iv = vec2(told, t); \/\/ Near, Far\n\n        \/\/ 6 iterations seems to be more than enough, for most cases...\n        \/\/ but there's an early exit, so I've added a couple more.\n        for (int ii=0; ii<8; ii++){ \n            \/\/Evaluate midpoint\n            mid = dot(iv, vec2(.5));\n            float d = map(rd*mid + ro);\n            if (abs(d) < 0.001)break;\n            \/\/ Suggestion from movAX13h - Shadertoy is one of those rare\n            \/\/ sites with helpful commenters. :)\n            \/\/ Set mid to near or far, depending on which side we're on.\n            iv = mix(vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn));\n        }\n\n        t = mid; \n        \n    }\n\n    return min(t, FAR);\n}\n\n\/\/ Shadows.\nfloat sha(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    const int maxIterationsShad = 16; \n\n    float dist = start;\n    float stepDist = end\/float(maxIterationsShad);\n\n    for (int i=0; i<maxIterationsShad; i++){\n        float h = map(ro + rd*dist);\n        \/\/shade = min(shade, k*h\/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h\/dist));\n\n        dist += clamp(h, 0.02, 0.16);\n        \n        \/\/ There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if ((h)<0.001 || dist > end) break; \n    }\n    \n    return min(max(shade, 0.) + 0.3, 1.0); \n}\n\n\/\/ Grey scale.\nfloat gr(vec3 p){ return dot(p, vec3(0.299, 0.587, 0.114)); }\n\n\/\/ Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 db( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \/\/ Gradient vector, constructed with offset greyscale texture values.\n    vec3 g = vec3( gr(tpl(tx, p - e.xyy, n)), gr(tpl(tx, p - e.yxy, n)), gr(tpl(tx, p - e.yyx, n)));\n    \n    g = (g - gr(tpl(tx,  p , n)))\/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); \/\/ Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n\/\/ Camera path. Arranged to coincide with the frequency of the lattice.\nvec3 camPath(float t){\n  \n    return vec3(-sin(t), sin(t) + .75, t*2. + .5);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n\t\/\/ Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*0.5)\/iResolution.y;\n\t\n\t\/\/ Camera Setup.\n\t\n    vec3 o = camPath(iGlobalTime); \/\/ Camera position, doubling as the ray origin.\n    vec3 lk = camPath(iGlobalTime + .1);  \/\/ \"Look At\" position.\n    vec3 l = o + vec3(1.5, 1., -0.5); \/\/ Light position, somewhere near the moving camera.\n\n\n    \/\/ Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159\/3.; \/\/ FOV - Field of view.\n    vec3 fwd = normalize(lk-o);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n\n    \/\/ Unit direction ray.\n    vec3 r = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n    \/\/ Lens distortion.\n    \/\/vec3 r = fwd + FOV*(u.x*rgt + u.y*up);\n    \/\/r = normalize(vec3(r.xy, (r.z - length(r.xy)*.5)));\n    \n    \n    \/\/ Rotate the camera using Fabrice's simplified rotation matrix.\n    u = sin(vec2(1.57, 0) - iGlobalTime\/2.); \/\/ Reusing \"u.\"\n    mat2 a = mat2(u, -u.y, u.x);\n    r.xz = a * r.xz;\n    r.xy = a * r.xy;\n\n    \/\/ Nimitz's fancy surface intersection formula.\n    float t = logBisectTrace(o, r);\n\n    \/\/ Initialize the scene color to zero.\n    vec3 col = vec3(0);\n    \n    \/\/ If the surface is hit, light it up.\n    if(t<FAR){\n    \n        \/\/ Position and normal.\n        vec3 p = o + r*t, n = nr(p);\n        \n        \/\/ Texture bump the normal.\n        float sz = 1.\/1.;\n        n = db(iChannel0, p*sz, n, .03\/(1. + t\/FAR));\n\n\n        l -= p; \/\/ Light to surface vector. Ie: Light direction vector.\n        float d = max(length(l), 0.001); \/\/ Light to surface distance.\n        l \/= d; \/\/ Normalizing the light direction vector.\n        \n        \/\/ Ambient occlusion and shadowing.\n        float ao =  cao(p, n, 4.);\n        float sh = sha(p, l, 0.04, d, 4.);\n        \n        \/\/ Diffuse, specular, fresnel. Only the latter is being used here.\n        \/\/float di = max(dot(l, n), 0.);\n        \/\/float sp = pow(max( dot( reflect(r, n), l ), 0.0 ), 8.); \/\/ Specular term.\n        float fr = clamp(1.0 + dot(r, n), 0.0, 1.0); \/\/ Fresnel reflection term.\n        \n        \/\/ Texturing the surface with some tri-planar mapping..\n        vec3 tx = tpl( iChannel0, p*sz, n);\n\n\t\t\/\/ Very simple coloring. Fresnel and texture combination. Radial blurs like simplicity. :)\n        col = tx*fr*4.;\n        col *= 1.\/(1. + d*.125 + d*d*.05)*ao*sh;\n\n        \n    }\n\n    vec3 bg = vec3(1, .7, .5);\n    col = mix(clamp(col, 0., 1.), bg, smoothstep(0., FAR-2., t));\n    fragColor = vec4(col, 1.);\n    \n    \n}","name":"","description":"","type":"buffer"}]}}