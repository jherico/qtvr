{"Shader":{"ver":"0.1","info":{"id":"MlsSzS","date":"1437677914","viewed":1160,"name":"Water in a box","username":"adam27","description":"Woda, pude\u0142ko i powietrze.","likes":7,"published":3,"flags":0,"tags":["water","box","warsztat","air"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\nfloat rand(vec2 v)\n{\n\tfloat x = fract(sin(dot(v, vec2(1872.8497, -2574.9248))) * 72123.19);\n\treturn x;\n}\n\nfloat noise(in vec2 p) \n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix(mix(rand(i + vec2(0.0,0.0)), rand(i + vec2(1.0,0.0)), u.x),\n\t\t\t\t\t\tmix(rand(i + vec2(0.0,1.0)), rand(i + vec2(1.0,1.0)), u.x), u.y);\n}\n\nfloat map(vec2 xz)\n{\n\txz += noise(xz);\n\tvec2 a = 1.0 - abs(sin(xz));\n\tvec2 b = abs(cos(xz));\n\treturn pow(dot(a, b), 0.5);\n}\n\nconst mat2 mat = mat2(1.8, 1.1, -1.1, 1.8);\n\nfloat water(vec3 p)\n{\n\tvec2 xz = p.xz;\n\txz.x *= 0.7;\n\tfloat amp = 1.0;\n\tfloat h = 0.0;\n\tfloat freq = 0.2;\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tfloat h1 = map((xz + iGlobalTime) * freq);\n\t\tfloat h2 = 0.0;\n\t\th += (h1 + h2) * amp;\n\t\tfreq *= 1.8;\n\t\tamp *= 0.18;\n\t\txz *= mat;\n\t}\n\treturn p.y - h;\n}\n\nvec3 getNormal(vec3 p, float d)\n{\n    vec3 n;\n    n.y = water(p);    \n    n.x = water(p + vec3(d,0,0)) - n.y;\n    n.z = water(p + vec3(0,0,d)) - n.y;\n    n.y = d;\n    return normalize(n);\n}\n\nconst int MAX_STEPS = 100;\n\nstruct Distance\n{\n\tfloat value;\n\tvec3 color;\n};\n\nstruct Hit\n{\n\tbool is;\n\tvec3 pos, normal;\n\tvec3 color;\n};\n    \nfloat box(vec3 p, vec3 s)\n{ \n    vec3 w = abs(p) - s;\n    return min(max(w.x,max(w.y,w.z)),0.0) + length(max(w,0.0));   \n}\n    \nDistance add(Distance d1, Distance d2)\n{\n    if (d2.value > d1.value)\n        return d1;\n    else\n        return d2;\n}\n    \nDistance distance(vec3 p)\n{   \n    Distance d = Distance(box(p - vec3(0.4, 0.0, 0.0), vec3(0.02, 0.4, 0.42)), vec3(0.3, 0.7, 0.5)); \n    d = add(d, Distance(box(p + vec3(0.4, 0.0, 0.0), vec3(0.02, 0.4, 0.42)), vec3(0.3, 0.7, 0.5))); \n    d = add(d, Distance(box(p - vec3(0.0, 0.0, 0.4), vec3(0.42, 0.4, 0.02)), vec3(0.3, 0.7, 0.5))); \n    d = add(d, Distance(box(p + vec3(0.0, 0.0, 0.4), vec3(0.42, 0.4, 0.02)), vec3(0.3, 0.7, 0.5))); \n    d = add(d, Distance(box(p + vec3(0.0, 0.4, 0.0), vec3(0.4, 0.02, 0.4)), vec3(0.3, 0.7, 0.5))); \n    \n    d = add(d, Distance(box(p - vec3(0.0, 0.32, 0.0), vec3(0.36, 0.02, 0.36)), vec3(0.2, 0.3, 0.6))); \n    \n    return d;\n}\n\nDistance distance2(vec3 p)\n{    \n    \n    Distance d = Distance(box(p - vec3(0.4, 0.0, 0.0), vec3(0.02, 0.4, 0.42)), vec3(0.3, 0.7, 0.5)); \n    d = add(d, Distance(box(p + vec3(0.4, 0.0, 0.0), vec3(0.02, 0.4, 0.42)), vec3(0.3, 0.7, 0.5))); \n    d = add(d, Distance(box(p - vec3(0.0, 0.0, 0.4), vec3(0.42, 0.4, 0.02)), vec3(0.3, 0.7, 0.5))); \n    d = add(d, Distance(box(p + vec3(0.0, 0.0, 0.4), vec3(0.42, 0.4, 0.02)), vec3(0.3, 0.7, 0.5))); \n    d = add(d, Distance(box(p + vec3(0.0, 0.4, 0.0), vec3(0.4, 0.02, 0.4)), vec3(0.3, 0.7, 0.5))); \n    \n    return d;\n}\n\nHit castRay(inout vec3 p, vec3 dir)\n{\t\n\tHit hit;\n\tDistance dist = distance(p);\n\tfloat eps = 0.001;\n    bool r = false;\n    vec3 c = vec3(0.0);\n\t\n\tfor (int i = 0; i < MAX_STEPS; i++)\n\t{\n\t\tDistance dist;\n        if (r)\n            dist = distance2(p);\n        else\n            dist = distance(p);\n                \n\t\tfloat d = dist.value;\n\t\tif (abs(d) <= eps)\n\t\t{\n           \tif (!r && dist.color.b > 0.55)\n            {            \n            \tdir = refract(dir, getNormal(p, 0.001), 0.9);\n                c = dist.color;\n                r = true;\n            }\n            else\n            {\n                hit.is = true;\n                hit.pos = p;\n                hit.normal.x = distance(p + vec3(eps,0,0)).value - distance(p - vec3(eps,0,0)).value;\n                hit.normal.y = distance(p + vec3(0,eps,0)).value - distance(p - vec3(0,eps,0)).value;\n                hit.normal.z = distance(p + vec3(0,0,eps)).value - distance(p - vec3(0,0,eps)).value;\n                hit.normal = normalize(hit.normal);\n                hit.color = dist.color * (1.0 - float(i) \/ float(MAX_STEPS));\n                if (r)\n                    hit.color += c;\n                return hit;\n            }\n\t\t}\n\t\tp += dir*d;\n\t}\t\n\thit.is = false;\n\thit.color = vec3(0);\n\treturn hit;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 angle = vec2(-iMouse.x\/200.0, radians(50.0));\n    vec3 center = vec3(0.0);\n    float zoom = 2.0;\n    \n    vec3 p = vec3(cos(angle.x)*cos(angle.y), sin(angle.y), sin(angle.x)*cos(angle.y));\n\tvec2 uv = (fragCoord.xy\/* + vec2(int(iGlobalTime*30.0))*\/) \/ iResolution.yy - vec2(iResolution.x \/ iResolution.y \/ 2.0, 0.5);\n    \n    vec3 tx = vec3(-sin(angle.x), 0.0, cos(angle.x));\n    vec3 ty = vec3(-cos(angle.x)*sin(angle.y), cos(angle.y), -sin(angle.x)*sin(angle.y));\n    \n    vec3 p2 = p;\n    p = p * zoom + center;\n    \n    vec3 dir = tx * uv.x + ty * uv.y - p2;\n    \n    vec3 color = vec3(0.0);\n    vec3 light = normalize(vec3(-0.6, 0.8, -0.3));\n    \n    \n\tHit hit = castRay(p, dir);\n    \n\tif (hit.is)\n\t\tcolor = hit.color * (max(dot(hit.normal, light), 0.0) * 0.8 + 0.2);\n\telse\n\t\tcolor = vec3(0);\n\t\n    \n    fragColor = vec4(color, 1.0);\n}","name":"","description":"","type":"image"}]}}