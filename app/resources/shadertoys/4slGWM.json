{"Shader":{"ver":"0.1","info":{"id":"4slGWM","date":"1371919214","viewed":2600,"name":"enlightened dark cloud","username":"FabriceNeyret2","description":"Mouse moves the light direction.<br\/>This is a test of analytical estimation of light scattering within a thin layer. <br\/>Defaut: gradient density within a \"skin\"; no account of curvature.","likes":34,"published":3,"flags":0,"tags":["procedural","noise","cloud","scattering","smoke","subsurface","diffusion"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Mikael Lemercier & Fabrice Neyret , June, 2013\n\n#define LINEAR_DENSITY 1  \/\/ 0: constant\n#define DENS 2.           \/\/ tau.rho\n#define rad .3            \/\/ sphere radius\n#define H   .05           \/\/ skin layer thickness (for linear density)\n#define ANIM true         \/\/ true\/false\n#define PI 3.14159\n\nvec4 skyColor =     vec4(.7,.8,1.,1.);\nvec3 sunColor = 10.*vec3(1.,.7,.1);   \/\/ NB: is Energy \n\nvec2 FragCoord;\n\n\/\/ --- noise functions from https:\/\/www.shadertoy.com\/view\/XslGRr\n\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\/\/ --- End of: Created by inigo quilez --------------------\n\nvec3 noise3( vec3 p )\n{\n\tif (ANIM) p += iGlobalTime;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1345.67,0,45.67));\n    float fz = noise(p+vec3(0,4567.8,-123.4));\n    return vec3(fx,fy,fz);\n}\nvec3 fbm3( vec3 p )\n{\n\tif (ANIM) p += iGlobalTime;\n    float fx = fbm(p);\n    float fy = fbm(p+vec3(1345.67,0,45.67));\n    float fz = fbm(p+vec3(0,4567.8,-123.4));\nreturn vec3(fx,fy,fz);\n}\nvec3 perturb3(vec3 p, float scaleX, float scaleI)\n{\n    scaleX *= 2.;\n\treturn scaleI*scaleX*fbm3(p\/scaleX); \/\/ usually, to be added to p\n}\n\nfloat constantDensityTransmittance(float NDotL,float NDotO)\n{\n    return NDotL\/(DENS*(NDotL+NDotO));\n}\n\nfloat linearDensityTransmittance(float NDotL,float NDotO,float LDotO)\n{\n    if (FragCoord.y\/iResolution.y>.42)\n\t\treturn sqrt(PI\/2.) \/ sqrt(DENS\/H* NDotO\/NDotL*(NDotL+NDotO) ) ; \/\/ test1\n\telse\n     \/\/ return .15*DENS*NDotL\/(NDotL+NDotO)*sqrt(1.-LDotO*LDotO);       \/\/ test2\n\t\treturn .15*DENS*NDotL\/(NDotL+NDotO);                            \/\/ test3\n}\n\nfloat Rz=0.;  \/\/ 1\/2 ray length inside object\nvec4 intersectSphere(vec3 rpos, vec3 rdir)\n{\n    vec3 op = vec3(0.0, 0.0, 0.0) - rpos;\n    \/\/float rad = 0.3;\n  \n    float eps = 1e-5;\n    float b = dot(op, rdir);\n    float det = b*b - dot(op, op) + rad*rad;\n      \n    if (det > 0.0)\n    {\n        det = sqrt(det);\n        float t = b - det;\n        if (t > eps)\n        {\n            vec4 P = vec4(normalize(rpos+rdir*t), t);\n            Rz = rad*P.z;   \/\/ 1\/2 ray length inside object\n#if LINEAR_DENSITY    \n            \/\/ skin layer counts less\n            float dH = 1.+H*(H-2.*rad)\/(Rz*Rz);\n            if (dH>0.) \/\/ core region\n                Rz *= .5*(1.+sqrt(dH));\n            else\n                Rz *= .5*rad*(1.-sqrt(1.-Rz*Rz\/(rad*rad)))\/H;\n#endif\n            return P;\n        }\n    }\n  \n    return vec4(0.0);\n}\n\nbool computeNormal(in vec3 cameraPos, in vec3 cameraDir, out vec3 normal)\n{\n    cameraPos = cameraPos+perturb3(cameraDir,.06,1.5);\n    vec4 intersect = intersectSphere(cameraPos,cameraDir);\n    if ( intersect.w > 0.)\n    {\n        normal = intersect.xyz;\n        \/\/normal = normalize(normal+perturb3(normal,.3,30.));\n        return true;\n    }\n    return false;\n}\nfloat computeTransmittance( in vec3 cameraPos, in vec3 cameraDir, in vec3 lightDir )\n{\n    vec3 normal;\n    if ( computeNormal(cameraPos,cameraDir,normal))\n    {\n        float NDotL = clamp(dot(normal,lightDir),0.,1.);\n        float NDotO = clamp(dot(normal,cameraPos),0.,1.);\n        float LDotO = clamp(dot(lightDir,cameraPos),0.,1.);\n      \n#if LINEAR_DENSITY\n        float transmittance = linearDensityTransmittance(NDotL,NDotO,LDotO)*.5;\n#else\n        float transmittance = constantDensityTransmittance(NDotL,NDotO);\n#endif\n        return transmittance;\n    }\n\n    return -1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    FragCoord=fragCoord;\n    \n    \/\/camera\n    vec3 cameraPos = vec3(0.0,0.0,1.0);      \n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n    vec3 ww = normalize( cameraPos - cameraTarget );\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x\/ iResolution.y;\n    vec3 cameraDir = normalize( p.x*uu + p.y*vv - 1.5*ww );\n \n    \/\/light\n    float theta = (iMouse.x \/ iResolution.x *2. - 1.)*PI;\n    float phi = (iMouse.y \/ iResolution.y - .5)*PI;\n    vec3 lightDir =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));\n  \n\t\/\/ shade object\n    float transmittance = computeTransmittance( cameraPos, cameraDir, lightDir );\n\t\n\t\/\/ display: special cases\n\tif (abs(q.y-.42)*iResolution.y<.5)  fragColor = vec4(.75);\n    else if (transmittance<0.) \t\t    fragColor = skyColor;\n\telse if (transmittance>1.) \t\t    fragColor = vec4(1.,0.,0.,1.); \t\t\n\telse\n\t{ \/\/ display: object\n\t\tRz = 1.-exp(-8.*DENS*Rz);\n\t    float alpha = Rz;\n    \t\/\/fragColor = vec4(alpha); return; \/\/ for tests\n    \tvec3 frag = vec3(transmittance,transmittance,transmittance);\n   \t\tfragColor = vec4(frag*sunColor,alpha) + (1.-alpha)*skyColor;\n\t}\n\t\n    \/\/display: light\n    float d = length(vec2(lightDir)-p)*iResolution.x;\n    float Z; if (lightDir.z>0.) Z=1.; else Z=0.;\n    if (d<10.) fragColor = vec4(1.,Z,.5,1.);\n  \n    \/\/vec3 normal;\n    \/\/computeNormal(cameraPos,cameraDir, normal);\n    \/\/fragColor = vec4(normal,1.);\n}","name":"","description":"","type":"image"}]}}