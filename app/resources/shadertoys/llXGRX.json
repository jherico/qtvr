{"Shader":{"ver":"0.1","info":{"id":"llXGRX","date":"1423683852","viewed":1179,"name":"Burning Heart","username":"dnnkeeper","description":"With love to Unity 3d <img src=\"\/img\/emoticonHappy.png\"\/> <br\/>Thanks eiffie (for heart distance field function) and simesgreen (for fireball shader example).","likes":12,"published":3,"flags":0,"tags":["procedural","3d","raymarch"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"const int _VolumeSteps = 40;\nconst float _StepSize = 0.08; \nconst float _Density = 0.1;\n\nconst float _SphereRadius = 1.75;\nconst float _NoiseFreq = 1.0;\nconst float _NoiseAmp = 3.0;\nconst float _PulseAmp = 0.05;\nconst float _PulseFreq = 3.0;\nconst float _WaveLength = 0.8;\nconst float _WaveStr = 0.5;\nconst vec3 _NoiseAnim = vec3(-0.50, -1.0, 0.0);\n\n\/\/ iq's nice integer-less noise function\n\n\/\/ matrix to rotate the noise octaves\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n\nfloat sqlen(in vec3 p)\n{\n    return (p.x*p.x+p.y*p.y+p.z*p.z);\n}\n\nfloat Heart(in vec3 p)\n{\n    p = vec3(p.z,p.y,p.x);\n    float h=p.x*p.x+p.y*p.y+2.0*p.z*p.z-1.0,pyyy=p.y*p.y*p.y;\n    \/\/float v=h*h*h-(p.x*p.x-0.1*p.z*p.z)*pyyy;\/\/the messed up bit\n    float v=h*h*h-(p.x*p.x)*pyyy;\/\/the messed up bit\n    \n    vec3 g=vec3(6.0*p.x*h*h-2.0*p.x*pyyy,\n                    6.0*p.y*h*h-3.0*p.x*p.x*p.y*p.y-0.3*p.z*p.z*p.y*p.y,\n                    12.0*p.z*h*h-0.2*p.z*pyyy);\n\n    float pulse = (sin(iGlobalTime*_PulseFreq)-1.0)*4.0;\n\tpulse = pow(8.0,pulse);\n    \n    return 5.0*(v\/length(g)+pulse*_PulseAmp);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    \/\/p = m*p*2.02; f += 0.03125*abs(noise( p ));\t\n    return f;\n}\n\n\/\/ returns signed distance to surface\nfloat distanceFunc(vec3 p)\n{\t\n\tfloat d = sqlen(p) - _SphereRadius;\t\/\/ distance to sphere\n    d = min(d, sin(d*_WaveLength-iGlobalTime*_PulseFreq)+_WaveStr); \n\t\/\/d += min(d,Heart(p));\n\t\/\/ offset distance with pyroclastic noise\n\t\/\/p = normalize(p) * _SphereRadius;\t\/\/ project noise point to sphere surface\n\td += fbm(p*_NoiseFreq + _NoiseAnim*iGlobalTime) * _NoiseAmp;\n    d = min(d,Heart(p));\n\treturn d;\n}\n\n\/\/ color gradient \n\/\/ this should be in a 1D texture really\nvec4 gradient(float x)\n{\n\t\/\/ no constant array initializers allowed in GLES SL!\n\tconst vec4 c0 = vec4(2, 2, 1, 1);\t\/\/ yellow\n\tconst vec4 c1 = vec4(1, 0, 0, 1);\t\/\/ red\n\tconst vec4 c2 = vec4(0, 0, 0, 0); \t\/\/ black\n\tconst vec4 c3 = vec4(0, 0.5, 1, 0.5); \t\/\/ blue\n\tconst vec4 c4 = vec4(0, 0, 0, 0); \t\/\/ black\n\t\n\tx = clamp(x, 0.0, 0.999);\n\tfloat t = fract(x*4.0);\n\tvec4 c;\n\tif (x < 0.25) {\n\t\tc =  mix(c0, c1, t);\n\t} else if (x < 0.5) {\n\t\tc = mix(c1, c2, t);\n\t} else if (x < 0.75) {\n\t\tc = mix(c2, c3, t);\n\t} else {\n\t\tc = mix(c3, c4, t);\t\t\n\t}\n\t\/\/return vec4(x);\n\t\/\/return vec4(t);\n\treturn c;\n}\n\n\/\/ shade a point based on distance\nvec4 shade(float d)\n{\t\n\t\/\/ lookup in color gradient\n\treturn gradient(d);\n\t\/\/return mix(vec4(1, 1, 1, 1), vec4(0, 0, 0, 0), smoothstep(1.0, 1.1, d));\n}\n\n\/\/ procedural volume\n\/\/ maps position to color\nvec4 volumeFunc(vec3 p)\n{\n\tfloat d = distanceFunc(p);\n\treturn shade(d);\n}\n\n\/\/ ray march volume from front to back\n\/\/ returns color\nvec4 rayMarch(vec3 rayOrigin, vec3 rayStep, out vec3 pos)\n{\n\tvec4 sum = vec4(0, 0, 0, 0);\n\tpos = rayOrigin;\n\tfor(int i=0; i<_VolumeSteps; i++) {\n\t\tvec4 col = volumeFunc(pos);\n\t\tcol.a *= _Density;\n\t\t\/\/col.a = min(col.a, 1.0);\n\t\t\n\t\t\/\/ pre-multiply alpha\n\t\tcol.rgb *= col.a;\n\t\tsum = sum + col*(1.0 - sum.a);\t\n#if 0\n\t\t\/\/ exit early if opaque\n        \tif (sum.a > 1.0)\n            \t\tbreak;\n#endif\t\t\n\t\tpos += rayStep;\n\t}\n\treturn sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy \/ iResolution.xy)*2.0-1.0;\n    p.x *= iResolution.x\/ iResolution.y;\n\t\n    float rotx = ( iMouse.y \/ iResolution.y)*4.0;\n    float roty = -(iMouse.x \/ iResolution.x)*4.0;\n\n    float zoom = 4.0;\n\n    \/\/ camera\n    vec3 ro = zoom*normalize(vec3(cos(roty), cos(rotx), sin(roty)));\n    vec3 ww = normalize(vec3(0.0,0.0,0.0) - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    ro += rd*2.0;\n\t\n    \/\/ volume render\n    vec3 hitPos;\n    vec4 col = rayMarch(ro, rd*_StepSize, hitPos);\n    \/\/vec4 col = gradient(p.x);\n\t    \n    fragColor = col;\n}\n","name":"","description":"","type":"image"}]}}