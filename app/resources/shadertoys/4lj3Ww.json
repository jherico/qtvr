{"Shader":{"ver":"0.1","info":{"id":"4lj3Ww","date":"1430089093","viewed":2695,"name":"Ray Marching Experiment 23","username":"aiekick","description":"I wanted to explore many other pattern <img src=\"\/img\/emoticonHappy.png\"\/><br\/>Click on cell and keep down to see in full size","likes":36,"published":3,"flags":0,"tags":["ray","experiment","marching","23"],"hasliked":0},"renderpass":[{"inputs":[{"id":22,"src":"\/presets\/cube00_0.jpg","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Stephane Cuillerdier - Aiekick\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ I wanted to explore many other pattern :)\n\n\/\/ Click on cell and keep down to see in full size\n\nconst vec2 RMPrec = vec2(0.5, 0.001); \/\/ ray marching tolerance precision \/\/ low, high\nconst vec2 DPrec = vec2(1e-5, 10.); \/\/ ray marching distance precision \/\/ low, high\n    \nfloat kernelRadius = 4.5; \/\/ radius of kernel\n\nfloat sphereThick = 0.02; \/\/ thick of sphere plates\nfloat sphereRadius = 6.; \/\/ radius of sphere\n\nfloat norPrec = 0.01; \/\/ normal precision \n\nvec2 gridSize = vec2(5.,4.);\/\/grid size (columns, rows)\n\nconst int rmIter = 200;\/\/ ray march iterations\n\n\/\/ public_int_i\/ethan adding\nconst int godrayIter = 128;\nconst float godrayIntensity = .06;\nconst float godrayPrecision = .05;\n\n\/\/ light\nconst vec3 LCol = vec3(0.8,0.5,0.2);\nconst vec3 LPos = vec3(-0.6, 0.7, -0.5);\nconst vec3 LAmb = vec3( 0. );\nconst vec3 LDif = vec3( 1. , 0.5, 0. );\nconst vec3 LSpe = vec3( 0.8 );\n\n\/\/ material\nconst vec3 MCol = vec3(0.);\nconst vec3 MAmb = vec3( 0. );\nconst vec3 MDif = vec3( 1. , 0.5, 0. );\nconst vec3 MSpe = vec3( 0.6, 0.6, 0.6 );\nconst float MShi =30.;\n    \n#define mPi 3.14159\n#define m2Pi 6.28318\n\nvec2 uvs(vec3 p)\n{\n    p = normalize(p);\n    vec2 tex2DToSphere3D;\n    tex2DToSphere3D.x = 0.5 + atan(p.z, p.x) \/ (m2Pi*1.1547);\n    tex2DToSphere3D.y = 0.5 - asin(p.y) \/ (mPi*1.5);\n    return tex2DToSphere3D;\n}\n\n\/\/ Hex Pattern based on IQ Shader https:\/\/www.shadertoy.com\/view\/Xd2GR3\nfloat compute(vec2 q, vec4 m)\n{\n    vec2 pi = floor(q);\n\tvec2 pf = fract(q);\n\tfloat v = 0.;\n    if (m.w == 0.||m.w == 4.) v = mod(pi.x + pi.y, m.z);\n    if (m.w == 1.) v = mod(pi.x - pi.y, m.z);\n    if (m.w == 2.||m.w >= 5.&&m.w <= 7.) v = mod(pi.x * pi.y, m.z);\n    if (m.w == 3.) v = mod(pi.x \/ pi.y, m.z);\n    \n    float ca = step(m.x,v);\n\tfloat cb = step(m.y,v);\n    \n\tvec2  ma = vec2(0.);\n    if (m.w == 0.) ma = step(pf.xy,pf.yx);\n    if (m.w == 2.) ma = step(pf.xy,pf.yx)\/ca;\n    if (m.w == 4.) ma = step(pf.xy,pf.yx)\/cb;\n    if (m.w == 5.) ma = step(pf.xy,pf.xy);\n    if (m.w == 6.) ma = step(pf.xy,pf.yy);\n    if (m.w == 7.) ma = step(pf.xx,pf.yy);\n    \n    return dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) );\n}\nfloat cellID = 0.;\/\/global var for pilot hex func\nfloat hex(vec2 p, int i)\n{\n    p*=50.;\n    \n    vec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\t\n    float e = 0.;\n    \n    if (cellID == 0.) e = compute(q, vec4(1.,2.,0.,0.));\n    if (cellID == 1.) e = compute(q, vec4(1.,2.,1.,0.));\n   \tif (cellID == 2.) e = compute(q, vec4(1.,2.,2.,0.));\n   \tif (cellID == 3.) e = compute(q, vec4(1.,2.,3.,0.));\n   \tif (cellID == 4.) e = compute(q, vec4(1.,2.,4.,0.));\n   \tif (cellID == 5.) e = compute(q, vec4(1.,2.,5.,0.));\n   \tif (cellID == 6.) e = compute(q, vec4(3.,2.,3.,0.));\n   \tif (cellID == 7.) e = compute(q, vec4(3.,1.,3.,0.));\n    if (cellID == 8.) e = compute(q, vec4(1.,2.,2.,2.));\n   \tif (cellID == 9.) e = compute(q, vec4(1.,2.,3.,2.));\n   \tif (cellID == 10.) e = compute(q, vec4(1.,2.,3.,4.));\n   \tif (cellID == 11.) e = compute(q, vec4(1.,2.,4.,4.));\n   \tif (cellID == 12.) e = compute(q, vec4(3.,2.,3.,4.));\n   \tif (cellID == 13.) e = compute(q, vec4(1.,2.,4.,5.));\n   \tif (cellID == 14.) e = compute(q, vec4(1.,2.,5.,5.));\n   \tif (cellID == 15.) e = compute(q, vec4(1.,2.,2.,6.));\n   \tif (cellID == 16.) e = compute(q, vec4(1.,2.,3.,6.));\n    if (cellID == 17.) e = compute(q, vec4(1.,2.,4.,7.));\n   \tif (cellID == 18.) e = compute(q, vec4(1.,2.,2.,7.));\n   \tif (cellID == 19.) e = compute(q, vec4(1.,2.,3.,7.)); \t\n    \n    float hex = i==0?clamp(0.,0.2,e):1.-smoothstep(e, 0.1, 0.0);\n    \n    return hex*.2;\n}\n\nvec2 map(vec3 p)\n{\n    vec2 res = vec2(0.);\n    \n    float t = sin(iGlobalTime*.5)*.5+.5;\n    \n    float sphereOut = length(p) -sphereRadius - hex(uvs(p.xyz),0);\n    res = vec2(sphereOut, 1.);\n    \n    float sphereIn = length(p) - sphereRadius - sphereThick;\n    if (-sphereIn>res.x) \n        res = vec2(-sphereIn, 2.);\n    \n    float kernel = length(p) - kernelRadius;\n    if (kernel<res.x)\n        res = vec2(kernel,3.);\n    \n    return res;\n}\n\nvec3 nor(vec3 p, float prec)\n{\n    vec2 e = vec2(prec, 0.);\n    \n    vec3 n;\n    \n    n.x = map(p+e.xyy).x - map(p-e.xyy).x; \n    n.y = map(p+e.yxy).x - map(p-e.yxy).x; \n    n.z = map(p+e.yyx).x - map(p-e.yyx).x;  \n    \n    return normalize(n); \n}\n\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. \/ 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. \/ 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)\/255.;\n    if (Temp < 1000.) col *= Temp\/1000.;\n   \treturn col;\n}\n\nvec3 ads( vec3 p, vec3 n )\n{\n    vec3 ldif = normalize( LPos - p);\n    vec3 vv = normalize( vec3(0.) - p );\n    vec3 refl = reflect( vec3(0.) - ldif, n );\n    \n    vec3 amb = MAmb*LAmb+ blackbody(2000.);\n    vec3 dif = max(0., dot(ldif, n.xyz)) * MDif * LDif;\n    vec3 spe = vec3( 0. );\n    if( dot(ldif, vv) > 0.)\n        spe = pow(max(0., dot(vv,refl)),MShi)*MSpe*LSpe;\n    \n    return amb*1.2 + dif*1.5 + spe*0.8;\n}\n\n\/\/ thanks to public_int_i\/ethan for his adding\n\/\/ in shader https:\/\/www.shadertoy.com\/view\/MtSGzy\nvec4 god(vec4 c, vec3 ro, vec3 rd, int iter ) \n{\n    float sc = dot(ro, ro) - 48.;\n    float sb = dot(rd, ro);\n\n    float sd = sb*sb - sc;\n    float st = -sb - sqrt(abs(sd));\n\n    float r = 6.92839855;\n    if (!(sd < 0.0 || st < 0.0)) \n    {\n        float gr = 0.;\n\n        ro += rd*st;\n        \n        float rlen = r - length(ro);\n\n        for (int i = 0; i < godrayIter; i++) \n        {\n            if ( i >= iter ) break;\n            if (hex(uvs(ro),0) < .04) \n                gr+=rlen;\n            \n            ro += rd * godrayPrecision;\n            \n            rlen = r -length(ro);\n            \n            if (!(rlen > 0. && rlen < 1.)) break;\n        }\n        \n        c.xyz += LCol * godrayIntensity * gr;\n    }\n    return c;\n}\n\nvec4 scn(vec4 col, vec3 ro, vec3 rd, int iter)\n{\n    vec2 s = vec2(DPrec.x);\n    float d = 0.;\n    vec3 p = ro+rd*d;\n    vec4 c = col;\n    \n    float b = 0.35;\n    \n    float t = 1.1*(sin(iGlobalTime*.3)*.5+.6);\n    \n    for(int i=0;i<rmIter;i++)\n    {\n        if (i >= iter) break;\n    \tif(s.x<DPrec.x||s.x>DPrec.y) break;\n        s = map(p);\n        d += s.x*(s.x>DPrec.x?RMPrec.x:RMPrec.y);\n        p = ro+rd*d;\n    }\n    \n    if (s.x<DPrec.x)\n    {\n        vec3 n = nor(p, norPrec); \n      \tvec3 ray = reflect(rd, n);\n\t\t\n        if ( s.y < 1.5) \/\/ ext\n        {\n            vec3 cuberay = textureCube(iChannel0, ray).rgb * 0.5;\n            c.rgb = MCol + cuberay + pow(b, 25.);\n        }\n        else if ( s.y < 2.5) \/\/ int\n        {\n            c.rgb = ads(p,n);\n        }\n        else if ( s.y < 3.5) \/\/ kernel\n        {\n            float b = dot(n,normalize(ro-p))*0.8;\n            c = (b*vec4(blackbody(2000.),0.2)+pow(b,0.2))*(1.0-d*.01);\n        }\n    }\n    else\n    {\n       \tc = textureCube(iChannel0, rd);\n    }\n    \n    return c;\n}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cu, vec3 org, float persp)\n{\n\tvec3 rorg = normalize(org-ro);\n    vec3 u =  normalize(cross(cu, rorg));\n    vec3 v =  normalize(cross(rorg, u));\n    vec3 rd = normalize(rorg + u*uv.x + v*uv.y);\n    return rd;\n}\n\/\/\/\/\/ FROM https:\/\/www.shadertoy.com\/view\/4lj3zy \/\/\/\n\/\/ virtual 2d array :\n\/\/sx = count cell for x axis of the virtual 2d array (matrice2)\n\/\/ID(cx,cy) = cy*sx+cx\n\/\/cx(ID) = ID modulo sx\n\/\/cy(ID) = (ID-cx)\/sx\n\nfloat EncID(vec2 s, vec2 h, vec2 sz) \/\/ encode id from coord \/\/ s:screenSize \/ h:pixelCoord \/ sz=gridSize\n{\n    float cx = floor(h.x\/(s.x\/sz.x));\n    float cy = floor(h.y\/(s.y\/sz.y));\n    return cy*sz.x+cx;\n}\nvec2 DecID(float id, vec2 sz) \/\/ decode id to coord \/\/ id:cellId \/ sz=gridSize\n{\n    float cx = mod(float(id), sz.x);\n    float cy = (float(id)-cx)\/sz.x;\n    return vec2(cx,cy);\n}\nvec3 getcell(vec2 s, vec2 h, vec2 sz) \/\/ return id \/ uv \/\/ s:screenSize \/ h:pixelCoord \/ sz=gridSize\n{\n    float cx = floor(h.x\/(s.x\/sz.x));\n    float cy = floor(h.y\/(s.y\/sz.y));\n    \n    float id = cy*sz.x+cx;\n    \n    vec2 size = s\/sz;\n    float ratio = size.x\/size.y;\n    vec2 uv = (2.*(h)-size)\/size.y - vec2(cx*ratio,cy)*2.;\n    uv*=1.5;\n    \n    return vec3(id, uv);\n}\n\/\/\/\/\/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 s = iResolution.xy;\n    vec2 g = fragCoord.xy;\n    vec2 uv = (2.*g-s)\/s.y;\n    vec2 m = iMouse.xy;\n    \n    float t = iGlobalTime*0.2;\n    float ts = sin(t)*.5+.5;\n    \n    float axz = -t; \/\/ angle XZ\n    float axy = .8; \/\/ angle XY\n    float cd = 7.5;\/\/*ts; \/\/ cam dist to scene origine\n    \n    float ap = 1.; \/\/ angle de perspective\n    vec3 cu = vec3(0.,1.,0.); \/\/ cam up \n    vec3 org = vec3(0., 0., 0.); \/\/ scn org\n    vec3 ro = vec3(cos(axz),sin(axy),sin(axz))*cd; \/\/ cam org\n   \n    vec4 c = vec4(0.,0.,0.,1.); \/\/ col\n    \n    \/\/ reduce iter for keep good fps in preview cell mode\n    int scnIter = rmIter\/3;\n    int godIter = godrayIter\/3;\n\n    vec3 cell = getcell(s,g,gridSize);\n    if(iMouse.z>0.) \n    {\n        cell.x = EncID(s,m,gridSize);\n        cell.yz = uv;\n        scnIter=rmIter;\/\/set scnIter to rmIter (max) for good render\n        godIter=godrayIter;\/\/set godIter to godrayIter (max) for good render\n    }\n    \n    cellID = cell.x; \/\/ global var for hex pattern\n    \n    vec3 rd = cam(cell.yz, ro, cu, org, ap);\n    \n    c = scn(c, ro, rd, scnIter);\n    \n    c = god(c, ro, rd, godIter);\/\/god rays\n    \n    fragColor = c;\n}\n","name":"","description":"","type":"image"}]}}