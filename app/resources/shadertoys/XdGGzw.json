{"Shader":{"ver":"0.1","info":{"id":"XdGGzw","date":"1453602837","viewed":132,"name":"First Raymarches","username":"cacheflowe","description":"My first real attempt at drawing with raymarching functions. Thanks to everybody who helps beginners like me understand this stuff <img src=\"\/img\/emoticonHappy.png\"\/>","likes":3,"published":3,"flags":0,"tags":["raymarching","hexagons"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define ITERATIONS 128\n\nfloat sdHexPrism( vec3 p, vec2 h ) {\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat opRep( vec3 p, vec3 spacing ) {\n    vec3 q = mod(p, spacing) - 0.5 * spacing;\n    return sdHexPrism( q, vec2( 0.2 + 0.1 * cos(iGlobalTime\/2.), 1.0 + 0.9 * sin(3.14 + iGlobalTime\/2.) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ 1 : retrieve the fragment's coordinates\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    uv -= vec2(0.5, 0.5);\n\n\t\/\/ 2 : camera position and ray direction\n\t\/\/ vec3 pos = vec3( sin(iGlobalTime), 0, sin(iGlobalTime) * 5. );\n\tvec3 pos = vec3( sin(iGlobalTime), 0, iGlobalTime \/ 20. );\n\tvec3 dir = normalize( vec3( uv, 1. ) );\n \n\t\/\/ 3 : ray march loop\n    \/\/ ip will store where the ray hits the surface\n\tvec3 ip;\n \n\t\/\/ variable step size\n\tfloat t = 0.0;\n\tfloat findThresh = 0.001;\n\tint found = 0;\n    int last_i = 0;\n    \n\tfor(int i = 0; i < ITERATIONS; i++) {\n\t\tlast_i = i;\n        \n        \/\/update position along path\n        ip = pos + dir * t;\n \n        \/\/gets the shortest distance to the scene\n        \/\/break the loop if the distance was too small\n        \/\/this means that we are close enough to the surface\n \t\tfloat temp;\n\n\t\t\/\/ make a repeating SDF shape\n\t\ttemp = opRep( ip, vec3(2.5 + 2.0 * sin(iGlobalTime\/2.) ) );\n\t\tif( temp < findThresh ) {\n\t\t\tfloat r = 0.7 + 0.3 * sin(ip.z\/8. + ip.x\/2.);\n\t\t\tfloat g = 0.6 + 0.3 * cos(ip.z\/8. + ip.y\/2.);\n\t\t\tfloat b = 0.5 + 0.4 * sin(ip.z\/8. + ip.x);\n\t\t\tip = vec3(r, g, b);\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t\/\/increment the step along the ray path\n\t\tt += temp;\n\t}\n\t\n\t\/\/ make background black if no shape was hit\n\tif(found == 0) {\n\t\tip = vec3(0,0,0);\n\t}\n \n\t\/\/ 4 : apply color to this fragment\n    \/\/ subtract from color as distance increases\n\tfragColor = vec4(ip - float(last_i) \/ float(ITERATIONS), 1.0 );\n}","name":"","description":"","type":"image"}]}}