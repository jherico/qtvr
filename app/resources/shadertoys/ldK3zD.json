{"Shader":{"ver":"0.1","info":{"id":"ldK3zD","date":"1453580231","viewed":140,"name":"distance meter","username":"cupe","description":"scale-invariant distance meter for SDFs. paint this onto a plane to sweep through your geometry.<br\/>black isolines are drawn at all powers of 10","likes":3,"published":3,"flags":0,"tags":["distancefield","sdf","tool","debugging"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/\n\/\/ scale-invariante distance meter\n\/\/\n\/\/ be less confused by your distances!\n\/\/\n\/\/ (as seen in the screenshots on http:\/\/mercury.sexy\/hg_sdf\/)\n\/\/\n\/\/ tries to paint a plane in useful colors. outputs HDR colors, so can easily\n\/\/ be integrated into your existing rendering without looking bad. \n\/\/\n\/\/\n\n\/\/ constants and stuff\n\n#define PI acos(-1.)\n#define INFINITY pow(2.,8.)\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0.))) + vmax(min(d, vec3(0.)));\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n\n\/\/ the actual SDF:\nfloat f (vec3 p) {\n    p.z += 1.0;\n    float sphere = length(p) - 1.;   \n    float box = fBox(p - vec3(1.0,0.0,1.0), vec3(1.0,1.0,1.0));\n    \n    return max(-sphere,box);\n}\n\n\/\/ tone mapping stolen from zavie's shader\nvec3 Uncharted2ToneMapping(vec3 color) {\n\tfloat A = 0.15;\n\tfloat B = 0.50;\n\tfloat C = 0.10;\n\tfloat D = 0.20;\n\tfloat E = 0.02;\n\tfloat F = 0.30;\n\tfloat W = 11.2;\n\tfloat exposure = 2.;\n\tcolor *= exposure;\n\tcolor = ((color * (A * color + C * B) + D * E) \/ (color * (A * color + B) + D * F)) - E \/ F;\n\tfloat white = ((W * (A * W + C * B) + D * E) \/ (W * (A * W + B) + D * F)) - E \/ F;\n\tcolor \/= white;\n\treturn color;\n}\n\n\/\/\n\/\/ interesting part starts here\n\/\/\n\/\/ the meter uses the \"fusion\" gradient, which goes from dark magenta (0) to white (1)\n\/\/ (often seen in heatmaps in papers etc)\n\/\/\n\nvec3 fusion(float x) {\n\tfloat t = clamp(x,0.0,1.0);\n\treturn clamp(vec3(sqrt(t), t*t*t, max(sin(PI*1.75*t), pow(t, 12.0))), 0.0, 1.0);\n}\n\n\/\/ HDR version\nvec3 fusionHDR(float x) {\n\tfloat t = clamp(x,0.0,1.0);\n\treturn fusion(sqrt(t))*(0.5+2.*t);\n}\n\n\n\/\/\n\/\/ distance meter function. needs a bit more than just the distance\n\/\/ to estimate the zoom level that it paints at.\n\/\/\n\/\/ if you have real opengl, you can additionally use derivatives (dFdx, dFdy)\n\/\/ to detect discontinuities, i had to strip that for webgl\n\/\/\n\/\/ visualizing the magnitude of the gradient is also useful\n\/\/\n\nvec3 distanceMeter(float dist, float rayLength, vec3 rayDir, float camHeight) {\n    float idealGridDistance = 20.0\/rayLength*pow(abs(rayDir.y),0.8);\n    float nearestBase = floor(log(idealGridDistance)\/log(10.));\n    float relativeDist = abs(dist\/camHeight);\n    \n    float largerDistance = pow(10.0,nearestBase+1.);\n    float smallerDistance = pow(10.0,nearestBase);\n\n   \n    vec3 col = fusionHDR(log(1.+relativeDist));\n    col = max(vec3(0.),col);\n    if (sign(dist) < 0.) {\n        col = col.grb*3.;\n    }\n\n    float l0 = (pow(0.5+0.5*cos(dist*PI*2.*smallerDistance),10.0));\n    float l1 = (pow(0.5+0.5*cos(dist*PI*2.*largerDistance),10.0));\n    \n    float x = fract(log(idealGridDistance)\/log(10.));\n    l0 = mix(l0,0.,smoothstep(0.5,1.0,x));\n    l1 = mix(0.,l1,smoothstep(0.0,0.5,x));\n\n    col.rgb *= 0.1+0.9*(1.-l0)*(1.-l1);\n    return col;\n}\n\n\n\/\/\n\/\/ interesting part ends here\n\/\/\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 screenCoord = (-iResolution.xy + 2.0*fragCoord.xy)\/iResolution.y;\n    vec2 m = iMouse.xy\/iResolution.xy;\n\n    float camDolly = iMouse.z>0.?m.y:(0.5+0.5*sin(iGlobalTime*0.5));\n    float camRotation = iMouse.z>0.?m.x*-5.:(0.2*iGlobalTime);\n    vec3 cam_pos = vec3(0.0,1.0,1.4) * pow(10., camDolly*4. - 2.0);\n    vec3 cam_dir = normalize(vec3(0.0,-0.8,-1.0));\n    vec3 cam_up = normalize(vec3(0.0,1.0,-0.8));\n    \n    pR(cam_up.xz,camRotation);\n    pR(cam_dir.xz,camRotation);\n    pR(cam_pos.xz,camRotation);\n    \n    float cam_fov = 45.0;\n    vec3 u = cross(cam_dir, cam_up);\n\tvec3 v = cam_up;\n\tvec3 w = -cam_dir;\n\n\tvec3 o = cam_pos;\n\t\n\tvec3 d = vec3(screenCoord, -1.0\/tan(cam_fov*PI\/360.0));\n    d = normalize(((mat3(u, v, w)) * d));\n    \n    float t = INFINITY;\n    if (d.y < 0.) {\n\t\tt = (o.y)\/-d.y;\n\t}\n   \n    vec3 p = d*t + o;\n    \n    float dist = f(p);\n    \n    vec3 col = distanceMeter(dist, t, d, cam_pos.y);\n    \n    col = Uncharted2ToneMapping(col);\n    \n    fragColor = vec4(pow(col, vec3(1.\/2.2)), 1.0 );\n}","name":"","description":"","type":"image"}]}}