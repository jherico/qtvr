{"Shader":{"ver":"0.1","info":{"id":"Mdf3Dr","date":"1367336643","viewed":1862,"name":"Outrun","username":"reinder","description":"Just a quick one. Please don't look at the source of this shader <img src=\"\/img\/emoticonHappy.png\"\/> The math is a mess and full of magical numbers and physical incorrect","likes":34,"published":3,"flags":0,"tags":["raycasting","outrun"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Outrun. Created by Reinder Nijhoff 2013\n\/\/ @reindernijhoff\n\/\/\n\/\/ https:\/\/www.shadertoy.com\/view\/Mdf3Dr\n\/\/\n\n\/\/ DON'T LOOK AT THE MATH!!!\n\n#define MAXDISTANCE 10000.\n#define TRACKSVISIBLE 10\n#define SEGMENTSPERTRACK 10\n#define SECONDSPERTRACK 0.97\n#define TRACKLENGTH 200.\n\nfloat time = iGlobalTime;\n\n\/\/\n\/\/ math functions\n\/\/\n\nfloat hash( float n ) {\n\treturn fract(sin(n)*43758.5453);\n}\nfloat noise(in float x) {\n\tfloat p = floor(x);\n\tfloat f = fract(x);\n\t\t\n\tf = f*f*(3.0-2.0*f);\t\n\treturn mix( hash(p+  0.0), hash(p+  1.0),f);\n}\nfloat crossp( vec2 a, vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n\/\/\n\/\/ intersection functions\n\/\/\n\nvoid intersectSegment(const vec3 ro, const vec3 rd, const vec2 a, const vec2 b, out float dist, out float u) {\n\tdist = MAXDISTANCE;\n\tvec2 p = ro.yz;\n\tvec2 r = rd.yz;\n\tvec2 q = a-p;\n\tvec2 s = b-a;\n\tfloat rCrossS = crossp(r, s);\n\t\n\tif( rCrossS == 0.){\n\t\treturn;\n\t}\n\tfloat t = crossp(q, s) \/ rCrossS;\n\tu = crossp(q, r) \/ rCrossS;\n\t\n\tif(0. <= t && 0. <= u && u <= 1.){\n\t\tdist = t;\n\t}\n}\n\nfloat trackAngle( float s ) {\n\treturn (2.*noise( s*0.1 )-1.)*2.;\n}\nfloat trackHeight( float s ) {\n\treturn 500.*noise( s*0.2 );\n}\n\nfloat traceTrack( vec3 ro, vec3 rd, out vec2 texcoord ) {\n\tfloat dist = MAXDISTANCE, dtest, xdist, zdist = MAXDISTANCE;\n\tfloat utest;\n\t\n\tfloat tf = time \/ SECONDSPERTRACK;\n\tfloat starttrack = floor(tf);\n\tfloat fracttrack = fract(tf);\n\t\n\tfloat z = -fracttrack*TRACKLENGTH;\n\t\n\tfloat sa = trackAngle( tf );\n\t\t\n\tfor( int it=0; it<TRACKSVISIBLE; it++) {\n\t\tfloat t = float(it)+starttrack;\n\t\t\t\n\t\tfor( int is=0; is<SEGMENTSPERTRACK; is++ ) {\t\t\t\n\t\t\tfloat dt = float(is)\/float(SEGMENTSPERTRACK);\n\t\t\tintersectSegment( ro, rd, vec2( trackHeight( t+dt ), z ), \n\t\t\t\t\t\t\t vec2( trackHeight( t+dt+(1.\/float(SEGMENTSPERTRACK)) ), z+(TRACKLENGTH\/float(SEGMENTSPERTRACK))), dtest, utest );\n\t\t\tif( dtest < dist ) {\n\t\t\t\tdist = dtest;\n\t\t\t\ttexcoord.y = utest;\n\t\t\t\txdist = ro.x+rd.x*dist;\n\t\t\t\tzdist = ro.z+rd.z*dist;\n\t\t\t\ttexcoord.x = xdist + 2.*zdist*sin( trackAngle(t+dt+(utest\/float(SEGMENTSPERTRACK)))-sa );\n\t\t\t}\n\t\t\tz+=(TRACKLENGTH\/float(SEGMENTSPERTRACK));\n\t\t}\n\t}\n\treturn zdist;\n}\n\nvec3 trackColor( vec2 texcoord ) {\n\tif( abs(texcoord.x)<50. ) { \/\/ road\n\t\tif(texcoord.y>0.5) {\n\t\t\treturn abs(texcoord.x)>46.?vec3(1.):vec3( 146.\/255. );\n\t\t} else {\n\t\t\treturn mod(texcoord.x, 22.)<1.5?vec3(1.):vec3( 154.\/255. );\n\t\t}\n\t} else { \/\/ desert\n\t\treturn (texcoord.y>0.5)?vec3( 235.\/255., 219.\/255., 203.\/255. )\n\t\t\t:vec3( 227.\/255., 211.\/255., 195.\/255. );\n\t}\n}\nvec3 skyColor( vec2 texcoord ) {\n\tvec3 col = vec3( 0.\/255., 146.\/255., 255.\/255.);\n\tfloat n = noise( texcoord.x )*texcoord.y*10.+texcoord.y*4.;\n\tn += noise( texcoord.x * 10. );\n\tif( n < 1. ) col = mix(\n\t\tvec3( 170.\/255., 154.\/255., 138.\/255.),\n\t\tvec3( 235.\/255., 219.\/255., 203.\/255. ), clamp(texcoord.y*16., 0., 1.) );\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 q = fragCoord.xy\/iResolution.xy;\n\tvec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x\/iResolution.y;\n\n\tvec3 ro = vec3( -20.*sin(trackAngle(time\/SECONDSPERTRACK)), 10.+trackHeight(time\/SECONDSPERTRACK), -14. );\n\tvec3 rd = normalize( vec3( p, 1. ) );\t\n\tvec3 color = vec3( 0. );\n\t\n\tvec2 texcoord;\n\tfloat d =  traceTrack( ro, rd, texcoord );\n\tif( d < MAXDISTANCE ) {\n\t\tcolor = mix( trackColor( texcoord ), vec3( 170.\/255., 154.\/255., 138.\/255.), d\/(float(TRACKSVISIBLE)*TRACKLENGTH));\n\t} else {\n\t\tif( rd.y > 0. ) {\n\t\t\tcolor = skyColor( vec2( p.x-2.*trackAngle(time\/SECONDSPERTRACK), p.y) );\n\t\t} else {\n\t\t\tcolor = vec3( 170.\/255., 154.\/255., 138.\/255.);\n\t\t}\n\t}\n\t\n\tfragColor = vec4( clamp(color, 0., 1.),1.0);\n}","name":"","description":"","type":"image"}]}}