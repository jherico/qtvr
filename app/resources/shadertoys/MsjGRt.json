{"Shader":{"ver":"0.1","info":{"id":"MsjGRt","date":"1392933372","viewed":2553,"name":"[NV15] Invader's","username":"iapafoto","description":"Try to make a short animation with various sequences, objects, effects, movements, materials and textures<br\/>[Mouse] Control camera angle<br\/>(code is not cleaned for the moment)","likes":25,"published":3,"flags":0,"tags":["texture","space","planet","animation","invaders"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by sebastien durand - 01\/2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ ------------------------------------------------------------------------------\n\/\/ Deep Space \n\/\/ Star Nest by Kali\n\/\/ https:\/\/www.shadertoy.com\/view\/4dfGDM\n\/\/ ------------------------------------------------------------------------------\n\/\/ Metal effect\n\/\/ Exterminate! by Antonalog\n\/\/ https:\/\/www.shadertoy.com\/view\/ldX3RX\n\/\/ Blue Spiral by donfabio\n\/\/ ------------------------------------------------------------------------------\n\/\/ Spiral effect\n\/\/ BLue Spiral by donfabio\n\/\/ https:\/\/www.shadertoy.com\/view\/lds3WB\n\n\/\/#define ANTIALIASING\n\/\/ Anti-Aliasing Level\n#define AA 3\n\n\n#define NB_ITER 64\n#define PI 3.14159265359\n#define TAO 6.28318531\n#define MAX_DIST 4000.\n#define PRECISION .0001\n\n#define PLANET 200.\n#define SHIP_GLOB 103.\n#define SHIP_HUBLOT 104.\n#define SHIP_TOP 500.\n#define SHIP_BOTTOM 501.\n#define SHIP_SIDE 502.\n#define SHIP_ARM 505.\n#define FLAG 300.\n\n#define COS cos\n#define SIN sin\n#define ATAN atan\n\n\nconst vec2 V01 = vec2(0,1);\nconst vec2 Ve = V01.yx*.001;\nvec3 L = normalize(vec3(10.25,.33,-.7));\n\nconst mat2 Rot1 = mat2(0.54030230586, 0.8414709848, -0.8414709848, 0.54030230586);\n\nfloat C1,S1, C2, S2, time; \n\nint AnimStep = 0;\nbool withPlanet = true;\n\n\/\/ 0.1% error - enough for animations\nfloat sin_(in float x) {\n\tx = mod(PI+x,2.*PI) - PI;\n\tfloat s = x*(1.27323954 - .4052847345*abs(x));\n\treturn s*(.776 + .224*abs(s));\n}\n\n\/\/ 0.1% error - enough for animations\nfloat cos_(in float x) {\n\treturn sin_(x+PI*.5);\n}\n\/*\nfloat atan2_(float y, float x) {\n  float t0, t1, t2, t3, t4;\n  t3 = abs(x);\n  t1 = abs(y);\n  t0 = max(t3, t1);\n  t1 = min(t3, t1);\n  t3 = float(1) \/ t0;\n  t3 = t1 * t3;\n  t4 = t3 * t3;\n  t0 =         - .013480470;\n  t0 = t0 * t4 + .057477314;\n  t0 = t0 * t4 - .121239071;\n  t0 = t0 * t4 + .195635925;\n  t0 = t0 * t4 - .332994597;\n  t0 = t0 * t4 + .999995630;\n  t3 = t0 * t3;\n  t3 = (abs(y) > abs(x)) ? 1.570796327 - t3 : t3;\n  t3 = (x < 0.) ?  3.141592654 - t3 : t3;\n  return (y < 0.) ? -t3 : t3;;\n}\n*\/\n\n\/\/ k : [0..1]\nfloat steps(in float x, in float k) {\n\tfloat fr = fract(x);\n\treturn floor(x)+(fr<k?0.:(fr-k)\/(1.-k));\n}\n\nfloat pyramid(in float x) {\n\tfloat fr = fract(x*.5+1.\/16.);\n\treturn clamp(4.*min(fr,1.-fr)-1.,-.75,.75);\n}\n\nfloat Noise(in vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D( iChannel0, (uv+ 0.5)\/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat Noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn texture2D( iChannel0, (uv+118.4)\/256.0, -100.0 ).x;\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)\/k, 0.0, 1.0 );\n    return mix(b, a, h ) - k*h*(1.0-h);\n}\n\nfloat Kaleido(inout vec2 v, in float nb){\n\tfloat id=floor(.5+ATAN(v.x,-v.y)*nb\/TAO);\n\tfloat a = id*TAO\/nb;\n\tfloat ca = COS(a), sa = SIN(a);\n\tv*=mat2(ca,sa,-sa,ca);\n\treturn id;\n}\n\nvec2 Kaleido2(inout vec3 p, in float nb1, in float nb2, in float d) {\n\tfloat id1 = Kaleido(p.yx, nb1);\n\tfloat id2 = Kaleido(p.xz, nb2*2.);\n\tp.z+=d;\t\n\treturn vec2(id1,id2);\n}\n\nvec2 minObj(vec2 o1, vec2 o2) {\n\treturn o1.x<o2.x?o1:o2;\n}\n\nvec2 sminObj(vec2 o1, vec2 o2, float k) {\n\tfloat d = smin(o1.x, o2.x, k);\n\treturn vec2(d, o1.x<o2.x?o1.y:o2.y);\n}\n\nvec2 maxObj(vec2 o1, vec2 o2) {\n\treturn o1.x>o2.x?o1:o2;\n}\n\nconst vec3 \n\tCOLOR_GLOBE1 = vec3(.1,.1,.1),\n\tCOLOR_GLOBE2 = vec3(.1,2.,2.),\n\tCOLOR_HUBLOT = vec3(.2,.2,.2),\n\tCOLOR_SIDE = vec3(.0,9.0,9.0);\n\t\n\/\/ ------------------------------------------------------------------------------\n\/\/ Spiral texture\n\/\/ Blue Spiral by donfabio\n\/\/ https:\/\/www.shadertoy.com\/view\/lds3WB\nfloat textureSpiral(vec2 uv) {\n\tfloat angle = ATAN(uv.y, uv.x),\n\tshear = length(uv),\n\tblur = 0.5;\n\treturn smoothstep(-blur, blur, cos_(8.0 * angle + 200.0 * time - 12.0 * shear));\n}\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r1, float r2) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - mix(r1,r2,h);\n}\n\nfloat textureInvader(vec2 uv) {\n\tfloat y = 7.-floor((uv.y)*16.+4.);\n\tif(y < 0. || y > 7.) return 0.;\n\tfloat x = floor((abs(uv.x))*16.);\n\/\/\tif(x < 0. || x > 14.) return 0.;\n\tfloat v=(y>6.5)? 6.:(y>5.5)? 40.:(y>4.5)? 47.:(y>3.5)? 63.:\n\t\t\t(y>2.5)? 27.:(y>1.5)? 15.:(y>0.5)? 4.: 8.;\n\treturn floor(mod(v\/pow(2.,x), 2.0)) == 0. ? 0.: 1.;\n}\n\nvec4 DEFlag(vec3 p) {\n    vec3 ba = vec3(1.5,0,0);\n    float h = clamp( dot(p,ba)\/dot(ba,ba), 0.0, 1.0 );\n    vec2 d = vec2(length( p - ba*h ) - .02, 1.);\n\tp.y -= .4;\n\tp.x -= 1.2;\n\tfloat box = length(max(abs(p)-vec3(.3,.4,.005),0.));\n\td = min(vec2(box, FLAG), d);\n\treturn vec4(d.x, FLAG, p.y, p.x);\n}\n\n\nfloat DEAlienArm(vec3 p0) {\n\tvec3 p = p0;\n\tp.x = -p.x;\n\tfloat d = MAX_DIST;\n\tfloat dy, dx = abs(C1);\n\tdx = clamp(dx,0.,.8);\n\tdy = .5*sqrt(1.-dx*dx);\n\tp.x-=dx;\n\tfloat x = dx;\n\tp = abs(p);\n\td = min(d, sdCapsule(p, vec3(x-dx,0,-dy), vec3(x, 0,dy),.01,.01));\n\td = min(d, sdCapsule(p, vec3(x,.04,-dy), vec3(x-dx,.04,dy),.01,.01));\n\td = min(d, length(p.xz+vec2(x-dx,-dy))-.05);\n\td = min(d, length(p.xz+vec2(-x,-dy))-.05);\n\tx+=dx;\n\td = min(d, sdCapsule(p, vec3(x-dx,0,-dy), vec3(x-dx*.5, 0,0),.01,.01));\n\td = min(d, sdCapsule(p, vec3(x-dx*.5,.04,.04), vec3(x-dx,.04,dy),.01,.01));\n\td = max(p.y-.06,max(-p.y+.005,d));\n\treturn d;\n}\n\n\nvec4 DEAlien(vec3 p0) {\n\tvec3 p=p0;\n\tvec2 d = minObj(vec2(length(p+vec3(-.125,0,0))-.75, SHIP_GLOB),\n\t\t\t\t\tvec2(length(p+vec3(1.6,0,0))-2., SHIP_TOP));\n\tp.yz = -abs(p.yz);\n\tp.yz+= .7;\n\td = minObj(vec2(length(p)-.24, SHIP_GLOB),d);\n\td = maxObj(vec2(length(p0-vec3(1.6,0,0))-2.,SHIP_BOTTOM),d);\n\tp.x+= .1;\n\tp.yz = -abs(p.yz);\n\tp.y+= .3;\n\tp.z+=.3;\n\td = maxObj(vec2(length(p0)-1.15, SHIP_SIDE), sminObj(vec2(length(p)-.2,SHIP_BOTTOM), d, .1));\n\n\tfloat r=0.;\n\tif (AnimStep >= 6) {\n\t\tr = 0.; \/\/.05*(1.-clamp(0.,1.,time-7.25));\n\t} else if (AnimStep >= 3) { \/\/ ouverture du panneau\n\t\tr = .05*clamp(0.,1.,time-5.25);\n\t}\n\tif (r>0.) {\n\t\tfloat dd = length(max(abs(p0+vec3(.35,0,0))-vec3(r,r,9.*r),0.))-r;\n\t\td = maxObj(vec2(-dd,SHIP_SIDE), d); \n\t}\n\tif (AnimStep == 4 || AnimStep == 5) {\n\t\tp0.x += .2;\n\t\td = minObj(vec2(DEAlienArm(p0), SHIP_ARM), d);\n\t}\n\t\n\treturn vec4(d.x,d.y, p0.yz);\n}\n\nfloat DECrater(vec3 p) {\n\tfloat d = MAX_DIST;\n\tvec2 id = Kaleido2(p, 9.,6.,2.);\n\tfloat noise = Noise(id*10.);\n\tif (noise<.6 && abs(id.y)>0.&&abs(id.y)<6.-1.) {  \n\t\td = sdCapsule(p, vec3(0,0,-.15), vec3(0,0,.1),.1+noise*.2,.1+noise*.5);\n\t\td = max(-(length(p-vec3(0,0,-.25))-(.1+noise*.5)),d);\n\t\td = max(-(length(p-vec3(0,0,-.05))-(.1+noise*.15)),d);\n\t\td*=.8;\n\t}\n\treturn d;\n}\n\nbool intersectSphere(in vec3 ro, in vec3 rd, in vec3 c, in float r) {\n    ro -= c;\n\tfloat b = dot(rd,ro), d = b*b - dot(ro,ro) + r*r;\n\treturn (d>0. && -sqrt(d)-b > 0.);\n}\n\n\/\/ vec4 : distance \/ id (object) \/ uv (texture) \nvec4 DE(vec3 p0) {\n\tfloat scalePlanet = 10.,\n\t\t  scaleFlag = 2.,\n\t\t  scaleAlien = .5;\n\tvec4 res = vec4(1000);\t\n\tvec3 p = p0;\n    float d,d1,dx;\n\n\/\/    if (withPlanet) {\n\tp = p0;\n\tp.x+=2.;\n\tp*=scalePlanet;\n\tp.yz *= Rot1;\n\tp.xz *= mat2(C2,S2,-S2,C2);\n    if (withPlanet) {    \n\td1 = DECrater(p);\n\/\/ Much better but cannot be render with the full scene in my computer\n\/\/\tp.xz *= Rot1;\n\/\/\tp.xy *= Rot1;\n\/\/\tfloat d2 = DECrater(p);\n\td = smin(length(p)-2.,d1,.15); \/\/smin(d2, d1,.2),.15);\n\n\td += .1*Noise((p)*2.);\n\td += .005*Noise((p)*20.);\n\tres = vec4(d\/=scalePlanet,PLANET, length(p), p.z);\n\t\n    }\n    \n\tif (AnimStep >= 4) {\n\t\tdx = abs(C1);\n\t\tdx = clamp(dx,.1,.8);\n\t\t\n\t\tif (AnimStep == 4) {\n\t\t\tp = p0;\n\t\t\tp.x += (2.5*dx\/scaleAlien) - 2.1;\n\t\t} else {\n\t\t\tp \/= scalePlanet;\n\t\t\t\/\/p.x-=1.;\n\t\t}\n\t\tp = p*scaleFlag;\n\t\tvec4 dFlag = DEFlag(p);\n\t\tdFlag.x \/= scaleFlag;\n\t\tres = (dFlag.x<res.x) ? dFlag: res;\n\t}\n\t\n\tif (AnimStep > 1 && AnimStep < 7) {\n\t\tp = p0;\n\t\tif (AnimStep < 3) {\n\t\t\tp.x -= 3.2-steps(10.*(.038+time-5.25),.75);\n\t\t\tp.z -= 2.* \/*floor*\/(5.*pyramid(10.*(.038+time-5.25)));\n\t\t} else if(AnimStep>5) {\n\t\t\tp.x -= 3.2-steps(10.*(.038+6.75-time),.75);\n\t\t\tp.z -= 2.* \/*floor*\/(5.*pyramid(10.*(.038+6.75-time)));\n\t\t} else {\n\t\t\tp.x-=3.2;\n\t\t}\n\t\tp*=scaleAlien;\n\t\tvec4 dAlien = DEAlien(p);\n\t\tdAlien.x\/=scaleAlien;\n\t\tres = (dAlien.x<res.x) ? dAlien: res;\n\t}\n\treturn res;\n}\n\nvec3 N(in vec3 p) {\n    vec2 e = vec2(Ve.x, -Ve.x); \n    return normalize(e.xyy * DE(p + e.xyy).x + e.yyx * DE(p + e.yyx).x + e.yxy * DE(p + e.yxy).x + e.xxx * DE(p + e.xxx).x);;\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k) {\n\tfloat res = 1.0, h, t = mint;\n    for( int i=0; i<20; i++ ) {\n\t\th = DE( ro + rd*t ).x;\n\t\tres = min( res, k*h\/t );\n                if( res<0.0001 ) break;\n\t\tt += 0.02;\n    }\n    return clamp(res, 0., 1.);\n}\n\n\/\/ ------------------------------------------------------------------------------\n\/\/ Deep Space \n\/\/ Star Nest by Kali\n\/\/ https:\/\/www.shadertoy.com\/view\/4dfGDM\n\n#define iterations 17\n#define formuparam 0.53\n#define volsteps 10\n#define stepsize 0.1\n#define tile   0.850\n#define brightness 0.0015\n#define darkmatter 1.500\n#define distfading .530\n#define saturation 0.650\n\nvec4 space(vec3 rd)\n{\n\tvec3 dir=rd;\n\tvec3 from=vec3(1.,.5,0.5);\n\n\t\/\/volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); \/\/ tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)\/dot(p,p)-formuparam; \/\/ the magic formula\n\t\t\ta+=abs(length(p)-pa); \/\/ absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); \/\/dark matter\n\t\ta*=a*a; \/\/ add contrast\n\t\tif (r>6) fade*=1.-dm; \/\/ dark matter, don't render near\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; \/\/ coloring based on distance\n\t\tfade*=distfading; \/\/ distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); \/\/color adjust\n\treturn vec4(v*.01,1.);\t\n}\n\n\/\/ ------------------------------------------------------------------------------\n\/\/ Metal effect\n\/\/ Exterminate! by Antonalog\n\/\/ https:\/\/www.shadertoy.com\/view\/ldX3RX\nfloat one_pi = 0.31830988618;\nfloat lightIntensity = 1.0;\n\nvec3 rho_d = vec3(0.147708, 0.0806975, 0.033172);\nvec3 rho_s = vec3(0.160592, 0.217282, 0.236425);\nvec3 alpha = vec3(0.122506, 0.108069, 0.12187);\nvec3 ppp = vec3(0.795078, 0.637578, 0.936117);\nvec3 F_0 = vec3(9.16095e-12, 1.81225e-12, 0.0024589);\nvec3 F_1 = vec3(-0.596835, -0.331147, -0.140729);\nvec3 K_ap = vec3(5.98176, 7.35539, 5.29722);\nvec3 sh_lambda = vec3(2.64832, 3.04253, 2.3013);\nvec3 sh_c = vec3(9.3111e-08, 8.80143e-08, 9.65288e-08);\nvec3 sh_k = vec3(24.3593, 24.4037, 25.3623);\nvec3 sh_theta0 = vec3(-0.284195, -0.277297, -0.245352);\n\nvoid initShipColor() {\t\t\t\n\trho_d = vec3(0.0657916, 0.0595705, 0.0581288);\n\trho_s = vec3(1.55275, 2.00145, 1.93045);\n\talpha = vec3(0.0149977, 0.0201665, 0.0225062);\n\tppp = vec3(0.382631, 0.35975, 0.361657);\n\tF_0 = vec3(4.93242e-13, 1.00098e-14, 0.0103259);\n\tF_1 = vec3(-0.0401315, -0.0395054, -0.0312454);\n\tK_ap = vec3(50.1263, 38.8508, 34.9978);\n\tsh_lambda = vec3(3.41873, 3.77545, 3.78138);\n\tsh_c = vec3(6.09709e-08, 1.02036e-07, 1.01016e-07);\n\tsh_k = vec3(46.6236, 40.8229, 39.1812);\n\tsh_theta0 = vec3(0.183797, 0.139103, 0.117092);\n}\n\t\t\t\nvec3 Fresnel(vec3 F0, vec3 F1, float V_H)\n{\n\treturn F0 - V_H * F1  + (1. - F0)*pow(1. - V_H, 5.);\n}\n\nvec3 D(vec3 _alpha, vec3 _p, float cos_h, vec3 _K)\n{\n\tfloat cos2 = cos_h*cos_h;\n\tfloat tan2 = (1.-cos2)\/cos2;\n\tvec3 ax = _alpha + tan2\/_alpha;\n\t\n\tax = max(ax,0.); \/\/bug?\n\t\n\treturn one_pi * _K * exp(-ax)\/(pow(ax,_p) * cos2 * cos2);\n\t\/\/ return vec3( 0.0 \/ (cos2 * cos2));\n}\n\nvec3 G1(float theta) {\n\ttheta = clamp(theta,-1.,1.); \/\/bug?\n\treturn 1.0 + sh_lambda * (1. - exp(sh_c * pow(max(acos(theta) - sh_theta0,0.), sh_k)));\n}\n\nvec3 shade(float inLight, float n_h, float n_l, float n_v, float v_h)\n{\n  \treturn  one_pi*inLight*(n_l*rho_d+rho_s*D(alpha,ppp,n_h,K_ap)*G1(n_l)*G1(n_v)*Fresnel(F_0,F_1,v_h));\n}\n\nvec3 brdf(vec3 lv, vec3 ev, vec3 n)\n{\n\tvec3 halfVector = normalize(lv + ev);\n\t\n\tfloat v_h = dot(ev, halfVector);\n\tfloat n_h = dot(n, halfVector);\n\tfloat n_l = dot(n, lv); \n\tfloat inLight = 1.0;\n\tif (n_l < 0.) inLight = 0.0;\n\tfloat n_v = dot(n, ev); \n\t\n\tvec3 sh = shade(inLight, n_h, n_l, n_v, v_h);\n\tsh = clamp( sh, 0., 1.); \/\/bug?\n\tvec3 retColor = lightIntensity * sh;\n\t\n\treturn retColor;\n}\n\n\/\/ -------------------------------------------------------------------- \n\n\t\nvec3 findColor(float obj, vec2 uv, vec3 n) {\n\tif (obj == FLAG) {\n\/\/ FLAG\n\t\tfloat c = textureInvader(uv);\n\t\treturn vec3(1.,c, c);\n\t} else if (obj == PLANET) {\n\/\/ PLANET\n\t\treturn mix(vec3(.7,.3,0),vec3(1,0,0), clamp(1.1-5.*(uv.x-1.8),0.1,.9));\n\t} else if (obj == SHIP_SIDE) {\n\t\tfloat spi = textureSpiral(uv);\n\t\treturn mix(COLOR_SIDE, .4*COLOR_SIDE, spi);\n\t} else {\n\t\tvec3 c, sp = space(n).xyz;\n\t\tif (obj == SHIP_GLOB || obj == SHIP_HUBLOT) {\n\t\t\tc = mix(COLOR_GLOBE1, COLOR_GLOBE2, .5+.5*C2);\n\t\t\treturn mix(c, sp, .8);\n\t\t} else if (obj == SHIP_ARM) {\n\t\t\treturn mix(vec3(1), sp, .2);\n\t\t} else {\t\t\t\n\t\t\tfloat spi = textureSpiral(uv);\n\t\t\tconst vec3 lightblue = .25*vec3(0.5, 0.7, 0.9);\n\t\t\tc = mix(lightblue,lightblue*.4, spi);\n\t\t\treturn mix(c, sp, .4);\n\t\t}\n\t}\n}\n\nvec3 Render(in vec3 p, in vec3 rd, in float t, in float obj, in vec2 uv) {\n\t\/\/return V01.xxy*(dot(N(p),L));\t\n\n\tvec3 nor = N(p);\n\tvec3 col = findColor(obj, uv, reflect(rd,nor));\t\n\tvec3 sunLight = L;\n\tfloat\tamb = clamp(.5+.5*nor.y, .0, 1.),\n            dif = clamp(dot( nor, sunLight ), 0., 1.),\n            bac = clamp(dot( nor, normalize(vec3(-sunLight.x,0.,-sunLight.z))), 0., 1.)*clamp( 1.0-p.y,0.0,1.0);\n\n\tfloat sh = softshadow( p, sunLight, .02, 100., 7.); \n\t\n\tif (obj != PLANET && obj != FLAG) {\n\t\tif (obj != SHIP_ARM) {\n\t\t\tinitShipColor();\n\t\t}\n\t\tfloat gamma = 2.2;\n\t\tlightIntensity *= 10.*(5.+.5*sh);\n\t\tcol *= (brdf(sunLight, -rd, nor) + .4*brdf(-sunLight, -rd, nor));\n\t\treturn sqrt(col);\n\t} else {dif *= sh; \n\n\t\t\tvec3 brdf = \n\t\t\t\t.2*(amb*vec3(.10,.11,.13) + bac*.15) +\n\t\t\t\t1.2*dif*vec3(1.,.9,.7);\n\t\n\t\t\tfloat \n\t\t\t\tpp = (obj == PLANET) ? 0. : clamp(dot(reflect(rd,nor), sunLight),0.,1.),\n\t\t\t\tspe = 2.*sh*pow(pp,16.),  \/\/ brillance\n\t\t\t\tfre = pow( clamp(1.+dot(nor,rd),0.,1.), 2.);\n\t\n\t\t\tcol = col*(.1+brdf + spe) + .2*fre*(.5+.5*col)*exp(-.01*t*t);\n\t\t\n\t\treturn sqrt(clamp(col,0.,1.));\n\t}\n}\n\n\nmat3 lookat(in vec3 ro, in vec3 up){\n\tvec3 fw=normalize(ro);\n\tvec3 rt=normalize(cross(fw,up));\n\treturn mat3(rt, cross(rt,fw),fw);\n}\n\n\n\nvec3 RD(in vec3 ro, in vec3 cp, vec2 fCoord) {\n\treturn lookat(cp-ro, V01.yxx)*normalize(vec3((2.*fCoord-iResolution.xy)\/iResolution.y, 12.0));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\ttime = 2.3*TAO+iGlobalTime*.5;\n\t\n\tC1 = COS(time);\n\tS1 = SIN(time);\n\tS2 = 2.*S1*C1;\n\tC2 = 1.-2.*S1*S1;\n\t\n\/\/ Animation\t\n\ttime \/= TAO;\n\tAnimStep = 0;\n\n\tvec3 cp = (AnimStep<2) ? vec3(-2,0,0) : vec3(0,0,0);\n\tfloat rCam = (AnimStep<2)?5.:45.;\n\n\tif (time > 7.25) {\n\t\tAnimStep = 7; \/\/ apres de la remontee\n\t\trCam = mix(45.,5.,clamp(time-7.25,0.,1.));\n\t\tcp = mix(vec3(0,0,0), vec3(-2,0,0),clamp(time-7.25,0.,1.));\n\t} else if (time>6.75) {\n\t \tAnimStep = 6; \/\/ apres de la remontee\n\t\trCam = 45.;\n\/\/\t\tcp = vec3(0,0,0);\n\t\tcp = mix(vec3(1,0,0),vec3(0,0,0),clamp(time-6.25,0.,1.));\n\t} else if (time>6.5) {\n\t\tAnimStep = 5; \/\/ remontee sans drapeau\n\t\trCam = 45.;\n\/\/\t\tcp = vec3(0,0,0);\n\t\tcp = mix(vec3(1,0,0),vec3(0,0,0),clamp(time-6.25,0.,1.));\n\t} else if (time>6.25) {\n\t\tAnimStep = 4; \/\/ pause du drapeau\n\t\trCam = 45.;\n\t\tcp = mix(vec3(1,0,0),vec3(0,0,0),clamp(time-6.25,0.,1.));\n\t} else if (time>5.25) {\n\t\tAnimStep = 3; \/\/ pause\n\t\trCam = mix(160.,45.,clamp(time-5.25,0.,1.));\n\t\tcp = vec3(1,0,0);\n\t} else if (time>3.25) {\t\t\n\t\tAnimStep = 2; \/\/ arrivee du vaiseau\n\t\trCam = mix(5.,160.,clamp(time-3.25,0.,1.));\n\t\tcp = mix(vec3(-2,0,0), vec3(1,0,0),clamp(time-3.25,0.,1.));\n\t}\n\n\tvec3 rd, ro = rCam*vec3(-.5+4.*iMouse.y\/iResolution.y,\n\t\t\t\t\t\t-SIN(time*2.12+iMouse.x\/iResolution.x),\n\t\t\t\t\t\t-COS(time*2.12)\n\t\t\t\t\t    );\n\t\n\tvec3 ctot = vec3(0);\n\t\n#ifdef ANTIALIASING \n\tfor (int i=0;i<AA;i++) {\n\t\tvec2 fCoord = fragCoord.xy+.4*vec2(COS(6.28*float(i)\/float(AA)),SIN(6.28*float(i)\/float(AA)));\t\n#else\n\t\tvec2 fCoord = fragCoord.xy;\n#endif\n\t\trd = RD(ro, cp, fCoord);\n\t\n        withPlanet = intersectSphere(ro, rd, vec3(-2.,0,0), .21);\n        \n\t\t\/\/ Ray marching\n\t\tfloat t=0.0,d=1.0,od=1.0;\n\t\tvec4 res;\n\t\tfor(int i=0;i<NB_ITER;i++){\n\t\t\tif(d<PRECISION|| t>MAX_DIST)break;\n\t\t\tt += res.x;\n\t\t\tres=DE(ro+rd*t); \/\/ *0.95;\n\t\t}\n\t\n\t\t\/\/ Render colors\n\t\tif(t<MAX_DIST){\/\/ if we hit a surface color it\n\t\t\tctot += Render(ro + rd*t, rd,t, res.y, res.zw);\n\t\t} else {\n\t\t\tctot += space(rd).xyz;\n\t\t}\n#ifdef ANTIALIASING \t\t\n    }\n\tctot \/= float(AA);\t\n#endif \t\t\n\tfragColor = vec4(ctot,1.0);\n}\n","name":"","description":"","type":"image"}]}}