{"Shader":{"ver":"0.1","info":{"id":"4sfGR7","date":"1365161571","viewed":2184,"name":"Abandoned base on Mars","username":"reinder","description":"Complete rewrite of old shader.<br\/>You're exploring an abandoned base on Mars. The base is covered with dirt.<br\/>Shader shows procedural levels and materials, a doom-like pseudo 3d-engine, dynamics lights & shadows, bumpmapping, specular maps and reflections.","likes":24,"published":3,"flags":0,"tags":["raycasting","procedurallevel","proceduralmaterial"],"hasliked":0},"renderpass":[{"inputs":[{"id":2,"src":"\/presets\/tex01.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":17,"src":"\/presets\/tex12.png","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Abandoned base on Mars. Created by Reinder Nijhoff 2013\n\/\/ @reindernijhoff\n\/\/\n\/\/ https:\/\/www.shadertoy.com\/view\/4sfGR7\n\/\/\n\n#define DIRT\n#define DYNAMICLIGHTNING\n\/\/#define SHADOWS\n\/\/#define REFLECTION\n\n#define ROOMSIZE 10.\n#define PORTALSIZE 1.5\n#define PORTALHEIGHT 3.0\n\n\/\/ seconds needed to walk through room\n#define WALKINGSPEED 3.\n\n#define MAXDISTANCE 1000.\n#define MAXMATERIALS 1000.\n\n#define EXPOSURE 2.3\n#define AMBIANT 2.2\n#define DYNAMICLIGHTSTRENGTH 7.\n#define PI 3.1415926\n\n#define NUMBEROFLIGHTS 2\n\nfloat dirtFactor;\n\n\/\/\n\/\/ math functions\n\/\/\n\nconst mat2 mr = mat2 (0.84147,  0.54030,\n\t\t\t\t\t  0.54030, -0.84147 );\nfloat hash( float n ) {\n\treturn fract(sin(n)*43758.5453);\n}\nvec2 hash2( float n ) {\n    return fract(sin(vec2(n,n+1.0))*vec2(2.1459123,3.3490423));\n}\n\nvec3 hash3( float n ) {\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(3.5453123,4.1459123,1.3490423));\n}\nfloat noise(in float x) {\n\tfloat p = floor(x);\n\tfloat f = fract(x);\n\t\t\n\tf = f*f*(3.0-2.0*f);\t\n\treturn mix( hash(p+  0.0), hash(p+  1.0),f);\n}\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn texture2D( iChannel1, (uv+118.4)\/256.0, -100.0 ).x;\n}\nfloat fbm( vec2 p ) {\n\tfloat f;\n\tf  =      0.5000*noise( p ); p = mr*p*2.02;\n\tf +=      0.2500*noise( p ); p = mr*p*2.33;\n\tf +=      0.1250*noise( p ); p = mr*p*2.01;\n\tf +=      0.0625*noise( p ); p = mr*p*2.01;\n\treturn f\/(0.9175);\n}\nvec3 rotate(vec3 r, float v){ return vec3(r.x*cos(v)+r.z*sin(v),r.y,r.z*cos(v)-r.x*sin(v));}\nfloat crossp( vec2 a, vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n\/\/\n\/\/ intersection functions\n\/\/\n\nvoid intersectPlane(const vec3 ro, const vec3 rd, const float height, out float dist) {\t\n\tdist = MAXDISTANCE;\n\tif (rd.y==0.0) {\n\t\treturn;\n\t}\n\t\n\tfloat d = -(ro.y - height)\/rd.y;\n\td = min(MAXDISTANCE, d);\n\tif( d > 0. ) {\n\t\tdist = d;\n\t}\n}\n\nvoid intersectSegment(const vec3 ro, const vec3 rd, const vec2 a, const vec2 b, out float dist, out float u) {\n\tdist = MAXDISTANCE;\n\tvec2 p = ro.xz;\n\tvec2 r = rd.xz;\n\tvec2 q = a-p;\n\tvec2 s = b-a;\n\tfloat rCrossS = crossp(r, s);\n\t\n\tif( rCrossS == 0.){\n\t\treturn;\n\t}\n\tfloat t = crossp(q, s) \/ rCrossS;\n\tu = crossp(q, r) \/ rCrossS;\n\t\n\tif(0. <= t && 0. <= u && u <= 1.){\n\t\tdist = t;\n\t}\n}\n\n\/\/\n\/\/ material functions\n\/\/\n\nfloat matfhf, matflf;\nfloat matnoisehf;\nvec3 math3;\n\nvoid materialInit(in float seed, const vec2 coord) {\n\tmatfhf = fbm( coord * 171. );\n\tmatflf = fbm( coord );\n\tmatnoisehf = noise( coord * 193. );\n\tmath3  = hash3( seed * 11. );\n}\n\nvec3 materialBaseColor( float t ) {\n\treturn texture2D( iChannel0, vec2(1.1459123*t,2.3490423*t) ).xyz;\n}\n\nvoid materialDirt(  vec2 coord, out vec3 color, out vec2 normal ) {\n\tcolor = vec3( 0.7, 0.5, 0.4 ) * (0.75*matfhf+0.25);\n\tnormal = vec2( matnoisehf*2. -1. );\n}\n\nvec2 materialGrooves( float seed, bool iswall ) {\n\tvec2 math2 = hash2( seed );\n\tif( iswall ) return clamp( floor(math2*6.) * 0.125 - 0.25, vec2(0.), vec2(1.));\n\treturn clamp( floor( math2*4.) * 0.125, vec2(0.), vec2(1.));\n}\n\nfloat grooveHeight( float l, float w, float p ) {\n\tif( l == 0. ) return 1.;\n\treturn smoothstep( l, (l-w), abs(2.*mod(p, l)-l) );\n}\n\nfloat materialHeightMap( vec2 grooves, vec2 coord ) {\n\treturn min( grooveHeight( grooves.x, 0.01, coord.x ), grooveHeight( grooves.y, 0.01, coord.y ));\n}\n\nfloat materialDirtAmount( vec2 grooves, vec2 coord ) {\n\tvec2 f = mix( vec2(0.01), grooves*2., dirtFactor );\n\treturn 1. - 0.5*min( grooveHeight( grooves.x, f.x, coord.x ), grooveHeight( grooves.y, f.y, coord.y ));\n}\n\n\/\/ calculate color\n\nvoid getMaterial( float seed, vec2 coord, vec2 grooves,  bool isfloor, bool iswall, \n\t\t\t  \t  out vec3 color, out vec2 normal, out float spec ) {\n\n\tfloat height = materialHeightMap( grooves, coord );\t\n\tnormal.x = (height-materialHeightMap( grooves, coord-vec2(0.002,0.) )) * 500.;\n\tnormal.y = (height-materialHeightMap( grooves, coord-vec2(0.,0.002) )) * 500.;\n\tnormal += (0.2 * fract( math3.y * 1.64325 )) * (vec2( matfhf, matnoisehf ) - vec2(0.5));\n\t\n\tspec = (height + 4.*matfhf )*0.1*fract( math3.x * 1.13 )*matflf;\n\t\n\tvec3 color1 = materialBaseColor( seed ); \t\n\tvec3 color2 = materialBaseColor( seed*2.6345 ); \t\n\n\t\/\/ checkboard ?\n\tbool checkx = grooves.x > 0. && mod( coord.x, grooves.x*2. ) < grooves.x;\n\tbool checky = grooves.y > 0. && mod( coord.y, grooves.y*2. ) < grooves.y;\n\t\n\tif( fract( math3.z * 4.435 ) < 0.5 && ((checkx && checky) || (!checkx && !checky)) ) {\n\t\tcolor = mix( color2, color1, matflf*fract(math3.y*45.234) );\n\t} else {\t\t\n\t\tcolor = mix( color1, color2, matflf*fract(math3.y*45.234) );\n\t}\n\t\n\tcolor *= (0.4+0.6*height+0.2*fract( math3.x*3.76 )*matfhf);\n\t\t\n#ifdef DIRT\t\n\tif( dirtFactor > 0.1 ) { \/\/ dirt\n\t\tvec2 dirtNormal; vec3 dirtColor;\t\t\n\t\tmaterialDirt( coord, dirtColor, dirtNormal );\n\t\t\n\t\tfloat dirtAmount = materialDirtAmount( grooves, coord );\t\n\n\t\tif( iswall ) {\n\t\t\tdirtAmount += clamp( dirtFactor - coord.y, -dirtAmount, 1.);\n\t\t} else\tif( !isfloor ) {\n\t\t\tdirtAmount *= 0.5; \/\/ less dirt on ceiling\n\t\t}\n\t\n\t\tfloat dirtMix = clamp( 10. * (0.5* (dirtAmount * matflf + matfhf ) - (1.-dirtFactor)), 0., 1.);\n\t\n\t\tif( dirtFactor > 0.1 ) {\n\t\t\tcolor = mix( color, dirtColor, dirtMix );\n\t\t\tspec *= 1. - dirtMix;\n\t\t\tnormal = mix( normal, dirtNormal, dirtMix );\n\t\t}\n\t}\n#endif\n}\n\nvoid getWallMaterial( float seed, vec2 coord,  \n\t\t\t\t\t  out vec3 color, out vec2 normal, out float spec ) {\n\tcoord *= 0.25;\t\n\tmaterialInit( seed, coord );\n\t\n\tfloat s = mod( floor( math3.y*13.4361 ), 8. ) * 0.125;\n\t\n\tfloat wseed = seed;\n\tif( coord.y > s ) wseed += 1.;\t\n\n\tvec2 grooves = materialGrooves( wseed, true );\n\n\tgetMaterial( seed, coord, vec2(grooves.x, max( grooves.y, s )), false, true, color, normal, spec );\n}\n\nvoid getFloorMaterial( float seed, vec2 coord, bool isfloor,  \n\t\t\t\t\t   out vec3 color, out vec2 normal, out float spec ) {\n\t\n\tcoord *= 0.25;\t\n\tmaterialInit( seed, coord );\n\tvec2 grooves = materialGrooves( seed, false );\n\n\tgetMaterial( seed, coord, grooves, isfloor, false, color, normal, spec );\n}\n\n\/\/\n\/\/ level creation\n\/\/\n\nvec3 portalPlacements; \/\/ t=-1, t=0, t=1\nbool inRoom;\nfloat currentSeed, currentSeedFract, roomSeed;\nvec3 ambiantLight;\nvec2 pillarPosition;\nfloat pillarAngle, roomHeight;\nvec2 roommorph;\nvec3 roomoffset;\n\n\n\/\/\n\/\/ Initialization\n\/\/\n\nvoid init( float t ) {\n\tfloat seed =  t \/ WALKINGSPEED;\n\tcurrentSeedFract = fract( seed );\t\n\tcurrentSeed = floor( seed );\t\n\tinRoom = mod( currentSeed, 2. ) < 1.;\n\n\t\/\/ dirt in base\n\tdirtFactor = 0.4+0.2*cos(iGlobalTime*0.05+0.5);\n\t\n\t\/\/ possible values: 0., 1., 2., 3. (n,e,s,w)\n\tportalPlacements = floor( mod( vec3( \n\t\tnoise(currentSeed*0.25-0.25), noise(currentSeed*0.25-0.0), noise(currentSeed*0.25+0.25) )*4., vec3(4.) ) );\t\n\t\n\tambiantLight = mix( materialBaseColor( currentSeed ), materialBaseColor( currentSeed+1. ), currentSeedFract );\n\tambiantLight = normalize( ambiantLight+vec3(0.5) );\n\n\troomSeed = (currentSeed+(inRoom?0.:1.));\n\troommorph = 0.5*hash2( roomSeed ) + vec2( 0.5 );\n\tpillarPosition = (vec2(-0.7)+1.4*hash2( roomSeed*11. ))*(ROOMSIZE*roommorph);\n\tpillarAngle = hash( roomSeed )*6.;\n\troomHeight = PORTALHEIGHT+PORTALHEIGHT*2.*hash(roomSeed);\n}\n\n\/\/\n\/\/ Render level\n\/\/\n\nvec2 avoidPillar( in vec2 position ) {\n\tvec2  v = position - pillarPosition;\n\tfloat d = length(v);\n\tif( d < 1.5 ) {\n\t\tposition += (1.5-d)*normalize(v);\n\t}\n\treturn position;\n}\n\nvoid traceRoom( bool inside, float seed, bool isroom, vec3 roo, vec3 rd,\n\t\t\t\tout float dist, out vec3 color, out vec3 normal, out vec3 bumpnormal, out float spec) {\n\t\n\tfloat p1, p2;\n\tdist = MAXDISTANCE;\n\tvec3 offset;\n\t\t\n\tcolor = normal = bumpnormal = vec3(0.); spec = 0.;\n\t\n\tif( inside ) {\n\t\tp1 = mod( portalPlacements[0]+2., 4.); \/\/ enter room this side\n\t\tp2 = portalPlacements[1]; \/\/ leaving room this side\n\t\toffset = vec3(0.);\n\t} else {\n\t\t\/\/ if you're not inside this room, calculate offset of room\n\t\tseed += 1.;\n\t\tp1 = portalPlacements[1]; \/\/ enter room this side\n\t\toffset = 2.*vec3( p1==1.?ROOMSIZE:p1==3.?-ROOMSIZE:0., 0., p1==0.?ROOMSIZE:p1==2.?-ROOMSIZE:0. );\n\t\tp1 = mod( p1+2., 4.); \/\/ enter room this side\n\t\tp2 = portalPlacements[2]; \/\/ leaving room this side\n\t}\n\n\tbool hitfloor;\n\n\tvec3 ro = roo - offset;\t\n\tvec3 t1, t2, hitnormal;\n\tvec2 hittex;\n\tfloat d, hitmaterial;\n\t\n\t\/\/ intersect with floor and ceiling\n\tt1 = vec3( -1., 0., 0. );\n\tt2 = vec3( 0., 0., -1. );\n\n\t\/\/ floor\t\t\n\tintersectPlane( ro, rd, 0.0, d );\n\tif( d < dist && all( lessThan( abs( (ro+d*rd).xz), vec2(ROOMSIZE)))) {\n\t\tdist = d;\n\t\thitmaterial\t= mod(seed*124.565431, MAXMATERIALS); \/\/ procedural foor material\n\t\thitnormal = vec3( 0., 1., 0.);\n\t\thitfloor = true;\n\t\thittex = (rd*dist+ro).xz;\n\t}\n\t\/\/ ceiling\n\tintersectPlane( ro, rd, isroom?roomHeight:PORTALHEIGHT, d );\n\tif( d < dist && all( lessThan( abs( (ro+d*rd).xz), vec2(ROOMSIZE)))) {\n\t\tdist = d;\n\t\thitmaterial\t= mod(seed*131.565431, MAXMATERIALS); \/\/ procedural foor material\n\t\thitnormal = vec3( 0., -1., 0.);\n\t\thitfloor = false;\n\t\thittex = (rd*dist+ro).xz;\n\t}\n\n\tvec2 hits, hite, s, e;\n\tfloat u, hitu = -1.;\n\t\n\tif(\tisroom ) {\n\t\troomoffset = offset;\n\t\t\n\t\t\/\/ the walls, check for each side of room...\n\t\tfor( int i=0; i<4; i++ ) {\n\t\t\tif( i == 0 ) {\n\t\t\t\ts = vec2( -ROOMSIZE, ROOMSIZE )*roommorph;\n\t\t\t\te = abs(s); \/\/vec2( ROOMSIZE, ROOMSIZE )*roommorph;\n\t\t\t} else if( i == 1 ) {\n\t\t\t\te = vec2( ROOMSIZE, -ROOMSIZE )*roommorph;\n\t\t\t\ts = abs(e); \/\/vec2( ROOMSIZE, ROOMSIZE )*roommorph;\n\t\t\t} else if( i == 2 ) {\n\t\t\t\te = vec2( -ROOMSIZE, -ROOMSIZE )*roommorph;\n\t\t\t\ts = e; e.x = -e.x; \/\/vec2( ROOMSIZE, -ROOMSIZE )*roommorph;\n\t\t\t} else {\n\t\t\t\ts = vec2( -ROOMSIZE, -ROOMSIZE )*roommorph;\n\t\t\t\te = s; e.y=-e.y;\/\/vec2( -ROOMSIZE, ROOMSIZE )*roommorph;\n\t\t\t}\n\t\t\t\n\t\t\tif( float(i) != p1 && float(i) != p2  ) { \/\/ normal wall\n\t\t\t\t\n\t\t\t\tintersectSegment( ro, rd, s, e, d, u );\n\t\t\t\tif( d < dist ) { dist = d; hitu = u; hits = s; hite = e; }\n\n\t\t\t} else { \/\/ three walls with portal\n\t\t\t\tvec2 sp, ep;\n\t\t\t\tif( i == 0 ) {\n\t\t\t\t\tsp = vec2( -PORTALSIZE, ROOMSIZE );\n\t\t\t\t\tep = vec2( PORTALSIZE, ROOMSIZE );\n\t\t\t\t} else if( i == 1) {\n\t\t\t\t\tsp = vec2( ROOMSIZE, PORTALSIZE );\n\t\t\t\t\tep = vec2( ROOMSIZE, -PORTALSIZE );\n\t\t\t\t} else if( i == 2) {\n\t\t\t\t\tsp = vec2( -PORTALSIZE, -ROOMSIZE );\n\t\t\t\t\tep = vec2( PORTALSIZE, -ROOMSIZE );\n\t\t\t\t} else {\n\t\t\t\t\tsp = vec2( -ROOMSIZE, -PORTALSIZE );\n\t\t\t\t\tep = vec2( -ROOMSIZE, PORTALSIZE );\n\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\tintersectSegment( ro, rd, s, sp, d, u );\n\t\t\t\tif( d < dist ) { dist = d; hitu = u; hits = s; hite = sp; }\n\t\t\t\t\n\t\t\t\tintersectSegment( ro, rd, ep, e, d, u );\n\t\t\t\tif( d < dist ) { dist = d; hitu = u; hits = ep; hite = e; }\n\t\t\t\t\n\t\t\t\t\/\/ portal!\n\t\t\t\tintersectSegment( ro, rd, sp, ep, d, u );\n\t\t\t\tif( d < dist && (rd.y*d+ro.y > PORTALHEIGHT) ) { \n\t\t\t\t\tdist = d; hitu = u; hits = sp; hite = ep;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else { \n\t\t\/\/ we are in a portal; check walls:\t\t\n\t\tfloat totalu = 2.0 * ROOMSIZE;\n\t\tif( mod( p1, 2.) == mod( p2, 2.) ) {\n\t\t\t\/\/ straight\t\n\t\t\n\t\t\tvec2 ps, pw;\n\t\t\tif( p1==0. || p1==2.) {\n\t\t\t\tps = vec2( 0., ROOMSIZE );\n\t\t\t\tpw = vec2( PORTALSIZE, 0. );\n\t\t\t} else {\n\t\t\t\tps = vec2( ROOMSIZE, 0. );\n\t\t\t\tpw = vec2( 0., PORTALSIZE );\n\t\t\t}\n\t\t\t\n\t\t\tvec2 o2, o1 = vec2(0.); \n\t\t\tfor( int j=0; j<6; j++ ) {\n\t\t\t\tif( j!=5 ) o2 = hash2(float(j)); else o2 = vec2(0.);\n\t\t\t\t\n\t\t\t\ts = o1+pw+ps*(1.-float(j)\/3.);\n\t\t\t\te = o2+pw+ps*(1.-float(j+1)\/3.);\n\t\t\t\t\n\t\t\t\tintersectSegment( ro, rd, s, e, d, u );\n\t\t\t\tif( d < dist ) { dist = d; hitu = totalu+u; hits = s; hite = e; }\n\t\t\t\t\n\t\t\t\te = o1-pw+ps*(1.-float(j)\/3.);\n\t\t\t\ts = o2-pw+ps*(1.-float(j+1)\/3.);\n\t\t\t\t\n\t\t\t\tintersectSegment( ro, rd, s, e, d, u );\n\t\t\t\tif( d < dist ) { dist = d; hitu = totalu-u; hits = s; hite = e; }\n\t\t\t\t\n\t\t\t\to1=o2;\n\t\t\t\ttotalu += distance( e, s );\n\t\t\t}\t\t\n\t\t} else {\n\t\t\t\/\/ curved\n\t\t\tfloat a; vec2 o;\n\t\t\tif( min(p1, p2) == 0. ) {\n\t\t\t\tif( max(p1, p2) == 1. ) {\n\t\t\t\t\ta = PI * 0.5; o = vec2( ROOMSIZE, ROOMSIZE );\n\t\t\t\t} else {\n\t\t\t\t\ta = PI * 0.0; o = vec2( -ROOMSIZE, ROOMSIZE );\n\t\t\t\t}\n\t\t\t} else if( min(p1, p2) == 1. ) {\n\t\t\t\ta = PI * 1.0; o = vec2( ROOMSIZE, -ROOMSIZE );\n\t\t\t} else {\n\t\t\t\ta = PI * 1.5; o = vec2( -ROOMSIZE, -ROOMSIZE );\n\t\t\t}\n\t\t\tfloat da = 0.5 * PI \/ 6.;\n\t\t\tfor( int j=0; j<6; j++ ) {\n\t\t\t\tfloat si = sin(a); float co = cos(a);\n\t\t\t\tfloat ds = sin(a+da); float dc = cos(a+da);\n\t\t\t\ta+=da;\n\t\t\t\t\n\t\t\t\ts = o+vec2( (ROOMSIZE+PORTALSIZE)*co , -(ROOMSIZE+PORTALSIZE)*si );\n\t\t\t\te = o+vec2( (ROOMSIZE+PORTALSIZE)*dc, -(ROOMSIZE+PORTALSIZE)*ds);\n\t\t\t\t\n\t\t\t\tintersectSegment( ro, rd, s, e, d, u );\n\t\t\t\tif( d < dist ) { dist = d; hitu = totalu+u; hits = s; hite = e; }\n\t\t\t\t\n\t\t\t\te = o+vec2( (ROOMSIZE-PORTALSIZE)*co , -(ROOMSIZE-PORTALSIZE)*si );\n\t\t\t\ts = o+vec2( (ROOMSIZE-PORTALSIZE)*dc, -(ROOMSIZE-PORTALSIZE)*ds);\n\t\t\t\t\n\t\t\t\tintersectSegment( ro, rd, s, e, d, u );\n\t\t\t\tif( d < dist ) { dist = d; hitu = totalu-u; hits = s; hite = e; }\n\t\t\t\t\n\t\t\t\ttotalu += distance( e, s );\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tif(\tisroom ) {\t\t\t\n\t\t\/\/ pillar\t\n\t\tfor( int i=0; i<4; i++ ) {\n\t\t\tfloat angle = float(i)*PI*0.5+pillarAngle;\n\t\t\ts = vec2( cos( angle ), sin( angle ) ) + pillarPosition; \n\t\t\te = vec2( cos( angle+PI*0.5 ), sin( angle+PI*0.5 ) ) + pillarPosition;\n\t\t\t\t\n\t\t\tintersectSegment( ro, rd, s, e, d, u );\n\t\t\tif( d < dist ) { dist = d; hitu = u; hits = s; hite = e; }\n\t\t}\n\t}\n\t\n\tif( dist >= MAXDISTANCE ) {\n\t\treturn;\n\t}\n\t\n\t\/\/ calculate color for material\n\t\n\tvec2 ntangent;\n\t\n\tif( hitu >= 0. ) {\n\t\tvec2 sme = hits-hite;\n\t\tfloat lt = length(sme);\n\t\thittex.x = lt*hitu;\n\t\thittex.y = (ro+rd*dist).y; \n\t\thitnormal = normalize( vec3( -sme.y, 0., sme.x ));\n\t\tt2 = vec3( 0., -1., 0. );\n\t\tt1 = cross( hitnormal, t2 );\n\n\t\tgetWallMaterial( mod(seed*14.1565431, MAXMATERIALS),\n\t\t\t\t\t\thittex, color, ntangent, spec );\t\n\t} else {\n\t\tgetFloorMaterial( hitmaterial, hittex, hitfloor,\n\t\t\t\t \t\t  color, ntangent, spec );\n\t}\n\t\n\tnormal = hitnormal;\n\tbumpnormal = normalize( (normal + ntangent.x*t1) + ntangent.y*t2 );\n}\n\n\nbool traceShadow( vec3 roo, vec3 rd, float maxdist ) { \t\n\n\tfloat u, d = MAXDISTANCE;\n\tvec3 ro = roo - roomoffset;\n\tvec2 e, s;\n\t\n\tfor( int i=0; i<4; i++ ) {\n\t\t\tfloat angle = float(i)*PI*0.5+pillarAngle;\n\t\t\ts = vec2( cos( angle ), sin( angle ) ) + pillarPosition; \n\t\t\te = vec2( cos( angle+PI*0.5 ), sin( angle+PI*0.5 ) ) + pillarPosition;\n\t\t\t\t\n\t\t\tintersectSegment( ro, rd, s, e, d, u );\n\t\t\tif( d < maxdist ) return true;\n\t\t}\n\treturn false;\n}\n\nfloat trace( vec3 roo, vec3 rd, out vec3 color, out vec3 normal, out float spec ) {\t\n\tnormal = color = vec3( 0. );\n\tvec3 matcolor, bumpnormal, hitcolor, hitnormal, hitbumpnormal;\n\tfloat dist = MAXDISTANCE, d, hitspec;\t\n\t\n\t\/\/ trace room\n\ttraceRoom( inRoom, currentSeed, true, roo, rd, dist,\n\t\t\t\t matcolor, normal, bumpnormal, spec);\n\t\/\/ trace portal\n\ttraceRoom( !inRoom, currentSeed, false, roo, rd, d,\n\t\t\t\t  hitcolor, hitnormal, hitbumpnormal, hitspec);\n\tif( d < dist ) {\n\t\tdist = d;\n\t\tmatcolor = hitcolor; normal = hitnormal; bumpnormal = hitbumpnormal; spec = hitspec;\n\t}\n\n\tvec3 intersection  = roo + rd*dist;\n\t\n\t\/\/ lightning\n\tcolor = (matcolor*ambiantLight)*(AMBIANT*(0.7 + 0.4*clamp( dot(bumpnormal, normalize( vec3( 0.2, 0.3, 0.5) ) ), 0., 1.)));\n\tcolor *= clamp( 7.5\/dist, 0., 1.);\n\t\n\tvec3 offset = roomoffset + vec3( 0., 0.5*roomHeight, 0. );\n\t\n#ifdef DYNAMICLIGHTNING\t\n\tfor( int i=0; i<NUMBEROFLIGHTS; i++ ) {\t\n\t\tfloat fi = float(i); \n\t\tvec3 lightcolor = hash3( roomSeed+float(i*643) );\n\t\t\n\t\tvec3 lightpos = (lightcolor*vec3(0.8*ROOMSIZE*roommorph.x,0.5*roomHeight,0.8*ROOMSIZE*roommorph.y)*\n\t\t\t\t\t\t\t\t cos((2.*(fi+iGlobalTime))*lightcolor ))+offset;\n\t\tvec3 lightvec = lightpos-intersection;\n\t\t\n\t\tif( dot( lightvec, normal ) < 0. ) continue;\n\t\t\n\t\tfloat l = length( lightvec );\n\t\tvec3 nlightvec = lightvec * (1.\/l);\n\t\t\n\t\t\/\/ diffuse\n\t\tfloat diff = DYNAMICLIGHTSTRENGTH * clamp( dot( nlightvec, bumpnormal ), 0., 1.);\t\n\t\t\n#ifndef REFLECTION\t\t\n\t\t\/\/ specular\t\t\n\t\tfloat specu = clamp( dot( reflect(rd,bumpnormal), nlightvec ), 0.0, 1.0 );\n\t\tspecu = 20. * DYNAMICLIGHTSTRENGTH * spec * (pow(specu,16.0) + 0.5*pow(specu,4.0));\n#endif\n\t\t\n#ifdef SHADOWS\t\t\n\t\tif( !traceShadow( nlightvec*0.001+intersection, nlightvec, l ) )\n#endif\n#ifdef REFLECTION\t\t\t\n\t\t\tcolor += matcolor*lightcolor*(diff \/ (l*l));\t\t\n#else\n\t\t\tcolor += matcolor*lightcolor*((diff+specu) \/ (l*l));\n#endif\n\t}\n#endif\n\t\n\tnormal = bumpnormal;\n\treturn dist;\n}\n\n\/\/\n\/\/ Camera path\n\/\/\n\nvec3 initCamera( float f ) {\t\n\tfloat p1 = mod( portalPlacements[0]+2., 4.);\n\tfloat p2 = portalPlacements[1];\n\tfloat mf = 1.-f;\n\t\n\tif( mod( p1, 2.) == mod( p2, 2.) ) {\n\t\t\/\/ straight\t\n\t\tvec3 cam;\n\t\tif( p1==0.) {\n\t\t\tcam.xy = vec2( 0., ROOMSIZE-f*ROOMSIZE*2. );\n\t\t} else if( p1==1.) {\n\t\t\tcam.xy = vec2(  ROOMSIZE-f*ROOMSIZE*2., 0. );\n\t\t} else if( p1==2.) {\n\t\t\tcam.xy = vec2( 0., -ROOMSIZE+f*ROOMSIZE*2. );\n\t\t} else {\n\t\t\tcam.xy = vec2( -ROOMSIZE+f*ROOMSIZE*2., 0. );\n\t\t}\n\t\tcam.z = (p2==1.)?0.5*PI:(p2==2.)?PI:(p2==3.)?PI*1.5:0.;\n\t\t\n\t\treturn cam;\n\t} else {\n\t\t\/\/ curved\n\t\tfloat a, an; vec2 o; \n\t\tif( min(p1, p2) == 0. ) {\n\t\t\tif( max(p1, p2) == 1. ) {\n\t\t\t\ta = PI * 0.5; o = vec2( ROOMSIZE, ROOMSIZE );\n\t\t\t} else {\n\t\t\t\ta = PI * 0.0; o = vec2( -ROOMSIZE, ROOMSIZE );\n\t\t\t}\n\t\t} else if( min(p1, p2) == 1. ) {\n\t\t\ta = PI * 1.0; o = vec2( ROOMSIZE, -ROOMSIZE );\n\t\t} else {\n\t\t\ta = PI * 1.5; o = vec2( -ROOMSIZE, -ROOMSIZE );\n\t\t}\n\t\tif( mod(p1+1.,4.) == p2) f=mf;\n\t\t\n\t\tif( mod(p1+1.,4.) == p2) { \/\/ counter clockwise\n\t\t\tan = f*0.5*PI+(p1)*PI*0.5;\n\t\t} else {\n\t\t\tan = f*0.5*PI+(p1+1.)*PI*0.5;\n\t\t}\n\t\t\n\t\ta += f*PI*0.5;\n\t\tfloat s = sin(a); float c = cos(a);\n\t\treturn vec3(o, an+0.5*PI)+vec3( c*ROOMSIZE, -s*ROOMSIZE, 0.);\n\t}\n\treturn vec3(0.);\n}\n\n\/\/\n\/\/ Main\n\/\/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 q = fragCoord.xy\/iResolution.xy;\n\tvec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x\/iResolution.y;\n\t\n\tinit( iGlobalTime+1.5 );\n\t\t\n\tvec3 camPosition = initCamera( currentSeedFract );\n\tif(inRoom) camPosition.xy = avoidPillar( camPosition.xy );\n\t\n\tvec3 ro = vec3( camPosition.x, 1.6+0.03*sin(iGlobalTime*6.), camPosition.y );\n\tvec3 ta = rotate( vec3(0.0, 0.0, 1.0), camPosition.z + 0.3*sin(iGlobalTime) );\n\t\t\n\tfloat roll = 0.13*sin(camPosition.z + 0.13*iGlobalTime);\n\t\n\t\/\/ camera tx\n\tvec3 cw = normalize( ta );\n\tvec3 cp = vec3( sin(roll), cos(roll),0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 1.5*cw );\n\n\t\n\t\n\tvec3 color, normal;\n\tfloat spec, dist;\n\tdist = trace( ro, rd, color, normal, spec );\n\n#ifdef REFLECTION\n\tif( spec > 0.0) {\n\t\tvec3 speccolor = vec3(0.);\n\t\tfloat refspec;\n\t\tvec3 refl = normalize(reflect( rd, normal ));\n\t\tdist = trace( ro+rd*dist+refl*0.001, refl, speccolor, normal, refspec );\t\n\t\t\/\/dist = trace( ro, rd, speccolor, normal, refspec );\t\t\t\t\n\t\tcolor += spec*speccolor;\n\t}\n#endif\n\t\n\tcolor = pow( color, vec3(EXPOSURE) );\n\t\n    \/\/ vigneting\n    color *= 0.25+0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15 );\n\t\n\tfragColor = vec4( clamp(color, 0., 1.),1.0);\n}","name":"","description":"","type":"image"}]}}