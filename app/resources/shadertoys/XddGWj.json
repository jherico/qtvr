{"Shader":{"ver":"0.1","info":{"id":"XddGWj","date":"1452283994","viewed":256,"name":"Lorenz Attractor Scope","username":"Flyguy","description":"A Lorenz attractor plotter thing made to look like an analog oscilloscope. Lower the speed to see the motion more clearly.","likes":7,"published":3,"flags":32,"tags":["math","simulation","chaos","lorenz","multipass"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define COLOR_BACK vec3(0.10, 0.10, 0.10)\n#define COLOR_TRACE vec3(0.10, 1.10, 0.50)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    \n    float b = texture2D(iChannel0, uv).x;\n    \n\tfragColor = vec4(mix(COLOR_BACK, COLOR_TRACE, b), 1.0);\n}","name":"","description":"","type":"image"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\n\/\/https:\/\/en.wikipedia.org\/wiki\/Lorenz_system\n\n\/\/Settings\n#define STEPS 96.0\n#define VIEW_SCALE 0.015\n\n#define SPEED 0.4\n#define INTENSITY 0.85\n#define FADE 0.80\n#define FOCUS 1.8\n\n#define MODE xy\n\n\/\/System Parameters\nfloat O = 10.0;\nfloat P = 28.0;\nfloat B = 8.0\/3.0;\n\n\/\/Initial Position\nvec3 start = vec3(1,0.001,0);\n\n\/\/Calculate the next position \nvec3 Integrate(vec3 cur, float dt)\n{\n\tvec3 next = vec3(0);\n    \n    next.x = O * (cur.y - cur.x);\n    next.y = cur.x * (P - cur.z) - cur.y;\n    next.z = cur.x*cur.y - B*cur.z;\n    \n    return cur + next * dt;\n}\n\n\/\/Distance to a line segment,\nfloat dfLine(vec2 start, vec2 end, vec2 uv)\n{   \n\tvec2 line = end - start;\n\tfloat frac = dot(uv - start,line) \/ dot(line,line);\n\treturn distance(start + line * clamp(frac, 0.0, 1.0), uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 res = iResolution.xy \/ iResolution.y;\n    vec2 uv = fragCoord \/ iResolution.y;\n    uv -= res\/2.0;\n    \n    float d = 1e6;\n    \n    vec3 last = texture2D(iChannel0, vec2(0,0)).xyz;\n    vec3 next = vec3(0);\n    \n    for(float i = 0.0;i < STEPS;i++)\n    {\n    \tnext = Integrate(last, iTimeDelta * SPEED);\n        \n        d = min(d, dfLine(last.MODE * VIEW_SCALE, next.MODE * VIEW_SCALE, uv));\n         \n        last = next;\n    }\n    \n    float c = (INTENSITY \/ SPEED) * smoothstep(FOCUS \/ iResolution.y, 0.0, d);\n\t\n\tc += (INTENSITY\/8.5) * exp(-1000.0 * d*d);\n    \n    \/\/pixel (0,0) saves the current position.\n    if(floor(fragCoord) == vec2(0,0))\n    {\n        if(iFrame == 0) \/\/Setup initial conditions.\n    \t{\n    \t\tfragColor = vec4(start, 0);\n    \t}\n        else \/\/Save current position.\n        {\n    \t\tfragColor = vec4(next, 0);\n        }\n    }\n    else\n    {\n        vec3 lc = texture2D(iChannel0, fragCoord \/ iResolution.xy).rgb;\n        fragColor = vec4(vec3(c) + lc * FADE, 0);\n    }\n}","name":"","description":"","type":"buffer"}]}}