{"Shader":{"ver":"0.1","info":{"id":"MdBGzG","date":"1392241143","viewed":18916,"name":"Canyon","username":"iq","description":"Another terrain, a quick one. Same concept as Elevated, just a different terrain shape.","likes":112,"published":3,"flags":0,"tags":["procedural","3d","raymarching","distancefield","terrain","elevated"],"hasliked":0},"renderpass":[{"inputs":[{"id":7,"src":"\/presets\/tex06.jpg","ctype":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":8,"src":"\/presets\/tex07.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":10,"src":"\/presets\/tex09.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/-----------------------------------------------------------------------------------\n\n#define LOWDETAIL\n\/\/#define HIGH_QUALITY_NOISE\n\nfloat noise1( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n#ifndef HIGH_QUALITY_NOISE\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D( iChannel2, (uv+ 0.5)\/256.0, -100.0 ).yx;\n#else\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\n\tvec2 rg1 = texture2D( iChannel2, (uv+ vec2(0.5,0.5))\/256.0, -100.0 ).yx;\n\tvec2 rg2 = texture2D( iChannel2, (uv+ vec2(1.5,0.5))\/256.0, -100.0 ).yx;\n\tvec2 rg3 = texture2D( iChannel2, (uv+ vec2(0.5,1.5))\/256.0, -100.0 ).yx;\n\tvec2 rg4 = texture2D( iChannel2, (uv+ vec2(1.5,1.5))\/256.0, -100.0 ).yx;\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\n#endif\t\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\/\/-----------------------------------------------------------------------------------\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat displacement( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise1( p ); p = m*p*2.02;\n    f += 0.2500*noise1( p ); p = m*p*2.03;\n    f += 0.1250*noise1( p ); p = m*p*2.01;\n\t#ifndef LOWDETAIL\n    f += 0.0625*noise1( p ); \n\t#endif\n    return f;\n}\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec4 x = texture2D( sam, p.yz );\n\tvec4 y = texture2D( sam, p.zx );\n\tvec4 z = texture2D( sam, p.xy );\n\treturn (x*abs(n.x) + y*abs(n.y) + z*abs(n.z))\/(abs(n.x)+abs(n.y)+abs(n.z));\n}\n\n\nvec4 texture2DGood( sampler2D sam, vec2 uv, float bias )\n{\n    uv = uv*1024.0 - 0.5;\n    vec2 iuv = floor(uv);\n    vec2 f = fract(uv);\n\tvec4 rg1 = texture2D( sam, (iuv+ vec2(0.5,0.5))\/1024.0, bias );\n\tvec4 rg2 = texture2D( sam, (iuv+ vec2(1.5,0.5))\/1024.0, bias );\n\tvec4 rg3 = texture2D( sam, (iuv+ vec2(0.5,1.5))\/1024.0, bias );\n\tvec4 rg4 = texture2D( sam, (iuv+ vec2(1.5,1.5))\/1024.0, bias );\n\treturn mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\n}\n\/\/-----------------------------------------------------------------------------------\n\nfloat terrain( in vec2 q )\n{\n\tfloat th = smoothstep( 0.0, 0.7, texture2D( iChannel0, 0.001*q, -100.0 ).x );\n    float rr = smoothstep( 0.1, 0.5, texture2D( iChannel1, 2.0*0.03*q, -100.0 ).y );\n\tfloat h = 1.9;\n\t#ifndef LOWDETAIL\n\th += (1.0-0.6*rr)*(1.5-1.0*th) * 0.2*(1.0-texture2D( iChannel0, 0.03*q, -100.0 ).x);\n\t#endif\n\th += th*7.0;\n    h += 0.3*rr;\n    return -h;\n}\n\nfloat terrain2( in vec2 q )\n{\n\tfloat th = smoothstep( 0.0, 0.7, texture2DGood( iChannel0, 0.001*q, -100.0 ).x );\n    float rr = smoothstep( 0.1, 0.5, texture2DGood( iChannel1, 2.0*0.03*q, -100.0 ).y );\n\tfloat h = 1.9;\n\th += th*7.0;\n    return -h;\n}\n\n\nvec4 map( in vec3 p )\n{\n\tfloat h = terrain( p.xz );\n\tfloat dis = displacement( 0.25*p*vec3(1.0,4.0,1.0) );\n\tdis *= 3.0;\n\treturn vec4( (dis + p.y-h)*0.25, p.x, h, 0.0 );\n}\n\nvec4 intersect( in vec3 ro, in vec3 rd, in float tmax )\n{\n    float t = 0.1;\n    vec3 res = vec3(0.0);\n    for( int i=0; i<256; i++ )\n    {\n\t    vec4 tmp = map( ro+rd*t );\n        res = tmp.ywz;\n        t += tmp.x;\n        if( tmp.x<(0.001*t) || t>tmax ) break;\n    }\n\n    return vec4( t, res );\n}\n\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    vec2 eps = vec2( 0.005*t, 0.0 );\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n        float h = map(ro + rd*t).x;\n        res = min( res, k*h\/t );\n\t\tt += clamp( h, 0.5, 1.0 );\n\t\tif( h<0.001 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\n\/\/ Oren-Nayar\nfloat Diffuse( in vec3 l, in vec3 n, in vec3 v, float r )\n{\n\t\n    float r2 = r*r;\n    float a = 1.0 - 0.5*(r2\/(r2+0.57));\n    float b = 0.45*(r2\/(r2+0.09));\n\n    float nl = dot(n, l);\n    float nv = dot(n, v);\n\n    float ga = dot(v-n*nv,n-n*nl);\n\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) \/ max(nl, nv));\n}\n\nvec3 cpath( float t )\n{\n\tvec3 pos = vec3( 0.0, 0.0, 95.0 + t );\n\t\n\tfloat a = smoothstep(5.0,20.0,t);\n\tpos.xz += a*150.0 * cos( vec2(5.0,6.0) + 1.0*0.01*t );\n\tpos.xz -= a*150.0 * cos( vec2(5.0,6.0) );\n\tpos.xz += a* 50.0 * cos( vec2(0.0,3.5) + 6.0*0.01*t );\n\tpos.xz -= a* 50.0 * cos( vec2(0.0,3.5) );\n\n\treturn pos;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x\/iResolution.y;\n    vec2 m = vec2(0.0);\n\tif( iMouse.z>0.0 ) m = iMouse.xy\/iResolution.xy;\n\n\t\n    \/\/-----------------------------------------------------\n    \/\/ camera\n    \/\/-----------------------------------------------------\n\n\tfloat an = 0.5*(iGlobalTime-5.0);\/\/ + 12.0*(m.x-0.5);\n\tvec3 ro = cpath( an + 0.0 );\n\tvec3 ta = cpath( an + 10.0 *1.0);\n\tta = mix( ro + vec3(0.0,0.0,1.0), ta, smoothstep(5.0,25.0,an) );\n    ro.y = terrain2( ro.xz ) - 0.5;\n\tta.y = ro.y - 0.1;\n\tta.xy += step(0.01,m.x)*(m.xy-0.5)*4.0*vec2(-1.0,1.0);\n\tfloat rl = -0.1*cos(0.05*6.2831*an);\n    \/\/ camera to world transform    \n    mat3 cam = setCamera( ro, ta, rl );\n    \n    \/\/ ray\n\tvec3 rd = normalize( cam * vec3(p.xy, 2.0) );\n\n    \/\/-----------------------------------------------------\n\t\/\/ render\n    \/\/-----------------------------------------------------\n\n\tvec3 klig = normalize(vec3(-1.0,0.19,0.4));\n\t\n\tfloat sun = clamp(dot(klig,rd),0.0,1.0 );\n\n\tvec3 hor = mix( 1.2*vec3(0.70,1.0,1.0), vec3(1.5,0.5,0.05), 0.25+0.75*sun );\n\t\n    vec3 col = mix( vec3(0.2,0.6,.9), hor, exp(-(4.0+2.0*(1.0-sun))*max(0.0,rd.y-0.1)) );\n    col *= 0.5;\n\tcol += 0.8*vec3(1.0,0.8,0.7)*pow(sun,512.0);\n\tcol += 0.2*vec3(1.0,0.4,0.2)*pow(sun,32.0);\n\tcol += 0.1*vec3(1.0,0.4,0.2)*pow(sun,4.0);\n\t\n\tvec3 bcol = col;\n\t\n\t\/\/ clouds\n\tfloat pt = (1000.0-ro.y)\/rd.y; \n\tif( pt>0.0 )\n\t{\n        vec3 spos = ro + pt*rd;\n        float clo = texture2D( iChannel0, 0.00006*spos.xz ).x;\t\n        vec3 cloCol = mix( vec3(0.4,0.5,0.6), vec3(1.3,0.6,0.4), pow(sun,2.0))*(0.5+0.5*clo);\n        col = mix( col, cloCol, 0.5*smoothstep( 0.4, 1.0, clo ) );\n\t}\n\t\n\t\n\t\/\/ raymarch\n    float tmax = 120.0;\n    \n    \/\/ bounding plane    \n    float bt = (0.0-ro.y)\/rd.y; \n\tif( bt>0.0 ) tmax = min( tmax, bt );\n        \n    vec4 tmat = intersect( ro, rd, tmax);\n    if( tmat.x<tmax )\n    {\n        \/\/ geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormal( pos, tmat.x );\n\t\tvec3 ref = reflect( rd, nor );\n\n\t\tfloat occ = smoothstep( 0.0, 1.5, pos.y + 11.5 ) * (1.0 - displacement( 0.25*pos*vec3(1.0,4.0,1.0) ));\n\n\t\t\/\/ materials\n\t\tvec4 mate = vec4(0.5,0.5,0.5,0.0);\n\t\t\n\t\t\/\/if( tmat.z<0.5 )\n\t\t{\n\t\t\tvec3 uvw = 1.0*pos;\n\n\t\t\tvec3 bnor;\n\t\t\tfloat be = 1.0\/1024.0;\n\t\t\tfloat bf = 0.4;\n\t\t\tbnor.x = texcube( iChannel0, bf*uvw+vec3(be,0.0,0.0), nor ).x - texcube( iChannel0, bf*uvw-vec3(be,0.0,0.0), nor ).x;\n\t\t\tbnor.y = texcube( iChannel0, bf*uvw+vec3(0.0,be,0.0), nor ).x - texcube( iChannel0, bf*uvw-vec3(0.0,be,0.0), nor ).x;\n\t\t\tbnor.z = texcube( iChannel0, bf*uvw+vec3(0.0,0.0,be), nor ).x - texcube( iChannel0, bf*uvw-vec3(0.0,0.0,be), nor ).x;\n\t\t\tbnor = normalize(bnor);\n\t\t\tfloat amo = 0.2  + 0.25*(1.0-smoothstep(0.6,0.7,nor.y) );\n\t\t\tnor = normalize( nor + amo*(bnor-nor*dot(bnor,nor)) );\n\n\t\t\tvec3 te = texcube( iChannel0, 0.15*uvw, nor ).xyz;\n\t\t\tte = 0.05 + te;\n\t\t\tmate.xyz = 0.6*te;\n\t\t\tmate.w = 1.5*(0.5+0.5*te.x);\n\t\t\tfloat th = smoothstep( 0.1, 0.4, texcube( iChannel0, 0.002*uvw, nor ).x );\n\t\t\tvec3 dcol = mix( vec3(0.2, 0.3, 0.0), 0.4*vec3(0.65, 0.4, 0.2), 0.2+0.8*th );\n\t\t\tmate.xyz = mix( mate.xyz, 2.0*dcol, th*smoothstep( 0.0, 1.0, nor.y ) );\n\t\t\tmate.xyz *= 0.5;\n\t\t\tfloat rr = smoothstep( 0.2, 0.4, texcube( iChannel1, 2.0*0.02*uvw, nor ).y );\n\t\t\tmate.xyz *= mix( vec3(1.0), 1.5*vec3(0.25,0.24,0.22)*1.5, rr );\n\t\t\tmate.xyz *= 1.5*pow(texcube( iChannel3, 8.0*uvw, nor ).xyz,vec3(0.5));\n            mate = mix( mate, vec4(0.7,0.7,0.7,.0), smoothstep(0.8,0.9,nor.y + nor.x*0.6*te.x*te.x ));\n\t\t\t\n\t\t\t\n\t\t\tmate.xyz *= 1.5;\n\t\t}\n\t\t\n\t\tvec3 blig = normalize(vec3(-klig.x,0.0,-klig.z));\n\t\tvec3 slig = vec3( 0.0, 1.0, 0.0 );\n\t\t\t\n\t\t\/\/ lighting\n        float sky = 0.0;\n        sky += 0.2*Diffuse( normalize(vec3( 0.0, 1.0, 0.0 )), nor, -rd, 1.0 );\n        sky += 0.2*Diffuse( normalize(vec3( 3.0, 1.0, 0.0 )), nor, -rd, 1.0 );\n        sky += 0.2*Diffuse( normalize(vec3(-3.0, 1.0, 0.0 )), nor, -rd, 1.0 );\n        sky += 0.2*Diffuse( normalize(vec3( 0.0, 1.0, 3.0 )), nor, -rd, 1.0 );\n        sky += 0.2*Diffuse( normalize(vec3( 0.0, 1.0,-3.0 )), nor, -rd, 1.0 );\n\t\tfloat dif = Diffuse( klig, nor, -rd, 1.0 );\n\t\tfloat bac = Diffuse( blig, nor, -rd, 1.0 );\n\n\n\t\tfloat sha = 0.0; if( dif>0.001 ) sha=softshadow( pos+0.01*nor, klig, 0.005, 64.0 );\n        float spe = mate.w*pow( clamp(dot(reflect(rd,nor),klig),0.0,1.0),2.0)*clamp(dot(nor,klig),0.0,1.0);\n\t\t\n\t\t\/\/ lights\n\t\tvec3 lin = vec3(0.0);\n\t\tlin += 7.0*dif*vec3(1.20,0.50,0.25)*vec3(sha,sha*0.5+0.5*sha*sha, sha*sha );\n\t\tlin += 1.0*sky*vec3(0.10,0.50,0.70)*occ;\n\t\tlin += 2.0*bac*vec3(0.30,0.15,0.15)*occ;\n\t    lin += 0.5*vec3(spe)*sha*occ;\n\t\t\n\t\t\/\/ surface-light interacion\n\t\tcol = mate.xyz * lin;\n\n\t\t\/\/ fog\n        bcol = 0.7*mix( vec3(0.2,0.5,1.0)*0.82, bcol, 0.15+0.8*sun ); col = mix( col, bcol, 1.0-exp(-0.02*tmat.x) );\t\t\n\t}\n\t\n\n\tcol += 0.15*vec3(1.0,0.9,0.6)*pow( sun, 6.0 );\n\t\n\t\/\/-----------------------------------------------------\n\t\/\/ postprocessing\n    \/\/-----------------------------------------------------\n    col *= 1.0 - 0.25*pow(1.0-clamp(dot(cam[2],klig),0.0,1.0),3.0);\n\t\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\n\tcol *= vec3(1.1,1.0,1.0);\n\tcol = col*col*(3.0-2.0*col);\n\tcol = pow( col, vec3(0.9,1.0,1.0) );\n\n\tcol = mix( col, vec3(dot(col,vec3(0.333))), 0.4 );\n\tcol = col*0.5+0.5*col*col*(3.0-2.0*col);\n\t\n\tcol *= 0.3 + 0.7*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\n    col *= smoothstep(0.0,2.5,iGlobalTime);\n\n\tfragColor = vec4( col, 1.0 );\n}\n","name":"","description":"","type":"image"}]}}