{"Shader":{"ver":"0.1","info":{"id":"lll3zl","date":"1424485535","viewed":1272,"name":"Spinning Rings","username":"squid","description":"Like a gyroscope type thing, but with a lot of rings. Code based on eiffie's DDE shader and iq's stuff (like everybody) [Mouse enabled]","likes":17,"published":3,"flags":0,"tags":["3d","torus","dde"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define GRADIENT_DELTA 0.5\n#define FUDGE_FACTOR 0.5\n#define COMPARE_FUDGE_FACTOR 0.2\n\n\n#define time iGlobalTime\n#define size iResolution\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0\/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0\/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nmat3 rotateY(float r)\n{\n    vec2 cs = vec2(cos(r), sin(r));\n    return mat3(cs.x, 0, cs.y, 0, 1, 0, -cs.y, 0, cs.x);\n}\n\nmat3 rotateZ(float r)\n{\n    vec2 cs = vec2(cos(r), sin(r));\n    return mat3(cs.x, cs.y, 0., -cs.y, cs.x, 0., 0., 0., 1.);\n}\n\nfloat DE(vec3 p0)\n{\n\t\/\/vec3 p=p0+sin(p0.yzx*4.0+2.4*sin(p0.zxy*5.0+time)+time*0.7)*0.5;\n\t\/\/float d=length(p)-1.0;\n    float t = iGlobalTime*.3;\n\tmat3 m = rotateZ(t)*rotateY(t*.5);\n    vec3 p = p0*m;\n\tfloat d = length(p0)+1.;\n    float r = 2.;\n    for(int i = 0; i < 14; ++i)\n    {\n        d = min(d, sdTorus82(p, vec2(r, 0.015)));\n        p *= m;\n        r -= .15;\n    }\n    return d;\n}\n\nvec2 DDE(vec3 p, vec3 rd){\n\tfloat d1=DE(p);\n  \treturn vec2(d1,d1*COMPARE_FUDGE_FACTOR);\n\tfloat dt=GRADIENT_DELTA*log(d1+1.0);\n\tfloat d2=DE(p+rd*dt);\n\tdt\/=max(dt,d1-d2);\n\treturn vec2(d1,FUDGE_FACTOR*log(d1*dt+1.0));\n}\n\nfloat rndStart(vec2 co){return fract(sin(dot(co,vec2(123.42,117.853)))*412.453);}\n\nmat3 lookat(vec3 fw,vec3 up){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,up));return mat3(rt,cross(rt,fw),fw);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 eps = vec2(.001, 0.);\n    return normalize(vec3(\n        DE(p+eps.xyy) - DE(p-eps.xyy),\n        DE(p+eps.yxy) - DE(p-eps.yxy),\n        DE(p+eps.yyx) - DE(p-eps.yyx)));\n}\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)\/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = DE( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<8; i++ )\n    {\n\t\tfloat h = DE( ro + rd*t );\n        res = min( res, 8.0*h\/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.3, 1. );\n\n}\n\n\nvec3 compute_color(vec3 ro, vec3 rd, float t)\n{\n    vec3 l = normalize(vec3(0., .7, .2));\n    vec3 p = ro+rd*t;\n    vec3 nor = normal(p);\n    vec3 ref = reflect(rd, nor);\n    \n    vec3 c = hsv2rgb(vec3(.2+length(p)*.2, 1.3, .9));\n    \n    \n    float dif = clamp( dot( nor, l ), 0.0, 1.0 )*softshadow(p, l, 0.02, 2.5);\n    float dom = smoothstep( -0.1, 0.1, ref.y )*softshadow(p, ref, 0.02, 2.5);\n   \tfloat fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    \n    float ao = calcAO(p, nor);\n    \n    vec3 v = vec3(0.);\n    v += .3*vec3(dif);\n    v += .3*dom*vec3(.6, .7, .9)*ao;\n    v += .6*fre*vec3(.7, .8, .6)*ao;\n \treturn c*v;\n}\n\nvec4 pixel(vec2 pxx)\n{\n    float pxl=4.0\/size.y;\/\/find the pixel size\n\tfloat tim=time*0.03+(iMouse.x\/size.x)*5.;\n\t\n\t\/\/position camera\n\tvec3 ro=vec3(cos(tim),0.5+(iMouse.y\/size.y)*2.-1.,sin(tim))*3.4;\n\tvec3 rd=normalize(vec3((2.0*pxx-size.xy)\/size.y,2.0));\n\trd=lookat(-ro,vec3(0.0,1.0,0.0))*rd;\n\t\/\/ro=eye;rd=normalize(dir);\n\tvec3 bcol=vec3(1.0);\n\t\/\/march\n\t\n\tfloat t=DDE(ro,rd).y*rndStart(pxx),d,od=1.0;\n    bool hit = false;\n\tvec4 col=vec4(0.);\/\/color accumulator\n\tfor(int i=0;i<120;i++){\n\t\tvec2 v=DDE(ro+rd*t,rd);\n\t\td=v.x;\/\/DE(ro+rd*t);\n\t\tfloat px=pxl*(1.0+t);\n\t\tif(d<px){\n            hit = true;\n            break;\n\t\t}\n\t\tod=d;\n\t\tt+=v.y;\/\/d;\n\t\tif(t>10.0)break;\n\t}\n    return hit ? vec4(compute_color(ro, rd, t), 1.) : \n    \t\t\t hsv2rgb(vec3(.45, 1., rd.y*.7 + .5)).xyzz*.2;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 xy = (fragCoord.xy\/size.xy);\n\tfloat v = .6 + 0.4*pow(20.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.5);\n\tfragColor=pow(pixel(fragCoord.xy)*v, vec4(1.\/2.2));\n\n} ","name":"","description":"","type":"image"}]}}