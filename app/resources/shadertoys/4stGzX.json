{"Shader":{"ver":"0.1","info":{"id":"4stGzX","date":"1451344373","viewed":222,"name":"Ray marched scene for beginners","username":"consoleartist","description":"This one is for beginners and is my first attempt at creating a ray marched scene. The goals were to setup a navigable camera, construct a simple scene, and shade it with shadows and reflections","likes":1,"published":3,"flags":0,"tags":["raymarch","tutorial","sphere","lambert","plane"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\n\/\/Some of the sources I used to construct this scene:\n\/\/Distance Functions (http:\/\/iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm)\n\/\/https:\/\/www.reddit.com\/r\/twotriangles\/comments\/1hy5qy\/tutorial_1_writing_a_simple_distance_field\/\n\nfloat sphere (vec3 rayPos, vec3 center, float radius) \/\/sphere primitive with offset controls\n{\n    return length(rayPos - center) - radius;\n}\n\n\nfloat sdPlane( vec3 rayPos, vec4 n )\n{\n  n = normalize(n); \/\/ orientation of plane, n must be normalized!\n  return dot(rayPos,n.xyz) + n.w;\n}\n\n\nfloat uberSphere(vec3 rayPos) \/\/a more complex sphere shape using booleans\n{\n   rayPos -= vec3(0.0, sin(iGlobalTime * 2.0) +2.0, 0.0); \/\/offsets. This makes the entire uber sphere \"bounce\"\n   \n   \/\/smaller spheres\n   float part_a = min(\n                      sphere(rayPos, vec3(-2.5, 0.0, 0.0), 0.5),\n                      sphere(rayPos, vec3( 2.5, 0.0, 0.0), 0.5)\n                     );\n   float part_b = min(\n                      sphere(rayPos, vec3(0.0, -2.5, 0.0), 0.5),\n                      sphere(rayPos, vec3(0.0,  2.5, 0.0), 0.5)\n                     );\n   float part_c = min(\n                      sphere(rayPos, vec3(0.0, 0.0, -2.5), 0.5),\n                      sphere(rayPos, vec3(0.0, 0.0,  2.5), 0.5)\n                     );\n   \n   \/\/larger sphere \n   float part_d = sphere(rayPos, vec3(0.0, 0.0, 0.0), 2.0);\n    \n   \n    \/\/return max(part_d, -min(part_a,min(part_b, part_c))); \/\/a large sphere with smaller ones cut into it.\n    return part_d; \/\/simplified the scene. comment this line out and uncomment the above one for a more complex scene using booleans            \n}\n\n\/\/the final assembled scene\nfloat scene(vec3 rayPos)\n{\n   float dist_a = sphere(rayPos, vec3(-0.0, -0.0, 0.0), 3.0);\n   float dist_b = sdPlane(rayPos, vec4(0.0, 1.0, 0.0, 1.0));\n   float booleanFloor = max(dist_b, -dist_a); \/\/ this cuts a sphere into the plane\n  \n   \/\/return min(uberSphere(rayPos),booleanFloor); \/\/this combines the floor with our uber sphere for the final scene\n   return min(uberSphere(rayPos),dist_b); \/\/ simplifed the scene with this line. comment this out and uncomment the above line for some additional boolean logic\n}\n\n\/\/normals\nvec3 normal(vec3 rayPos)\n{\n    vec3 e = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(scene(rayPos + e.xyy) - scene(rayPos - e.xyy),\n                          scene(rayPos + e.yxy) - scene(rayPos - e.yxy),\n                          scene(rayPos + e.yyx) - scene(rayPos - e.yyx)));\n}\n\n\/\/fresnel\nfloat fresnel(vec3 n, vec3 eye)\n{\n    \n    return 1.0 - max(dot(n,eye), 0.0);\n    \n}\n\n\n\/\/Lambert Diffuse Lighting\nfloat diffuse(vec3 normal, vec3 lightVector)\n{\n    return max(dot(normal, lightVector), 0.0);\n}\n\n\/\/hard shadows. Now we march from the current rayPos\/Surface toward the lightsource. \n\/\/If we hit an object in the scene then the surface point is in shadow and we return 0.0\nfloat shadow(vec3 rayPos, vec3 lightDir, vec3 normal)\n{\n    float sVal = 1.0; \/\/initial shadow value.sVal gets mutiplied with diffuse lighting\n    float sEPS = 0.01;\/\/ our shadow epsilon\/precision value\n    vec3 ro = rayPos + (normal * sEPS); \/\/reduces self-shadow artifacts since we are starting the march slightly above our surface\n    vec3 rd = lightDir; \/\/ we are now marching from our surface to light source.\n    float sDist; \/\/initializing our shadow distance value\n    \n    \n      for(int i = 0; i < 36; i++)\n      {\n        sDist = scene(ro); \/\/comparing shadow ray position with our scene\n        if(sDist < sEPS)\n        {\n            sVal = 0.0;\n            break;\n        }\n        ro += rd * sDist;\n     }\n    \n    return sVal;\n}\n\n\/\/reflections\nfloat reflection(vec3 eye, vec3 rayPos, vec3 n, vec3 lightDir)\n{\n    float rVal = 0.0;  \/\/reflection boolean value: 0 = miss, 1 = hit\n    vec3 refVec = normalize(reflect(-eye, n)); \/\/normalized reflection vector\n    float rEPS = 0.01; \/\/reflection EPSILON\n    vec3 ro = rayPos + (n * rEPS);\/\/ starts marching slightly \"above\" our surface to lessen artifacts\n    vec3 rd = refVec;\n    float rDist; \/\/initializing reflection distance value. This gets plugged into the scene function\n    float rShadowVal = 1.0;\n    for(int i = 0; i < 24; i++)\n    {\n        rDist = scene(ro);\n        if(rDist < rEPS)\n        {\n            \n          float rDiffuseVal = max(dot(normal(ro), lightDir), 0.0);\n            if(rDiffuseVal > 0.0) \/\/then we calculate reflection shadow ray\n            {\n              rShadowVal = shadow(ro, lightDir, normal(ro));\n            }\n            \n            rVal = rDiffuseVal * rShadowVal;\n            break;\n        }\n        ro += rd * rDist;\n    }\n        \n    return rVal;\n        \n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ color outs\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    float alpha = 1.0;\n    \n    \/\/Scene directional light\n    vec3 lightPos = vec3( sin(iGlobalTime * 2.0) * 5.0, 3.0, cos(iGlobalTime * 2.0) * 5.0); \/\/this makes the lightsource rotate around the scene center\n    vec3 lightDir = normalize(lightPos - vec3(0.0, 0.0, 0.0)); \/\/normalized light vector derived from lightPos. This vector is useful for shading and marching shadow rays\n    \n    \n\t\/\/Normalized device coordinates and aspect correction   \n    vec2 uv = fragCoord.xy \/ iResolution.xy;   \n    uv = uv * 2.0 - 1.0; \/\/ remap range from 0...1 to -1...1\n    \n    float aspectRatio = iResolution.x\/ iResolution.y;\n    uv.x *= aspectRatio; \/\/aspect correction\n    \n    \/\/Mouse values for navigation or other shenanigans. Normalized device coords and aspect correction to match UVs\n    vec2 daMouse = iMouse.xy\/ iResolution.xy;\n    daMouse = daMouse * 2.0 - 1.0;\n    daMouse.x *= aspectRatio;\n   \n    \/\/ camera controls (horizontal mouse = rotate, vertical mouse = elevation)\n    vec3 camControls;\n    camControls.x = sin(daMouse.x * 2.0) * 5.0;\n    camControls.y = (daMouse.y * 0.5 + 0.5) * 9.0;\n    camControls.z = cos(daMouse.x * 2.0) * 5.0;\n    \n    \/\/mapping camera to UV cordinates\n    vec3 cameraOrigin = vec3(camControls); \/\/cam controls\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n    vec3 upVector = vec3(0.0, 1.0, 0.0);\n    vec3 cameraDirection = normalize(cameraTarget - cameraOrigin);\n    vec3 cameraRight = normalize(cross(upVector, cameraOrigin));\n    vec3 cameraUp = cross(cameraDirection, -cameraRight); \/\/negate cameraRight to flip properly?\n   \n    vec3 rayDir = normalize(cameraRight * uv.x + cameraUp * uv.y + cameraDirection);\n    \n    \/\/Precision value used in the ray marching loop below. This number equals our \"surface\". If the distance returned from rayPos \n    \/\/to our scene function is less than this then we have \"touched\" our object and break out of the loop to do normals and lighting\n    const float EPSILON = 0.01; \n    \n    \/\/inital ray position per pixel. This is the value that gets marched forward and tested    \n    vec3 rayPos = cameraOrigin; \n    float shadowVal = 1.0;\n    \n    \n    for (int i = 0; i < 200; i++) \/\/ the larger the loop the more accurate\/slower the render time\n    {\n        float dist = scene(rayPos); \/\/ plug current rayPos into our scene function\n        \n        if (dist < EPSILON) \/\/then the ray has hit our surface so we calculate normals and lighting at this point\n        {\n            \n            vec3 n = normal(rayPos);\n            vec3 eye = normalize(cameraOrigin - rayPos);\n            float diffuseVal = diffuse(n, lightDir);\n            if(diffuseVal > 0.0) \/\/then we calculate shadow ray\n            {\n                shadowVal = shadow(rayPos, lightDir, n);\n            }\n            float refVal = reflection(eye, rayPos, n, lightDir);\n            float fresnelVal = fresnel(n, eye);\n            \n            \n            color = vec3((diffuseVal * shadowVal) + (refVal * fresnelVal));\n            break;\n        }\n        \n        rayPos += dist * rayDir; \/\/if nothing is hit we march forward and try again        \n    }\n    \n    fragColor = vec4(color,alpha);\/\/final color output\n}","name":"","description":"","type":"image"}]}}