{"Shader":{"ver":"0.1","info":{"id":"lsB3zD","date":"1384716411","viewed":6158,"name":"Doom 2","username":"reinder","description":"Reconstructing the first level of Doom 2 in a shader. This is, just like my shader 'Wolfenstein' (<a href=\"https:\/\/www.shadertoy.com\/view\/4sfGWX\" class=\"regular\" target=\"_blank\">https:\/\/www.shadertoy.com\/view\/4sfGWX<\/a>), an experiment to reconstruct some well-known textures in a textureless shader.","likes":31,"published":3,"flags":0,"tags":["procedural","textures","doom2"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Doom 2. Reinder Nijhoff 2013\n\/\/ @reindernijhoff\n\/\/\n\/\/ https:\/\/www.shadertoy.com\/view\/lsB3zD\n\/\/\n\n#define COL(r,g,b) vec3(r\/255.,g\/255.,b\/255.)\n\nfloat time = iGlobalTime;\n\n\/\/----------------------------------------------------------------------\n\/\/ Math functions\n\nfloat hash( const float n ) {\n    return fract(sin(n*14.1234512)*51231.545341231);\n}\nfloat hash( const vec2 x ) {\n\tfloat n = dot( x, vec2(14.1432,1131.15532) );\n    return fract(sin(n)*51231.545341231);\n}\nfloat crossp( const vec2 a, const vec2 b ) { return a.x*b.y - a.y*b.x; }\nvec3 rotate(vec3 r, float v){ return vec3(r.x*cos(v)+r.z*sin(v),r.y,r.z*cos(v)-r.x*sin(v));}\n\n\/\/----------------------------------------------------------------------\n\/\/ Intersection functions\n\nbool intersectWall(const vec3 ro, const vec3 rd, const vec2 a, const vec2 b, const float height, \n\t\t\t\t\t  inout float dist, inout vec2 uv ) {\n\tvec2 p = ro.xz;\tvec2 r = rd.xz;\n\tvec2 q = a-p;\tvec2 s = b-a;\n\tfloat rCrossS = crossp(r, s);\n\t\n\tif( rCrossS == 0.) {\n\t\treturn false;\n\t}\n\tfloat d = crossp(q, s) \/ rCrossS;\n\tfloat u = crossp(q, r) \/ rCrossS;\n\tfloat he = ro.y+rd.y*d;\n\t\n\tif(0. <= d && d < dist && 0. <= u && u <= 1. && he*sign(height) < height ) {\n\t\tdist = d;\n\t\tuv = vec2( -u*length(s), height-he );\n\t\treturn true;\n\t}\n\treturn false;\n}\nbool intersectFloor(const vec3 ro, const vec3 rd, const float height, \n\t\t\t\t\tinout float dist, inout vec2 uv ) {\t\n\tif (rd.y==0.0) {\n\t\treturn false;\n\t}\n\t\t\n\tfloat d = -(ro.y - height)\/rd.y;\n\td = min(100000.0, d);\n\tif( d > 0. && d < dist) {\n\t\tdist = d;\n\t\tuv = ro.xz+dist*rd.xz;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\/\/----------------------------------------------------------------------\n\/\/ Material helper functions\n\nfloat sat( const float a ) { return clamp(a,0.,1.); }\nfloat onCircleAA( const vec2 c, const vec2 centre, const float radius, const float aa ) {\n\treturn sat( aa*(radius - distance(c,centre)) );\n}\nfloat onLineX( const vec2 c, const float x ) {\n\treturn step(x,c.x)*step(c.x,x);\n}\nfloat onLineY( const vec2 c, const float y ) {\n\treturn step(y,c.y)*step(c.y,y);\n}\nfloat onBand( const float c, const float mi, const float ma ) {\n\treturn step(mi,c)*step(c,ma);\n}\nfloat onRect( const vec2 c, const vec2 lt, const vec2 rb ) {\n\treturn onBand( c.x, lt.x, rb.x )*onBand( c.y, lt.y, rb.y );\n}\nvec3 addKnobAA( const vec2 c, const vec2 centre, const float radius, const float strength, const vec3 col ) {\n\tvec2 lv = normalize( centre-c );\n\treturn mix( col, col*(1.0+strength*dot(lv,vec2(-0.7071,0.7071))), onCircleAA(c, centre, radius, 4. ) );\n}\nfloat onBandAA( const float c, const float mi, const float ma ) {\n\treturn sat( (ma-c+1.) )*sat( (c-mi+1.) );\n}\nfloat onRectAA( const vec2 c, const vec2 lt, const vec2 rb ) {\n\treturn onBandAA( c.x, lt.x, rb.x )*onBandAA( c.y, lt.y, rb.y );\n}\nvec3 addBevel( const vec2 c, const vec2 lt, const vec2 rb, const float size, const float strength, const float lil, const float lit, const vec3 col ) {\n\tfloat xl = sat( (c.x-lt.x)\/size); \n\tfloat xr = sat( (rb.x-c.x)\/size);\t\n\tfloat yt = sat( (c.y-lt.y)\/size); \n\tfloat yb = sat( (rb.y-c.y)\/size);\n\treturn mix( col, col*clamp(1.0+strength*(lil*(xl-xr)+lit*(yb-yt)), 0., 2.), onRectAA( c, lt, rb ) );\n}\n\n\/\/----------------------------------------------------------------------\n\/\/ Generate materials!\n\nvoid getMaterialColor( const int material, in vec2 uv, out vec3 col ) {\t\n\tuv = floor( uv );\n\tfloat huv = hash(uv), huvx = hash(uv.x);\n\t\n\tif( material == 0 ) { \/\/ ceiling GRNLITE1\n\t\tuv = mod(uv, vec2(64.)); vec2 centre = mod(uv,vec2(32.,16.));\n\t\tcol = mix( COL(90.,98.,69.),COL(152.,149.,125.),(0.75*huv+0.25*mod(uv.x,2.)) );\n\t\tcol = mix( col, mix(vec3(243.\/255.),vec3(169.\/255.), distance(centre,vec2(16.,8.))\/6.5), onCircleAA(centre, vec2(16.,8.), 6.25, 0.75) );\n\t} \n\telse if( material == 1 ) { \/\/ ceiling FLOOR_1\n\t\tuv = mod(uv, vec2(64.)); vec2 uv8 = mod(uv, vec2(32.,7.7));\n\t\tfloat h = huv*huvx;\n\t\tcol = mix( COL(136.,114.,95.), COL(143.,122.,92.), sat(4.*h) );\t\n\t\tcol = mix( col, COL(175.,126.,89.), sat( 2.*(hash(floor(uv*0.125))+huv-1.35) ) );\n\t\tcol = mix( col, COL(121.,103.,83.), sat( onLineX(uv,0.)+onLineY(uv,63.)) );\n\t\tcol = mix( col, COL(121.,103.,83.), onLineX(uv,31.)*huv );\n\t\tuv8.x = abs(16.-uv8.x);\n\t\tfloat d = min( max( uv8.x-8.,abs(uv8.y-4.) ), abs(distance(uv8,vec2(11.,4.))) )+huv;\n\t\tvec3 fgcol = mix( col, col*sat(((16.-uv8.y)\/12.)), step(d,3.) );\n\t\tcol = mix( mix( fgcol, COL(114.,94.,78.), sat(d*(3.5-d)\/4.)*step(2.,d) ), col, onRect(uv, vec2(32.,23),vec2(63.,39.) ) );\n\t}\n\telse if( material == 2 ) { \/\/ wall TEKGREN2 & TEKGREN5\n\t\tuv = mod(uv, vec2(128.,128)); vec2 uv64 = mod(uv, vec2(64.,65.) ); vec2 uv24 = mod(uv64, vec2(64.,24.) );\n\t\tfloat h = huv*huvx;\n\t\tcol = mix( vec3(114.\/255.), vec3(98.\/255.), sat(2.*h) );\n\t\tcol = mix( col, mix( COL(111.,114.,87.), COL(90.,98.,69.), sat(2.*h) ), sat( 100.*(hash(uv+vec2(523.,53.))*hash(150.-uv.x)-0.15)) );\t\n\t\tcol = addKnobAA( mod( uv24, vec2(3.,32.) ), vec2(0.,4.5), 1.1, 0.4, col );\n\t\tcol = mix( col, COL(137.,141.,115.), 0.7*sat( onLineX(uv64,1.)+onLineY(uv,1.)+onLineY(uv24,0.)+onLineY(uv24,19.)+onLineY(uv64,59.) ) ); \n\t\tcol = mix( col, COL(73.,81.,55.), sat( onLineX(uv64,0.)+onLineX(uv64,62.) ) ); \n\t\tcol = mix( col, mix(COL(73.,81.,55.),vec3(38.\/255.),uv24.y-22.), onBand(uv24.y,22.,23.) ); \n\t\tcol = mix( col, mix(COL(73.,81.,55.),vec3(38.\/255.),uv64.y-63.), onBand(uv64.y,63.,64.) ); \n\t\tcol = mix( col, vec3(38.\/255.), sat( onLineY(uv,0.)+onLineX(uv64,63.) ) ); \n\t\tcol = mix( col, COL(137.,141.,115.), onRect(uv,vec2(3.),vec2(60.,12.)) ); \n\t\tcol = mix( col, mix( vec3(1.), COL(255.,253.,110.), sat( abs(uv.x-32.)\/20.)-0.25*mod(uv.x,2.)), onRect(uv,vec2(4.),vec2(59.,11.)) ); \n\t}\t\n\telse if( material == 3 ) { \/\/ wall BRONZE2\n\t\tuv = mod(uv, vec2(64.,128)); float s = sin(31.15926*uv.x\/64.);\n\t\tcol = mix( vec3(75.\/255.), vec3(64.\/255.), huv );\n\t\tcol = mix( col, COL(106.,86.,51.),  sat( 5.*(huv+(s+1.2)*(1.-(uv.y+44.)\/64.))) * onBand(uv.y, 0., 30. ) );\n\t\tcol = mix( col, COL(123.,105.,85.), sat( 2.*(0.5*huvx+huv+(s+1.7)*(1.-(uv.y+44.)\/64.)-0.5) ) * onBand(uv.y, 0., 30. ) );\n\t\tcol = mix( col, COL(106.,86.,51.),  sat( 5.*(huv+(s+0.7)*(1.-(uv.y+14.)\/64.))) * onBand(uv.y, 30., 98. ) );\n\t\tcol = mix( col, COL(123.,105.,85.), sat( 2.*(1.1*huvx+(s+1.7)*(1.-(uv.y+14.)\/64.)-0.5) ) * onBand(uv.y, 30., 98. ) );\n\t\tcol = mix( col, COL(7.,59.,20.), sat( huv*uv.y\/96.-0.5) );\n\t\tcol = mix( col, COL(106.,86.,51.),  sat( 5.*(huv+(s+1.2)*(1.-(uv.y-40.)\/64.))) * onBand(uv.y, 98., 128. ) );\n\t\tcol = mix( col, COL(123.,105.,85.), sat( 2.*(huvx+(s+1.7)*(1.-(uv.y-40.)\/64.)-0.5) ) * onBand(uv.y, 98., 128. ) );\t\n\t\tcol = mix( col, mix(COL(110.,89.,70.),COL(130.,112.,92.),sat((uv.y-3.)\/18.)), onRectAA(mod(uv,vec2(16.,128.)),vec2(6.5,1.5),vec2(12.5,21.5)) );\n\t\tcol = addBevel( mod(uv,vec2(16.,128.)),vec2(5.5,-2.5),vec2(12.5,21.5), 2.3, 1., 0.1, 0.7, col );\n\t\tcol = mix( col, addBevel( abs(mod(uv+vec2(0.,-85.),vec2(64.))-vec2(32.,0.)), vec2(15.5,0.5), vec2(34.5,52.5), 1.2, 1., 0.5, -0.7, col ), onBand(uv.y, 30.,97.));\n\t\tcol = mix( col, 0.7*col, sat( onLineY(uv,127.)+onLineX(uv,0.)+onBand(uv.y, 97.,98.)+onBand(uv.y, 29.,30.)) );\n\t\tcol = mix( col, 1.2*col, sat( onBand(uv.y, 98.,99.)+onBand(uv.y, 0.,1.)+onLineX(uv, 63.)) );\n\t\tcol = mix( col, 0.75*col*uv.x, onBand(uv.x, 0., 1.)*onBand(uv.y, 30.,97.) );\n\t\tcol *= 1.0-0.1*huv;\n\t}\t\n\telse if( material == 4 ) { \/\/ wall STEP2\n\t\tuv = mod(uv, vec2(64.,16.));\n\t\tcol = mix( COL(182.,133.,93.), COL(132.,98.,66.), sat(huv-0.5) );\n\t\tcol = mix( col, COL(129.,111.,79.), sat(1.-(uv.y-4.)\/8.) );\n\t\tcol = mix( col, COL(102.,82.,50.), sat((huv+1.)*onRectAA(mod(uv,vec2(32.,16.)), vec2(1.5,9.7), vec2(29.5,13.5))) );\n\t\tcol = mix( col, COL(102.,82.,50.), 0.6*sat((huv+1.)*onRectAA(mod(uv,vec2(8.,16.)), vec2(2.5,3.5), vec2(5.5,6.2))) );\n\t\tcol = mix( col, COL(143.,122.,92.), onLineY(uv,0.) );\n\t\tcol = mix( col, COL(106.,86.,61.), onLineY(uv,2.) );\n\t\tcol *= 1.-0.2*onLineY(uv,3.);\n\t}\n\telse if( material == 5 ) { \/\/ wall PIPE4\n\t\tuv = mod(uv, vec2(128.,64.)); float huv2 = hash( uv*5312. );\n\t\tcol = mix( mix(COL(184.,165.,144.),COL(136.,102.,67.),uv.x\/128.), \n\t\t\t\t   mix(COL(142.,122.,104.),COL(93.,77.,50.),uv.x\/128.), sat(huv+huvx) );\n\t\tcol *= 1.+0.5*sat(hash(uv.y)-0.7);\n\t\tcol *= 1.-0.2*sat(hash(uv.y-1.)-0.7);\n\t\tcol = mix( col, COL(102.,82.,50.), sat(0.2*huv2+3.*(huvx-0.7)) );\n\t\tcol = mix( col, COL(165.,122.,85.), (0.75+0.5*huv2)*sat( onBandAA(uv.x,122.5,123.5)+onBandAA(uv.x,117.5,118.5)+onBandAA(uv.x,108.5,109.5) ) );\n\t\tcol = mix( col, mix(  (1.-sat(0.2*abs(2.8-mod(uv.x,6.))))*mix(COL(175.,126.,89.),COL(143.,107.,71.),0.4*distance( mod(uv,vec2(6.)), vec2 (1.5))), COL(77.,68.,40.), onBandAA(mod(uv.x+1.,6.),0.,1.5)),\n\t\t\t\t\t\t\t\t   (0.75+0.5*huv2)*sat( onBandAA(uv.x,6.5,11.5)+onBandAA(uv.x,54.5,59.5)+onBandAA(uv.x,66.5,70.5)+onBandAA(uv.x,72.5,78.5) ) );\n\t\tcol = mix( col, mix( COL(82.,90.,64.), 1.2*COL(118.,125.,99.), huv*(sat(abs(uv.x-14.)-huv)+sat(abs(uv.x-62.)-huv)) ), onBandAA(uv.x,12.8,13.8) + onBandAA(uv.x,60.8,61.8));\n\t\tcol = mix( col, vec3(0.), 0.3*(onBandAA(uv.y,18.8,21.8)*onBandAA(uv.x,40.8,52.8) + onBandAA(uv.x,0.1,3.7) + onBandAA(uv.x,41.3,44.2) + onBandAA(uv.x,48.9,51.8)+0.6*onBandAA(uv.x,80.1,81.6)));\n\t\tcol = mix( col, mix( 1.2*COL(205.,186.,167.), COL(143.,122.,92.), 0.3*(sat(abs(uv.x-2.)+huv)+sat(abs(uv.x-43.)+huv)+sat(abs(uv.x-51.)+huv)) ), onBandAA(uv.x,0.8,2.8) + onBandAA(uv.x,42.1,43.3) + onBandAA(uv.x,49.8,51.2)+0.6*onBandAA(uv.x,80.8,81.5));\n\t\tcol = mix( col, mix( 1.2*COL(205.,186.,167.), COL(154.,133.,105.), (sat(abs(uv.y-20.5)+huv)) ), onBandAA(uv.y,19.3,21.2)*onBandAA(uv.x,40.8,52.1));\n\t\tfloat d = min( min( min( min( min( min( distance(uv,vec2(6.,39.)), 0.8*distance(uv,vec2(23.,45.)) ), 1.2*distance(uv,vec2(39.,30.)) )\n\t\t\t\t\t  , 1.5*distance(uv,vec2(48.,42.)) ), distance(uv,vec2(90.,32.)) ), 0.8*distance(uv,vec2(98.,50.)) ), 1.15*distance(uv,vec2(120.,44.)) );;\n\t\td *= (1.-0.8*(sat(hash(uv.x+uv.y)-0.6)+sat(huvx-0.6)));\n\t\tcol = mix( col,COL(93.,77.,50.), sat((7.-d)\/8.) );\n\t\tcol = mix( col, vec3(0.), pow(sat((5.-d)\/6.),1.5) );\n\t}\n\telse if( material == 6 ) { \/\/ floor FLOOR_3_3\n\t\tuv = mod(uv, vec2(64.));\n\t\tcol = mix( COL(147.,126.,108.), COL(175.,152.,134.), sat( 1.5*(huv+hash(uv.x-uv.y)-0.95-uv.y\/128.)) );\n\t\tcol = mix( col, COL(175.,152.,134.), sat( 1.5*(huv+hash(uv.x-uv.y*1.1+5.)-1.8+uv.y\/64.)) );\n\t\tcol = mix( col, COL(130.,133.,108.), sat( 10.*(huv+hash(uv.x*1.1-uv.y+3.)-1.25)) );\n\t\tcol = mix( col, mix( COL(118.,125.,99.), COL(130.,133.,108.), 1.-huv), sat(5.*(huv-1.5+uv.y\/64.)) );\n\t\tcol = mix( col, COL(129.,111.,91.), sat( onLineX(uv,0.)+onLineY(uv,63.) ) );\n\t\tcol *= sat(0.92+huv);\t\t\n\t} \n\telse if( material == 7 ) { \/\/ floor FLOOR_0_1\n\t\tuv = mod(uv, vec2(64.)); \n\t\tfloat h = hash(3.*uv.x+uv.y);\n\t\tcol = mix( COL(136.,114.,95.), COL(143.,122.,104.), sat(4.*h*huv) );\n\t\tcol = mix( col, COL(129.,111.,91.), sat(h-0.5) );\t\n\t\tcol *= 1.+0.05*sat( 0.3+mod(uv.x,2.)*cos(uv.y*0.2)*huv );\n\t\tcol = mix( col, COL(175.,126.,89.), sat( 2.*(hash(floor(uv*0.125))+huv-1.5) ) );\n\t\tvec3 ncol = mix( col, COL(114.,94.,78.), sat( \n\t\t\t(0.4*huv+0.4)*onRectAA( mod(uv+vec2(0.,33.),vec2(64.)), vec2(6.5,0.5), vec2(36.5,58.5) )\n\t\t\t\t\t\t -onRectAA( mod(uv+vec2(0.,33.),vec2(64.)), vec2(9.5,3.5), vec2(33.5,55.5) ) ));\n\t\tncol = mix( ncol, COL(114.,94.,78.), sat( (0.6*huv+0.3)*onRectAA( mod(uv+vec2(0.,5.),vec2(64.)), vec2(33.5,0.5), vec2(59.5,60.5) ) ));\n\t\tncol = mix( ncol, col, sat(               0.8*onRectAA( mod(uv+vec2(0.,5.),vec2(64.)), vec2(35.5,2.5), vec2(57.5,58.5) ) ));\n\t\tncol = mix( ncol, COL(121.,103.,81.), sat( (0.8*huv+0.9)*onRectAA( mod(uv+vec2(0.,53.),vec2(64.)), vec2(18.5,0.5), vec2(41.5,22.5) ) ));\n\t\tncol = mix( ncol, col, sat(               onRectAA( mod(uv+vec2(0.,53.),vec2(64.)), vec2(19.5,1.5), vec2(40.5,21.5) ) ));\n\t\tncol = mix( ncol, COL(114.,94.,78. ), sat( (0.8*huv+0.6)*onRectAA( mod(uv+vec2(8.,46.),vec2(64.)), vec2(0.5,0.5), vec2(20.5,36.5) ) ));\n\t\tcol  = mix( ncol, col, sat(               onRectAA( mod(uv+vec2(8.,46.),vec2(64.)), vec2(1.5,1.5), vec2(19.5,35.5) ) ));\n\t} else  {\n\t\tcol = vec3(0.5);\n\t}\n}\n\n\/\/----------------------------------------------------------------------\n\/\/ Render MAP functions\n\nstruct lineDef { vec2 a, b; float h; float l; int m; };\n\nvec3 castRay( const vec3 ro, const vec3 rd ) {\n\tlineDef ldfs[14];\n\tldfs[0]  = lineDef(vec2(192.,-448.), vec2(320.,-320.), 264., 128., 5 );\n\tldfs[1]  = lineDef(vec2(320.,-320.), vec2(256.,0.),    264., 128., 5 );\n\tldfs[2]  = lineDef(vec2(256.,0.),    vec2(64.,0.),     264., 128., 5 );\n\tldfs[4]  = lineDef(vec2(64.,0.),     vec2(0.,0.),       56., 208., 4 );\n\tldfs[3]  = lineDef(vec2(0.,448.),    vec2(320.,448.),  128., 224., 2 );\n\tldfs[5]  = lineDef(vec2(64.,0.),     vec2(-64.,0.),   -128., 208., 5 );\n\tldfs[6]  = lineDef(vec2(192.,-320.), vec2(128.,-320.), 264., 128., 3 );\n\tldfs[7]  = lineDef(vec2(128.,-320.), vec2(128.,-256.), 264., 128., 3 );\n\tldfs[8]  = lineDef(vec2(192.,0.),    vec2(0.,-320.),    16., 144., 4 );\n\tldfs[9]  = lineDef(vec2(160.,0.),    vec2(0.,-256.),    24., 160., 4 );\n\tldfs[10] = lineDef(vec2(128.,0.),    vec2(0.,-192.),    32., 176., 4 );\n\tldfs[11] = lineDef(vec2(96.,0.),     vec2(0.,-128.),    40., 192., 4 );\n\tldfs[12] = lineDef(vec2(64.,0.),     vec2(0.,-64.),     48., 208., 4 );\n\tldfs[13] = lineDef(vec2(64.,0.),     vec2(64.,320.),   128., 224., 2 );\n\t\n\tfloat dist = 999999., curdist; vec2 uv, curuv;\n\tvec3 col = vec3( 0. ); float lightning = 128.; int mat = 0;\n\n\t\/\/ check walls\n\tfor( int i=0; i<14; i++ ) {\n\t\tvec2 a = ldfs[i].a, b = ldfs[i].b; float h=ldfs[i].h; \t\t\n\t\tif( intersectWall(ro, rd, a, b, h, dist, uv) || \n\t\t\tintersectWall(ro, rd, b*vec2(-1.,1.), a*vec2(-1.,1.), h, dist, uv) ) {\n\t\t\tmat = ldfs[i].m;\n\t\t\tlightning = ldfs[i].l * (1.-0.2*abs( normalize( (a-b).yx ).y ));\n\t\t}\n\t}\n\tif( mat == 5 ) { \/\/ fix large texture on wall above portal\n\t\tvec3 intersection = ro + rd*dist;\n\t\tif( intersection.z > -0.1 ) {\n\t\t\tuv = -intersection.xy+vec2(64.,0.);\n\t\t\tlightning = 0.8*max(128., min(208., 248.-20.*floor(abs(intersection.x)\/32.)));\n\t\t}\n\t\tuv *= 0.5;\n\t}\n\t\n\t\/\/ check floor and ceiling\n\tif( intersectFloor(ro, rd, 264., dist, uv ) ) {\n\t\tmat = 1;\n\t\tlightning =128.;\n\t\tfloat c1=320., c2=196.;\n\t\tfor( int i=4; i>=0; i-- ) {\n\t\t\tif( abs(uv.x)*(c1\/c2)-uv.y < c1 ) {\n\t\t\t\tlightning = float(208-i*16);\n\t\t\t}\n\t\t\tc1-=64.; c2-=32.;\n\t\t}\n\t}\n\tif( intersectFloor(ro, rd, 8., dist, uv ) ) {\n\t\tmat = 7;\n\t\tlightning =128.;\n\t}\t\t\n\tfloat c1=64., c2=64., c3=48.;\n\tfor( int i=0; i<5; i++ ) {\n\t\tcurdist = dist;\n\t\tif( intersectFloor(ro, rd, c3, curdist, curuv ) && abs(curuv.x)*(c1\/c2)-curuv.y < c1 ) {\n\t\t\tuv = curuv;\n\t\t\tmat = 7;\n\t\t\tdist = curdist;\n\t\t\tlightning = float(208-i*16);\n\t\t}\n\t\tc3-=8.; c1+=64.; c2+=32.;\n\t}\n\t\/\/ and hall\t\n\tcurdist = dist;\n\tif( (intersectFloor(ro, rd, 56., curdist, curuv ) || intersectFloor(ro, rd, 128., curdist, curuv ) ) && curuv.y > 0. ) {\n\t\tdist = curdist;\n\t\tuv = curuv;\n\t\tmat = rd.y>0.?0:6;\n\t\tlightning = 224.;\n\t}\n\t\n\tgetMaterialColor( mat, uv, col );\n\t\t\n\tcol *= 0.3*pow(2.*lightning\/255., 2.5)*sat( 1.-curdist\/2000. );\t\n\t\/\/ fake 8-bit pallete\n\tcol = floor((col)*64.+vec3(0.5))\/64.;\n\treturn col;\n}\n\n\/\/----------------------------------------------------------------------\n\/\/ Camera path\n\nfloat getPathHeight( const float z, const float t ) {\n\treturn max( 0.+step(0.,z)*56.+step(z,-448.)*56.+\n\t\tmix(56.,8.,(448.+z)\/32.)*step(-448.,z)*step(z,-416.)+\n\t\tmix(8.,56.,(320.+z)\/320.)*step(z,0.)*step(-320.,z), 8.) + 56.;\n}\nvec2 path( const float t ) {\n\treturn vec2(32.*sin(t*0.21), -200.-249.*cos( max(0.,mod(t,30.)-10.)*(3.1415936\/10.) ) );\n}\n\n\n\/\/----------------------------------------------------------------------\n\/\/ Main\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 q = fragCoord.xy\/iResolution.xy;\n\tvec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x\/ iResolution.y;\n\n\tvec3 ro; ro.xz = path(time); \n\tvec3 ta; ta.xz = path(time+0.1) + vec2(0.,20.);\n\tta.y = ro.y = getPathHeight(ro.z, time);\n\t\n    vec3 rdcenter =  rotate( normalize(ta - ro), 0.5*cos(time*0.5) );\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), rdcenter ));\n    vec3 vv = normalize(cross(rdcenter,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.25*rdcenter );\n\t\n\tvec3 col = castRay( ro, rd );\n\t\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}