{"Shader":{"ver":"0.1","info":{"id":"XsSGWm","date":"1389492411","viewed":2350,"name":"Dragon's Gullet","username":"RavenWorks","description":"based on Noben's art: <a href=\"http:\/\/forum.altermeta.net\/index.php\/topic,2381.msg29005.html\" class=\"regular\" target=\"_blank\">http:\/\/forum.altermeta.net\/index.php\/topic,2381.msg29005.html<\/a><br\/>thanks to <a href=\"http:\/\/iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\" class=\"regular\" target=\"_blank\">http:\/\/iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm<\/a>","likes":10,"published":3,"flags":0,"tags":["raymarch","fog","liquid","altermeta"],"hasliked":0},"renderpass":[{"inputs":[{"id":7,"src":"\/presets\/tex06.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"const float PI=3.14159265;\n\nfloat obj_spiral( vec3 p ){\n\t\n\tconst float flattenAmt = 2.0;\n\tconst float torusRadius = 3.5;\n\tfloat spacingScale = (1.3*flattenAmt) + sin(iGlobalTime*1.8)*0.1;\/\/kinda breaks the math, but close enough for fog\n\tfloat spiralPeriod = torusRadius*spacingScale;\n\t\n\tp.y *= flattenAmt;\n\t\n\tp.x += sin(iGlobalTime*2.0+p.y*0.4)*0.5;\n\tp.z += cos(iGlobalTime*2.0+p.y*0.4)*0.5;\n\tfloat ang = -atan(p.x,p.z);\n\tfloat dist = p.x*p.x+p.z*p.z;\/\/maybe faster to use length() even though sqrt isn't necessary?\n\t\n\tp.y -= dist*0.1;\n\t\n\t\/\/ this is super artifacty, but that actually suits the look...!\n\tfloat periodX = 6.0;\n\tfloat periodZ = 6.0;\n\tfloat distX = 0.05;\n\tfloat distZ = 0.05;\n\tfloat inX = p.x + cos(dist)*(0.5+cos(ang*2.0+iGlobalTime*3.0)*1.0);\n\tfloat inZ = p.z + sin(dist)*(0.5+sin(ang*2.0+iGlobalTime*3.0)*1.0);\n\tp.y += cos(inZ*periodZ)*distZ + sin(inX*periodX)*distX;\n\t\/\/ only modifying the y seems to look good enough by itself\n\t\n\t\n\t\n\t\n\t\n\t\n\tp.y += p.x*(1.2+sin(iGlobalTime*1.5+p.y*0.3)*0.2);\n\tp.y += ang\/(PI*2.0)*spiralPeriod;\n\tfloat spiralDist = -ang+PI+floor((p.y\/spiralPeriod))*PI*2.0;\n\tp.y = mod(p.y, spiralPeriod)-spiralPeriod*0.5;\n\t\n\tvec2 q = vec2((length(p.xz))-torusRadius,p.y);\n\t\n\t\n\t\n\tfloat wobbleC = \n\t\t    iGlobalTime*3.5+spiralDist*1.5  +\n\t\tsin(iGlobalTime*4.0+spiralDist*1.8) + \n\t\tsin(iGlobalTime*1.5+spiralDist*0.3) *\n\t\tsin(iGlobalTime*7.5+spiralDist*5.9);\n\tfloat ringRadius = 1.5 + sin(wobbleC)*0.2;\/\/sin(iGlobalTime+p.y)*0.2;\n\t\n\treturn length(q)-ringRadius;\n\t\n}\n\nconst float wallDist = 15.0;\nconst float wallThickness = 1.5;\nconst float wallRepeatX = PI\/5.0;\nconst float wallRepeatY = 12.0;\nconst float archThickness = 3.6;\nconst float archThicknessHalf = archThickness*0.5;\n\nfloat obj_cylinder(vec3 p){\n\t\n\tvec2 d = vec2(\n\t\tabs(p.z-wallDist)-wallThickness,\n\t\tarchThickness-abs(p.y+archThicknessHalf)\n\t);\n\t\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n\t\n}\n\nfloat obj_roundholes(vec3 p){\n\treturn length(vec2(p.x*17.2,p.y-archThicknessHalf))-archThickness;\n}\n\nfloat obj_columnHalf(vec3 p,float side){\n\treturn length(vec2((p.x+wallRepeatX*side*0.5)*18.2,p.z-wallDist))-0.7;\n}\nfloat obj_columns(vec3 p){\n\treturn min(obj_columnHalf(p,1.0),obj_columnHalf(p,-1.0));\n\t\/\/ yuck. too lazy to redo the mod though,\n\t\/\/ and this is a quick enough calculation that who cares!\n}\n\nfloat opS( float d1, float d2 ){\n    return max(-d1,d2);\n}\n\nfloat obj_room(vec3 worldP){\n\t\n\tfloat worldWithinY = (worldP.y\/wallRepeatY) + 0.5;\n\tfloat withinY = (fract( worldWithinY ) - 0.5)*wallRepeatY;\n\tfloat stepY = floor( worldWithinY );\n\t\n\tfloat rotOff = mod(stepY,2.0)*wallRepeatX*0.5;\n\t\n\tfloat worldRotX = atan(worldP.z,worldP.x);\n\t\n\tvec3 p = vec3(\n\t\tmod(worldRotX+rotOff+wallRepeatX*0.5,wallRepeatX)-wallRepeatX*0.5,\n\t\twithinY,\n\t\tlength(worldP.xz)\n\t);\n\t\/\/ converting to cylindrical space makes everything bow outwards a little,\n\t\/\/ but saves trouble in determining where things go...\n\t\/\/ (though it does make it messy to squish the X back into world space..\n\t\/\/  I could probably fix that but whatever)\n\t\n\tvec2 uv = vec2(worldRotX\/PI*1.0,worldP.y*0.025-p.z*0.0125);\n\tfloat bumpAmt = texture2D(iChannel0, uv).g * -0.1;\n\treturn min(obj_columns(p),opS(obj_roundholes(p),obj_cylinder(p))) + bumpAmt;\n\t\n}\n\nfloat wallWave(vec3 p){\n\tfloat rotX = atan(p.z,p.x);\n\tfloat wavePower = 2.0+sin(iGlobalTime*2.0+rotX*4.0)*1.5;\n\tfloat waveAmt = sin(p.y+sin(iGlobalTime*1.0)*1.5+sin(iGlobalTime*2.0+rotX*8.0+sin(rotX)*4.0)+rotX*2.0);\n\treturn pow((waveAmt+1.0)*0.5,wavePower)*0.22;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 vPos = fragCoord.xy\/iResolution.xy - 0.5;\n\t\n\t\/\/ Camera up vector.\n\tvec3 vuv=vec3(0,1,0); \n\t\/\/ Camera pos\n\tfloat rotAng = (iMouse.x\/iResolution.x)*PI*2.0 + iGlobalTime*0.3;\n\tconst float cameraDist = 11.0;\n\tvec3 prp = vec3(cos(rotAng)*cameraDist,((iMouse.y\/iResolution.y)-0.5)*5.0,sin(rotAng)*cameraDist);\n\t\/\/ Camera lookat\n\tvec3 vrp=vec3(0,0,0);\n\t\n\t\/\/ light\n\tvec3 L = normalize(vec3(1.0,-4.0,0.0));\n\t\n\t\/\/ Camera setup.\n\tvec3 vpn=normalize(vrp-prp);\n\tvec3 u=normalize(cross(vuv,vpn));\n\tvec3 v=cross(vpn,u);\n\tvec3 vcv=(prp+vpn);\n\tvec3 scrCoord=vcv+vPos.x*u*iResolution.x\/iResolution.y+vPos.y*v;\n\tvec3 scp=normalize(scrCoord-prp);\n\t\n\t\/\/ Raymarching.\n\tconst vec3 e=vec3(0.02,0,0);\n\tconst float maxd=40.0; \/\/Max depth\n\tvec3 c,p,N;\n\tfloat sA,sP;\n\tfloat f, d;\n\t\n\t\/\/ march to bg\n\tvec3 bgColor=vec3(0,0,0);\n \tf=1.0;\n\td=0.1;\n \tfor(int i=0;i<32;i++){\n\t\tif ((abs(d) < .001) || (f > maxd)) break;\n\t\tf+=d;\n\t\tp=prp+scp*f;\n\t\td = obj_room(p);\n\t}\n\t\n\tconst vec3 rockC = vec3(0.05,0.1,0.3);\n\tconst vec3 glowC = vec3(1.0,0.25,0.5);\n\t\n\tif (f < maxd){\n\t\tvec3 n = vec3(d-obj_room(p-e.xyy),\n\t\t\t\t\t  d-obj_room(p-e.yxy),\n\t\t\t\t\t  d-obj_room(p-e.yyx));\n\t\tN = normalize(n);\n\t\t\n\t\tfloat diffuse=max(dot(N,L),0.0);\n\t\tvec3 H = normalize(L-scp);\n\t\tfloat specular = max(dot(H,N),0.0);\n\t\tbgColor= (diffuse*0.9+0.1)*rockC + pow(specular,16.0)*0.25 + specular*wallWave(p)*glowC;\n\t}\n\t\n\t\/\/ march to flame\n\tconst float sparkleSpecAmt = 0.7;\n\tconst vec3 pinkFlame = vec3(1.0,0.25,0.5)*sparkleSpecAmt;\n\tconst vec3 yellowFlame = vec3(1.0,0.8,0.38)*sparkleSpecAmt - pinkFlame;\n\tconst float sparklePinkSpecPower = 4.0;\n\tconst float sparkleYellowSpecPower = 64.0;\n\t\n\tvec3 flameColor=vec3(0,0,0);\n\tfloat fogAccumulation = 0.0;\n\tfloat curWithinSpd = 0.0;\n\tf=1.0;\n\td=0.1;\n\tconst int countAmt = 256;\n\tvec3 firstCrossP;\n\tvec3 secondCrossP;\n\tfloat firstCrossD;\n\tfloat secondCrossD;\n\tbool wasOutside = true;\n\tint crosses = 0;\n \tfor(int i=0;i<countAmt;i++){\n\t\tif (f > maxd) {\n\t\t\t\/\/flameColor = vec3(0.0,0.0,1.0);\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (d < 0.01) {\n\t\t\tf+=0.1;\n\t\t\tcurWithinSpd += 0.0001;\n\t\t\tfogAccumulation += curWithinSpd;\n\t\t\tif (wasOutside) {\n\t\t\t\tcrosses++;\n\t\t\t\tif (crosses == 1) {\n\t\t\t\t\tfirstCrossP = p;\n\t\t\t\t\tfirstCrossD = d;\n\t\t\t\t} else {\n\t\t\t\t\tsecondCrossP = p;\n\t\t\t\t\tsecondCrossD = d;\n\t\t\t\t}\n\t\t\t}\n\t\t\twasOutside = false;\n\t\t} else {\n\t\t\tcurWithinSpd = 0.0;\n\t\t\tf+=d*0.5;\/\/this isn't completely thought-out, but it does the job..\n\t\t\t\/\/ a smaller number would have even less artifacts,\n\t\t\t\/\/ but I actually like the look of the smaller artifacts so let's keep them!\n\t\t\twasOutside = true;\n\t\t}\n\t\tp=prp+scp*f;\n\t\td = obj_spiral(p);\n\t\t\n\t\t\/\/if (i==countAmt-1) flameColor = vec3(1.0,0.0,0.0);\n\t}\n\tflameColor += vec3(0.2,1.0,0.8)*min(fogAccumulation,0.05)*3.0;\n\t\n\tif (crosses >= 1) {\n\t\tvec3 n = vec3(firstCrossD-obj_spiral(firstCrossP-e.xyy),\n\t\t\t\t\t  firstCrossD-obj_spiral(firstCrossP-e.yxy),\n\t\t\t\t\t  firstCrossD-obj_spiral(firstCrossP-e.yyx));\n\t\tN = normalize(n);\n\t\tfloat b=max(dot(N,normalize(-scp)),0.0);\n\t\tflameColor += pow(b,sparklePinkSpecPower)*pinkFlame;\n\t\tflameColor += pow(b,sparkleYellowSpecPower)*yellowFlame;\n\t}\n\t\n\tif (crosses >= 2) {\n\t\tvec3 n = vec3(secondCrossD-obj_spiral(secondCrossP-e.xyy),\n\t\t\t\t\t  secondCrossD-obj_spiral(secondCrossP-e.yxy),\n\t\t\t\t\t  secondCrossD-obj_spiral(secondCrossP-e.yyx));\n\t\tN = normalize(n);\n\t\tfloat b=max(dot(N,normalize(-scp)),0.0);\n\t\tflameColor += pow(b,sparklePinkSpecPower)*pinkFlame;\n\t\tflameColor += pow(b,sparkleYellowSpecPower)*yellowFlame;\n\t}\n\t\n\tfragColor = vec4((bgColor+flameColor),1.0);\n}","name":"","description":"","type":"image"}]}}