{"Shader":{"ver":"0.1","info":{"id":"Mtj3DG","date":"1432597510","viewed":1279,"name":"Ancient Mars","username":"florian","description":"Scene from Karla Quintero's modern dance performance \"If Mars\"<br\/>Mashup of heavy RMF, Kali's fractal (and stars I believe) and Nimitz's fog trick.<br\/>Added IQ's noise for posting on shadertoy.<br\/>Apologies for the brute force detail and hence slowness.","likes":22,"published":3,"flags":0,"tags":["mars"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Ancient Ruins\n\/\/ Scene from Karla Quintero's modern dance performance \"If Mars\"\n\/\/\n\/\/ Mashup of heavy RMF, Kali's fractal (and stars I believe) and Nimitz's fog trick.\n\/\/ Added IQ's noise for posting on shadertoy.\n\/\/ Apologies for the brute force detail and hence slowness.\n\/\/ \n\/\/ @rianflo\n\n\nfloat smin(float a, float b, float k)\n{\n\treturn -(log(exp(k*-a)+exp(k*-b))\/k);\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n#if 1\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D( iChannel0, (uv+ 0.5)\/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n#else\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n#endif\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n\nconst float PI = 3.1415926535897932384626433832795;\n\n\n\/\/ ----------------------------------------------------------EDIT ME----------------------------------------------------------------------\nfloat rmf(vec3 p)\n{\n    float signal = 0.0;\n    float value  = 0.0;\n    float weight = 1.0;\n    float h = 1.0;\n    float f = 1.0;\n\n    for (int curOctave=0; curOctave < 11; curOctave++) \n    {\n        signal = noise(p)*2.0-0.4;\n        signal = pow(1.0 - abs(signal), 2.0) * weight;\n        weight = clamp(0.0, 1.0, signal * 16.0);\n        value += (signal * pow(f, -1.0));\n        f *= 2.0;\n        p *= 2.0;\n    }\n    \n    return (value * 1.25) - 1.0;\n}\n\nconst int Iterations=15;\n\nconst float Scale=2.1;\n\nfloat de(vec3 pos) \n{\n\tvec3 p=pos;\n    p.y +=4.76-iGlobalTime*0.005;\n\tp.xz=abs(.5-mod(pos.xz,1.))+.01;\n\tfloat DEfactor=1.;\n\tfloat ot=1000.;\n\tfor (int i=0; i<Iterations; i++) \n    {\n\t\tp = abs(p)-vec3(0.,2.,0.);  \n\t\tfloat r2 = dot(p, p);\n\t\tot = min(ot,abs(length(p)));\n\t\tfloat sc=Scale\/clamp(r2,0.4,1.);\n\t\tp*=sc; \n\t\tDEfactor*=sc;\n\t\tp = p - vec3(0.5,1.,0.5);\n\t}\n    float rr=length(pos+vec3(0.,-3.03,1.85))-.017;\n    float d=length(p)\/DEfactor-.0005;\n\t\n    return d;\n}\n\nfloat sdf(vec3 p)\n{\n\tfloat sd = p.y;\n    \n    \n\tsd = smin(sd, de(p), 60.0);\n    \/\/sd = min(sd, length(p)-1.0-rmf(p+time*0.01, 8.0, 1.8, coneR)*0.06);\n    sd -= rmf(p*8.0+2.0)*0.015;       \/\/ ceiling\n    \n    return sd;\n}\n\nvec4 getColorAndRoughness(vec3 p, vec3 N, float ambo)\n{\n    return vec4(1.0);\n}\n\nvec3 grad(vec3 p, float coneR)\n{\n    coneR*=3.0;\n    vec3 f = vec3(sdf(p));\n    vec3 g = vec3(sdf(p+vec3(coneR, 0.0, 0.0)),\n                  sdf(p+vec3(0.0, coneR, 0.0)),\n                  sdf(p+vec3(0.0, 0.0, coneR)));\n    return (g-f) \/ coneR;\n}\n\nvec3 setupRayDirection(float camFov)\n{\n\tvec2 coord = vec2(gl_FragCoord.xy);\n    vec2 v = vec2(coord \/ iResolution.xy) * 2.0 - 1.0;\n    float camAspect = iResolution.x\/iResolution.y;\n    float fov_y_scale = tan(camFov\/2.0);\n    vec3 raydir = vec3(v.x*fov_y_scale*camAspect, v.y*fov_y_scale, -1.0);\n    return normalize(raydir);\n}\n\nfloat ambientOcclusion( in vec3 pos, in vec3 nor, float coneR )\n{\n  float occ = 0.0;\n  float sca = 1.1;\n  for ( int i=0; i<5; i++ )\n  {\n    float hr = 0.02 + 0.11*float(i) \/ 4.0;\n    vec3 aopos =  nor * hr + pos;\n    float dd = sdf(aopos);\n    occ += -(dd-hr)*sca;\n    sca *= 0.95;\n  }\n  return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );\n}\n\n\nvec3 shade(vec3 ro, vec3 rd, float t, float coneR, vec3 ld)\n{\n    vec3 g = grad(ro+rd*t, coneR);\n    vec3 N = normalize(g);\n    float ambo = ambientOcclusion(ro+rd*t, N, coneR);\n    float ndl = clamp(dot(N, ld), 0.0, 1.0);\n    vec3 color = mix(vec3(0.782, 0.569, 0.45), vec3(0.8, 0.678, 0.569), clamp(1.5-length(g), 0.0, 1.0));\n    return vec3(mix(ambo*color, ambo*color*ndl, 0.5));\n}\n\nfloat fogmap(in vec3 p, in float d)\n{\n    vec3 q = p;\n    q.z-=0.0;\n    p.x -= iGlobalTime*0.05;\n    vec3 turb = vec3(noise(80.0*p.xyz+iGlobalTime*0.51)*0.5, noise(160.0*p.xzy+iGlobalTime*0.2)*0.3, noise(60.0*p.zyx+iGlobalTime*0.1)*0.2);\n    p += turb;\n    float fog = (max(noise(p*64.0+0.1)-0.1, 0.0)*noise(p*16.0))*0.03;\n    \n    return fog;\n}\n\n\n#define iterations 14\n#define formuparam 0.530\n\n#define volsteps 3\n#define stepsize 0.2\n\n#define zoom   1.20\n#define tile   0.850\n#define speed  0.1\n\n#define brightness 0.0015\n#define darkmatter 0.400\n#define distfading 0.160\n#define saturation 0.400\n\nvec3 space(vec2 uv)\n{\n    vec3 v=vec3(0.4);\n    vec3 dir=vec3(uv*zoom,1.);\n\t\n\t\/\/float a2=2.0;\n\tfloat a1=4.0;\/\/+time*0.001;\n\tmat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n\tmat2 rot2=rot1;\/\/mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n\tdir.xz*=rot1;\n\tdir.xy*=rot2;\n\t\n\t\/\/from.x-=time;\n\t\/\/mouse movement\n\tvec3 from=vec3(170.0, 170.2,0.01);\n\tfrom+=vec3(0.0,0.0,-2.);\n\t\n\t\/\/from.x-=iMouse.x;\n\t\/\/from.y-=iMouse.y;\n\t\n\tfrom.xz*=rot1;\n\tfrom.xy*=rot2;\n\t\n\t\/\/volumetric rendering\n\tfloat s=.4,fade=.2;\n\t\n    \n    for (int r=0; r<volsteps; r++) \n    {\n        vec3 q = vec3(0.3, 0.5, -3.0)+s*dir;\n        \n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); \/\/ tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) \n        { \n\t\t\tp=abs(p)\/dot(p,p)-formuparam; \/\/ the magic formula\n\t\t\ta+=abs(length(p)-pa); \/\/ absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n        \n\t\tfloat dm=max(0.,darkmatter-a*a*.001); \/\/dark matter\n\t\ta*=a*a*2.; \/\/ add contrast\n\t\tif (r>3) fade*=1.-dm; \/\/ dark matter, don't render near\n\t\t\/\/v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; \/\/ coloring based on distance\n\t\tfade*=distfading; \/\/ distance fading\n\t\ts+=stepsize;\n\n\t}\n\tv=mix(vec3(length(v)),v,saturation); \/\/color adjust\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) \/ iResolution.y;\n    \n    vec3 lightDir = normalize(vec3(0.0, 0.4, -0.3));\n    \/\/float v = mouse.y;\n\tvec3 rayOrigin = vec3(0.0, 0.01, 0.7);\n    mat3 rm = rotationMatrix(vec3(0.0, 0.8, -0.15), -2.1);\n    vec3 rayDir = rm*setupRayDirection(radians(60.0));\n    \n\n    float travel = 0.0;\n    \n    vec3 sp = vec3(0.0);\n    float coneR;\n    vec3 col = space(p)*0.01;\n    float fog = 0.0;\n    \n    for (int i=0; i<256; i++)\n    {\n        \n        coneR = travel * tan(0.5*radians(60.0)\/iResolution.y);\n        float sd = sdf(rayOrigin+rayDir*travel);\n        \n        if (sd < coneR)\n        {\n            \n            col = shade(rayOrigin, rayDir, travel, coneR, lightDir);\n            col = mix(col, vec3(0.4, 0.4, 0.5), smoothstep(3.0, 4.0, travel));\n            break;\n        }\n        \n        fog += fogmap(rayOrigin+rayDir*travel, travel);\n        if (travel > 4.0 )\n        {\n            col = mix(col, vec3(0.4, 0.4, 0.5), smoothstep(1.0, 0.0, p.y));\n            break;\n        }\n        \n        travel += min(sd + travel * .001, 8.0);\n        \n        \n    }\n    \n    fog = min(fog, 1.0);\n    \n    \n    \n    col = mix(col, vec3(0.97, .95, .9), fog);\n    col = pow(col, vec3(1.2));\n    \n    vec2 q = fragCoord.xy\/iResolution.xy;\n    col *= pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n    \n    fragColor = vec4(col, 1.0);\n    \n    \n    \n}\n\n","name":"","description":"","type":"image"}]}}