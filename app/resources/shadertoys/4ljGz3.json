{"Shader":{"ver":"0.1","info":{"id":"4ljGz3","date":"1431502392","viewed":866,"name":"Volumetric Club","username":"Shadiest","description":"Volumetric approach has been \"inspired\" by GPU Pro 5 : http:\/\/bit.ly\/1EvLhhS<br\/>I would like to thank Iq, TekF and Gouky for their inspirations ! And coyote for fix ! *NOT* clean code :-)<br\/>N.B.: In pratice, the random ray march pattern should be blurred<br\/>","likes":8,"published":3,"flags":0,"tags":["ray","sphere","marching","volumetric","cylinder","3dvolumetric"],"hasliked":0},"renderpass":[{"inputs":[{"id":20,"src":"\/presets\/mzk03.mp3","ctype":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/Credits:\n\/\/[0] @iq for the fast cylinder intersection : https:\/\/www.shadertoy.com\/view\/4dSGW1\n\/\/[1] @TekF for the simple camera transform : https:\/\/www.shadertoy.com\/view\/XdsGDB\n\/\/[2] @gouky for the general idea, regular rotation & sound based effect : https:\/\/www.shadertoy.com\/view\/Xl2GDm\n\/\/[3] @coyote for initializer fix !\n\n#define USE_UNCHARTED_TONE_MAP 1\n\n\/\/< General Constant\nconst float pi = 3.14159265359;\nconst float epsilon = .00001;\nconst float infinite = 1.\/epsilon;\n\n\/\/< Camera\nvec2 camRot; \/\/time dependent\n\n\/\/< Main Sphere Settings\nconst vec3 sphereCenter = vec3(0,1.,0);\nconst float sphereRadius = 1.0;\nconst vec2 sphereSubDiv = vec2(24,12);\nconst float borderSize = .15;\nconst vec3 roomSize = vec3(7,3.5,7);\n\n\/\/< Cylinder Settings\nconst int cylinderCount = 8;\nconst float cylinderRadius = 0.1;\nconst float cylinderSceneRadius = 1.5;\nconst vec2 cylinderRange = vec2(-1.5,0.5);\nvec4 cylinderData[cylinderCount];\n\n\/\/< Light Settings\nconst vec2 lightPowerRange = vec2(1., 20.);\nconst vec2 lightPatternPowerRange = vec2(18., 18.); \/\/optional\nfloat lightPatternPower;\nfloat lightRadiusInvSqr = 1.\/pow(roomSize.z*2., 2.);\nfloat lightPower;\nvec3 lightPos;\nmat3 lightRotate;\n\n\/\/< Color scheme\nconst float gamma = 2.2;\nconst float exposure = 1.2;\nvec3 colorA = pow(vec3(0.,255., 41.)\/255., vec3(gamma));\nvec3 colorB = pow(vec3(102.,25., 255.)\/255., vec3(gamma));\nvec3 colorC = pow(vec3(178.,98., 9.)\/255., vec3(gamma));\nvec3 colorWhite = vec3(0.7,0.7,0.7);\n\n\/\/< Volumetric settings\nconst int volSliceCount = 16;\nconst float volDepthRange = roomSize.z * 2.;\nconst float volAnisotropyFactor = 0.6;\nconst float volDepthCurvePower = 0.5;\n\nfloat s(float x)\n{\n    float r = 1. - x*x;\n    return r*r*r;\n}\n\nfloat s3(float x)\n{\n    \/\/return s(s(s(x))); approximated with :\n    return s(clamp(x*2.87-0.83, 0., 1.));\n}\n\nvoid UpdateConstant()\n{\n   \t\/\/Cylinder\n    float soundAvg = 0.;\n    for (int c = 0; c < cylinderCount; ++c)\n    {\n        float t = float(c) \/ float(cylinderCount);\n        float teta = float(c)*2.*pi\/float(cylinderCount);\n        cylinderData[c].xyz = vec3(sin(teta), 0., cos(teta))*cylinderSceneRadius;\n        cylinderData[c].w = texture2D(iChannel1, vec2(t + 0.01, 0.25)).x;\n        \n        soundAvg += cylinderData[c].w;\n        \n        cylinderData[c].w = mix(cylinderRange.x, cylinderRange.y, cylinderData[c].w);\n    }\n    \n    soundAvg \/= float(cylinderCount);\n    \n    \/\/Light    \n    float t = abs(fract(iGlobalTime*.1) - 0.5)*2.;\n    lightPos.xyz = vec3(0., mix(-1., 1., s3(t)), 0.);\n    \n    lightRotate = mat3( cos(iGlobalTime), 0., sin(iGlobalTime),\n                         0., 1., 0.,\n                        -sin(iGlobalTime), 0., cos(iGlobalTime));\n    \n    lightPower = mix(lightPowerRange.x, lightPowerRange.y, soundAvg);\n    lightPatternPower = mix(lightPatternPowerRange.x, lightPatternPowerRange.y, soundAvg);\n    \n    \/\/Camera\n    camRot = vec2(.5,.5)+vec2(-.30,4.5)*(iMouse.yx\/iResolution.yx);\n    camRot.y += iGlobalTime*0.25;\n    \n}\n\n\n    \n\/\/< Volumetric Light Effect in Killzone Shadow Fall\nfloat GetScatteringFactor(vec3 Vn, vec3 Ln)\n{\n    \/\/Henyey and Greenstein Scattering function\n    float g = volAnisotropyFactor;\n    float cosTheta = dot(Vn, Ln);\n    float r = pow((1.-g),2.)\/(4.*pi*pow(1. + g*g* - 2.*g*cosTheta, 3.\/2.));\n    return r;\n}    \n\nfloat GetLookupDepth(in float inViewSpaceDepthNormalized)\n{\n    return pow(inViewSpaceDepthNormalized, volDepthCurvePower);\n}\n\nfloat GetIntensityFactor(in float t)\n{\n    return clamp(1.0 - t, 0., 1.);\n}\n\n\/\/< Ray Tracing\nstruct Ray\n{\n    vec3 org;\n    vec3 dir;\n};\n    \nstruct RayTraceResult\n{\n    vec3 pos; float t;\n    vec3 nn;\n};\n    \nstruct RayTraceSceneResult\n{    \n    RayTraceResult hit;\n    vec3 color;\n    vec3 emissive;\n};\n    \nRay ComputeRay(in vec3 origin, in vec2 rotation, in float distance, in float zoom, in vec2 fragCoord )\n{\n    \/\/< Credits [1]@TekF\n    Ray res;\n    \n\tvec2 c = vec2(cos(rotation.x),cos(rotation.y));\n\tvec4 s;\n\ts.xy = vec2(sin(rotation.x),sin(rotation.y));\n\ts.zw = -s.xy;\n\n    \/\/ from view space\n\tres.dir.xy = fragCoord.xy - iResolution.xy*.5;\n\tres.dir.z = iResolution.y*zoom;\n\tres.dir = normalize(res.dir);\n\tvec3 localRay = res.dir;\n\t\n\t\/\/ rotate ray\n\tres.dir.yz = res.dir.yz*c.xx + res.dir.zy*s.zx;\n\tres.dir.xz = res.dir.xz*c.yy + res.dir.zx*s.yw;\n\t\n\t\/\/ position camera\n\tres.org = origin - distance*vec3(c.x*s.y,s.z,c.x*c.y);\n    \n    return res;\n}\n\nRayTraceResult RayTraceCylinder(in Ray ray, vec3 pos, float radius, float height)\n{\n    RayTraceResult res;\n    res.t = infinite; res.pos = vec3(0.); res.nn = vec3(1.,1.,1.);\n    \n    \/\/< Credits : [0]iq\n    \/\/ intersect capped cylinder\t\t\n    vec3  ce = vec3( pos.x, 0.0, pos.z );\n    vec3  rc = ray.org - ce;\n    float a = dot( ray.dir.xz, ray.dir.xz );\n    float b = dot( rc.xz, ray.dir.xz );\n    float c = dot( rc.xz, rc.xz ) - radius;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        \/\/ cylinder\t\t\t\n        float t = (-b - sqrt( h ))\/a;\n        if( t>0.0 && (ray.org.y+t*ray.dir.y)<height )\n        {\n            res.t = t;\n            res.pos = ray.org + ray.dir*t;\n            res.nn = normalize(vec3(ce.x - res.pos.x, 0., ce.z - res.pos.z));\n        }\n        \/\/ cap\t\t\t\n        t = (height - ray.org.y)\/ray.dir.y;\n        if( t>0.0 && (t*t*a+2.0*t*b+c)<0.0 )\n        {\n            res.t = t;\n            res.pos = ray.org + ray.dir*t;\n            res.nn = vec3(0., 1., 0.);\n        }\n    }\n    \n    return res;\n}\n\nRayTraceResult RayTracePlane(in Ray ray, vec3 pos, vec3 nn)\n{\n    RayTraceResult res;\n    res.t = infinite; res.pos = vec3(0.); res.nn = vec3(1.,1.,1.);\n    \n\tfloat m = dot(nn, ray.dir);\n    if (abs(m) < epsilon)\n    {\n        return res;\n    }\n    \n    vec3 L = ray.org - pos;\n    float d = dot(nn, L);\n    float t = -d\/m;\n    if (t > epsilon)\n    {\n        res.nn = nn;\n        res.pos = ray.org + t*ray.dir;\n        res.t = t;\n    }\n    \n    return res;\n}\n\nRayTraceResult RayTraceRoom(in Ray ray)\n{\n    RayTraceResult res;\n    res.t = infinite; res.pos = vec3(0.); res.nn = vec3(1.,1.,1.);\n    \n    vec3 dir[6];\n    dir[0] = vec3(+1.,0.,0.);\n    dir[1] = vec3(-1.,0.,0.);\n    dir[2] = vec3(0.,+1.,0.);\n    dir[3] = vec3(0.,-1.,0.);\n    dir[4] = vec3(0.,0.,-1.);\n    dir[5] = vec3(0.,0.,+1.);\n    \n    float fMaxSqrDist = infinite;\n    \n    for (int i=0; i<6; ++i)\n    {\n        vec3 pos = roomSize*dir[i];\n        vec3 nn = dir[i];\n        \n        RayTraceResult current = RayTracePlane(ray, pos, nn);\n        if (current.t < fMaxSqrDist)\n        {\n            fMaxSqrDist = current.t;\n            res = current;\n        }\n    }\n    \n    return res;\n}\n\nRayTraceResult RayTraceSphere(in Ray ray, in vec3 c, in float r)\n{\n    RayTraceResult res;\n    res.t = infinite; res.pos = vec3(0.); res.nn = vec3(1.,1.,1.);\n    \n    vec3 L = c - ray.org;\n    float d = dot(L, ray.dir);\n    float l2 = dot(L, L);\n    float d2 = d*d;\n    float r2 = r*r;\n    \n    if (d < .0 && l2 > r2)\n    {\n        \/\/no intersect\n        return res;\n    }\n    \n    float m2 = l2 - d2;\n    if (m2 > r2)\n    {\n        \/\/ no intersect\n     \treturn res;   \n    }\n    \n    float q = sqrt(r2 - m2);\n    float t = l2 > r2 ? d - q : d + q;\n    \n    res.pos = t*ray.dir + ray.org;\n    res.t = t;\n    res.nn = normalize(res.pos - c);\n    \n    res.nn = l2 > r2 ? -res.nn : +res.nn;\n    \n    return res;\n}\n\nbool HolePattern(in vec3 p, in vec3 c)\n{\n    vec2 uv;\n    vec3 nn = normalize(p - c);\n    uv.x = .5 + atan(nn.x, nn.z)\/(2.*pi);\n    uv.y = .5 + asin(nn.y)\/pi;\n    \n    const float limit = 3.;\n    float cap = sphereSubDiv.y * uv.y;\n    \n   \tif (cap < limit || cap > sphereSubDiv.y - limit + borderSize)\n        return false;\n    \n    vec2 pattern = fract(sphereSubDiv*uv);\n    vec2 index = floor(sphereSubDiv*uv);\n    pattern -= vec2(.5,.5);\n    float border = min(abs(pattern.x+.5-borderSize), \n                       abs(pattern.y+.5-borderSize));\n    \n    bool r1 = border < borderSize;\n    bool r2 = length(pattern.xy - borderSize) < borderSize*1.5;\n\n\n    if (mod(index.x + index.y, 2.) > epsilon)\n    {\n        return r1 || r2;\n    }\n    else\n    {\n    \treturn r1;\n    }\n}\n\nRayTraceResult RayTraceHoledSphere(in Ray ray)\n{\n    RayTraceResult res = RayTraceSphere(ray, sphereCenter, sphereRadius);\n    if (!HolePattern(res.pos, sphereCenter))\n    {\n        res.t = infinite; res.pos = vec3(0.); res.nn = vec3(1.,1.,1.);\n    }\n    \n    return res;\n}\n\nRayTraceResult RayTraceHoledSphereDoubleSize(in Ray ray)\n{\n    RayTraceResult toSphere = RayTraceSphere(ray, sphereCenter, sphereRadius);\n    RayTraceResult toSphereHole = RayTraceHoledSphere(ray);\n    if (toSphereHole.t == infinite && toSphere.t < infinite)\n    {\n        vec3 bckOrg = ray.org;\n        ray.org = toSphere.pos + ray.dir*epsilon;\n        toSphereHole = RayTraceHoledSphere(ray);\n        toSphereHole.t += length(bckOrg - ray.org);\n    }\n    return toSphereHole;\n}\n\nvec3 ComputeLightPattern(vec3 Ln)\n{\n    Ln =  lightRotate*Ln,\n        \n    Ln = abs(Ln);\n    float a = max(Ln.x, max(Ln.y, Ln.z));\n    vec3 c = a == Ln.x ? colorC : a == Ln.y ? colorA : colorB;\n    return c * pow(a, lightPatternPower);\n}\n\n\/\/ http:\/\/www.frostbite.com\/wp-content\/uploads\/2014\/11\/course_notes_moving_frostbite_to_pbr.pdf\nfloat smoothDistanceAtt ( float squaredDistance , float invSqrAttRadius )\n{\n\tfloat factor = squaredDistance * invSqrAttRadius ;\n\tfloat smoothFactor = clamp (1. - factor * factor, 0., 1.);\n\treturn smoothFactor * smoothFactor ;\n}\n\nfloat getDistanceAtt ( vec3 unormalizedLightVector , float invSqrAttRadius )\n{\n\tfloat sqrDist = dot ( unormalizedLightVector , unormalizedLightVector );\n\tfloat attenuation = 1.0 \/ (max ( sqrDist , epsilon*epsilon) );\n\tattenuation *= smoothDistanceAtt ( sqrDist , invSqrAttRadius );\n\treturn attenuation ;\n}\n\n\nvec3 ComputeLightAttenuation(in vec3 pos)\n{\n    vec3 L = lightPos - pos;\n    vec3 Ln = normalize(L);\n    \n    float att = getDistanceAtt(L,lightRadiusInvSqr);   \n    return att * lightPower * ComputeLightPattern(Ln);\n}\n\nRayTraceSceneResult RayTraceScene(in Ray ray, bool bIgnoreDummyLight)\n{\n    const int nbObj = 3 + cylinderCount;\n    RayTraceResult obj[nbObj];\n    \n    obj[0] = RayTraceHoledSphereDoubleSize(ray);\n    obj[1] = RayTraceRoom(ray);\n    obj[2] = RayTraceSphere(ray, lightPos, .3);\n    \n    if (bIgnoreDummyLight)\n    {\n        obj[2].t = infinite;\n    }\n    \n    for (int c = 0; c < cylinderCount; ++c)\n    {\n    \tobj[c+3] =  RayTraceCylinder(ray, cylinderData[c].xyz, cylinderRadius, cylinderData[c].w);\n    }\n    \n    float minT = infinite;\n   \tRayTraceSceneResult res; res.emissive = vec3(0.); res.color = vec3(0.);\n    int hitI = 0;\n    for (int i = 0; i < nbObj; ++i)\n    {\n        if (minT > obj[i].t)\n        {\n           \tres.hit = obj[i];\n            minT = obj[i].t;\n            hitI = 0;\n        }\n    }\n    \n    if (hitI == 2) \/\/Dummy light\n    {\n        res.emissive = (ComputeLightPattern(normalize(lightPos - obj[2].pos)) + 0.2);\n        res.emissive *= 64.0;\n    }\n    else\n    {\n        res.color = colorWhite;\n    }\n    \n    return res;\n}\n\nvec3 GetLightIntensity(in vec3 pos)\n{\n    Ray ray;\n    ray.org = pos;\n    ray.dir = normalize(lightPos - ray.org);\n    ray.org += ray.dir*epsilon;\n    \n    RayTraceSceneResult scene = RayTraceScene(ray, true);\n    return scene.hit.t > length(lightPos - ray.org) ? ComputeLightAttenuation(ray.org) : vec3(0.);\n}\n\nvec3 GetLightDirection(vec3 pos)\n{\n    return normalize(pos - lightPos);\n}\n\nfloat GetRand(in vec4 rand, in int index)\n{\n    int r = int(mod(float(index), 4.));\n    return r == 0 ? rand[0] : r == 1 ? rand[1] : r == 2 ? rand[2] : rand[3];\n}\n\nvec4 ProcessScene(in vec2 fragCoord, in vec4 rand)\n{\n\tRay ray = ComputeRay(vec3(0), camRot, 6.0, 1.0, fragCoord);\n    \n    RayTraceSceneResult scene = RayTraceScene(ray, false);\n    \n    vec3 volumetric = vec3(0.);\n    int iRand = 0;\n    for (int s = 0; s < volSliceCount; ++s)\n    {\n        float t = float(s)\/float(volSliceCount);\n        float ct = GetLookupDepth(t) + GetRand(rand, s) * .01;\n        float at = volDepthRange * ct;\n        if (at > scene.hit.t)\n        {\n            break;\n        }\n        vec3 cPos = ray.org + at*ray.dir;\n        float lightScattering = GetScatteringFactor(ray.dir, GetLightDirection(cPos));\n        float decreaseFactor = GetIntensityFactor(ct);\n        volumetric += decreaseFactor * lightScattering * GetLightIntensity(cPos);\n    }\n    \n    vec3 lightIntensity = GetLightIntensity(scene.hit.pos);\n    float nl = clamp(dot(scene.hit.nn, GetLightDirection(scene.hit.pos)),.0,1.);\n    return vec4(scene.color*lightIntensity*nl + scene.emissive + volumetric,1.0);\n}\n\n\/\/http:\/\/filmicgames.com\/archives\/75\nconst float W = 5.0; \/\/default 11.2\nvec3 Uncharted2Tonemap(vec3 x)\n{\n\tfloat A = 0.15;\n\tfloat B = 0.50;\n\tfloat C = 0.10;\n\tfloat D = 0.20;\n\tfloat E = 0.02;\n\tfloat F = 0.30;\n\t\n    return ((x*(A*x+C*B)+D*E)\/(x*(A*x+B)+D*F))-E\/F;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    UpdateConstant();\n    \n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    uv *= iResolution.xy \/ 256.;\n    uv.x += fract(iGlobalTime * 300.);\n    uv.y += fract(iGlobalTime * 900.);\n    \n   \tvec4 rand = texture2D(iChannel0, uv);\n    rand = rand * 2. - 1.;\n    \n    fragColor = ProcessScene(fragCoord, rand);\n    \n    #if USE_UNCHARTED_TONE_MAP == 0\n    \t\/\/Simple Reinhard tone mapping\n        fragColor *= exposure\/(1. + fragColor \/ exposure);\n    #else\n        \/\/Filmic Tone Mapping\n        fragColor *= 16.0; \/\/ Hardcoded Exposure Adjustment\n        vec3 curr = Uncharted2Tonemap(exposure*fragColor.xyz);\n        vec3 whiteScale = 1.0\/Uncharted2Tonemap(vec3(W));\n        fragColor.xyz = curr*whiteScale;\n    #endif\n    fragColor.xyz = pow(fragColor.xyz, vec3(1.\/gamma));\n}","name":"","description":"","type":"image"}]}}