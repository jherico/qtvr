{"Shader":{"ver":"0.1","info":{"id":"XdcGzH","date":"1447944075","viewed":386,"name":"Koch Curve","username":"knighty","description":"Koch curves using foldings.","likes":17,"published":3,"flags":0,"tags":["kifs","kochcurve"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/Public domain\n#define PI 3.14159\n#define A2B PI\/360.\n#define MaxIter 14\n\/\/Constants\nconst float DRadius=0.7, Width=1.4, Gamma=2.2;\nconst vec3 BackgroundColor = vec3(1.);\nconst vec3 CurveColor = vec3(0.);\n\n\/\/Global variables\nfloat lambda,ca,sa,lscl;\nfloat aaScale;\nfloat Angle=60.;\nvec2 csa;\n\nvoid init() {\n    Angle = 90.*0.5*(1.+sin(iGlobalTime+0.1*PI));\n\tfloat ang=A2B*Angle;\n\tca=cos(ang),sa=sin(ang);\n\tcsa=vec2(ca,-sa);\n\tlambda=0.5\/(ca*ca);\n\tlscl=2.\/lambda;\n}\n\nfloat d2hline(vec2 p){\n   float t=max(-1.,min(1.,p.x));\n   p.x-=t;\n   return length(p);\n}\nfloat DE(vec2 p) {\n\tfloat d=1., r=dot(p,p);\n\tfor(int i=0; i<MaxIter; i++) {\n\t\tp.x=abs(p.x);\n\t\tp.x-=1.-lambda;\n\t\tfloat t=2.*min(0.,dot(p,csa));\n\t\tp-=csa*t;\n\t\tp.x-=lambda;\n\t\tp*=lscl; d*=lscl;\n\t\tp.x+=1.;\n\t\t r=dot(p,p);\n\t}\n\treturn d2hline(p)\/d;\/\/length(p)-1.;\n}\n\nfloat coverageFunction(float t){\n\t\/\/this function returns the area of the part of the unit disc that is at the rigth of the verical line x=t.\n\t\/\/the exact coverage function is:\n\t\/\/t=clamp(t,-1.,1.); return (acos(t)-t*sqrt(1.-t*t))\/PI;\n\t\/\/this is a good approximation\n\treturn 1.-smoothstep(-1.,1.,t);\n\t\/\/a better approximation:\n\t\/\/t=clamp(t,-1.,1.); return (t*t*t*t-5.)*t*1.\/8.+0.5;\/\/but there is no visual difference\n}\n\nfloat coverageLine(float d, float lineWidth, float pixsize){\n\td=d*1.\/pixsize;\n\tfloat v1=(d-0.5*lineWidth)\/DRadius;\n\tfloat v2=(d+0.5*lineWidth)\/DRadius;\n\treturn coverageFunction(v1)-coverageFunction(v2);\n}\n\nvec3 color(vec2 pos) {\/\/getColor2D(vec2 pos) {\n\tfloat pixsize=dFdx(pos.x);\n\tfloat v=coverageLine(abs(DE(pos)), Width, pixsize);\n\treturn pow(mix(pow(BackgroundColor,vec3(Gamma)),pow(CurveColor,vec3(Gamma)),v),vec3(1.\/Gamma));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst float scaleFactor=1.4;\n\tvec2 uv = scaleFactor*(fragCoord.xy-0.5*iResolution.xy) \/ iResolution.y;\n    uv.y+=0.5;\n\tinit(); \n\tfragColor = vec4(color(uv),1.0);\n}","name":"","description":"","type":"image"}]}}