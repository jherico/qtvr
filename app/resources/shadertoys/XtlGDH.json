{"Shader":{"ver":"0.1","info":{"id":"XtlGDH","date":"1421712080","viewed":974,"name":"kalizyl","username":"bergi","description":"If you suffer headache or stomach pain, try Kalizyl!","likes":20,"published":3,"flags":0,"tags":["raymarching","kaliset","lights","ornamental"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/*\tkalizyl \n\t\n\t(c) 2015, stefan berke (aGPL3)\n\n\tAnother attempt on the kali set\n\thttp:\/\/www.fractalforums.com\/new-theories-and-research\/very-simple-formula-for-fractal-patterns\/\n\n\tLooks cool and frametime is not too bad -\n\tbut still uses precission 0.1 for raymarching. (but see EIFFIE_MOD)\n\tMaybe saves some speed by not coloring the surface.\n\t\n*\/\n\n\/\/ plot a 2d slice of the distance function\n#define PLOT_2D\t\t\t0\n\/\/ enable eiffie's modification (https:\/\/www.shadertoy.com\/view\/XtlGRj)\n#define EIFFIE_MOD\t\t0\n\n\n#define KALI_PARAM \t\tvec3(0.71)\n#define LIGHT_COL \t\tvec3(1.0, 0.8, 0.4)\n\n#if EIFFIE_MOD == 0\n    #define FOG_DIST \t\t5.\n    #define FOG_COL \t\tvec3(0.5, 0.7, 1.0)\n    #define CYL_RADIUS \t\t0.07\n    #define NUM_TRACE \t\t80\n    #define MARCH_PRECISION\t0.1\n#else\n    #define FOG_DIST \t\t2.\n    #define FOG_COL \t\t(vec3(0.5, 0.7, 1.0)\/3.)\n    #define CYL_RADIUS \t\t0.009\n    #define NUM_TRACE \t\t40\n    #define MARCH_PRECISION\t0.9\n#endif\n\n#if EIFFIE_MOD == 0\n\/\/ standard kali set \n\/\/ modified to return distance to cylinders and spheres in 'kali-space'\nvec2 scene_dist(in vec3 p)\n{\n\tvec2 d = vec2(100.);\n\tfor (int i=0; i<4; ++i)\n\t{\n\t\tp = abs(p) \/ dot(p, p) - KALI_PARAM;\n        \/\/ distance to cylinder\n\t\td.x = min(d.x, length(p.xz));\t\n        if (i < 3)\n        {\n            vec3 lightpos = vec3(0., 1.+sin(iGlobalTime+p.y+float(i)*1.3), 0.);\n            \/\/ distance to sphere\n        \td.y = min(d.y, length(p - lightpos));\t\n        }\n\t}\n\treturn d - CYL_RADIUS;\n}\n\n#else\n\n\/\/ eiffie's mod\nvec2 scene_dist(in vec3 pos)\n{\n    \/\/ p.w will track how much we have stretched space\n    vec4 p = vec4(pos, 1.);\n\tvec2 d = vec2(100.);\n\tfor (int i=0; i<4; ++i)\n\t{\n\t\tp = abs(p) \/ dot(p.xyz, p.xyz) - vec4(KALI_PARAM, 0.);\n\t\td.x = min(d.x, length(p.xz)\/p.w); \/\/now we are calcing unstretched distance\n        if (i < 3)\n        {\n            vec3 lightpos = vec3(0., 1.+sin(iGlobalTime+p.y+float(i)*1.3), 0.);\n            d.y = min(d.y, length(p.xyz - lightpos)\/p.w);\n        }\n\t}\n\treturn d - CYL_RADIUS;\n}\n\n#endif\n\nvec3 traceRay(in vec3 pos, in vec3 dir)\n{\n\tvec3 p = pos;\n\n\tfloat t = 0., mlightd = 100.;\n    \n    vec2 d = scene_dist(pos);\n\n\tfor (int i=0; i<NUM_TRACE; ++i)\n\t{\t\n\t\tif (d.x < 0.001 || t >= FOG_DIST) \n\t\t\tcontinue;\n\n\t\tp = pos + t * dir;\n\t\tvec2 d = scene_dist(p);\n\n        \/\/ collect minimum distance to light\n\t\tmlightd = min(mlightd, d.y);\n\n\t\tt += d.x * MARCH_PRECISION;\t\t\n\t}\n\n    \/\/ only fog contribution\n\tvec3 col = FOG_COL * min(1., t\/FOG_DIST);\n\n    \/\/ plus light glow\n    col += LIGHT_COL \/ (1. + 50.*max(0., mlightd));\n\n\treturn col;\n}\n\nvec3 plot2d(in vec3 pos)\n{\n\tvec2 d = scene_dist(pos);\n    \/\/ inside?\n    float ins = smoothstep(0.01,-0.01, d.x);\n    vec3 col = vec3(d.x, ins, 0.);\n    \n    return col;\n}\n\n\/\/ camera path\nvec3 path(float ti)\n{\n\tfloat a = ti * 3.14159265 * 2.;\n\n\treturn vec3(\n\t\t\t\t1.1 * sin(a),\n\t\t\t\t0.52 * sin(a*2.),\n\t\t\t\t1.1 * cos(a) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy * 2. - 1.;\n\tuv.x *= iResolution.x \/ iResolution.y;\n\t\n    vec3 pos, dir;\n    mat3 dirm = mat3(vec3(1.,0.,0.), vec3(0.,1.,0.), vec3(0.,0.,1.));\n    \n    if (iMouse.z < 0.5)\n    {\n        \/\/ camera time\n        float ti = iGlobalTime \/ 19.;\n\n        pos = path(ti);\n\n        \/\/ camera orientation matrix\n        vec3 look;\n\n        \/\/ how much to look towards the center [0,1]\n        float lookcenter = 0.45 + 0.45 * sin(ti*7.);\n    \tlook = normalize(path(ti + 0.1) - pos);\n\t\tlook = look + lookcenter * (normalize(-pos) - look);\n        vec3 up = normalize(cross(vec3(0., 1., 0.), look));\n        vec3 right = normalize(cross(look, up));\n        \/\/look = normalize(cross(up, right));\n        dirm = mat3(right, up, look);\n\n        dir = dirm * normalize(vec3(uv, 1.5));\n    }\n    else\n    {\n        vec2 m = iMouse.xy \/ iResolution.xy;\n        pos = vec3(m.x*2.-1., 0., 3. * m.y);\n        dir = normalize(vec3(uv, -1.));\n    }\n#if PLOT_2D == 0\n\tfragColor = vec4( traceRay(pos, dir), 1.);\t\n#else\n    fragColor = vec4( plot2d(pos + dirm * vec3(uv,0.)), 1.);\t\n#endif\n}\n","name":"","description":"","type":"image"}]}}