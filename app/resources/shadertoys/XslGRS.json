{"Shader":{"ver":"0.1","info":{"id":"XslGRS","date":"1373407359","viewed":1387,"name":"My First Raymarcher","username":"fb39ca4","description":"Test.","likes":6,"published":3,"flags":0,"tags":["3d","raymarching","shadow"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"float square(float x) {\n\treturn x * x;\n}\n\nfloat sdSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane(vec3 p, vec4 n) {\n\treturn dot(p, n.xyz) + n.w;\n}\n\nfloat join(float a, float b) { return min(a, b); }\nfloat carve(float a, float b) { return max(a, -b); }\nfloat intersection(float a, float b) { return max(a, b); }\n\nfloat distanceField(vec3 p) {\n\tfloat sphere = sdSphere(p - vec3(0.0, 0.0, 4.0), 2.0);\n\tfloat box = sdBox(p - vec3(0.0, 0.0, 4.0), vec3(3.5, 1.0, 1.0));\n\tfloat plane = sdPlane(p, vec4(0.0, 1.0, 0.0, 1.0));\n\treturn join(carve(box, sphere), plane);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 mousePos = (iMouse.xy \/ iResolution.xy) * 2.0 - 1.0;\n\tvec2 screenPos = (fragCoord.xy \/ iResolution.xy) * 2.0 - 1.0;\n\tvec3 cameraPos = vec3(0.0, 0.0, 0.0);\n\tvec3 cameraDir = vec3(0.0, 0.0, 1.0);\n\tvec3 planeU = vec3(1.5, 0.0, 0.0);\n\tvec3 planeV = vec3(0.0, iResolution.y \/ iResolution.x * 1.5, 0.0);\n\tvec3 rayDir = normalize(cameraDir + screenPos.x * planeU + screenPos.y * planeV);\n\tvec3 rayPos = cameraPos;\n\tfloat rayDist;\n\tfloat rayDistTotal = 0.0;\n\t\n\tfor (int i = 0; i < 64; i++) {\n\t\trayDist = distanceField(rayPos);\n\t\tif (rayDist < 0.01) break;\n\t\trayPos += rayDist * rayDir;\n\t}\n\t\n\tvec3 lightPos;\n\t\/\/lightPos.xyz = vec3(2.5 * mousePos, 2.0);\n\tlightPos = vec3(0.0, 1.0, sin(iGlobalTime) * 3.0 + 4.0);\n\tvec3 lightRayDir = normalize(lightPos - rayPos);\n\tvec3 lightRayPos = rayPos + 0.001 * lightRayDir;\n\t\n\tfloat lightDistTotal = length(lightPos - rayPos);\n\tfloat lightDistAccum = 0.001;\n\tfloat lightDist;\n\tfor (int i = 0; i < 128; i++) {\n\t\tlightDist = distanceField(lightRayPos);\n\t\tif (lightDistAccum > lightDistTotal) continue;\n\t\tif (lightDist < 0.001) {\n\t\t\tfragColor = vec4(0.0);\n\t\t\treturn;\n\t\t}\n\t\tlightRayPos += lightDist * 0.9 * lightRayDir;\n\t\tlightDistAccum += lightDist;\n\t}\n\t\n\tconst float derivDist = 0.0001;\n\tconst float derivDist2 = 2.0 * derivDist;\n\tvec3 surfaceNormal;\n\tsurfaceNormal.x = distanceField(vec3(rayPos.x + derivDist, rayPos.y, rayPos.z)) \n\t\t\t\t\t- distanceField(vec3(rayPos.x - derivDist, rayPos.y, rayPos.z));\n\tsurfaceNormal.y = distanceField(vec3(rayPos.x, rayPos.y + derivDist, rayPos.z)) \n\t\t\t\t\t- distanceField(vec3(rayPos.x, rayPos.y - derivDist, rayPos.z));\n\tsurfaceNormal.z = distanceField(vec3(rayPos.x, rayPos.y, rayPos.z + derivDist)) \n\t\t\t\t\t- distanceField(vec3(rayPos.x, rayPos.y, rayPos.z - derivDist));\n\tsurfaceNormal = normalize(surfaceNormal \/ derivDist2);\n\n\t\/\/fragColor = vec4(lightDistAccum \/ 8.0);\n\tfragColor = vec4(3.0 * vec3(dot(surfaceNormal, lightRayDir)) \/ square(lightDistTotal), 1.0);\n}","name":"","description":"","type":"image"}]}}