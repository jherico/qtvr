{"Shader":{"ver":"0.1","info":{"id":"ldf3Dr","date":"1367876922","viewed":1493,"name":"Stereogram","username":"P_Malin","description":"A shader to generate a random dot stereogram or \"magic eye\" picture.<br\/><br\/>","likes":28,"published":3,"flags":0,"tags":["stereogram"],"hasliked":0},"renderpass":[{"inputs":[{"id":7,"src":"\/presets\/tex06.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":15,"src":"\/presets\/tex10.png","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Stereogram - @P_Malin\n\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ A shader to generate a random dot stereogram or \"magic eye\" picture.\n\/\/ http:\/\/en.wikipedia.org\/wiki\/Autostereogram\n\n\/\/ The default is for \"wall eyed\" viewing. \n\/\/ Remove this define if (like me) you prefer \"cross eyed\" viewing.\n#define INVERT_DEPTH\n\n\/\/#define SHOW_DEPTH_IMAGE\n\n\/\/#define ADD_COLOUR\n\/\/#define ANIMATE\n\n\/\/ This is a simulation of what it looks like to see the effect\n\/\/ Enable this define and watch the routine\n\/\/ or you can  click the mouse in the bottom middle of the picture.\n\/\/ Then move the mouse to the left or right at the bottom of the screen \n\/\/ until the dots overlap giving three dots. This is like what you see when you cross\n\/\/ or diverge your eyes.\n\/\/ Then move the mouse up the image. This simulates the harder bit of refocusing\n\/\/ your eyes while keeping them converged in the right place.\n\/\/#define SIMULATION_MODE\n\n\/\/ Like simulation mode but without the defocus effect\n\/\/ Use the mouse to control the separation of two blended images\n\/\/#define OVERLAY_MODE\n\n#ifdef ADD_COLOUR\n\t#define DOUBLE_COLOUR\n#endif\n\n#ifdef ANIMATE\n\t\/\/#define RANDOM_BACKDROP_OFFSET\n\t#define RANDOM_BACKDROP_OFFSET_PER_LINE\n\t#define USE_NOISE_IMAGE\n#endif\n\n#define DRAW_DOTS\n\n#ifndef SIMULATION_MODE\n\t#define INTEGER_OFFSET\n#endif\n\nfloat fPixelRepeat = 96.0;\nfloat fDepthScale = 8.0;\n\n\n\/\/ colour settings\nconst float fFuzziness = 0.25; \/\/ Colour blurry falloff (must be > 0.0)\nconst float fNoiseDesaturation = 0.5;\nconst float fColourDesaturation = 0.75;\n\nfloat GetTime()\n{\n#ifdef ANIMATE\n\treturn iGlobalTime;\n#else\n\treturn 0.0;\n#endif\n}\n\nvec2 Random2(float f)\n{\n\treturn fract( sin( vec2(123.456, 78.9012) * f ) * vec2(3456.7890, 123.4567) );\n}\n\n\/\/ w is depth, rgb is colour\nvec4 GetDepth( vec2 vPixel, vec4 vPrev )\n{\n\tvec4 vResult = vPrev;\n\t\n\tvec2 vUV = (vPixel \/ iResolution.xy) * 2.0 - 1.0;\n\tvUV.x *= iResolution.x \/ iResolution.y;\n\t\n\tfloat fGroundHeight = 0.75;\n\tfloat fHeadHeight = -0.25;\n\tfloat fXOffset = 0.2;\n\t\n\t\/\/ The image...\n\tfloat fDepth = 0.0; \/\/ 0 = far, 1 = near\n\t\n\tfloat fWave = sin(GetTime());\n\tfWave = -fWave * fWave * 0.3;\n\t\n\tfloat a = -0.5;\n\tfloat b = 0.5 + fWave;\n\tfloat c = 0.0;\t\n\t\n\t\/\/ stem\n\t{\n\t\tvec2 vCurvePos = vUV + vec2(-fXOffset, fGroundHeight);\n\t\t\n\t\tfloat fStemThickness = 0.05;\n\t\t\n\t\tfloat x = vCurvePos.x;\n\t\tfloat y = vCurvePos.y;\n\t\t\t\t\n\t\tfloat f = y * y * a + y * b + c;\n\t\tf = abs(f - x);\n\t\tvec2 df = vec2(2.0 * a * y + b, 1.0);\n\t\tf = f \/ length(df);\n\t\tf = f - fStemThickness;\n\t\tif( y < 1.0)\n\t\t{\n\t\t\tif(f < 0.0)\n\t\t\t{\n\t\t\t\tfloat d = 1.0 - (f \/ -fStemThickness);\n\t\t\t\tfDepth = 0.25 + 0.25 * sqrt(1.0 - d * d);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tvResult.rgb = mix(vResult.rgb, vec3(0.0, 1.0, 0.0), smoothstep(fFuzziness, -fFuzziness, f));\n\t\t}\n\t}\t\t\n\n\t{\n\t\tfloat y = fGroundHeight - fHeadHeight;\n\t\tfloat fHeadX = y * y * a + y * b + c;\n\t\t\n\t\tvec2 vHeadPos = vUV + vec2(-fXOffset-fHeadX, fHeadHeight);\n\t\tfloat fAngle = atan(vHeadPos.x, vHeadPos.y) - fWave * 1.5;\n\t\tfloat fLength = length(vHeadPos);\n\t\t\n\t\tfloat fPetalSin = sin(0.7 + fAngle * 5.0);\n\n\t\tfloat fPetalDist = fLength - 0.1 + fPetalSin * 0.2 - 0.2;\t\t\t\n\t\tfloat fPetalShadeFraction = (fPetalSin) * 0.5 + 0.5;\n\t\t\n\t\t\/\/ petals\t\t\n\t\tif( fPetalDist < 0.0 )\n\t\t{\n\t\t\tfDepth = 0.5 + fPetalShadeFraction * 0.3;\n\t\t}\n\n\t\tvResult.rgb = mix(vResult.rgb, vec3(1.0, 1.0, 1.0), smoothstep(fFuzziness, -fFuzziness, fPetalDist));\n\t\t\n\t\t\n\t\t\/\/ head\n\t\tfloat fHeadDistance = fLength - 0.1;\n\t\tif( fHeadDistance < 0.0)\n\t\t{\n\t\t\tfloat f = fLength \/ 0.1;\n\t\t\tfDepth = 0.75 + sqrt(1.0 - f * f) * 0.25;\n\t\t}\n\t\t\n\t\tvResult.rgb = mix(vResult.rgb, vec3(1.0, 1.0, 0.0), smoothstep(fFuzziness, -fFuzziness, fHeadDistance));\t\t\n\t}\t\t\n\n\t\/\/ leaves\n\t{\n\t\tvec2 vLeafPos = vUV + vec2(-fXOffset, +0.8);\n\t\t\n\t\tvLeafPos *= 2.0;\n\t\tvLeafPos.x = abs(vLeafPos.x - (vUV.y + fGroundHeight) * fWave * 2.0);\n\n\t\tfloat fLeafDist1 = (vLeafPos.x * vLeafPos.x - vLeafPos.y) \/ length(vec2(vLeafPos.x, 1.0));\n\t\tfloat fLeafDist2 = (vLeafPos.y * vLeafPos.y - vLeafPos.x) \/ length(vec2(vLeafPos.y, 1.0));\n\t\t\n\t\tfloat fLeafDist = max(fLeafDist1, fLeafDist2);\n\t\t\n\t\tif(fLeafDist < 0.0)\n\t\t{\n\t\t\tfloat f = clamp(abs(vLeafPos.x - vLeafPos.y), 0.0, 0.1);\n\t\t\tfDepth = 0.5 + vLeafPos.y * 0.5 + f;\n\t\t}\t\t\t\n\n\t\tvResult.rgb = mix(vResult.rgb, vec3(0.0, 1.0, 0.0), smoothstep(fFuzziness, -fFuzziness, fLeafDist));\n\t}\t\t\n\t\n\t\/\/ ground\n\tif(vUV.y < -fGroundHeight)\n\t{\n\t\tfDepth = 1.0;\t\n\t}\n\t\t\n\tvResult.rgb = mix(vResult.rgb, vec3(1.0, 0.5, 0.15), smoothstep(-fGroundHeight + fFuzziness, -fGroundHeight - fFuzziness, vUV.y));\n\t\t\n\tvResult.w = fDepth;\n\t\n\treturn vResult;\n}\n\nvec4 GetStereogramDepth(vec2 vPixel, vec4 vPrev)\n{\n\t\/\/ Adjust pixel co-ordinates to be in centre of strip\n\treturn GetDepth(vPixel - vec2(fPixelRepeat * 0.5, 0.0), vPrev);\n}\n\nvec3 Stereogram(vec2 vPixel)\n{\n\tvec2 vInitialPixel = vPixel;\n\t#ifdef INTEGER_OFFSET\n\tvInitialPixel = floor(vInitialPixel + 0.5);\n\t#endif\n\tvec2 vIntPixel = vInitialPixel;\n\t\n\t\/\/ This is an arbitrary number, enough to make sure we will reach the edge of the screen\n\tfor(int i=0; i<64; i++)\n\t{\n\t\t\/\/ Step left fPixelRepeat minus depth...\n\t\tvec4 vDepth = GetStereogramDepth(vIntPixel, vec4(0.0));\n\t\tfloat fOffset = -fPixelRepeat;\n\n\t\t#ifndef INVERT_DEPTH\n\t\tfOffset -= vDepth.w * fDepthScale;\n\t\t#else\n\t\tfOffset += vDepth.w * fDepthScale;\n\t\t#endif\t\t\n\t\t\n\t\tvIntPixel.x = vIntPixel.x + fOffset;\t\t\n\t\t#ifdef INTEGER_OFFSET\n\t\tvIntPixel.x = floor(vIntPixel.x + 0.5);\n\t\t#endif\n\t\t\n\t\t\/\/ ...until we fall of the screen\n\t\tif(vIntPixel.x < 0.0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tvIntPixel.x = mod(vIntPixel.x, fPixelRepeat);\n\t\n\tvec2 vUV = (vIntPixel + 0.5) \/ fPixelRepeat;\n\n\tvec3 vResult;\n\t\n\t#ifdef RANDOM_BACKDROP_OFFSET\t\n\t\tvUV += Random2(iGlobalTime);\n\t#endif \/\/ RANDOM_BACKDROP_OFFSET\n\t\n\t#ifdef RANDOM_BACKDROP_OFFSET_PER_LINE\n\t\tvUV += Random2(iGlobalTime + vUV.y * iResolution.y);\n\t#endif\n\t\n\tconst float fMipLod = -32.0;\n\t\n\t#ifdef USE_NOISE_IMAGE\n\t\tvResult = texture2D(iChannel1, fract(vec2(vUV)), fMipLod).rgb;\n\t#else\n\t\tvResult = texture2D(iChannel0, fract(vec2(vUV)), fMipLod).rgb;\t\n\t#endif \/\/ USE_NOISE_IMAGE\n\t\n\t#ifdef ADD_COLOUR\n\tvec4 vColour = vec4(0.0, 0.8, 1.0, 1.0);\t\n\tvColour = GetStereogramDepth(vInitialPixel, vColour);\n\t\n\t#ifdef DOUBLE_COLOUR\n\tvColour = GetStereogramDepth(vInitialPixel + vec2(fPixelRepeat, 0.0), vColour);\n\t#endif \/\/ DOUBLE_COLOUR\n\t\t\n\tvResult = mix(vResult, vec3(1.0), fNoiseDesaturation); \/\/ desaturate noise\n\tvColour.rgb = mix(vColour.rgb, vec3(1.0), fColourDesaturation); \/\/ desaturate colour\n\tvResult = vResult * vColour.rgb;\n\t#endif\n\t\n\treturn vResult;\n}\n\nvec3 ImageColour(vec2 vPixelCoord)\n{\n\tvec3 vColour = Stereogram(vPixelCoord);\n\n\t#ifdef DRAW_DOTS\n\tfloat fRadius = 12.0;\t\n\tfloat fOffset = 8.0;\n\t\n\t{\n\t\tvec2 vToCentre = vPixelCoord - vec2((iResolution.x \/ 2.0) + fPixelRepeat * 0.5, iResolution.y - fRadius - fOffset);\n\t\tfloat fLength = length(vToCentre);\n\t\tfloat fAngle = atan(vToCentre.x, vToCentre.y);\n\t\tvec3 vDotColour = vec3(0.1, 0.3, 0.5);\n\t\tfloat fSpiral = abs( 0.5 - fract(fLength * 0.2 + fAngle * 3.14159 * 2.0 * 0.05 - iGlobalTime));\n\t\tvDotColour = mix(vDotColour, vec3(1.0, 1.0, 1.0), fSpiral);\n\t\tvColour = mix(vColour, vDotColour, smoothstep(fRadius, fRadius - 2.0, length(vToCentre)));\n\t}\n\t{\n\t\tvec2 vToCentre = vPixelCoord - vec2((iResolution.x \/ 2.0) - fPixelRepeat * 0.5, iResolution.y - fRadius - fOffset);\n\t\tfloat fLength = length(vToCentre);\n\t\tfloat fAngle = atan(vToCentre.x, vToCentre.y);\n\t\tvec3 vDotColour = vec3(0.1, 0.3, 0.5);\n\t\tfloat fSpiral = abs( 0.5 - fract(fLength * 0.2 + fAngle * 3.14159 * 2.0 * 0.05 - iGlobalTime));\n\t\tvDotColour = mix(vDotColour, vec3(1.0, 1.0, 1.0), fSpiral);\n\t\tvColour = mix(vColour, vDotColour, smoothstep(fRadius, fRadius - 2.0, length(vToCentre)));\n\t}\n\t\n\t#endif\n\n\t#ifdef SHOW_DEPTH_IMAGE\n\tvec4 vImage = GetDepth(vPixelCoord, vec4(0.0));\n\tvColour = vec3(vImage.w);\n\t#endif\n\t\n\treturn vColour;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\t#ifdef SIMULATION_MODE\n\t\tfloat fTaps;\n\n\t\tfloat fOffset = 0.0;\n\t\tfloat fOffset2 = 0.0;\n\t\tfloat fFocus = 1.0;\n\t\n\t\n\t\tif(iMouse.z > 0.0)\n\t\t{\t\t\n\t\t\tvec2 vMouse = vec2(0.5, 1.0);\n\t\t\tvMouse = iMouse.xy \/ iResolution.xy;\n\t\t\tfOffset = ((vMouse.x - 0.5) * fPixelRepeat) * 1.75;\n\t\t\tfFocus = 1.0 - vMouse.y;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfloat fTime = mod(iGlobalTime, 25.0);\n\t\t\t\n\t\t\tif(fTime < 5.0)\n\t\t\t{\n\t\t\t}\n\t\t\telse\n\t\t\tif(fTime < 10.0)\n\t\t\t{\n\t\t\t\tfloat f = (fTime - 5.0) \/ 5.0;\n\t\t\t\tfOffset = f * fPixelRepeat * 0.5;\n\t\t\t}\t\t\n\t\t\telse if(fTime < 15.0)\n\t\t\t{\n\t\t\t\tfloat f = (fTime - 10.0) \/ 5.0;\n\t\t\t\tfOffset = fPixelRepeat * 0.5;\n\t\t\t\tfFocus = 1.0 - f; \n\t\t\t}\n\t\t\telse\t\t\t\n\t\t\t{\n\t\t\t\tfOffset = fPixelRepeat * 0.5;\n\t\t\t\tfFocus = 0.0; \n\t\t\t\t\n\t\t\t\t\/\/ wiggle picture (doesnt work with animated background noise)\n\t\t\t\t#ifndef RANDOM_BACKDROP_OFFSET_PER_LINE\n\t\t\t\tvec2 vPixelCoord = fragCoord.xy;\n\t\t\t\tfloat fDepth = GetDepth(vPixelCoord, vec4(0.0)).w;\n\t\t\t\tfOffset2 = (fDepth - 0.5) * sin(fTime * 32.0) * 4.0;\n\t\t\t\t\n\t\t\t\t\t#ifndef ADD_COLOUR\n\t\t\t\t\tif(vPixelCoord.y < (iResolution.y - 32.0))\n\t\t\t\t\t{\n\t\t\t\t\t\tfOffset = 0.0;\n\t\t\t\t\t\tfOffset2 += fPixelRepeat * 0.5;\n\t\t\t\t\t}\n\t\t\t\t\t#endif\n\t\t\t\t#endif\n\t\t\t}\n\t\t}\n\t\t\n\t\tfloat fCoC1 = (0.5 - abs(0.5 - fract(fOffset * 2.0 \/ fPixelRepeat))) * 2.0;\n\t\tfloat fCoC2 = (0.5 - abs(0.5 - fract(fOffset \/ fPixelRepeat))) * 2.0;\n\t\tfloat fCoC = mix(fCoC1, fCoC2, fFocus);\n\t\tfCoC = smoothstep(0.2, 1.0, fCoC) * 8.0;\n\t\tvec3 vColour = vec3(0.0);\n\t\tfloat fTotal = 0.0;\n\t\tfor(int i=0; i<16; i++)\n\t\t{\n\t\t\tvec2 vOffset = (Random2(fTotal) * 2.0 - 1.0) * fCoC;\n\t\t\tvColour += (ImageColour(fragCoord.xy + vec2(-fOffset + fOffset2, 0.0) + vOffset)\n\t\t\t \t\t+  ImageColour(fragCoord.xy + vec2( fOffset + fOffset2, 0.0)+vOffset)) * 0.5;\n\t\t\tfTotal+= 1.0;\n\t\t}\n\t\tvColour \/= fTotal;\n\t#else\n\t\t#ifdef OVERLAY_MODE\n\t\t\tfloat fOffset = (iMouse.x - iResolution.x * 0.5) * 0.25;\n\t\t\tvec3 vColour = (ImageColour(fragCoord.xy + vec2(-fOffset, 0.0))\n\t\t\t\t\t\t +  ImageColour(fragCoord.xy + vec2( fOffset, 0.0))) * 0.5;\n\t\t#else\n\t\t\tvec3 vColour = ImageColour(fragCoord.xy);\n\t\t#endif\n\t\t\n\t#endif\n\tfragColor = vec4(vColour,1.0);\n}","name":"","description":"","type":"image"}]}}