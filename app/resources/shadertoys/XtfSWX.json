{"Shader":{"ver":"0.1","info":{"id":"XtfSWX","date":"1439998199","viewed":787,"name":"Skin peeler","username":"Dave_Hoskins","description":"I thought I had lost this, but it turned up in an old SynthClips project. It's an edit of Nimitz's \"Xyptonjtroz\", before I re-wrote it to make \"Frozen Wasteland\". I thought I'd post it here before it gets lost forever! <img src=\"\/img\/emoticonHappy.png\"\/>","likes":22,"published":3,"flags":8,"tags":["3d","raymarching","audio","wind","xyptonjtroz","sand","daytime"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Skin peeler\n\/\/ by Dave Hoskins\n\/\/ Originally from Xyptonjtroz by nimitz (twitter: @stormoid)\n\/\/ Edited by Dave Hoskins, by changing atmosphere with quite a few lighting changes & added audio\n\n#define ITR 100\n#define FAR 30.\n#define time iGlobalTime\n\n\/*\n\tBelievable animated volumetric dust storm in 7 samples,\n\tblending each layer in based on geometry distance allows to\n\trender it without visible seams. 3d Triangle noise is \n\tused for the dust volume.\n\n\tFurther explanation of the dust generation...\n\t\t\n\tThe basic idea is to have layers of gradient shaded volumetric\n\tanimated noise. The problem is when geometry is intersected\n\tbefore the ray reaches the far plane. A way to smoothly blend\n\tthe low sampled noise is needed.  So I am blending (smoothstep)\n\teach dust layer based on current ray distance and the solid \n\tinteresction distance. I am also scaling the noise taps\tas a \n\tfunction of the current distance so that the distant dust doesn't\n\tappear too noisy and as a function of current height to get some\n\t\"ground hugging\" effect.\n\t\n*\/\n\n#define MOD3 vec3(.16532,.17369,.15787)\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\n\nfloat height(in vec2 p)\n{\n    p *= 0.2;\n    return sin(p.y)*0.4 + sin(p.x)*0.4;\n}\n\n\/\/smooth min form iq\nfloat smin( float a, float b)\n{\n    const float k = 0.7;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\/\/\/  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3.zxy, p3.yxz+19.19);\n    return fract(vec2(p3.x * p3.y, p3.z*p3.x));\n}\n\nfloat vine(vec3 p, in float c, in float h)\n{\n    p.y += sin(p.z*.5625+1.3)*1.5-.5;\n    p.x += cos(p.z*.4575)*1.;\n    \/\/p.z -=.3;\n    vec2 q = vec2(mod(p.x, c)-c\/2., p.y);\n    return length(q) - h -sin(p.z*3.+sin(p.x*7.)*0.5+time)*0.13;\n}\n\nfloat map(vec3 p)\n{\n    p.y += height(p.zx);\n    \n    vec3 bp = p;\n    vec2 hs = hash22(floor(p.zx\/4.));\n    p.zx = mod(p.zx,4.)-2.;\n    \n    float d = p.y+0.5;\n    p.y -= hs.x*0.4-0.15;\n    p.zx += hs*1.3;\n    d = smin(d, length(p)-hs.x*0.4);\n    \n    d = smin(d, vine(bp+vec3(1.8,0.,0),15.,.8) );\n    d = smin(d, vine(bp.zyx+vec3(0.,0,17.),20.,0.75) );\n    \n    return d*1.1;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.002;\n    float h=precis*2.0;\n    float d = 0.;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t   \th = map(ro+rd*d);\n        \n    }\n\treturn d;\n}\n\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                 \nmat2 m2 = mat2(0.970,  0.242, -0.242,  0.970);\n\nfloat triNoise3d(in vec3 p)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec3 dg = tri3(bp);\n        p += (dg);\n\n        bp *= 2.;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        \/\/p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))\/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\nfloat fogmap(in vec3 p, in float d)\n{\n   p.x += time;\n   p.z += time*.5;\n    \n    return triNoise3d(p*2.2\/(d+8.0))*(smoothstep(.7,.0,p.y));\n}\n\nvec3 fog(in vec3 col, in vec3 ro, in vec3 rd, in float mt)\n{\n    float d = .5;\n    for(int i=0; i<7; i++)\n    {\n        vec3  pos = ro + rd*d;\n        float rz = fogmap(pos, d);\n        col = mix(col,vec3(.85, .65, .5),clamp(rz*smoothstep(d,d*1.8,mt),0.,1.) );\n        d *= 1.8;\n        if (d>mt)break;\n    }\n    return col;\n}\n\nvec3 normal(in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.005;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\nfloat bnoise(in vec3 p)\n{\n    float n = sin(triNoise3d(p*3.)*7.)*0.4;\n    n += sin(triNoise3d(p*1.5)*7.)*0.2;\n    return (n*n)*0.01;\n}\n\nvec3 bump(in vec3 p, in vec3 n, in float ds)\n{\n    vec2 e = vec2(.005,0);\n    float n0 = bnoise(p);\n    vec3 d = vec3(bnoise(p+e.xyy)-n0, bnoise(p+e.yxy)-n0, bnoise(p+e.yyx)-n0)\/e.x;\n    n = normalize(n-d*2.5\/sqrt(ds));\n    return n;\n}\n\nfloat shadow(in vec3 ro, in vec3 rd, in float mint, in float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<20; i++ )\n    {\n\t\tfloat h = map(ro + rd*t);\n        res = min( res, 4.*h\/t );\n        t += clamp( h, 0.2, 1.5 );\n            }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\n{\t\n\tvec2 p = fragCoord.xy\/iResolution.xy-0.5;\n    vec2 q = fragCoord.xy\/iResolution.xy;\n\tp.x*=iResolution.x\/iResolution.y;\n    vec2 mo = iMouse.xy \/ iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(-0.1,0.07):mo;\n\tmo.x *= iResolution.x\/iResolution.y;\n\t\n\tvec3 ro = vec3(smoothstep(0.,1.,tri(time*.6)*2.)*0.1, smoothstep(0.,1.,tri(time*1.2)*2.)*0.05, -time*0.6);\n    ro.y -= height(ro.zx)+0.07;\n    mo.x += smoothstep(0.7,1.,sin(time*.35))-1.5 - smoothstep(-.7,-1.,sin(time*.35));\n \n    vec3 eyedir = normalize(vec3(cos(mo.x),mo.y*2.-0.2+sin(time*.75*1.37)*0.15,sin(mo.x)));\n    vec3 rightdir = normalize(vec3(cos(mo.x+1.5708),0.,sin(mo.x+1.5708)));\n    vec3 updir = normalize(cross(rightdir,eyedir));\n\tvec3 rd=normalize((p.x*rightdir+p.y*updir)*1.+eyedir);\n\t\n    vec3 ligt = normalize( vec3(.5, .5, -.2) );\n    \n\tfloat rz = march(ro,rd);\n\t\n    vec3 fogb = mix(vec3(.5, .4,.4), vec3(1.,.9,.8), min(pow(max(dot(rd,ligt), 0.0), 1.5)*1.25, 1.0));\n    vec3 col = fogb;\n    \n    if ( rz < FAR )\n    {\n        vec3 pos = ro+rz*rd;\n        vec3 nor= normal( pos );\n        float d = distance(pos,ro);\n        nor = bump(pos,nor,d);\n        float shd = shadow(pos,ligt,0.1,3.);\n        float dif = clamp( dot( nor, ligt ), 0.0, 1.0 )*shd;\n        float spe = pow(clamp( dot( reflect(rd,nor), ligt ), 0.0, 1.0 ),3.)*shd;\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 1.5 );\n        vec3 brdf = dif*vec3(1.00)+abs(nor.y)*.4;\n        col = clamp(mix(vec3(.7,0.4,.3),vec3(.3, 0.1, 0.1),(pos.y+.5)*.25), .0, 1.0);\n        col *= (sin(bnoise(pos*.1)*250.)*0.5+0.5);\n        col = col*brdf + spe*fre;\/\/ + fre*vec3(.4,.4,0.4)*.5*crv;\n    }\n    \n    \/\/ordinary distance fog first\n    col = mix(col, fogb, smoothstep(FAR-10.,FAR,rz));\n    \n    \/\/then volumetric fog\n    col = fog(col, ro, rd, rz);\n    \n    \/\/post...\n\n\tcol = pow(col,vec3(0.8));\n    col = smoothstep(0.0, 1.0, col);\n    \n    col *= .5+.5*pow(70. *q.x*q.y*(1.0-q.x)*(1.0-q.y), .2);\n    \n    \n\tfragColor = vec4( col  * smoothstep(0.0, 3.0, time), 1.0 );\n}\n\n\n\n","name":"","description":"","type":"image"},{"inputs":[],"outputs":[{"channel":"0"}],"code":"vec2 add = vec2(1.0, 0.0);\n#define MOD2 vec2(.16632,.17369)\n#define MOD3 vec3(.16532,.17369,.15787)\n\nfloat tri(in float x){return abs(fract(x)-.5)*2.0;}\n\/\/----------------------------------------------------------------------------------------\n\/\/  1 out, 1 in ...\nfloat hash11(float p)\n{\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);\n}\n\/\/----------------------------------------------------------------------------------------\n\/\/  2 out, 1 in...\nvec2 hash21(float p)\n{\n\t\/\/p  = fract(p * MOD3);\n    vec3 p3 = fract(vec3(p) * MOD3);\n    p3 += dot(p3.xyz, p3.yzx + 19.19);\n   return fract(vec2(p3.x * p3.y, p3.z*p3.x));\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/\/  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3.zxy, p3.yxz+19.19);\n    return fract(vec2(p3.x * p3.y, p3.z*p3.x));\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  2 out, 1 in...\nvec2 Noise21(float x)\n{\n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return  mix( hash21(p), hash21(p + 1.0), f)-.5;\n    \n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  2 out, 1 in...\nfloat Noise11(float x)\n{\n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix( hash11(p), hash11(p + 1.0), f)-.5;\n\n}\n\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  2 out, 2 in...\nvec2 Noise22(vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    vec2 res = mix(mix( hash22(p),          hash22(p + add.xy),f.x),\n                   mix( hash22(p + add.yx), hash22(p + add.xx),f.x),f.y);\n    return res-.5;\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ Fractal Brownian Motion...\nvec2 FBM22(vec2 x)\n{\n    vec2 r = vec2(0.0);\n    \n    float a = .6;\n    \n    for (int i = 0; i < 8; i++)\n    {\n        r += Noise22(x * a) \/ a;\n        a += a;\n    }\n     \n    return r;\n}\n\n\nvec2 mainSound(float time)\n{\n     vec2 audio = vec2(.0);\n    for (float t = 0.0; t < 1.0; t+=.5)\n    {\n        time = time+t;\n        vec2 n1 = FBM22( time*(Noise21(time*3.25)*40.0+Noise21(time*.3)*7500.0+9500.0)) * (abs(Noise21(time)))*1.5;\n        vec2 n2 = FBM22( time*(Noise21(time*.4)+3900.0))*abs(Noise21(time*1.5))*1.5;\n        vec2 n3 = FBM22( time*(Noise21(time*1.3)+Noise21(-time*.03)*200.0+1940.0))*(.5+abs(Noise21(time-99.)))*1.5;\n        vec2 s1 = sin(time*240.+(Noise21(time*.23))*(Noise21(-time*.12)*2000.0+4000.0))*abs(Noise21(time*32.3+199.))*abs(Noise21(-time*.04+9.)+.5)*4.;\n\n        audio += (n1+n2+n3+s1)\/8.0;\n    }\n    float foot = tri(time*1.2);\n    audio += Noise11(time*10.0)*Noise11(time*500.0)*Noise11(time*3000.0)* smoothstep(0.6,1.,abs(foot)) *6.;\n    \n    return clamp(audio, -1.0, 1.0) * smoothstep(0.0, 3.0, time) * smoothstep(60.0, 55.0, time);\n    \n    \n}","name":"","description":"","type":"sound"}]}}