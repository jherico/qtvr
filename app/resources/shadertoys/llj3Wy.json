{"Shader":{"ver":"0.1","info":{"id":"llj3Wy","date":"1432277366","viewed":2681,"name":"Nitrostasis","username":"otaviogood","description":"Ray marching some noise with a (1\/distance) march count glow. I had to do a stochastic sampling look to get rid of banding from 1\/distance, but I think it worked.","likes":31,"published":3,"flags":0,"tags":["volume","clouds","fire"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/*--------------------------------------------------------------------------------------\nLicense CC0 - http:\/\/creativecommons.org\/publicdomain\/zero\/1.0\/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^This means do anything you want with this code. Because we are programmers, not lawyers.\n\n-Otavio Good\n*\/\n\nfloat localTime = 0.0;\nfloat marchCount;\n\nfloat PI=3.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\n\n\/\/ noise functions\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(sin(f)*110003.9);\n}\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv.xy);\n    vec2 fl = floor(uv.xy);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\nfloat noiseValue(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x),\n             mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x),\n             mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\n\/\/ IQ's style of super fast texture noise\nfloat noiseTex(in vec3 x)\n{\n    vec3 fl = floor(x);\n    vec3 fr = fract(x);\n\tfr = fr * fr * (3.0 - 2.0 * fr);\n\tvec2 uv = (fl.xy + vec2(37.0, 17.0) * fl.z) + fr.xy;\n\tvec2 rg = texture2D(iChannel0, (uv + 0.5) * 0.00390625, -100.0 ).xy;\n\treturn mix(rg.y, rg.x, fr.z);\n}\n\/\/ 2 components returned\nvec2 noiseTex2(in vec3 x)\n{\n    vec3 fl = floor(x);\n    vec3 fr = fract(x);\n\tfr = fr * fr * (3.0 - 2.0 * fr);\n\tvec2 uv = (fl.xy + vec2(37.0, 17.0) * fl.z) + fr.xy;\n\tvec4 rgba = texture2D(iChannel0, (uv + 0.5) * 0.00390625, -100.0 ).xyzw;\n\treturn mix(rgba.yw, rgba.xz, fr.z);\n}\n\nvec3 camPos = vec3(0.0), camFacing;\nvec3 camLookat=vec3(0,0.0,0);\n\n\/\/ polynomial smooth min (k = 0.1);\nfloat smin(float a, float b, float k)\n{\n    float h = clamp( 0.5+0.5*(b-a)\/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat smax(float a, float b, float k)\n{\n    float h = clamp( 0.5+0.5*((-b)+a)\/k, 0.0, 1.0 );\n    return -(mix( -b, -a, h ) - k*h*(1.0-h));\n}\n\nvec2 matMin(vec2 a, vec2 b)\n{\n\tif (a.x < b.x) return a;\n\telse return b;\n}\n\n\/\/ Calculate the distance field that defines the object.\nvec2 DistanceToObject(in vec3 p)\n{\n    \/\/ first distort the y with some noise so it doesn't look repetitive.\n    \/\/p.xyz = RotateY(p, length(p.xz) + iGlobalTime);\n    \/\/p.y += 0.1;\n    \/\/p.xyz = RotateZ(p, length(p.z) + iGlobalTime);\n    p.y += noiseTex(p*0.5)*0.5;\n    \/\/ multiple frequencies of noise, with time added for animation\n    float n = noiseTex(p*2.0+iGlobalTime*0.6);\n    n += noiseTex(p*4.0+iGlobalTime*0.7)*0.5;\n    n += noiseTex(p*8.0)*0.25;\n    n += noiseTex(p*16.0)*0.125;\n    n += noiseTex(p*32.0)*0.0625;\n    n += noiseTex(p*64.0)*0.0625*0.5;\n    n += noiseTex(p*128.0)*0.0625*0.25;\n    \/\/ subtract off distance for cloud thickness\n    float dist = n*0.25 - (0.275);\/\/ - abs(p.y*0.02)\/* - iGlobalTime*0.01*\/);\n    \/\/dist = smax(dist, -(length(p-camPos) - 0.3), 0.1);\t\/\/ nice near fade\n    \/\/ smooth blend subtract repeated layers\n    dist = smax(dist, -(abs(fract(p.y*4.0)-0.5) - 0.15), 0.4);\n    vec2 distMat = vec2(dist, 0.0);\n    \/\/ sun in the distance\n    distMat = matMin(distMat, vec2(length(p-camLookat - vec3(0.0, 0.5, -1.0)) - 0.6, 6.0));\n    return distMat;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    localTime = iGlobalTime - 0.0;\n\t\/\/ ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv = fragCoord.xy\/iResolution.xy * 2.0 - 1.0;\n    float zoom = 1.7;\n    uv \/= zoom;\n\n\t\/\/ Camera up vector.\n\tvec3 camUp=vec3(0,1,0);\n\n\t\/\/ Camera lookat.\n\tcamLookat=vec3(0,0.0,0);\n\n    \/\/ debugging camera\n    float mx=(iMouse.x\/iResolution.x+0.375)*PI*2.0-0.7 + localTime*3.1415 * 0.0625*0.666*0.0;\n\tfloat my=-iMouse.y*0.0\/iResolution.y*10.0 - sin(localTime * 0.31)*0.5*0.0;\/\/*PI\/2.01;\n\tcamPos += vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(3.2);\n    camPos.z -= iGlobalTime * 0.5;\n    camLookat.z -= iGlobalTime * 0.5;\n\n    \/\/ add randomness to camera for depth-of-field look close up.\n    \/\/ Reduces the banding the the marchcount glow causes\n    camPos += vec3(Hash2d(uv)*0.91, Hash2d(uv+37.0), Hash2d(uv+47.0))*0.01;\n\n\t\/\/ Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x\/iResolution.y) + uv.y * upNorm;\n\tvec3 rayVec = normalize(worldPix - camPos);\n\n\t\/\/ ----------------------------------- Animate ------------------------------------\n\t\/\/ --------------------------------------------------------------------------------\n\tvec2 distAndMat = vec2(0.5, 0.0);\n    const float nearClip = 0.02;\n\tfloat t = nearClip;\n\tfloat maxDepth = 10.0;\n\tvec3 pos = vec3(0,0,0);\n    marchCount = 0.0;\n    {\n        \/\/ ray marching time\n        for (int i = 0; i < 150; i++)\t\/\/ This is the count of the max times the ray actually marches.\n        {\n            pos = camPos + rayVec * t;\n            \/\/ *******************************************************\n            \/\/ This is _the_ function that defines the \"distance field\".\n            \/\/ It's really what makes the scene geometry.\n            \/\/ *******************************************************\n            distAndMat = DistanceToObject(pos);\n            if ((t > maxDepth) || (abs(distAndMat.x) < 0.0025)) break;\n            \/\/ move along the ray\n            t += distAndMat.x * 0.7;\n            \/\/marchCount+= (10.0-distAndMat.x)*(10.0-distAndMat.x)*1.2;\/\/distance(lastPos, pos);\n            marchCount+= 1.0\/distAndMat.x;\n        }\n    }\n\n    \/\/ --------------------------------------------------------------------------------\n\t\/\/ Now that we have done our ray marching, let's put some color on this geometry.\n\n\tvec3 finalColor = vec3(0.0);\n\n\t\/\/ If a ray actually hit the object, let's light it.\n\tif (abs(distAndMat.x) < 0.0025)\n   \/\/ if (t <= maxDepth)\n\t{\n        \/\/ ------ Calculate texture color ------\n        vec3 texColor = vec3(0.2, 0.26, 0.21)*0.75;\n        \/\/ sun material\n        if (distAndMat.y == 6.0) texColor = vec3(0.51, 0.21, 0.1)*10.5;\n        finalColor = texColor;\n\n        \/\/ visualize length of gradient of distance field to check distance field correctness\n        \/\/finalColor = vec3(0.5) * (length(normalU) \/ smallVec.x);\n        \/\/finalColor = normal * 0.5 + 0.5;\n\t}\n    else\n    {\n    }\n    \/\/ This is the glow\n    finalColor += marchCount * vec3(4.2, 1.0, 0.41) * 0.0001;\n    \/\/ fog\n\tfinalColor = mix(vec3(0.91, 0.81, 0.99)*1.75, finalColor, exp(-t*0.15));\n\n    if (t <= nearClip) finalColor = vec3(1.9, 1.1, 0.9)*0.25 * noiseTex(vec3(iGlobalTime*8.0));\n\n    \/\/ vignette?\n    finalColor *= vec3(1.0) * pow(saturate(1.0 - length(uv\/2.5)), 2.0);\n    finalColor *= 1.2;\n    finalColor *= 0.85;\n\n\t\/\/ output the final color with sqrt for \"gamma correction\"\n\tfragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n","name":"","description":"","type":"image"}]}}