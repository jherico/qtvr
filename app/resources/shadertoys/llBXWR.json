{"Shader":{"ver":"0.1","info":{"id":"llBXWR","date":"1442730149","viewed":916,"name":"Tunnel Experiment 1","username":"aiekick","description":"Tunnel Experiment 1","likes":4,"published":3,"flags":0,"tags":["tunnel","experiment","1"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Stephane Cuillerdier - Aiekick\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define mPi 3.14159\n#define m2Pi 6.28318\n\nfloat dstepf = 0.0;\n\nconst vec2 NoiseVar = vec2(950.,200.);\n    \nconst vec2 RMPrec = vec2(.1, 0.001); \nconst vec2 DPrec = vec2(0.0001, 500.); \n\nfloat random(float p) {return fract(sin(p)*NoiseVar.x);}\nfloat mynoise(vec2 p) {return random(p.x + p.y*NoiseVar.y);}\nvec2 sw(vec2 p) {return vec2( floor(p.x) , floor(p.y) );}\nvec2 se(vec2 p) {return vec2( ceil(p.x)  , floor(p.y) );}\nvec2 nw(vec2 p) {return vec2( floor(p.x) , ceil(p.y)  );}\nvec2 ne(vec2 p) {return vec2( ceil(p.x)  , ceil(p.y)  );}\nfloat snoise(vec2 p) {\n  \tvec2 inter = smoothstep(0., 1., fract(p));\n  \tfloat s = mix(mynoise(sw(p)), mynoise(se(p)), inter.x);\n  \tfloat n = mix(mynoise(nw(p)), mynoise(ne(p)), inter.x);\n  \treturn mix(s, n, inter.y);\n}\n\n\/\/https:\/\/www.shadertoy.com\/view\/llsXzB\n\/\/https:\/\/en.wikipedia.org\/wiki\/Oren%E2%80%93Nayar_reflectance_model\nfloat OrenNayarLightModel(vec3 rd, vec3 ld, vec3 n, float albedo)\n{\n\tvec3 col = vec3(0.);\n\tfloat RDdotN = dot(-rd, n);\n\tfloat NdotLD = dot(n, ld);\n    float aRDN = acos(RDdotN);\n\tfloat aNLD = acos(NdotLD);\n\tfloat mu = 5.; \/\/ roughness\n\tfloat A = 1.-.5*mu*mu\/(mu*mu+0.57);\n    float B = .45*mu*mu\/(mu*mu+0.09);\n\tfloat alpha = max(aRDN, aNLD);\n\tfloat beta = min(aRDN, aNLD);\n\tfloat e0 = 4.8;\n\treturn albedo \/ mPi * cos(aNLD) * (A + ( B * max(0.,cos(aRDN - aNLD)) * sin(alpha) * tan(beta)))*e0;\n}\n\n\/\/https:\/\/www.shadertoy.com\/view\/Xl23Rc\nvec3 strate(vec2 uv)\n{\n    vec3 col1 = vec3(.94,.7,.25);\n    vec3 col2 = vec3(.91,.67,.11);\n    float y = uv.y+.85*sin(-uv.x);\n    y\/=.85;\n    float r = sin(25.*y)+cos(16.*y)+cos(19.*y);\n    vec3 col = mix(col1, col2, r);\n    return col;\n}\n\n\/\/ used to compute campath and plane deformation along z\nfloat cosPath(vec3 p, vec3 dec){return dec.x * cos(p.z * dec.y + dec.z);}\nfloat sinPath(vec3 p, vec3 dec){return dec.x * sin(p.z * dec.y + dec.z);}\n\nvec2 getCylinder(vec3 p, vec2 pos, float r, vec3 c, vec3 s)\n{return p.xy - pos - vec2(cosPath(p, c), sinPath(p, s));}\n\nfloat smin( float a, float b, float smoothing ){\n\n    float h = clamp( 0.5+0.5*(b-a)\/smoothing, 0.0, 1.0 );\n    return mix( b, a, h ) - smoothing*h*(1.0-h);\n}\n\nvec2 map(vec3 p)\n{\n\tvec2 res = vec2(0.);\n\t\n\tfloat strateDisp = dot(strate(p.xy\/2.7), vec3(.17));\n\tfloat strateNoise = snoise(p.zy\/.67) *.17;\n\t\n\tfloat path = sinPath(p ,vec3(6.2, .33, 0.));\n\n\tfloat bottom = p.y + .7 - snoise(p.xz) * .38- snoise(p.xz\/.039) * .05;\n\tres = vec2(bottom, 1.);\n\n\tfloat cyl = 0.;vec2 vecOld;\n\tfor (float i=0.;i<6.;i++)\n\t{\n\t\tfloat x = 1. * i;\n\t\tfloat y\t= .88 + 0.0102*i;\n\t\tfloat z\t = -0.02 -0.16*i;\n\t\tfloat r = 4.4 + 2.45 * i;\n\t\tvec2 vec = getCylinder(p, vec2(path, 3.7 * i), r , vec3(x,y,z), vec3(z,x,y)) +  strateDisp + strateNoise;\n\t\tcyl = r - smin(length(vec), length(vecOld), .28);\n\t\tvecOld = vec;\t\n\t}\n\n\tif (cyl < res.x)\n\t\tres = vec2(cyl, 2.);\n\t\t\n\treturn res;\n}\n\nvec3 nor( vec3 pos, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n\t\tmap(pos+e.xyy).x - map(pos-e.xyy).x,\n\t\tmap(pos+e.yxy).x - map(pos-e.yxy).x,\n\t\tmap(pos+e.yyx).x - map(pos-e.yyx).x );\n    return normalize(n);\n}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cu, vec3 cv)\n{\n\tvec3 rov = normalize(cv-ro);\n    vec3 u =  normalize(cross(cu, rov));\n    vec3 v =  normalize(cross(rov, u));\n    vec3 rd = normalize(rov + u*uv.x + v*uv.y);\n    return rd;\n}\n\n\/\/ from iq code\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h\/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\/\/ from iq code\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)\/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nconst vec3 lig = vec3(-0.2, 1., -0.2);\nvec3 lighting(vec3 col, vec3 p, vec3 n, vec3 rd, vec3 ref, float t) \/\/ lighting    \n{\n\t\/\/ from iq code\n\tfloat occ = calcAO( p, n );\n\tfloat amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n\tfloat dif = clamp( dot( n, lig ), 0.0, 1.0 );\n\tfloat bac = clamp( dot( n, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-p.y,0.0,1.0);\n\tfloat dom = smoothstep( -0.1, 0.1, ref.y );\n\tfloat fre = pow( clamp(1.0+dot(n,rd),0.0,1.0), 2.0 );\n\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n\tdif *= softshadow( p, lig, 0.02, 2.5 );\n\tdom *= softshadow( p, ref, 0.02, 2.5 );\n\n\tvec3 brdf = vec3(0.0);\n\tbrdf += 1.20*dif*vec3(1.00,0.90,0.60);\n\tbrdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n\tbrdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n\tbrdf += 0.40*dom*vec3(0.50,0.70,1.00)*occ;\n\tbrdf += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n\tbrdf += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\tbrdf += 0.02;\n\tcol = col*brdf;\n\n\tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0005*t*t ) );\n\t\n\treturn col;\n}\n\nvoid mainImage( out vec4 f, in vec2 g )\n{\n    vec2 si = iResolution.xy;\n\tvec2 uv = (g+g-si)\/min(si.x, si.y);\n\n    float t = iGlobalTime*5.;\n\t\n\tvec4 gp = vec4(0.,5.,0.,0.);\/\/uGamePad360;\n\t\n    vec3 cu = vec3(0,1,0);\n    vec3 ro = vec3(gp.xy, t);\n\tvec3 cv = vec3(gp.zw*.01,.08); \n\tvec3 rd = cam(uv, ro, cu, ro + cv);\n    vec3 d = vec3(0.);\n    vec3 p = ro+rd*d.x;\n    vec2 s = vec2(DPrec.y,0.);\n\t\n    for(int i=0;i<200;i++)\n\t{      \n\t\tif(s.x<DPrec.x||s.x>DPrec.y) break;\n        s = map(p);\n\t\td.x += s.x * (s.x>DPrec.x?RMPrec.x:RMPrec.y);\n        p = ro+rd*d.x;\n   \t}\n\t\n\tif (d.x<DPrec.y)\n\t{\n\t\tvec3 n = nor(p, .05);\n        \n        float rug = 0.;\n        if ( s.y < 1.5) rug = .75;\t\/\/ sand\n\t\telse rug = .3; \/\/ wall\n\t\n\t\tf.rgb = vec3(.98,.76,.24) + OrenNayarLightModel(reflect(rd, n), rd, n, rug); \/\/ roughness\n        f.rgb = lighting(f.rgb, p, n, rd, rd, d.x); \/\/ lighting    \n   \t}\n}\n","name":"","description":"","type":"image"}]}}