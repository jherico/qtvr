{"Shader":{"ver":"0.1","info":{"id":"Xs2SzR","date":"1408490004","viewed":1577,"name":"Nebula Flight","username":"TekF","description":"Experiment in marching emissive media, to try to get something fast enough to run full screen.","likes":23,"published":3,"flags":0,"tags":["raymarching"],"hasliked":0},"renderpass":[{"inputs":[{"id":28,"src":"\/presets\/tex15.png","ctype":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Ben Quantock 2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nconst float tau = 6.28318530717958647692;\n\n#if ( 1 ) \/\/ is hash noise or texture noise faster?\n\n\/\/ texture noise\nvec2 Noise( in vec3 x )\n{\n    vec3 p = floor(x), f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec4 rg = texture2D( iChannel0, (uv+0.5)\/256.0, -100.0 );\n\treturn mix( rg.yw, rg.xz, f.z );\n}\n\n#else\n\n\/\/ hash noise adapted from IQ\nfloat hash( vec3 p )\n{\n\tfloat h = dot(p,vec3(127.1,311.7,201.3));\n\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix(mix( mix( hash( i + vec3(0,0,0) ), \n                         hash( i + vec3(1,0,0) ), u.x),\n                    mix( hash( i + vec3(0,1,0) ), \n                         hash( i + vec3(1,1,0) ), u.x), u.y),\n               mix( mix( hash( i + vec3(0,0,1) ), \n                         hash( i + vec3(1,0,1) ), u.x),\n                    mix( hash( i + vec3(0,1,1) ), \n                         hash( i + vec3(1,1,1) ), u.x), u.y), u.z );\n}\n\nvec2 Noise( in vec3 x )\n{\n    return vec2( noise(x), noise(x.zxy) );\n}\n\n#endif\n\n\nvec4 Density( vec3 pos )\n{\n    pos \/= 30.0;\n    vec2 s = vec2(0);\n\ts += Noise(pos.xyz\/1.0)\/1.0;\n\ts += Noise(pos.zxy*2.0)\/2.0;\n\ts += Noise(pos.yzx*4.0)\/4.0;\n\ts += Noise(pos.xzy*8.0)\/8.0;\n    \n    s \/= 2.0-1.0\/8.0;\n    \n    s.y = pow(s.y,5.0)*1.0;\n    \n    \/\/s.y *= smoothstep( 2.5, .0, length(pos) );\n    \n    return vec4(pow(sin(vec3(1,2,5)+tau*s.x)*.5+.5,vec3(1.0))*16.0,s.y);\n}\n\n\nvec3 Path( float time )\n{\n    \/\/ sort of like a spirograph pattern, but more random\n    time *= .2;\n    vec2 a = vec2(1,.3)*time;\n    float r = sin(time*1.2)*.2+.8;\n    \n    return 100.0*r*vec3(cos(a.x),1,sin(a.x))*vec2(cos(a.y),sin(a.y)).xyx;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float T = iGlobalTime;\n    \n    \/\/ create a camera without constant \"up\", so we get more spacey feel and more variety\n    \n    \/\/ fly a \"plane\", with a free camera inside it\n    \/\/ i.e. \"up\" stays in the plane of the curve\n    \n    \n    vec3 pos = Path(T);\n    \n    float d = .5;\n    vec3 a=Path(T+d), b=Path(T-d);\n    vec3 sky = (a+b)\/2.0-pos;\n\n    \/\/ alternate between looking forward and looking toward centre of nebula, for parallax\n    vec3 forward = normalize( mix( normalize(a-b), normalize(vec3(0)-pos), smoothstep( -.2, .2, sin(T*.2) ) ) );\n    vec3 right = normalize(cross(sky,forward));\n    vec3 up = normalize(cross(forward,right));\n    \n    vec2 uv = (fragCoord.xy-iResolution.xy*.5)\/iResolution.y;\n    vec3 ray = forward*1.0 + right*uv.x + up*uv.y;\n    ray = normalize(ray);\n    \n    vec3 c = vec3(0,0,0);\n\tfloat t = 0.0;\n    float baseStride = 3.0; \/\/ small enough to detect the highest frequency details\n    float stride = baseStride;\n    float visibility = 1.0;\n    for ( int i=0; i < 30; i++ )\n    {\n        if ( visibility < .001 ) break; \/\/ causes \"ripples\" on things, but not bad.\n        \n        vec4 sample = Density( pos + t*ray );\n        float visibilityAfterSpan = pow( 1.0-sample.a, stride );\n\n\t\t\/\/ optional: don't allow any non-occluding glow\n        sample.rgb *= sample.a;\n\n        c += sample.rgb*visibility*(1.0-visibilityAfterSpan); \/\/ this seems too easy!\n        visibility *= visibilityAfterSpan;\n\n\/\/        float newStride = baseStride\/visibility; \/\/ this is wrong, but looks amazing!\n        float newStride = baseStride\/mix(1.0,visibility,.3); \/\/ step further when visibility is reduced (but not too much\n        t += (stride+newStride)*.5;\n        stride = newStride;\n    }\n    \n    c = pow(c,vec3(1.0\/2.2));\n    \n    \/\/ dithering, because I can see banding\n    c += (texture2D(iChannel1,(fragCoord.xy+.5)\/8.0,-100.0).x-.5)\/256.0;\n    \n\tfragColor = vec4(c,1);\n}","name":"","description":"","type":"image"}]}}