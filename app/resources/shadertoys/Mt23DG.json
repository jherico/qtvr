{"Shader":{"ver":"0.1","info":{"id":"Mt23DG","date":"1432155652","viewed":692,"name":"Worm \/ Ripple from Sphere","username":"ddddddddd","description":"modified from the Simple Sphere shader.<br\/>just playing around. not supposed to be anything precise.","likes":1,"published":3,"flags":0,"tags":["sphere","ripple","worm"],"hasliked":0},"renderpass":[{"inputs":[{"id":1,"src":"\/presets\/tex00.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ simple sphere cheat map.\n\/\/ modified. playing around.\n\/\/ dean alex\n\n\/\/ USE MOUSE\n\n\nfloat radius = 0.25;\nfloat focal = 0.5;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    \/\/----- setup -----\n    float aspect = iResolution.x \/ iResolution.y;\n    float Px = iMouse.x \/ iResolution.x * aspect;\n    float Py = iMouse.y \/ iResolution.y;\n    \n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    \n    float tx = uv.s * aspect;\n    float ty = uv.t;\n    \n    \n    \/\/ play around with the 'center' of the sphere, proportionally with our uv position\n    \/\/ time is one of the sine wave inputs (to make it ripple). the rest are just playing.\n    \/\/ if x effects y, as y effects x, we get more interesting shapes\n    Px = (tx + cos(iGlobalTime * 3.0 - ty)*0.25) * 0.6 + Px * 0.4;\n    Py = Py * ty + (sin(Px * 15.0 + iGlobalTime * 3.0) * 0.15 + 0.4) * (1.0 - ty);\n    \n    \n    \n    \n    \/\/----- get coordinates of texture -----\n    float dx = tx - Px;\n    float dy = ty - Py;\n    float dis = sqrt( dx*dx + dy*dy );\n    \n    if( dis > radius ){ \/\/ piexl is outside boundary of sphere\n        fragColor = texture2D( iChannel0, vec2( tx * 2.0,ty*2.0 ) ) * 0.4;\n        return;\n    }\n    \n    \n    \/\/ width of radius at y\n    float rad_w = sqrt( radius*radius - dy*dy );\n    float warp_x = dx \/ rad_w;\n    \n    \/\/ height of radius at x\n    float rad_h = sqrt( radius*radius - dx*dx );\n    float warp_y = dy \/ rad_h;\n    \n    \/\/ warp the values with a cos curve to approximate the angle of the edges\n    warp_x = warp_x \/ (cos( dx * 3.14159265358979586 ));\n    warp_y = warp_y \/ (cos( dy * 3.14159265358979586 ));\n    \n    \n    \n    \/\/----- shading -----\n    float dismf = dis \/ radius;\n    dismf = 1.0 - dismf;\n    \n    \n    vec4 tex = texture2D( iChannel0, vec2( warp_x * focal + Px, warp_y * focal + Py ) );\n    tex.rgb *= (dismf * 0.9) + 0.1;\n    \n    \/\/ specular\n    dismf = dismf * dismf * dismf * dismf;\n    tex.rgb += dismf;\n        \n    fragColor = tex;\n}\n","name":"","description":"","type":"image"}]}}