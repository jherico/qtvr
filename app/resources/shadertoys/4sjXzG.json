{"Shader":{"ver":"0.1","info":{"id":"4sjXzG","date":"1413297020","viewed":6772,"name":"Terrain Tubes","username":"iq","description":"Testing some super cheap cosine-based noise, and some random ideas on tubes.","likes":68,"published":3,"flags":0,"tags":["procedural","3d","distancefield","terrain"],"hasliked":0},"renderpass":[{"inputs":[{"id":4,"src":"\/presets\/tex03.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":9,"src":"\/presets\/tex08.jpg","ctype":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define USE_BOUND_PLANE\n#define USE_COSINE\n#define DRAW_RUBES\n\nconst mat2 m2 = mat2(1.6,-1.2,1.2,1.6);\n\nfloat tri( in vec2 p )\n{\n#ifdef USE_COSINE\n    return 0.5*(cos(6.2831*p.x) + cos(6.2831*p.y));\n#else\n    vec2 q = 2.0*abs(fract(p)-0.5);\n    q = q*q*(3.0-2.0*q);\n    return -1.0 + q.x + q.y;\n#endif    \n}\n\nfloat terrainLow( vec2 p )\n{\n    p *= 0.0013;\n\n    float s = 1.0;\n\tfloat t = 0.0;\n\tfor( int i=0; i<2; i++ )\n\t{\n        t += s*tri( p );\n\t\ts *= 0.5 + 0.1*t;\n        p = 0.97*m2*p + (t-0.5)*0.2;\n\t}\n\treturn t*55.0;\n}\n\nfloat terrainMed( vec2 p )\n{\n    p *= 0.0013;\n\n    float s = 1.0;\n\tfloat t = 0.0;\n\tfor( int i=0; i<6; i++ )\n\t{\n        t += s*tri( p );\n\t\ts *= 0.5 + 0.1*t;\n        p = 0.97*m2*p + (t-0.5)*0.2;\n\t}\n            \n    return t*55.0;\n}\n\nfloat terrainHigh( vec2 p )\n{\n    vec2 q = p;\n    p *= 0.0013;\n\n    float s = 1.0;\n\tfloat t = 0.0;\n\tfor( int i=0; i<7; i++ )\n\t{\n        t += s*tri( p );\n\t\ts *= 0.5 + 0.1*t;\n        p = 0.97*m2*p + (t-0.5)*0.2;\n\t}\n    \n    t +=   0.05*texture2D( iChannel0, 0.001*q ).x;\n    t +=   0.03*texture2D( iChannel0, 0.005*q ).x;\n    t += t*0.03*texture2D( iChannel0, 0.020*q ).x;\n\n\treturn t*55.0;\n}\n\nfloat tubes( vec3 pos, float time )\n{\n    float sep = 400.0;\n\n    pos.z -= sep*0.025*tri( 0.005*pos.xz*vec2(0.5,1.5) );\n    pos.x -= sep*0.050*tri( 0.005*pos.zy*vec2(0.5,1.5) );\n    \n    vec3 qos = mod( pos + sep*0.5, sep ) - sep*0.5; \n    qos.y = pos.y - 70.0;\n    qos.x += sep*0.3*cos( 0.01*pos.z);\n    qos.y += sep*0.1*cos( 0.01*pos.x );\n\n    float sph = length( qos.xy ) - sep*0.012;\n\n    sph -= (1.0-0.8*smoothstep(-10.0,0.0,qos.y))*sep*0.003*tri( 0.15*pos.xy*vec2(0.2,1.0) );\n\n    return sph;\n}\n\n\nfloat tubesH( vec3 pos, float time )\n{\n    float t = tubes( pos, time );\n\n    t += 1.0*texture2D( iChannel3, 0.01*pos.yz ).x;\n    t += 2.0*texture2D( iChannel0, 0.005*pos.xy ).x;\n\n    return t;\n}\n\nvec2 map( in vec3 pos, float time )\n{\n    float m = 0.0;\n\tfloat h = pos.y - terrainMed(pos.xz);\n\n#ifdef DRAW_RUBES\n    float sph = tubes( pos, time );\n    float k = 60.0;\n    float w = clamp( 0.5 + 0.5*(h-sph)\/k, 0.0, 1.0 );\n    h = mix( h, sph, w ) - k*w*(1.0-w);\n    m = mix( m, 1.0, w ) - 1.0*w*(1.0-w);\n    m = clamp(m,0.0,1.0);\n#endif    \n    return vec2( h, m );\n}\n\nfloat mapH( in vec3 pos, in float time )\n{\n    float y = terrainHigh(pos.xz);\n        \n    float h = pos.y - y;\n    \n#ifdef DRAW_RUBES\n    float sph = tubesH( pos, time );\n    float k = 60.0;\n    float w = clamp( 0.5 + 0.5*(h-sph)\/k, 0.0, 1.0 );\n    h = mix( h, sph, w ) - k*w*(1.0-w);\n#endif    \n\n    return h;\n}\n\nvec2 interesct( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float time )\n{\n    float t = tmin;\n    float  m = 0.0;\n\tfor( int i=0; i<160; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n        vec2 res = map( pos, time );\n        m = res.y;\n        if( res.x<(0.001*t) || t>tmax  ) break;\n        t += res.x * 0.5;\n\t}\n\n\treturn vec2( t, m );\n}\n\nfloat calcShadow(in vec3 ro, in vec3 rd )\n{\n\tvec2  eps = vec2(150.0,0.0);\n    float h1 = terrainMed( ro.xz );\n    float h2 = terrainLow( ro.xz );\n    \n    float d1 = 10.0;\n    float d2 = 80.0;\n    float d3 = 200.0;\n    float s1 = clamp( 1.0*(h1 + rd.y*d1 - terrainMed(ro.xz + d1*rd.xz)), 0.0, 1.0 );\n    float s2 = clamp( 0.5*(h1 + rd.y*d2 - terrainMed(ro.xz + d2*rd.xz)), 0.0, 1.0 );\n    float s3 = clamp( 0.2*(h2 + rd.y*d3 - terrainLow(ro.xz + d3*rd.xz)), 0.0, 1.0 );\n\n    return min(min(s1,s2),s3);\n}\n\nvec3 calcNormalHigh( in vec3 pos, float t, in float time )\n{\n#ifdef DRAW_RUBES\n    vec2 e = vec2(1.0,-1.0)*0.001*t;\n\n    return normalize( e.xyy*mapH( pos + e.xyy, time ) + \n\t\t\t\t\t  e.yyx*mapH( pos + e.yyx, time ) + \n\t\t\t\t\t  e.yxy*mapH( pos + e.yxy, time ) + \n\t\t\t\t\t  e.xxx*mapH( pos + e.xxx, time ) );\n#else\n\tfloat e = 0.003*t;\n    vec2  eps = vec2(e,0.0);\n    float h = terrainHigh( pos.xz );\n    return normalize(vec3( terrainHigh(pos.xz-eps.xy)-h, e, terrainHigh(pos.xz-eps.yx)-h ));\n#endif\n}\n\n\nvec3 calcNormalMed( in vec3 pos, float t )\n{\n\tfloat e = 0.005*t;\n    vec2  eps = vec2(e,0.0);\n    float h = terrainMed( pos.xz );\n    return normalize(vec3( terrainMed(pos.xz-eps.xy)-h, e, terrainMed(pos.xz-eps.yx)-h ));\n}\n\nvec3 camPath( float time )\n{\n    vec2 p = 1100.0*vec2( cos(0.0+0.23*time), cos(1.5+0.205*time) );\n\treturn vec3( p.x, 0.0, p.y );\n}\n\nvec3 dome( in vec3 rd, in vec3 light1 )\n{\n\tfloat sda = clamp(0.5 + 0.5*dot(rd,light1),0.0,1.0);\n    float cho = max(rd.y,0.0);\n    \n    vec3 bgcol = mix( mix(vec3(0.00,0.40,0.60)*0.7, \n                          vec3(0.80,0.70,0.20),                        pow(1.0-cho,3.0 + 4.0-4.0*sda)), \n                          vec3(0.43+0.2*sda,0.4-0.1*sda,0.4-0.25*sda), pow(1.0-cho,10.0+ 8.0-8.0*sda) );\n    bgcol *= 0.8 + 0.2*sda;\n    return bgcol*0.75;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3  cw = normalize(ta-ro);\n\tvec3  cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3  cu = normalize( cross(cw,cp) );\n\tvec3  cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = -1.0 + 2.0*fragCoord.xy\/iResolution.xy;\n    vec2 sp = xy*vec2(iResolution.x\/iResolution.y,1.0);\n\n    \/\/--------------------------\n\n    \/\/ animate    \n    float camid = floor((0.0+iGlobalTime-0.0)\/9.0);\n    float time = 16.5 + (0.0+iGlobalTime-0.0)*0.1 + 20.0*iMouse.x\/iResolution.x + 72.1*camid + 19.0*max(0.0,camid-1.0);\n\n    \/\/ camera    \n\tfloat cr = 0.18*sin(-0.1*time);\n\tvec3  ro = camPath( time + 0.0 );\n\tvec3  ta = camPath( time + 3.0 );\n    ro.y = terrainLow( ro.xz ) + 60.0 + 30.0*sin(1.0*(time-14.4));\n\tta.y = ro.y - 200.0;\n    \/\/ camera to world transformation\n    mat3 cam = setCamera( ro, ta, cr );\n    \n    \/\/ light      \n    vec3 light1 = normalize( vec3(-0.8,0.2,0.5) );\n    \n    \/\/--------------------------\n    \n    \/\/ generate ray\n    vec3 rd = cam * normalize(vec3(sp.xy,1.5));\n        \n    \/\/ background    \n    vec3 bgcol = dome( rd, light1 );\n    \n    \/\/ raymarch\n    float tmin = 10.0;\n    float tmax = 4500.0;\n    \n#ifdef USE_BOUND_PLANE\n    \/\/ intersect boundg plane\n    float maxh = 130.0;\n    float tp = (maxh-ro.y)\/rd.y;\n    if( tp>0.0 )\n    {\n        if( ro.y>maxh ) tmin = max( tmin, tp );\n        else            tmax = min( tmax, tp );\n    }\n#endif\n    \n\tfloat sundotc = clamp( dot(rd,light1), 0.0, 1.0 );\n    vec3  col = bgcol;\n    \n    vec2 res = interesct( ro, rd, tmin, tmax, time );\n    if( res.x>tmax )\n    {\n        \/\/ sky\t\t\n\t\tcol += 0.2*0.12*vec3(1.0,0.5,0.1)*pow( sundotc,5.0 );\n\t\tcol += 0.2*0.12*vec3(1.0,0.6,0.1)*pow( sundotc,64.0 );\n\t\tcol += 0.2*0.12*vec3(2.0,0.4,0.1)*pow( sundotc,512.0 );\n\n        \/\/ clouds\n  \t\tvec2 sc = ro.xz + rd.xz*(1000.0-ro.y)\/rd.y;\n\t\tcol = mix( col, 0.25*vec3(0.5,0.9,1.0), 0.4*smoothstep(0.0,1.0,texture2D(iChannel0,0.000005*sc).x) );\n\n        \/\/ sun scatter\n        col += 0.2*0.2*vec3(1.5,0.7,0.4)*pow( sundotc, 4.0 );\n    }\n\telse\n\t{\n        \/\/ mountains\t\t\n        float t = res.x;\n\t\tvec3 pos = ro + t*rd;\n        vec3 nor = calcNormalHigh( pos, t, time );\n        vec3 sor = calcNormalMed( pos, t );\n        vec3 ref = reflect( rd, nor );\n\n        \/\/ rock\n        col = vec3(0.07,0.06,0.05);\n        col *= 0.2 + sqrt( texture2D( iChannel0, 0.01*pos.xy*vec2(0.5,1.0) ).x *\n                           texture2D( iChannel0, 0.01*pos.zy*vec2(0.5,1.0) ).x );\n        vec3 col2 = vec3(1.0,0.2,0.1)*0.01;\n        col = mix( col, col2, 0.5*res.y );\n        \n        \/\/ grass\n        float s = smoothstep(0.6,0.7,nor.y - 0.01*(pos.y-20.0));        \n        s *= smoothstep( 0.15,0.2,0.01*nor.x+texture2D(iChannel0, 0.001*pos.zx).x);\n        vec3 gcol = 0.13*vec3(0.22,0.23,0.04);\n        gcol *= 0.3+texture2D( iChannel1, 0.03*pos.xz ).x*1.4;\n        col = mix( col, gcol, s );\n        \/\/col *= texture2D( iChannel0, 0.3*pos.xz ).x*3.2;\n        nor = mix( nor, sor, 0.3*s );\n        vec3 ptnor = nor;\n\n        \/\/ trees\n        s = smoothstep(0.9,0.95,nor.y - 0.01*(pos.y-20.0));        \n        s *= smoothstep( 0.1,0.13,-0.17+texture2D(iChannel0, 0.001*pos.zx).x);\n        vec3 tor = -1.0 + 2.0*texture2D( iChannel1, 0.015*pos.xz ).xyz;\n        tor.y = 1.5;\n        tor = normalize(tor);\n        col = mix( col, 0.11*vec3(0.22,0.25,0.02)*1.0, s );\n        nor = mix( nor, tor, 0.7*s );\n        \n\t\t\/\/ snow\n        s = ptnor.y + 0.008*pos.y - 0.2 + 0.2*(texture2D(iChannel1,0.00015*pos.xz+0.0*sor.y).x-0.5);\n        float sf = fwidth(s) * 1.5;\n        s = smoothstep(0.84-sf, 0.84+sf, s );\n        col = mix( col, 0.15*vec3(0.42,0.6,0.8), s);\n        nor = mix( nor, sor, 0.5*smoothstep(0.9, 0.95, s ) );\n\n        \/\/ lighting\t\t\n        float amb = clamp( nor.y,0.0,1.0);\n\t\tfloat dif = clamp( dot( light1, nor ), 0.0, 1.0 );\n\t\tfloat bac = clamp( dot( normalize( vec3(-light1.x, 0.0, light1.z ) ), nor ), 0.0, 1.0 );\n\t\tfloat sha = mix( calcShadow( pos, light1 ), 1.0, res.y );\n        float spe = pow( clamp( dot(ref,light1), 0.0, 1.0 ), 4.0 ) * dif;\n\t\t\n\t\tvec3 lin  = vec3(0.0);\n        lin += dif*vec3(11.0,6.00,3.00)*vec3( sha, sha*sha*0.5+0.5*sha, sha*sha*0.8+0.2*sha );\n\t\tlin += amb*vec3(0.25,0.30,0.40);\n        lin += bac*vec3(0.35,0.40,0.50);\n        lin += spe*vec3(4.00,4.00,4.00)*res.y;\n        \n        col *= lin;\n\n        \/\/ fog\n        col = mix( col, 0.25*mix(vec3(0.4,0.75,1.0),vec3(0.3,0.3,0.3), sundotc*sundotc), 1.0-exp(-0.0000008*t*t) );\n\n        \/\/ sun scatter\n        col += 0.15*vec3(1.0,0.8,0.3)*pow( sundotc, 8.0 )*(1.0-exp(-0.003*t));\n\n        \/\/ background\n        col = mix( col, bgcol, 1.0-exp(-0.00000004*t*t) );\n    }\n    \n    \/\/ gamma\n\tcol = pow( col, vec3(0.45) );\n \n    \/\/ color grading    \n    col = col*1.4*vec3(1.0,1.0,1.02) + vec3(0.0,0.0,0.11);\n    col = clamp(col,0.0,1.0);\n    col = col*col*(3.0-2.0*col);\n    col = mix( col, vec3(dot(col,vec3(0.333))), 0.25 );\n    \n    \/\/ vignetting\t\n \tcol *= 0.5 + 0.5*pow( (xy.x+1.0)*(xy.y+1.0)*(xy.x-1.0)*(xy.y-1.0), 0.1 );\n \n    \/\/ camera fade\n    col *= smoothstep( 0.0, 0.1, 2.0*abs(fract(0.5+iGlobalTime\/9.0)-0.5) );\n   \n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}