{"Shader":{"ver":"0.1","info":{"id":"lt23Dt","date":"1433782349","viewed":857,"name":"bubble dist plasma","username":"FabriceNeyret2","description":"Well, it first was a bug in a Worley\/Voronoi shader... :-)<br\/><br\/>NB: try #define NOISE  1 or 3 if you wish.","likes":16,"published":3,"flags":0,"tags":["voronoi","distance"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define NOISE 2 \/\/ Perlin, Worley1, Worley2\n\n#define PI 3.14159\n\n\/\/ --- noise functions from https:\/\/www.shadertoy.com\/view\/XslGRr\n\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n           \t\t    -0.80,  0.36, -0.48,\n             \t\t-0.60, -0.48,  0.64 );\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x ) { \/\/ in [0,1]\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.-2.*f);\n\n    float n = p.x + p.y*57. + 113.*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p ) { \/\/ in [0,1]\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\/\/ --- End of: Created by inigo quilez --------------------\n\n\/\/ more 2D noise\nvec2 hash12( float n ) {\n    return fract(sin(n+vec2(1.,12.345))*43758.5453);\n}\nfloat hash21( vec2 n ) {\n    return hash(n.x+10.*n.y);\n}\nvec2 hash22( vec2 n ) {\n    return hash12(n.x+10.*n.y);\n}\nfloat cell;   \/\/ id of closest cell\nvec2  center; \/\/ center of closest cell\n\nvec3 worley( vec2 p ) {\n    vec3 d = vec3(1e15);\n    vec2 ip = floor(p);\n    for (float i=-2.; i<3.; i++)\n   \t \tfor (float j=-2.; j<3.; j++) {\n                vec2 p0 = ip+vec2(i,j);\n            \tfloat a0 = hash21(p0), a=5.*a0*iGlobalTime+2.*PI*a0; vec2 dp=vec2(cos(a),sin(a)); \n                vec2  c = hash22(p0)*.5+.5*dp+p0-p;\n                float d0 = dot(c,c);\n                if      (d0<d.x) { d.yz=d.xy; d.x=d0; cell=hash21(p0); center=c;}\n                else if (d0<d.y) { d.z =d.y ; d.y=d0; }\n                else if (d0<d.z) {            d.z=d0; }  \n            }\n    return sqrt(d);\n}\n\n\/\/ distance to Voronoi borders, as explained in https:\/\/www.shadertoy.com\/view\/ldl3W8 \nfloat worleyD( vec2 p) {\n    float d = 1e15;\n    vec2 ip = floor(p);\n    for (float i=-2.; i<3.; i++)\n   \t \tfor (float j=-2.; j<3.; j++) {\n                vec2 p0 = ip+vec2(i,j);\n            \tfloat a0 = hash21(p0), a=5.*a0*iGlobalTime+2.*PI*a0; vec2 dp=vec2(cos(a),sin(a)); \n                vec2  c = hash22(p0)*.5+.5*dp+p0-p;\n                float d0 = dot(c,c);\n \t    float c0 = dot(center+c,normalize(c-center));\n        d=min(d, c0);\n    }\n\n    return .5*d;\n}\n\n\nfloat grad=0.05+4.*(1.+cos(iGlobalTime))*.5, scale = 5.; \n\n\/\/ my noise\nfloat tweaknoise( vec2 p) {\n    float d=0.;\n    for (float i=0.; i<5.; i++) {\n        float a0 = hash(i+5.6789), a=1.*a0*iGlobalTime+2.*PI*a0; vec2 dp=vec2(cos(a),sin(a)); \n                \n        vec2 ip = hash12(i+5.6789)+dp;\n        float di = smoothstep(grad\/2.,-grad\/2.,length(p-ip)-.5);\n        d += (1.-d)*di;\n    }\n    \/\/float d = smoothstep(grad\/2.,-grad\/2.,length(p)-.5);\n#if NOISE==1 \/\/ 3D Perlin noise\n    float v = fbm(vec3(scale*p,.5));\n#elif NOISE==2 \/\/ Worley noise\n    float v = 1. - scale*worley(scale*p).x;\n#elif NOISE>=3 \/\/ trabeculum 2D\n    if (d<0.5) return 0.;\n    grad=.8, scale = 5.;\n\tvec3 w = scale*worley(scale*p);\n    float v;\n    if (false) \/\/ keyToggle(32)) \n        v =  2.*scale*worleyD(scale*p);\n    else\n \tv= w.y-w.x;\t \/\/  v= 1.-1.\/(w.y-w.x);\n#endif\n    \n    return v*d;\n    \/\/return smoothstep(thresh-grad\/2.,thresh+grad\/2.,v*d);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = 2.*(fragCoord.xy \/ iResolution.y -vec2(.9,.5));\n  \n    float c0=tweaknoise(p), c=sin(c0*5.);\n\n    vec3 col; \/\/ = vec3(c);\n    col = .5+.5*cos(c0*5.+vec3(0.,2.*PI\/3.,-2.*PI\/3.));\n    col *= vec3(sin(12.*c0)); \n    \/\/ col = mix(col,vec3(cos(12.*c0)),.5);\n    col = mix(col,vec3(c),.5+.5*cos(.13*(iGlobalTime-6.)));\n\n   fragColor = vec4(col,1.);\n}","name":"","description":"","type":"image"}]}}