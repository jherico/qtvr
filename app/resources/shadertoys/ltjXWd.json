{"Shader":{"ver":"0.1","info":{"id":"ltjXWd","date":"1447460535","viewed":402,"name":"simple hexagon raymarch","username":"macbooktall","description":"just a simple raymarch.<br\/>forked from cail's https:\/\/www.shadertoy.com\/view\/lt2SRt","likes":10,"published":3,"flags":0,"tags":["hexagons"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ tweaked copy of https:\/\/www.shadertoy.com\/view\/Xds3zN by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec3 hue(vec3 color, float shift) {\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI     = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ     = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR   = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG   = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB   = vec3 (1.0, -1.107, 1.704);\n\n    \/\/ Convert to YIQ\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I      = dot (color, kRGBToI);\n    float   Q      = dot (color, kRGBToQ);\n\n    \/\/ Calculate the hue and chroma\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    \/\/ Make the user's adjustments\n    hue += shift;\n\n    \/\/ Convert back to YIQ\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    \/\/ Convert back to RGB\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n    color.r = dot (yIQ, kYIQToR);\n    color.g = dot (yIQ, kYIQToG);\n    color.b = dot (yIQ, kYIQToB);\n\n    return color;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    \/\/pos.x += sin(pos.z+iGlobalTime)*0.2;\n    \/\/pos.y += cos(pos.z+iGlobalTime)*0.2;\n    \n    float height = .42;\n    float depth = .75;\n    float t = 0.02 + sin(iGlobalTime)*0.01;\n    pos.z = mod(pos.z,depth*2.)-0.5*depth*2.;\n\n   \tfloat cyl = sdHexPrism( pos, vec2(height-t, depth+t));\n   \tfloat scyl = sdHexPrism( pos, vec2(height-t*2.0, depth+t+.001));\n    \n    vec2 res = vec2(opS(scyl,cyl),1.5); \n    vec2 final = res;\n    \n    for (int i = 1; i < 3; i++) {\n\n\/\/        float c = cos(pos.z+iGlobalTime*0.5);\n\/\/    float s = sin(pos.z+iGlobalTime*0.5);\n\/\/    mat2  m = mat2(c,-s,s,c);\n\/\/    pos = vec3(m*pos.xy,pos.z);\n        \n        height -= 0.1;\n        depth -= 0.19;\n    \tcyl = sdHexPrism( pos, vec2(height-t, depth+t));\n    \tscyl = sdHexPrism( pos, vec2(height-t*2.0, depth+t+.001));\n\t\n       final = opU(final, vec2(opS(scyl,cyl),2.5)); \n    \n    }\n     \n   return final;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 0.0;\n    float tmax = 100.0;\n    \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<100; i++ )\n    {\n   vec2 res = map( ro+rd*t );\n        if(  t>tmax ) break;\n        t += res.x;\n   m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\nvec3 eps = vec3( 0.01, 0.0, 0.0 );\nvec3 nor = vec3(\n   map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n   map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n   map(pos+eps.yyx).x - map(pos-eps.yyx).x );\nreturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\nfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)\/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= .95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(1.0);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    \n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        \/\/ material        \n        float occ = calcAO( pos, nor );\n\t\tcol = 1.0 - hue(vec3(0.0,1.0,1.0),iGlobalTime*0.02+pos.z)*occ;\n    }\n\nreturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\nvec3 cw = normalize(ta-ro);\nvec3 cp = vec3(sin(cr), cos(cr),0.0);\nvec3 cu = normalize( cross(cw,cp) );\nvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy\/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x\/iResolution.y;\n    vec2 mo = iMouse.xy\/iResolution.xy;\n \n\t\/\/ camera\n\tvec3 ro = vec3(0., 0.,iGlobalTime );\n\t\n    vec3 ta = ro+vec3( 0., 0.,1. );\n\t\n    \/\/ camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 3.14159\/2.0 );\n\n    \/\/ ray direction\n\tvec3 rd = ca * normalize(vec3(p.xy,4.5));\n\n    \/\/ render\n    vec3 col = render( ro, rd );\n\n    fragColor=vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}