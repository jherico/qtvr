{"Shader":{"ver":"0.1","info":{"id":"4tlGz8","date":"1418551733","viewed":286,"name":"Spinning Tree","username":"dr2","description":"A spinning, flapping mechanical tree.","likes":1,"published":3,"flags":0,"tags":["raymarching","rotation"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ \"Spinning Tree\" by dr2 - 2014\n\/\/ License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float s = 0.;\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return s;\n}\n\nvec3 WoodCol (vec3 p, vec3 n)\n{\n  p *= 4.;\n  float f = dot (vec3 (Fbm2 (p.yz * vec2 (1., 0.1)),\n     Fbm2 (p.zx * vec2 (1., 0.1)), Fbm2 (p.yx * vec2 (1., 0.1))), abs (n));\n  return 0.5 * mix (vec3 (0.8, 0.4, 0.2), vec3 (0.45, 0.25, 0.1), f);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p = abs (fract (c.xxx + vec3 (1., 2.\/3., 1.\/3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat AngQnt (float a, float s1, float s2, float nr)\n{\n  return (s1 + floor (s2 + a * (nr \/ (2. * pi)))) * (2. * pi \/ nr);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nint idObj;\nvec3 qHit, ltDir;\nfloat tCur, qLevl;\nconst float dstFar = 150.;\n\nfloat ObjDf (vec3 p)\n{\n  const float tLen = 8., tRad = 0.6, bhLen = 1., blLen = 3., dt = 0.15;\n  float d, mt1, mt2, sFac, kf, tSeq, r;\n  vec3 q = p;\n  float dHit = dstFar;\n  d = PrCylDf (q.xzy, tRad, tLen);\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = 2; }\n  q.y -= -1.05 * tLen;\n  d = PrCylDf (q.xzy, 6. * tRad, 0.05 * tLen);\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = 3; }\n  q.y -= 2.05 * tLen + 1.4 * tRad;\n  d = PrSphDf (q, 1.5 * tRad);\n  if (d < dHit) { dHit = d;  qHit = q;  idObj = 4; }\n  tSeq = mod (tCur, 10.) \/ 10.;\n  for (int k = 0; k < 7; k ++) {\n    kf = float (k);\n    sFac = 1. - 0.1 * kf;\n    q = p;  q.y -= (-0.3 + 0.21 * kf) * tLen;\n    mt1 = tSeq - 0.3;\n    mt2 = 0.9 - tSeq;\n    q.xz = Rot2D (q.xz, pi * (0.1 * (1. + kf) + (1. + 0.5 * kf) *\n      (mt1 * step (abs (mt1 - dt), dt) + mt2 * step (abs (mt2 - dt), dt))));\n    q.xz = Rot2D (q.xz, AngQnt (atan (q.z, - q.x), 0.5, 0., 12.));\n    q.x -= - sFac * bhLen;\n    d = PrBoxDf (q, sFac * vec3 (bhLen, 0.1 * bhLen, 0.5 * bhLen));\n    if (d < dHit) { dHit = d;  qHit = q;  idObj = 1; }\n    q.x -= - sFac * bhLen;\n    q.xy = Rot2D (q.xy, pi * (-0.36 + 0.25 * smoothstep (0.25, 0.4, tSeq - 0.01 * kf) *\n       (1. - smoothstep (0.8, 0.95, tSeq + 0.01 * kf))) * (1. + 0.08 \/ sFac));\n    q.x -= - sFac * blLen;\n    r = 0.5 * (1. - q.x \/ (sFac * blLen));\n    d = PrBoxDf (q, sFac *\n       vec3 (blLen, 0.1 * bhLen * (1. - 0.8 * r), 0.5 * bhLen * (1. + 0.7 * r)));\n    if (d < dHit) { dHit = d;  qHit = q \/ (sFac * blLen);  idObj = 1;  qLevl = kf; }\n  }\n  return dHit;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  const float dTol = 0.001;\n  float d;\n  float dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < dTol || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh = 1.;\n  float d = 0.1;\n  for (int i = 0; i < 100; i++) {\n    float h = ObjDf (ro + rd * d);\n    sh = min (sh, 20. * h \/ d);\n    d += 0.1;\n    if (h < 0.001) break;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nvec3 ObjCol (vec3 n)\n{\n  vec3 col;\n  if (idObj == 1) {\n    if (length (vec2 (qHit.x + 0.85, qHit.z)) < 0.1)\n       col = HsvToRgb (vec3 (mod (0.5 * tCur - qLevl \/ 7., 1.), 1., 1.));\n    else col = vec3 (0.1, 1., 0.1);\n  } else if (idObj == 2) col = WoodCol (3. * qHit.xzy, n);\n  else if (idObj == 3) col = WoodCol (qHit, n);\n  else if (idObj == 4) col = HsvToRgb (vec3 (mod (0.3 * tCur, 1.), 1., 1.));\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, objCol, col;\n  float dstHit, dif;\n  int idObjT;\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  if (idObj < 0) dstHit = dstFar;\n  idObjT = idObj;\n  if (dstHit >= dstFar) col = vec3 (0., 0., 0.04);\n  else {\n    ro += rd * dstHit;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    objCol = ObjCol (vn);\n    dif = max (dot (vn, ltDir), 0.);\n    col = objCol * (0.2 + max (0., dif) * ObjSShadow (ro, ltDir) *\n       (dif + pow (max (0., dot (ltDir, reflect (rd, vn))), 128.)));\n  }\n  col = sqrt (clamp (col, 0., 1.));\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy \/ iResolution.xy - 1.;\n  uv.x *= iResolution.x \/ iResolution.y;\n  tCur = iGlobalTime;\n  float dist = 30.;\n  float az = 0.;\n  float el = 0.2;\n  float cEl = cos (el);\n  float sEl = sin (el);\n  float cAz = cos (az);\n  float sAz = sin (az);\n  mat3 vuMat = mat3 (1., 0., 0., 0., cEl, - sEl, 0., sEl, cEl) *\n     mat3 (cAz, 0., sAz, 0., 1., 0., - sAz, 0., cAz);\n  vec3 rd = normalize (vec3 (uv, 2.4)) * vuMat;\n  vec3 ro = - vec3 (0., 0., dist) * vuMat;\n  ltDir = normalize (vec3 (-0.5, 0.8, -0.4));\n  vec3 col = ShowScene (ro, rd);\n  float vv = dot (uv, uv);\n  col = mix (col, vec3 (1., 1., 0.1), smoothstep (0.8, 1., vv * vv));\n  fragColor = vec4 (col, 1.);\n}\n","name":"","description":"","type":"image"}]}}