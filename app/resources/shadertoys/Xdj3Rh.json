{"Shader":{"ver":"0.1","info":{"id":"Xdj3Rh","date":"1383614599","viewed":1098,"name":"Binary gates","username":"iq","description":"Binary gates","likes":12,"published":3,"flags":0,"tags":["2d"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ In electronics\/logic, there are 16 possible gates that you can build with one output and \n\/\/ two inputs. Some of them have proper names, such as AND, OR, XOR, NAND or NOR (gates 1, \n\/\/ 7, 6, 15 and 8 respectivelly), but others don't.\n\n\/\/ When these gates are made not digital\/discrete but continuous in the interval 0..1, two\n\/\/ dimensional gradients of values appear. Some of them have also proper names in image\n\/\/ manipulation software, such as \"screen\" (which is a gate OR), \"multiply\" (which is\n\/\/ gate AND) or \"exclusion\" (which is gate XOR).\n\n\/\/ The behavior of the gates also matches that of the 16 posible bilinear interpolations\n\/\/ of binary values in the corners of a quad.\n\nfloat bilin( float u, float v, float a, float c, float b, float d )\n{\n    return mix( mix(a,b,u),\n\t\t\t    mix(c,d,u), v );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\t\n\tfloat c = 0.0;\n\t\n\tfloat r = floor(uv.y*4.0 )*4.0 + floor(uv.x*4.0 );\n\t\n\tfloat a = fract(uv.x*4.0);\n\tfloat b = fract(uv.y*4.0);\n#if 1\n                      \/* 0011 = A         *\/\n                      \/* 0101 = B         *\/\n                      \/* ----   --------- *\/\n         if( r< 0.5 ) \/* 0000 = RESET     *\/ c = 0.0;\n\telse if( r< 1.5 ) \/* 0001 = A AND B   *\/ c = a*b;\n\telse if( r< 2.5 ) \/* 0010 = A AND !B  *\/ c = a - a*b;\n\telse if( r< 3.5 ) \/* 0011 = A         *\/ c = a;\n\telse if( r< 4.5 ) \/* 0100 = !A AND B  *\/ c = b - a*b;\n\telse if( r< 5.5 ) \/* 0101 = B         *\/ c = b;\n\telse if( r< 6.5 ) \/* 0110 = A XOR B   *\/ c = a + b - 2.0*a*b;\n\telse if( r< 7.5 ) \/* 0111 = A OR B    *\/ c = a + b - a*b;\n\telse if( r< 8.5 ) \/* 1000 = A NOR B   *\/ c = 1.0 - a - b + a*b;\n\telse if( r< 9.5 ) \/* 1001 = A XNOR B  *\/ c = 1.0 - b - a + 2.0*a*b;\n\telse if( r<10.5 ) \/* 1010 = !B        *\/ c = 1.0 - b;\n\telse if( r<11.5 ) \/* 1011 = !A NAND B *\/ c = 1.0 - b + a*b;\n\telse if( r<12.5 ) \/* 1100 = !A        *\/ c = 1.0 - a;\n\telse if( r<13.5 ) \/* 1101 = A NAND !B *\/ c = 1.0 - a + a*b;\n\telse if( r<14.5 ) \/* 1110 = A NAND B  *\/ c = 1.0 - a*b;\n\telse if( r<15.5 ) \/* 1111 = SET       *\/ c = 1.0;\n#else\n                      \/* 0011 = A         *\/\n                      \/* 0101 = B         *\/\n                      \/* ----   --------- *\/\n         if( r< 0.5 ) \/* 0000 = RESET     *\/ c = bilin( a, b, 0.,0.,0.,0. );\n\telse if( r< 1.5 ) \/* 0001 = A AND B   *\/ c = bilin( a, b, 0.,0.,0.,1. );\n\telse if( r< 2.5 ) \/* 0010 = A AND !B  *\/ c = bilin( a, b, 0.,0.,1.,0. );\n\telse if( r< 3.5 ) \/* 0011 = A         *\/ c = bilin( a, b, 0.,0.,1.,1. );\n\telse if( r< 4.5 ) \/* 0100 = !A AND B  *\/ c = bilin( a, b, 0.,1.,0.,0. );\n\telse if( r< 5.5 ) \/* 0101 = B         *\/ c = bilin( a, b, 0.,1.,0.,1. );\n\telse if( r< 6.5 ) \/* 0110 = A XOR B   *\/ c = bilin( a, b, 0.,1.,1.,0. );\n\telse if( r< 7.5 ) \/* 0111 = A OR B    *\/ c = bilin( a, b, 0.,1.,1.,1. );\n\telse if( r< 8.5 ) \/* 1000 = A NOR B   *\/ c = bilin( a, b, 1.,0.,0.,0. );\n\telse if( r< 9.5 ) \/* 1001 = A XNOR B  *\/ c = bilin( a, b, 1.,0.,0.,1. );\n\telse if( r<10.5 ) \/* 1010 = !B        *\/ c = bilin( a, b, 1.,0.,1.,0. );\n\telse if( r<11.5 ) \/* 1011 = !A NAND B *\/ c = bilin( a, b, 1.,0.,1.,1. );\n\telse if( r<12.5 ) \/* 1100 = !A        *\/ c = bilin( a, b, 1.,1.,0.,0. );\n\telse if( r<13.5 ) \/* 1101 = A NAND !B *\/ c = bilin( a, b, 1.,1.,0.,1. );\n\telse if( r<14.5 ) \/* 1110 = A NAND B  *\/ c = bilin( a, b, 1.,1.,1.,0. );\n\telse if( r<15.5 ) \/* 1111 = SET       *\/ c = bilin( a, b, 1.,1.,1.,1. );\n#endif\t\t\n\t\t\n\tvec3 col = vec3(c);\n\t\t\n\tcol = mix( col, vec3(0.9,0.5,0.3), smoothstep( 0.490, 0.495, abs(a-0.5) ) );\n\tcol = mix( col, vec3(0.9,0.5,0.3), smoothstep( 0.485, 0.490, abs(b-0.5) ) );\n\n\tfragColor = vec4(col,1.0);\n}","name":"","description":"","type":"image"}]}}