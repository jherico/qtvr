{"Shader":{"ver":"0.1","info":{"id":"XdlGzH","date":"1362869245","viewed":5069,"name":"Reprojection","username":"P_Malin","description":"Projecting a 2d texture onto a 3d scene. Click in window to see grid over 3d scene.<br\/>","likes":80,"published":3,"flags":0,"tags":["2d","3d"],"hasliked":0},"renderpass":[{"inputs":[{"id":5,"src":"\/presets\/tex04.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Reprojection - @P_Malin\r\n\r\n#define kMaxIterations 24\r\n\r\n\/\/ Turn up iterations if you enable this\r\n\/\/#define ENABLE_SHADOW\r\n\r\nconst float kPI = 3.141592654;\r\n\r\nstruct C_Ray\r\n{\r\n    vec3 vOrigin;\r\n    vec3 vDir;\r\n};\r\n\r\nvec3 RotateY( const in vec3 vPos, const in float s, const in float c )\r\n{\r\n\tvec3 vResult = vec3( c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);\r\n\r\n\treturn vResult;\r\n}\r\n\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\/\/ Scene Description \r\n\r\nfloat GetDistanceBox(const in vec3 vPos, const in vec3 vDimension)\r\n{\r\n\treturn length(max(abs(vPos)-vDimension,0.0));\r\n}\r\n\r\n\/\/ result is x=scene distance y=material or object id; zw are material specific parameters (maybe uv co-ordinates)\r\nfloat GetDistanceScene( const in vec3 vPos )\r\n{   \r\n\tfloat fResult = 1000.0;\r\n\t\r\n\tfloat fFloorDist = vPos.y + 3.2;\t\r\n\tfResult = min(fResult, fFloorDist);\r\n\t\r\n\t\r\n\tvec3 vBuilding1Pos = vec3(58.8, 0.0, 50.0);\r\n\tconst float fBuilding1Radius = 50.0;\r\n\tvec3 vBuilding1Offset = vBuilding1Pos - vPos;\r\n\tfloat fBuilding1Dist = length(vBuilding1Offset.xz) - fBuilding1Radius;\r\n\t\r\n\tfResult = min(fResult, fBuilding1Dist);\r\n\t\r\n\t\r\n\t\r\n\tvec3 vBuilding2Pos = vec3(60.0, 0.0, 55.0);\r\n\tconst float fBuilding2Radius = 100.0;\r\n\tvec3 vBuilding2Offset = vBuilding2Pos - vPos;\r\n\tfloat fBuilding2Dist = length(vBuilding2Offset.xz) - fBuilding2Radius;\r\n\t\r\n\tfBuilding2Dist = max(vBuilding2Offset.z - 16.0, -fBuilding2Dist); \/\/ back only\r\n\t\r\n\tfResult = min(fResult, fBuilding2Dist);\r\n\r\n\t\r\n\tvec3 vBollardDomain = vPos;\r\n\tvBollardDomain -= vec3(1.0, -2.0, 13.5);\r\n\tvBollardDomain = RotateY(vBollardDomain, sin(0.6), cos(0.6));\r\n\tfloat fBollardDist = GetDistanceBox(vBollardDomain, vec3(0.2, 1.3, 0.2));\r\n\t\t\r\n\tfResult = min(fResult, fBollardDist);\r\n\r\n\t\r\n\tvec3 vFenceDomain = vPos;\r\n\tvFenceDomain -= vec3(-5.5, -2.5, 7.0);\r\n\tvFenceDomain = RotateY(vFenceDomain, sin(1.0), cos(1.0));\r\n\tfloat fFenceDist = GetDistanceBox(vFenceDomain, vec3(0.5, 1.2, 0.2));\r\n\t\t\r\n\tfResult = min(fResult, fFenceDist);\r\n\t\r\n\t\r\n\r\n\tvec3 vCabDomain = vPos;\r\n\tvCabDomain -= vec3(-1.4, -1.5,29.5);\r\n\tvCabDomain = RotateY(vCabDomain, sin(0.01), cos(0.01));\r\n\tfloat fCabDist = GetDistanceBox(vCabDomain, vec3(1.2, 1.5, 3.0));\r\n\t\t\r\n\tfResult = min(fResult, fCabDist);\r\n\t\r\n\t\t\r\n\tvec3 vBusDomain = vPos;\r\n\tvBusDomain -= vec3(-15.25, -2.0, 30.0);\r\n\tvBusDomain = RotateY(vBusDomain, sin(0.3), cos(0.3));\r\n\tfloat fBusDist = GetDistanceBox(vBusDomain, vec3(1.0, 3.0, 3.0));\r\n\t\t\r\n\tfResult = min(fResult, fBusDist);\r\n\t\r\n\t\t\r\n\tvec3 vBusShelter = vPos;\r\n\tvBusShelter -= vec3(7.5, -2.0, 30.0);\r\n\tvBusShelter = RotateY(vBusShelter, sin(0.3), cos(0.3));\r\n\tfloat fBusShelterDist = GetDistanceBox(vBusShelter, vec3(1.0, 5.0, 2.0));\r\n\t\t\r\n\tfResult = min(fResult, fBusShelterDist);\r\n\t\r\n\tvec3 vRailings = vPos;\r\n\tvRailings -= vec3(12.0, -2.0, 18.0);\r\n\tvRailings = RotateY(vRailings, sin(0.3), cos(0.3));\r\n\tfloat fRailings = GetDistanceBox(vRailings, vec3(1.0, 1.0, 2.0));\r\n\t\t\r\n\tfResult = min(fResult, fRailings);\r\n\t\t\r\n\t\r\n\tvec3 vCentralPavement = vPos;\r\n\tvCentralPavement -= vec3(5.3, -3.0, 8.0);\r\n\tvCentralPavement = RotateY(vCentralPavement, sin(0.6), cos(0.6));\r\n\tfloat fCentralPavementDist = GetDistanceBox(vCentralPavement, vec3(0.8, 0.2, 8.0));\r\n\t\t\r\n\tfResult = min(fResult, fCentralPavementDist);\r\n\t\r\n\r\n\t\r\n\treturn fResult;\r\n}\r\n\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\/\/ Raymarching \r\n\r\n\r\n\/\/ This is an excellent resource on ray marching -> http:\/\/www.iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\r\nfloat Raymarch( const in C_Ray ray )\r\n{        \r\n    float fDistance = 0.1;\r\n        \r\n    for(int i=0;i<=kMaxIterations;i++)              \r\n    {\r\n        float fSceneDist = GetDistanceScene( ray.vOrigin + ray.vDir * fDistance );\r\n        \r\n        if((fSceneDist <= 0.01) || (fDistance >= 1000.0))\r\n        {\r\n            break;\r\n        }                        \r\n\r\n        fDistance = fDistance + fSceneDist; \r\n    }\r\n\r\n\tfDistance = min(fDistance, 1000.0);\r\n\t\r\n\treturn fDistance;\r\n}\r\n               \r\n\r\nvoid GetCameraRay( const in vec3 vPos, const in vec3 vForwards, const in vec3 vWorldUp, const in vec2 fragCoord, out C_Ray ray)\r\n{\r\n    vec2 vUV = ( fragCoord.xy \/ iResolution.xy );\r\n    vec2 vViewCoord = vUV * 2.0 - 1.0;\t\r\n\r\n\tvViewCoord.y *= -1.0;\r\n\r\n    ray.vOrigin = vPos;\r\n\r\n    vec3 vRight = normalize(cross(vWorldUp, vForwards));\r\n    vec3 vUp = cross(vRight, vForwards);\r\n        \r\n    ray.vDir = normalize( vRight * vViewCoord.x + vUp * vViewCoord.y + vForwards);    \r\n}\r\n\r\nvoid GetCameraRayLookat( const in vec3 vPos, const in vec3 vInterest, const in vec2 fragCoord, out C_Ray ray)\r\n{\r\n\tvec3 vForwards = normalize(vInterest - vPos);\r\n\tvec3 vUp = vec3(0.0, 1.0, 0.0);\r\n\r\n\tGetCameraRay(vPos, vForwards, vUp, fragCoord, ray);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    C_Ray ray;\r\n\r\n    vec3 vCameraPos = vec3(0.0, 0.0, 0.0);\r\n\t\r\n\tvCameraPos.x += sin(iGlobalTime * 5.0) * 1.5;\r\n\tvCameraPos.z += (sin(iGlobalTime * 3.0) + 1.2) * 3.0;\r\n\t\r\n\tvec3 vCameraIntrest = vec3(0.0, 1.0, 20.0);\r\n\r\n\tGetCameraRayLookat( vCameraPos, vCameraIntrest, fragCoord, ray);\r\n\r\n    float fHitDist = Raymarch(ray);\r\n\tvec3 vHitPos = ray.vOrigin + ray.vDir * fHitDist;\r\n\t\t\r\n\tvec3 vProjPos = vHitPos;\r\n\t\t\r\n\tfloat fProjectionDist = 0.5;\r\n\tvec2 vUV = vec2(((vProjPos.xy) * fProjectionDist) \/ vProjPos.z);\r\n\t\r\n\tvec2 vProjectionOffset = vec2(-0.5, -0.61);\r\n\tvUV += vProjectionOffset;\r\n\t\t\r\n\tvUV.y = 1.0 - vUV.y;\r\n\t\t\r\n\tvec3 vResult = texture2D(iChannel0, vUV).rgb;\r\n\t\t\t\r\n\tif(iMouse.z > 0.0)\r\n\t{\r\n\t\tvec3 vGrid =  step(fract(vHitPos \/ 5.0), vec3(0.9));\r\n\t\tvResult = mix(vec3(1.0, 1.0, 1.0), vResult, vGrid);\r\n\t}\r\n\t\r\n\t#ifdef ENABLE_SHADOW\r\n\tC_Ray shadowRay;\r\n\tshadowRay.vOrigin = vec3(0.0, 0.0, 0.0);\r\n\tshadowRay.vDir = normalize(vHitPos);\r\n\r\n\tfloat fLength = length(vHitPos);\t\r\n\tfloat fShadowDist = Raymarch(shadowRay);\r\n\t\r\n\tvResult *= 0.2 + 0.8 * step(fLength, fShadowDist + 0.1);\r\n\t#endif\r\n\t\r\n\tfragColor = vec4(vResult,1.0);\r\n}\r\n","name":"","description":"","type":"image"}]}}