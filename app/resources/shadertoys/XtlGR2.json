{"Shader":{"ver":"0.1","info":{"id":"XtlGR2","date":"1423366139","viewed":744,"name":"Golden Mean Fractal","username":"cornusammonis","description":"A fractal generated by overlaying lines with distances proportional to powers of the golden mean. The generating function fract(ln(x)\/ln(phi)), x > 0, is zero when x is a power of the golden mean. This is animated by adding a phase offset and multiplier.","likes":4,"published":3,"flags":0,"tags":["fractal"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define PI 3.14159265359\n#define PHI 1.61803398875\n#define LN_PHI 0.48121182506\n#define PI_OVER_FIVE 0.62831853071\n#define FREQ1 0.5\n#define FREQ2 0.2\n\n\/\/ saw\nfloat gen(float x, float o, float s) {\n    return fract(log(abs(x))\/(LN_PHI + s) - o);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tfloat t = FREQ1 * iGlobalTime;\n    float t2 = 1.0 + sin(FREQ2 * iGlobalTime);\n    vec2 scale = vec2(1.0, iResolution.y \/ iResolution.x);\n\tvec2 uv = scale * ((fragCoord.xy \/ iResolution.xy) - 0.5);\n    float sum = 0.0;\n    for (int i = 0; i < 5; i++) {\n\t    float rot = uv.x * sin(PI_OVER_FIVE * float(i)) + uv.y * cos(PI_OVER_FIVE * float(i));\n        sum += gen(rot, t, t2);\n    }\n    vec3 col;\n    if ( mod(floor(sum),2.0) == 0.0 ) {\n       col = vec3(fract(sum));     \n    } else {\n       col = vec3(1.0 - fract(sum));\n    }\n\tfragColor=vec4(col, 1.0);\n}","name":"","description":"","type":"image"}]}}