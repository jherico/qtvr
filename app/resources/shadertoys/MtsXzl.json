{"Shader":{"ver":"0.1","info":{"id":"MtsXzl","date":"1439130293","viewed":909,"name":"Infinite Hermite Rectangles","username":"demofox","description":"Based on https:\/\/www.shadertoy.com\/view\/ltsXzl, but extended to multiple squares.  Each checkerboard square is a cubic hermite rectangle.  Could add lower frequency sine waves to look better maybe.","likes":11,"published":3,"flags":0,"tags":["3d","hermite"],"hasliked":0},"renderpass":[{"inputs":[{"id":24,"src":"\/presets\/cube02_0.jpg","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define SHOW_GRID 1\n#define FUN_REFLECT 0\n\nconst float c_scale = 0.5;\nconst float c_rate = 2.0;\n\n#define FLT_MAX 3.402823466e+38\n\n\/\/=======================================================================================\nfloat CubicHermite (float A, float B, float C, float D, float t)\n{\n\tfloat t2 = t*t;\n    float t3 = t*t*t;\n    float a = -A\/2.0 + (3.0*B)\/2.0 - (3.0*C)\/2.0 + D\/2.0;\n    float b = A - (5.0*B)\/2.0 + 2.0*C - D \/ 2.0;\n    float c = -A\/2.0 + C\/2.0;\n   \tfloat d = B;\n    \n    return a*t3 + b*t2 + c*t + d;\n}\n\n\/\/=======================================================================================\nfloat hash(float n) {\n    return fract(sin(n) * 43758.5453123);\n}\n\n\/\/=======================================================================================\nfloat GetHeightAtTile(vec2 T)\n{\n    float rate = hash(hash(T.x) * hash(T.y))*0.5+0.5;\n    \n    return (sin(iGlobalTime*rate*c_rate) * 0.5 + 0.5) * c_scale;\n}\n\n\/\/=======================================================================================\nfloat HeightAtPos(vec2 P)\n{\n    vec2 tile = floor(P);\n    \n    P = fract(P);\n    \n    float CP0X = CubicHermite(\n        GetHeightAtTile(tile + vec2(-1.0,-1.0)),\n        GetHeightAtTile(tile + vec2(-1.0, 0.0)),\n        GetHeightAtTile(tile + vec2(-1.0, 1.0)),\n        GetHeightAtTile(tile + vec2(-1.0, 2.0)),\n        P.y\n    );\n    \n    float CP1X = CubicHermite(\n        GetHeightAtTile(tile + vec2( 0.0,-1.0)),\n        GetHeightAtTile(tile + vec2( 0.0, 0.0)),\n        GetHeightAtTile(tile + vec2( 0.0, 1.0)),\n        GetHeightAtTile(tile + vec2( 0.0, 2.0)),\n        P.y\n    );    \n    \n    float CP2X = CubicHermite(\n        GetHeightAtTile(tile + vec2( 1.0,-1.0)),\n        GetHeightAtTile(tile + vec2( 1.0, 0.0)),\n        GetHeightAtTile(tile + vec2( 1.0, 1.0)),\n        GetHeightAtTile(tile + vec2( 1.0, 2.0)),\n        P.y\n    );        \n    \n    float CP3X = CubicHermite(\n        GetHeightAtTile(tile + vec2( 2.0,-1.0)),\n        GetHeightAtTile(tile + vec2( 2.0, 0.0)),\n        GetHeightAtTile(tile + vec2( 2.0, 1.0)),\n        GetHeightAtTile(tile + vec2( 2.0, 2.0)),\n        P.y\n    );\n    \n    return CubicHermite(CP0X, CP1X, CP2X, CP3X, P.x);\n}\n\n\/\/=======================================================================================\nvec3 NormalAtPos( vec2 p )\n{\n\tfloat eps = 0.01;\n    vec3 n = vec3( HeightAtPos(vec2(p.x-eps,p.y)) - HeightAtPos(vec2(p.x+eps,p.y)),\n                         2.0*eps,\n                         HeightAtPos(vec2(p.x,p.y-eps)) - HeightAtPos(vec2(p.x,p.y+eps)));\n    return normalize( n );\n}\n\n\/\/=======================================================================================\nfloat RayIntersectSphere (vec4 sphere, in vec3 rayPos, in vec3 rayDir)\n{\n\t\/\/get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    \/\/get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t\/\/exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn -1.0;\n\n\t\/\/calculate discriminant\n\tfloat discr = b * b - c;\n\n\t\/\/a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn -1.0;\n\n\t\/\/ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat collisionTime = -b - sqrt(discr);\n\n\t\/\/if t is negative, ray started inside sphere so clamp t to zero and remember that we hit from the inside\n\tif(collisionTime < 0.0)\n\t\tcollisionTime = -b + sqrt(discr);\n    \n    return collisionTime;\n}\n\n\/\/=======================================================================================\nvec3 DiffuseColor (in vec3 pos)\n{\n    #if SHOW_GRID\n    pos = mod(floor(pos),2.0);\n    return vec3(mod(pos.x + pos.z, 2.0) < 1.0 ? 1.0 : 0.4);\n    #else\n    return vec3(0.1, 0.8, 0.9);\n    #endif\n}\n\n\/\/=======================================================================================\nvec3 ShadePoint (in vec3 pos, in vec3 rayDir, float time, bool fromUnderneath)\n{\n\tvec3 diffuseColor = DiffuseColor(pos);\n\tvec3 reverseLightDir = normalize(vec3(1.0,1.0,-1.0));\n\tvec3 lightColor = vec3(0.95,0.95,0.95);\t\n\tvec3 ambientColor = vec3(0.05,0.05,0.05);\n\n\tvec3 normal = NormalAtPos(pos.xz);\n    normal *= fromUnderneath ? -1.0 : 1.0;\n\n    \/\/ diffuse\n\tvec3 color = diffuseColor * ambientColor;\n\tfloat dp = dot(normal, reverseLightDir);\n\tif(dp > 0.0)\n\t\tcolor += (diffuseColor * dp * lightColor);\n    \n    \/\/ specular\n    vec3 reflection = reflect(reverseLightDir, normal);\n    dp = dot(rayDir, reflection);\n    if (dp > 0.0)\n        color += pow(abs(dp), 15.0) * vec3(0.5);\t\t\n    \n    \/\/ reflection (environment mappping)\n    #if FUN_REFLECT\n    reflection = reflect(rayDir, normalize(normal*vec3(1.0,0.9,1.0)));\n    color += textureCube(iChannel0, reflection).rgb * vec3(0.25,0.0,0.0);    \n    reflection = reflect(rayDir, normalize(normal*vec3(1.0,1.0,1.0)));\n    color += textureCube(iChannel0, reflection).rgb * vec3(0.0,0.25,0.0);   \n    reflection = reflect(rayDir, normalize(normal*vec3(1.0,1.1,1.0)));\n    color += textureCube(iChannel0, reflection).rgb * vec3(0.0,0.0,0.25);                          \n    #else\n    reflection = reflect(rayDir, normal);\n    color += textureCube(iChannel0, reflection).rgb * 0.25;    \n    #endif\n    \n    return color;\n}\n\n\/\/=======================================================================================\nvec3 HandleRay (in vec3 rayPos, in vec3 rayDir, in vec3 pixelColor, out float hitTime)\n{\n\tfloat time = 0.0;\n\tfloat lastHeight = 0.0;\n\tfloat lastY = 0.0;\n\tfloat height;\n\tbool hitFound = false;\n    hitTime = FLT_MAX;\n    bool fromUnderneath = false;\n    \n    vec2 timeMinMax = vec2(0.0, 20.0);\n    \n    time = timeMinMax.x;\n    \n    const int c_numIters = 100;\n    float deltaT = (timeMinMax.y - timeMinMax.x) \/ float(c_numIters);\n    \n    vec3 pos = rayPos + rayDir * time;\n    float firstSign = sign(pos.y - HeightAtPos(pos.xz));\n    \n\tfor (int index = 0; index < c_numIters; ++index)\n\t{\t\t\n\t\tpos = rayPos + rayDir * time;\n        \n        height = HeightAtPos(pos.xz);\n        \n        if (sign(pos.y - height) * firstSign < 0.0)\n        {\n            fromUnderneath = firstSign < 0.0; \n        \thitFound = true;\n\t\t\tbreak;\n        }\n\t\t\n\t\ttime += deltaT;\t\t\n\t\tlastHeight = height;\n\t\tlastY = pos.y;\n    }\n    \n\t\n\tif (hitFound) {\n\t\ttime = time - deltaT + deltaT*(lastHeight-lastY)\/(pos.y-lastY-height+lastHeight);\n\t\tpos = rayPos + rayDir * time;\n\t\tpixelColor = ShadePoint(pos, rayDir, time, fromUnderneath);\n        hitTime = time;\n\t}\n\n\treturn pixelColor;\n}\n\n\/\/=======================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t   \n    \/\/ scrolling camera\n    vec3 cameraOffset = vec3(iGlobalTime, 0.5, iGlobalTime);\n    \n    \/\/----- camera\n    vec2 mouse = iMouse.xy \/ iResolution.xy;\n\n    vec3 cameraAt \t= vec3(0.5,0.5,0.5) + cameraOffset;\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14 + iGlobalTime * 0.25;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.5;\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 5.0;\n    cameraPos += vec3(0.5,0.5,0.5) + cameraOffset;\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y \/ iResolution.x;\n    float cameraDistance\t= 6.0;  \/\/ intuitively backwards!\n\t\n\t\t\n\t\/\/ Objects\n\tvec2 rawPercent = (fragCoord.xy \/ iResolution.xy);\n\tvec2 percent = rawPercent - vec2(0.5,0.5);\n\t\n\tvec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n\t\t\t\t   - (cameraLeft * percent.x * cameraViewWidth)\n\t\t           + (cameraUp * percent.y * cameraViewHeight);\n\tvec3 rayDir = normalize(rayTarget);\n\t\n\t\n    float hitTime = FLT_MAX;\n\tvec3 pixelColor = textureCube(iChannel0, rayDir).rgb;\n    pixelColor = HandleRay(cameraPos, rayDir, pixelColor, hitTime);\n    \n    fragColor = vec4(clamp(pixelColor,0.0,1.0), 1.0);\n}","name":"","description":"","type":"image"}]}}