{"Shader":{"ver":"0.1","info":{"id":"MdsGDM","date":"1372348949","viewed":889,"name":"perlin video transition -test","username":"FabriceNeyret2","description":"use saturated perlin noise for separating channels.","likes":7,"published":3,"flags":0,"tags":["procedural"],"hasliked":0},"renderpass":[{"inputs":[{"id":8,"src":"\/presets\/tex07.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":12,"src":"\/presets\/vid01.webm","ctype":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":29,"src":"\/presets\/vid02.ogv","ctype":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define ANIM true\n#define PI 3.14159\nvec2 FragCoord;\nvec4 FragColor;\n\n\/\/ --- noise functions from https:\/\/www.shadertoy.com\/view\/XslGRr\n\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\/\/ --- End of: Created by inigo quilez --------------------\n\nfloat myfbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p ); p = m*p*2.04;\n    f += 0.0625\/2.*noise( p ); p = m*p*2.03;\n    f += 0.0625\/4.*noise( p );\n    return f;\n}\n\nvec3 noise3( vec3 p )\n{\n\tif (ANIM) p += iGlobalTime;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1345.67,0,45.67));\n    float fz = noise(p+vec3(0,4567.8,-123.4));\n    return vec3(fx,fy,fz);\n}\nvec3 fbm3( vec3 p )\n{\n\tif (ANIM) p += iGlobalTime;\n    float fx = fbm(p);\n    float fy = fbm(p+vec3(1345.67,0,45.67));\n    float fz = fbm(p+vec3(0,4567.8,-123.4));\nreturn vec3(fx,fy,fz);\n}\nvec3 perturb3(vec3 p, float scaleX, float scaleI)\n{\n    scaleX *= 2.;\n\treturn scaleI*scaleX*fbm3(p\/scaleX); \/\/ usually, to be added to p\n}\n\n\/\/ --- sliders and mouse widgets\n\nbool affMouse() \n{\n\tfloat R=5.;\n\tvec2 pix = FragCoord.xy\/iResolution.y;\n\tfloat pt = max(1e-2,1.\/iResolution.y); R*=pt;\n\n\tvec2 ptr = iMouse.xy\/iResolution.y; \n\tvec2 val = iMouse.zw\/iResolution.y; \n\tfloat s=sign(val.x); val = val*s;\n\t\n\t\/\/ current mouse pos\n    float k = dot(ptr-pix,ptr-pix)\/(R*R*.4*.4);\n\t\tif (k<1.) \n\t    { if (k>.8*.8) FragColor = vec4(0.);\n\t\t     else      FragColor = vec4(s,.4,0.,1.); \n\t\t  return true;\n\t\t}\n\t\n\t\/\/ prev mouse pos \n    k = dot(val-pix,val-pix)\/(R*R*.4*.4);\n\t\tif (k<1.) \n\t    { if (k>.8*.8) FragColor = vec4(0.);\n\t\t     else      FragColor = vec4(0.,.2,s,1.); \n\t\t  return true;\n\t\t}\n\t\n\treturn false;\n}\nbool affSlider(vec2 p0, vec2 dp, float v)\n{\n\tfloat R=5.;\n\tvec2 pix = FragCoord.xy\/iResolution.y;\n\tfloat pt = max(1e-2,1.\/iResolution.y); R*=pt;\n\tpix -= p0;\n\n\tfloat dp2 = dot(dp,dp);\n\tfloat x = dot(pix,dp)\/dp2; if ((x<0.)||(x>1.)) return false;\n\tfloat x2=x*x;\n\tfloat y = dot(pix,pix)\/dp2-x2; if (y>R*R) return false;\n\n\tFragColor = vec4(1.,.2,0.,1.); \n\ty = sqrt(y);\n\tif (y<pt) return true;       \/\/ rule\n\tvec2 p = vec2(x-v,y);\n\tif (dot(p,p)<R*R) return true; \/\/ button\n\t\n\treturn false;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    FragCoord=fragCoord;\n\t\/\/ --- events\n\n\tvec2 uv  = fragCoord.xy\/iResolution.y;\n\tvec2 val = iMouse.xy\/iResolution.xy;\n\t\n\tif (affMouse()) return;\n\tif (iMouse.z<=0.) \/\/ auto-tuning if no user tuning\n\t{\n\t\tfloat t = iGlobalTime;\n\t\tval = vec2(.95,.5) + vec2(.04,.3)*vec2(cos(t),sin(t));\n\t}\n    if (affSlider(vec2(.05,.02),vec2(.4,0),val.x)) {fragColor=FragColor; return;}\n    if (affSlider(vec2(.02,.05),vec2(0,.4),val.y)) {fragColor=FragColor; return;} \n\n\t\/\/ --- shaping noise\n\n\tvec3 dir = vec3(0.,0.,1.);\n\tvec3 p = 4.*vec3(uv,0)+iGlobalTime*dir;\n\tfloat x = 1.*myfbm(p);\n\tfloat x1=x, x2=x;\n\t\/\/ shape 2 ou 3 regions separated by noisy borders\n#if 1\n\t\/\/x = sin(8.*PI*(x-.5));\n\tx  = smoothstep(-val.y+val.x,1.-val.y+1.-val.x,x);\n#else\n\tx1 = smoothstep(-val.y+val.x,1.-val.y+1.-val.x,x);\n\tx2 = smoothstep(-.7+val.x,1.-.7+1.-val.x,x);\n\tx = abs(x2-x1);\n#endif\n\t\n\t\/\/ --- texture and color sources\n\tuv  = fragCoord.xy\/iResolution.xy;\n\tuv = mod(uv,vec2(1.,1.));\n\tvec3 T0 = texture2D(iChannel0,uv).rgb;\n    vec3 T1 = texture2D(iChannel1,uv).rgb;\n    vec3 T2 = texture2D(iChannel2,uv).rgb;\n\tvec3 B  = vec3(0.);\n\tvec3 W  = vec3(1.);\n\tvec3 fire = vec3(.6,0.,0.);\n\t\n\t\/\/ --- compositing\n    vec3 v;\n\t\/\/ v = vec3(x); \n\tv = mix(T0,T1,x);\n\t\/\/v = mix(T0,B,x1)+mix(B,T1,x2-x1)+mix(B,T2,x2);\n\tfloat k = (1.-pow(.5+.5*cos(PI*(x-.5)),3.));\n\tvec3 v2;\n\t\/\/ v2 = T2;\n\tv2 = fire;\n\tv = mix(v2,v,k);  \n\t\n\tfragColor = vec4(v,1.0);\n}","name":"","description":"","type":"image"}]}}