{"Shader":{"ver":"0.1","info":{"id":"XdSGDc","date":"1394124728","viewed":2329,"name":"Rainy London","username":"Dave_Hoskins","description":"Thanks to P_Malin for doing the model locations. I've re-used quite a lot of that code to start this, and added some furniture.<br\/>Uses rain sheets that catch the light sources, note the orange rain when near the bollard. Plus distance blurring of texture.","likes":48,"published":3,"flags":64,"tags":["3d","raymarch","rainylondon","soundcloud"],"hasliked":0},"renderpass":[{"inputs":[{"id":5,"src":"\/presets\/tex04.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":166,"src":"https:\/\/soundcloud.com\/j_lofi\/rainy-night-in-london","ctype":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Rainy London\n\/\/ By David Hoskins.\n\n\/\/ Uses parts of 'Reprojection' by P_Malin for modelling.\n\/\/ https:\/\/www.shadertoy.com\/view\/XdlGzH\n\n\n#define NUM_LIGHTS 11\n\nvec4 lightArray[NUM_LIGHTS];\nvec3 lightColours[NUM_LIGHTS];\n\nconst float kPI = 3.141592654;\n\nstruct C_Ray\n{\n    vec3 vOrigin;\n    vec3 vDir;\n};\nC_Ray ray;\n\nvec2 coord;\n\n\/\/----------------------------------------------------------------------------------------\nfloat sMin( float a, float b )\n{\n    float k = 1.5;\n\tfloat h = clamp(0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.-h);\n}\n\n\/\/-----------------------------------------------------------------------------------------\nvec3 RotateY( const in vec3 vPos, const in float ang)\n{\n\tfloat s = sin(ang);\n\tfloat c = cos(ang);\n\tvec3 vResult = vec3( c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);\n\n\treturn vResult;\n}\n\n\/\/-----------------------------------------------------------------------------------------\nfloat Hash(in vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(27.16898, 28.90563))) * 44549.5473453);\n}\n\n\/\/-----------------------------------------------------------------------------------------\nfloat Noise(in vec2 p)\n{\n\tvec2 f;\n\tf = fract(p);\t\t\t\/\/ Separate integer from fractional\n    p = floor(p);\n    f = f*f*(3.0-2.0*f);\t\/\/ Cosine interpolation approximation\n    float res = mix(mix(Hash(p),\n\t\t\t\t\t\tHash(p + vec2(1.0, 0.0)), f.x),\n\t\t\t\t\tmix(Hash(p + vec2(0.0, 1.0)),\n\t\t\t\t\t\tHash(p + vec2(1.0, 1.0)), f.x), f.y);\n    return res;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat RoundBox( vec3 p, vec3 b)\n{\n\treturn length(max(abs(p)-b,0.0))-.5;\n}\n\n\/\/-----------------------------------------------------------------------------------------\nfloat GetDistanceBox(const in vec3 vPos, const in vec3 vDimension)\n{\n\treturn length(max(abs(vPos)-vDimension,0.0));\n}\n\n\/\/-----------------------------------------------------------------------------------------\nfloat MapToScene( const in vec3 vPos )\n{   \n\tfloat fResult = 1000.0;\n\t\n\tfloat fFloorDist = vPos.y + 3.2;\t\n\tfResult = min(fResult, fFloorDist);\n\t\n\tvec3 vBuilding1Pos = vec3(68.8, 0.0, 55.0);\n\tconst float fBuilding1Radius = 58.5;\n\tvec3 vBuilding1Offset = vBuilding1Pos - vPos;\n\tfloat fBuilding1Dist = length(vBuilding1Offset.xz) - fBuilding1Radius;\n\t\n\tfResult = min(fResult, fBuilding1Dist);\n\t\n\tvec3 vBuilding2Pos = vec3(60.0, 0.0, 55.0);\n\tconst float fBuilding2Radius = 100.0;\n\tvec3 vBuilding2Offset = vBuilding2Pos - vPos;\n\tfloat fBuilding2Dist = length(vBuilding2Offset.xz) - fBuilding2Radius;\n\tfBuilding2Dist = max(vBuilding2Offset.z - 16.0, -fBuilding2Dist); \/\/ back only\n\t\n\tfResult = min(fResult, fBuilding2Dist);\n\n\tvec3 vBollardDomain = vPos;\n\tvBollardDomain -= vec3(1.0, -2.0, 14.2);\n\t\/\/vBollardDomain = RotateY(vBollardDomain, 0.6);\n\tfloat fBollardDist = RoundBox(vBollardDomain, vec3(-0.2, .75, -.2));\n\t\t\n\tfResult = min(fResult, fBollardDist);\n\t\n\tvec3 vFenceDomain = vPos;\n\tvFenceDomain -= vec3(-5.5, -2.5, 7.0);\n\tvFenceDomain = RotateY(vFenceDomain, 1.5);\n\tfloat fFenceDist = GetDistanceBox(vFenceDomain, vec3(0.5, 1.2, 0.2));\n\t\t\n\tfResult = min(fResult, fFenceDist);\n\t\n\tvec3 vCabDomain = vPos;\n\tvCabDomain -= vec3(-1.4, -1.55,29.5);\n\tvCabDomain = RotateY(vCabDomain, 0.1);\n\tfloat fCabDist = RoundBox(vCabDomain+vec3(0.0, .85, 0.0), vec3(.8, .54, 2.5));\n\tfResult = min(fResult, fCabDist);\n\tfCabDist = RoundBox(vCabDomain, vec3(.6, 1.2, 1.2));\n\tfResult = sMin(fResult, fCabDist);\n\n\tvec3 vBusDomain = vPos;\n\tvBusDomain -= vec3(-15., 0.0, 29.5);\n\tvBusDomain = RotateY(vBusDomain, 0.35);\n\tfloat fBusDist = RoundBox(vBusDomain, vec3(.55, 1.8, 4.0));\n\t\t\n\tfResult = min(fResult, fBusDist);\n\t\t\n\tvec3 vBusShelter = vPos;\n\tvBusShelter -= vec3(7.5, -2.0, 30.0);\n\tvBusShelter = RotateY(vBusShelter, 0.3);\n\tfloat fBusShelterDist = RoundBox(vBusShelter, vec3(.725, 5.3, 1.7));\n\t\t\n\tfResult = min(fResult, fBusShelterDist);\n\t\n\tvec3 vRailings = vPos;\n\tvRailings -= vec3(15.0, -.55, 18.0);\n\tvRailings = RotateY(vRailings, 0.3);\n\tfloat fRailings = RoundBox(vRailings, vec3(.0, -.1, 7.5));\n\t\t\n\tfResult = min(fResult, fRailings);\n\t\n\tvec3 vCentralPavement = vPos;\n\tvCentralPavement -= vec3(5.3, -3.0, 8.0);\n\tvCentralPavement = RotateY(vCentralPavement, 0.6);\n\tfloat fCentralPavementDist = GetDistanceBox(vCentralPavement, vec3(0.8, 0.2, 8.0));\n\t\t\n\tfResult = min(fResult, fCentralPavementDist);\n\t\n\treturn fResult;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat Raymarch( const in C_Ray ray )\n{        \n    float fDistance = .1;\n    bool hit = false;\n    for(int i=0;i < 50; i++)\n    {\n\t\t\tfloat fSceneDist = MapToScene( ray.vOrigin + ray.vDir * fDistance );\n\t\t\tif(fSceneDist <= 0.01 || fDistance >= 150.0)\n\t\t\t{\n\t\t\t\thit = true;\n                break;\n\t\t\t} \n\n        \tfDistance = fDistance + fSceneDist;\n\t}\n\t\n\treturn fDistance;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 Normal( in vec3 pos )\n{\n\tvec2 eps = vec2( 0.01, 0.0);\n\tvec3 nor = vec3(\n\t    MapToScene(pos+eps.xyy) - MapToScene(pos-eps.xyy),\n\t    MapToScene(pos+eps.yxy) - MapToScene(pos-eps.yxy),\n\t    MapToScene(pos+eps.yyx) - MapToScene(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\n\/\/----------------------------------------------------------------------------------------\nvoid GetCameraRay( const in vec3 vPos, const in vec3 vForwards, const in vec3 vWorldUp, out C_Ray ray)\n{\n    vec2 vUV = coord.xy;\n    vec2 vViewCoord = vUV * 2.0 - 1.0;\t\n\n\tvViewCoord.y *= -1.0;\n\n    ray.vOrigin = vPos;\n\n    vec3 vRight = normalize(cross(vWorldUp, vForwards));\n    vec3 vUp = cross(vRight, vForwards);\n        \n    ray.vDir = normalize( vRight * vViewCoord.x + vUp * vViewCoord.y + vForwards);    \n}\n\n\/\/----------------------------------------------------------------------------------------\nvoid GetCameraRayLookat( const in vec3 vPos, const in vec3 vInterest, out C_Ray ray)\n{\n\tvec3 vForwards = normalize(vInterest - vPos);\n\tvec3 vUp = vec3(0.0, 1.0, 0.0);\n\n\tGetCameraRay(vPos, vForwards, vUp, ray);\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 Render(vec3 vCamPos, vec3 vHitPos, out vec3 normal)\n{\n\tnormal = Normal(vHitPos);\n\t\t\n\tfloat fProjectionDist = .5;\n\tvec2 vUV = vec2(((vHitPos.xy) * fProjectionDist) \/ vHitPos.z);\n\t\n\tvec2 vProjectionOffset = vec2(-0.5, -0.62);\n\tvUV += vProjectionOffset;\n\t\t\n\tvUV.y = 1.0 - vUV.y;\n\t\t\n\tvec3 col = vec3(0.0);\n\tfloat dis = pow(max(vHitPos.z-vCamPos.z-20.0, 0.0), .5) * .4;\n\n\tfor (int y = 0; y < 3; y++)\n\t{\n\t\tfor (int x = 0; x < 3; x++)\n\t\t{\n\t\t\tcol += texture2D(iChannel0, vUV + (vec2(x, y) * dis \/ iChannelResolution[3].xy)).rgb;\n\t\t}\n\t}\n\tcol \/= 9.0;\n\t\n\/\/\tcol = texture2D(iChannel0, vUV).rgb;\n\t\n\tcol *= 3.0 \/ pow(vHitPos.z, .7);\n\n\tvec3 lightCol = vec3(1.0);\n\tfor (int i = 0; i < NUM_LIGHTS; i++)\n\t{\n\t\tcol += pow(max(dot(normalize(lightArray[i].xyz-ray.vOrigin), ray.vDir), 0.0), lightArray[i].w)*.7\n\t\t\t\t\t\t* lightColours[i];\n\t\tvec3 lightDir = lightArray[i].xyz-vHitPos;\n\t\tdis = (dot(lightDir, lightDir));\n\t\tlightDir \/= pow(dis, .3);\n\t\tcol += lightColours[i] * max(dot(normal, lightDir), 0.0) * 2.5\/dis;\n\n\t}\n\treturn min(col, 1.0);\n}\n\n\/\/----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\/\/ Yes, that's right, this is done for EVERY pixel! Haha - *gulp*\n\t\/\/ X, Y, Z, POWER...\n\tlightArray[0]  = vec4(10.5, 10.5, 37., 130.);\t\t\/\/ Right street lamp\n\tlightArray[1]  = vec4(-30.0, 11.5, 40., 150.);\t\t\/\/ Near left Street lamp\n\tlightArray[2]  = vec4(15.1, 2.5, 20., 100.);\t\t\/\/ Large right window\n\tlightArray[3]  = vec4(-12.1, 10.3, 70., 350.);\t\t\/\/ Distant street light\n\tlightArray[4]  = vec4(.95, -1.75, 13.5, 239.);\t\t\/\/ Road light\n\tlightArray[5]  = vec4(-30., 4.7, 31.5, 250.);\t\t\/\/ Underground sign\n\tlightArray[6]  = vec4(-1.7, -1.8, 24.8, 15450.);\t\/\/ Taxi left light\n\tlightArray[7]  = vec4(-.3, -1.8, 25., 15450.);\t\t\/\/ Taxi right light\n\tlightArray[8]  = vec4(-14.0, -1.15, 24.8, 2500.0);\t\/\/ Bus red left\n\tlightArray[9]  = vec4(-12.8, -1.15, 25.3, 2500.0);\t\/\/ Bus red right\n\tlightArray[10] = vec4(-18.9, .5, 55.5, 100.0);\t\t\/\/ Bus headlights\n\t\n\t\/\/ R, G, B...\n\tlightColours[0]  = vec3(.85);\t\t\t\/\/ Right street lamp\n\tlightColours[1]  = vec3(1.3);\t\t\t\/\/ Near left Street lamp\n\tlightColours[2]  = vec3(.8, .8, .5);\t\/\/ Large right window\n\tlightColours[3]  = vec3(1.0);\t\t\t\/\/ Distant street light\n\tlightColours[4]  = vec3(.7, .5, .1);\t\/\/ Road light\n\tlightColours[5]  = vec3(0.5, .8, 1.0);\t\/\/ Underground sign\n\tlightColours[6]  = vec3(.5, .6, .6);\t\/\/ Taxi left light\n\tlightColours[7]  = vec3(.5, .6, .6);\t\/\/ Taxi right light\n\tlightColours[8]  = vec3(.12, 0.0, 0.0);\t\/\/ Bas red left\n\tlightColours[9]  = vec3(.12, 0.0, 0.0);\t\/\/ Bus read right\n\tlightColours[10] = vec3(.5, .5, .4);\t\/\/ Bus headlights\n\t\n    vec3 vCameraPos = vec3(0.0, 0.0, 9.8);\n\tfloat ang = iGlobalTime * .3 + 3.4;\n\tfloat head = pow(abs(sin(ang*8.0)), 1.5) * .15;\n\tvCameraPos += vec3(cos(ang) * 2.5, head,  sin(ang) * 8.5);\n    coord = fragCoord.xy \/ iResolution.xy;\n\t\n\tvec3 vCameraIntrest = vec3(-1.0, head, 25.0);\n\tGetCameraRayLookat( vCameraPos, vCameraIntrest, ray);\n\tvec3 originalRayDir = ray.vDir;\n\n    float fHitDist = Raymarch(ray);\n\tvec3 vHitPos = ray.vOrigin + ray.vDir * fHitDist;\n\t\/\/vec3 vHitPos = vCameraPos + ray.vDir * fHitDist;\n\tvec3 normal;\n\tvec3 col = Render(ray.vOrigin, vHitPos, normal);\n\t\n\tif (normal.y > .3)\n\t{\n\t\tray.vOrigin = vHitPos;\n\t\tray.vDir = reflect(ray.vDir, normal);\n\t\tfloat animate = fract(iGlobalTime * 37.3918754) * 157.0;\n\t\tray.vDir += vec3(Noise(vHitPos.xz * 37.0 + animate)-.5, 0.0,\n\t\t\t\t\t\t Noise(vHitPos.xz * 37.0 + animate)-.5) * .1;\n\t\tray.vDir = normalize(ray.vDir);\n\t\t\n\t    fHitDist = Raymarch(ray);\n\t\t\n\t\tvec3 refPos = ray.vOrigin + ray.vDir * fHitDist;\n\t\tfloat n = (Noise(vHitPos.xz*4.0) + Noise(vHitPos.xz)) * .5;\n\t\tn = pow(n, .3) \/ ( 1.5 + fHitDist * .01);\n\t\tfloat amount = smoothstep(0.3, 1.0, max(normal.y, 0.0));\n\t\tcol = mix(col, Render(ray.vOrigin, refPos, normal), n * amount);\n\t}\n\t\n\t\/\/ Ten layers of rain sheets...\n\tvec2 q = fragCoord.xy\/iResolution.xy;\n\tfloat dis = 1.;\n\tfor (int i = 0; i < 12; i++)\n\t{\n\t\tvec3 plane = vCameraPos + originalRayDir * dis;\n\t\t\/\/plane.z -= (texture2D(iChannel3, q*iGlobalTime).x*3.5);\n\t\tif (plane.z < vHitPos.z)\n\t\t{\n\t\t\tfloat f = pow(dis, .45)+.25;\n\n\t\t\tvec2 st =  f * (q * vec2(1.5, .05)+vec2(-iGlobalTime*.1+q.y*.5, iGlobalTime*.12));\n\t\t\tf = (texture2D(iChannel3, st * .5, -99.0).x + texture2D(iChannel3, st*.284, -99.0).y);\n\t\t\tf = clamp(pow(abs(f)*.5, 29.0) * 140.0, 0.00, q.y*.4+.05);\n\n\t\t\tvec3 bri = vec3(.25);\n\t\t\tfor (int t = 0; t < NUM_LIGHTS; t++)\n\t\t\t{\n\t\t\t\tvec3 v3 = lightArray[t].xyz - plane.xyz;\n\t\t\t\tfloat l = dot(v3, v3);\n\t\t\t\tl = max(3.0-(l*l * .02), 0.0);\n\t\t\t\tbri += l * lightColours[t];\n\t\t\t\t\n\t\t\t}\n\t\t\tcol += bri*f;\n\t\t}\n\t\tdis += 3.5;\n\t}\n\tcol = clamp(col, 0.0, 1.0);\n\t\t\t\n\tif(iMouse.z > 0.0)\n\t{\n\t\tvec3 vGrid =  step(fract(vHitPos \/ 2.0), vec3(0.9));\n\t\tcol = mix(vec3(1.0, 1.0, 1.0), col, vGrid);\n\t}\n\tcol = mix(texture2D(iChannel0, vec2(q.x, 1.0-q.y)).xyz, col, smoothstep(2.25, 4.0, iGlobalTime));\n\t\/\/col = pow(col, vec3(1.1));\n\t\n\tfragColor = vec4(col, 1.0);\n}\n\t","name":"","description":"","type":"image"}]}}