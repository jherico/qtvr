{"Shader":{"ver":"0.1","info":{"id":"Xt2XDc","date":"1447055146","viewed":448,"name":"Landscape shadow mapping","username":"eliemichel","description":"This is a simulation of sunlight casting on a landscape.<br\/>Mouse X -> Azimut<br\/>Mouse Y -> Sun direction","likes":0,"published":3,"flags":0,"tags":["landscape","sunlight","shaddowmapping"],"hasliked":0},"renderpass":[{"inputs":[{"id":4,"src":"\/presets\/tex03.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Landscape Shadow mapping\n\/\/ License CC 3.0 - Copyright \u00c9lie Michel - 2015\n\/\/ https:\/\/www.shadertoy.com\/view\/Xt2XDc\n\n\/\/ CAUTION: This is still a wip\n\n\/\/ Some code from:\n\/\/ Mountains. By David Hoskins - 2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ https:\/\/www.shadertoy.com\/view\/4slGD4\n\n\nfloat treeLine = 0.0;\nfloat treeCol = 0.0;\n\n\nvec3 sunLight  = normalize( vec3(  0.4, 0.4,  0.48 ) );\nvec3 sunColour = vec3(1.0, .9, .83);\nfloat specular = 0.0;\nvec3 cameraPos;\nfloat ambient;\nvec2 add = vec2(1.0, 0.0);\n#define MOD2 vec2(3.07965, 7.4235)\n#define MOD3 vec3(3.07965, 7.1235, 4.998784)\n\n\/\/ This peturbs the fractal positions for each iteration down...\n\/\/ Helps make nice twisted landscapes...\nconst mat2 rotate2D = mat2(1.3623, 1.7531, -1.7131, 1.4623);\n\n\/\/ Alternative rotation:-\n\/\/ const mat2 rotate2D = mat2(1.2323, 1.999231, -1.999231, 1.22);\n\n\n\/\/  1 out, 2 in...\nfloat Hash12(vec2 p)\n{\n\tp  = fract(p \/ MOD2);\n    p += dot(p.xy, p.yx+19.19);\n    return fract(p.x * p.y);\n}\nvec2 Hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) \/ MOD3);\n    p3 += dot(p3.zxy, p3.yxz+19.19);\n    return fract(vec2(p3.x * p3.y, p3.z*p3.x));\n}\n\n\nfloat Noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    float res = mix(mix( Hash12(p),          Hash12(p + add.xy),f.x),\n                    mix( Hash12(p + add.yx), Hash12(p + add.xx),f.x),f.y);\n    return res;\n}\n\nvec2 Noise2( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y * 57.0;\n   vec2 res = mix(mix( Hash22(p),          Hash22(p + add.xy),f.x),\n                  mix( Hash22(p + add.yx), Hash22(p + add.xx),f.x),f.y);\n    return res;\n}\n\n\/\/--------------------------------------------------------------------------\nfloat Trees(vec2 p)\n{\n\t\n \t\/\/return (texture2D(iChannel1,0.04*p).x * treeLine);\n    return Noise(p*13.0)*treeLine;\n}\n\n\n\/\/--------------------------------------------------------------------------\n\/\/ Low def version for ray-marching through the height field...\n\/\/ Thanks to IQ for all the noise stuff...\n\nfloat terrain2( in vec2 p)\n{\n\tvec2 pos = p*0.05;\n\tfloat w = (Noise(pos*.25)*0.75+.15);\n\tw = 66.0 * w * w;\n\tvec2 dxy = vec2(0.0, 0.0);\n\tfloat f = .0;\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tf += w * Noise(pos);\n\t\tw = -w * 0.4;\t\/\/...Flip negative and positive for variation\n\t\tpos = rotate2D * pos;\n\t}\n\tfloat ff = Noise(pos*.002);\n\t\n\tf += pow(abs(ff), 5.0)*275.-5.0;\n\treturn f;\n}\n\n\nfloat dist( in vec2 a, in vec2 b ) {\n    float dx = a.x - b.x;\n    float dy = a.y - b.y;\n    return sqrt(dx * dx + dy * dy);\n}\n\nfloat terrain( in vec2 p ) {\n    float h = 0.0;\n\th += texture2D(iChannel0, p\/10.0).r*0.1;\n    h += texture2D(iChannel0, p\/100.0).g*0.3;\n    h += texture2D(iChannel0, p\/1000.0).b*0.6;\n    \n    float d = dist(p, vec2(0.5, 0.3));\n\tfloat m = 1.0 \/ (1.0 + exp(100.0 * max(0.0, d - 0.1)));\n    h = h * 0.9 + pow(m, 2.0) * 2.0;\n        \n    return h;\n}\n\nfloat map( in vec3 p )\n{\n\tfloat h = terrain2(p.xz);\n    return p.y - h;\n}\n\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n    float h = 1.0;\n    float t = 1.0;\n    float alpha = 0.9999;\n\tfor( int i=0; i<256; i++ )\n\t{\n\t\tif( h<0.1 || t>4000.0 ) break;\n\t\tfloat dt = alpha*h + (1.0 - alpha)*t;\n        t += dt * 0.1;\n\t\th = map( ro + t*rd );\n\t}\n\n\tif( h>1.0 ) t = -1.0;\n\treturn t;\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<128; i++ )\n\t{\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h\/t );\n        t += h;\n        if (t >= maxt) {\n            break;\n        }\n\t}\n    return res;\n}\n\n\nvec3 camPath( float time )\n{\n    vec2 p = 600.0*vec2( cos(1.4+0.37*time), \n                         cos(3.2+0.31*time) );\n\n\treturn vec3( p.x, 0.0, p.y );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 xy = -1.0 + 2.0*fragCoord.xy \/ iResolution.xy;\n\tvec2 s = xy*vec2(1.75,1.0);\n\n\t\n    float time = iGlobalTime*.15 + 4.0*iMouse.x\/iResolution.x;\n\n\tvec3 light1 = normalize( vec3(  0.4, 0.22,  0.6 ) );\n\n\tvec3 ro = camPath( iGlobalTime*.15 );\n\tvec3 ta = camPath( iGlobalTime*.15 + 3.0 );\n    ro.y = map( ro ) + 200.0;\n\tta.y = ro.y - 50.0;\n    ro = vec3(-200.0, 200.0, -200.0);\n    ta = vec3(0.0, 0.0, 0.0);\n\n\tfloat cr = 0.0;\/\/*cos(0.1*time);\n\tvec3  cw = normalize(ta-ro);\n\tvec3  cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3  cu = normalize( cross(cw,cp) );\n\tvec3  cv = normalize( cross(cu,cw) );\n\tvec3  rd = normalize( s.x*cu + s.y*cv + 1.5*cw );\n\n\tfloat sundot = clamp(dot(rd,light1),0.0,1.0);\n\tvec3 col = vec3(0.0);\n    float t = intersect( ro, rd );\n    \n    \/\/col = vec3(0.85,.95,1.0)*(1.0-0.5*rd.y);\n\t\/\/col += 0.25*vec3(1.0,0.8,0.4)*pow( sundot,12.0 );\n    \n    \/\/s += vec2(1.0);\n    \/\/s = fragCoord.xy\/iResolution.x;\n\t\n\tif( t>=0.0 )\n\t{\n\t\tvec3 pos = ro + t*rd;\n        col = vec3(pow(0.1 + pos.y \/ 150.0, 0.5));\n        \n        float theta = iMouse.y\/iResolution.y * 2.0 * 3.1415;\n        float azimuth = exp(iMouse.x\/iResolution.x * 15.0 - 15.0) * 100.0;\n        light1 = normalize(vec3(cos(theta), azimuth, sin(theta)));\n        t = softshadow(pos, light1, 20.0, 400.0, 100.0);\n        col.rg = col.rg * 0.0 + vec2(t) * 0.9;\n    }\n    \n    \/\/col.r = pow(terrain(s)*2.0, 0.5);\n    \n\tfragColor=vec4(col,1.0);\n}","name":"","description":"","type":"image"}]}}