{"Shader":{"ver":"0.1","info":{"id":"4sB3zz","date":"1382440855","viewed":1199,"name":"Plotting Functions","username":"hornet","description":"Three ways to plot a highly oscillating function<br\/>- multisampling (xy)<br\/>- weighing by value-distance (y)<br\/>- na\u00efve single sample of value<br\/><br\/>Originally inspired by http:\/\/blog.hvidtfeldts.net\/index.php\/2011\/07\/plotting-high-frequency-functions-using-a-gpu\/","likes":11,"published":3,"flags":0,"tags":["graph","plot"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#ifdef GL_ES\nprecision highp float;\n#endif\n \n \nfloat aspect = iResolution.x \/ iResolution.y;\n \nfloat function( float x ) {\n  return sin(x*x*x)*sin(x);\n\/\/  return sin(x*x*x)*sin(x) + 0.1*sin(x*x);\n\/\/  return sin(x);\n}\n \n\/\/note: does one sample per x, thresholds on distance in y\nfloat discreteEval( vec2 uv ) {\n  const float threshold = 0.015;\n  float x = uv.x;\n  float fx = function( x );\n  float dist = abs( uv.y - fx );\n  float hit = step( dist, threshold );\n  return hit;\n}\n \n\/\/note: samples graph by checking multiple samples being above \/ below function\n\/\/original from http:\/\/blog.hvidtfeldts.net\/index.php\/2011\/07\/plotting-high-frequency-functions-using-a-gpu\/\nfloat stochEval( vec2 uv ) {\n  const int samples = 255; \/\/note: on AMD requires 255+ samples, should be ~50\n  const float fsamples = float(samples);\n  vec2 maxdist = 0.075 * vec2( aspect, 1.0 );\n  vec2 stepsize = maxdist \/ vec2(samples);\n  float count = 0.0;\n  vec2 initial_offset = - 0.5 * fsamples * stepsize;\n  uv += initial_offset;\n  for ( int ii = 0; ii<samples; ii++ ) {\n    float i = float(ii);\n    float fx = function( uv.x + i*stepsize.x );\n    for ( int jj = 0; jj<samples; jj++ ) {\n      float j = float(jj);\n      float diff =  fx - float(uv.y + j*stepsize.y);\n      count = count + step(0.0, diff) * 2.0 - 1.0;\n    }\n  }\n  return 1.0 - abs( count ) \/ float(samples*samples);\n}\n \n\/\/note: averages distances over multiple samples along x, result is identical to superEval\nfloat distAvgEval( vec2 uv ) {\n  const int samples = 55;\n  const float fsamples = float(samples);\n  vec2 maxdist = 0.075 * vec2( aspect, 1.0 );\n  vec2 halfmaxdist = 0.5 * maxdist;\n  float stepsize = maxdist.x \/ fsamples;\n  float initial_offset_x = -0.5*fsamples * stepsize;\n  uv.x += initial_offset_x;\n  float hit = 0.0;\n  for( int i=0; i<samples; ++i ) {\n    float x = uv.x + stepsize * float(i);\n    float y = uv.y;\n    float fx = function( x );\n    float dist = ( y - fx );\n    float vt = clamp( dist \/ halfmaxdist.y -1.0, -1.0, 1.0 );\n    hit += vt;\n  }\n  return 1.0 - abs(hit) \/ fsamples;\n}\n \n\/\/note: does multiple thresholded samples\nfloat proxyEval( vec2 uv ) {\n  const int samples = 255; \/\/note: on AMD requires 255+ samples, should be ~50\n  const float fsamples = float(samples);\n  vec2 maxdist = vec2(0.05) * vec2( aspect, 1.0 );\n  vec2 halfmaxdist = vec2(0.5) * maxdist;\n  float stepsize = maxdist.x \/ fsamples;\n  float initial_offset_x = -0.5 * fsamples * stepsize;\n  uv.x += initial_offset_x;\n  float hit = 0.0;\n  for( int i=0; i<samples; ++i ) {\n    float x = uv.x + stepsize * float(i);\n    float y = uv.y;\n    float fx = function( x );\n    float dist = abs( y - fx );\n    hit += step( dist, halfmaxdist.y );\n  }\n  const float arbitraryFactor = 3.5; \/\/note: to increase intensity\n  const float arbitraryExp = 0.95;\n  return arbitraryFactor * pow( hit \/ fsamples, arbitraryExp );\n}\n \n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv_norm = fragCoord.xy \/ iResolution.xy;\n\tvec4 dim = vec4( -2.0 + sin(iGlobalTime), 12.0 + sin(iGlobalTime), -3.0, 3.0 );\n\tuv_norm = (uv_norm ) * ( dim.yw - dim.xz ) + dim.xz;\n \n\t\/\/float hitStoch = stochEval( uv_norm - vec2(0,2) );\n\tfloat hitProximity = proxyEval( uv_norm - vec2(0,2) );\n\tfloat hitDistAvgStoch = distAvgEval( uv_norm - vec2(0,0) );\n\tfloat hitDiscr = discreteEval( uv_norm  + vec2(0,2) );\n \n\tvec3 g0 = vec3(0.0,0.8,0.2) * hitProximity;\n\tvec3 g1 = vec3(1.0,0.0,0.0) * hitDistAvgStoch;\t\n\tvec3 g2 = vec3(0.0,0.5,1.0) * hitDiscr;\n\t\n\tfragColor = vec4( g0+g1+g2, 1.0 );\n}\n","name":"","description":"","type":"image"}]}}