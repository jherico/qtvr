{"Shader":{"ver":"0.1","info":{"id":"Xt2XzW","date":"1442017330","viewed":871,"name":"Beenox goes BlackOps 3","username":"fungos","description":"my first shader toying, had nothing to do and wanted to try distance fields. still need improve this a lot, mostly  reflection and bo3 logo material (maybe some fire), suggestions? <img src=\"\/img\/emoticonHappy.png\"\/><br\/><br\/>Some machines can't compile the shader, help someone?","likes":6,"published":3,"flags":0,"tags":["logo","distance","geometry","beenox","blackops3","cod"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define A 3.545\n#define B 1.15\n#define M smoothstep\n\n\/\/ rotate on axis Z\nvec3 Z(vec3 v, float a)\n{\n    vec3 vo = v; float c = cos(a); float s = sin(a);\n    v.x = c * vo.x - s * vo.y;\n    v.y = s * vo.x + c * vo.y;\n    return v;\n}\n\n\/\/ Rotate on axis Y\nvec3 Y(vec3 v, float a)\n{\n    vec3 vo = v; float c = cos(a); float s = sin(a);\n    v.x = c * vo.x - s * vo.z;\n    v.z = s * vo.x + c * vo.z;\n    return v;\n}\n\n\/\/ Torus82\nfloat T(vec3 p, vec2 t)\n{\n    vec2 q = vec2(sqrt(p.x * p.x + p.y * p.y) - t.x, p.z);\n    q = q*q; q = q*q; q = q*q;\n    return pow(q.x + q.y, 1. \/ 8.) - t.y;\n}\n\n\/\/ Gear\nfloat G(vec3 p, float a, float r)\n{\n    float d = 1.;\n    for (int i = 0; i < 6; i++)\n    {\n        vec3 q = abs(Z(p, a) - vec3(.0, r + .25, .0));\n        d = min(d, max(q.z - .3, max((q.x * .6 + q.y * .7), q.y) - .25));\n        a += 1.03;\n    }\n    \n    return max(-d, T(p, vec2(r, .1)));\n}\n\n\/\/ sdBox\nfloat X(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), .0) + length(max(d, .0));\n}\n\n\/\/ sdHexPrism\nfloat H(vec3 p, vec2 h)\n{\n    vec3 q = abs(p);\n    return max(q.z - h.y, max((q.x + q.y * .3), q.y) - h.x);\n}\n\n\/\/ smin\nfloat S(float a, float b, float k)\n{\n    float h = clamp(.5 + .5 * (b - a) \/ k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\n\/\/ Beenox\nfloat BX(float t, vec3 p, float f)\n{\n    float s = t*t;\n    if (t > A) s \/= 2.;\n    p = Y(p, s);\n    \n    float a = G(p, .6, f * .5);\n    float b = length(p) - f * .33;\n    return min(b, a);\n}\n\n\/\/ Black Ops 3\nfloat BO(vec3 p, float x, float t)\n{\n    vec2 z = vec2(.12, .15);\n    vec3 w = vec3(.12, z);\n    \n    \/\/ 1\n    float a = X(p - vec3(x, .0, .0), vec3(.14, .6, .15));\n    float b = X(p - vec3(x + .1, .48, .0), w);\n    float c = H(Z(p - vec3(x + .065, .32,  .0), .8), z);\n    float d = X(p - vec3(x + .1, -.49, .0), vec3(.12, .11, .15));\n    float e = H(Z(p - vec3(x + .065, -.335, .0), -.75), z);\n    a = min(a, min(e, min(d, min(c, b))));\n\n    \/\/ 2\n    c = mix(.0, .15, M(0., 4.5, t));\n    d = mix(.0, .2, M(.7, .8, t));\n    b = X(p - vec3(.0, .0, .0), vec3(d, .6, c));\n\n    \/\/ 3\n    c = X(p - vec3(-x, .0, .0), vec3(.13, .6, .15));\n    d = X(p - vec3(-x - .1, .48, .0), w);\n    e = H(Z(p - vec3(-x - .065, .32, .0), -.8), z);\n    float f = X(p - vec3(-x - .1,-.48, .0), vec3(.12, .12, .15));\n    float g = H(Z(p - vec3(-x - .065, -.335, .0), .75), z);\n    c = min(c, min(g, min(f, min(e, d))));\n    \n    return min(c, min(b, a));\n}\n\nfloat map(float t, vec3 p)\n{\n    float x = 0.;\n    float y = 0.;\n\tfloat d = 0.;\n    if (t < A + B)\n\t{\n        d = BX(t, p, 1.);\n\t}\n    else if (t < 5.)\n\t{\n        d = BX(A + B, p, 1.);\n\t}\n    else if (t < 7.)\n    {\n        x = BX(A + B, p, M(1.1, 0., t - 5.));\n        y = X(p, vec3(.15, .6 * M(0., 1., t - 5. + .4), .15));\n        d = S(y, x, .1);\n    }\n    else\n    {\n        t -= 7.;\n        x = .2 * pow(M(.0, 1., t), .5);\n        y = .25 * pow(M(1.2, 3., t), .5);\n        d = BO(p, x + y, t);\n    }\n\treturn d;\n}\n\n\/\/ plane - intersection with a predefined plane\nvec3 P(vec3 p, vec3 d) \n{\n    vec3 n = vec3(0., 1., 0.);\n    float f = dot(-n * .8 - p, n) \/ dot(n, d);\n    return p + d * f;\n}\n\n\/\/ Material used for the infinite plane\nvec2 MAT(vec2 uv)\n{\n    vec2 uv2 = mod(uv, vec2(2.)) - mod(uv, vec2(1.));\n    float d = uv2.x + uv2.y; \n    d = pow(d - 1., 2.) * .4;\n    \n    float s = d;\n    d += s * .2;\n\n    \/\/d - diffuse, s - specular\n    return vec2(d, s * s * .5 + .1);\n}\n\n\/\/ render background layer used for reflection\nvec3 BG(vec3 p, vec3 d, vec3 l)\n{\n    \/\/ plane normal\n    vec3 n = vec3(0., 1., 0.);\n    \n    \/\/ diffuse lighting for the plane\n    float df = dot(n, l) * .5 + .5; \n    \n    \/\/ to blend the plane with the sky\n    float a = max(0., dot(d, -n)); \/\/ alpha - this coefficient is used\n    \n    \/\/ get the floor material\n    vec2 m = MAT(P(p, d).xz); \/\/ x = diffuse coefficient, y = specular coefficient\n    \n    \/\/ atmosphere\n    vec3 at = vec3(.3, .4, .7) * (1. - abs(d.y)) * 1.5;\n\n    \/\/ calculate the planes color\n    vec3 c = m.x * vec3(.4) * df + (m.y * .7) * (at * .2);\n    \n    \/\/ reduce fog\n    a = pow(a, .4);\n    \n    \/\/ mix the plane with the sky\n    return mix(at, c, a);\n}\n\n\/\/ Normal\nvec3 N(float t, vec3 p, float e)\n{\n\tfloat d = map(t, p);\n\treturn normalize(\n        vec3(\n            map(t, p + vec3(e, 0, 0)) - d,\n            map(t, p + vec3(0, e, 0)) - d,\n            map(t, p + vec3(0, 0, e)) - d\n        )\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = 0.;\n    if (iResolution.x <= 400.0) t = mod(iGlobalTime - 6.455, 15.);\n    else t = mod(iGlobalTime, 15.);\n    vec2 uv = fragCoord.xy \/ iResolution.xy - .5;\n    uv.x *= iResolution.x \/ iResolution.y; \/\/fix aspect ratio\n    if (iResolution.y < 200.0) t = A;\n    \n    \/\/ ray position\n    vec3 p = vec3(0., 0., 2.1); \n    \n    \/\/ ray direction\n    vec3 d = normalize(Y(vec3(uv, 1.), 3.14159));\n    \n    \/\/ light\n    vec3 l = vec3(-.5, 1.2, .5);\n    \n    \/\/ background\n    \/\/vec3 c = vec3(0.);\n    vec3 c = BG(p, d, l);\n\n    \/\/ raymarching\n    float di = 0.;\n    for (int i = 0; i < 75; i++)\n    {\n        \/\/ scene\n        di = map(t, p);\n        p += d * di * .4;\n\n        \/\/ too far away from the object or close enough, stop\n        if (di > 5. || di < .03) \n            break;\n    }\n\n    if (di < .03)\n    {\n        vec3 n = N(t, p, .002);\n\n        \/\/ a bit more wierd diffuse lighting, but looks great\n        float diffuse = dot(l, n) * .1 + .5;\n        diffuse = pow(diffuse, 1.5);\n\n        \/\/ object color\n        c = mix(vec3(.4, .4, 1.4), vec3(.1), M(B, 7., t));\n\n        \/\/ reflection\n        c = mix(c * diffuse, BG(p, reflect(d, n), l), (1.0 + dot(d, n)) * .6 + .2);\n\n        \/\/ self occlusion\n        c *= map(t, p + n) * .5 + .5;\n    }    \n    \n    \/\/ fade in\n    c = mix(c, vec3(0.), M(3., 0., t));\n\n    \/\/ fade out\n    c = mix(c, vec3(0.), M(14., 15., t)); \n    \n    fragColor = vec4(c, 1.);\n}","name":"","description":"","type":"image"}]}}