{"Shader":{"ver":"0.1","info":{"id":"4slGRH","date":"1362565218","viewed":1596,"name":"Primes","username":"iq","description":"Computes pr-ime numbers. The quadratic patterns (vertical lines in this case) of Euler can be clearly seen. Checks are done by following the sequence {2, 4, 2, 4, 6, 2, 6, 4} which skips multiples of 2, 3 and 5.","likes":9,"published":3,"flags":0,"tags":["2d","mathematics"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Info on prime hunting: http:\/\/www.iquilezles.org\/blog\/?p=1558\nfloat isPrime( float x )\n{\n\tif( x==1.0 ) return 0.0;\n\tif( x==2.0 ) return 1.0;\n\tif( x==3.0 ) return 1.0;\n\tif( x==5.0 ) return 1.0;\n\tif( x==7.0 ) return 1.0;\n\t\n\tif( mod(x,2.0)==0.0 ) return 0.0;\n\tif( mod(x,3.0)==0.0 ) return 0.0;\n\tif( mod(x,5.0)==0.0 ) return 0.0;\n\n\tfloat y = 7.0;\n\tfor( int i=0; i<200; i++ ) \/\/ count up to 6000\n\t{\n\t\tif( mod(x,y)==0.0 )  return 0.0;\n\t\ty += 4.0; if( y>=x ) return 1.0;\n\t\tif( mod(x,y)==0.0 )  return 0.0;\n\t\ty += 2.0; if( y>=x ) return 1.0;\n\t\tif( mod(x,y)==0.0 )  return 0.0;\n\t\ty += 4.0; if( y>=x ) return 1.0;\n\t\tif( mod(x,y)==0.0 )  return 0.0;\n\t\ty += 2.0; if( y>=x ) return 1.0;\n\t\tif( mod(x,y)==0.0 )  return 0.0;\n\t\ty += 4.0; if( y>=x ) return 1.0;\n\t\tif( mod(x,y)==0.0 )  return 0.0;\n\t\ty += 6.0; if( y>=x ) return 1.0;\n\t\tif( mod(x,y)==0.0 )  return 0.0;\n\t\ty += 2.0; if( y>=x ) return 1.0;\n\t\tif( mod(x,y)==0.0 )  return 0.0;\n\t\ty += 6.0; if( y>=x ) return 1.0;\n        \n        \n        \n        \/\/ speeds up, slows down, or crashes your compiler, \n        \/\/ depending on your GLSL implementation:\n        \n        \/\/if( (y*y) > x ) break; \n\t}\n\t\n\treturn 1.0;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat s = 0.5 + 0.5*cos(6.2831*iGlobalTime\/10.0);\n\ts = 0.1 + 0.9*s;\n\tfloat xres = s*iResolution.x;\n\tvec2  uv   = s*fragCoord.xy;\n\n\tvec3 col = vec3(0.0);\n\t\n\tfloat y = 1.0 + floor(uv.y);\n\tfloat o = floor(xres\/2.0 - uv.x);\n\tif( abs(o)<y )\n\t{\n\t    float n = y*y-2.0*y + 2.0 - o  + y -1.0;\n\t    float f = isPrime( n );\n\t    col = vec3( f*0.25,f,0.0);\n\t}\n\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}