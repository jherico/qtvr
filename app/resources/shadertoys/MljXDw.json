{"Shader":{"ver":"0.1","info":{"id":"MljXDw","date":"1444317396","viewed":2543,"name":"Cloudy spikeball","username":"Duke","description":"This technique was used in \"Code Is My Pron\" demo http:\/\/www.pouet.net\/prod.php?which=56866<br\/>Ported it from http:\/\/glslsandbox.com\/e#1802.0 with some modifications.","likes":57,"published":3,"flags":0,"tags":["volume","cloud","pouet","ball"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ port from http:\/\/glslsandbox.com\/e#1802.0 with some modifications\n\/\/--------------\n\/\/ Posted by las\n\/\/ http:\/\/www.pouet.net\/topic.php?which=7920&page=29&x=14&y=9\n\n#define SCATTERING\n\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n#define hsv(h,s,v) mix(vec3(1.), clamp((abs(fract(h+vec3(3., 2., 1.)\/3.)*6.-3.)-1.), 0., 1.), s)*v\n\n\n\/* original noise\nfloat pn(vec3 p) {\n   vec3 i = floor(p);\n   vec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n   vec3 f = cos((p-i)*pi)*(-.5) + .5;\n   a = mix(sin(cos(a)*a), sin(cos(1.+a)*(1.+a)), f.x);\n   a.xy = mix(a.xz, a.yw, f.y);\n   return mix(a.x, a.y, f.z);\n}\n*\/\n\n\/\/ iq's noise\nfloat pn( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D( iChannel0, (uv+ 0.5)\/256.0, -100.0 ).yx;\n\treturn -1.0+2.4*mix( rg.x, rg.y, f.z );\n}\n\n\nfloat fpn(vec3 p) {\n   return pn(p*.06125)*.5 + pn(p*.125)*.25 + pn(p*.25)*.125;\n}\n\n\/\/vec3 n1 = vec3(1.000,0.000,0.000);\n\/\/vec3 n2 = vec3(0.000,1.000,0.000);\n\/\/vec3 n3 = vec3(0.000,0.000,1.000);\nvec3 n4 = vec3(0.577,0.577,0.577);\nvec3 n5 = vec3(-0.577,0.577,0.577);\nvec3 n6 = vec3(0.577,-0.577,0.577);\nvec3 n7 = vec3(0.577,0.577,-0.577);\nvec3 n8 = vec3(0.000,0.357,0.934);\nvec3 n9 = vec3(0.000,-0.357,0.934);\nvec3 n10 = vec3(0.934,0.000,0.357);\nvec3 n11 = vec3(-0.934,0.000,0.357);\nvec3 n12 = vec3(0.357,0.934,0.000);\nvec3 n13 = vec3(-0.357,0.934,0.000);\nvec3 n14 = vec3(0.000,0.851,0.526);\nvec3 n15 = vec3(0.000,-0.851,0.526);\nvec3 n16 = vec3(0.526,0.000,0.851);\nvec3 n17 = vec3(-0.526,0.000,0.851);\nvec3 n18 = vec3(0.851,0.526,0.000);\nvec3 n19 = vec3(-0.851,0.526,0.000);\n\nfloat spikeball(vec3 p) {\n   vec3 q=p;\n   p = normalize(p);\n   vec4 b = max(max(max(\n      abs(vec4(dot(p,n16), dot(p,n17),dot(p, n18), dot(p,n19))),\n      abs(vec4(dot(p,n12), dot(p,n13), dot(p, n14), dot(p,n15)))),\n      abs(vec4(dot(p,n8), dot(p,n9), dot(p, n10), dot(p,n11)))),\n      abs(vec4(dot(p,n4), dot(p,n5), dot(p, n6), dot(p,n7))));\n   b.xy = max(b.xy, b.zw);\n   b.x = pow(max(b.x, b.y), 140.);\n   return length(q)-2.5*pow(1.5,b.x*(1.-mix(.3, 1., sin(iGlobalTime*2.)*.5+.5)*b.x));\n}\n\nfloat f(vec3 p) {\n   p.z += 6.;\n   R(p.xy, iGlobalTime);\n   R(p.xz, iGlobalTime);\n   return spikeball(p) +  fpn(p*50.+iGlobalTime*15.) * 0.45;\n}\n\n\/*\nvec3 g(vec3 p) {\n   vec2 e = vec2(.0001, .0);\n   return normalize(vec3(f(p+e.xyy) - f(p-e.xyy),f(p+e.yxy) - f(p-e.yxy),f(p+e.yyx) - f(p-e.yyx)));\n}\n*\/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n   \/\/ p: position on the ray\n   \/\/ d: direction of the ray\n   vec3 p = vec3(0.,0.,2.);\n   vec3 d = vec3((gl_FragCoord.xy\/(0.5*iResolution.xy)-1.)*vec2(iResolution.x\/iResolution.y,1.0), 0.) - p;\n   d = normalize(d); \n   \n   \/\/ ld, td: local, total density \n   \/\/ w: weighting factor\n   float ld=0., td=0.;\n   float w=0.;\n   \n   \/\/ total color\n   vec3 tc = vec3(0.);\n   \n   \/\/ i: 0 <= i <= 1.\n   \/\/ r: length of the ray\n   \/\/ l: distance function\n   float r=0., l=0., b=0.;\n\n   \/\/ rm loop\n   for (float i=0.; (i<1.); i+=1.\/64.) {\n\t   if(!((i<1.) && (l>=0.001*r) && (r < 50.)&& (td < .95)))\n\t\t   break;\n      \/\/ evaluate distance function\n      l = f(p) * 0.5;\n      \n      \/\/ check whether we are close enough (step)\n      \/\/ compute local density and weighting factor \n      const float h = .05;\n      ld = (h - l) * step(l, h);\n      w = (1. - td) * ld;   \n     \n      \/\/ accumulate color and density\n      tc += w; \/\/ * hsv(w, 1., 1.); \/\/ * hsv(w*3.-0.5, 1.-w*20., 1.); \n      td += w;\n       \n      td += 1.\/200.;\n      \n      \/\/ enforce minimum stepsize\n      l = max(l, 0.03);\n      \n      \/\/ step forward\n      p += l*d;\n      r += l;\n   }  \n    \n   #ifdef SCATTERING\n   \/\/ simple scattering approximation\n   tc *= 1. \/ exp( ld * 0.4 ) * 1.25;\n   #endif\n      \n   fragColor = vec4(tc, 1.0); \/\/vec4(tc.x+td*2., ld*3., 0, tc.x);\n}","name":"","description":"","type":"image"}]}}