{"Shader":{"ver":"0.1","info":{"id":"XlsGDH","date":"1421729372","viewed":726,"name":"kali-set density","username":"bergi","description":"Left is a 2d slice, right is the volume of the Kali set. <br\/>Click left to navigate right.","likes":2,"published":3,"flags":0,"tags":["kaliset","volumemarching"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/** Kali set volume rendering test\n\n\t(c) stefan berke, 2015\n\n\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\tEstimating the distance to a surface in the Kali set is relatively difficult,\n\tinstead stepping through a volume and just picking up colors is quite easy. \n\tThis is a tool for finding good spots in the set and testing rendering methods. \n\n\tThe left side shows a 2d slice of the Kali set from OFFSET to OFFSET + KALI_SCALE.\n\tThe right side is a close-up 3d volume of the position you selected last with the mouse.\n\tThe SCALE parameter is the extend of the camera frustum's near-plane. It helps to \n\tview larger parts of the volume but it also clips close objects away, which may look \n\tquite unrealistic with AUTO_ROTATION - just so you know..\n*\/\n\n\/\/ ------------------ \"interface\" -----------------------\n\n#define COLOR_MODE \t\t1\t\t\t\t\t\t\t\/\/ 0 == last value, 1 == average, 2 == average change\n#define AUTO_ROTATION\t17\t\t\t\t\t\t\t\/\/ rotate volume (degree per second)\n#define AUTO_MOVE\t\t1\t\t\t\t\t\t\t\/\/ slightly move camera in volume\n#define GRAYSCALE\t\t0\t\t\t\t\t\t\t\/\/ percent to convert all colors to white (anti-psychadelic)\n\nconst vec3 OFFSET = \tvec3(0., 0., 0.1);\t\t\t\/\/ offset in kali set (left and right screen)\nconst float KALI_SCALE =1.;\t\t\t\t\t\t\t\/\/ size of the visible area on the left\n\nconst vec3 KALI_PARAM =\tvec3(0.45, 0.8, 0.8);\t\t\/\/ the magic number (most of the numbers are magic :)\nconst int NUM_ITER =\t19;\t\t\t\t\t\t\t\/\/ number of iterations in kali set\n\nconst float SCALE = \t0.06;\t\t\t\t\t\t\/\/ size of the camera frustum's near-plane\n\t\t\t\t\t\t\t\t\t\t\t\t\t\/\/ set to zero for point-camera\nconst float DEPTH = \t0.06;\t\t\t\t\t\t\/\/ maximum depth to trace in volume\nconst float MIX_ALPHA =\t0.5;\t\t\t\t\t\t\/\/ opacity of the traced samples\nconst int NUM_TRACE = \t100;\t\t\t\t\t\t\/\/ number traces through volume\nconst float STEP = \t\tDEPTH \/ float(NUM_TRACE);\n\n\n\/\/ ----------------- kali set --------------------------\n\n#if COLOR_MODE == 0\n\n    vec3 kaliset(in vec3 p)\n    {\n        for (int i=0; i<NUM_ITER; ++i)\n        {\n            p = abs(p) \/ dot(p, p) - KALI_PARAM;\n        }\n        return p;\n    }\n\n#elif COLOR_MODE == 1\n\n    vec3 kaliset(in vec3 p)\n    {\n        vec3 c = vec3(0.);\n        for (int i=0; i<NUM_ITER; ++i)\n        {\n            p = abs(p) \/ dot(p, p) - KALI_PARAM;\n            c += p;\n        }\n        return c \/ float(NUM_ITER);\n    }\n\n#elif COLOR_MODE == 2\n\n    vec3 kaliset(in vec3 p)\n    {\n        vec3 c = vec3(0.), pp = vec3(0.);\n        for (int i=0; i<NUM_ITER; ++i)\n        {\n            p = abs(p) \/ dot(p, p) - KALI_PARAM;\n            c += abs(p - pp);\n            pp = p;\n        }\n        return c \/ float(NUM_ITER) \/ 3.;\n    }\n\n#endif\n\n\n\/\/ ---------------------- renderer --------------------------\n\n\/\/ quite inefficient volume tracer\n\/\/ it starts at the end of the ray (pos + DEPTH * dir)\n\/\/ and moves towards the camera plane\n\/\/ mixing-in the colors from the kaliset() function\nvec3 trace(in vec3 pos, in vec3 dir)\n{\n    vec3 col = vec3(0.);\n    for (int i=0; i<NUM_TRACE; ++i)\n    {\n        float t = float(i) \/ float(NUM_TRACE);\n        \n        vec3 p = pos + DEPTH * (1.-t) * dir;\n        \n        vec3 k = clamp(kaliset(p), 0., 1.) * (0.01+0.99*t);\n\n#if GRAYSCALE != 0\n        k += (float(GRAYSCALE)\/100.) * (vec3(max(k.x, max(k.y, k.z))) - k);\n#endif\n        \n        float ka = dot(k, k) \/ 3.;\n              \n        col += ka * MIX_ALPHA * (k - col);\n        \n    }\n    \n    return col;\n}\n\n\n\n\/\/ ------------------- number printing ----------------------\n\n\/\/ code by eiffie https:\/\/www.shadertoy.com\/view\/Mdl3Wj\n\nvoid Char(int i, vec2 p, inout float d){\n  const float w=0.1,h=0.3,w2=0.2,h2=0.4;\n  if(i>127){i-=128;d=min(d,max(abs(p.x),abs(p.y)-h));}\n  if(i>63){i-=64;d=min(d,max(abs(p.x-w2),abs(p.y-w2)-w));}\n  if(i>31){i-=32;d=min(d,max(abs(p.x-w2),abs(p.y+w2)-w));}\n  if(i>15){i-=16;d=min(d,max(abs(p.x+w2),abs(p.y-w2)-w));}\n  if(i>7){i-=8;d=min(d,max(abs(p.x+w2),abs(p.y+w2)-w));}\n  if(i>3){i-=4;d=min(d,max(abs(p.x)-w,abs(p.y-h2)));}\n  if(i>1){i-=2;d=min(d,max(abs(p.x)-w,abs(p.y)));}\n  if(i>0)d=min(d,max(abs(p.x)-w,abs(p.y+h2)));\n}\nint Digi(int i){\/\/converts digits to char codes\n  if(i==0)return 125;if(i==1)return 128;if(i==2)return 79;if(i==3)return 103;\n  if(i==4)return 114;if(i==5)return 55;if(i==6)return 63;if(i==7)return 100;\n  if(i==8)return 127;return 118;\n}\nvec3 PrintVal(float n, vec2 uv)\n{\n  uv *= 10.;\n  float d=1.0;\n  if(n!=n){\/\/error\n    uv.x-=2.8;\n    Char(31,uv,d);uv.x-=0.6;\n    Char(10,uv,d);uv.x-=0.6;\n    Char(10,uv,d);uv.x-=0.6;\n    Char(43,uv,d);uv.x-=0.6;\n    Char(10,uv,d);\n  }else{\n    if(n<0.0){n=-n;Char(2,uv+vec2(0.6,0.0),d);}\/\/negative sign\n    float c=floor(max(log(n)\/log(10.0),0.0));\n    d=min(d,length(uv+vec2(-0.6*c-0.3,0.55)));\/\/decimal place\n    if(c>0.0)n\/=pow(10.0,c);\n    for(int i=0;i<6;i++){\n      c=floor(n);\n      Char(Digi(int(c)),uv,d);\n      uv.x-=0.6;\n      n=(n-c)*10.0;\n    }\n  }\n  vec3 color=mix(vec3(0.3,0.8,0.5),vec3(0.0),smoothstep(0.0,0.2,d));\n  return mix(vec3(1.),color,smoothstep(0.0,0.08,d));\n}\n\n\n\/\/ --------------------- put it together -----------------------\n\nvec2 rotate(in vec2 v, float r)\n{\n\tfloat s = sin(r), c = cos(r);\n    \treturn vec2(v.x * c - v.y * s, v.x * s + v.y * c);\n}\n                \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.x;\n\tvec2 mouse = iMouse.xy \/ iResolution.x * KALI_SCALE * 2.;\n\t\n    vec3 col;\n    \n    if (uv.x < 0.5)\n    {\n        vec3 pos = vec3(uv * KALI_SCALE * 2., 0.00) + OFFSET;\n        col = clamp(kaliset(pos), .0, 1.);\n    }\n    else\n    {\n        uv.x -= .5;\n        uv *= 2.;\n\t\tfloat time = iGlobalTime;\n        \n        \/\/ cheap frustum\n        vec3 pos = vec3((uv-.5) * SCALE, 0.);\n        vec3 dir = normalize(vec3(uv-.5, 1.0));\n#if AUTO_ROTATION != 0\n        float rr = 3.14159265 * float(AUTO_ROTATION) \/ 180. * time;\n        pos.xz = rotate(pos.xz, rr);\n        dir.xz = rotate(dir.xz, rr);\n#endif\n#if AUTO_MOVE != 0\n        pos.x += 0.001*sin(time);\n        pos.y += 0.001*sin(time*1.1);\n#endif\n\n\t\tpos.xy += mouse;\n        pos += OFFSET;\n\n\t\tcol = trace(pos, dir);\n    }\n\n    \/\/ print coordinates\n    if (iMouse.z > .5)\n    {\n    \tuv = fragCoord.xy \/ iResolution.x * 2. - vec2(1.08, 1.);\n    \tcol = max(col, PrintVal(mouse.x + OFFSET.x, uv));\n    \tcol = max(col, PrintVal(mouse.y + OFFSET.y, uv + vec2(0., 0.12)));\n        col = max(col, PrintVal(OFFSET.z, uv + vec2(0., 0.24)));\n    }\n    \n    fragColor = vec4(col, 1.);\n}","name":"","description":"","type":"image"}]}}