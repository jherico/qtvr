{"Shader":{"ver":"0.1","info":{"id":"XtsGR2","date":"1424079000","viewed":892,"name":"simple terrian","username":"EvilRyu","description":"Try some simplest terrian.","likes":13,"published":3,"flags":0,"tags":["raymarching","fbm","terrian"],"hasliked":0},"renderpass":[{"inputs":[{"id":4,"src":"\/presets\/tex03.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by EvilRyu 2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat hash(vec2 p)\n{\n    p=fract(p*vec2(5.3983,5.4472));\n   \tp+=dot(p.yx,p.xy+vec2(21.5351,14.3137));\n    return fract(p.x*p.y*95.4337);\n}\n\nfloat noise(vec2 p)\n{\n    vec2 f;\n    f=fract(p);\n    p=floor(p);\n    f=f*f*(3.0-2.0*f);\n    return mix(mix(hash(p),hash(p+vec2(1.0,0.0)),f.x),\n               mix(hash(p+vec2(0.0,1.0)),hash(p+vec2(1.0,1.0)),f.x),f.y);\n}\n\nfloat fbm(vec2 p)\n{\n    p*=0.09;\n    float f=0.;\n    float freq=4.0;\n    float amp=0.8;\n    for(int i=0;i<10;++i)\n    {\n        f+=noise(p*freq)*amp;\n        amp*=0.5;\n        freq*=1.79;\n    }\n\n    return f;\n}\n\nfloat f(vec3 p)\n{\n    float h=fbm(p.xz);\n    h+=smoothstep(-.5,1.5,h);\n    h=p.y-h;\n    return h;\n}\n\nvec3 getnormal(vec3 p,float t)\n{\n    vec3 eps=vec3(0.001*t,0.0,0.0);\n    vec3 n=vec3(f(p-eps.xyy)-f(p+eps.xyy),\n                2.0*eps.x,\n                f(p-eps.yyx)-f(p+eps.yyx));\n  \n    return normalize(n);\n}\n\nfloat tmax = 20.0;\n\nfloat intersect(vec3 ro,vec3 rd )\n{\n    float h=1.0;\n    float t=0.01;\n    for(int i=0;i<150;++i)\n    {\n        h=f(ro+t*rd);\n        if(h<0.001*t||t>tmax)\n  \t\t\tbreak;\n        t+=h*0.5;\n    }\n    return t;\n}\n\/\/ from iq's Terrian Tubes https:\/\/www.shadertoy.com\/view\/4sjXzG\nvec3 dome(vec3 rd, vec3 sun_dir)\n{\n    float sun=dot(rd,sun_dir);\n    float sda=clamp(0.5+0.5*sun,0.0,1.0);\n    float cho=max(rd.y,0.0);\n    vec3 bgcol=mix(mix(vec3(0.00,0.40,0.80)*0.7, \n                       vec3(0.70,0.70,0.40),\n                       pow(1.0-cho,1.0 + 3.0-3.0*sda)), \n                   vec3(0.53+0.2*sda,0.45-0.1*sda,0.4-0.25*sda),\n                   pow(0.95-cho,10.0+8.0-8.0*sda));\n    bgcol*=0.8+0.2*sda;\n    return bgcol*0.4;\n}\n\nvec3 l1dir;\nvec3 lighting(vec3 n,vec3 p,vec3 rd)\n{\n    l1dir.z*=-1.0;\n    float dif=max(0.0,dot(l1dir,n));\n    float bac=max(0.0,dot(normalize(vec3(-l1dir.x,0.0,l1dir.z)),n));\n    float sky=max(0.0,dot(vec3(0.0,1.0,0.0),n));\n    float sha=smoothstep(0.0,0.1,p.y-1.13);\n    float spe=pow(max(0.0,dot(reflect(rd,n),l1dir)),2.0);\n   \tfloat amb=0.5*smoothstep(0.0,2.0,p.y);\n    vec3 col=2.3*dif*vec3(1.32,1.12,0.45)*sha;\n    col+=0.8*bac*vec3(1.32,1.10,0.4);\n    col+=0.3*sky*vec3(0.0,0.6,1.0);\n    col+=vec3(0.5)*spe;\n    col+=0.3*amb*vec3(1.0);\n    if(p.y-1.1<0.18)col*=vec3(0.4,0.6,0.7);\n    return col;\n}\n    \nvec3 camerapath(float t)\n{\n    vec3 p=vec3(-13.0+3.5*cos(t),3.3,-1.1+2.4*cos(2.4*t+2.0));\n\treturn p;\n} \n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{ \n    vec2 q=fragCoord.xy\/iResolution.xy; \n \tvec2 uv = -1.0 + 2.0*q; \n \tuv.x*=iResolution.x\/iResolution.y; \n\n \tvec3 ta=camerapath(iGlobalTime*0.2+0.3);\n    ta.y-=0.2;\n\tvec3 ro=camerapath(iGlobalTime*0.2);\n\n \tvec3 cf = normalize(ta-ro); \n    vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n    vec3 cu = normalize(cross(cs,cf)); \n \tvec3 rd = normalize(uv.x*cs + uv.y*cu + 1.5*cf);  \/\/ transform from view to world\n\n    l1dir=normalize(vec3(0., 0.15, -1.1));\n   \n    vec3 sun_dir=l1dir;\n    float sun=clamp(dot(sun_dir,rd),0.0,1.0);\n    \n    vec3 col=dome(rd,l1dir);\n   \n    float t=intersect(ro,rd);\n\tif(t>tmax) \/\/ sky\n    { \n        col += 0.8*vec3(1.0,0.8,0.7)*pow(sun,512.0);\/\/sun\n\t\tcol += 0.1*vec3(1.0,0.4,0.2)*pow(sun,4.0);\n\t\tvec2 cuv=ro.xz+rd.xz*(10.0-ro.y)\/rd.y;\/\/cloud\n        vec3 cloud=mix(vec3(1.0,0.7,0.1),vec3(1.0),1.0-sun);\n\t\tcol=mix(col, cloud, 0.5*pow(texture2D(iChannel0,0.001*cuv).x,1.6));\n    }\n    else\n    {\n        vec3 p=ro+t*rd;\n        vec3 n=getnormal(p,t);\n        col=0.2*vec3(1.0,1.0,1.0)*lighting(n,p,rd);\n        col=mix(col, 0.25*vec3(0.4,0.75,1.0), 1.0-exp(-0.006*t*t) );\n    }\n   \tcol+=vec3(1.0,0.6,0.2)*0.2*pow(sun,2.0);\n\n\n    \/\/ post\n    col=pow(clamp(col,0.0,1.0),vec3(0.45)); \n  \n    col = col*1.3*vec3(1.0,1.0,1.02) + vec3(0.0,0.0,0.11);\n    col = clamp(col,0.0,1.0);\n    col = col*col*(3.0-2.0*col);\n    col = mix( col, vec3(dot(col,vec3(0.333))), 0.25 );\n    col*=0.5+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  \/\/ vigneting\n \tfragColor = vec4(col.xyz, 1.0); \n }","name":"","description":"","type":"image"}]}}