{"Shader":{"ver":"0.1","info":{"id":"MdSXzz","date":"1409129442","viewed":2008,"name":"Warping - procedural 4","username":"iq","description":"More fbm warping","likes":29,"published":3,"flags":0,"tags":["procedural","2d","warping"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat hash( vec2 p )\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f\/0.9375;\n}\n\nvec2 fbm2( in vec2 p )\n{\n    return vec2( fbm(p.xy), fbm(p.yx) );\n}\n\nvec3 map( vec2 p )\n{   \n    p *= 0.7;\n\n    float f = dot( fbm2( 1.0*(0.05*iGlobalTime + p + fbm2(-0.05*iGlobalTime+2.0*(p + fbm2(4.0*p)))) ), vec2(1.0,-1.0) );\n\n    float bl = smoothstep( -0.8, 0.8, f );\n\n    float ti = smoothstep( -1.0, 1.0, fbm(p) );\n\n    return mix( mix( vec3(0.50,0.00,0.00), \n                     vec3(1.00,0.75,0.35), ti ), \n                     vec3(0.00,0.00,0.02), bl );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy+2.0*fragCoord.xy)\/iResolution.y;\n    \n\n    float e = 0.0045;\n\n    vec3 colc = map( p               ); float gc = dot(colc,vec3(0.333));\n    vec3 cola = map( p + vec2(e,0.0) ); float ga = dot(cola,vec3(0.333));\n    vec3 colb = map( p + vec2(0.0,e) ); float gb = dot(colb,vec3(0.333));\n    \n    vec3 nor = normalize( vec3(ga-gc, e, gb-gc ) );\n\n    vec3 col = colc;\n    col += vec3(1.0,0.7,0.6)*8.0*abs(2.0*gc-ga-gb);\n    col *= 1.0+0.2*nor.y*nor.y;\n    col += 0.05*nor.y*nor.y*nor.y;\n    \n    \n    vec2 q = fragCoord.xy\/iResolution.xy;\n    col *= pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}