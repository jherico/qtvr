{"Shader":{"ver":"0.1","info":{"id":"XsfXW8","date":"1399832742","viewed":1795,"name":"textured ellipsoids","username":"FabriceNeyret2","description":"S: toggles sky  SPACE: decompos<br\/> <br\/>In Siggraph'85, Gardner proposed a smart way to fake hypertextures with simple ellipsoids.<br\/>The secret is to have transparency (or the density noise) vanishing at silhouettes, i.e., view-dep (e.g. based on dot(N,Eye) ).","likes":36,"published":3,"flags":0,"tags":["procedural","noise","cloud"],"hasliked":0},"renderpass":[{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Gardner textured ellipsoids\n\nvec3 R = vec3(2.,4.,2.);              \/\/ ellipsoid radius\nvec3 L = normalize(vec3(-.4,0.,1.));  \/\/ light source\n#define AMBIENT .4\t\t\t\t\t  \/\/ ambient luminosity\n\n#define ANIM true\nfloat t = iGlobalTime;\n#define PI 3.1415927\nvec4 FragColor;\n\nbool keyToggle(int ascii) {\n\treturn (texture2D(iChannel2,vec2((.5+float(ascii))\/256.,0.75)).x > 0.);\n}\n\n\/\/ --- noise functions from https:\/\/www.shadertoy.com\/view\/XslGRr\n\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )    \/\/ in [0,1]\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x ) \/\/ in [0,1]\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )    \/\/ in [0,1]\n{\n\tif (ANIM) p += iGlobalTime;\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\/\/ --- End of Created by inigo quilez\n\nfloat snoise( in vec3 x ) \/\/ in [-1,1]\n{ return 2.*noise(x)-1.; }\n\nfloat sfbm( vec3 p )      \/\/ in [-1,1]\n{\n\tif (ANIM) p += iGlobalTime;\n    float f;\n    f  = 0.5000*snoise( p ); p = m*p*2.02;\n    f += 0.2500*snoise( p ); p = m*p*2.03;\n    f += 0.1250*snoise( p ); p = m*p*2.01;\n    f += 0.0625*snoise( p );\n    return f;\n}\n\n\n\n\/\/ --- view matrix when looking T from O with [-1,1]x[-1,1] screen at dist d\n\n\nmat3 lookat(vec3 O, vec3 T, float d) {\n\tmat3 M;\n\tvec3 OT = normalize(T-O);\n\tM[0] = OT;\n\tM[2] = normalize(vec3(0.,0.,1.)-OT.z*OT)\/d;\n\tM[1] = cross(M[2],OT);\n\treturn M;\n}\n\n\/\/ --- ray -  ellipsoid intersection\n\/\/ if true, return P,N and thickness l\n\nbool intersect_ellipsoid(vec3 O, vec3 D, out vec3 P, out vec3 N, out float l) {\n\tvec3 OR = O\/R, DR = D\/R; \/\/ to space where ellipsoid is a sphere \n\t\t\/\/ P=O+tD & |P|=1 -> solve t in O^2 +2(O.D)t + D^2.t^2 = 1\n\tfloat OD = dot(OR,DR), OO=dot(OR,OR), DD=dot(DR,DR);\n\tfloat d = OD*OD - (OO-1.)*DD;\n\t\n\tif (!((d >=0.)&&(OD<0.)&&(OO>1.))) return false;\n\t\/\/ ray intersects the ellipsoid (and not in our back)\n\t\/\/ note that t>0 <=> -OD>0 &  OD^2 > OD^ -(OO-1.)*DD -> |O|>1\n\t\t\n\tfloat t = (-OD-sqrt(d))\/DD;\n\t\/\/ return intersection point, normal and thickness\n\tP = O+t*D;\n\tN=normalize(P\/(R*R));\n\tl = 2.*sqrt(d)\/DD;\n\n\treturn true;\n}\n\n\/\/ --- Gardner textured ellipsoids (sort of)\n\n\/\/ 's' index corresponds to Garner faked silhouette\n\/\/ 'i' index corresponds to interior term faked by mid-surface\n\nfloat ks,ps, ki,pi;  \/\/ smoothness\/thichness parameters\n\nfloat l;\nvoid draw_obj(vec3 O, mat3 M, vec2 pos, int mode) {\n\tvec3 D = normalize(M*vec3(1.,pos));\t\t\/\/ ray\n\t\n\tvec3 P,N; \n\tif (! intersect_ellipsoid(O,D, P,N,l)) return;\n\t\n\tvec3 Pm = P+.5*l*D,                \t\t\/\/ .5: deepest point inside cloud. \n\t\t Nm = normalize(Pm\/(R*R)),     \t\t\/\/ it's normal\n\t     Nn = normalize(P\/R);\n\tfloat nl = clamp( dot(N,L),0.,1.), \t\t\/\/ ratio of light-facing (for lighting)\n\t\t  nd = clamp(-dot(Nn,D),0.,1.); \t\/\/ ratio of camera-facing (for silhouette)\n\n\n\tfloat ns = fbm(P), ni = fbm(Pm+10.);\n\tfloat A, l0 = 3.;\n\t\/\/l += l*(l\/l0-1.)\/(1.+l*l\/(l0*l0));     \/\/ optical depth modified at silhouette\n\tl = clamp(l-6.*ni,0.,1e10);\n\tfloat As = pow(ks*nd, ps), \t\t\t \t \/\/ silhouette\n\t\t  Ai = 1.-pow(.7,pi*l);              \/\/ interior\n\n\n\tAs =clamp(As-ns,0.,1.)*2.; \/\/ As = 2.*pow(As ,.6);\n\tif (mode==2) \n\t\tA = 1.- (1.-As)*(1.-Ai);  \t\t\t\/\/ mul Ti and Ts\n\telse\n\t\tA = (mode==0) ? Ai : As; \n\tA = clamp(A,0.,1.); \n\tnl = .8*( nl + ((mode==0) ? fbm(Pm-10.) : fbm(P+10.) ));\n\n\t#if 0 \/\/ noise bump\n\tN = normalize(N -.1*(dFdx(A)*M[1]+dFdy(A)*M[2])*iResolution.y); \n\tnl = clamp( dot(N,L),0.,1.);\n#endif\n\t\n\tvec4 col = vec4(mix(nl,1.,AMBIENT));\n\tFragColor = mix(FragColor,col,A);\n}\n\n\/\/ === main =============================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = 2.*(fragCoord.xy \/ iResolution.y-vec2(.85,.5));\n\tvec2 mouse = 2.*(iMouse.xy \/ iResolution.xy - vec2(.85,.5));\n\tfloat z = .2;\n\tks = 1.+mouse.x, ps = mouse.y*8., ki, pi;\n\tks = 1.; ps = 3.;   ki = .9; pi = 3.;\n\t\n\tif (iMouse.z>0.) {\n\t\tt = -PI\/2.*mouse.x;\n\t\tz = -PI\/2.*mouse.y;\n\t}\n\tvec3 O = vec3(-15.*cos(t)*cos(z),15.*sin(t)*cos(z),15.*sin(z));\t\/\/ camera\n\tfloat compas = t-.2*uv.x; vec2 dir = vec2(cos(compas),sin(compas));\n\tFragColor = (keyToggle(64+19)) \n\t\t? vec4(0.) \n\t\t: clamp(vec4(.6,.7+.3*dir,1.)*(uv.y+1.6)\/1.8,0.,1.); \t\t\/\/ sky\n\n\tmat3 M = lookat(O,vec3(0.),5.); \n\tvec2 dx = vec2(1.,0.);\n\t\n\tif (!keyToggle(32))\n\t\tdraw_obj(O,M, uv, 2);\t\n\telse {\n\t\tdraw_obj(O,M, 1.5*(uv+dx), 0);\t\n\t\tdraw_obj(O,M, 1.5*(uv-dx), 1);\t\n\t}\n    \n   fragColor = FragColor; \n}\n","name":"","description":"","type":"image"}]}}