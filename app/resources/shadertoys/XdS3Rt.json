{"Shader":{"ver":"0.1","info":{"id":"XdS3Rt","date":"1392023597","viewed":3712,"name":"Sphere - visibility","username":"iq","description":"Analytical sphere visibility. Can be used for occlusion culling!  White: spheres don't touch.   Yellow: spheres touch (partial occlusion).   Red: spheres completely occlude each other. I'm expecting the \"Yellow is gay\" joke.","likes":12,"published":3,"flags":0,"tags":["3d","sphere","analytic"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\/\/ Analytical sphere visibility, which can be used of occlusion culling, based on this\n\/\/\n\/\/ Aarticle I wrote in 2008: http:\/\/iquilezles.org\/www\/articles\/sphereocc\/sphereocc.htm\n\/\/\n\/\/ Related info: http:\/\/iquilezles.org\/www\/articles\/spherefunctions\/spherefunctions.htm\n\n\/\/-----------------------------------------------------------------\n\n\/\/ 1: spheres don't overlap\n\/\/ 2: spheres overlap partially\n\/\/ 3: spheres overlap completely\n\nint sphereVisibility( in vec4 sA, in vec4 sB, in vec3 c )\n{\n    vec3 ac = sA.xyz - c;\n    vec3 bc = sB.xyz - c;\n\n    float ia = 1.0\/length(ac);\n    float ib = 1.0\/length(bc);\n\n    float k0 = dot(ac,bc)*ia*ib;\n    float k1 = sA.w*ia;\n    float k2 = sB.w*ib;\n\n\t     if( k0*k0 + k1*k1 + k2*k2 + 2.0*k0*k1*k2 - 1.0 < 0.0 ) return 1;\n\telse if( k0*k0 + k1*k1 + k2*k2 - 2.0*k0*k1*k2 - 1.0 < 0.0 ) return 2;\n\n\treturn 3;\n}\n\n\/\/-----------------------------------------------------------------\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\nfloat oSphere( in vec3 pos, in vec3 nor, in vec4 sph )\n{\n    vec3 di = sph.xyz - pos;\n    float l = length(di);\n    return 1.0 - max(0.0,dot(nor,di\/l))*sph.w*sph.w\/(l*l); \n}\n\n\/\/-----------------------------------------------------------------\n\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\n\n\/\/-----------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) \/ iResolution.y;\n\t\n\tfloat an = 0.6 - 0.5*iGlobalTime + 10.0*iMouse.x\/iResolution.x;\n\tvec3 ro = vec3( 3.5*cos(an), 0.0, 3.5*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n\tvec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n\tvec4 sph1 = vec4(-1.2,0.7,0.0,1.0);\n\tvec4 sph2 = vec4( 1.2,0.0,0.0,1.0);\n\n    int vis = sphereVisibility( sph1, sph2, ro );\n\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tfloat occ = 1.0;\n\tvec3  pos = vec3(0.0);\n\t\n\tfloat h = iSphere( ro, rd, sph1 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n\t\tpos = ro + h*rd;\n\t\tnor = normalize(pos-sph1.xyz); \n\t\tocc = oSphere( pos, nor, sph2 );\n\t\tocc *= smoothstep(-0.6,-0.2,sin(20.0*(pos.x-sph1.x)));\n\t}\n\th = iSphere( ro, rd, sph2 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n\t\tpos = ro + h*rd;\n\t\tnor = normalize(pos-sph2.xyz); \n\t\tocc = oSphere( pos, nor, sph1 );\n\t\tocc *= smoothstep(-0.6,-0.2,sin(20.0*(pos.z-sph1.z)));\n\t}\n\n\tvec3 col = vec3(0.02)*clamp(1.0-0.5*length(p),0.0,1.0);\n\tif( tmin<100.0 )\n\t{\n\t    pos = ro + tmin*rd;\n        col = vec3(0.5);\n\t\tif( vis==1 ) col = vec3(1.0,1.0,1.0);\n\t\tif( vis==2 ) col = vec3(1.0,1.0,0.0);\n\t\tif( vis==3 ) col = vec3(1.0,0.0,0.0);\n\t\tcol *= occ;\n\t\tcol *= 0.7 + 0.3*nor.y;\n\t\tcol *= exp(-0.5*max(0.0,tmin-2.0));\n\t}\n\n\tcol = pow( col, vec3(0.45) );\n\n    col += (1.0\/255.0)*hash3(p.x+13.0*p.y);\n\n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}