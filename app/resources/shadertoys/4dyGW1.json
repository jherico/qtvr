{"Shader":{"ver":"0.1","info":{"id":"4dyGW1","date":"1454156650","viewed":53,"name":" Suresh's Voronoi Party (II)","username":"imallett","description":"An improved version of this shader:<br\/>https:\/\/www.shadertoy.com\/view\/ldKGDz<br\/>Which in turn was based on a discussion with the author. Supports higher-level envelopes, antialiasing, and more.","likes":1,"published":3,"flags":0,"tags":["voronoi"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/Algorithm parameters\n#define NUM_POINTS 16\n#define MS_PER_STEP 1000.0\n#define ENVELOPE_DEPTH 2 \/\/Must be at least 1 (2 if you want boundaries)\n#define NORM 2 \/\/1==L_1 norm, 2==L_2 norm, etc.  Use -1 for infinity norm.\n#if   NORM ==  1\n\t#define NORM_FUNC L_1\n#elif NORM ==  2\n\t#define NORM_FUNC L_2\n#elif NORM == -1\n\t#define NORM_FUNC L_inf\n#else\n\t#error Unsupported norm!\n#endif\n\n\/\/Extra features\n\/\/#define WEIGHT_FIRST_CONE\n#ifdef WEIGHT_FIRST_CONE\n\t#define FIRST_CONE_WEIGHT -0.5\n#endif\n\n\/\/Render parameters\n#define DRAW_BOUNDARIES \/\/Must have ENVELOPE_DEPTH >= 2 and NORM == 2\n#ifdef DRAW_BOUNDARIES\n\t#define BOUNDARY_RADIUS 0.005\n#endif\n#define POINT_RADIUS 0.02\n\/\/\tCan set to higher to see deeper levels.  Must be strictly less than ENVELOPE_DEPTH.  Not\n\/\/\t\tsupported with DRAW_BOUNDARIES defined.\n#define ENVELOPE_LEVEL 0\n\n\n\/\/The envelope we build implicitly\nstruct Record {\n\tfloat u;\n\tfloat dist;\n\tvec2 generating_pt;\n};\nRecord envelope[ENVELOPE_DEPTH];\n\n\n\/\/Norms\nfloat L_1(vec2 p0, vec2 p1) {\n\tvec2 tmp = abs(p0 - p1);\n\treturn tmp.x + tmp.y;\n}\nfloat L_2(vec2 p0, vec2 p1) {\n\treturn distance(p0, p1);\n}\nfloat L_inf(vec2 p0, vec2 p1) {\n\tvec2 tmp = abs(p0 - p1);\n\treturn max(tmp.x, tmp.y);\n}\n\n\/\/Inserts the given record into \"envelope\" of current size \"size\".  Returns whether it was appended or\n\/\/\treplaced another record successfully.\nbool insert(Record record, int size) {\n\t\/\/Similar algorithms don't work because WebGL doesn't like dynamically indexed loops (or while loops).\n\t\/\/\tThis one perturbs it into working.\n\tif (record.dist<envelope[ENVELOPE_DEPTH-1].dist) {\n\t\t\/\/Kick out last element\n\t\tenvelope[ENVELOPE_DEPTH-1] = record;\n\t\t\/\/Bubble sort\n\t\tfor (int i=ENVELOPE_DEPTH-1;i>=1;--i) {\n\t\t\tif (envelope[i-1].dist > envelope[i].dist) {\n\t\t\t\tRecord temp = envelope[i-1];\n\t\t\t\tenvelope[i-1] = envelope[i];\n\t\t\t\tenvelope[i] = temp;\n\t\t\t} else break;\n\t\t}\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nvec4 get_sample(vec2 frag_coord) {\n\t\/\/Setup\n\tvec2 aspect = vec2(iResolution.x\/iResolution.y, 1.0);\n\n\tvec2 uv = frag_coord.xy\/iResolution.xy;\n\tvec2 frag_pos = aspect*(2.0*uv - vec2(1.0));\n\n\tfor (int i=0;i<ENVELOPE_DEPTH;++i) {\n\t\tenvelope[i].dist = 9999999999999.0;\n\t}\n\n\t\/\/Add each point to the per-sample envelope.\n\tvec4 color;\n\tfor (int i=0;i<NUM_POINTS;++i) {\n\t\tfloat u = float(i)*(1.0\/float(NUM_POINTS));\n\t\tvec4 sample = texture2D(\n\t\t\tiChannel0,\n\t\t\tvec2( u, iGlobalTime*(1.0\/MS_PER_STEP) )\n\t\t);\n\t\tvec2 generating_pt = aspect*(2.0*sample.xy-vec2(1.0));\n\n\t\tfloat dist = NORM_FUNC(frag_pos,generating_pt);\n\n\t\tif (dist<POINT_RADIUS) { return vec4(1.0); } \/\/Draw generating points\n\n\t\t#ifdef WEIGHT_FIRST_CONE\n\t\t\tif (i==0) dist+=FIRST_CONE_WEIGHT;\n\t\t#endif\n\n\t\t\/\/Note: because GPUs compute 2x2 quads, this code must be in the loop, instead of\n\t\t\/\/\toutside of it.  Terrible, I know.\n\t\tif (insert(Record(u,dist,generating_pt),i<ENVELOPE_DEPTH?i:ENVELOPE_DEPTH)) {\n\t\t\tcolor = texture2D(iChannel0, vec2(envelope[ENVELOPE_LEVEL].u, 0.0));\n\n\t\t\t#if defined DRAW_BOUNDARIES && ENVELOPE_DEPTH > 1 && NORM == 2 && ENVELOPE_LEVEL == 0\n\t\t\tvec2 normal = normalize(envelope[ENVELOPE_LEVEL].generating_pt - envelope[ENVELOPE_LEVEL+1].generating_pt);\n\t\t\tvec2 displ = frag_pos - 0.5*(envelope[ENVELOPE_LEVEL].generating_pt + envelope[ENVELOPE_LEVEL+1].generating_pt);\n\t\t\tfloat d = dot(normal,displ);\n\t\t\tif (abs(d)<BOUNDARY_RADIUS) {\n\t\t\t\tcolor = vec4(0.0);\n\t\t\t}\n\t\t\t#endif\n\t\t}\n\t}\n\treturn color;\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n\t\/\/Run algorithm (16x supersampling)\n\tfrag_color = vec4(0,0,0,0);\n\tfor (int j=0;j<4;++j) {\n\t\tfor (int i=0;i<4;++i) {\n\t\t\tfrag_color += get_sample(frag_coord-vec2(0.475,0.475)+vec2(0.25,0.25)*vec2(i,j));\n\t\t}\n\t}\n\tfrag_color *= 1.0\/16.0;\n}\n","name":"","description":"","type":"image"}]}}