{"Shader":{"ver":"0.1","info":{"id":"XtjXz3","date":"1445501469","viewed":694,"name":"secret lair","username":"ryk","description":"You could say I'm a fan of light fixtures behind fans. Better not, though.","likes":10,"published":3,"flags":0,"tags":["volumetric"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Copyright 2015 Martin Rykfors\n\/\/ Licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported (CC BY-NC-SA 3.0)\n\/\/ If you redistribute this work, please credit me by providing a link to https:\/\/www.shadertoy.com\/user\/ryk\nfloat time;\nvec2 size;\n#define PI 3.1415926535897\n#define Y_WALL 1.5\n#define Z_WALL 1.5\n\nstruct Ray\n{\n\tvec3 org;\n\tvec3 dir;\n};\n\nRay createRay(vec3 center, vec3 lookAt, vec3 up, vec2 uv, float fov, float aspect)\n{\n\tRay ray;\n\tray.org = center;\n\tvec3 dir = normalize(lookAt - center);\n\tup = normalize(up - dir*dot(dir,up));\n\tvec3 right = cross(dir, up);\n\tuv = 2.*uv - vec2(1.);\n\tfov = fov * 3.1415\/180.;\n\tray.dir = dir + tan(fov\/2.) * right * uv.x + tan(fov\/2.) \/ aspect * up * uv.y;\n\tray.dir = normalize(ray.dir);\t\n\treturn ray;\n}\n\nfloat fan(vec2 p, float blur){\n    float y = p.y;\n    float rs = dot(p,p);\n    float arg = atan(p.y, p.x);\n    float f = 1. - smoothstep(1.-blur, 1.+blur, rs);\n    f *= smoothstep(0.02-blur\/8., 0.02+blur\/8., rs);\n    float period = 2.*PI\/8.;\n    arg += time*2.;\n    arg += period;\n    arg = mod(arg, 2.*period);\n    arg -= period;\n    p = sqrt(rs) * vec2(cos(arg), sin(arg));\n    p -= vec2(0.55, 0.);\n    p *= vec2(1.9,6.5);\n    f *= smoothstep(1.-blur*4., 1.+blur*4., dot(p,p));\n    return f;\n}\n\nfloat intensity(vec3 pos,float bias){\n    float inside = (pos.y > -Y_WALL ? 1.: 0.) * (pos.z > -Z_WALL ? 1.: 0.);\n    pos.z -= 2.;\n    pos.z += pos.y\/1.;\n    vec2 p = pos.xz;\n    float b = (pos.y + Y_WALL)\/1.3 + bias;\n\n    return fan(p,b) * 0.03 * inside;\n}\n\nfloat renderFog(Ray ray){\n    float acc = 0.;\n    float dist = 0.;\n    vec3 pos;\n    for (int i = 0; i < 80; i++){\n        pos = ray.org + ray.dir*dist;\n        acc += intensity(pos, 1.0) * smoothstep(-Z_WALL, -Z_WALL+0.08, pos.z);\n        dist+=0.12;\n    }\n    return acc;\n}\n\nvec3 render(Ray ray){\n    float n = -dot(vec3(0.,1.,0.), ray.dir);\n    float delta = ray.org.y + Y_WALL;\n    float dist1 = delta\/n;\n    dist1 = dist1 < 0. ? 100000. : dist1;\n    \n    n = -dot(vec3(0.,0.,1.), ray.dir);\n    delta = ray.org.z + Z_WALL;\n    float dist2 = delta\/n;\n    dist2 = dist2 < 0. ? 100000. : dist2;\n    vec3 col;\n    if (dist1 < dist2){\n        vec3 pos = ray.org + ray.dir*dist1;\n        col = vec3(0.19,0.24,0.24)\/(1.+sqrt(dist1\/8.)) + intensity(pos+vec3(0.,0.0001,0.),0.02)*38.;\n    }\n    else{\n        vec3 pos = ray.org + ray.dir*dist2;\n        col = vec3(0.17,0.21,0.21)\/(1.+sqrt(dist2\/8.))+ intensity(pos+vec3(0.,0.,0.001),-0.9)*38.;\n    }\n    return col;\n}\n\nvec3 centerTrajectory(){\n    float t = sin(time\/8.);\n    float at = atan(abs(t*4.));\n    t = sign(t)*at;\n    return vec3(0, t*2.8+0.0, -t*2.0 + 0.5);\n}\n\nvec3 cameraTrajectory(){\n    vec2 c = vec2(cos(time\/4.), sin(time\/4.));\n    c.y *= 2.5;\n    c.y += 4.5;\n    c.x *= 4.;\n    c.x += 1.;\n    return vec3(c,0.5);\n}\n\nvec4 mainRender(vec2 uv){\n   \n    vec2 p = uv*2. - 1.;\n    vec3 camPos = cameraTrajectory();\n    vec3 center = centerTrajectory();\n    vec3 up = vec3(0.,0.,1.);\n    Ray ray = createRay(camPos, center, up, uv, 90., size.x\/size.y);\n\n    float fog = renderFog(ray);\n    vec3 fogCol = vec3(1.) * fog;\n\n    vec3 sceneCol = render(ray) + fogCol;\n    return vec4(sceneCol, 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    size = iResolution.xy;\n    time = iGlobalTime + 15.;\n\tfragColor = mainRender(uv);\n}","name":"","description":"","type":"image"}]}}