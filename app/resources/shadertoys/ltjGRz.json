{"Shader":{"ver":"0.1","info":{"id":"ltjGRz","date":"1426806534","viewed":3329,"name":"[NV15] Space","username":"reinder","description":"Space - winner of the 'best visuals' category of the Shadertoy Hackathon @ NVSCENE 2015.<br\/><br\/>See <a href=\"https:\/\/www.shadertoy.com\/view\/4tjGRh\"  class=\"regular\" target=\"_blank\">4tjGRh<\/a> for the updated shader with space-to-surface flight.","likes":41,"published":3,"flags":8,"tags":["space"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ [NV15] Space. Created by Reinder Nijhoff 2015\n\/\/ @reindernijhoff\n\/\/\n\/\/ https:\/\/www.shadertoy.com\/view\/ltjGRz\n\/\/\n\n#define SHOW_ASTEROIDS\n\/\/#define HIGH_QUALITY\n\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = (PI \/ 180.0);\nconst float MAX = 10000.0;\n\nconst float EARTH_RADIUS = 1000.;\nconst float EARTH_ATMOSPHERE = 10.;\nconst float RING_INNER_RADIUS = 1500.;\nconst float RING_OUTER_RADIUS = 2300.;\nconst float RING_DETAIL_DISTANCE = 40.;\nconst float RING_HEIGHT = 2.;\nconst float RING_VOXEL_STEP_SIZE = .03;\nconst vec3  RING_COLOR_1 = vec3(0.42,0.3,0.2);\nconst vec3  RING_COLOR_2 = vec3(0.51,0.41,0.32) * 0.2;\n\nconst int   ASTEROID_NUM_STEPS = 10;\nconst float ASTEROID_TRESHOLD \t= 0.001;\nconst float ASTEROID_EPSILON \t= 1e-6;\nconst float ASTEROID_DISPLACEMENT = 0.1;\n\n#ifdef HIGH_QUALITY\nconst int   RING_VOXEL_STEPS = 60;\nconst float ASTEROID_MAX_DISTANCE = 2.7; \nconst float ASTEROID_RADIUS = 0.12;\n#else\nconst int   RING_VOXEL_STEPS = 26;\nconst float ASTEROID_MAX_DISTANCE = 1.; \/\/ RING_VOXEL_STEPS * RING_VOXEL_STEP_SIZE\nconst float ASTEROID_RADIUS = 0.13;\n#endif\n\n\n\n#define SUN_DIRECTION normalize( vec3( 1.,  .3, .2 ) )\nconst vec3 SUN_COLOR = vec3(1.0, .7, .55)*.2;\n\n\/\/-----------------------------------------------------\n\/\/ Noise functions\n\/\/-----------------------------------------------------\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453123);\n}\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat hash( vec3 p ) {\n\tfloat h = dot(p,vec3(127.1,311.7,758.5453123));\t\n    return fract(sin(h)*43758.5453123);\n}\nvec3 hash31(float p) {\n\tvec3 h = vec3(1275.231,4461.7,7182.423) * p;\t\n    return fract(sin(h)*43758.543123);\n}\nvec3 hash33( vec3 p) {\n    return vec3( hash(p), hash(p.zyx), hash(p.yxz) );\n}\nfloat noise( in float p ) {    \n    float i = floor( p );\n    float f = fract( p );\t\n\tfloat u = f*f*(3.0-2.0*f);\n    return -1.0+2.0* mix( hash( i + 0. ), hash( i + 1. ), u);\n}\nfloat noise( in vec2 p ) {    \n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nfloat fbm( vec2 p ) {\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m2*p*2.02;\n    f += 0.2500*noise( p ); p = m2*p*2.03;\n    f += 0.1250*noise( p ); p = m2*p*2.01;\n    f += 0.0625*noise( p );\n    \n    return f\/0.9375;\n}\n\n\/\/ fBm\nfloat fbm3(vec3 p, float a, float f) {\n    return noise(p);\n}\n\nfloat fbm3_high(vec3 p, float a, float f) {\n    float ret = 0.0;    \n    float amp = 1.0;\n    float frq = 1.0;\n    for(int i = 0; i < 4; i++) {\n        float n = pow(noise(p * frq),2.0);\n        ret += n * amp;\n        frq *= f;\n        amp *= a * (pow(n,0.2));\n    }\n    return ret;\n}\n\n\/\/-----------------------------------------------------\n\/\/ Lightning functions\n\/\/-----------------------------------------------------\n\nfloat diffuse(vec3 n,vec3 l) { \n    return clamp(dot(n,l),0.,1.);\n}\n\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) \/ (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n\/\/-----------------------------------------------------\n\/\/ Math functions\n\/\/-----------------------------------------------------\n\nvec2 rotate(float angle, vec2 v) {\n    return vec2(cos(angle) * v.x + sin(angle) * v.y, cos(angle) * v.y - sin(angle) * v.x);\n}\n\nfloat boolSub(float a,float b) { \n    return max(a,-b); \n}\nfloat sphere(vec3 p,float r) {\n\treturn length(p)-r;\n}\n\n\/\/-----------------------------------------------------\n\/\/ Intersection functions (by iq)\n\/\/-----------------------------------------------------\n\nvec3 nSphere( in vec3 pos, in vec4 sph ) {\n    return (pos-sph.xyz)\/sph.w;\n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\nvec3 nPlane( in vec3 ro, in vec4 obj ) {\n    return obj.xyz;\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pla ) {\n    return (-pla.w - dot(pla.xyz,ro)) \/ dot( pla.xyz, rd );\n}\n\n\n\/\/-----------------------------------------------------\n\/\/ Wet stone by TDM\n\/\/ \n\/\/ https:\/\/www.shadertoy.com\/view\/ldSSzV\n\/\/-----------------------------------------------------\n\nfloat rock( const in vec3 p, const in vec3 id ) {  \n    float d = sphere(p,ASTEROID_RADIUS);    \n    for(int i = 0; i < 7; i++) {\n        float ii = float(i)+id.x;\n        float r = (ASTEROID_RADIUS*2.5) + ASTEROID_RADIUS*hash(ii);\n        vec3 v = normalize(hash31(ii) * 2.0 - 1.0);\n    \td = boolSub(d,sphere(p+v*r,r * 0.8));       \n    }\n    return d;\n}\n\nfloat map( const in vec3 p, const in vec3 id) {\n    float d = rock(p, id) + fbm3(p*4.0,0.4,2.96) * ASTEROID_DISPLACEMENT;\n    return d;\n}\n\nfloat map_detailed( const in vec3 p, const in vec3 id) {\n    float d = rock(p, id) + fbm3_high(p*4.0,0.4,2.96) * ASTEROID_DISPLACEMENT;\n    return d;\n}\n\nvoid asteroidTransForm(inout vec3 ro, const in vec3 id ) {\n    float xyangle = (id.x-.5)*iGlobalTime*2.;\n    ro.xy = rotate( xyangle, ro.xy );\n    \n    float yzangle = (id.y-.5)*iGlobalTime*2.;\n    ro.yz = rotate( yzangle, ro.yz );\n}\nvoid asteroidUnTransForm(inout vec3 ro, const in vec3 id ) {\n    float yzangle = (id.y-.5)*iGlobalTime*2.;\n    ro.yz = rotate( -yzangle, ro.yz );\n\n    float xyangle = (id.x-.5)*iGlobalTime*2.;\n    ro.xy = rotate( -xyangle, ro.xy );  \n}\n\/\/ tracing\nvec3 asteroidGetNormal(vec3 p, vec3 id) {\n    asteroidTransForm( p, id );\n    \n    vec3 n;\n    n.x = map_detailed(vec3(p.x+ASTEROID_EPSILON,p.y,p.z), id);\n    n.y = map_detailed(vec3(p.x,p.y+ASTEROID_EPSILON,p.z), id);\n    n.z = map_detailed(vec3(p.x,p.y,p.z+ASTEROID_EPSILON), id);\n    n = normalize(n-map_detailed(p, id));\n    \n    asteroidUnTransForm( n, id );\n    return n;\n}\n\nvec2 asteroidSpheretracing(vec3 ori, vec3 dir, vec3 id) {\n\n    asteroidTransForm( ori, id );\n    asteroidTransForm( dir, id );\n    \n    vec2 td = vec2(0.0);\n    for(int i = 0; i < ASTEROID_NUM_STEPS; i++) {\n        vec3 p = ori + dir * td.x;\n        td.y = map(p, id);\n        if(td.y < ASTEROID_TRESHOLD) break;\n        td.x += (td.y-ASTEROID_TRESHOLD) * 0.9;\n    }\n    return td;\n}\n\n\/\/ stone\nvec3 asteroidGetStoneColor(vec3 p, float c, vec3 l, vec3 n, vec3 e) {\n   vec3 color = RING_COLOR_1;\n        \n\tfloat fresnel = .5*pow(1.0-abs(dot(n,e)),5.);\n    color = mix( diffuse(n,l)*color*SUN_COLOR, SUN_COLOR*specular(n,l,e,3.0),fresnel);    \n    \n    return color;\n}\n\n\n\/\/-----------------------------------------------------\n\/\/ Ring (by me ;))\n\/\/-----------------------------------------------------\n\nvec3 ringShadowColor( const in vec3 ro ) {\n    if( iSphere( ro, SUN_DIRECTION, vec4( 0., 0., 0., EARTH_RADIUS ) ) > 0. ) {\n        return vec3(0.);\n    }\n    return vec3(1.);\n}\n\nbool ringMap( const in vec3 ro ) {\n    return ro.z < RING_HEIGHT\/RING_VOXEL_STEP_SIZE && hash(ro)<.5;\n}\n\nvec4 renderRingNear( const in vec3 ro, const in vec3 rd ) { \n\/\/ find startpoint \n    float d1 = iPlane( ro, rd, vec4( 0., 0., 1., RING_HEIGHT ) );\n    float d2 = iPlane( ro, rd, vec4( 0., 0., 1., -RING_HEIGHT ) );\n   \n    if( d1 < 0. && d2 < 0. ) return vec4( 0. );\n    \n    float d = min( max(d1,0.), max(d2,0.) );\n    \n    if( d > ASTEROID_MAX_DISTANCE ) return vec4( 0. );\n    \n    vec3 ros = ro + rd*d;\n    \n    \/\/ avoid precision problems..\n    vec2 mroxy = mod(ros.xy, vec2(5.));\n    vec2 roxy = ros.xy - mroxy;\n    ros.xy -= roxy;\n    \n    ros \/= RING_VOXEL_STEP_SIZE;\n    \n\tvec3 pos = floor(ros);\n\tvec3 ri = 1.0\/rd;\n\tvec3 rs = sign(rd);\n\tvec3 dis = (pos-ros + 0.5 + rs*0.5) * ri;\n\t\n    float alpha = 0., dint;\n\tvec3 offset = vec3(0.), id, asteroidro;\n    vec2 asteroid;\n    \n\tfor( int i=0; i<RING_VOXEL_STEPS; i++ ) {\n\t\tif( ringMap(pos) ) {\n            id = hash33(pos);\n            offset = id*(1.-2.*ASTEROID_RADIUS)+ASTEROID_RADIUS;\n            dint = iSphere( ros, rd, vec4(pos+offset, ASTEROID_RADIUS) );\n            \n#ifdef SHOW_ASTEROIDS   \n            if( dint > 0. ) {\n                asteroidro = ros+rd*dint-(pos+offset);\n    \t        asteroid = asteroidSpheretracing( asteroidro, rd, id );\n\t\t\t\t\n                if( asteroid.y < .1 ) {\n\t                alpha = 1.;\n        \t    \tbreak;\t    \n                }\n            }\n#else\n        if( dint > 0. ) {\n            alpha = 1.;\n            break;\t    \n        }\n#endif\n        }\n\t\tvec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n    \n    if( alpha > 0. ) {\n        \n#ifdef SHOW_ASTEROIDS            \n        vec3 intersection = ros + rd*(asteroid.x+dint);\n        vec3 n = asteroidGetNormal( asteroidro + rd*asteroid.x, id );\n#else\n        vec3 intersection = ros + rd*dint;\n        vec3 n = nSphere( intersection, vec4(pos+offset, ASTEROID_RADIUS) );     \n#endif\n        vec3 col = asteroidGetStoneColor(intersection, .1, SUN_DIRECTION, n, rd);\n\n        intersection *= RING_VOXEL_STEP_SIZE;\n        intersection.xy += roxy;\n        col *= ringShadowColor( intersection );\n         \n\t    return vec4( col, 1.-smoothstep(0.4*ASTEROID_MAX_DISTANCE, 0.5* ASTEROID_MAX_DISTANCE, distance( intersection, ro ) ) );\n    }\n    \n\treturn vec4(0.);\n}\n\n\/\/-----------------------------------------------------\n\/\/ Ring (by me ;))\n\/\/-----------------------------------------------------\n\nvec4 renderRingFar( const in vec3 ro, const in vec3 rd, inout float maxd ) {\n    \/\/ intersect plane\n    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\n    \n    if( d > 0. && d < maxd ) {\n        maxd = d;\n\t    vec3 intersection = ro + rd*d;\n        float l = length(intersection.xy);\n        \n        if( l > RING_INNER_RADIUS && l < RING_OUTER_RADIUS ) {\n            float dens = .5 + .5 * (.2+.8*noise( l*.07 )) * (.5+.5*noise(intersection.xy));\n            vec3 col = mix( RING_COLOR_1, RING_COLOR_2, abs( noise(l*0.2) ) ) * abs(dens) * 1.5;\n            \n            col *= ringShadowColor( intersection );\n    \t\tcol *= .8+.3*diffuse( vec3(0,0,1), SUN_DIRECTION );\n\t\t\tcol *= SUN_COLOR;\n            return vec4( col, dens );\n        }\n    }\n    return vec4(0.);\n}\n\nvec4 renderRing( const in vec3 ro, const in vec3 rd, inout float maxd ) {\n    vec4 far = renderRingFar( ro, rd, maxd );\n\t\n    float l = length( ro.xy );\n    \n    \/\/ detail needed ?\n    \n    if( abs(ro.z) < RING_HEIGHT+RING_DETAIL_DISTANCE \n        && l < RING_OUTER_RADIUS+RING_DETAIL_DISTANCE \n        && l > RING_INNER_RADIUS-RING_DETAIL_DISTANCE ) {\n     \t\n\t    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\n        float detail = mix( .5 * noise( fract(ro.xy+rd.xy*d) * 92.1)+.25, 1., smoothstep( 0.,RING_DETAIL_DISTANCE, d) );\n        far.xyz *= detail;    \n    }\n    \n\t\/\/ are asteroids neaded ?\n    if( abs(ro.z) < RING_HEIGHT+ASTEROID_MAX_DISTANCE \n        && l < RING_OUTER_RADIUS+ASTEROID_MAX_DISTANCE \n        && l > RING_INNER_RADIUS-ASTEROID_MAX_DISTANCE ) {\n        \n        vec4 near = renderRingNear( ro, rd );\n        far = mix( far, near, near.w );\n        maxd=0.;\n    }\n    \n    return far;\n}\n\n\/\/-----------------------------------------------------\n\/\/ Planet (by me ;))\n\/\/-----------------------------------------------------\n\nvec4 renderStars( const in vec3 rd ) {\n\tvec3 rds = rd;\n\tvec3 col = vec3(0);\n    float v = 1.0\/( 2. * ( 1. + rds.z ) );\n    \n    vec2 xy = vec2(rds.y * v, rds.x * v);\n    float s = noise(rds*134.);\n \/\/   s += noise_3(rds*370.);\n    s += noise(rds*470.);\n    s = pow(s,19.0) * 0.00001;\n    if (s > 0.5) {\n        vec3 backStars = vec3(s)*.5 * vec3(0.95,0.8,0.9); \n        col += backStars;\n    }\n\treturn   vec4( col, 1 ); \n} \n\n\/\/-----------------------------------------------------\n\/\/ Planet (by me ;))\n\/\/-----------------------------------------------------\n\nvec4 renderPlanet( const in vec3 ro, const in vec3 rd, inout float maxd ) {\n    float d = iSphere( ro, rd, vec4( 0., 0., 0., EARTH_RADIUS ) );\n                      \n\tif( d < 0. || d > maxd) {\n        return vec4(0);\n\t}\n    maxd = d;\n    vec3 col = vec3( .2, 7., 4. ) * 0.4;\n    \n    col *= diffuse( normalize( ro+rd*d ), SUN_DIRECTION ) * SUN_COLOR;\n                 \n    float m = MAX;\n    col *= (1. - renderRingFar( ro+rd*d, SUN_DIRECTION, m ).w );\n    \n \treturn vec4( col, 1 ); \n}\n\n\/\/-----------------------------------------------------\n\/\/ Atmospheric Scattering by GLtracy\n\/\/ \n\/\/ https:\/\/www.shadertoy.com\/view\/lslXDr\n\/\/-----------------------------------------------------\n\n\/\/ scatter const\nconst float K_R = 0.166;\nconst float K_M = 0.0025;\nconst float E = 14.3; \t\t\t\t\t\t\/\/ light intensity\nconst vec3  C_R = vec3( 0.3, 0.7, 1.0 ); \t\/\/ 1 \/ wavelength ^ 4\nconst float G_M = -0.85;\t\t\t\t\t\/\/ Mie g\n\nconst float SCALE_H = 4.0 \/ ( EARTH_ATMOSPHERE );\nconst float SCALE_L = 1.0 \/ ( EARTH_ATMOSPHERE );\n\nconst int NUM_OUT_SCATTER = 8;\nconst float FNUM_OUT_SCATTER = 8.0;\n\nconst int NUM_IN_SCATTER = 8;\nconst float FNUM_IN_SCATTER = 8.0;\n\n\n\/\/ ray intersects sphere\n\/\/ e = -b +\/- sqrt( b^2 - c )\nvec2 ray_vs_sphere( vec3 p, vec3 dir, float r ) {\n\tfloat b = dot( p, dir );\n\tfloat c = dot( p, p ) - r * r;\n\t\n\tfloat d = b * b - c;\n\tif ( d < 0.0 ) {\n\t\treturn vec2( MAX, -MAX );\n\t}\n\td = sqrt( d );\n\t\n\treturn vec2( -b - d, -b + d );\n}\n\n\/\/ Mie\n\/\/ g : ( -0.75, -0.999 )\n\/\/      3 * ( 1 - g^2 )               1 + c^2\n\/\/ F = ----------------- * -------------------------------\n\/\/      2 * ( 2 + g^2 )     ( 1 + g^2 - 2 * g * c )^(3\/2)\nfloat phase_mie( float g, float c, float cc ) {\n\tfloat gg = g * g;\n\t\n\tfloat a = ( 1.0 - gg ) * ( 1.0 + cc );\n\n\tfloat b = 1.0 + gg - 2.0 * g * c;\n\tb *= sqrt( b );\n\tb *= 2.0 + gg;\t\n\t\n\treturn 1.5 * a \/ b;\n}\n\n\/\/ Reyleigh\n\/\/ g : 0\n\/\/ F = 3\/4 * ( 1 + c^2 )\nfloat phase_reyleigh( float cc ) {\n\treturn 0.75 * ( 1.0 + cc );\n}\n\nfloat density( vec3 p ){\n\treturn exp( -( length( p ) - EARTH_RADIUS ) * SCALE_H );\n}\n\nfloat optic( vec3 p, vec3 q ) {\n\tvec3 step = ( q - p ) \/ FNUM_OUT_SCATTER;\n\tvec3 v = p + step * 0.5;\n\t\n\tfloat sum = 0.0;\n\tfor ( int i = 0; i < NUM_OUT_SCATTER; i++ ) {\n\t\tsum += density( v );\n\t\tv += step;\n\t}\n\tsum *= length( step ) * SCALE_L;\n\t\n\treturn sum;\n}\n\nvec4 in_scatter( vec3 o, vec3 dir, vec2 e, vec3 l ) {\n\tfloat len = ( e.y - e.x ) \/ FNUM_IN_SCATTER;\n\tvec3 step = dir * len;\n\tvec3 p = o + dir * e.x;\n\tvec3 v = p + dir * ( len * 0.5 );\n\n    float sumdensity = 0.;\n\tvec3 sum = vec3( 0.0 );\n\n    for ( int i = 0; i < NUM_IN_SCATTER; i++ ) {\n\t\tvec2 f = ray_vs_sphere( v, l, EARTH_RADIUS + EARTH_ATMOSPHERE );\n\t\tvec3 u = v + l * f.y;\n\t\t\n\t\tfloat n = ( optic( p, v ) + optic( v, u ) ) * ( PI * 4.0 );\n\t\t\n        float dens = density( v );\n        \n\t    float m = MAX;\n\t\tsum += dens * exp( -n * ( K_R * C_R + K_M ) ) \n    \t\t* (1. - renderRingFar( u, SUN_DIRECTION, m ).w );\n        \n\t\tsumdensity += dens;\n        \n\t\tv += step;\n\t}\n\tsum *= len * SCALE_L;\n\t\n\tfloat c  = dot( dir, -l );\n\tfloat cc = c * c;\n\t\n\treturn vec4( sum * ( K_R * C_R * phase_reyleigh( cc ) + K_M * phase_mie( G_M, c, cc ) ) * E, sumdensity * len * SCALE_L);\n}\n\nvec4 renderAtmospheric( const in vec3 ro, const in vec3 rd, inout float d ) {\n\tvec2 e = ray_vs_sphere( ro, rd, EARTH_RADIUS + EARTH_ATMOSPHERE );\n\tif ( e.x > e.y ) {\n        d = MAX;\n\t\treturn vec4(0.);\n\t}\n\t\n\tvec2 f = ray_vs_sphere( ro, rd, EARTH_RADIUS + 3. );\n\te.y = min( e.y, f.x );\n\td = e.y;\n    \n    return in_scatter( ro, rd, e, SUN_DIRECTION );\n}\n\n\/\/-----------------------------------------------------\n\/\/ Lens flare by musk\n\/\/\n\/\/ https:\/\/www.shadertoy.com\/view\/4sX3Rs\n\/\/-----------------------------------------------------\n\nvec3 lensflare(vec2 uv,vec2 pos) {\n\tvec2 main = uv-pos;\n\tvec2 uvd = uv*(length(uv));\n\t\n\tfloat f0 = 1.5\/(length(uv-pos)*16.0+1.0);\n\t\n\tfloat f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;\n\n\tfloat f2 = max(1.0\/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;\n\tfloat f22 = max(1.0\/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;\n\tfloat f23 = max(1.0\/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;\n\t\n\tvec2 uvx = mix(uv,uvd,-0.5);\n\t\n\tfloat f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\n\tfloat f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\n\tfloat f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\n\t\n\tvec3 c = vec3(.0);\n\t\n\tc.r+=f2+f4; c.g+=f22+f42; c.b+=f23+f43;\n\tc = c*.5 - vec3(length(uvd)*.05);\n\tc+=vec3(f0);\n\t\n\treturn c;\n}\n\n\/\/-----------------------------------------------------\n\/\/ cameraPath\n\/\/-----------------------------------------------------\n\nvec3 pro, pta, pup;\nfloat dro, dta, dup;\n\nvoid camint( inout vec3 ret, const in float t, const in float duration, const in vec3 dest, inout vec3 prev, inout float prevt ) {\n\n    if( t >= prevt && t <= prevt+duration ) {\n    \tret = mix( prev, dest, smoothstep(prevt, prevt+duration, t) );\n    }\n    \n    prev = dest;\n    prevt += duration;\n}\n\nvoid cameraPath( in float t, out vec3 ro, out vec3 ta, out vec3 up ) {\n    t = mod( t, 66. );\n    \n    dro = dta = dup = 0.;\n    \n    pro = ro = vec3(-6300. ,-5000. ,1500. );\n    pta = ta = vec3(    0. ,    0. ,   0. );\n    pup = up = vec3(    0. ,    0.2,   1. ); \n \n  \n    camint( ro, t, 5., vec3(-4300. ,-1000. , 500. ), pro, dro );\n    camint( ta, t, 5., vec3(    0. ,    0. ,   0. ), pta, dta );\n    camint( up, t, 7., vec3(    0. ,    0.1,   1. ), pup, dup ); \n    \n\/\/    camint( ro, t, 5., vec3(-3300. , 1000. , 200. ), pro, dro );\n\/\/    camint( ta, t, 5., vec3(    0. ,    0. ,   0. ), pta, dta );\n\/\/    camint( up, t, 6., vec3(    0. ,  -0.3,    1. ), pup, dup ); \n    \n    camint( ro, t, 8., vec3(-2000. , 1600. , 200. ), pro, dro );\n    camint( ta, t, 5., vec3(    0. ,  700. ,-100. ), pta, dta );\n    camint( up, t, 4., vec3(    0. ,  -0.3,    1. ), pup, dup ); \n    \n\n    camint( ro, t, 3., vec3(-1355. , 1795. , 1.2 ), pro, dro );\n    camint( ta, t, 1., vec3(    0. , 300. ,-600. ), pta, dta );\n    camint( up, t, 6., vec3(    0. ,  0.1,    1. ), pup, dup );\n\n    camint( ro, t, 15., vec3(-1354.95 , 1795.11 , 1.19 ), pro, dro );\n    camint( ta, t, 19., vec3(    0. , 100. ,   600. ), pta, dta );\n    camint( up, t, 14., vec3(    0. ,  0.3,    1. ), pup, dup );\n    \n    \n    camint( ro, t, 7., vec3(-1354.93 , 1795.51 , 1.4 ), pro, dro );\n    camint( ta, t, 7., vec3(    0. , 0. , 0. ), pta, dta );\n    camint( up, t, 7., vec3(    0. ,  0.25,    1. ), pup, dup );\n    \n    \n    camint( ro, t, 7., vec3(2900.5 , 3102. , 200.5 ), pro, dro );\n    camint( ta, t, 7., vec3(    0. , 0. , 0. ), pta, dta );\n    camint( up, t, 6., vec3(    0. ,  0.2,    1. ), pup, dup );\n    \n    camint( ro, t, 11., vec3(4102. , -2900. , 450. ), pro, dro );\n    camint( ta, t, 11., vec3(    0. ,   -100. ,   0. ), pta, dta );\n    camint( up, t, 18., vec3(    0. ,    0.15,   1. ), pup, dup ); \n    \n    camint( ro, t, 10., vec3(-6300. ,-5000. , 1500. ), pro, dro );\n    camint( ta, t, 10., vec3(    0. ,    0. ,   0. ), pta, dta );\n    camint( up, t, 3., vec3(    0. ,    0.2,   1. ), pup, dup ); \n    \n    up = normalize( up );\n}\n\n\/\/-----------------------------------------------------\n\/\/ mainImage\n\/\/-----------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    \n    vec2 p = -1.0 + 2.0 * (fragCoord.xy) \/ iResolution.xy;\n    p.x *= iResolution.x\/iResolution.y;\n    \n    \/\/ black bands\n    vec2 bandy = vec2(.1,.9);\n    if( uv.y < bandy.x || uv.y > bandy.y ) {\n        fragColor = vec4(0.,0.,0.,1.);\n        return;\n    }\n    \n    \/\/ camera\n\tvec3 ro, ta, up;\n    cameraPath( iGlobalTime*.7, ro, ta, up );\n      \n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,up) );\n    vec3 vv = normalize( cross(uu,ww));\n\tvec3 rd = normalize( -p.x*uu + p.y*vv + 2.2*ww );\n    \n    float maxd = MAX;  \n\tvec3 col = renderStars( rd ).xyz;\n    \n    vec4 planet = renderPlanet( ro, rd, maxd );       \n    if( planet.w > 0. ) col.xyz = planet.xyz;\n    \n    float atmosphered = MAX;\n    vec4 atmosphere = renderAtmospheric( ro, rd, atmosphered );\n    col = col * (1.-atmosphere.w ) + atmosphere.xyz; \n\n    vec4 ring = renderRing( ro, rd, maxd );\n    if( ring.w > 0. && atmosphered < maxd ) {\n\t    ring.xyz = ring.xyz * (1.-atmosphere.w ) + atmosphere.xyz; \n    }\n    col = col * (1.-ring.w ) + ring.xyz;\n    \n    \/\/ post processing\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\tcol *= vec3(1.,0.99,0.95);   \n\tcol = clamp(1.06*col-0.03, 0., 1.);      \n    \n    \n\tvec2 sunuv =  2.7*vec2( dot( SUN_DIRECTION, -uu ), dot( SUN_DIRECTION, vv ) );\n\tfloat flare = dot( SUN_DIRECTION, normalize(ta-ro) );\n\tcol += vec3(1.4,1.2,1.0)*lensflare(p, sunuv)*clamp( flare+.3, 0., 1.);\n    \n    fragColor = vec4( col ,1.0);\n}\n","name":"","description":"","type":"image"},{"inputs":[],"outputs":[{"channel":"0"}],"code":"\n\/\/----------------------------------------------------------------------\n\/\/ Wind function by Dave Hoskins https:\/\/www.shadertoy.com\/view\/4ssXW2\n\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453123);\n}\nvec2 Hash( vec2 p) {\n    return vec2( hash(p.x), hash(p.y) );\n}\n\n\/\/--------------------------------------------------------------------------\nvec2 Noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 res = mix(mix( Hash(p + 0.0), Hash(p + vec2(1.0, 0.0)),f.x),\n                   mix( Hash(p + vec2(0.0, 1.0) ), Hash(p + vec2(1.0, 1.0)),f.x),f.y);\n    return res-.5;\n}\n\n\/\/--------------------------------------------------------------------------\nvec2 FBM( vec2 p ) {\n    vec2 f;\n\tf  = 0.5000\t * Noise(p); p = p * 2.32;\n\tf += 0.2500  * Noise(p); p = p * 2.23;\n\tf += 0.1250  * Noise(p); p = p * 2.31;\n    f += 0.0625  * Noise(p); p = p * 2.28;\n    f += 0.03125 * Noise(p);\n    return f;\n}\n\n\/\/--------------------------------------------------------------------------\nvec2 Wind(float n) {\n    vec2 pos = vec2(n * (162.017331), n * (132.066927));\n    vec2 vol = Noise(vec2(n*23.131, -n*42.13254))*1.0 + 1.0;\n    \n    vec2 noise = vec2(FBM(pos*33.313))* vol.x *.5 + vec2(FBM(pos*4.519)) * vol.y;\n    \n\treturn noise;\n}\n\n\/\/----------------------------------------------------------------------\n\n\n\nvec2 mainSound(float time) {\n    \/\/16 - 38\n \/\/   time -= 7.5;\n    time *= .7;\n    float vol = 1.-smoothstep(14.,16.5, time);\n    vol += smoothstep(34.5,38., time);\n    vol = vol*.8+.2;\n    \n\treturn Wind(time*.05) * vol;\n}","name":"","description":"","type":"sound"}]}}