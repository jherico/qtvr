{"Shader":{"ver":"0.1","info":{"id":"Mt23R1","date":"1427050332","viewed":779,"name":"rykscape","username":"ryk","description":"An idea so stupid I had to implement it. My shader equivalent of a theme song.","likes":4,"published":3,"flags":0,"tags":["space","dither","netscape"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"struct Ray\n{\n\tvec3 org;\n\tvec3 dir;\n};\n\nstruct VolData\n{\n    vec3 bgCol;\n    vec3 fgCol;\n};\n\t\nstruct Hit\n{\n\tfloat dist;\n\tfloat index;\n};\n\nfloat hash(vec2 p)\n{\n    return fract(sin((mod(p.x*p.y*87328.24,1.0)+mod(p.y*923.123,1.0)))*34345.965 );\n}\n\t\nfloat time;\n\nfloat sphere(vec3 pos)\n{\n    return length(pos) - 4.;\n}\n\t\nHit scene(vec3 pos)\n{\n\treturn Hit(sphere(pos), 0.);\n}\n\nHit raymarch(Ray ray)\n{\n\tvec3 pos;\n\tHit hit;\n\thit.dist = 0.;\n\tHit curHit;\n\tfor (int i = 0; i < 30; i++)\n\t{\n\t\tpos = ray.org + hit.dist * ray.dir;\n\t\tcurHit = scene(pos);\n\t\thit.dist += curHit.dist;\n\t}\n\thit.index = curHit.index;\n\thit.index = curHit.dist < 0.01 ? hit.index : -1.;\n\treturn hit;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    scene(pos+eps.xyy).dist - scene(pos-eps.xyy).dist,\n\t    scene(pos+eps.yxy).dist - scene(pos-eps.yxy).dist,\n\t    scene(pos+eps.yyx).dist - scene(pos-eps.yyx).dist );\n\treturn normalize(nor);\n}\n\nvec3 starStart = vec3(-3.,15.,-10.);\nvec3 starEnd = vec3(3.3,-3.,8.);\n\nvec3 foreStarPos()\n{\n    float t = fract(time\/4.);\n    return mix(starStart,starEnd,t);\n}\n\nfloat foreStarDist()\n{\n    return max(0., length(foreStarPos()) - 4.);\n}\n\nvec4 render(Ray ray)\n{\n\tHit hit = raymarch(ray);\n\tvec3 pos = ray.org + hit.dist*ray.dir;\n\tvec3 surfaceCol = vec3(0.5,0.3,.3);\n\tvec3 specCol = vec3(0.5,0.4,.3);\n\tvec3 col = vec3(0.);\n\tif (hit.index != -1.)\n\t{\n\t\tvec3 nor = calcNormal(pos);\n\t\tvec3 l = normalize(foreStarPos() - pos);\n        float inten = max(0.,1.-length(foreStarPos() - pos)\/10.);\n\t\tcol = surfaceCol;\n\t\t\n\t\tfloat diff = clamp(dot(nor,l),0.,1.);\n\t\tvec3 r = normalize(2.*dot(nor,l)*nor-l);\n\t\tvec3 v = normalize(ray.org-pos);\n\t\tfloat spec = clamp(dot(v,r),0.,1.);\n\t\tcol = (diff*col + pow(spec,10.)*specCol)*inten + inten;\n\t}\n\treturn vec4(col, hit.index);\n}\n\nvec3 glow(Ray ray)\n{\n    float minDist = length(ray.org - ray.dir * dot(ray.dir, ray.org)) - 3.9;\n    float inten = max(0.1, 1.-pow(foreStarDist()*.3, 0.8));\n    float noi = sin(time*2. + sin(time*2.2)*2.) + 1.;\n    return vec3(0.2, 0.7, 0.9)\/pow(minDist, 2.) * (inten+noi\/15.) * 0.8;\n}\n\nfloat foreIntensity(vec3 pos)\n{\n    vec3 dir = starEnd - starStart;\n    vec3 c = foreStarPos();\n    vec3 p = pos-c;\n    float a = 0.8;\n    p.yz *= mat2(cos(a), sin(a), -sin(a), cos(a));\n    vec3 stretch = p.z > 0. ? vec3(1.) : vec3(1.,1.,0.1);\n    float dist = length(p*stretch);\n    return max(0., 2.-dist*4.);\n}\n\nfloat backIntensity(vec3 pos, vec3 center, float speed, float spacing)\n{\n    pos -= center;\n    pos.z -= speed*time;\n    pos.z += spacing\/2.;\n    pos.z = mod(pos.z, spacing);\n    pos.z -= spacing\/2.;\n    vec3 stretch = pos.z > 0. ? vec3(1.) : vec3(1.,1.,.05);\n    float dist = length(pos*stretch);\n    return max(0., 2.-dist*2.);\n}\n\nVolData shootingStars(Ray ray)\n{\n    float dist = 0.;\n    vec3 p;\n    float fIntensity = 0.;\n    float bIntensity = 0.;\n    float a = 0.8;\n    for (float i = 0.; i < 50.; i+=1.)\n    {\n        p = ray.org + ray.dir * dist * i;\n        dist += 0.01;\n        fIntensity += foreIntensity(p);\n        p.yz *= mat2(cos(a), sin(a), -sin(a), cos(a));\n        bIntensity += backIntensity(p, vec3(-8., -1., 0.), 20., 50.);\n        bIntensity += backIntensity(p, vec3(-4., 9., 0.), 20., 60.);\n        bIntensity += backIntensity(p, vec3(-13., 5., 0.), 40., 80.);\n    }\n    VolData v;\n    v.fgCol = vec3(.8,.5,.4) * fIntensity;\n    v.bgCol = vec3(.8,.5,.4) * bIntensity*0.6;\n    v.bgCol += vec3(.5,.7,.8) * pow(hash(ray.dir.yz), 50.);\n   \n    return v;\n}\n\nRay createRay(vec3 center, vec3 lookAt, vec3 up, vec2 uv, float fov, float aspect)\n{\n\tRay ray;\n\tray.org = center;\n\tvec3 dir = normalize(lookAt - center);\n\tup = normalize(up - dir*dot(dir,up));\n\tvec3 right = cross(dir, up);\n\tuv = 2.*uv - vec2(1.);\n\tfov = fov * 3.1415\/180.;\n\tray.dir = dir + tan(fov\/2.) * right * uv.x + tan(fov\/2.) \/ aspect * up * uv.y;\n\tray.dir = normalize(ray.dir);\t\n\treturn ray;\n}\n\nvoid backBar(vec2 uv, inout vec4 col)\n{\n    float w = 0.1;\n    float h = 0.7;\n    float mar = 0.002;\n    float l =\n        step(0., uv.x)\n        * (1. - step(w, uv.x)) \n        * smoothstep(0., mar, uv.y)\n        * (1. - smoothstep(h-mar, h, uv.y));\n    col.rgb = mix(col.rgb, vec3(1.), l);\n}\n\nvoid lserif(vec2 uv, inout vec4 col)\n{\n    float c = 0.05;\n    float w = 0.2;\n    float h = 0.03;\n    float mar = 0.002;\n    float l =\n        step(-w\/2.+c, uv.x)\n        * (1. - step(w\/2.+c, uv.x)) \n        * step(0., uv.y)\n        * (1. - step(h, uv.y));\n    float rad = w\/2.-c;\n    vec2 lp = uv + vec2( w\/2. - c, -h-rad);\n    float lc = smoothstep(rad-mar, rad+mar, length(lp)) * step(0., lp.x) * step(0., -lp.y)\n        * (1.-step(rad, -lp.y)) * (1.-step(rad, lp.x));\n    vec2 rp = uv + vec2( -w\/2. - c, -h-rad);\n    float rc = smoothstep(rad-mar, rad+mar, length(rp)) * step(0., -rp.x) * step(0., -rp.y)\n        * (1.-step(rad, -rp.y)) * (1.-step(rad, -rp.x));\n    col.rgb = mix(col.rgb, vec3(1.), l + lc + rc);\n}\n\nvoid userif(vec2 uv, inout vec4 col)\n{\n    float c = 0.05;\n    float w = 0.2;\n    float h = 0.03;\n    float mar = 0.002;\n    float l =\n        step(-w\/2.+c, uv.x)\n        * (1. - step(0., uv.x)) \n        * smoothstep(0., mar, uv.y)\n        * (1. - step(h, uv.y));\n    float rad = w\/2.-c;\n    vec2 lp = uv + vec2( w\/2. - c, -h-rad);\n    float lc = smoothstep(rad-mar, rad+mar, length(lp)) * step(0., lp.x) * step(0., -lp.y)\n        * (1.-step(rad, -lp.y)) * (1.-step(rad, lp.x));\n    col.rgb = mix(col.rgb, vec3(1.),  l+lc);\n}\n\nvoid roundThing(vec2 uv, inout vec4 col)\n{\n    float mar = 0.003;\n    float outRad = 0.18;\n    float inRad = 0.15;\n    float rw = 0.08;\n    uv.x -= rw;\n    float outerCircle = smoothstep(outRad+mar, outRad, length(uv)) * step(0., uv.x);\n    float rect = step(-rw, uv.x) * (1. - step(0., uv.x))\n        * (1.-smoothstep(outRad, outRad+mar, uv.y)) * smoothstep(-outRad-mar,-outRad, uv.y);\n    float innerCircle = smoothstep(inRad-mar, inRad, length(uv+vec2(rw,0.))) ;\n    col.rgb = mix(col.rgb, vec3(1.), (outerCircle + rect) * innerCircle);\n}\n\nvoid diagBar(vec2 uv, inout vec4 col)\n{\n    float m = 8.;\n    float d = 0.11;\n    float h = 0.2;\n    float lowT = sin(uv.x*m)*h;\n    float upT = sin((uv.x-d)*m)*h;\n    float mar = 0.003;\n    float l =\n        smoothstep(lowT, lowT+mar, uv.y)\n        * (1. - smoothstep(upT, upT+mar, uv.y));\n    float doDraw = col.w != 0. ? 1. : 0.;\n    col.rgb = mix(col.rgb, vec3(1.), l*doDraw);\n}\n\nvoid drawR(vec2 uv, inout vec4 col)\n{\n    uv += vec2(.08,.05);\n    backBar(uv-vec2(.4,.2), col);\n    lserif(uv-vec2(.4,.2), col);\n    userif(uv*vec2(1.,-1) + vec2(-0.4, 0.9), col);\n    roundThing(uv-vec2(.5,.717), col);\n    diagBar(uv-vec2(0.22,.36), col);\n}\n\nvec2 quantize(vec2 uv, float steps)\n{\n    return uv - fract(uv*steps)\/steps;\n}\n\nvec3 quantizeColor(vec3 col, vec2 uv)\n{\n    vec3 noi = vec3(hash(uv + vec2(0.3,0.)*sin(time)),\n                    hash(uv+ vec2(0.3)*sin(time)),\n                    hash(uv+ vec2(0.,.3)*sin(time))) - 0.5;\n    col += noi\/5.;\n    return col - fract(col*5.)\/5.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord \/ iResolution.xy;\n\ttime = iGlobalTime ;\n\tvec3 cameraPos = vec3(3.,5.,0.);\n\tvec3 lookAt = vec3(0.,5.,0.);\n\tvec3 up = vec3(0.,1.,0.);\n\tfloat aspect = iResolution.x\/iResolution.y;\n    vec2 uvQuant = quantize(uv, 64.);\n\tRay rayQuant = createRay(cameraPos, lookAt, up, uvQuant, 90., aspect);\n\tRay ray = createRay(cameraPos, lookAt, up, uv, 90., aspect);\n\t\/\/vec4 col = render(ray);\n\tvec4 col = render(rayQuant);\n    vec3 glowCol = glow(rayQuant);\n    VolData shots = shootingStars(rayQuant);\n    col.rgb += (glowCol + shots.bgCol) * col.w * -1. + shots.fgCol;\n    col.rgb = quantizeColor(col.rgb, uvQuant);\n    drawR(uv, col);\n\tfragColor = vec4(col.rgb,1.0);\n}\n\n","name":"","description":"","type":"image"}]}}