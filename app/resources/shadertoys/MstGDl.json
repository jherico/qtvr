{"Shader":{"ver":"0.1","info":{"id":"MstGDl","date":"1452933227","viewed":251,"name":"Voxel Editor","username":"elias","description":"Mouse = rotate view<br\/>ESDF = Move<br\/>R = insert voxel<br\/><br\/>See shader comments for more info.","likes":4,"published":3,"flags":48,"tags":["raytracing","voxel","editor"],"hasliked":0},"renderpass":[{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/*\n\n    One pixel stores 4 voxels.\n    Each color channel holds three coordinates in the form of 0.XXYYZZ\n    With 4x4 pixels we have a total of 64 voxels to play with. (change size below)\n\n    I recommend pausing the shader for easier control.\n\n*\/\n\n#define SIZE 4. \/\/ change in Buf A too\n\n#define NCUBES (SIZE*SIZE*4.)\n#define CSIZE (0.5\/NCUBES)\n#define T iGlobalTime\n#define load(a,b) texture2D(b,(a+0.5)\/iResolution.xy)\n\nstruct Ray    { vec3 o, d; };\nstruct Camera { vec3 p, d; };\nstruct Hit    { vec3 p, n; float t; int id; };\nstruct Plane  { vec3 n; float s; };\n\n\/* ===================== *\/\n\/* ====== Globals ====== *\/\n\/* ===================== *\/\n\nCamera _cam = Camera(vec3(0,1,-1)*0.2, vec3(0,-1,1));\n\nconst int _numObjects = 3;\nHit _objects[_numObjects];\n\nHit _miss = Hit(vec3(0),vec3(0),-1e10,0);\nRay _r;\n\nvec2 _uv;\nvec3 _n;\nvec3 _cursor;\n\nfloat _tmin,_tmax;\nint _ignore = -1;\n\n\/* =================== *\/\n\/* ====== Utils ====== *\/\n\/* =================== *\/\n\nmat3 rotX(float a){float c=cos(a);float s=sin(a);return mat3(1,0,0,0,c,-s,0,s,c);}\nmat3 rotY(float a){float c=cos(a);float s=sin(a);return mat3(c,0,-s,0,1,0,s,0,c);}\n\nvec3 getCoords(float n)\n{\n\tfloat x = floor(n*100.);\n\tfloat y = n*10000.;\n\tfloat z = fract(y)*100.;\n\ty = floor(y)-x*100.;\n\n\treturn floor((vec3(x,y+NCUBES\/2.,z)-NCUBES\/2.)\/NCUBES*NCUBES+0.5)\/NCUBES+vec3(CSIZE);\n}\n\n\/* ======================== *\/\n\/* ====== Raytracing ====== *\/\n\/* ======================== *\/\n\nRay lookAt(Camera cam, vec2 c)\n{\n    vec3 dir = normalize(cam.d);\n    vec3 right = normalize(cross(dir,vec3(0,1,0)));\n    vec3 up = cross(right, dir);\n  \n    return Ray(cam.p, normalize(right*c.x + up*c.y + dir));\n}\n\nHit plane(Ray r, vec3 n, float s)\n{\n    float t = dot(n,n*s-r.o)\/dot(n,r.d);\n    return Hit(r.o+r.d*t,n,t,0);\n}\n\nvoid startObject(Ray r)\n{\n    _r = r;\n    _tmax = -1e10;\n    _tmin = 1e10;\n}\n\nvoid join(vec3 n, float s)\n{    \n    float t = (-dot(n,_r.o)+s)\/dot(n,_r.d);\n\n    if (dot(n,_r.d)<0.0)\n    {\n        if(_tmax < t)\n        {\n            _tmax = t;\n            _n = n;\n        }\n    }\n    else\n    {\n        _tmin = min(_tmin,t);\n    }\n}\n\nHit endObject()\n{\n    float t = _tmax < _tmin ? _tmax : -1e10;\n    return Hit(_r.o+_r.d*t,_n,t,0);\n}\n\nHit cube(Ray r, vec3 p, float d)\n{\n    r.o -= p;\n    \n    startObject(r);\n    \n    join(vec3( 0, 1, 0),d);\n    join(vec3( 0,-1, 0),d);\n    join(vec3( 1, 0, 0),d);\n    join(vec3(-1, 0, 0),d);\n    join(vec3( 0, 0, 1),d);\n    join(vec3( 0, 0,-1),d);\n    \n    _r.o += p;\n    \n    return endObject();\n}\n\nbool compare(inout Hit a, Hit b)\n{\n    if (a.t < 0.0 || b.t > 0.0 && b.t < a.t)\n    {\n        a = b;\n        return true;\n    }\n    \n    return false;\n}\n\nHit trace(Ray r)\n{\n    Hit h = _miss;\n    \n    for(float x = 0.; x < SIZE; x++)\n    {\n        for(float y = 0.; y < SIZE; y++)\n        {\n            vec4 n = texture2D(iChannel0, (vec2(x,y)+0.5)\/iResolution.xy);\n\n            if(n.x > 0.0) compare(h,cube(r,getCoords(n.x),CSIZE));\n            if(n.y > 0.0) compare(h,cube(r,getCoords(n.y),CSIZE));\n            if(n.z > 0.0) compare(h,cube(r,getCoords(n.z),CSIZE));\n            if(n.w > 0.0) compare(h,cube(r,getCoords(n.w),CSIZE));\n        }\n    }\n    \n    _objects[0] = plane(r,vec3(0,1,0),0.0);\n\t_objects[1] = h;\n    \n    _objects[2] = _miss;\n    \n    if (_ignore != 2) { _objects[2] = cube(r,_cursor,CSIZE); }\n    \n    h = _objects[0];\n    \n    for (int i = 1; i < _numObjects; i++)\n    {\n        Hit t = _objects[i];\n        \n        if(compare(h,t) == true)\n        {\n            h.id = i;\n        }\n    }\n    \n    return h;\n}\n\n\/* ======================= *\/\n\/* ====== Rendering ====== *\/\n\/* ======================= *\/\n\nvec3 getColor(Hit h)\n{\n    if (h.t <= 0.0) { return vec3(0); }\n    \n    vec3 col = vec3(1);\n    vec3 light = _cam.p; \/\/vec3(0,1,0);\n    \n    for(int i = 0; i < 2; i++)\n    {\n        float diff = max(dot(h.n,normalize(light-h.p)),0.0);\n        float spec = pow(max(dot(reflect(normalize(h.p-light),h.n),normalize(_cam.p)),0.0),100.0);\n        float fog = min(0.9\/exp(length(light-h.p)),1.);\n\n        if (h.id == 0)\n        {\n            float s = CSIZE*4.;\n            float l = length(max(abs(h.p.xz)-0.5,0.)) == 0.0 ? 1.0: 0.0;\n            col *= l*fog;\n            col -= floor(fract(h.p.x\/s+.5*floor(fract(h.p.z\/s)+.5))+.5)*0.05;\n        }\n        else if (h.id == 1)\n        {\n            col = mix(vec3(1,0.8,0.5),col*diff*fog,0.2);\n        }\n        \n        if (h.id == 2)\n        {\n            _ignore = 2;\n            h = trace(lookAt(_cam,_uv));\n            _ignore = -1;\n        }\n        else\n        {\n            if (i==1)\n            {\n                col = mix(col,vec3(0,1,0),(sin(T*4.0)+1.0)\/4.0+0.3);\n            }\n            \n            break;\n        }\n    }\n    \n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    _uv = (2.*fragCoord.xy-iResolution.xy)\/iResolution.xx;\n    \n    vec2 uvm = (2.*iMouse.xy-iResolution.xy)\/iResolution.xx;\n    vec2 rot = load(vec2(iResolution.x-1.,0),iChannel0).xy;\n    vec3 pos = load(vec2(iResolution.x-4.,0),iChannel0).xyz*1e4;\n\n    _cam.p += pos;\n    _cam.d *= rotX(rot.x)*rotY(rot.y);\n\n    _ignore = 2;\n    Hit h = trace(lookAt(_cam,uvm));\n    _cursor = floor(h.p*NCUBES+h.n*0.5)\/NCUBES+vec3(CSIZE);\n    _ignore = -1;\n\n    \n    fragColor = vec4(getColor(trace(lookAt(_cam,_uv))),1);\n}","name":"","description":"","type":"image"},{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define inside(a) (fragCoord.x == a.x+0.5 && fragCoord.y == a.y+0.5)\n#define load(a,b) texture2D(b,(a+0.5)\/iResolution.xy)\n#define save(a,b) if(inside(a)){fragColor=b;return;}\n\n#define SIZE 4.\n#define NCUBES (SIZE*SIZE*4.)\n#define CSIZE (0.5\/NCUBES)\n\nstruct Ray    { vec3 o, d; };\nstruct Camera { vec3 p, d; };\nstruct Hit    { vec3 p, n; float t; int id; };\nstruct Plane  { vec3 n; float s; };\n\n\/* ===================== *\/\n\/* ====== Globals ====== *\/\n\/* ===================== *\/\n\nCamera _cam = Camera(vec3(0,1,-1)*0.2, vec3(0,-1,1));\n \nbool _perspective = true;\nconst int _numObjects = 2;\n \nHit _objects[_numObjects];\nHit _miss = Hit(vec3(0),vec3(0),-1e10,0);\n\nRay _r;\nvec3 _n;\nfloat _tmin,_tmax;\n\n\/* =================== *\/\n\/* ====== Utils ====== *\/\n\/* =================== *\/\n\nmat3 rotX(float a){float c=cos(a);float s=sin(a);return mat3(1,0,0,0,c,-s,0,s,c);}\nmat3 rotY(float a){float c=cos(a);float s=sin(a);return mat3(c,0,-s,0,1,0,s,0,c);}\n\nvec3 getCoords(float n)\n{\n\tfloat x = floor(n*100.);\n\tfloat y = n*10000.;\n\tfloat z = fract(y)*100.;\n\ty = floor(y)-x*100.;\n\n\treturn (vec3(x,y+NCUBES\/2.,z)-NCUBES\/2.)\/NCUBES+vec3(CSIZE);\n}\n\n\nfloat setCoords(vec3 p)\n{\n    float n = 0.0;\n    \n    n += p.x\/1e2;\n    n += p.y\/1e4;\n    n += p.z\/1e6;\n    \n    return n;\n}\n\n\/* ======================== *\/\n\/* ====== Raytracing ====== *\/\n\/* ======================== *\/\n\nRay lookAt(Camera cam, vec2 c)\n{\n    vec3 dir = normalize(cam.d);\n    vec3 right = normalize(cross(dir,vec3(0,1,0)));\n    vec3 up = cross(right, dir);\n \n    if (_perspective == true)    \n    return Ray(cam.p, normalize(right*c.x + up*c.y + dir));\n    else\n    return Ray(cam.p + (right*c.x + up*c.y)*0.5, dir);\n}\n\nvoid startObject(Ray r)\n{\n    _r = r;\n    _tmax = -1e10;\n    _tmin = 1e10;\n}\n\nvoid join(vec3 n, float s)\n{    \n    float t = (-dot(n,_r.o)+s)\/dot(n,_r.d);\n\n    if (dot(n,_r.d)<0.0)\n    {\n        if(_tmax < t)\n        {\n            _tmax = t;\n            _n = n;\n        }\n    }\n    else\n    {\n        _tmin = min(_tmin,t);\n    }\n}\n\nHit endObject()\n{\n    float t = _tmax < _tmin ? _tmax : -1e10;\n    return Hit(_r.o+_r.d*t,_n,t,0);\n}\n\nHit cube(Ray r, vec3 p, float d)\n{\n    r.o -= p;\n    \n    startObject(r);\n    \n    join(vec3( 0, 1, 0),d);\n    join(vec3( 0,-1, 0),d);\n    join(vec3( 1, 0, 0),d);\n    join(vec3(-1, 0, 0),d);\n    join(vec3( 0, 0, 1),d);\n    join(vec3( 0, 0,-1),d);\n    \n    _r.o += p;\n    \n    return endObject();\n}\n\nbool compare(inout Hit a, Hit b)\n{\n    if (a.t < 0.0 || b.t > 0.0 && b.t < a.t)\n    {\n        a = b;\n        return true;\n    }\n    \n    return false;\n}\n\nHit plane(Ray r, vec3 n, float s)\n{\n    float t = dot(n,n*s-r.o)\/dot(n,r.d);\n    return Hit(r.o+r.d*t,dot(n,_r.d)<0.0?-n:n,t,0);\n}\n\nHit trace(Ray r)\n{\n    _objects[0] = plane(r,vec3(0,1,0),0.0001);\n    \n    Hit h = _miss;\n    \n    for(float x = 0.; x < SIZE; x++)\n    {\n        for(float y = 0.; y < SIZE; y++)\n        {\n            vec4 n = texture2D(iChannel0, (vec2(x,y)+0.5)\/iResolution.xy);\n\n            if(n.x > 0.0) compare(h,cube(r,getCoords(n.x),CSIZE));\n            if(n.y > 0.0) compare(h,cube(r,getCoords(n.y),CSIZE));\n            if(n.z > 0.0) compare(h,cube(r,getCoords(n.z),CSIZE));\n            if(n.w > 0.0) compare(h,cube(r,getCoords(n.w),CSIZE));\n        }\n    }\n                                  \n\t_objects[1] = h;\n    \n    h = _objects[0];\n    \n    for (int i = 1; i < _numObjects; i++)\n    {\n        Hit t = _objects[i];\n        \n        if(compare(h,t) == true)\n        {\n            h.id = i;\n        }\n    }\n    \n    return h;\n}\n\n\/* =================== *\/\n\/* ====== Logic ====== *\/\n\/* =================== *\/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy\/iResolution.yy;\n    vec2 uvm = (2.*iMouse.xy-iResolution.xy)\/iResolution.xx;\n    \n    float key_space = texture2D(iChannel3, vec2(32.5\/256.,0)).x;\n    float key_r = texture2D(iChannel3, vec2(82.5\/256.,0)).x;\n\n    fragColor = texture2D(iChannel0, fragCoord.xy\/iResolution.xy);\n\n    \/\/ Drag rotate\n    if (inside(vec2(iResolution.x-1.,0)))\n    {\n\t    vec4 iMouseLast = load(vec2(iResolution.x-2.,0), iChannel0);\n\t    if (iMouseLast.w < 1.0) { iMouseLast.xy = iMouse.xy; }\n        fragColor.yx += (iMouseLast.xy-iMouse.xy)\/iResolution.xy*vec2(-1,1)*2.;\n        return;\n    }\n    \n    \/\/ Last mouse position\n    if (inside(vec2(iResolution.x-2.,0)))\n    {\n        fragColor = iMouse;\n        return;\n    }\n    \n    \/\/ Free spot index\n    if (inside(vec2(iResolution.x-3.,0)))\n    {\n        vec2 c = fragColor.xy*100.;\n        vec4 p = texture2D(iChannel0,(c+0.5)\/iResolution.xy);\n        \n        if      (p.x == 0.0) fragColor.z = 0.1;\n        else if (p.y == 0.0) fragColor.z = 0.2;\n        else if (p.z == 0.0) fragColor.z = 0.3;\n        else if (p.w == 0.0) fragColor.z = 0.4;\n        else\n        {\n            c.x = mod(c.x+1.0,SIZE);\n            if (c.x == 0.0)\n            c.y = mod(c.y+1.0,SIZE);\n            \n            fragColor.xy = c\/100.;\n            fragColor.z = 0.0;\n        }\n        \n        return;\n    }\n    \n    \/\/ Camera movement\n    if (inside(vec2(iResolution.x-4.,0)))\n    {\n        vec2 rot = load(vec2(iResolution.x-1.,0),iChannel0).xy;     \n        _cam.d *= rotX(rot.x)*rotY(rot.y);\n        \n        vec3 right = normalize(cross(_cam.d,vec3(0,1,0)));\n        \n        float key_left  = texture2D(iChannel3, vec2(83.5\/256.,0)).x;\n        float key_up    = texture2D(iChannel3, vec2(69.5\/256.,0)).x;\n        float key_right = texture2D(iChannel3, vec2(70.5\/256.,0)).x;\n        float key_down  = texture2D(iChannel3, vec2(68.5\/256.,0)).x;\n        \n        float x = key_left > 0.0 ? -1. : key_right > 0.0 ? 1. : 0.0;\n        float z = key_down > 0.0 ? -1. : key_up    > 0.0 ? 1. : 0.0;\n\n        fragColor.xyz += (right*x + normalize(_cam.d)*z)\/1e6;\n        \n        return;\n    }\n\n    if (fragCoord.x > SIZE || fragCoord.y > SIZE) discard;\n\n    if (key_space < 1.0 && key_r > 0.0 || key_r > 0.0)\n    {\n        \/\/ Check if pixel is a \"free spot\" candidate\n        vec4 p = load(vec2(iResolution.x-3.,0),iChannel0);\n        if(all(equal(fragCoord-0.5,p.xy*100.))==false) { return; }\n        \n        vec2 rot = load(vec2(iResolution.x-1.,0),iChannel0).xy;\n        vec3 pos = load(vec2(iResolution.x-4.,0),iChannel0).xyz*1e4;\n\n        _cam.p += pos;\n        _cam.d *= rotX(rot.x)*rotY(rot.y);\n\n        \n        \/\/ Cast ray and check if the projection lies in the visible area\n        Hit h = trace(lookAt(_cam,uvm));\n        if (h.t<=0.0 || length(max(abs(h.p.xz)-0.5,0.)) != 0.0) { return; }\n        \n        vec3 q = floor((floor(h.p*NCUBES+0.5*h.n)\/NCUBES+vec3(0.5,0,0.5))*NCUBES+0.5);\n        float n = setCoords(q);\n\n        if      (p.z == 0.1) fragColor.x = n;\n        else if (p.z == 0.2) fragColor.y = n;\n        else if (p.z == 0.3) fragColor.z = n;\n        else if (p.z == 0.4) fragColor.w = n;\n    }\n}","name":"","description":"","type":"buffer"}]}}