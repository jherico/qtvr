{"Shader":{"ver":"0.1","info":{"id":"MddGW2","date":"1452297208","viewed":234,"name":"mapping edit","username":"FabriceNeyret2","description":"drag nodes with mouse to edit the mapping.<br\/>Space to toggle the grid.","likes":8,"published":3,"flags":48,"tags":["mapping","mesh"],"hasliked":0},"renderpass":[{"inputs":[{"id":5,"src":"\/presets\/tex04.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ inspired from https:\/\/www.shadertoy.com\/view\/MstGW2\n\n#define S 80.\n                                                               \/\/ draw segment [a,b]\n#define L(a,b)  O.g+= 1e-1 \/ length( clamp( dot(U-a,v=b-a)\/dot(v,v), 0.,1.) *v - U+a )\n#define T(i,j) texture2D(iChannel0,(.5+S*vec2(i,j))\/iResolution.xy).xy\n    \nfloat cross(vec2 a, vec2 b) { return a.x*b.y - b.x*a.y; }\n#define key(k) ( texture2D(iChannel2,vec2((.5+float(k))\/256.,.75)).x > 0.)\n\n\nvoid mainImage( out vec4 O,  vec2 U )\n{   \n    O -= O; \n    vec2 st=vec2(-1);\n    \n    for (int j=0; j<5; j++) \n    {\n        vec2 v, P00, P01, P10 = T(0,j), P11 = T(0,j+1);\n        \/\/ L(P10,P11);\n        \n        for (int i=0; i<9; i++) \n        {\n            P00=P10, P01=P11, P10 = T(i+1,j), P11=T(i+1,j+1);\n\/*          vec2 M = max(max(P00,P01),max(P10,P11)),\n                 m = min(min(P00,P01),min(P10,P11)),\n                 P = step(m,U)*step(U,M);\n           if (P.x*P.y >= 0.) \/\/ bbox optimization   <><><>  Indeed, makes it costlier !\n*\/            { \n            \/\/ find u,v bilinar coordinates of current pixel within the current mesh cell\n            vec2 AB = P10-P00, CD = P11-P01, AC = P01-P00, D=CD-AB;\n\/*          if (length(D)<1e-5) { \/\/ no u*v term: parallelogramm case\n                float c = cross(AB,AC), u = cross(U-P00,AC)\/c, v = cross(U-P00,AB)\/(-c);\n                if ( min(u,v)>=0. && max(u,v)<=1. ) O=texture2D(iChannel1, (vec2(u,v)+vec2(i,j))\/vec2(9,5));\n                continue;\n            } *\/  \/\/ <><><> never called\n            float c = cross(AC,D), a = cross(U-P00,D)\/c, b = cross(-AB,D)\/c, \/\/ v = a+b.u\n                  A = D.x*b, B = AB.x+AC.x*b +D.x*a, C = P00.x-U.x+AC.x*a,   \/\/ P2(u) = 0\n                  d = B*B - 4.*A*C;\n            if (d>=0.) { \/\/ solve P2(u), then v. if (u,v) in [0,1]^2, cur pixel is in this cell\n                d = sqrt(d); \n                float u;\n                if (abs(A)<1e-5) u = -C\/B; \/\/ P2() is a P1()\n                else {                     \/\/ full P2()\n                  u = (-B+d)\/(2.*A);\n                  if (u<0. || u>1.) u = (-B-d)\/(2.*A);\n                }\n                if (u>=0. && u<=1.) {\n                    float v = a+b*u;\n                    if (v>=0. && v<=1.)\n                 \/\/ O += (1.-O.a)* \/\/ if 2 patches clame the same pixel\n                 \/\/     texture2D(iChannel1, \n                        st = (\n                                  (vec2(u,v)+vec2(i,j))\/vec2(9,5)); \/\/texture patch\n                }\n            }}\n            \n            if (!key(32)) {\n                L(P00,P01); L(P00,P10);   \/\/ draw one vertical and one horizontal segment\n                 O += smoothstep(5.,3.,length(U-T(i,j)));  \/\/ draw points\n            }\n        }\n    }\n    if (st.x>=0.) O += texture2D(iChannel1, st);\n}","name":"","description":"","type":"image"},{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ inspired from https:\/\/www.shadertoy.com\/view\/MstGW2\n\n\/\/ each pixel of BufA encodes a pair of vertex coordinates.\n\/\/ It's Image shader responsability to pick and connect some of these.\n\n\nvoid mainImage( out vec4 O,  vec2 uv )\n{\n    vec2 U = uv\/iResolution.xy;\n    \n    O = texture2D(iChannel0,U);\n  \/\/if (iFrame==0) {\n    if (length(O.xy)==0.) {   \/\/ better if further increase of window size\n        O.xy = uv + 10.*(2.*texture2D(iChannel1,U).xy-1.);  \/\/ initial jittered coords\n        return;\n    }\n    else  {\n        float a = 10.*iGlobalTime + uv.x+117.1*uv.y; \/\/ decorelates rotation angle\n        O.xy += .2* vec2(cos(a),sin(a));       \/\/ shake coords\n    }\n    \n    if ( length(iMouse.xy-O.xy) < 10. )        \/\/ edit coords\n        O.xy = iMouse.xy;\n}","name":"","description":"","type":"buffer"}]}}