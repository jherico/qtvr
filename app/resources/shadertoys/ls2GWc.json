{"Shader":{"ver":"0.1","info":{"id":"ls2GWc","date":"1394722879","viewed":842,"name":"disparity4","username":"FabriceNeyret2","description":"C: toggles greyscale vs colors<br\/>G: toggles grid vs dots<br\/>D: toggles deformations vs displacement<br\/>S: toggles stereo (horiz displ only) vs radial disp<br\/>M: mark central dots<br\/>SPACE: toggles mouse tune center or color<br\/>#define NB : number of dots vertically","likes":1,"published":3,"flags":0,"tags":["illusion","autostereogram","stereovision"],"hasliked":0},"renderpass":[{"inputs":[{"id":5,"src":"\/presets\/tex04.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"float t = iGlobalTime;\nconst float PI=3.1415927;\n\n#define NB 40.    \/\/ 25.\n#define radius .3 \/\/ .4   max: 0.5\n\nbool keyToggle(int ascii) {\n\treturn (texture2D(iChannel2,vec2((.5+float(ascii))\/256.,0.75)).x > 0.);\n}\n\n\/\/ === draw a circle (p,r) ===\n\nfloat circle(vec2 p, float r) {\n\t\n\tif (keyToggle(71)) { p = p\/r - 1.; r = p.x*p.y;\t} \n\telse\t\t\t     r = length(p)\/r - 1.;\n\n\treturn step(0.,r);\n\t\/\/ return smoothstep(-.03,.03,r);\n}\n\n\/\/ === defines distortion ===\n\n#define POLYNOMIAL 1\n#if POLYNOMIAL\n\/\/const float P0=0.,P01=1.,P02=-1.; \/\/ P=x-x\u00b2 (0,0) \/ (.5,1\/4) \\ (1,0)\n\tconst float P0=0.,P01=-0.5,P02=0.5;\n\tconst float R=.5;\t\/\/ resize the curve to [0,R]\n\tfloat F(float x) { return P0 + (P01\/R)*x + (P02\/(R*R))*x*x; }\n#else\n\tconst float R=PI\/4.;\n\tfloat F(float x) { return .25*sin(-4.*x); }\n#endif\n\n\/\/ === scalar direct and reverse transforms ===\n\nfloat f(float x) {\n\tfloat sx= sign(x), ax = abs(x); \/\/ We force odd symmetry => P0=0\n\tif (ax > R) return x;\n\tfloat dx = F(ax);\n\treturn x + sx*dx; \n}\n\nfloat invf(float x) {\n\tfloat sx= sign(x), ax = abs(x); \/\/ We force odd symmetry => P0=0\n\tif (ax > R) return x;\n\n#if POLYNOMIAL\n\t\/\/ resize the curve to [0,R]\n# if 0\n\tfloat B =.5*(1.+(P01\/R))*(R*R\/P02); \/\/ a=1, b\/2, c\n\tfloat C =  (P0-ax)   *(R*R\/P02);\n\treturn sx*(-B + sign(B)*sqrt(B*B-C));  \/\/ -b' +- sqrt(b'2-c)\n# else\n\tfloat B = .5*(1.+ (P01\/R))*(R*R\/P02) + ax; \/\/ a=1, -b\/2, c\n\tfloat C = (P0 +ax*(P01\/R))*(R*R\/P02) + ax*ax;\n\tfloat dx = B - sign(B)*sqrt(B*B-C);  \/\/ -b' +- sqrt(b'2-c)\n\treturn x - sx*dx;\n# endif\n#endif\n}\n\n\/\/ === vectorial direct and reverse transforms ===\n\nvec2 disp(vec2 p, vec2 c) { \/\/ distorsion centre c size r\n\tfloat l=length(p-c);\n\tif (keyToggle(83)) \/\/ horizontal displacement only \n\t\treturn c + (p-c)\/l*vec2(f(l),l);\n\telse\n\t\treturn c + (p-c)\/l*f(l); \/\/ radial displacement\n}\nvec2 invdisp(vec2 p, vec2 c) { \/\/ inverse distorsion\n\tfloat l=length(p-c);\n\tif (keyToggle(83))   \/\/ horizontal displacement only \n\t\treturn c + (p-c)\/l*vec2(invf(l),l);\n\telse\n\t\treturn c + (p-c)\/l*invf(l); \/\/ radial displacement\n}\n\n\/\/\/ === draw a distorted pattern ===\n\nfloat stiples(vec2 p, vec2 center, float n) {\n\tvec2 c, p2 = disp(p,center); \n\tn *= .5;               \/\/ because domain range = [-1,1]\n\tp2 = n*p2+.5;\n\tif (keyToggle(68)) { \/\/ --- distorsion mode --- \n\t    p2 = fract(p2)\/n; \/\/ pos relative to a tile\n\t    c = vec2(.5\/n);     \n\t} else {             \/\/ --- displacement mode --- \n\t\tc = floor(p2)\/n;\n\t\tc = invdisp(c,center);\n\t\tp2 = p;\n\t}\n\/\/  return texture2D(iChannel0,.5*(1.+p2)).r;\n\n\t\n\treturn circle(p2-c,radius\/n);\n}\n\n\/\/ === main loop ===\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = 2.*(fragCoord.xy\/iResolution.y - vec2(.9,.5));\n\tvec2 center = vec2(0.);\n\tvec4 m = iMouse\/iResolution.y;\n\tif (!keyToggle(32)) {\n\t\tif (m.x+m.y==0.) m.xy = vec2(.9001,.5);\n\t\tcenter = 2.*(m.xy- vec2(.9,.5));\n\t\tm.xy = vec2(0.);\n\t}\n\tif ((m.z<0.) || (m.x+m.y==0.)) m.y=.8;\n\t\n\tfloat v; vec3 col;\n#if 1\n\tv = stiples(uv,center,NB);\n\tbool grey=keyToggle(67);\n\tif (keyToggle(77) && (floor(.25*NB*disp(uv,center) +.25)\/NB==vec2(0.)))\n\t\tgrey = !grey;\n\t\n\tif (grey) col = vec3(v);\n\telse\t  col = mix(vec3(1.,0.,0.),m.y*vec3(0.,1.,0.),v);\n#else  \/\/ --- display control curves\n\tv =      f(uv.x )-uv.y; col.r = smoothstep(.03,-.03,abs(v));\n\tv =   invf(uv.x) -uv.y; col.g = smoothstep(.03,-.03,abs(v));\n\tv = f(invf(uv.x))-uv.y; col.b = smoothstep(.03,-.03,abs(v));\n#endif\t\n\t\n\tfragColor = vec4(col, 1.);\n}","name":"","description":"","type":"image"}]}}