{"Shader":{"ver":"0.1","info":{"id":"ltfXWS","date":"1439299130","viewed":859,"name":"Antialiased Blocky Sampling","username":"Permutator","description":"Since these descriptions have a character limit, I made a big ol' comment at the top of the code instead. Wow, look at how much I wrote about this tiny little shader. I do really pointless things sometimes.","likes":8,"published":3,"flags":0,"tags":["2d","texture","antialiasing","filtering","aa"],"hasliked":0},"renderpass":[{"inputs":[{"id":15,"src":"\/presets\/tex10.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/* There are a few shaders on this site already that attempt to do this (most notably\n * <https:\/\/www.shadertoy.com\/view\/ldlSzS>), but none of them were quite what I wanted,\n * so I made this one myself.\n * \n * It has an interface almost as simple as texture2D's, with only one extra parameter\n * for the resolution of the texture. You don't need to pass in the screen resolution\n * or anything, since it uses dFdx and dFdy. I haven't tested this, but it should also\n * work on textures that have been transformed in complex ways, such as ones in 3D\n * environments.\n * It doesn't use fwidth. It uses the Pythagorean Theorem instead. I don't really get\n * why fwidth doesn't just work like that in the first place... Maybe fwidth has some\n * hidden meaning that I don't understand? In any case, it isn't the right function\n * for this.\n * It also has no branching and only calls texture2D once, using the GPU's built-in\n * bilinear interpolation.\n * \n * You can honestly just lift the v2len and textureBlocky functions out of this shader,\n * put them into your own, and use them. It's very easy.\n * \n * Since copyright law exists, I guess I ought to put this under a license of some kind\n * if I want you to be able to use it. It's tiny and actually rather self-evident, so\n * I'll put it under the CC0 1.0 Public Domain Dedication:\n * <http:\/\/creativecommons.org\/publicdomain\/zero\/1.0\/>\n * Ta-dahhh! Now you can use it however you want without even giving me credit.\n *\/\n\n\n\n\/\/ change this value to compare different interpolation methods.\n\/\/ \n\/\/ 0: antialiased blocky interpolation\n\/\/ 1: linear interpolation\n\/\/ 2: aliased blocky interpolation\n#define RENDER_MODE 0\n\n\n\n\/\/ basically calculates the lengths of (a.x, b.x) and (a.y, b.y) at the same time\nvec2 v2len(in vec2 a, in vec2 b) {\n    return sqrt(a*a+b*b);\n}\n\n\n\/\/ samples from a linearly-interpolated texture to produce an appearance similar to\n\/\/ nearest-neighbor interpolation, but with resolution-dependent antialiasing\n\/\/ \n\/\/ this function's interface is exactly the same as texture2D's, aside from the 'res'\n\/\/ parameter, which represents the resolution of the texture 'tex'.\nvec4 textureBlocky(in sampler2D tex, in vec2 uv, in vec2 res) {\n    uv *= res; \/\/ enter texel coordinate space.\n    \n    \n    vec2 seam = floor(uv+.5); \/\/ find the nearest seam between texels.\n    \n    \/\/ here's where the magic happens. scale up the distance to the seam so that all\n    \/\/ interpolation happens in a one-pixel-wide space.\n    uv = (uv-seam)\/v2len(dFdx(uv),dFdy(uv))+seam;\n    \n    uv = clamp(uv, seam-.5, seam+.5); \/\/ clamp to the center of a texel.\n    \n    \n    return texture2D(tex, uv\/res, -1000.); \/\/ convert back to 0..1 coordinate space.\n}\n\n\n\n\/\/ simulates nearest-neighbor interpolation on a linearly-interpolated texture\n\/\/ \n\/\/ this function's interface is exactly the same as textureBlocky's.\nvec4 textureUgly(in sampler2D tex, in vec2 uv, in vec2 res) {\n    return texture2D(tex, (floor(uv*res)+.5)\/res, -1000.);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy * 2. - iResolution.xy) \/ min(iResolution.x, iResolution.y);\n    float theta = iGlobalTime \/ 12.;\n    vec2 trig = vec2(sin(theta), cos(theta));\n    uv *= mat2(trig.y, -trig.x, trig.x, trig.y) \/ 8.;\n    \n    #if RENDER_MODE == 0\n    fragColor = textureBlocky(iChannel0, uv, iChannelResolution[0].xy);\n    #elif RENDER_MODE == 1\n    fragColor = texture2D(iChannel0, uv);\n    #elif RENDER_MODE == 2\n    fragColor = textureUgly(iChannel0, uv, iChannelResolution[0].xy);\n    #endif\n}\n","name":"","description":"","type":"image"}]}}