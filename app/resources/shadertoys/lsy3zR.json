{"Shader":{"ver":"0.1","info":{"id":"lsy3zR","date":"1452934688","viewed":200,"name":"vortex simulation 2","username":"FabriceNeyret2","description":"red\/blue = vortices +\/-, intensity = strenght      white = passive markers.     2 buffers instead of pipelined in one.","likes":5,"published":3,"flags":32,"tags":["simulation","vortex","seminewton"],"hasliked":0},"renderpass":[{"inputs":[{"id":259,"src":"\/presets\/previz\/buffer02.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ inspired from http:\/\/evasion.imag.fr\/~Fabrice.Neyret\/demos\/JS\/Vort.html\n\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n\tO = texture2D(iChannel0,U\/iResolution.xy);   \n}","name":"","description":"","type":"image"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ semi-Newton integration of Biot-Savart velocity field induced by vortex particles\n\/\/ inspired from http:\/\/evasion.imag.fr\/~Fabrice.Neyret\/demos\/JS\/Vort.html\n\n#define N 20         \/\/ N*N partics. to be changed in all tabs !\n#define Nf float(N)\n#define MARKERS .90  \/\/ % of passive markers\n#define BINARY 0     \/\/ are vorticities distributed or binaries ( -1 or 1 )\n#define CYCLE 2      \/\/ evaluate forces through cycling world 0:no 1:full 2:cheap\nfloat STRENGTH  = 1e3 * .25\/(1.-MARKERS)*sqrt(30.\/Nf);\n\n#define tex(i,j)    texture2D(iChannel1, (vec2(i,j)+.5)\/iResolution.xy)\n#define rand2(U)    fract(1e5*sin(mat2(17.1,191.7,-31.1,241.7)*U))\n#define W(i,j)      tex(i,j+N).z\n\n    \nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 T = floor(U\/Nf); \/\/ several grids are mapped in the buffer\n    \/\/ tile (0,0).xy , zw : pos, velocity of pass 1  (init from pass 2 output)\n    \/\/ tile (0,1).z         vorticity\n    \/\/ tile (0,2).xy , zw : backup of ref pos, velocity  ( UNUSED )\n    \n    if (iFrame < 10) {   \/\/ ----- initialization\n        O = vec4( U + 3.*rand2(U),      \/\/ P0\n                  2.*rand2(U+7.13)-1.);  \/\/ V0 (for gravity) or W (if tile(0,1) )\n        O.xy *= iResolution.xy\/Nf;\n\n        if (T==vec2(0,1)) \n            if (.5+.5*O.w < MARKERS) O.z = 0.;   \/\/ W = 0 : passive markers\n        \telse if (BINARY==1) O.z = sign(O.z); \/\/ binary mode: all active |W|=1\n        return; \n    }\n    \n    if (T==vec2(0,1))\n        O = texture2D(iChannel0, U\/iResolution.xy);  \/\/ for buffer persistency \n    \n    U = mod(U,Nf);      \/\/ U = particle id ( N*N particles )\n    \n    \/\/if ( T == vec2(0,2) )  \/\/ backup ref positions ( UNUSED )\n    \/\/    { O = refState(U); return; }\n    \n    int pass = 0;\n    float dt = iTimeDelta; \n    \n    if ( T == vec2(0,0) ) { \/\/ pass 1 : 1\/2 time step from ref position (to get V)\n        pass = 1; \n        dt *= .5; \n        O = texture2D(iChannel1, U\/iResolution.xy);\n    }\n    if (pass==0) return;\n    \n    \/\/ if pass 1: compute tmp pos(v) at half time-step\n    \/\/ if pass 2: compute new pos using velocities(tmppos) and ref pos\n\n    \/\/ ----- evaluate forces (Newton, for gravity) \n    \/\/         or directly velocity (Biot-Savart, for vorticity)\n    vec2 F = vec2(0);\n \n#if CYCLE == 1         \/\/ forces through cycling world\n    for (int cx=-1; cx<2; cx++)\n      for (int cy=-1; cy<2; cy++)\n#endif\n    for (int j=0; j<N; j++)\n        for (int i=0; i<N; i++) \n        {\n            float w = W(i,j);\n            \/\/ we could optimize by not considering markers, but the main cost is not there.\n            vec2 d = tex(i,j).xy - O.xy;\n#if CYCLE == 1\n            d += iResolution.xy*vec2(cx,cy);\n#elif CYCLE == 2     \/\/ cycling world : clipped to most contributive window\n            d = ( fract(.5+d\/iResolution.xy) -.5)*iResolution.xy;\n#endif\n            float l = dot(d,d);\n         \/\/ if (l>1e-5) F += d \/l;                   \/\/ Newton, for gravity \n            if (l>1e-5) F += vec2(-d.y,d.x) * w \/l;  \/\/ Biot-Savart, for vorticity\n            }\n    \n \/\/ O.zw += 1e-1*F*dt;    \/\/ v += sum(F).dt   for Newton\n    O.zw = STRENGTH*F;    \/\/ direct eval of V (stored as F) for Biot-Savart\n    if (pass==2)   \/\/ increment from ref pos, not pass 1 pos\n        O.xy = texture2D(iChannel0, U\/iResolution.xy).xy;\n    \/\/  O.xy = texture2D(iChannel0, (U+vec2(0,2)*Nf)\/iResolution.xy).xy; \/\/ from backup\n    O.xy += O.zw*dt;      \/\/ x += v.dt\n    O.xy = mod(O.xy, iResolution.xy);\n  \n}\n\n","name":"","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ semi-Newton integration of Biot-Savart velocity field induced by vortex particles\n\/\/ inspired from http:\/\/evasion.imag.fr\/~Fabrice.Neyret\/demos\/JS\/Vort.html\n\n#define N 20         \/\/ N*N partics. to be changed in all tabs !\n#define Nf float(N)\n#define MARKERS .90  \/\/ % of passive markers\n#define BINARY 0     \/\/ are vorticities distributed or binaries ( -1 or 1 )\n#define CYCLE 2      \/\/ evaluate forces through cycling world 0:no 1:full 2:cheap\nfloat STRENGTH  = 1e3 * .25\/(1.-MARKERS)*sqrt(30.\/Nf);\n\n#define tex(i,j)    texture2D(iChannel1, (vec2(i,j)+.5)\/iResolution.xy)\n#define rand2(U)    fract(1e5*sin(mat2(17.1,191.7,-31.1,241.7)*U))\n#define W(i,j)      tex(i,j+N).z\n\n    \nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 T = floor(U\/Nf); \/\/ several grids are mapped in the buffer\n    \/\/ tile (0,0).xy , zw : pos, velocity of pass 1  (init from pass 2 output)\n    \/\/ tile (0,1).z         vorticity\n    \/\/ tile (0,2).xy , zw : backup of ref pos, velocity  ( UNUSED )\n    \n    if (iFrame < 10) {   \/\/ ----- initialization\n        O = vec4( U + 3.*rand2(U),      \/\/ P0\n                  2.*rand2(U+7.13)-1.);  \/\/ V0 (for gravity) or W (if tile(0,1) )\n        O.xy *= iResolution.xy\/Nf;\n\n        if (T==vec2(0,1)) \n            if (.5+.5*O.w < MARKERS) O.z = 0.;   \/\/ W = 0 : passive markers\n        \telse if (BINARY==1) O.z = sign(O.z); \/\/ binary mode: all active |W|=1\n        return; \n    }\n    \n    if (T==vec2(0,1))\n        O = texture2D(iChannel0, U\/iResolution.xy);  \/\/ for buffer persistency \n    \n    U = mod(U,Nf);      \/\/ U = particle id ( N*N particles )\n    \n    \/\/if ( T == vec2(0,2) )  \/\/ backup ref positions ( UNUSED )\n    \/\/    { O = refState(U); return; }\n    \n    int pass = 0;\n    float dt = iTimeDelta; \n    \n    if ( T == vec2(0,0) ) { \/\/ pass 1 : 1\/2 time step from ref position (to get V)\n        pass = 2; \n        O = texture2D(iChannel1, U\/iResolution.xy);\n    }\n    if (pass==0) return;\n    \n    \/\/ if pass 1: compute tmp pos(v) at half time-step\n    \/\/ if pass 2: compute new pos using velocities(tmppos) and ref pos\n\n    \/\/ ----- evaluate forces (Newton, for gravity) \n    \/\/         or directly velocity (Biot-Savart, for vorticity)\n    vec2 F = vec2(0);\n \n#if CYCLE == 1         \/\/ forces through cycling world\n    for (int cx=-1; cx<2; cx++)\n      for (int cy=-1; cy<2; cy++)\n#endif\n    for (int j=0; j<N; j++)\n        for (int i=0; i<N; i++) \n        {\n            float w = W(i,j);\n            \/\/ we could optimize by not considering markers, but the main cost is not there.\n            vec2 d = tex(i,j).xy - O.xy;\n#if CYCLE == 1\n            d += iResolution.xy*vec2(cx,cy);\n#elif CYCLE == 2     \/\/ cycling world : clipped to most contributive window\n            d = ( fract(.5+d\/iResolution.xy) -.5)*iResolution.xy;\n#endif\n            float l = dot(d,d);\n         \/\/ if (l>1e-5) F += d \/l;                   \/\/ Newton, for gravity \n            if (l>1e-5) F += vec2(-d.y,d.x) * w \/l;  \/\/ Biot-Savart, for vorticity\n            }\n    \n \/\/ O.zw += 1e-1*F*dt;    \/\/ v += sum(F).dt   for Newton\n    O.zw = STRENGTH*F;    \/\/ direct eval of V (stored as F) for Biot-Savart\n    if (pass==2)   \/\/ increment from ref pos, not pass 1 pos\n        O.xy = texture2D(iChannel0, U\/iResolution.xy).xy;\n    \/\/  O.xy = texture2D(iChannel0, (U+vec2(0,2)*Nf)\/iResolution.xy).xy; \/\/ from backup\n    O.xy += O.zw*dt;      \/\/ x += v.dt\n    O.xy = mod(O.xy, iResolution.xy);\n  \n}\n\n","name":"","description":"","type":"buffer"},{"inputs":[{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":259,"src":"\/presets\/previz\/buffer02.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ display with motion blur   ( no use of parallelism :-( )\n\/\/ indeed, this is the slowest part. :-( Any idea for optimising ?\n\n#define N 20     \/\/ N*N partics. to be changed in all tabs !\n#define Nf float(N)\n#define Rp 16.\n#define Rm 2.\n#define PASS 1   \/\/ display pass 0 or pass 1\n\n#define tex(i,j) texture2D(iChannel0, (vec2(i,j)+.5)\/iResolution.xy)\n#define W(i,j)   tex(i,j+N).z\n\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n#if 0 \/\/ test\n    float n = 3.*Nf\/iResolution.y,\n        r = iResolution.x\/iResolution.y;\n    U \/= iResolution.xy;\n\tO.xy =  U.x < .5 ? texture2D(iChannel0,U*n).xy\n                     : texture2D(iChannel0,(U-vec2(2.*n,0))*n).zw;\n   if (U.y < 1.\/3.) O \/= iResolution.y;\n   else if (U.x>.5 && max((U.x-.5)*r,U.y-1.\/3.)<1.\/3.) O = O.x==0. ? vec4(1) : O.x>0. ? vec4(O.x,0,0,1) : vec4(0,0,-O.x,1);\n   \/\/ O = fract(O);\n    \n#else    \n    \n    O = (1.-.05)*texture2D(iChannel1,U\/iResolution.xy); \/\/ blur relaxation of past\n\n    for (int j=0; j<N; j++)\n        for (int i=0; i<N; i++) \n        {\n            vec2 d = tex(i,j).xy - U.xy;\n            float l = dot(d,d),\n                  w = W(i,j);    \/\/ particle vorticity\n         \/\/ O += 2.*abs(w)\/l;\n            if (l<Rp)              \n              if   (w==0.) O += smoothstep(Rm,Rm\/2.,l) * .2; \/\/ passiwe marker : white\n              else { l = smoothstep(Rp,Rp\/2.,l) * .3;        \/\/ active vortices : red\/blue\n                     if (w>0.) O.x += w*l; else O.z += -w*l;\n                   }\n     }\n#endif\n    \n}\n","name":"","description":"","type":"buffer"}]}}