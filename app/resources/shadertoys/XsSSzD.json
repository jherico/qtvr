{"Shader":{"ver":"0.1","info":{"id":"XsSSzD","date":"1409348200","viewed":6928,"name":"Alien Thorns","username":"Dave_Hoskins","description":"3D voronoi cells twisted into each other. I Managed to get the texture to move with the voronoi objects. They also slowly change colour.","likes":20,"published":3,"flags":8,"tags":["3d","raymarching","voronoi","sound","alienthorns"],"hasliked":0},"renderpass":[{"inputs":[{"id":2,"src":"\/presets\/tex01.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":4,"src":"\/presets\/tex03.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":8,"src":"\/presets\/tex07.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Alien Thorns\n\/\/ Dave Hoskins\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PRECISION 0.02\n\n#define MOD3 vec3(.0631,.07369,.08787)\n\nvec3 sunDir = normalize(vec3(-.3, 0.6, .8));\n\nfloat time;\n\n\/\/--------------------------------------------------------------------------------------------------\nvec3 TexCube(in vec3 p, in vec3 n )\n{\n    p *= .5;\n\tvec3 x = texture2D( iChannel0, p.yz, -100.0 ).xyz;\n\tvec3 y = texture2D( iChannel1, p.zx, -100.0 ).xyz;\n\tvec3 z = texture2D( iChannel2, p.xy, -100.0 ).xyz;\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\n\/\/--------------------------------------------------------------------------------------------------\nvec4 ThornVoronoi( vec3 p, out float which)\n{\n    \n    vec2 f = fract(p.xz);\n    p.xz = floor(p.xz);\n\tfloat d = 1.0e10;\n    vec3 id = vec3(0.0);\n    \n\tfor (int xo = -1; xo <= 1; xo++)\n\t{\n\t\tfor (int yo = -1; yo <= 1; yo++)\n\t\t{\n            vec2 g = vec2(xo, yo);\n            vec2 n = texture2D(iChannel3,(p.xz + g+.5)\/256.0, -100.0).xy;\n            n = n*n*(3.0-2.0*n);\n            \n\t\t\tvec2 tp = g + .5 + sin(p.y + 1.2831 * (n * time*.5)) - f;\n            float d2 = dot(tp, tp);\n\t\t\tif (d2 < d)\n            {\n                \/\/ 'id' is the colour code for each thorn\n                d = d2;\n                which = n.x+n.y*3.0;\n                id = vec3(tp.x, p.y, tp.y);\n            }\n\t\t}\n\t}\n\n    return vec4(id, 1.35-pow(d, .17));\n}\n\n\n\/\/--------------------------------------------------------------------------------------------------\nfloat MapThorns( in vec3 pos)\n{\n    float which;\n\treturn pos.y * .21 - ThornVoronoi(pos, which).w  - max(pos.y-5.0, 0.0) * .5 + max(pos.y-5.5, 0.0) * .8;\n}\n\n\/\/--------------------------------------------------------------------------------------------------\nvec4 MapThornsID( in vec3 pos, out float which)\n{\n    vec4 ret = ThornVoronoi(pos, which);\n\treturn vec4(ret.xyz, pos.y * .21 - ret.w - max(pos.y-5.0, 0.0) * .5 + max(pos.y-5.5, 0.0) * .8);\n}\n\n\/\/--------------------------------------------------------------------------------------------------\nfloat Hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract(p3.x * p3.y * p3.z);\n}\n\n\/\/--------------------------------------------------------------------------------------------------\nvec4 Raymarch( in vec3 ro, in vec3 rd, in vec2 uv, in vec2 fragCoord, out float which)\n{\n\tfloat maxd = 40.0;\n\t\n    vec4 h = vec4(1.0);\n    float t = 0.+ Hash12(fragCoord.xy)*.2;\n    vec3 p;\n    for (int i = 0; i < 110; i++)\n    {\n        p = ro + rd * t;\n        if(h.w < PRECISION || t > maxd || p.y > 12.0 ) break;\n\t    h = MapThornsID(p, which);\n        t += h.w * .5 + min(t*.002, .03);\n    }\n\n    if (t > maxd || p.y > 8.0)\tt = -1.0;\n    \n    return vec4(h.xyz, t);\n}\n\n\/\/--------------------------------------------------------------------------------------------------\nvec3 Normal( in vec3 pos )\n{\n    vec2 eps = vec2(PRECISION, 0.0);\n\treturn normalize( vec3(\n           MapThorns(pos+eps.xyy) - MapThorns(pos-eps.xyy),\n           MapThorns(pos+eps.yxy) - MapThorns(pos-eps.yxy),\n           MapThorns(pos+eps.yyx) - MapThorns(pos-eps.yyx) ) );\n\n}\n\n\/\/--------------------------------------------------------------------------\nfloat FractalNoise(in vec2 xy)\n{\n\tfloat w = 1.5;\n\tfloat f = 0.0;\n    xy *= .08;\n\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tf += texture2D(iChannel2, .5+xy * w, -99.0).x \/ w;\n\t\tw += w;\n\t}\n\treturn f*.8;\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 GetClouds(in vec3 sky, in vec3 cameraPos, in vec3 rd)\n{\n    \/\/if (rd.y < 0.0) return vec3(0);\n\t\/\/ Uses the ray's y component for horizon fade of fixed colour clouds...\n\tfloat v = (70.0-cameraPos.y)\/rd.y;\n\trd.xz = (rd.xz * v + cameraPos.xz+vec2(0.0,0.0)) * 0.004;\n\tfloat f = (FractalNoise(rd.xz) -.5);\n\tvec3 cloud = mix(sky, vec3(.4, .2, .2), max(f, 0.0));\n   \treturn cloud;\n}\n\n\/\/\n\/\/--------------------------------------------------------------------------------------------------\nfloat Shadow( in vec3 ro, in vec3 rd, float mint)\n{\n    float res = 1.0;\n    float t = .15;\n    for( int i=0; i < 15; i++ )\n    {\n        float h = MapThorns(ro + rd*t);\n\t\th = max( h, 0.0 );\n        res = min( res, 4.0*h\/t );\n        t+= clamp( h*.6, 0.05, .1);\n\t\tif(h < .001) break;\n    }\n    return clamp(res,0.05,1.0);\n}\n\n\/\/--------------------------------------------------------------------------------------------------\nvec3 Path( float time )\n{\n\treturn vec3(1.3+ 17.2*cos(0.2-0.5*.33*time*.75), 4.7, 7.- 16.2*sin(0.5*0.11*time*.75) );\n}\n\n\/\/--------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 q = fragCoord.xy \/ iResolution.xy;\n\tvec2 p = (-1.0 + 2.0*q)*vec2(iResolution.x \/ iResolution.y, 1.0);\n\t\n    \/\/ Camera...\n\tfloat off = iMouse.x*1.0*iMouse.x\/iResolution.x;\n\ttime =173.0+iGlobalTime + off;\n\tvec3 ro = Path( time+0.0 );\n    \n\tvec3 ta = Path( time+5.2 );\n    float add = (sin(time*.3)+1.0)*2.0;\n    ro.y+= add;\n    ta.y -= add;\n\tta.y *= 1.0+sin(3.0+0.12*time) * .5;\n\tfloat roll = 0.3*sin(0.07*time);\n\t\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = (cross(cu,cw));\n\t\n\tfloat r2 = p.x*p.x*0.32 + p.y*p.y;\n    p *= (7.0-sqrt(37.5-11.5*r2))\/(r2+1.0);\n\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.1*cw );\n\n\tvec3 col \t\t= mix(vec3(.3, .3, .5), GetClouds(vec3(0.), ro, rd),\tpow(abs(rd.y), .5));\n    vec3 background = mix(vec3(.3, .3, .5), vec3(.0), \t\t\t\t\t\tpow(abs(rd.y), .5));\n\n\tfloat sun = clamp( dot(rd, sunDir), 0.0, 1.0 );\n\tfloat which;\n\tvec4 ret = Raymarch(ro, rd, q, fragCoord, which);\n    \n    if(ret.w > 0.0)\n\t{\n\t\tvec3 pos = ro + ret.w*rd;\n\t\tvec3 nor = Normal(pos);\n\t\tvec3 ref = reflect(rd, nor);\n\t\t\n\t\tfloat s = clamp( dot( nor, sunDir ), 0.0, 1.0 );\n\t\t\n        float sha = 0.0; if( s>0.01) sha = Shadow(pos, sunDir, 0.05);\n\t\tvec3 lin = s*vec3(1.0,.9,.8) * sha;\n\t\tlin += background*(max(nor.y, 0.0)*.2);\n\n\t\tcol = TexCube(ret.xyz, nor);\n        vec3 wormCol =  clamp(abs(fract(which * 1.5 + vec3(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0)) * 6.0 - 3.0) -1.0, 0.0, 1.0);\n        \n\t\tcol = lin * col * (.7 + wormCol * .6);\n        col += vec3(1.0, .6, 1.0)*pow(clamp( dot( ref, sunDir ), 0.0, 1.0 ), 10.0) * sha;\n\t\t\n\t\tcol = mix( col, background, 1.0-exp(-0.002*ret.w*ret.w) );\n\t}\n\n    col += vec3(.4,.25,.25)*pow( sun, 20.0 )*4.0*clamp( (rd.y+0.4) \/ .2,0.0,1.0);\n    \/\/ Gamma & colour adjust...\n\tcol = pow(col, vec3(.45, .45, .5));\n    \/\/ Border shading...\n    col *= 0.5 + 0.5*pow( 52.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2 );\n\n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"},{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define PI 3.14159265359\n\n#define MOD3 vec3(.0631,.07369,.08787)\nfloat gTime;\n\n\/\/--------------------------------------------------------------------------------------------------\nvec2 Hash2(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3.zxy, p3.yxz+19.19);\n    return fract(vec2(p3.x * p3.y, p3.z*p3.x));\n}\n\n\/\/--------------------------------------------------------------------------------------------------\nvec2 Noise( in vec2 x )\n{\n    return mix(Hash2(floor(x)), Hash2(floor(x)+1.0), fract(x));\n}\n\nfloat Saw(float n, float fil)\n{\n\tfloat v = 0.0;\n\tfloat f = 1.0;\n    int filter = int((fil));\n    \n\tfor (int i = 0; i < 100; i++)\n\t{\n        if (i > filter) break;\n        float a = .5*(sin(2.0*f*n * PI) \/ f);\n        if (i > filter-filter\/10) a = 2.5 * a;\n        v += a;\n        \n\t\tf++;\n\t}\n\treturn v* 2000.0 \/ (fil+1000.0);\n}\n\n\nvec2 Hash( vec2 n)\n{\n\tvec4 p = texture2D( iChannel0, n*vec2(.78271, .32837), -100.0 );\n    return (p.xy + p.zw) * .5; \n}\n\n\/\/--------------------------------------------------------------------------\nvec2 Noise2D( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 res = mix(mix( Hash(p + 0.0), Hash(p + vec2(1.0, 0.0)),f.x),\n                   mix( Hash(p + vec2(0.0, 1.0) ), Hash(p + vec2(1.0, 1.0)),f.x),f.y);\n    return res-.5;\n}\n\n\/\/--------------------------------------------------------------------------\nvec2 FBM( vec2 p )\n{\n    vec2 f;\n\tf  = 0.5000\t * Noise2D(p); p = p * 2.32;\n\tf += 0.2500  * Noise2D(p); p = p * 2.23;\n\tf += 0.1250  * Noise2D(p); p = p * 2.31;\n    f += 0.0625  * Noise2D(p); p = p * 2.28;\n    f += 0.03125 * Noise2D(p);\n    return f;\n}\n\n\n\/\/--------------------------------------------------------------------------------------------------\nvec4 ThornVoronoi( vec3 p)\n{\n    \n    vec2 f = fract(p.xz);\n    p.xz = floor(p.xz);\n\tfloat d = 1.0e10;\n    vec3 id = vec3(0.0);\n    \n\tfor (int xo = -1; xo <= 1; xo++)\n\t{\n\t\tfor (int yo = -1; yo <= 1; yo++)\n\t\t{\n            vec2 g = vec2(xo, yo);\n            vec2 n = texture2D(iChannel3,(p.xz + g+.5)\/256.0, -100.0).xy;\n            n = n*n*(3.0-2.0*n);\n            \n\t\t\tvec2 tp = g + .5 + sin(p.y + 1.2831 * (n * gTime*.5)) - f;\n            float d2 = dot(tp, tp);\n\t\t\tif (d2 < d)\n            {\n                \/\/ 'id' is the colour code for each thorn\n                d = d2;\n\n                id = vec3(tp.x, p.y, tp.y);\n            }\n\t\t}\n\t}\n\n    return vec4(id, 1.35-pow(d, .17));\n}\n\n\n\/\/--------------------------------------------------------------------------------------------------\nfloat MapThorns( in vec3 pos )\n{\n\treturn pos.y * .21 - ThornVoronoi(pos).w  - max(pos.y-5.0, 0.0) * .5 + max(pos.y-5.5, 0.0) * .8;\n}\n\n\/\/--------------------------------------------------------------------------------------------------\nvec3 Path( float time )\n{\n\t\treturn vec3(1.3+ 17.2*cos(0.2-0.5*.33*time*.75), 4.7, 7.6 - 16.2*sin(0.5*0.11*time*.75) );\n}\n\/\/--------------------------------------------------------------------------------------------------\nvec2 mainSound(float time)\n{\n    gTime = time+173.0;\n\t\n    vec3 ro = Path(gTime+.0);\n    vec3 ta = Path(gTime + 5.2);\n    float add = (sin(gTime*.3)+1.0)*2.0;\n     ro.y+= add;\n    ta.y -= add;\n    \n    vec3 cw = normalize(ta-ro);\t\t\/\/ Point down movement line\n\tvec3 cp = vec3(0.0, 1.0, 0.0);\t\/\/ Up vector\n    vec3 cu = (cross(cw, cp));\t\t\/\/ Cross product to get the right ear direction\n    \n    vec2 ears;\n    ears.x = abs(MapThorns(ro+cu*.1)) * .8;\n    ears.y = abs(MapThorns(ro-cu*.1)) * .8;\n    \n    vec2 gain = vec2(0.0);\n    gain = clamp(1. - ears, 0.0, 1.0);\n    gain = pow(gain, vec2(3.9));\n    \n    float fil1 = sin(gTime*.521)* 50.0 + 60.0;\n    float fil2 = -sin(gTime*.474)* 50.0 + 60.0;\n    vec2 audio;\n    audio.x = gain.x * (Saw(11.125*time, fil1) + Saw(22.2*time, fil1));\n    audio.y = gain.y * (Saw(11.125*time, fil2) + Saw(22.3*time, fil2));\n    vec2 pos = vec2(gTime * (192.017331), gTime * (182.066927));\n    pos -= sin((gTime*.143))*20.0 * (gain.x+gain.y);\n    audio += FBM(pos) * Saw(gTime*10.5 -sin(gTime * .2)* 8.0, 30.0) ;\n    \n    return clamp(audio, -1.0, 1.0) * smoothstep(60.01, 55.0, time);\n}","name":"","description":"","type":"sound"}]}}