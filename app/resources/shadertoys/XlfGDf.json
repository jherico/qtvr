{"Shader":{"ver":"0.1","info":{"id":"XlfGDf","date":"1427164494","viewed":695,"name":"Phase Engine","username":"mpcomplete","description":"Creating patterns by combining different geometric transforms onto a point on a circle.","likes":1,"published":3,"flags":0,"tags":["transforms"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/#define DEBUG 1\nfloat time = iGlobalTime;\n\n\/\/ Fuzzy unit circle.\nfloat circle(in vec2 p)\n{\n    float r = length(p);\n    float angle = atan(p.y, p.x);\n    return step(r, 1.) * pow(1.-r, .5);\n}\n\n\/\/ 2D rotation matrix.\nmat2 rotate(float angle)\n{\n    return mat2(\n        vec2( cos(angle), sin(angle)),\n        vec2(-sin(angle), cos(angle)));\n}\n\n\/\/ Transform a point on square to a circle.\nvec2 mapSquare(in vec2 p)\n{\n    vec2 ap = abs(p);\n    float r = max(ap.x, ap.y);\n    float angle = atan(p.y, p.x);\n\n    return r*vec2(cos(angle), sin(angle));\n}\n\n\/\/ Make a pattern of squares in a repeating grid.\nvec2 dupSquares(in vec2 p)\n{\n    vec2 ap = abs(sin(p*6.));\n    float r = max(ap.x, ap.y);\n    float angle = atan(p.y, p.x);\n\n    return r*vec2(cos(angle), sin(angle));\n}\n\n\/\/ Duplicate pattern in dupSquaresConcentric squares.\nvec2 dupSquaresConcentric(in vec2 p)\n{\n    vec2 ap = abs(p);\n    float r = max(ap.x, ap.y);\n    float angle = atan(p.y, p.x);\n\n    return sin(3.*r)*vec2(cos(angle), sin(angle));\n}\n\n\/\/ Duplicate pattern in a repeating grid.\nvec2 dupGrid(in vec2 p)\n{\n    return abs(sin(p*4.));\n}\n\nfloat numPhases = 6.;\nvec2 getTransform(in vec2 p, float t)\n{\n    int which = int(mod(t, numPhases));\n\n    if (which == 0) {\n        p = mapSquare(p);\n        p = pow(vec2(.3), abs(p));\n        p = rotate(time*.1)*p;\n        p += .1*sin(time*.2);\n        p = dupSquares(p);\n        p -= .1*sin(time*.2);\n        p = dupSquares(p);\n    } else if (which == 1) {\n        p = pow(abs(p), vec2(.5));\n        p = mapSquare(p);\n        p = pow(abs(p), vec2(3.));\n        p += .1*sin(time*.2);\n        p = dupSquares(p);\n        p = rotate(time*.1)*p;\n        p = dupGrid(p);\n        p -= .1;\n        p = rotate(time*.1)*p;\n    } else if (which == 2) {\n        p = mapSquare(p);\n        p = dupGrid(p*.5);\n        p += .2 + .1*sin(time*.2);\n        p = dupSquares(p);\n        p = rotate(time*.1)*p;\n        p = dupSquares(p);\n    } else if (which == 3) {\n        p = mapSquare(p);\n        p = dupGrid(p*.7);\n        p = dupSquaresConcentric(p);\n        p = rotate(time*.1)*p;\n        p = dupSquares(p);\n        p += .3*sin(time*.2);\n        p = pow(abs(p), vec2(.5));\n        p = dupSquares(p);\n    } else if (which == 4) {\n        p = pow(vec2(.3), abs(p));\n        p = mapSquare(p);\n        p = dupGrid(p);\n        p = dupSquaresConcentric(p);\n        p = rotate(time*.1)*p;\n        p = dupSquares(p);\n        p += .3*sin(time*.2);\n        p = pow(abs(p), vec2(.5));\n        p = dupSquares(p);\n    } else if (which == 5) {\n        p = pow(vec2(.3), abs(p));\n        p = mapSquare(p);\n        p = dupGrid(p);\n        p = dupSquaresConcentric(p);\n        p += .3*sin(time*.2);\n        p = rotate(time*.1)*p;\n        p = dupSquares(p);\n        p = pow(abs(p), vec2(.5));\n        p = dupSquares(p);\n    }\n#if 0  \/\/ REJECTS\n    } else {\n        p = mapSquare(p);\n        p = dupSquares(p*.5);\n        p = dupGrid(p);\n        p = dupSquares(p*.5);\n        p = rotate(time*.1)*p;\n        p = dupSquares(p);\n\n    }\n#endif\n    return p;\n}\n\nvec2 applyTransform(in vec2 p)\n{\n    float t = time*.05;\n#ifdef DEBUG\n    if (iMouse.z > .001) t = iMouse.x\/iResolution.x * numPhases;\n#endif\n    float pct = smoothstep(0., 1., mod(t, 1.));\n    return mix(getTransform(p, t), getTransform(p, t+1.), pct);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy \/ iResolution.xy;\n    p.x *= iResolution.x\/iResolution.y;\n    p *= 1.3;\n\n    p = applyTransform(p);\n    float c1 = circle(p);\n#if 0\n    float c2 = circle(p*1.7);\n    float c3 = circle(p*1.3);\n#else\n    float c2 = circle(p*1.7 + .25*vec2(sin(time*.6), cos(time*.4)));\n    float c3 = circle(p*1.3 - .15*vec2(sin(time*.5), cos(time*.5)));\n#endif\n\n    fragColor = vec4(c1, c2, c3, 1.0);\n}","name":"","description":"","type":"image"}]}}