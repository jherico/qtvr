{"Shader":{"ver":"0.1","info":{"id":"lstGzX","date":"1451752341","viewed":130,"name":"The Long Way","username":"Sgw32","description":"Logo on the startup of the game","likes":2,"published":3,"flags":0,"tags":["tunnel","game","logo","lightning"],"hasliked":0},"renderpass":[{"inputs":[{"id":9,"src":"\/presets\/tex08.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ by Nikos Papadopoulos, 4rknova \/ 2013\n\/\/ Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ by Sgw32\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n#define PI\t3.14159265359\n#define SIZE 3.\n\n#define S(t) tan(t.x*0.4+0.7)\n\nfloat hash(in vec3 p)\n{\n\treturn fract(sin(dot(p,vec3(283.6,127.1,311.7))) * 43758.5453);\n}\n\nfloat noise(vec3 p, vec3 fft, vec3 wav){\n\tp.y -= iGlobalTime * 2. + 2. * fft.x * fft.y;\n\tp.z += iGlobalTime * .4 - fft.z;\n\tp.x += 2. * cos(wav.y);\n\t\n    vec3 i = floor(p);\n\tvec3 f = fract(p); \n\tf *= f * (3.-2.*f);\n    \n    vec2 c = vec2(0,1);\n\n    return mix(\n\t\tmix(mix(hash(i + c.xxx), hash(i + c.yxx),f.x),\n\t\t\tmix(hash(i + c.xyx), hash(i + c.yyx),f.x),\n\t\t\tf.y),\n\t\tmix(mix(hash(i + c.xxy), hash(i + c.yxy),f.x),\n\t\t\tmix(hash(i + c.xyy), hash(i + c.yyy),f.x),\n\t\t\tf.y),\n\t\tf.z);\n}\n\nfloat fbm(vec3 p, vec3 fft, vec3 wav)\n{\n\treturn .5000 * noise(1. * p, fft, wav) \n\t\t + .2500 * noise(2. * p, fft, wav)\n\t     + .1250 * noise(4. * p, fft, wav)\n\t     + .0625 * noise(8. * p, fft, wav);\n}\n\nfloat rand2(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise2(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand2(b), rand2(b + d.yx), f.x), mix(rand2(b + d.xy), rand2(b + d.yy), f.x), f.y);\n}\n\nfloat fbm2(vec2 n) {\n    float total = 0.0, amplitude = 1.0;\n    for (int i = 0; i < 7; i++) {\n        total += noise2(n) * amplitude;\n        n += n;\n        amplitude *= 0.5;\n    }\n    return total;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 fft = vec3(S(vec2(.0,.25)),S(vec2(.5,.25)),S(vec2(1.,.25)));\n\tvec3 wav = vec3(S(vec2(.0,.75)),S(vec2(.5,.75)),S(vec2(1.,.75)));\n\tfloat t  = cos(fft.x * 2. \/ PI);\n\tfloat ct = cos(t);\n\tfloat st = sin(t);\n\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\tvec2 vc = (2. * uv - 1.) * vec2(iResolution.x \/ iResolution.y, 1.);\n\t\n\tvc = vec2(vc.x * ct - vc.y * st\n\t\t\t ,vc.y * ct + vc.x * st);\n\n\tvec3 rd = normalize(vec3(.5, vc.x, vc.y));\n\tvec3 c = 2. * vec3(fbm(rd, fft, wav)) * fft.xyz;\n\tc += hash(hash(uv.xyy) * uv.xyx * iGlobalTime) * .2;;\n\tc *= .9 * smoothstep(length(uv * .5 - .25), .7, .4);\n\tc = c.xyz*1.;\n    c.x*=2.;\n    \n    vec2 p = -1.0 + 2.0 * fragCoord.xy \/ iResolution.xy;\n\n    \/\/ calculate angle of current pixel from origin\n    \/\/ atan return values are in [-pi\/2, pi\/2]\n    \/\/ original tutorial uses function atan(p.y, p.x) which gives a horizontal line\n    \/\/ in left middle as artefact so i will keep this\n    \n    float a = 0.;\n    if (abs(p.y)<abs(p.x))\n    \ta = acos(p.y\/p.x);\n    \n    \/\/ distance of point from origin\n    float r = length(p);\n\n    \/\/ note that uv are from lower left corner and should be in 0-1\n    \/\/ r is in range [0, sqrt(2)]\n    \/\/ a is in range [-pi\/2, pi\/2] so y will be in range [-1\/2, 1\/2]\n    \/\/ 3.1416 = pi\n    \/\/ note that texture is mapped twice devided by a horizontal line\n    \/\/ spent hours trying to visualize below two line.. no luck ! :-\/ :'(\n    uv.x = .2\/r; \n    uv.y = a\/(3.1416);\n    \n    \/\/ add global time for a moving tunnel\n    uv.x = uv.x + iGlobalTime\/2.0;\n    \n    \n    \n    vec4 col = vec4(0,0,0,1);\n    \/\/vec2 uv = (vec2(atan(p.y,p.x), .2\/cc.w))*cc.w;\n   \/\/uv = fragCoord.xy * 1.0 \/ iResolution.xy;\n   \n    \/\/ draw a line, left side is fixed\n    vec2 tq = uv * vec2(2.0,1.0) - iGlobalTime*3.0;\n    vec2 t2 = (vec2(1,-1) + uv) * vec2(2.0,1.0) - iGlobalTime*3.0; \/\/ a second strand\n   \n    \/\/ draw the lines,\n\/\/  this make the left side fixed, can be useful\n\/\/  float ycenter = mix( 0.5, 0.25 + 0.25*fbm( t ), uv.x*4.0);\n\/\/    float ycenter2 = mix( 0.5, 0.25 + 0.25*fbm( t2 ), uv.x*4.0);\n    float ycenter = fbm2(tq)*0.5;\n    float ycenter2= fbm2(t2)*0.5;\n\n    \/\/ falloff\n    float diff = abs(uv.y - ycenter);\n    float c1 = 0.;\n    c1 = 1.0 - mix(0.0,1.0,diff*20.0);\n   \n    float diff2 = abs(uv.y - ycenter2);\n    float c2 = 1.0 - mix(0.0,1.0,diff2*20.0);\n   \n    float c3 = max(c1,c2);\n    if (c3<0.)\n        c3=0.;\n    if (c2<0.)\n        c2=0.;\n    if (c1<0.)\n        c1=0.;\n    \n    col = vec4(c3*0.6,0.2*c2,c3,1.0); \/\/ purple color\n    \n    float time = iGlobalTime;\n    time = mod(time, 5.);\n    uv = fragCoord.xy \/ iResolution.xy;\n\t\n\tvec3 color = vec3(0.0, 0.0, 0.0);\n    \n    \n\tfloat piikit  = 0.5+asin(sin(SIZE*uv.x*6.28))\/5.;\n    \n    \n    if (uv.x<(1.\/(SIZE)))\n    {\n            piikit=0.5;\n    }  \n    \n    \n    if (uv.x>(1.-1.\/(SIZE)))\n    {\n            piikit=0.5;\n    }    \n    \n    float x1 = uv.x*2.;\n    \/\/float xt = time\/10.;\n    float pos = 2.+8.*pow(time,4.);\n   \n    \/\/xx=-pow(xx,2.);\n    \n    \/\/piikit=1.-exp(xx);\n    \n\tfloat flash = 1.;\n                \n\tfloat glow = (flash*0.02)\/abs(piikit - uv.y);\n                \n\tcolor = vec3(0.0, glow*0.5, 0);\n\tcolor += vec3(sqrt(glow*0.2));\n    \n\tfragColor = col + vec4(c,1.)+vec4(color,1);\n}","name":"","description":"","type":"image"}]}}