{"Shader":{"ver":"0.1","info":{"id":"XtX3zl","date":"1424136515","viewed":760,"name":"AudioToy","username":"jherico","description":"Working on a potential audio meter for voice.","likes":2,"published":3,"flags":0,"tags":["2d","audio"],"hasliked":0},"renderpass":[{"inputs":[{"id":11,"src":"\/presets\/vid00.ogv","ctype":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"id":19,"src":"\/presets\/mzk02.mp3","ctype":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"const float PI = 3.1415926;\nconst vec3 COLOR = vec3(0xEE, 0x94, 0x02) \/ vec3(255);\nconst vec3 HIGHLIGHT = vec3(0xFC, 0xCD, 0x81) \/ vec3(255);\nconst vec3 BG = vec3(0x3D) \/ vec3(255);\n\n\/* \n * This fragment shader is intented to produce a ring with varying color around\n * its circumference.  It has two modes.  \n \n * The first is the 'waveform' state, where the highlighted\n * amount of the ring is determined by the incoming uniform iAudio, which is \n * presumably being driven by an audio level from hardware.  In this mode \n * the ring displays bilateral symmetry, with the highlight color starting \n * at the bottom and going up both sides as the value of iAudio increases   \n *\n * The second mode is a 'wait' state which is selected whenever the iAudio value \n * falls below zero.  In this mode, the ring displays three-way axial symmetry\n * and slowly rotates the three regions of highlighting around the axis over time.\n * \n * This code relies heavily on the GLSL function smoothstep to create transitions \n * between the highlight color and the 'background' color as well as to control the \n * alpha value at the edge of the ring to provide antialiasing\n * \n * In order to test or modify this code without having to deal with an android build and\n * debug cycle between every change, you can use the website Shadertoy.com to test changes.\n * Simply copy the entire contents of this file to a new shader on Shadertoy.com and \n * uncomment the '#define SHADERTOY' line below.  If you wish to test responsiveness to audio\n * input, you should set the iChannel0 input on Shadertoy to an audio file, and populate \n * iAudio with a value from that channel, as seen in the main function below. \n *\/\n\n#define SHADERTOY \n\n#ifdef SHADERTOY\nfloat iAudio;\nvec4 bg;\n#else\nuniform float iAudio;\nuniform vec2 iResolution;\nuniform float iGlobalTime;\n#endif\n\nfloat aastep(float threshold, float dist) {\n    float afwidth = 0.7 * length(vec2(dFdx(dist), dFdy(dist)));\n    return smoothstep(threshold - afwidth, threshold + afwidth, dist);\n}\n\nvec2 waveform(float theta) {\n    \/\/ Controls the minimum amount of the waveform to show \n    const float MIN_ACTIVE = 0.3;\n    \/\/ Controls the width of the gradient from the active to the passive color\n    const float TRANSITION_WIDTH = 0.1;\n\n    theta = abs(theta);\n\n    float level = max(iAudio, MIN_ACTIVE); \n    float color = smoothstep(level, level - TRANSITION_WIDTH, 1.0 - theta);\n    level = pow(level, 1.6);\n    float highlight = smoothstep(level, level - TRANSITION_WIDTH * 4.0, 1.0 - theta);\n    return vec2(color, highlight);\n}\n\n\nvec2 waitOld(float theta) {\n    \/\/ Controls the width of the spinners in wait mode\n    const float WAIT_CENTER = 0.5;\n    const float WAIT_WIDTH = 0.1;\n    const float WAIT_MIN = WAIT_CENTER - WAIT_WIDTH;\n    const float WAIT_MAX = WAIT_CENTER + WAIT_WIDTH;\n    \/\/ Controls the width of the gradient from the active to the passive color\n    const float TRANSITION_WIDTH = 0.02;\n\n    \/\/ How fast will we spin the circle (revolutions per second)\n    const float ANIMATION_SPEED = 0.33;\n\n    \/\/ Animate the circle\n    theta = fract(theta + iGlobalTime * ANIMATION_SPEED);\n\n    float level = smoothstep(WAIT_MAX, WAIT_MAX - TRANSITION_WIDTH, theta) * \n        smoothstep(WAIT_MIN, WAIT_MIN + TRANSITION_WIDTH, theta);\n    \n    return vec2(level, 1.0);\n}\n\n\nfloat smoothsteprange(float max, float min, float transition, float value) {\n    return smoothstep(max, max - transition, value) * \n        smoothstep(min, min + transition, value);\n}\n\nvec2 circle(vec2 ndc) {\n    \/\/ The inner radius of the ring\n    const float INNER_RADIUS = 0.8;\n    \/\/ The outer radius of the ring\n    const float OUTER_RADIUS = 1.0;\n    \/\/ The width of the transition from the edge of the ring to the background (for anti-aliasing)\n    const float TRANSITION_WIDTH = 0.02;\n    const float CIRCLE_SMOOTH = 0.05;\n    const float CENTER = (OUTER_RADIUS + INNER_RADIUS) \/ 2.0;\n    const float HALF_WIDTH = (OUTER_RADIUS - INNER_RADIUS) \/ 2.0;\n    \n\n    float r = length(ndc);\n    if (r < INNER_RADIUS || r > OUTER_RADIUS) {\n        \/\/ If we're not in the circle, just return 0, so the caller will discard the pixel\n        return vec2(0.0);\n    }\n    \n    \n\n    \/\/ Calculate the alpha value via smoothstep.  \n    \/\/ float alpha = aastep(INNER_RADIUS, r) * (1.0 - aastep(OUTER_RADIUS, r));\n    float alpha = smoothsteprange(OUTER_RADIUS, INNER_RADIUS, TRANSITION_WIDTH, r);\n    float centerDist = abs(CENTER - r) \/ HALF_WIDTH;\n    return vec2(alpha, 0.0) ;\n}\n\nvec2 getPixelCoordinate() {\n    vec2 uv = gl_FragCoord.xy \/ iResolution.xy;\n    vec2 ndc = (uv * 2.0) - 1.0;\n    float aspect = iResolution.x \/ iResolution.y; \n    if (aspect > 1.0) {\n        ndc.x *= aspect;\n    } else if (aspect < 1.0) {\n        ndc.y \/= aspect;\n    }\n    return ndc;\n}\n\n\nfloat getTheta(vec2 ndc, float symmetry) {\n    \/\/ Map theta to the range (-1,1), 0.0 is at the top\n    float theta = atan(ndc.x, ndc.y) \/ PI;\n    if (2.0 == symmetry) {\n        \/\/ Bilateral symmetry\n        theta = abs(theta);\n    } else if (symmetry > 2.0) {\n        \/\/ Axial symmetry\n        theta = theta + 1.0;\n        theta \/= 2.0;\n        theta = fract(theta * symmetry);\n    } else if (symmetry < 1.0) {\n        \/\/ No symmetry, map the whole circle to (0, 1), 0.5 is at the top.\n        theta = theta + 1.0;\n        theta \/= 2.0;\n    }\n    return theta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 ndc = getPixelCoordinate();\n\n#ifdef SHADERTOY\n    \/\/ Uncomment this to try out the waveform effect with audio input\n    iAudio = texture2D(iChannel0, vec2(0.2, 0.25)).r;\n    \/\/ Uncomment this to try out the wait effect;\n    \/\/ iAudio = -1.0;\n    bg = mix(texture2D(iChannel1, (ndc + 1.0) \/ 2.0), vec4(0), 1.0 - 0.23);\n#endif\n\n    vec2 c = circle(ndc);\n    float alpha = c.x;\n    if (alpha == 0.0) {\n#ifdef SHADERTOY\n        fragColor = bg;\n        return;\n#else\n        discard;\n#endif\n    }\n\n    vec2 smooth = vec2(1.0);\n    if (iAudio < 0.0) {\n        float theta = getTheta(ndc, 0.0);\n        smooth = waitOld(theta);\n    } else {\n        float theta = getTheta(ndc, 2.0);\n        smooth = waveform(theta);\n    }\n    vec3 outColor = mix(COLOR, HIGHLIGHT, smooth.y * (1.0 - c.y));\n    outColor = mix(BG, outColor, smooth.x);\n\n#ifdef SHADERTOY\n    if (alpha < 1.0) {\n        outColor = mix(bg.rgb, outColor, alpha);\n    }\n#endif\n    \n    fragColor = vec4(outColor, alpha);\n}\n\n\n","name":"","description":"","type":"image"}]}}