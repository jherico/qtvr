{"Shader":{"ver":"0.1","info":{"id":"Xlf3Wj","date":"1425039234","viewed":783,"name":"Ray Marching Experiment 10","username":"aiekick","description":"y mouse axis => refraction coef (default 0.95)","likes":3,"published":3,"flags":0,"tags":["raymarching","voronoi","refraction","experiment","glass"],"hasliked":0},"renderpass":[{"inputs":[{"id":24,"src":"\/presets\/cube02_0.jpg","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"id":24,"src":"\/presets\/cube02_0.jpg","ctype":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Stephane Cuillerdier - Aiekick\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n#define REFLEXIONS_STEP 2\n#define ITERATIONS_MAX 100\n\n#define RUGOSITY_DENSITY_MAX 10.\n#define RUGOSITY_DENSITY_DEFAULT 5.\n\n#define CELLS_DENSITY_MAX 10.\n#define CELLS_DENSITY_DEFAULT 0.6\n\n#define TIME_RATIO iGlobalTime*0.4\n\n\/\/ VORONOI based on IQ shader https:\/\/www.shadertoy.com\/view\/ldl3W8\n\/\/vec2 getHash2BasedTex(vec2 p) {return texture2D( iChannel0, (p+0.5)\/256.0, -100.0 ).xy;}\/\/texture based white noise\nvec2 getHash2BasedProc(vec2 p)\n{\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453); \/\/procedural white noise\n}\n\nvec3 getVoronoi(vec2 x)\n{\n    vec2 n=floor(x),f=fract(x),mr;\n    float md=5.;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ ){\n        vec2 g=vec2(float(i),float(j));\n\t\tvec2 o=0.5+0.5*sin(TIME_RATIO+6.2831*getHash2BasedProc(n+g));\/\/animated\n        vec2 r=g+o-f;\n        float d=dot(r,r);\n        if( d<md ) {md=d;mr=r;} }\n    return vec3(md,mr);\n}\n\n\/\/ sphere mapping of v2 voronoi\nvec3 voronoiSphereMapping(vec3 n)\n{\n\tvec2 uv=vec2(atan(n.x,n.z),acos(n.y));\n    float voroRatio = CELLS_DENSITY_DEFAULT;\n\t\/\/if ( iMouse.z > 0. ) {voroRatio=iMouse.x\/iResolution.x * CELLS_DENSITY_MAX;}\n    return getVoronoi(voroRatio*uv);\n}\n\n\/\/\/\/\/\/\/\/MAP\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nfloat density=RUGOSITY_DENSITY_DEFAULT;\n\nfloat map(vec3 p){\n    \/\/if ( iMouse.z > 0. ) {density=iMouse.x\/iResolution.x * RUGOSITY_DENSITY_MAX;}\n\t\n    float rugosity = cos(density*p.x)*sin(density*p.y)*sin(density*p.z)*cos(256.1)*sin(0.8);\n\t\n    float disp = length(vec4(voronoiSphereMapping(normalize(p)),1.))*0.4-0.8;\n    \n    return length(p)-1.6-disp-rugosity;\n}\n\n\/\/ normal calc based on nimitz shader https:\/\/www.shadertoy.com\/view\/4sSSW3\nvec3 getNor(const in vec3 p, float rmPrec){  \n    vec2 e = vec2(-1., 1.)*rmPrec;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );\n}\n\n\/\/\/\/\/\/\/\/MAIN\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float cam_a = 0.;\/\/cos(TIME_RATIO*0.5); \/\/ angle z\n    float cam_e = 0.;\/\/sin(TIME_RATIO*0.5); \/\/ elevation\n    float cam_d = 2.; \/\/ distance to origin axis\n    vec3 camUp=vec3(0,1,0.);\/\/Change camere up vector here\n  \tvec3 camView=vec3(0,0,0); \/\/Change camere view here\n  \tfloat li = 0.6; \/\/ light intensity\n    float rmPrec = 0.001; \/\/ ray marching precision\n    float maxd = 10.; \/\/ ray marching distance max\n    float refl_i = 0.8; \/\/ reflexion light intensity\n    float refr_a = 0.95; \/\/ refraction angle\n    float refr_i = 0.2; \/\/ refraction light intensity\n    float bii = 0.35; \/\/ bright init intensity\n    \n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \n    if ( iMouse.z>0.) refr_a = iMouse.y\/iResolution.y * 1.; \/\/ mouse y axis \n    \n    vec2 su = iResolution.xy;\n\tvec2 uv = (2.*fragCoord.xy -su)\/su.y;\n    \n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(-sin(cam_a)*cam_d, cam_e, cos(cam_a)*cam_d); \/\/\n  \tvec3 rov = normalize(camView-ro);\n    vec3 u = normalize(cross(camUp,rov));\n  \tvec3 v = cross(rov,u);\n  \tvec3 rd = normalize(rov + uv.x*u + uv.y*v);\n    \n    vec2 e = vec2(-1., 1.)*0.005; \n            \n    float b = bii;\n    float s = rmPrec;\n    float d = 0.;\n    \n    vec3 p = ro+rd*d;\n    \n    vec3 n, ray, cubeRay;\n    \n    for(int k=0;k<REFLEXIONS_STEP;k++)\n    {\n        for(int i=0;i<ITERATIONS_MAX;i++)\n        {      \n            if (s<rmPrec||s>maxd) break;\n            s = map(p);\n            d += s;\n            p = ro+rd*d;\n        }\n\n        if (d<maxd)\n        {\n            n = getNor(p, rmPrec);\n            vec3 np = normalize(p);\n\n            vec3 voroCol = voronoiSphereMapping(np);\n            vec3 marchCol = vec3(max(0.,2.3-d));\n            \n            vec3 coln = normalize(mix(marchCol,voroCol,0.7)); \/\/ cell teinte\n\n            b = li+bii;\n\n            ray = reflect(rd, n);\n            cubeRay = textureCube(iChannel0, ray).rgb  * refl_i * coln;\n\n            ray = refract(rd, n, refr_a);\n            cubeRay += textureCube(iChannel0, ray).rgb * refr_i * coln;\n\n            float ratio = float(k)\/float(REFLEXIONS_STEP);\n            \n            if ( k == 0 ) \n                col = cubeRay+pow(b,25.); \n            else \n                col = mix(col, cubeRay+pow(b,15.\/ratio), ratio*0.8);  \n\n            ro = p;\n            rd = ray;\n            s = rmPrec;\n            \/\/d = -1.; \/\/ uncomment for a weird reflection effect with k=5 iteration\n        }\n        else if (k==0)\n        {\n            b=bii+0.1;\n            col = textureCube(iChannel1, rd).rgb;\n        }\n    }\n\tfragColor.rgb = col;\n}","name":"","description":"","type":"image"}]}}