{"Shader":{"ver":"0.1","info":{"id":"XtlGzS","date":"1422994206","viewed":760,"name":"Tiny Planet Cutting Experience","username":"aiekick","description":"Tiny Planet Cutting Experience","likes":4,"published":3,"flags":0,"tags":["planet","tiny","cutting","experience"],"hasliked":0},"renderpass":[{"inputs":[{"id":10,"src":"\/presets\/tex09.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":23,"src":"\/presets\/cube01_0.png","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"id":23,"src":"\/presets\/cube01_0.png","ctype":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Stephane Cuillerdier - Aiekick\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/\/\/\/\/\/\/TIME RATIO\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n#define TIME_RATIO 0.5*sin(iGlobalTime*0.00000005)+0.5\n#define TIME_MORPHING_RATIO 0.5*sin(iGlobalTime*CUTTER_MODE_MORPHING_SPEED)+0.5\n#define NOISE_VALUE1 950.\n#define NOISE_VALUE2 1000.*TIME_RATIO\n\/\/\/\/\/\/\/\/CONSTANTS\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n#define PI 3.14159265359\n\/\/\/\/\/\/\/\/VARS\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n#define CUTTER_MODE_MORPHING_SPEED 0.8\n#define CUTTER_MODE_MORPHING_RATIO TIME_MORPHING_RATIO\n#define PLANET_ROT_SPEED 0.8\n#define CAMERA_ANGLE PI+RAYMARCHING_PRECISION\n#define CAMERA_SPEED 0.5\n#define CAM_ELEVATION 0.0\n#define CAM_ZOOM 5.0\n#define PLANET_RADIUS 3.\n#define WATER_RADIUS 3.02\n#define DISPLACE_RANGE 1.\n#define GROUND_THICKNESS 0.05\n#define RAYMARCHING_PRECISION 0.0005\n#define RAYMARCHING_STEP 150\n#define ZERO 0.000001\n#define ROUNDED_BOX_CORNER_RADIUS 0.1\n#define PLANET_SECTION_OFFSET 2.1\n#define KERNEL_RADIUS 2.25\n#define LIGHT_INTENSITY 0.76\n\/\/COLORS STRATUM STONE AND SNOW\n#define RANGE_STONE 0.2\n#define RANGE_SNOW 0.4\n#define RANGE_SAND_WATER_OFFSET 0.015\n\/\/\/\/\/\/\/\/COLORS\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n#define KERNEL_TEMPERATURE 2200.\n#define MANTLE0_TEMPERATURE 2200.\n#define MANTLE1_TEMPERATURE 400.\n\n\/\/ COLORS\nvec3 WATER_COLOR = vec3(0.\/255., 0.\/255., 255.\/255.);\nvec3 MANTLE_COLOR2 = vec3(138.\/255.,41.\/255.,8.\/255.);\nvec3 MANTLE_COLOR0 = vec3(247.\/255.,254.\/255.,46.\/255.);\nvec3 MANTLE_COLOR1 = mix(MANTLE_COLOR2, MANTLE_COLOR0,0.5);\nvec3 KERNEL_COLOR = vec3(255.\/255.,0.\/255.,0.\/255.);\nvec3 GROUND_COLOR = vec3(4.\/255., 180.\/255., 4.\/255.);\nvec3 STONE_COLOR = vec3(127.\/255., 117.\/255., 102.\/255.);\nvec3 SNOW_COLOR = vec3(255.\/255., 255.\/255., 255.\/255.);\nvec3 SAND_COLOR = vec3(250.\/255., 234.\/255., 115.\/255.);\n\n\/\/\/\/\/\/\/\/VARS\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nfloat PlanetRotY=0.0;\nfloat PlanetRotX=0.0;\n\n\/\/\/\/\/\/\/\/NOISE\/\/\/\/thanks to iq shaders\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nfloat random(float p) {return fract(sin(p)*NOISE_VALUE1);}\nfloat noise(vec2 p) {return random(p.x + p.y*NOISE_VALUE2);}\nvec2 sw(vec2 p) {return vec2( floor(p.x) , floor(p.y) );}\nvec2 se(vec2 p) {return vec2( ceil(p.x)  , floor(p.y) );}\nvec2 nw(vec2 p) {return vec2( floor(p.x) , ceil(p.y)  );}\nvec2 ne(vec2 p) {return vec2( ceil(p.x)  , ceil(p.y)  );}\nfloat snoise(vec2 p) {\n  \tvec2 inter = smoothstep(0., 1., fract(p));\n  \tfloat s = mix(noise(sw(p)), noise(se(p)), inter.x);\n  \tfloat n = mix(noise(nw(p)), noise(ne(p)), inter.x);\n  \treturn mix(s, n, inter.y);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/COLOR RANGE BY temperature \/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ return color from temperature \n\/\/http:\/\/www.physics.sfasu.edu\/astro\/color\/blackbody.html\n\/\/http:\/\/www.vendian.org\/mncharity\/dir3\/blackbody\/\n\/\/http:\/\/www.vendian.org\/mncharity\/dir3\/blackbody\/UnstableURLs\/bbr_color.html\nvec3 blackbody(float Temp){\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. \/ 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. \/ 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)\/255.;\n    if (Temp < 1000.) col *= Temp\/1000.;\n   \treturn col;\n}\n\n\/\/\/\/\/\/\/ROTATE\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nvec3 rotateX(vec3 pos, float alpha) {\nmat4 trans= mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(alpha), -sin(alpha), 0.0, 0.0, sin(alpha), cos(alpha), 0.0, 0.0, 0.0, 0.0, 1.0);\nreturn vec3(trans * vec4(pos, 1.0));\n}\nvec3 rotateY(vec3 pos, float alpha) {\nmat4 trans2= mat4(cos(alpha), 0.0, sin(alpha), 0.0, 0.0, 1.0, 0.0, 0.0,-sin(alpha), 0.0, cos(alpha), 0.0, 0.0, 0.0, 0.0, 1.0);\nreturn vec3(trans2 * vec4(pos, 1.0));\n}\n\/\/\/\/\/\/\/\/BASE OBJETS\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nfloat oplane( vec3 p, vec4 n ){return dot(p,n.xyz) + n.w;}\nfloat orbox(in vec3 p, vec3 b, float r ){return length(max(abs(p)-b,0.0))-r;}\nfloat osphere( vec3 p, float s ){return length(p)-s;}\n\n\/\/\/\/\/\/\/DISPLACEMENT\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nfloat displacement(vec3 p, float range)\n{\n    return snoise(p.yx)*snoise(p.zy)*snoise(p.zx)*range;\n}\n\n\/\/\/\/\/\/\/\/OP OBJETS\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nfloat owater(vec3 p)\n{\n    return osphere(p, WATER_RADIUS);\n}\nfloat oplanet( vec3 p ){\n  \tvec3 rotPX = rotateX(p, PlanetRotX*PLANET_ROT_SPEED);\n    vec3 rotPXY = rotateY(rotPX, PlanetRotY*PLANET_ROT_SPEED);\n    float d1 = osphere(rotPXY, PLANET_RADIUS);\n  \tfloat d2 = displacement(rotPXY, DISPLACE_RANGE);\n    float uDisp = d1-d2;\n    if ( uDisp <= WATER_RADIUS) uDisp += 0.05;\n    else uDisp -= 0.05;\n    return uDisp;\n}\nfloat okernel( vec3 p ){\n  \tvec3 rotPX = rotateX(p, PlanetRotX*PLANET_ROT_SPEED);\n    vec3 rotPXY = rotateY(rotPX, PlanetRotY*PLANET_ROT_SPEED);\n    float kernel = osphere(rotPXY, KERNEL_RADIUS);\n  \treturn kernel;\n}\nfloat ocutter( vec3 p ){\n   \tvec3 rotX1 = rotateX(p, -PI\/5.);\n    vec3 rotXY1 = rotateY(rotX1, -PI\/4.);\n    float ratio1 = PLANET_SECTION_OFFSET + 1.35;float dim1=2.5;\n    float dB =  orbox(rotXY1+vec3(ratio1,-ratio1,ratio1), vec3(dim1,dim1,dim1), ROUNDED_BOX_CORNER_RADIUS); \/\/ rounded box\n    \n    vec3 rotX2 = rotateX(p, PI\/5.);\n    vec3 rotXY2 = rotateY(rotX2, -PI\/4.);\n    float ratio2 = PLANET_SECTION_OFFSET + 0.5;float dim2=2.5;\n  \tfloat dS = osphere(rotXY2+vec3(ratio2,ratio2,ratio2), dim2); \/\/ sphere\n    \n    return mix(dB, dS, CUTTER_MODE_MORPHING_RATIO);\/\/ morph between two shapes\n}\n\n\/\/\/\/\/\/\/\/BOOLEANS OP\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5+0.5*(b-a)\/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);}\nfloat opI( float d1, float d2 ){return max(d1,d2);}\nfloat opU( float d1, float d2 ){return min(d1,d2);}\nfloat opS( float d1, float d2 ){return max(-d1,d2);}\nfloat opB( float d1, float d2, float b ){return smin( d1, d2, b );} \/\/ blend\n\n\/\/\/\/\/\/\/\/GLOBAL OBJECT\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nfloat map(vec3 p){\n   \treturn opB(opS(ocutter(p), opU(owater(p), oplanet(p))), okernel(p), 0.07);\n}\n\n\/\/ sky from iapafoto shader => https:\/\/www.shadertoy.com\/view\/Xtl3zM\nvec3 getSky(float offTime, vec3 size, sampler2D cloudTex, vec2 uv)\n{\n    \/\/stereo dir\n    \n    float t = 3.+offTime*.08;\n    float ct = cos(t);\n    float st = sin(t);\n\tfloat m = .55;\n    uv = (uv * 2. * m - m)*3.;\n    uv.x *= size.x\/size.y;\n    uv *= mat2(ct,st,-st,ct);\n\tvec3 rd = normalize(vec3(2.*uv.x,dot(uv,uv)-1.,2.*uv.y));\n    \n\tvec3 col = 2.5*vec3(0.18,0.33,0.45) - rd.y*1.5;\n    col *= 0.9;\n\tvec2 cuv = rd.xz*(1000.0)\/rd.y;\n    float cc = 1.;\n    float cc0 = texture2D( cloudTex, 0.00015*cuv +0.1+ 0.0043*offTime ).x;\n    float cc1 = 0.35*texture2D( cloudTex, 0.00015*2.0*cuv + 0.0043*.5*offTime ).x;\n    cc = 0.65*cc1 + cc0;\n    cc = smoothstep( 0.3, 1.0, cc0 );\n  \tcol = mix( col, vec3(0.95), 0.9*cc );\n    col = .35+.65*col;  \/\/ less background sky => higlight the Ball\n    \n   \treturn col;\n}\n\n\/\/ normal calc based on nimitz shader https:\/\/www.shadertoy.com\/view\/4sSSW3\nvec3 getNormal(const in vec3 p){  \n    vec2 e = vec2(-1., 1.)*RAYMARCHING_PRECISION;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );\n}\n\n\/\/\/\/\/\/\/\/MAIN\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 vColour = vec3(0.0);\n    float bright = 0.1;\n       \n    PlanetRotY = iGlobalTime * PLANET_ROT_SPEED;\n    PlanetRotX = iGlobalTime * PLANET_ROT_SPEED;\n\n    vec2 uv = fragCoord.xy\/iResolution.xy*2.-1.;\n    uv.x*=iResolution.x\/iResolution.y;\n    \n    \/\/Camera init\n  \tvec3 camUp=vec3(0,1,0);\/\/Change camere up vector here\n  \tvec3 camView=vec3(0,0,0); \/\/Change camere view here\n  \t\n    vec3 prp = vec3(-sin(CAMERA_ANGLE)*CAM_ZOOM, CAM_ELEVATION, cos(CAMERA_ANGLE)*CAM_ZOOM); \/\/cam init path\n  \t\n    float maxd = 10.; \/\/Max depth\n\n  \t\/\/Camera setup\n  \tvec3 vpn = normalize(camView-prp);\n  \tvec3 u = normalize(cross(camUp,vpn));\n  \tvec3 v = cross(vpn,u);\n  \tvec3 vcv = prp + vpn;\n  \tvec3 scrCoord = vcv + uv.x*u + uv.y*v;\n  \tvec3 scp=normalize(scrCoord-prp);\n\n  \t\/\/Raymarching\n  \tfloat s=0.0001;\n    float f=0.;\n    for(int i=0;i<RAYMARCHING_STEP;i++)\n  \t{\n    \tif (abs(s)<0.0001||f>maxd) break;\n    \ts=map(prp+scp*f);\n        f+=s;\n  \t}\n    \n    if (f<maxd)\n    {\n        vec3 pos = prp+scp*f;\n        vec3 nor = getNormal(pos);\n        vec3 norp = normalize(pos);\n        \n    \tvec3 c = GROUND_COLOR;\n        float d = length(pos);\n        float range_ratio = (d-PLANET_RADIUS);\n        float planet = oplanet(pos);\n        float water = owater(pos);\n\n        bright += dot(nor,norp)*0.8;\n        \n        \/\/ CUTTER\n        float kernel = okernel(pos);\n        float cutter = ocutter(pos); \n                \n        if ( cutter <= ZERO ) \/\/ cut coloring\n        { \n        \tif ( water <=ZERO && planet >=ZERO ) c = WATER_COLOR;\n            if ( planet <=ZERO && planet >= -GROUND_THICKNESS ) c = GROUND_COLOR;\n            else\n            {\n            \tc = blackbody(MANTLE1_TEMPERATURE); \/\/ limit between volumes\n                if ( d <= PLANET_RADIUS ) \/\/ mantle\n                {\n                \tfloat ratio = (d-KERNEL_RADIUS)\/(PLANET_RADIUS - KERNEL_RADIUS);\n                    float temp = mix(MANTLE0_TEMPERATURE, MANTLE1_TEMPERATURE, ratio);\n                    c = blackbody(temp);\n                }\n            }    \n            if ( kernel <= RAYMARCHING_PRECISION) { c = blackbody(KERNEL_TEMPERATURE);  } \/\/ kernel\n        }    \n        \n        if ( water <=RAYMARCHING_PRECISION && planet > ZERO ) c = WATER_COLOR;\n        else if ( water <= RANGE_SAND_WATER_OFFSET && water > ZERO && planet > ZERO ) c = SAND_COLOR;\n        else if ( planet >= ZERO ) c = GROUND_COLOR;\n        if ( range_ratio >= RANGE_STONE && planet >= -GROUND_THICKNESS*(1.-RANGE_STONE\/range_ratio)*8. ) c = STONE_COLOR;\n        if ( range_ratio >= RANGE_SNOW && planet >= -GROUND_THICKNESS*(1.-RANGE_SNOW\/range_ratio)*5. ) c = SNOW_COLOR;\n\n        if (cutter>ZERO) \n        {\n            vec3 rayReflect = reflect(prp, nor);\n        \tvec3 cube = textureCube(iChannel1, rayReflect).rgb;  \n            vColour = mix(vColour, bright*c+cube\/bright+pow(bright,15.0)*(1.-f*.01), 0.5);\n        }\n        else \n        {\n            bright += 0.1;\n            vColour = mix(vColour, (bright*c+pow(bright,8.0))*(1.0-f*.01), 1.0);\n        }\n\t}\n    else \/\/ draw sky and weird light ray\n    { \n        float time = 0.5*sin(iGlobalTime)+0.5;\n        \n        vec2 uv = fragCoord.xy\/iResolution.xy*2.-1.;\n        uv.x*=iResolution.x\/iResolution.y;\n        \n        vec3 uvv = vec3(uv,time*uv.y*-1.);uvv*=vec3(1.,-1.,-1.);\n        \n        vec2 uv2 = fragCoord.xy \/ iResolution.xy;\n        \n        vec3 sky = getSky(iGlobalTime, iResolution, iChannel2, uv2);\n        \n        vec3 cube = textureCube(iChannel0, uvv).rgb; \n        \n        vec3 envt = mix(sky,cube,0.3);\n        \n    \tvColour = mix(vColour, envt, 1.0); \n    }\n    \n    fragColor.rgb = vColour;\n}","name":"","description":"","type":"image"}]}}