{"Shader":{"ver":"0.1","info":{"id":"lss3DB","date":"1378951562","viewed":1635,"name":"Beehive","username":"movAX13h","description":"Bees 'drop' honey when they 'land'. Now and then a new bee spawns.","likes":17,"published":3,"flags":0,"tags":["2d","hexagon","bee"],"hasliked":0},"renderpass":[{"inputs":[{"id":8,"src":"\/presets\/tex07.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Beehive fragment shader by movAX13h, September 2013\n\n\/\/ NOTE: The texture in channel 0 is used as base for the texture of the wings.\n\/\/ If you wish to see 'The Bee' close-up, feel free to uncomment the following line:\n\/\/#define THE_BEE\n\nfloat time = iGlobalTime*0.8 - 2.0;\n\nfloat rand( float n )\n{\n  \treturn fract(cos(n)*41415.92653);\n}\n\nfloat noise(vec2 p)\n{\n  \tvec2 f  = smoothstep(0.0, 1.0, fract(p));\n  \tp  = floor(p);\n  \tfloat n = p.x + p.y*57.0;\n  \treturn mix(mix(rand(n+0.0), rand(n+1.0),f.x), mix( rand(n+57.0), rand(n+58.0),f.x),f.y);\n}\n\nfloat fbm( vec2 p )\n{\n\tmat2 m2 = mat2(1.6,-1.2,1.2,1.6);\t\n  \tfloat f = 0.5000*noise( p ); p = m2*p;\n  \tf += 0.2500*noise( p ); p = m2*p;\n  \tf += 0.1666*noise( p ); p = m2*p;\n  \tf += 0.0834*noise( p );\n  \treturn f;\n}\n\nfloat rand12(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 rand21(float p)\n{\n\treturn fract(vec2(sin(p * 591.32), cos(p * 391.32)));\n}\n\nvec2 rotate(vec2 p, float a)\n{\n\treturn vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));\n}\n\nconst float hexSize = 20.0;\n\nvec3 hexCoord(vec2 p)\n{\n\t\/\/ simulating a rotated cube...\n\t\/\/ got suggestions?\n\t\n    vec3 q = vec3(p \/ hexSize, 0.0);\n\tq.z = -0.5 * q.x - q.y;\n\t\n    float z = -0.5 * q.x - q.y;\n    q.y -= 0.5 * q.x;\n\t\n\tvec3 i = floor(q+0.5);\n    float s = floor(i.x + i.y + i.z);\n\tvec3 d = abs(i-q);\n\t\n\tif( d.x >= d.y && d.x >= d.z ) i.x -= s;\n\telse if( d.y >= d.x && d.y >= d.z )\ti.y -= s;\n\telse i.z -= s;\n\t\n    vec2 coord = vec2(i.x, ( i.y - i.z + (1.0-mod(i.x, 2.0)) ) \/ 2.0 );\n\tfloat dist = length(p - vec2(coord.x, coord.y - 0.5*mod(i.x-1.0, 2.0))*hexSize) \/ hexSize;\n\treturn vec3(coord, dist);\n}\n\nfloat wingsTex(vec2 p)\n{\n\tvec3 col = texture2D(iChannel0, p.yx*5.0).rgb;\n\treturn 0.3+0.8*smoothstep(0.2, 0.0, (col.r+col.g+col.b)\/3.0);\n}\n\nvoid bee(vec2 pos, float size, inout vec3 col, float t, bool mirror)\n{\n\tif (clamp(pos.x, 0.0, size) != pos.x || clamp(pos.y, 0.0, size) != pos.y) return;\n\t\n\tvec2 p = (pos \/ size - 0.5) - vec2(0.0, -0.1); \/\/ ran out of space ...\n\tif (mirror) p.x*=-1.0;\t\n\t\n\tfloat b = (1.1 - p.y)\/0.6;\n\tfloat flapping = -abs(sin(t*86.0)); \/\/ I know ...\n\tfloat f;\n\t\n\t\/\/ left wing\n\tf = smoothstep(0.0, -0.02, length(vec2(1.8*b, 1.0)*(rotate(p-vec2(-0.1+0.2*flapping, 0.43+0.1*flapping), 0.3+flapping)))-0.2);\n\tcol += wingsTex(p+flapping)*f*b;\n\t\n\t\/\/ body\n\tf = smoothstep(0.0, -0.1, length(rotate(p-vec2(0.0, -0.05), 0.2+0.1*sin(time*4.0))*vec2(1.0, 1.4))-0.5);\n\tf = max(0.0, f-smoothstep(0.0, -0.1, length(vec2(1.0, 1.6)*(p-vec2(-0.45, -0.5)))-0.6));\n\tcol = mix(col, p.y+vec3(1.0, 0.8, 0.0)-0.5*sin(24.0*length(vec2(1.0, 1.3)*(p-vec2(-0.5, 0.1)))), f);\n\n\t\/\/ right wing\n\tf = smoothstep(0.0, -0.02, length(vec2(1.8*b, 1.0)*(rotate(p-vec2(0.04-0.1*flapping, 0.38+0.1*flapping), 0.3-flapping)))-0.2);\n\tcol += wingsTex(p-flapping)*f*b;\n\t\n\t\/\/ head\n\tf = smoothstep(0.0, -0.05, length(vec2(1.2, 1.0)*(p-vec2(-0.32, 0.03)))-0.2);\n\tcol = mix(col, vec3(0.8, 0.6, 0.0)-0.12*cos(p.y*15.0), f);\n\t\n\t\/\/ left eye ball\n\tf = smoothstep(0.0, -0.02, length(vec2(1.4, 1.0)*(p-vec2(-0.42, 0.05)))-0.1);\n\tcol = mix(col, vec3(smoothstep(0.2, -0.1, length(vec2(1.3, 1.0)*(p-vec2(-0.44, 0.05)))-0.1)), f);\n\t\n\t\/\/ left eye iris\n\tf = smoothstep(0.0, -0.02, length(vec2(1.6, 0.9)*(p-vec2(-0.46, 0.05)))-0.06);\n\tcol = mix(col, vec3(0.2, 0.2, 0.8), f);\n\t\n\t\/\/ left eye pupil\n\tf = smoothstep(0.0, -0.02, length(vec2(1.4, 1.0)*(p-vec2(-0.47, 0.055)))-0.04);\n\tcol = mix(col, vec3(0.0), f);\n\n\t\/\/ right eye ball\t\n\tf = smoothstep(0.0, -0.02, length(vec2(1.4, 1.0)*(p-vec2(-0.34, 0.05)))-0.1);\n\tcol = mix(col, vec3(smoothstep(0.2, -0.1, length(vec2(1.3, 1.0)*(p-vec2(-0.36, 0.05)))-0.1)), f);\n\n\t\/\/ right eye iris\n\tf = smoothstep(0.0, -0.02, length(vec2(1.6, 0.9)*(p-vec2(-0.365, 0.05)))-0.06);\n\tcol = mix(col, vec3(0.2, 0.2, 0.8), f);\n\t\n\t\/\/ right eye pupil\n\tf = smoothstep(0.0, -0.02, length(vec2(1.4, 1.0)*(p-vec2(-0.372, 0.055)))-0.04);\n\tcol = mix(col, vec3(0.0), f);\n\t\n\t\/\/ eyelids\n\tf = smoothstep(0.0, -0.03, length(vec2(1.32, 1.1)*(p-vec2(-0.386, 0.06)))-0.17);\n\tf = max(0.0, f-smoothstep(0.0, -0.03, length(vec2(1.0, 1.0)*(p-vec2(-0.42, -0.2 - step(0.99, sin(time*0.9))*max(0.0, 0.2*sin(t*18.0)))))-0.3));\n\tcol = mix(col, vec3(1.0, 0.8, 0.0) - 0.3*sin(15.0*min(length(p-vec2(-0.46, 0.17)), length(p-vec2(-0.33, 0.16)))-0.4), f);\n\t\t\n\t\/\/ mouth (needs improvement!)\n\tf = smoothstep(0.0, -0.02, length(vec2(1.1, 0.7)*(p-vec2(-0.37, -0.11)))-0.06);\n\tcol = mix(col, vec3(0.8, 0.6, 0.0)-0.07*sin(p.y*40.0+0.5)*sin(p.x*80.0+1.5), f);\n\t\n\t\/\/ left antenna (can get better)\n\tf = smoothstep(0.0, -0.03, length(vec2(1.6, 1.1)*(p-vec2(-0.47, 0.25)))-0.17);\n\tf = max(0.0, f-smoothstep(0.0, -0.03, length(vec2(1.6, 0.9)*(p-vec2(-0.49, 0.21)))-0.17));\n\tcol = mix(col, vec3(0.8, 0.6, 0.0) + 0.4*sin(p.y*18.0-0.4), f);\n\n\t\/\/ right antenna (can get better)\n\tf = smoothstep(0.0, -0.03, length(vec2(1.6, 1.1)*(p-vec2(-0.37, 0.24)))-0.17);\n\tf = max(0.0, f-smoothstep(0.0, -0.03, length(vec2(1.6, 0.9)*(p-vec2(-0.40, 0.20)))-0.17));\n\tcol = mix(col, vec3(0.8, 0.6, 0.0) + 0.2*sin(p.y*18.0), f);\n\t\n\t\/\/ legs (they are so small, let's skip for now and see if they are needed at all)\n\t\/\/ [even more small squeezed circles]\n}\n\nstruct Agent\n{\n\tvec2 hash;\n\tvec2 pos;\n\tvec2 workplace;\n\tfloat lifetime; \/\/ 0 to 1\n};\n\nconst float cycleDuration = 6.0;\n\t\nAgent spawnAgent(float t, vec2 bounds) \/\/ time and bounds (+\/-)\n{\n\tfloat tick = floor(t\/cycleDuration);\n\tfloat lifetime = t\/cycleDuration - tick; \/\/ 0 to 1\n\t\n\tvec2 hash = 2.0*(rand21(tick)-0.5);\n\t\n\tvec2 begin = vec2(sign(hash.x), hash.y) * bounds;\n\tvec2 target = rand21(begin.y+hash.x) * bounds * 0.5 * -sign(hash);\n\tvec2 workplace = target;\n\tvec2 way = target - begin;\n\n\tfloat animtime = lifetime;\n\tif (animtime > 0.5)\n\t{\n\t\tanimtime -= 0.5;\n\t\tbegin = target;\n\t\ttarget = vec2(sign(way.x)*bounds.x, way.y)*1.5;\n        target.y *= -1.0;\n\t\tway = target - begin;\n\t}\n\t\n\tvec2 pos = begin + way*(smoothstep(0., 0.3, animtime));\n\tpos += vec2(cos(t*(4.0+hash.x))*10.0, sin(t*(4.0+hash.y))*10.0); \/\/ variation\n\t\n\treturn Agent(hash, pos, workplace, lifetime);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy*0.5);\n\n\t#ifdef THE_BEE\n\t\tvec3 col = vec3(0.501);\n\t\tif (iMouse.z < 1.0)\n\t\t{\n\t\t\tbee(uv-vec2(-270.0, -150.0), 300.0, col, time, true);\n\t\t\tbee(uv-vec2(110.0, -200.0), 50.0, col, time, true);\n\t\t\tbee(uv-vec2(60.0, -130.0), 20.0, col, time, false);\n\t\t\tbee(abs(uv-vec2(220.0, 0.0)), 100.0, col, time, true);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbee(uv+vec2(iResolution.y*0.5), iResolution.y, col, time, true);\n\t\t}\n\t#else\n\t\tvec2 shift = vec2(100.0*sin(iGlobalTime*0.335), 100.0*sin(iGlobalTime*0.313));\n\t\tuv += shift;\n\t\n\t\tvec3 hex = hexCoord(uv);\n\t\tvec3 col = vec3(0.6, 0.3, 0.0)-0.2*fbm(vec2(uv.x-time*28.0, uv.y)*0.008);\n\t\tfloat cellHash = rand12(hex.xy);\n\t\tcol = mix(col, vec3(1.0), smoothstep(0.2, 1.0, hex.b));\n\t\tcol -= 0.1*cellHash;\n\t\t\n\t\tvec2 bounds = iResolution.xy*0.7; \/\/ taken +\/- (from center)\n\n\t\t\/\/ thumbnail version\n\t\tif (iResolution.y < 250.0) \n\t\t{\n\t\t\tvec2 p = vec2(iResolution.x*0.4, iResolution.y*0.4+10.0*sin(time*3.0));\n\t\t\tbee(uv+p-shift, iResolution.y*0.8, col, time, true); \n\t\t\tp = vec2(-90.0, 20.0+10.0*sin(time*4.0));\n\t\t\tbee(uv+p-shift, 20.0, col, time + 10.0, false); \n\t\t}\n\t\telse \n\t\t{\n\t\t\tfloat num = time \/ 5.123;\n\t\t\tfor (float i = 0.0; i < 80.0; i++)\n\t\t\t{\t\n\t\t\t\tif (i > num) break; \/\/continue; \/\/ break did not work with my old GPU\n\t\t\t\t\n\t\t\t\tfloat t = time+i*5.123;\n\t\t\t\tAgent a = spawnAgent(t, bounds);\n\t\t\t\tvec3 ahex = hexCoord(a.workplace + vec2(hexSize, 0.0));\n\t\t\t\tfloat dist = length(hex.xy - ahex.xy);\n\t\t\t\tif (dist < 5.0)\tcol -= 0.04*(5.0-dist)*smoothstep(0.1, 0.0, min(0.1, abs(a.lifetime-0.5)));\n\t\t\t\tbee(uv-a.pos, 20.0+220.0*(max(0.0, a.lifetime-0.5)), col, t*1.235, a.hash.x < 0.0);\n\t\t\t}\n\t\t}\n\t#endif\n\t\n\tfragColor = vec4(col,1.0);\n}","name":"","description":"","type":"image"}]}}