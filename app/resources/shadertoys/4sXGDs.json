{"Shader":{"ver":"0.1","info":{"id":"4sXGDs","date":"1382918249","viewed":6897,"name":"Pool","username":"iq","description":"Raytraced pool table.","likes":31,"published":3,"flags":0,"tags":["3d","raytracing"],"hasliked":0},"renderpass":[{"inputs":[{"id":4,"src":"\/presets\/tex03.jpg","ctype":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":24,"src":"\/presets\/cube02_0.jpg","ctype":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"id":25,"src":"\/presets\/cube03_0.png","ctype":"cubemap","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define eps 0.001\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nvec2 hash2( float n )\n{\n    return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123));\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\nfloat distanceToSegment( vec2 a, vec2 b, vec2 p )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn length( pa - ba*h );\n}\n\nvec3 nSphere( in vec3 pos, in vec4 sph )\n{\n    return (pos-sph.xyz)\/sph.w;\n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\t\n\th = sqrt(h);\n\t\n\tfloat t1 = -b - h;\n\tfloat t2 = -b + h;\n\t\n\tif( t1<eps && t2<eps )\n\t\treturn -1.0;\n\t\n\tif( t1<eps )\n\t\treturn t2;\n\t\n\treturn t1;\n}\n\n\nfloat sSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tfloat res = 1.0;\n\t\n\tvec3 oc = sph.xyz - ro;\n\tfloat b = dot( oc, rd );\n\t\n\tif( b<0.0 ) \n\t{\n\t\tres = 1.0;\n\t}\n\telse\n\t{\n\t    float h = sqrt( dot(oc,oc) - b*b ) - sph.w;\n\t\t\n        res = clamp( 16.0 * h \/ b, 0.0, 1.0 );\n\t}\n\treturn res;\n\n\t\n\t\n\treturn res;\n}\n\n\nvec3 nPlane( in vec3 ro, in vec4 obj )\n{\n    return obj.xyz;\n}\n\n\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pla )\n{\n    return (-pla.w - dot(pla.xyz,ro)) \/ dot( pla.xyz, rd );\n}\n\nfloat sPlane( in vec3 ro, in vec3 rd, in vec4 pla )\n{\n    float t = (-pla.w - dot(pla.xyz,ro)) \/ dot( pla.xyz, rd );\n\t\n\tif( t<0.0 ) return 1.0;\n\treturn 0.0;\n}\n\nvec4 sphere[4];\n\nvec2 intersect( in vec3 ro, in vec3 rd, out vec3 uvw )\n{\n\tvec2 res = vec2( 1e20, -1.0 );\n    float t;\n\t\n\tt = iPlane( ro, rd, vec4(0.0,1.0,0.0,0.0) ); if( t>eps && t<res.x ) { res = vec2( t, 0.0 ); uvw = ro+rd*t; }\n\n\tt = iSphere( ro, rd, sphere[0] ); if( t>eps && t<res.x ) { res = vec2( t, 1.0 ); uvw = ro+rd*t - vec3(sphere[0].xyz); }\n    t = iSphere( ro, rd, sphere[1] ); if( t>eps && t<res.x ) { res = vec2( t, 2.0 ); uvw = ro+rd*t - vec3(sphere[1].xyz); }\n    t = iSphere( ro, rd, sphere[2] ); if( t>eps && t<res.x ) { res = vec2( t, 3.0 ); uvw = ro+rd*t - vec3(sphere[2].xyz); }\n    t = iSphere( ro, rd, sphere[3] ); if( t>eps && t<res.x ) { res = vec2( t, 4.0 ); uvw = ro+rd*t - vec3(sphere[3].xyz); }\n\t\t\t\t\t  \n    return res;\t\t\t\t\t  \n}\n\nvec3 calcNormal( in vec3 pos, in float mat )\n{\n\tvec3 nor = vec3(0.0);\n\t\n\tif( mat<4.5 ) nor = nSphere( pos, sphere[3] );\n\tif( mat<3.5 ) nor = nSphere( pos, sphere[2] );\n\tif( mat<2.5 ) nor = nSphere( pos, sphere[1] );\n\tif( mat<1.5 ) nor = nSphere( pos, sphere[0] );\n\tif( mat<0.5 ) nor = nPlane(  pos, vec4(0.0,1.0,0.0,1.0) );\n\t\t\t\t\t  \n    return nor;\t\t\t\t\t  \n}\n\nfloat shadow( in vec3 ro, in vec3 rd )\n{\n#if 0\n\tvec2 res = vec2( 1e20, 1.0 );\n\t\n    float t = 0.0;\n\tt = iSphere( ro, rd, sphere[0] ); if( t>eps && t<res.x ) res = vec2( t, 0.0 );\n    t = iSphere( ro, rd, sphere[1] ); if( t>eps && t<res.x ) res = vec2( t, 0.0 );\n    t = iSphere( ro, rd, sphere[2] ); if( t>eps && t<res.x ) res = vec2( t, 0.0 );\n    t = iSphere( ro, rd, sphere[3] ); if( t>eps && t<res.x ) res = vec2( t, 0.0 );\n    t = iPlane(  ro, rd, vec4(0.0,1.0,0.0,1.0)  ); if( t>eps && t<res.x ) res = vec2( t, 0.0 );\n\t\n    return res.y;\t\t\t\t\t  \n#else\n\n\tfloat res = 1.0;\n\t\n    float t = 0.0;\n\tt = sSphere( ro, rd, sphere[0] ); res = min( t, res );\n    t = sSphere( ro, rd, sphere[1] ); res = min( t, res );\n    t = sSphere( ro, rd, sphere[2] ); res = min( t, res );\n    t = sSphere( ro, rd, sphere[3] ); res = min( t, res );\n    t = sPlane(  ro, rd, vec4(0.0,1.0,0.0,1.0) ); res = min( t, res );\n\t\n    return res;\t\t\t\t\t  \n\n\n#endif\t\n}\n\nvec3 doEnvironment( in vec3 rd )\n{\n\treturn 24.0*pow( textureCube( iChannel1, rd ).xyz, vec3(2.2) );\n}\n\nvec3 doEnvironmentBlurred( in vec3 rd )\n{\n\treturn 9.0*pow( textureCube( iChannel2, rd ).xyz, vec3(2.2) );\n}\n\n\nvec4 doMaterial( in vec3 pos, in vec3 nor, float ma )\n{\n\tvec4 mate = vec4(0.0);\n\tif( ma<4.5 ) { mate = vec4(0.30,0.25,0.20,1.0)*1.25; }\n\tif( ma<3.5 ) { mate = vec4(0.00,0.10,0.20,1.0)*1.25; \n                   mate.xyz = mix( mate.xyz, vec3(0.29, 0.27, 0.25 ), smoothstep( 0.9, 0.91, abs(pos.z) ) ); \n\t\t\t\t   float d = distanceToSegment( vec2(0.22,0.0), vec2(-0.22,0.0), pos.yx );\n\t\t\t\t   mate.xyz *= smoothstep( 0.04, 0.05, d );\n\t\t\t\t }\n\tif( ma<2.5 ) { mate = vec4(0.20,0.20,0.00,1.0)*1.25;\n                   mate.xyz = mix( mate.xyz, vec3(0.29, 0.27, 0.25 ), smoothstep( 0.9, 0.91, abs(pos.x) ) ); \n                   float d1 = distanceToSegment( vec2(0.22,0.12), vec2(-0.22,0.12), pos.yz );\n                   float d2 = distanceToSegment( vec2(0.22,-0.12), vec2(-0.22,-0.12), pos.yz );\n                   float d = min( d1, d2 );\n                   mate.xyz *= smoothstep( 0.04, 0.05, d );\n\t\t\t\t }\n\tif( ma<1.5 ) { mate = vec4(0.20,0.00,0.00,1.0)*1.25;\n                   mate.xyz = mix( mate.xyz, vec3(0.29, 0.27, 0.25 ), smoothstep( 0.9, 0.91, abs(pos.x) ) + smoothstep( 0.55, 0.56, abs(pos.y) ) ); \n                   float d1 = distanceToSegment( vec2(0.22,0.0), vec2(-0.22,0.0), pos.yz );\n                   float d2 = distanceToSegment( vec2(0.22,0.0), vec2( -0.07,-0.2), pos.yz*vec2(1.0,-sign(pos.x)) );\n                   float d3 = distanceToSegment( vec2(-0.07,-0.2), vec2(-0.07,0.04), pos.yz*vec2(1.0,-sign(pos.x)) );\n                   float d = min(d1,min(d2,d3));\n                   mate.xyz *= smoothstep( 0.04, 0.05, d );\n                 }\n\tif( ma<0.5 ) { mate = vec4(0.01,0.20,0.03,0.0)*1.25; \n                   mate.xyz *= 0.78 + 0.22*texture2D( iChannel3, 0.1*pos.xz ).x; \n                 }\n\treturn mate;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 m = vec2(0.5);\n\tif( iMouse.z>0.0 ) m = iMouse.xy\/iResolution.xy;\n\n    \/\/-----------------------------------------------------\n    \/\/ animate\n    \/\/-----------------------------------------------------\n\tfloat an = 1.3 + 0.1*iGlobalTime - 7.0*m.x;\n\tsphere[0] = vec4( 1.0,1.0, 1.0,1.0);\n\tsphere[1] = vec4(-4.0,1.0, 0.0,1.0);\n\tsphere[2] = vec4( 0.0,1.0, 3.0,1.0);\n\tsphere[3] = vec4( 5.0,1.0, -2.0,1.0);\n\n    \/\/ montecarlo\t\n\tvec3 tot = vec3(0.0);\n\tfor( int a=0; a<40; a++ )\n\t{\n\t\tvec4 rrr = texture2D( iChannel0, (fragCoord.xy +0.5+3.3137*float(a))\/iChannelResolution[0].xy  ).xzyw;\n\n        \/\/-----------------------------------------------------\n        \/\/ camera\n        \/\/-----------------------------------------------------\n\t\n        vec2 p = -1.0 + 2.0 * (fragCoord.xy + rrr.xy) \/ iResolution.xy;\n        p.x *= iResolution.x\/iResolution.y;\n\n\t    vec3 ro = vec3(8.0*sin(an),4.0,8.0*cos(an));\n        vec3 ta = vec3(0.0,0.0,0.0);\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n\t    vec3 rd = normalize( p.x*uu + p.y*vv + 3.0*ww );\n\n        \/\/ dof\n\t    vec3 fp = ro + rd * 8.0;\n\t    ro += (uu*rrr.z + vv*rrr.w)*0.5;\n\t    rd = normalize( fp - ro );\n\t\t\n\n        \/\/-----------------------------------------------------\n\t    \/\/ render\n        \/\/-----------------------------------------------------\n\n\t    vec3 col = vec3(0.0);\n        vec3 uvw = vec3(0.0);\n\t\n\t\t\/\/ raymarch\n\t\tvec2 tmat = intersect( ro, rd, uvw );\n\t\/\/\tif( tmat.y>-0.5 )\n\t\t{\n\t\t\tvec3 pos = ro + tmat.x*rd;\n\t\t\tvec3 nor = calcNormal( pos, tmat.y );\n\t\t    vec3 ref = reflect( rd, nor );\n\t\n\t\t\t\/\/ material\n\t\t\tvec4 mate = doMaterial( uvw, nor, tmat.y );\n\n\t\t\t\/\/ lighting\n\t\t\tvec3 lin = vec3(0.0);\n\t\t\t\n\t\t\t\/\/ diffuse\n            #if 0            \n\t\t    vec3  ru  = normalize( cross( nor, vec3(0.0,1.0,1.0) ) );\n\t\t    vec3  rv  = normalize( cross( ru, nor ) );\n            #else\n            \/\/ see http:\/\/orbit.dtu.dk\/fedora\/objects\/orbit:113874\/datastreams\/file_75b66578-222e-4c7d-abdf-f7e255100209\/content\n            \/\/ (link provided by nimitz)\n            vec3 tc = vec3( 1.0+nor.z-nor.xy*nor.xy, -nor.x*nor.y)\/(1.0+nor.z);\n            vec3 ru = vec3( tc.xz, -nor.x );\n       \t    vec3 rv = vec3( tc.zy, -nor.y );\n            #endif        \n            \n\t\t    for( int j=0; j<3; j++ )\n\t\t    {\n                vec2  aa = hash2( rrr.x + float(j)*203.1 + float(a)*13.713 );\n                float ra = sqrt(aa.y);\n                float rx = ra*cos(6.2831*aa.x); \n                float ry = ra*sin(6.2831*aa.x);\n                float rz = sqrt( 1.0-aa.y );\n                vec3  rr = vec3( rx*ru + ry*rv + rz*nor );\n                lin += shadow( pos, rr ) * doEnvironmentBlurred( rr );\n\t\t\t}\n\t\t\tlin \/= 3.0;\n\t        \/\/ bounce\n\t\t    lin += 1.5*clamp(0.3-0.7*nor.y,0.0,1.0)*vec3(0.0,0.2,00);\n\t\t\t\/\/ rim\n\t\t\tlin *= 1.0 + 6.0*mate.xyz*mate.w*pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 2.0 );;\n            \/\/ specular\n\t\t\tfloat fre = 0.04 + 4.0*pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 5.0 );\n\t\t\t\/\/lin += 1.0*doEnvironment(ref ).xyz * mate.w * fre * shadow( pos, ref );\n\t\t\tlin += 1.0*doEnvironment(ref ).xyz * mate.w * fre * step( 0.0, ref.y );\n\t\t\t\n            \/\/ light-material interaction\t\t\t\n\t\t\tcol = mate.xyz * lin;\n\t\t}\n\n\t\ttot += col;\n\t}\n\ttot \/= 40.0;\n\t\n    \/\/ gamma\n\ttot = pow( clamp(tot,0.0,1.0), vec3(0.45) );\n\n\t\/\/tot = tot*0.5 + 0.5*tot*tot*(3.0-2.0*tot);\n    tot *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15 );\n\n    fragColor = vec4( tot, 1.0 );\n}\n","name":"","description":"","type":"image"}]}}