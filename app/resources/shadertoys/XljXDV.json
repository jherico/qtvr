{"Shader":{"ver":"0.1","info":{"id":"XljXDV","date":"1446950350","viewed":452,"name":"2015\/11\/07","username":"hughsk","description":"Expanding on 2015\/11\/04: https:\/\/www.shadertoy.com\/view\/Xt2SDV<br\/><br\/>This adds multiple colored point lights, makes the circles a little more disorderly and blobs them in from the edges.","likes":7,"published":3,"flags":0,"tags":["2d","shadow","light","point"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define STEPS 80\n\n#define sr(a) (a * 2.0 - 1.0)\n#define rs(a) (a * 0.5 + 0.5)\n#define sq(a) (a * vec2(1, iResolution.y \/ iResolution.x))\n\nfloat random(vec2 co) {\n   return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (b - a) \/ k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat sdBox( vec2 p, vec2 b )\n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat t = iGlobalTime * 1.;\n\nfloat map(vec2 p, vec4 ro) {\n    vec2 P = p;\n    \n    float w = 0.15;\n    float r = 0.03125;\n    float a = t;\n    float d = 0.0;\n    \n    p.y += iGlobalTime * 0.15;\n    \n    vec2 idx = floor(p \/ w * 0.5 + 0.5);\n    \n    r += sin((idx.x + idx.y) * 2. + t * 5.) * 0.009;\n    a += sin((idx.x + idx.y) * 2.);\n    a += random(idx) * 5.;\n    \n    p = mod(p + w, w * 2.) - w;\n    d = length(p - 0.095 * vec2(sin(a), cos(a))) - r;\n    d = smin(d, length(P) - 0.25, 0.05);\n    \n    \/\/ \"push\" away any surfaces close to the lights\n    d = -smin(-d, length(P - ro.xy) - 0.05, 0.05);\n    d = -smin(-d, length(P - ro.zw) - 0.075, 0.05);\n    d = smin(d, -sdBox(P, sq(vec2(1))), 0.065);\n    \n\treturn d;\n}\n\nfloat shadow(vec2 uv, vec2 ro, vec2 rd, vec4 lights) {\n    float lim = 0.0005;\n    float res = -1.0;\n    float inc = lim * 2.0;\n    float t = inc;\n    float maxt = length(ro - uv);\n    \n    if (map(uv, lights) < 0.0) return 0.0;\n    \n    for (int i = 0; i < STEPS; i++) {\n        if (t >= maxt) return -1.0;\n        float d = map(uv - rd * t, lights);\n        if (d <= 0.0) return 0.0;\n        \n        t = min(t + d * 0.2, maxt);\n        res = t;\n    }\n    \n    return res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = sq(sr(fragCoord.xy \/ iResolution.xy));\n    vec2 ro1 = (iMouse.z > 0.\n        ? sq(sr(iMouse.xy \/ iResolution.xy))\n        : 0.5 * vec2(\n            sin(iGlobalTime),\n            cos(iGlobalTime)\n        ));\n    \n    vec2 ro2 = (sin(iGlobalTime * 0.2) + 2.5) * 0.15 * vec2(cos(iGlobalTime), sin(iGlobalTime));\n    vec4 lights = vec4(ro1, ro2);\n    \n    vec2 rd1 = normalize(uv - ro1);\n    vec2 rd2 = normalize(uv - ro2);\n    float s1 = shadow(uv, ro1, rd1, lights) > -0.5 ? 0.35 : 1.0;\n    float s2 = shadow(uv, ro2, rd2, lights) > -0.5 ? 0.35 : 1.0;\n    float l1 = s1 * pow(max(0.0, 1.0 - length(ro1 - uv) * 0.8), 2.5);\n    float l2 = s2 * pow(max(0.0, 1.0 - length(ro2 - uv) * 0.8), 2.5);\n    float d = map(uv, lights);\n    \n    vec3 lcol1 = vec3(1, 0.5, 0.3);\n    vec3 lcol2 = vec3(0, 1, 1);\n    \n    bool inside = d < 0.0;\n    bool stroke = d > -0.005 && inside; \n    vec3 m = inside ? vec3(stroke ? 0 : 5) : vec3(1, 0.9, 0.7);\n    \n\tfragColor = vec4(m * (l1 * lcol1 + l2 * lcol2), 1);\n}","name":"","description":"","type":"image"}]}}