{"Shader":{"ver":"0.1","info":{"id":"XtXGWn","date":"1420590764","viewed":793,"name":"Sonar","username":"jherico","description":"A work in progress, public so I can test the shadertoy API","likes":4,"published":3,"flags":0,"tags":["3d","shadertoyvr"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Based on 'Elevated' by by inigo quilez - iq\/2013\n\/\/ Modified by Brad Davis\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\/\/ value noise, and its analytical derivatives\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n\tfloat a = texture2D(iChannel0,(p+vec2(0.5,0.5))\/256.0,-100.0).x;\n\tfloat b = texture2D(iChannel0,(p+vec2(1.5,0.5))\/256.0,-100.0).x;\n\tfloat c = texture2D(iChannel0,(p+vec2(0.5,1.5))\/256.0,-100.0).x;\n\tfloat d = texture2D(iChannel0,(p+vec2(1.5,1.5))\/256.0,-100.0).x;\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\nfloat terrain( in vec2 x )\n{\n\tvec2  p = x*0.003;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<6; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x\/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\n\treturn 140.0*a;\n}\n\nfloat terrain2( in vec2 x )\n{\n\tvec2  p = x*0.003;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<14; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x\/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\n\treturn 140.0*a;\n}\n\nfloat terrain3( in vec2 x )\n{\n\tvec2  p = x*0.003;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x\/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\n\treturn 140.0*a;\n}\n\nfloat map( in vec3 p )\n{\n    return p.y - terrain(p.xz);\n}\n\nfloat interesct( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    float t = tmin;\n\tfor( int i=0; i<120; i++ )\n\t{\n\t\tfloat h = map( ro + t*rd );\n\t\tif( h<(0.002*t) || t>tmax ) break;\n\t\tt += 0.5*h;\n\t}\n\n\treturn t;\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd )\n{\n    \/\/ real shadows\t\n    float res = 1.0;\n    float t = 0.001;\n\tfor( int i=0; i<48; i++ )\n\t{\n\t    vec3  p = ro + t*rd;\n        float h = map( p );\n\t\tres = min( res, 16.0*h\/t );\n\t\tt += h;\n\t\tif( res<0.001 ||p.y>200.0 ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos, float t )\n{\n    vec2  eps = vec2( 0.002*t, 0.0 );\n    return normalize( vec3( terrain2(pos.xz-eps.xy) - terrain2(pos.xz+eps.xy),\n                            2.0*eps.x,\n                            terrain2(pos.xz-eps.yx) - terrain2(pos.xz+eps.yx) ) );\n}\n\nvec3 camPath( float time )\n{\n\treturn 1100.0*vec3( cos(0.0+0.23*time), 0.0, cos(1.5+0.21*time) );\n}\n\t\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*texture2D( iChannel0, p\/256.0 ).x; p = m2*p*2.02;\n    f += 0.2500*texture2D( iChannel0, p\/256.0 ).x; p = m2*p*2.03;\n    f += 0.1250*texture2D( iChannel0, p\/256.0 ).x; p = m2*p*2.01;\n    f += 0.0625*texture2D( iChannel0, p\/256.0 ).x;\n    return f\/0.9375;\n}\n\nconst vec3 DARKGREY = vec3(0.1);\nconst vec3 LIGHTGREY = vec3(0.2);\nconst vec3 WHITE = vec3(1);\nconst vec3 AMBER = vec3(1, 0.49, 0);\n\n\nvec3 fade(vec3 col1, vec3 col2, float max, float min, float actual) {\n    if (actual >= max) {\n        return col2;\n    }\n\n    if (actual <= min) {\n        return col1;\n    }\n    \n    float mixVal = (actual - min) \/ (max - min);\n    return mix(col1, col2, mixVal);\n}\n\nvec3 fade(vec3 col, float max, float min, float actual) {\n    return fade(col, DARKGREY, max, min, actual);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = -1.0 + 2.0*fragCoord.xy\/iResolution.xy;\n\tvec2 s = xy*vec2(iResolution.x\/iResolution.y,1.0);\n\n    float time = iGlobalTime*0.15 + 0.3 + 4.0*iMouse.x\/iResolution.x;\n\t\n\tvec3 light1 = normalize( vec3(-0.8,0.4,-0.3) );\n\n    \/\/ camera position\n\tvec3 ro = camPath( time );\n\tvec3 ta = camPath( time + 3.0 );\n\tro.y = terrain3( ro.xz ) + 11.0;\n\tta.y = ro.y - 20.0;\n\tfloat cr = 0.2*cos(0.1*time);\n\n    \/\/ camera ray    \n\n    #ifdef SHADERTOY_VR\n\tvec3  rd = normalize( iDir );\n    #else\n\tvec3  cw = normalize(ta-ro);\n\tvec3  cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3  cu = normalize( cross(cw,cp) );\n\tvec3  cv = normalize( cross(cu,cw) );\n\tvec3  rd = normalize( s.x*cu + s.y*cv + 2.0*cw );\n    #endif\n\n    \/\/ bounding plane\n    float tmin = 2.0;\n    float tmax = 2000.0;\n    float maxh = 210.0;\n    float tp = (maxh-ro.y)\/rd.y;\n    if( tp>0.0 )\n    {\n        if( ro.y>maxh ) tmin = max( tmin, tp );\n        else            tmax = min( tmax, tp );\n    }\n\n\tfloat sundot = clamp(dot(rd,light1),0.0,1.0);\n\tvec3 col;\n    float t = interesct( ro, rd, tmin, tmax );\n    float sec = fract(iGlobalTime \/ 2.0);\n    float dist = fract(t \/ 100.0);\n    if( t>tmax) {\n\t\tcol = DARKGREY;\n\t} else {\n        \/\/ mountains\t\t\n\t\tvec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t );\n        vec3 ref = reflect( rd, nor );\n        float fre = clamp( 1.0+dot(rd,nor), 0.0, 1.0 );\n        vec3 edge = fract(pos \/ vec3(40.0) + vec3(0.5));\n        vec3 mountainColor = LIGHTGREY;\n        mountainColor = fade(mountainColor, 500.0, 400.0, t);\n        vec3 gridColor = mountainColor;\n        if (edge.x < 0.03 ||edge.z < 0.03) {\n            gridColor = AMBER;\n        }\n        gridColor = fade(gridColor, 2000.0, 800.0, t);\n        mountainColor = fade(mountainColor, gridColor, 100.0, 80.0, t);\n        if (t < 100.0) {\n\t        vec3 highlightColor = vec3(0.1);\n            float dotVal = dot(rd, nor);\n            if (dotVal > 0.1) {\n            \thighlightColor = (dotVal + 0.2) * WHITE;\n            }\n\t        mountainColor = fade(highlightColor, mountainColor, 100.0, 50.0, t);\n        }\n\n        col = mountainColor;\n\/\/        if (t < 100.0 && abs(dist-sec) < 0.01) {\n\/\/        \tcol = mix(col, vec3(0,1,0), (1.0 - dist));\n\/\/        } else {\n\/\/\t\t\t    col = fade(col, 1000.0, 400.0, t);\n\/\/\t\t\t    col = fade(col, 200.0, 100.0, t);\n\/\/        }\n    }\n\n    \/\/ gamma\n\tcol = pow(col,vec3(0.4545));\n\n    \/\/ vignetting\t\n\tcol *= 0.5 + 0.5*pow( (xy.x+1.0)*(xy.y+1.0)*(xy.x-1.0)*(xy.y-1.0), 0.1 );\n\t\n    #ifdef STEREO\t\n    col *= vec3( isCyan, 1.0-isCyan, 1.0-isCyan );\t\n\t#endif\n\t\n\tfragColor=vec4(col,1.0);\n}","name":"","description":"","type":"image"}]}}