{"Shader":{"ver":"0.1","info":{"id":"ldVGDR","date":"1454071140","viewed":75,"name":"Flashing Balls","username":"dr2","description":"Another bouncing balls variation","likes":1,"published":3,"flags":32,"tags":["dynamics","collisions"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ \"Flashing Balls\" by dr2 - 2016\n\n\/\/ License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n\/*\nAnother bouncing balls variation. As before, the balls are elastic, and there is\ndamping and gravity. Colliding balls now flash and then fade back to their original\ncolors. The mouse controls box rotation.\n*\/\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nmat3 QToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2.\/3., 1.\/3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nconst float txRow = 64.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi = float (idVar);\n  return texture2D (txBuf, (vec2 (mod (fi, txRow), floor (fi \/ txRow)) + 0.5) \/\n     txSize);\n}\n\nconst float pi = 3.14159;\nconst vec3 nmEdge = vec3 (3, 3, 3);\nconst int nMol = int (nmEdge.x * nmEdge.y * nmEdge.z);\nvec3 pMol[nMol], ltDir, rdSign;\nfloat szMol[nMol], tmrMol[nMol], dstFar, hbLen, tmrMax;\nint idObj;\n\nfloat ObjDf (vec3 p)\n{\n  vec4 fVec;\n  vec3 q, eLen, eShift;\n  float dMin, d, eWid, sLen;\n  dMin = dstFar;\n  sLen = hbLen - 0.3;\n  eWid = 0.03;\n  eShift = vec3 (0., sLen, sLen);\n  eLen = vec3 (sLen + eWid, eWid, eWid);\n  fVec = vec4 (sLen * rdSign, 0.);\n  q = p;\n  d = min (min (PrBoxDf (q - fVec.xww, eLen.yxx),\n     PrBoxDf (q - fVec.wyw, eLen.xyx)), PrBoxDf (q - fVec.wwz, eLen.xxy));\n  if (d < dMin) { dMin = d;  idObj = 1; }\n  q = abs (p);\n  d = min (min (PrBoxDf (q - eShift, eLen), PrBoxDf (q - eShift.yxz, eLen.yxz)),\n     PrBoxDf (q - eShift.yzx, eLen.yzx));\n  if (d < dMin) { dMin = d;  idObj = 2; }\n  for (int n = 0; n < nMol; n ++) {\n    d = PrSphDf (p - pMol[n], 0.45 * szMol[n]);\n    if (d < dMin) { dMin = d;  idObj = 10 + n; }\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.0002, -0.0002, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (int j = 0; j < 5; j ++) {\n    d = 0.1 + float (j) \/ 8.;\n    ao += max (0., d - 3. * ObjDf (ro + rd * d));\n  }\n  return 0.7 + 0.3 * clamp (1. - 0.1 * ao, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 objCol;\n  vec3 c, col, vn;\n  float dstHit, tmr, ao;\n  int idObjT, idMol;\n  rdSign = sign (rd);\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    tmr = 0.;\n    if (idObj == 1) objCol = vec4 (0.8, 0.8, 1., 0.4);\n    else if (idObj == 2) objCol = vec4 (0.7, 0.7, 0.9, 0.4);\n    else {\n      idMol = idObj - 10;\n      for (int n = 0; n < nMol; n ++) {\n        if (n == idMol) {\n          tmr = tmrMol[n];\n          break;\n        }\n      }\n      tmr = sqrt (tmr \/ tmrMax);\n      c = vec3 (mix (float (idMol) \/ float (nMol), 0.2, tmr),\n         1. - 0.7 * tmr, 0.5 + 0.5 * tmr);\n      objCol = vec4 (min (HsvToRgb (c) + 0.2 * tmr * vec3 (1., 1., 0.5), 1.), 1.);\n    }\n    ao = (idObj == 1) ? ObjAO (ro, vn) : 1.;\n    col = objCol.rgb * (0.3 + 0.7 * ao * max (dot (vn, ltDir), 0.)) +\n       objCol.a * ao * pow (max (0., dot (ltDir, reflect (rd, vn))), 128.);\n  } else col = vec3 (0., 0., 0.1);\n  return clamp (col, 0., 1.);\n}\n\nvoid GetMols ()\n{\n  vec4 p;\n  for (int n = 0; n < nMol; n ++) {\n    p = Loadv4 (2 * n);\n    pMol[n] = p.xyz;\n    szMol[n] = p.w;\n    tmrMol[n] = Loadv4 (2 * n + 1).w;\n  }\n  hbLen = Loadv4 (2 * nMol).y;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 qtVu;\n  vec3 col, rd, ro;\n  vec2 canvas, uv, ut;\n  float tCur;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy \/ canvas - 1.;\n  uv.x *= canvas.x \/ canvas.y;\n  tCur = iGlobalTime;\n  ut = abs (uv) - vec2 (1.);\n  if (max (ut.x, ut.y) > 0.003) col = vec3 (0.82);\n  else {\n    dstFar = 100.;\n    qtVu = Loadv4 (2 * nMol + 1);\n    vuMat = QToRMat (qtVu);\n    rd = normalize (vec3 (uv, 8.)) * vuMat;\n    ro = vec3 (0., 0., -48.) * vuMat;\n    ltDir = normalize (vec3 (1., 1.5, -1.2)) * vuMat;\n    GetMols ();\n    tmrMax = 20.;\n    col = ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n","name":"","description":"","type":"image"},{"inputs":[{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ \"Flashing Balls\" by dr2 - 2016\n\n\/\/ License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 QMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n     q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n     q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n   - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n   - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 EulToQ (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\nconst float txRow = 64.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi = float (idVar);\n  return texture2D (txBuf, (vec2 (mod (fi, txRow), floor (fi \/ txRow)) + 0.5) \/\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi = float (idVar);\n  vec2 d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi \/ txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n\nconst float pi = 3.14159;\nconst vec3 nmEdge = vec3 (3, 3, 3);\nconst int nMol = int (nmEdge.x * nmEdge.y * nmEdge.z);\nvec4 qtVu;\nfloat hbLen, tmrMax;\n\nvoid Step (int mId, out vec3 r, out vec3 v, out float sz, out float tmr)\n{\n  vec4 p;\n  vec3 rn, vn, dr, f;\n  float fOvlap, fDamp, grav, rSep, szn, szMn, ms, dt;\n  fOvlap = 100.;\n  fDamp = 0.005;\n  grav = 1.;\n  p = Loadv4 (2 * mId);\n  r = p.xyz;\n  sz = p.w;\n  ms = sz * sz;\n  p = Loadv4 (2 * mId + 1);\n  v = p.xyz;\n  tmr = p.w;\n  f = vec3 (0.);\n  tmr = max (tmr - 1., 0.);\n  for (int n = 0; n < nMol; n ++) {\n    p = Loadv4 (2 * n);\n    rn = p.xyz;\n    szn = p.w;\n    dr = r - rn;\n    rSep = length (dr);\n    szMn = 0.5 * (sz + szn);\n    if (n != mId && rSep < szMn) {\n      f += fOvlap * (szMn \/ rSep - 1.) * dr;\n      tmr = tmrMax;\n    }\n  }\n  szMn = 0.5 * (sz + 1.);\n  dr = hbLen - abs (r);\n  f -= step (dr, vec3 (szMn)) * fOvlap * sign (r) * (szMn \/ abs (dr) - 1.) * dr +\n      vec3 (0., grav * ms, 0.) * QToRMat (qtVu) + fDamp * v;\n  dt = 0.02;\n  v += dt * f \/ ms;\n  r += dt * v;\n}\n\nvoid Init (int mId, out vec3 r, out vec3 v, out float sz, out float tmr)\n{\n  float fm;\n  fm = float (mId);\n  r = 1.5 * floor (vec3 (mod (fm, nmEdge.x),\n      mod (fm, nmEdge.x * nmEdge.y) \/ nmEdge.x,\n      fm \/ (nmEdge.x * nmEdge.y))) - 0.5 * (nmEdge - 1.);\n  v = 2. * normalize (vec3 (Hashff (fm), Hashff (fm + 0.3),\n     Hashff (fm + 0.6)) - 0.5);\n  sz = 1. - 0.5 * Hashff (fm + 0.1);\n  tmr = 0.;\n}\n\nvoid OrientVu (inout vec4 qtVu, vec4 mPtr, inout vec4 mPtrP, bool init)\n{\n  vec3 vq1, vq2;\n  vec2 dm;\n  float mFac;\n  if (! init) {\n    qtVu = vec4 (0., 0., 0., 1.);\n    mPtrP = vec4 (99., 0., -1., 0.);\n  } else {\n    if (mPtr.z > 0.) {\n      if (mPtrP.x == 99.) mPtrP = mPtr;\n      mFac = 1.5;\n      dm = - mFac * mPtrP.xy;\n      vq1 = vec3 (dm, sqrt (max (1. - dot (dm, dm), 0.)));\n      dm = - mFac * mPtr.xy;\n      vq2 = vec3 (dm, sqrt (max (1. - dot (dm, dm), 0.)));\n      qtVu = normalize (QMul (vec4 (cross (vq1, vq2), dot (vq1, vq2)), qtVu));\n      mPtrP = mPtr;\n    } else mPtrP = vec4 (99., 0., -1., 0.);\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, p;\n  vec3 r, v;\n  float tCur, sz, tmr;\n  int mId, pxId;\n  bool doInit;\n  vec2 kv = floor (fragCoord);\n  pxId = int (kv.x + txRow * kv.y);\n  if (kv.x >= txRow || pxId > 2 * nMol + 2) discard;\n  tCur = iGlobalTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy \/ iResolution.xy - 0.5;\n  qtVu = Loadv4 (2 * nMol + 1);\n  mPtrP = Loadv4 (2 * nMol + 2);\n  mId = pxId \/ 2;\n  tmrMax = 20.;\n  doInit = false;\n  if (iFrame < 2) {\n    hbLen = 3.5;\n    OrientVu (qtVu, mPtr, mPtrP, false);\n    stDat = vec4 (0., hbLen, tCur, 0.);\n    if (mId < nMol) doInit = true;\n  } else {\n    OrientVu (qtVu, mPtr, mPtrP, true);\n    stDat = Loadv4 (2 * nMol);\n    ++ stDat.x;\n    hbLen = stDat.y;\n    if (mPtrP.z < 0.) qtVu = normalize (QMul (EulToQ (0.2 * (tCur - stDat.z) *\n       pi * vec3 (-0.27, -0.34, -0.11)), qtVu));\n    stDat.z = tCur;\n    if (mId < nMol) {\n      Step (mId, r, v, sz, tmr);\n      p = (2 * mId == pxId) ? vec4 (r, sz) : vec4 (v, tmr);\n    }\n  }\n  if (doInit) {\n    Init (mId, r, v, sz, tmr);\n    p = (2 * mId == pxId) ? vec4 (r, sz) : vec4 (v, tmr);\n  }\n  if (pxId == 2 * nMol + 1) stDat = qtVu;\n  else if (pxId == 2 * nMol + 2) stDat = mPtrP;\n  Savev4 (pxId, ((pxId < 2 * nMol) ? p : stDat), fragColor, fragCoord);\n}\n","name":"","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ \"Flashing Balls\" by dr2 - 2016\n\n\/\/ License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 QMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n     q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n     q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n   - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n   - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 EulToQ (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\nconst float txRow = 64.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi = float (idVar);\n  return texture2D (txBuf, (vec2 (mod (fi, txRow), floor (fi \/ txRow)) + 0.5) \/\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi = float (idVar);\n  vec2 d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi \/ txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n\nconst float pi = 3.14159;\nconst vec3 nmEdge = vec3 (3, 3, 3);\nconst int nMol = int (nmEdge.x * nmEdge.y * nmEdge.z);\nvec4 qtVu;\nfloat hbLen, tmrMax;\n\nvoid Step (int mId, out vec3 r, out vec3 v, out float sz, out float tmr)\n{\n  vec4 p;\n  vec3 rn, vn, dr, f;\n  float fOvlap, fDamp, grav, rSep, szn, szMn, ms, dt;\n  fOvlap = 100.;\n  fDamp = 0.005;\n  grav = 1.;\n  p = Loadv4 (2 * mId);\n  r = p.xyz;\n  sz = p.w;\n  ms = sz * sz;\n  p = Loadv4 (2 * mId + 1);\n  v = p.xyz;\n  tmr = p.w;\n  f = vec3 (0.);\n  tmr = max (tmr - 1., 0.);\n  for (int n = 0; n < nMol; n ++) {\n    p = Loadv4 (2 * n);\n    rn = p.xyz;\n    szn = p.w;\n    dr = r - rn;\n    rSep = length (dr);\n    szMn = 0.5 * (sz + szn);\n    if (n != mId && rSep < szMn) {\n      f += fOvlap * (szMn \/ rSep - 1.) * dr;\n      tmr = tmrMax;\n    }\n  }\n  szMn = 0.5 * (sz + 1.);\n  dr = hbLen - abs (r);\n  f -= step (dr, vec3 (szMn)) * fOvlap * sign (r) * (szMn \/ abs (dr) - 1.) * dr +\n      vec3 (0., grav * ms, 0.) * QToRMat (qtVu) + fDamp * v;\n  dt = 0.02;\n  v += dt * f \/ ms;\n  r += dt * v;\n}\n\nvoid Init (int mId, out vec3 r, out vec3 v, out float sz, out float tmr)\n{\n  float fm;\n  fm = float (mId);\n  r = 1.5 * floor (vec3 (mod (fm, nmEdge.x),\n      mod (fm, nmEdge.x * nmEdge.y) \/ nmEdge.x,\n      fm \/ (nmEdge.x * nmEdge.y))) - 0.5 * (nmEdge - 1.);\n  v = 2. * normalize (vec3 (Hashff (fm), Hashff (fm + 0.3),\n     Hashff (fm + 0.6)) - 0.5);\n  sz = 1. - 0.5 * Hashff (fm + 0.1);\n  tmr = 0.;\n}\n\nvoid OrientVu (inout vec4 qtVu, vec4 mPtr, inout vec4 mPtrP, bool init)\n{\n  vec3 vq1, vq2;\n  vec2 dm;\n  float mFac;\n  if (! init) {\n    qtVu = vec4 (0., 0., 0., 1.);\n    mPtrP = vec4 (99., 0., -1., 0.);\n  } else {\n    if (mPtr.z > 0.) {\n      if (mPtrP.x == 99.) mPtrP = mPtr;\n      mFac = 1.5;\n      dm = - mFac * mPtrP.xy;\n      vq1 = vec3 (dm, sqrt (max (1. - dot (dm, dm), 0.)));\n      dm = - mFac * mPtr.xy;\n      vq2 = vec3 (dm, sqrt (max (1. - dot (dm, dm), 0.)));\n      qtVu = normalize (QMul (vec4 (cross (vq1, vq2), dot (vq1, vq2)), qtVu));\n      mPtrP = mPtr;\n    } else mPtrP = vec4 (99., 0., -1., 0.);\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, p;\n  vec3 r, v;\n  float tCur, sz, tmr;\n  int mId, pxId;\n  bool doInit;\n  vec2 kv = floor (fragCoord);\n  pxId = int (kv.x + txRow * kv.y);\n  if (kv.x >= txRow || pxId > 2 * nMol + 2) discard;\n  tCur = iGlobalTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy \/ iResolution.xy - 0.5;\n  qtVu = Loadv4 (2 * nMol + 1);\n  mPtrP = Loadv4 (2 * nMol + 2);\n  mId = pxId \/ 2;\n  tmrMax = 20.;\n  doInit = false;\n  if (iFrame < 2) {\n    hbLen = 3.5;\n    OrientVu (qtVu, mPtr, mPtrP, false);\n    stDat = vec4 (0., hbLen, tCur, 0.);\n    if (mId < nMol) doInit = true;\n  } else {\n    OrientVu (qtVu, mPtr, mPtrP, true);\n    stDat = Loadv4 (2 * nMol);\n    ++ stDat.x;\n    hbLen = stDat.y;\n    if (mPtrP.z < 0.) qtVu = normalize (QMul (EulToQ (0.2 * (tCur - stDat.z) *\n       pi * vec3 (-0.27, -0.34, -0.11)), qtVu));\n    stDat.z = tCur;\n    if (mId < nMol) {\n      Step (mId, r, v, sz, tmr);\n      p = (2 * mId == pxId) ? vec4 (r, sz) : vec4 (v, tmr);\n    }\n  }\n  if (doInit) {\n    Init (mId, r, v, sz, tmr);\n    p = (2 * mId == pxId) ? vec4 (r, sz) : vec4 (v, tmr);\n  }\n  if (pxId == 2 * nMol + 1) stDat = qtVu;\n  else if (pxId == 2 * nMol + 2) stDat = mPtrP;\n  Savev4 (pxId, ((pxId < 2 * nMol) ? p : stDat), fragColor, fragCoord);\n}\n","name":"","description":"","type":"buffer"}]}}