{"Shader":{"ver":"0.1","info":{"id":"ltBXWy","date":"1446138064","viewed":588,"name":"Dusty nebula 2","username":"Duke","description":"Variation of this <a href=\"https:\/\/www.shadertoy.com\/view\/4lSXD1\" class=\"regular\" target=\"_blank\">https:\/\/www.shadertoy.com\/view\/4lSXD1<\/a> shader. I am still trying to make nebula.","likes":10,"published":3,"flags":0,"tags":["star","space","nebula","dust"],"hasliked":0},"renderpass":[{"inputs":[{"id":28,"src":"\/presets\/tex15.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Variation of this https:\/\/www.shadertoy.com\/view\/4lSXD1 shader\n\/\/ Most of the code come from https:\/\/www.shadertoy.com\/view\/Xss3DS\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\/\/ change this to get different nebulas :)\n#define NEBULA_SEED 4.\n\n\n\/\/ the bounding sphere of the nebula. this is less general but means that\n\/\/ ray cast is only performed for nearby pixels, and raycast can begin from the sphere\n\/\/ (instead of walking out from the camera)\nfloat nebRadius = 2.72;\nvec3 nebCenter = vec3(0.,nebRadius,0.);\n\n\/\/ iq's noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D( iChannel1, (uv+ 0.5)\/256.0, -100.0 ).yx;\n\treturn -1.0+2.0*mix( rg.x, rg.y, f.z );\n}\n\n\/\/ assign colour to the media\nvec3 computeColour( float density, float radius )\n{\n\t\/\/ these are almost identical to the values used by iq\n\t\n\t\/\/ colour based on density alone. gives impression of occlusion within\n\t\/\/ the media\n\tvec3 result = mix( 1.1*vec3(1.0,0.9,0.8), vec3(0.4,0.15,0.1), density );\n\t\n\t\/\/ colour added for nebula\n\tvec3 colBottom = 3.1*vec3(0.8,1.0,1.0);\n\tvec3 colTop = 2.*vec3(0.48,0.53,0.5);\n\tresult *= mix( colBottom*2.0, colTop, min( (radius+.5)\/1.7, 1.0 ) );\n\t\n\treturn result;\n}\n\n\/\/ maps 3d position to colour and density\nfloat densityFn( in vec3 p, in float r, out float rawDens, in float rayAlpha )\n{\n    float l = length(p);\n\t\/\/ density has dependency on mouse y coordinate (linear radial ramp)\n\tfloat mouseIn = 1.1;\n\t\/\/if( iMouse.z > 0.0 )\n\t\t\/\/mouseIn = iMouse.y\/iResolution.y;\n\tfloat mouseY = 1.0 - mouseIn;\n    float den = 1. - 1.5*r*(4.*mouseY+.5);\n    \n\t\/\/ offset noise based on seed\n    float t = NEBULA_SEED;\n    vec3 dir = vec3(0.,1.,0.);\n    \n    \/\/ participating media    \n    float f;\n    vec3 q = p - dir* t; f  = 0.50000*noise( q );\n\tq = q*2.02 - dir* t; f += 0.25000*noise( q );\n\tq = q*2.03 - dir* t; f += 0.12500*noise( q );\n\tq = q*2.40 - dir* t; f += 0.06250*noise( q );\n    q = q*2.50 - dir* t; f += 0.03125*noise( q );\n    \n\t\/\/ add in noise with scale factor\n\trawDens = den + 4.0*f*l;\n\t\n    den = clamp( rawDens, 0.0, 1.0 );\n    \n    \/\/if (den>0.9) den = -3.*den;\n    \n\t\/\/ thin out the volume at the far extends of the bounding sphere to avoid\n\t\/\/ clipping with the bounding sphere\n\tden *= l*0.6-smoothstep(0.8,0.,r\/nebRadius);\n\t\n\treturn den;\n}\n\nvec4 raymarch( in vec3 rayo, in vec3 rayd, in float nebInter, in vec2 fragCoord )\n{\n    vec4 sum = vec4( 0.0 );\n     \n    float step = 0.075;\n     \n    \/\/ dither start pos to break up aliasing\n\tvec3 pos = rayo + rayd * (nebInter + step*texture2D( iChannel0, fragCoord.xy\/iChannelResolution[0].x ).x);\n    \n\n\t\n    for( int i=0; i<56; i++ )\n    {\n        if( sum.a > 0.99 ) continue;\n\t\t\n\t\tfloat radiusFromNebCenter = length(pos - nebCenter);\n\t\t\n\t\tif( radiusFromNebCenter > nebRadius+0.01 ) continue;\n\t\t\n\t\tfloat dens, rawDens;\n\t\t\n        dens = densityFn( pos, radiusFromNebCenter, rawDens, sum.a );\n        \n        float smoothStep =   float(i) + dens\/0.075;\n        \n\t\tdens = 1.1 - smoothStep\/56.0;\n\t\t\n\t\tvec4 col = vec4( computeColour(dens,radiusFromNebCenter), dens );\n\t\t\n\t\t\/\/ uniform scale density\n\t\tcol.a *= 0.031;\n\t\t\n\t\t\/\/ colour by alpha\n\t\tcol.rgb *= col.a\/0.6;\n\t\t\n\t\t\/\/ alpha blend in contribution\n\t\tsum = sum + col*(1.0 - sum.a);  \n\t\t\n\t\t\/\/ take larger steps through negative densities.\n\t\t\/\/ something like using the density function as a SDF.\n\t\tfloat stepMult = 1. + 2.5*(1.-clamp(rawDens+1.,1.,1.));\n\t\t\n\t\t\/\/ step along ray\n\t\tpos += rayd * step * stepMult;\n    }\n\t\n    return clamp( sum, 0.0, 1.0 );\n}\n\n\n\/\/ iq's sphere intersection\nfloat iSphere(in vec3 ro, in vec3 rd, in vec4 sph)\n{\n\t\/\/sphere at origin has equation |xyz| = r\n\t\/\/sp |xyz|^2 = r^2.\n\t\/\/Since |xyz| = ro + t*rd (where t is the parameter to move along the ray),\n\t\/\/we have ro^2 + 2*ro*rd*t + t^2 - r2. This is a quadratic equation, so:\n\tvec3 oc = ro - sph.xyz; \/\/distance ray origin - sphere center\n\t\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - sph.w * sph.w; \/\/sph.w is radius\n\tfloat h = b*b - c; \/\/ delta\n\tif(h < 0.0) \n\t\treturn -1.0;\n\tfloat t = (-b - sqrt(h)); \/\/Again a = 1.\n\n\treturn t;\n}\n\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos )\n{\n    \/\/ camera orbits around nebula\n\t\n    float camRadius = 3.8;\n\t\/\/ use mouse x coord\n\tfloat a = iGlobalTime*20.;\n\tif( iMouse.z > 0. )\n\t\ta = iMouse.x;\n\tfloat theta = -(a-iResolution.x)\/80.;\n    float xoff = camRadius * cos(theta);\n    float zoff = camRadius * sin(theta);\n    cameraPos = vec3(xoff,nebCenter.y,zoff);\n     \n    \/\/ camera target\n    vec3 target = vec3(0.,nebCenter.y,0.);\n     \n    \/\/ camera frame\n    vec3 fo = normalize(target-cameraPos);\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\n    vec3 up = normalize(cross(fo,ri));\n     \n    \/\/ multiplier to emulate a fov control\n    float fov = .5;\n\t\n    \/\/ ray direction\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\n\t\n\treturn rayDir;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\/\/ get aspect corrected normalized pixel coordinate\n    vec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x \/ iResolution.y;\n    \n\tvec3 rayDir, cameraPos;\n\t\n    rayDir = computePixelRay( p, cameraPos );\n\t\n\tvec4 col = vec4(0.);\n\t\n    \/\/ does pixel ray intersect with nebula bounding sphere?\n\tfloat boundingSphereInter = iSphere( cameraPos, rayDir, vec4(nebCenter,nebRadius) );\n\tif( boundingSphereInter > 0. )\n\t{\n\t\t\/\/ yes, cast ray\n\t    col = raymarch( cameraPos, rayDir, boundingSphereInter,fragCoord );\n\t}\n\t\n    \/\/ smoothstep final color to add contrast\n    fragColor = vec4((col.xyz*col.xyz*(6.3-2.0*col.xyz))*vec3(0.31,0.38,0.48),1.0);\n}\n","name":"","description":"","type":"image"}]}}