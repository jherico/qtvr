{"Shader":{"ver":"0.1","info":{"id":"ltjXWR","date":"1442966892","viewed":974,"name":"MegaWave 2","username":"aiekick","description":"MegaWave 2","likes":16,"published":3,"flags":0,"tags":["2","megawave"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Stephane Cuillerdier - Aiekick\/2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst vec3 ligthDir = vec3(0.,1., 0.5);\nconst float mPi = 3.14159;\nconst float m2Pi = 6.28318;\n\nfloat t = 0.;\n\nfloat dstepf = 0.;\n\nvec2 df(vec3 p)\n{\n\tdstepf += 0.001;\n\n\tvec2 res = vec2(1000.);\n\t\n\tvec3 q;\n\t\n\t\/\/ mat 2\n\tq.x = cos(p.x);\n\tq.y = p.y * 5. - 25. + 10. * cos(p.x \/ 7. + t) + 10. * sin(p.z \/ 7. + t);\n\tq.z = cos(p.z);\n\tfloat sphere = length(q) - 1.;\n\tif (sphere < res.x)\n\t\tres = vec2(sphere, 2.);\n\t\n\t\/\/ mat 3\n\tq.x = cos(p.x);\n\tq.y = p.y * 5. + 25. + 10. * cos(p.x \/ 7. + t + mPi) + 10. * sin(p.z \/ 7. + t + mPi);\n\tq.z = cos(p.z);\n\tsphere = length(q) - 1.;\n\tif (sphere < res.x)\n\t\tres = vec2(sphere, 3.);\n\t\t\n\treturn res;\n}\n\nvec3 nor( vec3 p, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n\t\tdf(p+e.xyy).x - df(p-e.xyy).x,\n\t\tdf(p+e.yxy).x - df(p-e.yxy).x,\n\t\tdf(p+e.yyx).x - df(p-e.yyx).x );\n    return normalize(n);\n}\n\n\/\/ from iq code\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<200; i++ )\n    {\n\t\tfloat h = df( ro + rd*t ).x;\n        res = min( res, 8.0*h\/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\/\/ from iq code\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)\/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = df( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\/\/--------------------------------------------------------------------------\n\/\/ Grab all sky information for a given ray from camera\n\/\/ from Dave Hoskins \/\/ https:\/\/www.shadertoy.com\/view\/Xsf3zX\nvec3 GetSky(in vec3 rd, in vec3 sunDir, in vec3 sunCol)\n{\n\tfloat sunAmount = max( dot( rd, sunDir), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32), v);\n\tsky = sky + sunCol * sunAmount * sunAmount * .25;\n\tsky = sky + sunCol * min(pow(sunAmount, 800.0)*1.5, .3);\n\treturn clamp(sky, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 f, in vec2 g )\n{\t\n\tvec2 si = iResolution.xy;\n    \n\tvec2 uv = (2.*g-si)\/min(si.x, si.y);\n\t\n\tt = iGlobalTime;\n\t\n\tvec3 rayOrg = vec3(t,0.,t)  * 5.;\n\tvec3 camUp = vec3(0,1,0);\n\tvec3 camOrg = rayOrg + vec3(1,0,1);\n\t\n\tfloat fov = 0.5;\n\tvec3 axisZ = normalize(camOrg - rayOrg);\n\tvec3 axisX = normalize(cross(camUp, axisZ));\n\tvec3 axisY = normalize(cross(axisZ, axisX));\n\tvec3 rayDir = normalize(axisZ + fov * uv.x * axisX + fov * uv.y * axisY);\n\t\n\tvec2 s = vec2(0.01);\n\tfloat d = 0.;\n\tvec3 p = rayOrg + rayDir * d;\n\tfloat dMax = 80.;\n\tfloat sMin = 0.0001;\n\t\n\tfloat h = .8;\n\t\n\tfor (float i=0.; i<250.; i++)\n\t{\n\t\tif (s.x<sMin || d>dMax) break;\n\t\ts = df(p);\n\t\td += s.x * (s.x>0.001?0.25:0.001);\n\t\tp = rayOrg + rayDir * d;\t\n\t}\n\t\n\tvec3 sky = GetSky(rayDir, ligthDir, vec3(h*5.));\n\t\n\tif (d<dMax)\n\t{\n\t\tvec3 n = nor(p, 0.001);\n\t\t\n\t\t\/\/ \tiq primitive shader : https:\/\/www.shadertoy.com\/view\/Xds3zN\n\t\tfloat r = mod( floor(5.0*p.z) + floor(5.0*p.x), 2.0);\n\t\tf.rgb = 0.4 + 0.1*r*vec3(1.0);\n\n\t\t\/\/ from iq\n\t\tfloat occ = calcAO( p, n );\n\t\tfloat amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n\t\tfloat dif = clamp( dot( n, ligthDir ), 0.0, 1.0 );\n\t\tfloat spe = pow(clamp( dot( rayDir, ligthDir ), 0.0, 1.0 ),16.0);\n\t\tdif *= softshadow( p, ligthDir, 0.02, 50.);\n\t\tvec3 brdf = vec3(0.0);\n\t\tbrdf += 1.20*dif*vec3(1.00,0.90,0.60);\n\t\tbrdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n\t\tbrdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n\t\tf.rgb *= brdf + dstepf;\n\t\tf.rgb = mix( f.rgb, sky, 1.0-exp( -0.001*d*d ) );\n\t}\n\telse\n\t{\n\t\tf.rgb = sky;\n\t}\n}\n","name":"","description":"","type":"image"}]}}