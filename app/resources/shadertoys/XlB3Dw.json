{"Shader":{"ver":"0.1","info":{"id":"XlB3Dw","date":"1429289576","viewed":696,"name":"Squircle 3D","username":"dys129","description":"Take it to another dimension squircle in 3D - because we can! Credits go to all shadertoy community!","likes":2,"published":3,"flags":0,"tags":["squircle"],"hasliked":0},"renderpass":[{"inputs":[{"id":19,"src":"\/presets\/mzk02.mp3","ctype":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/\n\/\/ #TeamSquircle\n\/\/\n\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D( iChannel0, (uv+ 0.5)\/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn texture2D( iChannel0, (uv+118.4)\/256.0, -100.0 ).x;\n}\n\n\nvec3 rotateX(vec3 v, float a)\n{\n    return vec3(v.x ,\n                v.y * cos(a) + v.z * sin(a),\n                -v.y * sin(a) + v.z * cos(a));\n}\n\nvec3 rotateY(vec3 v, float a)\n{\n    return vec3(v.x * cos(a) + v.z * sin(a),\n                v.y,\n                -v.x * sin(a) + v.z * cos(a));\n}\n\nvec3 rotateZ(vec3 v, float a)\n{\n \treturn vec3(v.x * cos(a) + v.y * sin(a),\n                v.x * -sin(a) + v.y * cos(a),\n                v.z);\n}\n\nfloat plane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sphere(vec3 ro, float r)\n{\n return length(ro) - r;   \n}\n\nfloat cylinder( vec3 p, vec2 h )\n{\n  return max( length(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat opU( float d1, float d2 )\n{\n\treturn (d1<d2) ? d1 : d2;\n}\n\n\nbool IntersectBox(vec3 ro, vec3 rd, vec3 bmin, vec3 bmax, out float t0, out float t1)\n{\n    vec3 invR = 1.0 \/ rd;\n    vec3 tbot = invR * (bmin-ro);\n    vec3 ttop = invR * (bmax-ro);\n    vec3 tmin = min(ttop, tbot);\n    vec3 tmax = max(ttop, tbot);\n    vec2 t = max(tmin.xx, tmin.yz);\n    t0 = max(t.x, t.y);\n    t = min(tmax.xx, tmax.yz);\n    t1 = min(t.x, t.y);\n    return t0 <= t1;\n}\n\nfloat sphercile(vec3 ro, float r, float power)\n{\n\treturn pow( abs(ro.x), power) + pow( abs(ro.y), power) + pow( abs(ro.z), power) - r;\n}\n\nfloat selipse(vec3 ro, float e, float n)\n{\n \tfloat r = 2.0 \/ e;\n    float t = 2.0 \/ n;\n    \n    float inside =  pow(pow(abs(ro.x), r) + pow(abs(ro.y), r), t\/r) + pow(abs(ro.z),t);\n    return inside - 1.0;\n}\n\nvec3 selipse_nrm(vec3 ro, float e, float n)\n{\n    float r = 2.0 \/ e;\n    float t = 2.0 \/ n;\n    \n    float xr = pow(abs(ro.x), r);\n    float yr = pow(abs(ro.y), r);\n    float zt = pow(abs(ro.z), t);\n \treturn vec3(t*xr * pow((xr + yr), t\/r-1.0)\/ro.x,\n                t*yr * pow((xr + yr), t\/r-1.0)\/ro.y,\n                t*zt\/abs(ro.z));\n}\n\nvec4 map( vec3 p )\n{\n\n    vec3 cc = vec3(2.3);\n\tvec3 q = mod(p, cc) - 0.5 * cc;\n    p = q;\n    float d = box(p,vec3(1.0));\n    vec4 res = vec4( d, 1.0, 0.0, 0.0 );\n\n \tfloat s = 1.0;\n    for( int m=0; m<4; m++ )\n    {\n\t   \n        vec3 a = mod( p*s, 2.0 )-1.0;\n        s *= 3.0;\n        vec3 r = abs(1.0 - 3.0*abs(a));\n        float da = max(r.x,r.y);\n        float db = max(r.y,r.z);\n        float dc = max(r.z,r.x);\n        float c = (min(da,min(db,dc))-1.0)\/s;\n\n        if( c>d )\n        {\n          d = c;\n          res = vec4( d, min(res.y,0.2*da*db*dc), (1.0+float(m))\/4.0, 0.0 );\n        }\n    }\n\n    return res;\n}\n\n\nvec3 fog_clr = vec3(0.3,0.1,0.2);\nvec3 applyFog(vec3 clr, vec3 rd)\n{\n    \n    float fog = 1.0 - exp(-length(rd) * 0.05);\n    clr.rgb = mix(clr.rgb, fog_clr, fog);\n    return clr;\n}\n\nvec2 scene(vec3 ro)\n{\n\n    float time = iGlobalTime;\n    float tt = 1.0 + abs(sin(time * 1.5))*3.0;\n \tvec3 ppp = ro + vec3(0,-1,0);\n    ppp = rotateY(ppp, iGlobalTime * 2.0);\n    vec2 sp0 = vec2(sphercile(ppp, 1.0, 1.0), 0.0);\n    vec2 pl0 = vec2(plane(ro), 1.0);\n    vec2 sa0 = vec2(selipse(ppp, 2.0, 2.0), 0.0);\n    float rad = 3.5;\n    vec3 ccc = vec3(0.0, 0.0, 2.0*rad + 0.5);\n    vec3 qqq = mod(ro - vec3(0.0,0.0,rad), ccc) - 0.5 * ccc;\n    float sph = sphere(qqq, rad);\n    float cb = map(ro).x;\n    float r = max(cb, -sph);\n    return vec2(r, 1.0);\n}\n\n\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    scene(pos+eps.xyy).x - scene(pos-eps.xyy).x,\n\t    scene(pos+eps.yxy).x - scene(pos-eps.yxy).x,\n\t    scene(pos+eps.yyx).x - scene(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)\/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = scene( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nfloat shadow( vec3 ro, vec3 rd)\n{\n\tfloat t = 0.02;\n    float res = 1.0;\n    for(int i=0;i<16;i++)\n    {\n    \tfloat h = scene( ro + rd*t ).x;\n        res = min( res, 8.0*h\/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001) break;    \n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat freqs[4];\n\nvec3 lighting(vec3 pos, vec3 rd, vec3 nrm, float mid)\n{\n    vec3 lpos = vec3(0.6, 0.7, 0.80);\n    vec3  lig = normalize( lpos );\n    float ndl = clamp( dot( nrm, lig ), 0.0, 1.0 );\n\t\n\tfloat bac = clamp( dot( nrm, normalize(lig*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\n    \n    \n    vec3 clr = vec3(0.0);\n    clr += ndl*vec3(0.70,0.12,0.30);\n    clr += bac*vec3(0.40,0.18,0.20);\n    clr += 0.5 * clamp( dot(nrm,normalize(-pos)), 0.0, 1.0) * vec3(0.3,0.4,0.3);\n    float off = texture2D( iChannel1, vec2( atan(pos.z, pos.x) * 0.15 * 0.5 + 0.5, 0.25 ) ).x * 1.0 - 0.5;\n    float ns = noise(pos.xz + iGlobalTime * 1.2);\n    float p0 = clamp(1.0 - abs(pos.y*20.0 + \/*mod(iGlobalTime * 50.0, 150.0) - 75.0*\/ + ns * 35.0 + (freqs[3] + freqs[2] * 40.0)), 0.0,1.0);\n    float p1 = clamp(1.0 - abs(pos.y*20.0 + \/*mod(iGlobalTime * 50.0, 150.0) - 75.0*\/ + off * 55.0), 0.0,1.0);\n    float bit1 = mix(0.4, 5.0, clamp( (freqs[0] - 0.95) * 20.0, 0.0, 1.0));\n    float bit2 = freqs[3] + freqs[2];\/\/mix(0.2, 10.0, clamp( (freqs[2] - 0.5) * 1.0 \/ 0.5, 0.0, 1.0));\n   \/\/ clr.rgb += vec3(p0) * 2.0 * mix(vec3(0.6,0.6,0.2), vec3(0.6,0.2,0.9), bit1);\n    clr.rgb += vec3(p1) * 2.0 * mix(vec3(1.0,0.0,0.0), vec3(0.2, 0.9,0.1), bit2 );\n    clr.rgb *= calcAO(pos + 0.01 * nrm, nrm);\n    return clr;\n}\n\n#define NUM_STEPS 64\n\nvec4 rayMarchSpheroid(vec3 ro, vec3 rd, out float tk)\n{\n   float t0, t1;\n\tbool box_hit = IntersectBox(ro, rd, vec3(-1,-1,-1), vec3(1,1,1), t0, t1); \n    \n    if(!box_hit)\n        return vec4(0.0);\n    \n    \n\tfloat E = sin(iGlobalTime * 0.8) * 1.5 + 1.6;\n    float N = 1.6 + sin(iGlobalTime * 0.7) * 1.5;\n    float t = t0;\n    vec4 clr = vec4(0.0);\n    float dt = (t1 - t0) \/ float(NUM_STEPS);\n    \n    for(int i =0; i<NUM_STEPS; i++)\n    {\n        float hit = selipse(ro+t*rd, E, N);\n        float eps = 0.001;\n        \n        if(hit < eps)\n        {\n            float resT = t - 0.5 * dt;\n        \tvec3 pos = ro + resT*rd;        \t\n            vec3 nrm = normalize(selipse_nrm(pos, E, N));\n            vec3 rfl = reflect( rd, nrm );\n            vec3  lig = normalize( vec3(0.6, 0.7, 0.5) );\n            \n            vec3 ppp = pos;\n            clr.rgb = vec3(0.0);\n            float rt = 1.0;\n            vec3 rfl_clr = vec3(0.0);\n            for(int j = 0; j < 10; j++)\n            {\n                \n            \tvec2 rhit = scene(pos + rt * rfl); \n                if(rhit.x < 0.001)\n                {\n                 vec3 rpos = pos + rt * rfl;\n                 vec3 rnrm = calcNormal(rpos);   \n                 rfl_clr = lighting(rpos, rfl, rnrm, 0.0);   \n                   break;\n                }\n                \n                rt += max(rhit.x, 0.001);\n            }\n            clr.rgb += rfl_clr * 0.6;\n            clr.rgb += max(dot(lig, nrm), 0.0) * vec3(0.4,0.5,0.6)* 0.3;\n            clr.rgb = applyFog(clr.rgb, t*rd);\n            clr.w = 1.0;\n            break;\n        }                \n        t += dt;\n    }\n    tk = t;\n    return clr;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    freqs[0] = texture2D( iChannel1, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture2D( iChannel1, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture2D( iChannel1, vec2( 0.50, 0.25 ) ).x;\n\tfreqs[3] = texture2D( iChannel1, vec2( 0.80, 0.25 ) ).x;\n    \n    vec2 q = fragCoord.xy\/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x\/iResolution.y;\n    vec2 mo = -1.0 + 2.0 * iMouse.xy\/iResolution.xy;\n    \n    float k = 3.0;\n \tvec3 ro = vec3(sin(iGlobalTime * 0.4) * 4.3, 0.1 + 0.0 * sin(iGlobalTime*0.4), cos(iGlobalTime * 0.4) * 3.1);\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n    \n    float t = 0.0;\n    vec4 clr = vec4(0.0, 0.0, 0.0, 1.0);\n    clr.rgb = fog_clr;\n    for(int i =0; i<64; i++)\n    {\n        vec2 hit = scene(ro+t*rd);\n        float eps = 0.001;\n        float dt = 0.01;\n        if(hit.x < eps)\n        {\n        \tvec3 pos = ro + t*rd;\n        \tvec3 nrm = calcNormal( pos );\n        \tvec3 rfl = reflect( rd, nrm );\n            clr.rgb = lighting(pos, rd, nrm, 0.0); \n            \n            clr.rgb = applyFog(clr.rgb, t*rd);\n    \n            break;\n        }\n        \n        t += max(hit.x, 0.001);\n    }\n    float kt = 1000.0;\n    vec4 sph = rayMarchSpheroid(ro, rd, kt);\n    clr.rgb = mix(clr.rgb, sph.rgb, sph.a * float(k < t));\n\n\tfragColor = clr;\n}","name":"","description":"","type":"image"}]}}