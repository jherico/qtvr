{"Shader":{"ver":"0.1","info":{"id":"lsfGDB","date":"1378277216","viewed":6186,"name":"Disk - intersection","username":"iq","description":"Spinning disks","likes":58,"published":3,"flags":1,"tags":["3d","raytracing","intersection","disk"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define SC 3.0\n\n#if 1\n\/\/\n\/\/ Elegant way to intersect a planar coordinate system (3x3 linear system)\n\/\/\nvec3 intersectCoordSys( in vec3 o, in vec3 d, vec3 c, vec3 u, vec3 v )\n{\n\tvec3 q = o - c;\n\treturn vec3(\n        dot( cross(u,v), q ),\n\t\tdot( cross(q,u), d ),\n\t\tdot( cross(v,q), d ) ) \/ \n        dot( cross(v,u), d );\n}\n\n#else\n\/\/\n\/\/ Ugly (but faster) way to intersect a planar coordinate system: plane + projection\n\/\/\nvec3 intersectCoordSys( in vec3 o, in vec3 d, vec3 c, vec3 u, vec3 v )\n{\n\tvec3  q = o - c;\n\tvec3  n = cross(u,v);\n    float t = -dot(n,q)\/dot(d,n);\n    float r =  dot(u,q + d*t);\n    float s =  dot(v,q + d*t);\n    return vec3(t,s,r);\n}\n\n#endif\t\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,12578.1459123,19642.3490423));\n}\n\nvec3 shade( in vec4 res )\n{\n    float ra = length(res.yz);\n    float an = atan(res.y,res.z) + 8.0*iGlobalTime;\n    float pa = sin(3.0*an);\n\n    vec3 cola = 0.5 + 0.5*sin( (res.w\/64.0)*3.5 + vec3(0.0,1.0,2.0) );\n\t\n\tvec3 col = vec3(0.0);\n\tcol += cola*0.4*(1.0-smoothstep( 0.90, 1.00, ra) );\n    col += cola*1.0*(1.0-smoothstep( 0.00, 0.03, abs(ra-0.8)))*(0.5+0.5*pa);\n    col += cola*1.0*(1.0-smoothstep( 0.00, 0.20, abs(ra-0.8)))*(0.5+0.5*pa);\n\tcol += cola*0.5*(1.0-smoothstep( 0.05, 0.10, abs(ra-0.5)))*(0.5+0.5*pa);\n    col += cola*0.7*(1.0-smoothstep( 0.00, 0.30, abs(ra-0.5)))*(0.5+0.5*pa);\n\n\treturn col*0.3;\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n  \t\/\/ raytrace\n    vec3 col = vec3( 0.0 );\n\tfor( int i=0; i<64; i++ )\n\t{\n\t\t\/\/ position disk\n\t    vec3 r = 2.5*(-1.0 + 2.0*hash3( float(i) ));\nr *= SC;\t\t\n        \/\/ orientate disk\n\t\tvec3 u = normalize( r.zxy );\n        vec3 v = normalize( cross( u, vec3(0.0,1.0,0.0 ) ) );\t\t\t\t\t\t   \n\t\t\n        \/\/ intersect coord sys\n        vec3 tmp = intersectCoordSys( ro, rd, r, u, v );\ntmp \/= SC;\t\t\n\t    if( dot(tmp.yz,tmp.yz)<1.0 && tmp.x>0.0 ) \n\t    {\n            \/\/ shade\t\t\t\n\t\t    col += shade( vec4(tmp,float(i)) );\n\t    }\n\t}\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x\/iResolution.y;\n\n    \/\/ camera\n\tvec3 ro = 2.0*vec3(cos(0.5*iGlobalTime*1.1),0.0,sin(0.5*iGlobalTime*1.1));\n    vec3 ta = vec3(0.0,0.0,0.0);\n    \/\/ camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t\/\/ create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.0*ww );\n\n    vec3 col = render( ro*SC, rd );\n    \n    fragColor = vec4( col, 1.0 );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec3 col = render( fragRayOri + vec3(0.0,0.0,0.0), fragRayDir );\n\n    fragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}