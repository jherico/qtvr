{"Shader":{"ver":"0.1","info":{"id":"llsXzH","date":"1434807048","viewed":931,"name":"Inflatable Analyser","username":"frutbunn","description":"Best seen fullscreen!","likes":11,"published":3,"flags":0,"tags":["3d"],"hasliked":0},"renderpass":[{"inputs":[{"id":8,"src":"\/presets\/tex07.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":13,"src":"\/presets\/mzk00.mp3","ctype":"music","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":25,"src":"\/presets\/cube03_0.png","ctype":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define MAX_STEPS \t\t\t50\n#define MAX_DISTANCE \t\t8.\n#define MARCHING_STEP_INC \t.4\n#define EPSILON \t\t\t.01\n\n#define COLORS  4\n\n#define PI 3.14159265358979323846\n#define TIMER(sec, min, max) (((mod(iGlobalTime, (sec)) * ((max) - (min))) \/ (sec)) + (min))\n\nfloat globalTimer = TIMER(80., 0., 60.);\n#define SCENE1  0.\n#define SCENE2  30.\n#define SCENE3  40.\n#define SCENE4  50.\n#define SCENE5  60.\n\nfloat scol[7];\nfloat b[4];\n\nvec4 texSphere(sampler2D t, vec3 p, vec3 n, float scale) {\n    return texture2D(t, p.yz * scale) * abs (n.x)\n     + texture2D(t, p.xz * scale) * abs (n.y)\n     + texture2D(t, p.xy * scale) * abs (n.z);\n}\n\nmat2 mm2(in float a) {\n    float c = cos(a), s = sin(a);\n    \n    return mat2(c, s, -s, c);\n}\n\nfloat smin(in float a, in float b ) {\n    const float k=12.; \n    float res = exp( -k*a ) + exp( -k*b );\n    \n    return -log( res )\/k;\n}\n\nfloat map(in vec3 p, out float o[COLORS]) {   \n#   define SS 1.5\n    float cx = cos(SS*p.x), cy = cos(SS*p.y), cz = cos(SS*p.z);\n    float sx = sin(SS*p.x), sy = sin(SS*p.y), sz = sin(SS*p.z);\n    \n    float lpxz = length(p.xz);\n    o[0] = (length(vec2((lpxz-1.5)-(b[0]), p.y))-.15) + cx*cy*sz;\n    o[1] = (length(vec2((lpxz-1.5)-(b[1]), p.y))-.15) + cx*cy*cz;\n    o[2] = (length(vec2((lpxz-1.5)-(b[2]), p.y))-.25) + cx*sy*sz;\n    o[3] = (length(vec2((lpxz-1.5)-(b[3]), p.y))-.25) + sx*sy*sz;\n\n    return smin(o[0]*1.5, smin(o[1], smin(o[2], o[3])));\n}\n\nfloat scene(in vec3 p, out float o[COLORS]) {\n    return map(p, o);\n}\n\nfloat scene(in vec3 p) {\n    float o[COLORS]; return map(p, o);\n}\n\nvoid colorize(in float d, in vec3 material_col, inout float z_depth, inout vec3 pixel_col) {\n    const float max_displace = .25;\n    const float max_col_bleed = 1.25;\n    \n    float nc = smoothstep(d-max_col_bleed, d+max_col_bleed, z_depth);\n    float nzd = smoothstep(d-max_displace, d+max_displace, z_depth);\n    \n    z_depth = d*(nzd) + z_depth*(1.-nzd);\n    pixel_col = (1.-nc)*pixel_col + (nc)*material_col;\n}\n\nfloat rayMarch(in vec3 origin, in vec3 ray, out vec3 col) {\n    float o[COLORS];\n    \n    float t = 0.;\n    for (int i=0; i < MAX_STEPS; i++) {\n        float d = scene(origin + ray*t, o);\n\n        if (d < EPSILON) \n            break;\n\n        t += d*MARCHING_STEP_INC;\n\n        if (t > MAX_DISTANCE) \n            break;\n    }\n\n    float z_depth = 1000.;\n    colorize(o[0], vec3(scol[0]*.5, scol[6]*.0, scol[3]*.0), z_depth, col );\n    colorize(o[1], vec3(scol[4]*.0, scol[4]*.3, scol[4]*.0), z_depth, col );\n    colorize(o[2], vec3(scol[1]*.2, scol[5]*.0, scol[4]*.3), z_depth, col );\n    colorize(o[3], vec3(scol[2]*.4, scol[4]*.3, scol[6]*.6), z_depth, col );\n    \n    col = clamp(col, 0., 1.);\n    \n    return t;\n}\n\nfloat ambientOcculation(in vec3 origin, in vec3 ray) {\n    const float delta = .1;\n    const int samples = 6;\n    float r = 0.;\n    \n    for (int i=1; i <= samples; i++) {\n        float t = delta * float(i);\n        float d = scene(origin + ray*t);\n        float len = abs(t - d);\n        r += len * pow(2.0, -float(i));\n    }\n    \n    return r;\n}\n\nfloat shadowSample(in vec3 origin, in vec3 ray) {\n    float r = 1.;\n    float t = 1.;\n    const int samples = 12;\n    \n    for (int i=0; i <= samples; i++) {\n        float d = scene(origin + ray*t);\n        r = min(r, 2.0*d\/t);\n        t += d;\n    }\n    \n    return max(r, 0.);\n}\n\nvec3 getNormal(in vec3 p, in float ep) {\n    float d0 = scene(p);\n    float dX = scene(p - vec3(ep, 0.0, 0.0));\n    float dY = scene(p - vec3(0.0, ep, 0.0));\n    float dZ = scene(p - vec3(0.0, 0.0, ep));\n\n    return normalize(vec3(dX-d0, dY-d0, dZ-d0));\n}\n\nvec3 starfield(in vec2 uv) {\n    vec3 col = vec3(.0);\n\n    vec3 ray = vec3(uv*.8, .7);\n    ray.xy*=mm2(TIMER(10. ,0., -PI*2.));\n    ray.zy*=mm2(PI*2.1);\n\n    vec3 t = ray\/max(abs(ray.x), abs(ray.y));\n    vec3 p = 1.*t+.5;\n    \n    if (globalTimer>SCENE4 && globalTimer<=SCENE5) {\n        float dd = PI, c = cos(dd*p.y+dd), s = sin(dd*p.y+dd);\n        p = vec3(mat2(c,-s,s,c)*p.xz,p.y);\n    }\n    \n    for(int i=0; i<3; i++) {\n        float n = fract(sin(dot((vec2(floor(p.xy*30.334))), vec2(12.9898, 78.233)))*43758.5453)+.5;\n        float z = fract(cos(n)-sin(n)-iGlobalTime*.2);       \n        \n        float d = 60.*z-p.z;\n        float j = max(0., 1.5-3.*length(fract(p.xy)-.5));\n        vec3 c = max(vec3(0), vec3(1.0-abs(d))*(1.\/t.z*2.));\n        \n        col += (1.-z)*c*j;\n        p += t;\n    }\n\n    if (globalTimer>SCENE2 && globalTimer<=SCENE4) {\n        col.r *= scol[0];\n    } else if (globalTimer>SCENE4 && globalTimer<=SCENE5) {\n        col.g*=4.;\n        col *= length(uv*.5);\n    }\n\n    return col;\n}\n\nfloat f1(in float x) {\n    return sqrt(1.-(x-1.)*(x-1.));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (gl_FragCoord.xy \/ iResolution.xy) - vec2(.5);\n    uv.x *= iResolution.x\/iResolution.y;\n   \n    \n#\tdefine MM 6.5 \n    scol[0]=texture2D(iChannel2, vec2(0., 0.25) ).x;     scol[0]=f1(clamp(1.*scol[0]*scol[0], 0., 1.)); scol[0]*=MM*scol[0]*scol[0];\n    scol[1]=texture2D(iChannel2, vec2(.17*1., 0.25) ).x; scol[1]=f1(clamp(1.*scol[1]*scol[1], 0., 1.)); scol[1]*=MM*scol[1]*scol[1];\n    scol[2]=texture2D(iChannel2, vec2(.17*2., 0.25) ).x; scol[2]=f1(clamp(1.*scol[2]*scol[2], 0., 1.)); scol[2]*=MM*scol[2]*scol[2];\n    scol[3]=texture2D(iChannel2, vec2(.17*3., 0.25) ).x; scol[3]=f1(clamp(1.*scol[3]*scol[3], 0., 1.)); scol[3]*=MM*scol[3]*scol[3];\n    scol[4]=texture2D(iChannel2, vec2(.17*4., 0.25) ).x; scol[4]=f1(clamp(1.*scol[4]*scol[4], 0., 1.)); scol[4]*=MM*scol[4]*scol[4];\n    scol[5]=texture2D(iChannel2, vec2(.17*5., 0.25) ).x; scol[5]=f1(clamp(1.*scol[5]*scol[5], 0., 1.)); scol[5]*=MM*scol[5]*scol[5];\n    scol[6]=texture2D(iChannel2, vec2(.99, 0.25) ).x;    scol[6]=f1(clamp(1.*scol[6]*scol[6], 0., 1.)); scol[6]*=MM*scol[6]*scol[6];    \n    \n    b[0] = (scol[1]+scol[2]+scol[3])*.33;\n    b[1] = (scol[3]+scol[3]+scol[4])*.33;\n    b[2] = (scol[4]+scol[5]+scol[6])*.33;\n    b[3] = (scol[2]+scol[3]+scol[4])*.33;\n    \n    \n    vec2 uv2 = uv;\n   \n    if (globalTimer>SCENE2 && globalTimer<=SCENE4) {\n        float ts1 = abs(TIMER(5., -15.5, 15.5));\n        float ts2 = abs(TIMER(10., 15.5, -15.5));\n        uv2.y*=cos(uv2.y*-(ts1-ts2*1.));\n        uv2.x*=sin(uv2.x*-(ts1-ts2*1.));\n    }\n    \n    float o = min(TIMER(10., -PI*2., PI*2.), TIMER(10., PI*2., -PI*2.))+PI;    \n    float o2 = min(TIMER(20., -PI*2., PI*2.), TIMER(20., PI*2., -PI*2.))+PI;\n        \n    float o3 = min(TIMER(5., -PI*2., PI*2.), TIMER(5., PI*2., -PI*2.))+PI;\n    float o3b = min(TIMER(10., -PI*2., PI*2.), TIMER(10., PI*2., -PI*2.))+PI;\n        \n    uv.x+=cos(o)*.5;\n    uv.y+=cos(o2)*.3;\n    uv*= ( (1.5+cos(o3)) + (1.5+cos(o3b)) ) *.5;\n    \n    vec3 eye = vec3(0., 0., -5.);\n    vec3 light = vec3(-2., -.5, -6.5);\n    vec3 ray = vec3(uv.x, uv.y, 1.);\n    vec3 scene_color = vec3(0.);\n\n    float rx = TIMER(10. ,0., PI*2.);\n    float ry = TIMER(8. ,0., PI*2.);\n    float rz = TIMER(5. ,0., PI*2.);\n    \n    eye.zx*=mm2(rx); eye.xy*=mm2(rz); eye.zy*=mm2(ry);\n    light.zx*=mm2(rx); light.xy*=mm2(rz); light.zy*=mm2(ry);\n    ray.zx*=mm2(rx); ray.xy*=mm2(rz); ray.zy*=mm2(ry);\n    \n    float depth = rayMarch(eye, ray, scene_color);\n    if (depth < MAX_DISTANCE) {\n        vec3 p = (eye + ray*depth);\n        \n        float d_ep=length(p - depth);\n        vec3 p_normal = getNormal(p, d_ep*d_ep*EPSILON*0.003);\n        \n        vec3 light_dir = -normalize(light-p);\n        vec3 reflected_light_dir = reflect(-light_dir, -p_normal);\n\n        const float j=.003;\n        float shadow = shadowSample(p, -light_dir);\n        float attenuation = 1.\/(1. + j*pow( length(light-p), 2.0));\n        attenuation -= (1.-shadow)*.6;\n        \n        float ambient = pow(max(1.-ambientOcculation(p, -ray), 0.), 8.);\n        float diffuse = max(0., dot(light_dir, p_normal));\n        float lighting = max(0., (diffuse*.4 + ambient*.6)*attenuation);\n\n        vec3 reflectioncolor = textureCube(iChannel1, reflected_light_dir).rgb;\n        vec3 texcol = texSphere(iChannel0, .1*p, p_normal, 1.0 ).rgb*lighting;\n        scene_color = (clamp(mix(scene_color, reflectioncolor, max(0., 1.+(dot(-p_normal, ray)))), 0., 1.)+scene_color)*lighting;\n        scene_color = scene_color + texcol*.4;\n\n        scene_color *= max(dot(-p_normal,-ray),.5);\n    } else {\n        scene_color=starfield(uv2);\n    }\n    \n    scene_color = clamp(scene_color, 0., 1.);\n    fragColor = vec4(pow(scene_color, vec3(.85)), 1.);\n}","name":"","description":"","type":"image"}]}}