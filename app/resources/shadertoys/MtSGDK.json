{"Shader":{"ver":"0.1","info":{"id":"MtSGDK","date":"1432382500","viewed":707,"name":"Corroded Sphere","username":"ManuManu","description":"I try to make a decomposed sphere<br\/><br\/>Made on GlSlSandbox here : http:\/\/glslsandbox.com\/e#25147.1","likes":4,"published":3,"flags":0,"tags":["raymarching","fractal"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\n#ifdef GL_ES\n\/\/precision mediump float;\nprecision highp float;\n#endif\n\n\n\n\/\/ IT's strange, the version http:\/\/glslsandbox.com\/e#25099.7\n\/\/ does not compile on my (cheap) desktop computer (without any error line)\n\/\/ but is ok on my old laptop...\n\/\/\n\/\/ It looks like using a vec2 ( material , dist ) for the raymarching \n\/\/ is failing somewhere...\n\/\/\n\/\/ Do you know why ?\n\n\n#define NB_ITER 64\n#define FAR \t100.\n\n\n\/\/#define EDIT\n\nvec3 skyColor( vec2 uv)\n{\n\tvec3 col1 = vec3(.0, .4, .6);\n\tvec3 col2  = vec3(.6, .6,.4);\n\treturn mix (col1, col2, 1.-length(uv+vec2(.2, .3) ) \/ .5);\n}\nvec4 mapFloor ( vec3 pos )\n{\n\tvec3 col1 = vec3( 1., 0., 0.);\n\tvec3 col2 = vec3( 0., 1., 0.);\n\tfloat val = sign( fract( .25*pos.x) -.5 ) * sign( fract( .25*pos.z) -.5 );\n\tvec3 col =mix( col1, col2, val );\n\tfloat dist = pos.y;\n\treturn vec4( col, dist );\n}\n\nvec4 mapSphere( vec3 pos, float radius )\n{\n\/\/\tfloat DEP_VAL =sin(time) +2.;\n\tfloat dist = length(  pos ) - radius;\/\/+ .2*sin(DEP_VAL *pos.x + sin(5.*time)) * sin(DEP_VAL *pos.y+ cos(6.*time)) * sin(DEP_VAL *pos.z+ sin(time));\n\tvec3 col = vec3( 1.0, .2, .2 );\n\treturn  vec4( col, dist);\n}\n\n\nfloat Mylength( vec3 pos )\n{\n\treturn max(abs(pos.x), max( abs(pos.y), abs( pos.z)) );\n}\n\nfloat Mylength2( vec3 pos )\n{\n\treturn abs(pos.x) + abs(pos.y) + abs( pos.z);\n}\n\nvec4 mapCube( vec3 pos )\n{\n\t\/\/vec4 ret = vec4( abs(atan (pos.x ) ) *abs(atan (pos.y ) ), .0, .0, 1.  );\n\t\/\/vec4 ret = vec4(fract( pos.z ) > .5);\n\tvec3 col = vec3( .0, .9, .1);\n\tfloat dist = Mylength(  pos ) - 5.0;\n\treturn vec4( col, dist );\n}\n\n\nvec4 combine(vec4 val1, vec4 val2 )\n{\n\tif ( val1.w < val2.w ) return val1;\n\treturn val2;\n}\n\n\nvec4 subst( vec4 val1, vec4 val2 )\n{\n\tfloat dist = max(-val2.w, val1.w);\n\treturn vec4(vec3(val1), dist);\n}\n\n\nvec4 mapLotsOfSpheres( vec3 pos)\n{\n\tvec3 col = vec3(.3, .8, .2 );\n\tconst float radius=6.0;\n\tfloat dist = length( mod( pos+15., 30.)-15.) -radius;\n\treturn vec4( col, dist);\n}\nvec4 mapLotsOfCubes( vec3 pos)\n{\n\tvec3 col = vec3(.3, .8, .2 );\n\tconst float radius=6.0;\n\tfloat dist = Mylength( mod( pos+8., 16.)-8.) -radius;\n\treturn vec4( col, dist);\n}\n\nvec4 StrangeSphere( vec3 pos ) \n{\n\t\/\/float move = sin(3.*time ) *.5 - 10.;\n\tfloat move = 10.;\n\tfloat rad = 10.;\n\tvec3 newPos = pos - vec3( .0+move, 5., 50.);\n\tvec4 val2 = mapSphere(newPos, rad );\n\tvec3 p = newPos;\n\tif (val2.w < .1 )\t\/\/ Optimization, don't try the strange thing outside the sphere\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tfloat t = float(i)*.11+0.004*iGlobalTime;\n\t\tfloat c = cos(t);\n\t\tfloat s = sin(t);\n\t\tmat2 m = mat2(c,-s,s,c);\n\t\tp.xy = m*p.xy;\n\t\t\t      \n\t\trad *= .5;\n\t\tp.x = p.x - rad*2.;\n\t\tvec3 p2 = p;\n\t\tp2.xzy=mod (p.xzy+rad, rad*2.5) -rad;\n\t\t\/\/p2.z=mod (p.z+rad, rad*2.5) -rad;\n\t\t\/\/p2=mod (p+rad, rad*2.5) -rad;\n\n\t\t\/\/vec3 p2 = p;\n\t\tvec4 sph = mapSphere( p2, rad );\n\t\t\/\/val2= combine(val2, sph);\n\t\tval2 = subst(val2, sph);\n\t\t\/\/val2 = sph;\n\t}\n\treturn val2;\n}\n\n\n\/\/#define MOVING_OBJECTS\nvec4 map( vec3 pos)\n{\n\tvec4 ret = mapFloor( pos );\n\n\tvec4 res = combine( ret, StrangeSphere(pos));\n\treturn res;\n}\n\nfloat ambientOcclusion(vec3 pos, vec3 norm)\n{\n    const int steps = 3;\n    const float delta = 0.50;\n\n    float a = 0.0;\n    float weight = 1.0;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) \/ float(steps)) * delta; \n        a += weight*(d - map(pos + norm*d).w);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k) {\n    float sh = 1.0;\n    float t = mint;\n    float h = 0.0;\n    for(int i = 0; i < 15; i++) {\n        if(t > maxt) continue;\n        h = map(ro + rd * t).w;\n        sh = min(sh, k * h \/ t);\n        t += h;\n    }\n    return sh;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = ( fragCoord.xy \/ iResolution.xy );\n\tuv -= .5;\n\tuv.x *= iResolution.x \/ iResolution.y;\n\t\/\/uv.x += cos( uv.x)*3.02;\n\t\/\/float fish_eye =  -length(uv)*1.+ sin(iGlobalTime);\n\t\/\/float fish_eye = sin(5.*uv.x) + sin(5.*uv.y) + 1.;\n\tfloat fish_eye =  1.;\n\tvec3 dir = vec3( uv, 1.0 + fish_eye);\n\tdir = normalize(dir);\n\t\n\tvec3 pos = vec3( .0, 8.1, .0);\n\t\/\/vec3 pos = vec3( 20.*sin(iGlobalTime), 8.1, 20.*cos(iGlobalTime));\n\t\n\tfloat nbIterF = 0.;\n\tvec4 result;\n\tfor (int i =0; i < NB_ITER; i++)\n\t{\n\t\tresult = map( pos );\n\t\tpos += result.w * dir;\n\t\tif ( (pos.z > FAR) || (abs(result.w) < .001)) break;\n\t\t\/\/if ( (pos.z > FAR)) break;\n\t\tnbIterF += 1.0;\t\n\t}\n\tvec3 col = result.xyz;\n\tif ( pos.z> FAR ) \n\t{\n\t\tcol = skyColor(uv);\n\t}\n\telse\n\t{\n\t\t\/\/vec3 lightPos = vec3(10.* sin(3.*iGlobalTime) + 10., 8.5, 10.*cos(3.*iGlobalTime) + 30. );\n\t\tvec3 lightPos = vec3(1.* sin(3.*iGlobalTime) + 10., 8.5, 1.*cos(3.*iGlobalTime) + 30. );\n\t\tvec3 light2Pos = normalize( lightPos - pos);\n\t\tvec3 eps = vec3( .1, .0, .0 );\n\t\tvec3 n = vec3( result.w - map( pos - eps.xyy ).w,\n\t\t\t       result.w - map( pos - eps.yxy ).w,\n\t\t\t       result.w - map( pos - eps.yyx ).w );\n\t\tn = normalize(n);\n\t\t\/\/col =abs(n);\n\t\t\t\t\n\t\tfloat lambert = max(.0, dot( n, light2Pos));\n\t\tcol *= vec3(lambert);\n\t\t\n\t\t\/\/vec3 light = vec3( sin( time ), 20 , cos(time) );\n\t\t\/\/col = col* vec3(dot ( -dir, n ));\n\t\t\n\t\t\/\/ specular : \n\t\tvec3 h = normalize( -dir + light2Pos);\n\t\tfloat spec = max( 0., dot( n, h ) );\n\t\tcol += vec3(pow( spec, 16.));\n\t\tcol *= ambientOcclusion( pos, n );\n\t\tcol *= softshadow(pos, light2Pos, .02, 5., 14. );\n\t\t\/\/col = vec3(ambientOcclusion( pos, n ));\n\t\t\n\t}\n\t\/\/vec3 col = vec3( nbIterF\/64. );\n\tfragColor= vec4( col, 1.0);\n}","name":"","description":"","type":"image"}]}}