{"Shader":{"ver":"0.1","info":{"id":"XlfSDl","date":"1440390559","viewed":896,"name":"Metaeaux - Glow","username":"metaeaux","description":"Volumetric shading with distance fields.","likes":3,"published":3,"flags":0,"tags":["raymarching","distancefields","glow","volumetricshading"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"const vec4 ambientColor = vec4(0.15, 0.2, 0.32, 1.0);\nconst vec4 skyColor = 0.3 * vec4(0.31, 0.47, 0.67, 1.0);\nconst float PI = 3.14159;\n\nfloat sphere(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat cube(vec3 p, vec3 size)\n{\n\tvec3 d = abs(p) - size;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(abs(p) - size, vec3(0.0)));\n}\n\nfloat cylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nvec3 repeat( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return q;\n}\n\nvec3 rotate(vec3 p, float theta)\n{\n    theta *= 2. * 3.14159;\n    mat3 ry = mat3(cos(theta), 0., sin(theta),\n                0., 1., 0.,\n                -sin(theta), 0., cos(theta));\n    return ry * p;\n}\n\nfloat distanceField(vec3 p) {\n    \/\/vec3 rotation = rotate(p, iGlobalTime * 0.2);\n    \/\/rotation = rotate(rotation.zxy, iGlobalTime * 0.4);\n    \/\/vec3 repeated = repeat(p, vec3(1.));\n    float d1 = torus(p, vec2(.3, .1));\n    return d1;\n}\n\nvec3 getNormal(vec3 p)\n{\n\tfloat h = 0.0001;\n\n\treturn normalize(vec3(\n\t\tdistanceField(p + vec3(h, 0, 0)) - distanceField(p - vec3(h, 0, 0)),\n\t\tdistanceField(p + vec3(0, h, 0)) - distanceField(p - vec3(0, h, 0)),\n\t\tdistanceField(p + vec3(0, 0, h)) - distanceField(p - vec3(0, 0, h))));\n}\n\n\/\/ phong shading\nvec4 phong(vec3 p, vec3 normal, vec3 lightPos, vec4 lightColor)\n{\n\tfloat lightIntensity = 0.0;\n\tvec3 lightDirection = normalize(lightPos - p);\n    \n    \/\/ lambert shading\n\tlightIntensity = clamp(dot(normal, lightDirection), 0.0, 1.);\n    \n    \/\/ lambert shading\n    vec4 colour = lightColor * lightIntensity;\n    \n    \/\/ specular highlights\n    colour += pow(lightIntensity, 32.0) * (1.0 - lightIntensity*0.5);\n        \n    \/\/ ambient colour\n    colour += ambientColor * (1.0 - lightIntensity);\n    \n    \n\treturn colour;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float gridSize = 6.0;\n    float u = gl_FragCoord.x * gridSize \/ iResolution.x - gridSize \/ 2.;\n    float v = gl_FragCoord.y * gridSize \/ iResolution.y - gridSize \/ 2.;\n    float aspectRatio = iResolution.x \/ iResolution.y;\n    \n    \n    vec2 theta = 2. * 3.14159 * (iResolution.xy - iMouse.xy) \/ iResolution.xy;\n    \n    theta.x += iGlobalTime;\n    \n    vec3 camUp = vec3(0., -0.5, 0.);\n    vec3 camForward = vec3(sin(theta.x), sin(theta.y), cos(theta.x));\n    vec3 camRight = cross(camForward, camUp); \/\/ vec3(1., 0., 0.);\n    float focalLength = 1.97;\n\n    vec3 ro = -vec3(sin(theta.x), sin(theta.y), cos(theta.x)); \/\/vec3(0., 0., -1.);\n\tvec3 rd = normalize(camForward * focalLength + camRight * u * aspectRatio + camUp * v);\n    vec4 color = skyColor;\n\n    float t = 0.0;\n    const int maxSteps = 32;\n    for(int i = 0; i < maxSteps; ++i)\n    {\n        vec3 p = ro + rd * t;\n        float d = distanceField(p);\n        if(d < 0.2 && d > 0.000001)\n        {\n            vec3 normal = getNormal(p);\n            color += 0.09*phong(p, normal, vec3(2.0, -2.0, -2.0), vec4(1.0, 0.5, 0.5, 0.01));\n\n        }\n\n\n        t += 0.2 * d;\n    }\n\n    fragColor = color;\n}","name":"","description":"","type":"image"}]}}