{"Shader":{"ver":"0.1","info":{"id":"4dy3zR","date":"1452875156","viewed":368,"name":"2D Movable Metaball","username":"aiekick","description":"use mouse or keyboard for move the ball <img src=\"\/img\/emoticonHappy.png\"\/><br\/>you have 2 sec for 60Hz display or 1 sec on 120 Hz display to put it in fullscreen after the reset <img src=\"\/img\/emoticonHappy.png\"\/>","likes":10,"published":3,"flags":48,"tags":["movetest"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/*\nthis layer read the ball pos from bufferA for warping the grid\nand superpose on top the ball in motion blur from buffer B\n*\/\n\nconst vec2 vBallPos = vec2(0.0,0.0);\nvec4 loadValue( in vec2 re ){return texture2D( iChannel1, (0.5+re) \/ iChannelResolution[0].xy, -100.0 );}\n\nvec2 warp(vec2 uv, vec2 m, float f, float z) \n{\n    \/\/ uv middle with center to the m vec2\n\tvec2 mo = 5.*(2.*m-iResolution.xy)\/min(iResolution.x,iResolution.y), mouv = mo-uv;\n    \n    \/\/ electro static formula\n\treturn uv - f*exp(-dot( mouv, mouv)\/abs(z)) * mouv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ read ball pos from buffer A\n    vec2 ballPos = loadValue(vBallPos).xy;\n    \n    \/\/ uv with center in bottom left of the screen (the range is (0,0) to (iResolution.x, iResolution.y)\n    vec2 uvBottomleft = fragCoord \/ iResolution.xy;\n    \n    \/\/ uv with center in middle of the screen (the range is (-5,-5) to (5,5)\n    vec2 uvMiddle = (2. * fragCoord - iResolution.xy)\/min(iResolution.x,iResolution.y)*5.;\n    \n    \/\/ uv for warping who take the ball position\n\tvec2 uvWarp = warp(uvMiddle, ballPos, 0.5, 16.);\n\t\n\t\/\/ convert uv to repeat (for doing the gris)\n\tvec2 rp = vec2(1);\n\tuvWarp = mod(uvWarp, rp) -rp\/2.;\n\t\n\t\/\/ base Color of the grid lines\n    vec3 c = vec3(0.8,0.2,0.2);\n    \n    \/\/ vertical lines\n    float vlines = smoothstep(.16, .25, uvWarp.x * uvWarp.x); \/\/ meta axis x\n    \n    \/\/ horizontal line\n    float hlines = smoothstep(.16, .25, uvWarp.y * uvWarp.y); \/\/ meta axis y\n\t\n    \/\/ superpose of verticals and horizontals line\n    c *= vlines + hlines;\n    \n    \/\/ superpose of gris and motion blured metaball from buffer B\n\tfragColor = c.xyzx + texture2D(iChannel0, uvBottomleft);\n}\n","name":"","description":"","type":"image"},{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/*\nthis layer read, modify, and save the position of the ball with mouse or keyboard\n*\/\n\n\/\/ texel loc of the ball position\nconst vec2 vBallPos = vec2(0.0,0.0);\n\n\/\/ speed increment\nconst float speed = 0.65;\n    \t\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ IQ Storage : https:\/\/www.shadertoy.com\/view\/MddGzf\nfloat isInside( vec2 p, vec2 c ) {vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nfloat isInside( vec2 p, vec4 c ) {vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y); }\nvec4 loadValue( in vec2 re ){return texture2D( iChannel0, (0.5+re) \/ iChannelResolution[0].xy, -100.0 );}\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord ){fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;}\nvoid storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord ){fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;}\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Keyboard \n\/\/ Keyboard constants definition\n\/\/ from P_Malin Code : https:\/\/www.shadertoy.com\/view\/XdcGWS\nconst float KEY_LEFT  = 37.5\/256.0;\nconst float KEY_UP    = 38.5\/256.0;\nconst float KEY_RIGHT = 39.5\/256.0;\nconst float KEY_DOWN  = 40.5\/256.0;\n\/\/ for other keyboard code see the shader of P_Malin\nbool KeyIsPressed(float key){return texture2D( iChannel1, vec2(key, 0.0) ).x > 0.0;}\nbool KeyIsToggled(float key){return texture2D( iChannel1, vec2(key, 1.0) ).x > 0.0;}\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ read the ball position from this buffer (the last saved)\n    vec2  ballPos = loadValue(vBallPos).xy;\n    \n    \n    bool kl = KeyIsPressed(KEY_LEFT);\n    bool kr = KeyIsPressed(KEY_RIGHT);\n    bool ku = KeyIsPressed(KEY_UP);\n    bool kd = KeyIsPressed(KEY_DOWN);\n    \n    \/\/ if mouse active, ball position is the position of the mouse\n    if (iMouse.z>0.) \n    {\n        ballPos = iMouse.xy;\n    }\n    else if (kl || kr || ku || kd)\/\/ else we use keyboard  (Left, Right,Up, Down, Right)\n    {\n        \/\/ ajust the speed step for depending of resolution and render time\n        float sp = speed * iTimeDelta * max(iResolution.x, iResolution.y);\n        \n    \tif (kl) ballPos.x -= sp;\n    \tif (kr) ballPos.x += sp;\n    \tif (ku) ballPos.y += sp;\n    \tif (kd) ballPos.y -= sp;\n    }\n    else\n    {\n        \/\/ middle of the screen\n        vec2 midScreen = iResolution.xy \/ 2.;\n\n        \/\/ angle \n        float a = iGlobalTime*2.;;\n\n        \/\/infini path\n        ballPos = vec2(cos(a) * 1.5, sin(a) * cos(a) * 1.2) * midScreen.y * 0.8 + midScreen;\n    }\n    \n    \/\/ init fragcolor before save\n    fragColor = vec4(0);\n    \n    \/\/for define a initial ball position to the middle of the screen for iframe < 10 \n    \/\/ 120 frames is near 2 sec on 60Hz display or 1 sec on 120 Hz display.\n    \/\/ its sufficient to put in full screen after the reset of the shader\n    \/\/ and get the good iResolution for the new size of the fullscreen\n    if ( iFrame < 120) ballPos = iResolution.xy\/2.;\n    \n    \/\/ finally dont forget to store the ball position in the buffer\n    storeValue( vBallPos, vec4(ballPos,0,1), fragColor, fragCoord );\n}","name":"","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/*\nthis layer read the ball postiion from buffer A \nand do the motion blur effect of the ball\n*\/\n\nconst vec2 vBallPos = vec2(0.0,0.0);\nvec4 loadValue( in vec2 re ){return texture2D( iChannel1, (0.5+re) \/ iChannelResolution[0].xy, -100.0 );}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = 2.;\n    \n    \/\/ uv with center in bottom left of the screen (the range is (0,0) to (iResolution.x, iResolution.y)\n    vec2 uvBottomleft = fragCoord \/ iResolution.xy;\n    \n    \/\/ uv with center in middle of the screen (the range is (-zoom,-zoom) to (zoom,zoom)\n    vec2 uvMiddle = (2. * fragCoord - iResolution.xy)\/iResolution.y * zoom;\n    \n    \/\/ read the ball position from buffer A\n    vec2 ballPos = loadValue(vBallPos).xy;\n    \n    \/\/ uv with center to the ball position\n    vec2 uvBall = (2. * ballPos - iResolution.xy)\/iResolution.y * zoom;\n    \n    \/\/ position of the ball in uv\n    vec2 p = uvMiddle - uvBall;\n    \n    \/\/ simpole mean of 10% for the current color and 90% of the last rendering color from this bufferB\n    fragColor = 0.1\/dot(p,p) * 0.1 + texture2D(iChannel0, uvBottomleft) * 0.9; \/\/ easy mean\n}","name":"","description":"","type":"buffer"}]}}