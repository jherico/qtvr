{"Shader":{"ver":"0.1","info":{"id":"4lsSzX","date":"1438651295","viewed":1094,"name":"Distance Field Text","username":"Flyguy","description":"Distance field based text with an 80's scifi like style. This is based on some shaders I posted on GLSL Sandbox a few days ago.","likes":21,"published":3,"flags":0,"tags":["retro","text","logo","distance","shadertoy","scifi"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/#define SHOW_DISTANCE\n\n#define BACK_COL_TOP vec3(1,0,1)\n#define BACK_COL_BOTTOM vec3(0,0,1)\n\n#define TEXT_COL1_TOP vec3(0.05, 0.05, 0.40)\n#define TEXT_COL1_BOTTOM vec3(0.60, 0.90, 1.00)\n#define TEXT_COL2_TOP vec3(0.10, 0.10, 0.00)\n#define TEXT_COL2_BOTTOM vec3(1.90, 1.30, 1.00)\n\n\/\/--- Primiives ---\nfloat dfSemiArc(float rma, float rmi, vec2 uv)\n{\n\treturn max(abs(length(uv) - rma) - rmi, uv.x-0.0);\n}\n\n\/\/p0 = bottom left, clockwise winding\nfloat dfQuad(vec2 p0, vec2 p1, vec2 p2, vec2 p3, vec2 uv)\n{\n\tvec2 s0n = normalize((p1 - p0).yx * vec2(-1,1));\n\tvec2 s1n = normalize((p2 - p1).yx * vec2(-1,1));\n\tvec2 s2n = normalize((p3 - p2).yx * vec2(-1,1));\n\tvec2 s3n = normalize((p0 - p3).yx * vec2(-1,1));\n\t\n\treturn max(max(dot(uv-p0,s0n),dot(uv-p1,s1n)), max(dot(uv-p2,s2n),dot(uv-p3,s3n)));\n}\n\nfloat dfRect(vec2 size, vec2 uv)\n{\n\treturn max(max(-uv.x,uv.x - size.x),max(-uv.y,uv.y - size.y));\n}\n\/\/-----------------\n\n\/\/--- Letters ---\nvoid S(inout float df, vec2 uv)\n{\n\tdf = min(df, dfSemiArc(0.25, 0.125, uv - vec2(-0.250,0.250)));\n\tdf = min(df, dfSemiArc(0.25, 0.125, (uv - vec2(-0.125,-0.25)) * vec2(-1)));\n\tdf = min(df, dfRect(vec2(0.125, 0.250), uv - vec2(-0.250,-0.125)));\n\tdf = min(df, dfQuad(vec2(-0.625,-0.625), vec2(-0.500,-0.375), vec2(-0.125,-0.375), vec2(-0.125,-0.625), uv));\t\n\tdf = min(df, dfQuad(vec2(-0.250,0.375), vec2(-0.250,0.625), vec2(0.250,0.625), vec2(0.125,0.375), uv));\n}\n\nvoid H(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.250, 1.250), uv - vec2(-0.625,-0.625)));\n    df = min(df, dfRect(vec2(0.250, 1.250), uv - vec2(-0.000,-0.625)));\n\tdf = min(df, dfQuad(vec2(-0.375,-0.125), vec2(-0.375,0.125), vec2(0.000, 0.125), vec2(-0.125,-0.125), uv));\t\n}\n\nvoid A(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.250, 0.825), uv - vec2(-0.625,-0.625)));\n    df = min(df, dfRect(vec2(0.250, 0.825), uv - vec2(-0.000,-0.625)));\n\tdf = min(df, dfQuad(vec2(-0.375,-0.125), vec2(-0.375,0.125), vec2(0.000, 0.125), vec2(-0.125,-0.125), uv));\t\n    df = min(df, dfSemiArc(0.3125, 0.125, (uv.yx - vec2(0.1875,-0.1875)) * -1.0));\n}\n\nvoid D(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.250, 1.25), uv - vec2(-0.625,-0.625)));\n    df = min(df, dfSemiArc(0.5, 0.125, (uv.xy * vec2(-1,1) - vec2(0.375,-0.00))));\n}\n\nvoid E(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.250, 1.250), uv - vec2(-0.625,-0.625)));    \n    df = min(df, dfQuad(vec2(-0.375,-0.625), vec2(-0.375,-0.375), vec2(0.250, -0.375), vec2( 0.125,-0.625), uv));\t\n    df = min(df, dfQuad(vec2(-0.375,0.375), vec2(-0.375,0.625), vec2(0.250, 0.625), vec2(0.125, 0.375), uv));\t   \n    df = min(df, dfQuad(vec2(-0.375,-0.125), vec2(-0.375,0.125), vec2(0.000, 0.125), vec2(-0.125,-0.125), uv));\t\n}\n\nvoid R(inout float df, vec2 uv)\n{\n\tdf = min(df, dfRect(vec2(0.250, 1.250), uv - vec2(-0.625,-0.625)));\n    df = min(df, dfSemiArc(0.25, 0.125, (uv.xy * vec2(-1,1) - vec2(0.125,0.25))));    \n    df = min(df, dfRect(vec2(0.25, 0.250), uv - vec2(-0.375,0.375)));\n    df = min(df, dfQuad(vec2(-0.375,-0.125), vec2(-0.250,0.125), vec2(0.000, 0.125), vec2(-0.125,-0.125), uv));\t\n    df = min(df, dfQuad(vec2(-0.375,-0.125), vec2(-0.1,-0.125), vec2(0.250,-0.625), vec2(-0.025,-0.625), uv));\t\n\n}\n\nvoid T(inout float df, vec2 uv)\n{\n    df = min(df, dfRect(vec2(0.250, 1.0), uv - vec2(-0.3125,-0.625))); \n\tdf = min(df, dfQuad(vec2(-0.625, 0.375), vec2(-0.625,0.625), vec2(0.250, 0.625), vec2(0.125, 0.375), uv));\t\n}\n\nvoid O(inout float df, vec2 uv)\n{\n    df = min(df, dfRect(vec2(0.25, 0.375), uv - vec2( 0.000,-0.1875)));  \n    df = min(df, dfRect(vec2(0.25, 0.375), uv - vec2(-0.625,-0.1875)));  \n    df = min(df, dfSemiArc(0.3125, 0.125, (uv.yx - vec2(0.1875,-0.1875)) * -1.0));\n    df = min(df, dfSemiArc(0.3125, 0.125, (uv.yx - vec2(-0.1875,-0.1875)) ));\n}\n\nvoid Y(inout float df, vec2 uv)\n{\n    df = min(df, dfRect(vec2(0.25, 0.25), uv - vec2( 0.000,0.375)));  \n    df = min(df, dfRect(vec2(0.25, 0.25), uv - vec2(-0.625,0.375)));  \n    df = min(df, dfSemiArc(0.3125, 0.125, (uv.yx - vec2(0.375,-0.1875)) ));\n    df = min(df, dfRect(vec2(0.250, 0.75), uv - vec2(-0.3125,-0.625))); \n}\n\n\/\/---------------\n\n\/\/--- Gradient Stuff ---\n\/\/returns 0-1 when xn is between x0-x1\nfloat linstep(float x0, float x1, float xn)\n{\n\treturn (xn - x0) \/ (x1 - x0);\n}\n\nvec3 retrograd(float x0, float x1, float m, vec2 uv)\n{\n\tfloat mid = x0+(x1 - x0) * m;\n\n\tvec3 grad1 = mix(TEXT_COL1_BOTTOM, TEXT_COL1_TOP, linstep(mid, x1, uv.y));\n    vec3 grad2 = mix(TEXT_COL2_BOTTOM, TEXT_COL2_TOP, linstep(x0, mid, uv.y));\n\n\treturn mix(grad2, grad1, smoothstep(mid, mid + 0.04, uv.y));\n}\n\/\/----------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 aspect = iResolution.xy\/iResolution.y;\n\tvec2 uv = ( fragCoord.xy \/ iResolution.y );\n\t\n\tuv = (uv - aspect\/2.0)*8.0;\n\t\n    \/\/Text distance field\n\tfloat dist = 1e6;\n\t\n\tvec2 chSpace = vec2(1.125,1.500);\n\t\n\tvec2 chuv = uv;\n\tchuv.x += (chSpace.x * 9.0) \/ 2.0 - 0.75;\n\t\t\n\tS(dist, chuv); chuv.x -= chSpace.x;\n\tH(dist, chuv); chuv.x -= chSpace.x;\n\tA(dist, chuv); chuv.x -= chSpace.x;\n\tD(dist, chuv); chuv.x -= chSpace.x;\n    E(dist, chuv); chuv.x -= chSpace.x;\n    R(dist, chuv); chuv.x -= chSpace.x;\n\tT(dist, chuv); chuv.x -= chSpace.x;\n    O(dist, chuv); chuv.x -= chSpace.x;\n    Y(dist, chuv); chuv.x -= chSpace.x;\n    \n    dist \/= 2.0;\n    \n    \/\/Colors and mixing mask\n\tfloat mask = smoothstep(4.0 \/ iResolution.y, 0.00, dist);\n    \n\tvec3 textcol = retrograd(-0.75, 0.50, 0.40 + pow(abs(dist), 0.25) * 0.08, uv);\n\t\n\tvec3 backcol = mix(BACK_COL_BOTTOM, BACK_COL_TOP, (uv.y\/4.0)+0.5) * smoothstep(0.02, 0.025, dist);\n\t\n    \/\/Grid Stuff\n\tvec2 gdef = vec2(uv.x \/ abs(uv.y), 1.0 \/ (uv.y));\n\tgdef.y = clamp(gdef.y,-1e2, 1e2);\n\t\n\tvec2 gpos = vec2(0.0,-iGlobalTime);\n\t\n\tgdef += gpos;\n\t\n\tvec2 grep = mod(gdef*vec2(1.0,2.0), vec2(1.0));\n\t\n\tfloat grid = max(abs(grep.x - 0.5),abs(grep.y - 0.5));\n\t\n\tfloat gs = length(gdef-gpos)*0.01;\n\t\n\tbackcol *= mix(smoothstep(0.46-gs,0.48+gs,grid), 1.0, step(0.0,uv.y))*0.75+0.25;\n\t\n    \/\/Mixing text with background\n\tvec3 color = mix(backcol,textcol,mask);\n\t\n    #ifdef SHOW_DISTANCE\n    color = vec3(sin(dist*48.0));\n    #endif\n    \n\tfragColor = vec4( vec3( color ), 1.0 );\n}","name":"","description":"","type":"image"}]}}