{"Shader":{"ver":"0.1","info":{"id":"ltB3Wd","date":"1436918249","viewed":842,"name":"Ray Marching Experiment 28","username":"aiekick","description":"seems to be a lava sphere (800\u00b0C)<br\/>mouse control<br\/>now i need a fast antialaising ^^","likes":1,"published":3,"flags":0,"tags":["ray","experiment","marching","28"],"hasliked":0},"renderpass":[{"inputs":[{"id":10,"src":"\/presets\/tex09.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":23,"src":"\/presets\/cube01_0.png","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Stephane Cuillerdier - Aiekick\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define lava_temperature 1200.\n\nfloat dstef = 0.0;\n    \nconst vec2 RMPrec = vec2(0.2, 0.05); \/\/ ray marching tolerance precision \/\/ vec2(low, high)\nconst vec2 DPrec = vec2(0.0001, 50.); \/\/ ray marching distance precision\n    \n\/\/ return color from temperature \n\/\/ algo based on :\n\/\/http:\/\/www.physics.sfasu.edu\/astro\/color\/blackbody.html\n\/\/http:\/\/www.vendian.org\/mncharity\/dir3\/blackbody\/\n\/\/http:\/\/www.vendian.org\/mncharity\/dir3\/blackbody\/UnstableURLs\/bbr_color.html\nvec3 hco(float temp)\/\/ hot color\n{\n\tvec3 col = vec3(255.);\n\tcol.x = 56100000. * pow(temp,(-3. \/ 2.)) + 148.;\n   \tcol.y = 100.04 * log(temp) - 623.6;\n   \tif (temp > 6500.) col.y = 35200000. * pow(temp,(-3. \/ 2.)) + 184.;\n   \tcol.z = 194.18 * log(temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)\/255.;\n\tif (temp < 1000.) col *= temp\/1000.;\n   \treturn col;\n}\n\n\/\/ from my shader https:\/\/www.shadertoy.com\/view\/ltXSWN (reduced with coyote help)\n#define b(p) vec4(R = sqrt(length(v-col.p) * vec2(.7)),0.0001\/dot(R,R),0)\nvec4 map(vec3 p)\n{\n    vec2 v = p.xz\/15.;\n    vec4 col;\n    vec2 R;\n    float t = iGlobalTime*.5;\n    col.z = (col.x = cos(t))*2.; \n\tcol.w = -.5*(col.y = sin(t)); \n    col = b(xy*-.07) + b(xy*.07) + b(xw*-.1) + b(zy*.15);\n    col = texture2D(iChannel1, col.xy); \/\/ col.z is the metaball\n    \n    dstef += 0.02;\n\n    col.rgb = clamp(col.rgb, vec3(0), vec3(1.));\n \tfloat dist = length(p) -4. + smoothstep(0., 1., dot(col.rgb,vec3(0.1)));\n    \n    \n \treturn vec4(dist, col.rgb);\n}\n\nvec3 nor( vec3 pos, float prec )\n{\n\tvec2 e = vec2( prec, 0. );\n\tvec3 n = vec3(\n\tmap(pos+e.xyy).x - map(pos-e.xyy).x,\n\tmap(pos+e.yxy).x - map(pos-e.yxy).x,\n\tmap(pos+e.yyx).x - map(pos-e.yyx).x );\n\treturn normalize(n);\n}\n\nvoid mainImage( out vec4 f, in vec2 g )\n{\n    float t = iGlobalTime*.2;\n    \n    float ca = t; \/\/ angle z\n    \n    float ce = 2.5; \/\/ elevation\n    float cd = 4.6; \/\/ distance to origin axis\n   \t\n    vec3 cu=vec3(0,1,0);\/\/Change camere up vector here\n  \tvec3 cv=vec3(0,0,0); \/\/Change camere view here\n  \tfloat li = 0.6; \/\/ light intensity\n    float prec = 0.00001; \/\/ ray marching precision\n    float maxd = 50.; \/\/ ray marching distance max\n    float refl_i = .6; \/\/ reflexion intensity\n    float refr_a = 1.2; \/\/ refraction angle\n    float refr_i = .8; \/\/ refraction intensity\n    float bii = 0.35; \/\/ bright init intensity\n    float marchPrecision = 0.5; \/\/ ray marching tolerance precision\n    \n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    if ( iMouse.z>0.) ce = iMouse.x\/iResolution.x * 10.; \/\/ mouse x axis \n    if ( iMouse.z>0.) cd = iMouse.y\/iResolution.y * 50.; \/\/ mouse y axis \n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n   \n    vec2 si = iResolution.xy;\n   \tvec2 uv = (g+g-si)\/si.y;\n    \n    vec3 ro = vec3(sin(t)*cd, ce+1., cos(t)*cd); \/\/\n  \tvec3 rov = normalize(cv-ro);\n    vec3 u = normalize(cross(cu,rov));\n  \tvec3 v = cross(rov,u);\n  \tvec3 rd = normalize(rov + uv.x*u + uv.y*v);\n    \n    float b = bii;\n    \n    float d = 0.;\n    vec3 p;\n    float s = DPrec.x;\n\t                   \n    for(int i=0;i<200;i++)\n    {      \n        p = ro+rd*d;\n    \tif(s<DPrec.x||s>DPrec.y) break;\n        s = map(p).x*(s>DPrec.x?RMPrec.x:RMPrec.y);\n        d += s;\n    }\n\n    if (d<DPrec.y)\n    {\n    \tvec3 n = nor(p, 0.2);\n\n       \tf = textureCube(iChannel0, reflect(rd, n))  * refl_i + pow(b,15.); \n\n        f.rgb = mix( f.rgb, map(p).yzw, 2.8-dstef);\n        \n        f.rgb *= hco(dstef*lava_temperature);\n    }\n    else\n    {\n        f = textureCube(iChannel0, rd);\n    }\n}","name":"","description":"","type":"image"}]}}