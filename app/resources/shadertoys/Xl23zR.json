{"Shader":{"ver":"0.1","info":{"id":"Xl23zR","date":"1426863086","viewed":631,"name":"[NV15] UFBs","username":"andr00","description":"Who are these mysterious invaders? What do they want?","likes":0,"published":3,"flags":0,"tags":["space","nv15","unidentified"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"vec2 hash2( vec2 p ) {\n\treturn texture2D( iChannel0, (p+0.5)\/256.0, -100.0 ).xy;\n}\n\nvoid rY(inout vec3 p, float a) {\n\tfloat c,s;vec3 q=p;\n\tc = cos(a); s = sin(a);\n\tp.x = c * q.x + s * q.z;\n\tp.z = -s * q.x + c * q.z;\n}\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat box(vec3 p, vec3 s) {\n    return length(max(abs(p) - s, 0.0));\n}\n\nfloat mod1(inout float x, float m) {\n\tfloat r = floor(x\/m);\n\tx = mod(x,m) - 0.5 * m;\n\treturn r;\n}\n\nfloat aUfb(vec3 pos) {\n    return \n\t\tmax(\n        min(\n        sphere(pos - vec3(-1.0,0.0,0.0), 2.0)\n        ,sphere(pos - vec3(1.0,0.0,0.0), 2.0)\n\t\t),\n       box(pos - vec3(0.0, 1.9,1.0), vec3(3.0,1.0,3.0))\n        )\n        ;\t\n\n}\n\nfloat regularUfbs(vec3 pos) {\n\tpos.x -= iGlobalTime * 5.0;\n\tpos.y += 7.1;\n\tmod1(pos.x, 12.0);\n\tmod1(pos.z, 12.0);\n\trY(pos, iGlobalTime * 0.5);\n    return aUfb(pos);\n}\n\nvoid wavey( inout vec3 p )\n{\n\tp.y += (sin(length(p-vec3(100.0,0.0,-100.0)) - iGlobalTime * 5.0) * 0.1)\n\t\t+ sin(length(p-vec3(-100.0,0.0,-100.0)) - iGlobalTime * 5.0) * 0.1\n;\n}\n\nfloat xzplane(vec3 pos,float y) {\n\treturn abs(pos.y - y);\n}\n\nfloat waterplane(vec3 pos) {\n\twavey(pos);\n\treturn xzplane(pos,12.0);\n}\n\nfloat distFunc(vec3 pos) {\n    return min(regularUfbs(pos),waterplane(pos));\n}\n\nvec3 distNorm(vec3 pos) {\n    const vec2 eps = vec2(0.0, 0.1);\n    return normalize(vec3(\n\t\t\t distFunc(pos + eps.yxx) - distFunc(pos - eps.yxx),\n\t\t\t distFunc(pos + eps.xyx) - distFunc(pos - eps.xyx),\n\t\t\t distFunc(pos + eps.xxy) - distFunc(pos - eps.xxy)));\n}\n\nvec4 lightUfb(vec3 pos, vec3 lig, vec3 rayDir) {\n\tvec3 normal = distNorm(pos);\n\n\tfloat ndl = clamp( dot(normal, lig), 0.0, 1.0 );\n\tfloat diffuse = max(0.0, dot(-rayDir, normal));\n\/\/\tvec3 bcolor = vec3(1.0); \/\/ NASA\n  vec3 bcolor = vec3(0.92, 0.82, 0.63); \/\/ strangely peachy\n\/\/\tvec3 bcolor = vec3(0.92, 0.82, 0.01); \/\/ maybe these are minions\n\n    vec3 color = bcolor * 0.1 + bcolor * ndl + ndl * 0.05 * pow(clamp(dot(normalize(-rayDir+lig),normal),0.0,1.0),1.0);\n\n\treturn vec4(color, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = fragCoord.xy \/ iResolution.xx;    \n    float t = iGlobalTime;\n\n\tvec3 cameraOrigin = vec3(2.0, 4.0, 2.0);\n\n    \/\/ You probably want to zero this out if you're viewing this in VR\n    vec2 cameraNoise = hash2(vec2(iGlobalTime * 0.0001, iGlobalTime));\n\n    vec3 cameraTarget = vec3(cameraNoise.xy * pow(sin(iGlobalTime),2.0) + vec2(0.0,3.0), 0.0);\n       \n    vec3 upDirection = normalize(vec3(0.1 - cameraNoise.x * 0.3, 1.0, 0.0));\n\n\tvec3 cameraDir = normalize(cameraTarget - cameraOrigin);    \n    \n\tvec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n\tvec3 cameraUp = cross(cameraDir, cameraRight);\n\tvec2 screenPos = -1.0 + 2.0 * fragCoord.xy \/ iResolution.xy; \n\tscreenPos.x *= iResolution.x \/ iResolution.y;\n\n\tvec3 rayDir = normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n\n\n\tconst int MAX_ITER = 100; \/\/ 30 = eerie\n\tconst float MAX_DIST = 800.0; \n\tconst float EPSILON = 0.001;\n\n\tfloat totalDist = 0.0;\n\tvec3 pos = cameraOrigin;\n\tfloat dist = EPSILON;\n\n    vec2 cCoord = vec2(0.5,0.5);\n    \n    float d2 = pow(length(p-cCoord),2.0);\n\n    float moreShade = clamp(0.5 - abs(0.3 - d2),0.0,1.0);\n    vec4 halo = vec4(moreShade * 0.2);\n\n\n\tfloat reflectcount = 0.0;    \n\tfloat ix = 0.0;\n\tconst float iterStep = 1.0 \/ float(MAX_ITER);\n\n\tfor (float ix = 0.0; ix <= 1.0; ix += iterStep) {\n\n\t    if ((dist < EPSILON) || (totalDist > MAX_DIST))\n     \t   break;\n\n        dist = distFunc(pos);\n        totalDist += dist;\n        pos += dist * rayDir; \n\n        vec3 lig = normalize( vec3(5.0, -1.4, 2.0) );\n\t\t\n        if (dist < EPSILON) {\n            if(waterplane(pos) < EPSILON && (reflectcount < 1.0)) {\n\t\t\treflectcount += 1.0;\n\n\t\t\tpos.y -= 0.04; \/\/ corny\n\t\t\trayDir = reflect(rayDir, distNorm(pos));\n\t\t\tdist = distFunc(pos);\n            } else {\n                \/\/ it's a ufb              \n\t            fragColor = lightUfb(pos, lig, rayDir);            \n\t\t\t   fragColor += vec4(ix);\n\t\t  }\n\n        } else {\n\t\t\tfragColor = vec4(ix,ix,ix*0.8 + 0.2,1.0);\n\t\t}\n\t}\n\tfragColor += halo;\n    \n}\n","name":"","description":"","type":"image"}]}}