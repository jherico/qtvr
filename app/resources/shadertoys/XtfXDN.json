{"Shader":{"ver":"0.1","info":{"id":"XtfXDN","date":"1437227300","viewed":4147,"name":" [SIG15] Oblivion","username":"Dave_Hoskins","description":"The Oblivion drone. I love all the scenes that include these things.<br\/>PLEASE REWIND ON FIRST LOAD [|<], to make sure audio is in sync.<br\/>\"Tech 4-9, Jack Harper!!!\"","likes":79,"published":3,"flags":8,"tags":["3d","raymarch","sound","speech","formant","siggraph","drone","sig15","oblivion","cruise"],"hasliked":0},"renderpass":[{"inputs":[{"id":4,"src":"\/presets\/tex03.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":8,"src":"\/presets\/tex07.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":27,"src":"\/presets\/cube05_0.png","ctype":"cubemap","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ [SIG15] Oblivion\n\/\/ by David Hoskins.\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ The Oblivion drone. I love all the scenes that include these things.\n\/\/ It takes bits from all over:-\n\/\/ https:\/\/www.youtube.com\/watch?v=rEby9OkePpg&feature=youtu.be\n\/\/ These drones were the true stars of the film!\n\n\/\/ You might need to rewind to sync the audio properly.\n\n\/\/ Some info, if you want to know:-\n\/\/ The camera is delayed when following the drone to make it feel hand held.\n\/\/ The rendering layers consist of:-\n\/\/ 1. Background, including sky, ground and shadow. Plus a check for a possible heat haze\n\/\/    to bend the ray, before beginning trace.\n\/\/ 2. Anti-aliased drone ray-marching, which is traced from just in front to just behind it for speed.\n\/\/ 3. Clouds, and fogging.\n\/\/ 4. Foreground, for ID scanner\n\n#define PI 3.14156\n#define TAU 6.2831853071\n#define MOD2 vec2(443.8975,397.2973)\n#define MOD3 vec3(443.8975,397.2973, 491.1871)\n\nconst vec2 add = vec2(1.0, 0.0);\nvec3 sunDir = normalize(vec3(-2.3, 3.4, -5.89));\nconst vec3 sunCol = vec3(1.0, 1.0, .9);\nvec2 gunMovement;\nvec3 drone;\nvec3 droneRots;\nfloat scannerOn;\nvec4 dStack;\nvec4 eStack;\nint emitionType = 0;\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ Action cue sheet, for easy manipulation...\n#define cueINCLOUDS 0.0\n#define cueFLYIN 14.0\n#define cueFRONTOF cueFLYIN + 10.0\n#define cueTHREAT cueFRONTOF + 5.\n#define cueFLYOFF cueTHREAT + 19.0\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ A hash that's the same on all platforms...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3.zxy, p3.yxz+19.19);\n    return fract(vec3(p3.x * p3.y, p3.x*p3.z, p3.y*p3.z));\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * MOD3);\n   p3 += dot(p3.xyz, p3.yzx + 19.19);\n   return fract(vec3(p3.x * p3.y, p3.x*p3.z, p3.y*p3.z));\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 noise3(float n)\n{\n    float f = fract(n);\n    n = floor(n);\n    f = f*f*(3.0-2.0*f);\n    return mix(hash31(n), hash31(n+1.0), f);\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(1.5-f)*2.0;\n    \n    vec3 res = mix(mix( hash32(p), hash32(p + add.xy),f.x),\n               mix( hash32(p + add.yx), hash32(p + add.xx),f.x),f.y);\n    return res;\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ CubeMap OpenGL clamping fix. Why do I have to do this?\nvec3 cubeMap(in samplerCube sam, in vec3 v, float size)\n{\n   float M = max(max(abs(v.x), abs(v.y)), abs(v.z));\n   float scale = (float(size) - 1.) \/ float(size);\n   if (abs(v.x) != M) v.x *= scale;\n   if (abs(v.y) != M) v.y *= scale;\n   if (abs(v.z) != M) v.z *= scale;\n   return textureCube(sam, v).xyz;\n}\n\n\/\/ Thanks to iq for the distance functions...\n\/\/----------------------------------------------------------------------------------------\nfloat circle(vec2 p, float s )\n{\n    return length(p)-s;\n}\n\/\/----------------------------------------------------------------------------------------\nfloat  sphere(vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat prism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.x-h.y,max(q.z*0.6+p.y*.5,-p.y)-h.x*0.5);\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat prismFlip( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.x-h.y,max(q.z*.8-p.y*.5,p.y)-h.x*0.5);\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat roundedSquare( vec2 p, vec2 b)\n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    \n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat roundedBox( vec3 p, vec3 b, float r )\n{\n\treturn length(max(abs(p)-b,0.0))-r;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat sMin( float a, float b, float k )\n{\n    \n\tfloat h = clamp(0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.-h);\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec2 rot2D(inout vec2 p, float a)\n{\n    return cos(a)*p - sin(a) * vec2(p.y, -p.x);\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 rot3DXY(in vec3 p, in vec2 a)\n{\n\tvec2 si = sin(a);\n\tvec2 co = cos(a);\n    p.xz *= mat2(co.y, -si.y, si.y, co.y);\n    p.zy *= mat2(co.x, -si.x, si.x, co.x);\n    return p;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat boxMap( sampler2D sam, in vec3 p, in vec3 n)\n{\n    p = p*vec3(.1, .03, .1);\n    n = abs(n);\n\tfloat x = texture2D( sam, p.yz ).y;\n\tfloat y = texture2D( sam, p.zx ).y;\n\tfloat z = texture2D( sam, p.xy ).y;\n\treturn (x*n.x + y*n.y + z*n.z)\/(n.x+n.y+n.z);\n}\n\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n\nfloat triNoise3d(in vec3 p, in float spd, float ti)\n{\n    float z=1.1;\n\tfloat rz = 0.;\n    vec3 bp = p*1.5;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec3 dg = tri3(bp);\n        p += (dg+spd);\n        bp *= 1.9;\n\t\tz *= 1.5;\n\t\tp *= 1.3;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))\/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\nfloat fogmap(in vec3 p, in float d, float ti)\n{\n    p.xz *= .4;\n    p.z += ti*1.5;\n    return max(triNoise3d(p*.3\/(d+20.),0.2, ti)*1.8-.7, 0.)*(smoothstep(0.,25.,p.y));\n}\n\/\/ Thanks to nimitz for the quick fog\/clouds idea...\n\/\/ https:\/\/www.shadertoy.com\/view\/4ts3z2\nvec3 clouds(in vec3 col, in vec3 ro, in vec3 rd, in float mt, float ti)\n{\n    float d = 3.5;\n    for(int i=0; i<7; i++)\n    {\n        if (d>mt)break;\n        vec3  pos = ro + rd*d;\n        float rz = fogmap(pos, d, ti);\n        vec3 col2 = (vec3(.4,0.4,.4));\n        col = mix(col,col2,clamp(rz*smoothstep(d,d*1.86,mt),0.,1.) );\n        d *= 1.86;\n        \n    }\n    return col;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec4 numbers(vec4 mat, vec2 p)\n{\n    p.y *= 1.70;\n    p.y+=.32;\n\tfloat d;\n\td =(roundedSquare(p+vec2(1.4, -.25), vec2(.02, .76)));\n  \td =min(d, (roundedSquare(p+vec2(1.48, -1.04), vec2(.1, .06))));\n\n    vec2 v = p;\n    v.x -= v.y*.6;\n    v.x = abs(v.x+.149)-.75;\n\td = min(d, roundedSquare(v+vec2(0.0, -.7), vec2(.07, .4)));\n    v = p;\n    v.x -= v.y*.6;\n    v.x = abs(v.x-.225)-.75;\n    p.x = abs(p.x-.391)-.75;\n  \td = min(d, circle(p, .5));\n   \td = max(d, -circle(p, .452));\n    d = max(d, -roundedSquare(v+vec2(0., -.87), vec2(.33, .9)));\n    \n    mat = mix(mat, vec4(.8), smoothstep(0.2, .15, d));\n    return mat;\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ Find the drone...\nfloat mapDE(vec3 p)\n{\n    p -= drone.xyz;\n    p = rot3DXY(p, droneRots.xy);\n\n    float d = sphere(p, 10.0);\n\tvec3 v = p;\n    v.xy = abs(v.xy);\n    v.xy = rot2D(v.xy, -PI\/6.2);\n    \/\/ Cross pieces...\n    d = sMin(d, roundedBox(v-vec3(0,0,-8), vec3(4.9, .3, .5), 1.), 1.2); \n    d = max(d, -roundedBox(v-vec3(0,0,-8.5), vec3(4.8, .3, 1.), 1.));\n    \n    \/\/ Centre cutout...\n    \/\/d = sMin(d, roundedBox(p-vec3(0,0,-8.5), vec3(1.3, 1.4, 1.5), .7), .4); \n    d = max(d,-roundedBox(p-vec3(0,0,-9.1), vec3(2., 1.5, 4.0), .7)); \n    \/\/ Inside...\n    d = min(d, sphere(p, 8.8));\n    d = max(d, roundedBox(p, vec3(6.5, 12, 12.0), .8)); \n    \/\/ Make back...\n    d = sMin(d, prismFlip(p+ vec3(.0, -4.1, -8.1), vec2(7., 4.7) ), 1.);\n    d = max(d, -prism(p + vec3(.0, 6.4, -11.4), vec2(8.0, 10.0) ));\n    d = min(d, sphere(p+ vec3(.0, 5.6, -6.2), 3.0));\n    \n    \/\/ Eye locations..\/\n    d = min(d, sphere(v+ vec3(-3.5, .0, 7.4), 1.1));\n    \n    v = p;\n    v.x = abs(v.x);\n    d = sMin(d, roundedBox(v+vec3(-4.2,-6.,-10.0), vec3(1.1, .1, 4.5), 1.), 2.4); \n    \n    v =abs(p)-vec3(gunMovement.x, .0, 0.) ;\n    v.x -= p.z*.1*gunMovement.y;\n\tfloat d2 = sphere(v, 10.0);\n    d2 = max(d2, -roundedBox(v, vec3(6.55, 12, 12.0), .8)); \n    d = min(d2 ,d);\n    d = min(d,roundedBox(v-vec3(5.5, 3.5, 3.5), vec3(2.3, .1, .1), .4));\n    d = min(d,roundedBox(v-vec3(5.5, .0, 5.), vec3(2.4, .1, .1), .4));\n\n    v =vec3(abs(p.xy)-vec2(gunMovement.x, .0), p.z);\n    v.x -= p.z*.1*gunMovement.y;\n\n    d = min(d, roundedBox(v-vec3(8., 2.8, -6.5), vec3(.3, 1., 3.), .2));\n    d = min(d, roundedBox(v-vec3(8., 2.3, -10.), vec3(.2, .4, 1.2), .2));\n    d = min(d, roundedBox(v-vec3(8., 3.4, -10.), vec3(.01, .01, 1.2), .4));\n    d = max(d, -roundedBox(v-vec3(8., 3.4, -10.4), vec3(.01, .01, 1.2), .3));\n    d = max(d, -roundedBox(v-vec3(8., 2.3, -10.4), vec3(.01, .01, 1.2), .3));\n    \n    d = min(d,  roundedBox(v-vec3(8.55, 0, -4.5), vec3(.4, .2, 1.), .4));\n    d = max(d, -roundedBox(v-vec3(8.65, 0, -4.5), vec3(.0, .0, 2.), .34));\n       \n    return d;\n}\n\n\/\/---------------------------------------------------------------------------\nfloat bumpstep(float edge0, float edge1, float x)\n{\n    return 1.0-abs(clamp((x - edge0) \/ (edge1 - edge0), 0.0, 1.0)-.5)*2.0;\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ Find the drone's material...yes, it's IFtastic! :D\nvec4 mapCE(vec3 p, vec3 nor)\n{\n    vec4 mat;\n    p -= drone.xyz;\n\tp = rot3DXY(p, droneRots.xy);\n\n    const vec4 gunMetal = vec4(.05, .05, .05,.3);\n    vec4 body     = vec4(.8, .8, .8,.4);\n   \n    float dirt1 = smoothstep(-.1, .5,boxMap(iChannel1,p, nor))*.25+.75;\n    mat = body*dirt1;\n  \n    float d = sphere(p+vec3(0,0,.5), 8.9);\n    float d2;\n    d = max(d, roundedBox(p, vec3(6., 12, 11.0), .72)); \n    if (d < .0 || p.z > 14.5)\n    {\n        d = sphere(p-vec3(-3.3 , 1.8, -8.1), .9);\n        d2 = sphere(p-vec3(3.1 , 1.7, -8.1), .5);\n        \/\/ EyeCam...\n\t    if (d < 0.0)\n        {\n            mat = vec4(1., 0.03, 0.0, .7);\n            emitionType = 1;\n        }else\n\t\t\/\/ Scanner...\n       \tif (d2 < 0.0)\n       \t{\n            d2 = d2 < -.015 ? max(-circle(mod(p.xy-vec2(3.185 , 1.78), .16)-.08, .085)*35.0, 0.0): 1.0;\n\t\t\tmat = vec4(.2+scannerOn*.6, 0.2+scannerOn*.75, 0.2+scannerOn, .7*d2)*d2;\n            \n\t\t\temitionType = 2;\n      \t}\n        else\n\t        mat = numbers(gunMetal, p.xy);\n        \/\/ Do hex border line around numbers...\n        p = abs(p);\n        mat = p.x > p.y*.76 ? mix(mat, vec4(0.0), bumpstep(2.3, 2.4, p.x+p.y*.5)):mix(mat, vec4(0.0), bumpstep(1.82, 1.92, p.y));\n        return mat;\n    }\n\n     \/\/ Gun placements and carriers...\n    vec3 v = p;\n    \n   \t\/\/v.yz = rot2D(p.yz, gunMovement.x);\n\tv =abs(v)-vec3(gunMovement.x, .0, 0.) ;\n    v.x -= p.z*.1*gunMovement.y;\n\td2 = sphere(v, 10.0);\n    d2 = max(d2, -roundedBox(v, vec3(6.55, 12, 4.0), 1.1)); \n    \n    d = min(d2, d);\n    d2 = min(d,\troundedBox(v-vec3(5.5, 3.5, 3.5), vec3(2.3, .1, .1), .4));\n    \/\/d2 = min(d2,roundedBox(v-vec3(5.5, .0, 3.7), vec3(2.3, .1, .1), .4));\n    d2 = min(d2, sphere(v-vec3(5., .0, 3.7), 3.8));\n    if(d2 < d) mat = vec4(.0, .0, .0, 6.);\n    \/\/return mat;\n    \n    v = vec3(abs(p.x)-gunMovement.x, p.yz);\n    v.x -= p.z*.1*gunMovement.y;\n    float dirt = (smoothstep(-.1, .5,boxMap(iChannel1,v, nor))*.2+.8);\n    body = body * dirt;\n \n    v = vec3(abs(p.xy)-vec2(gunMovement.x, .0), p.z);\n    v.x -= p.z*.1*gunMovement.y;\n    \n    if ( v.x > 7.4)  mat =mix(body, gunMetal, smoothstep(2.5, 2.3, v.y))*dirt;\n    d2 =  roundedBox(v-vec3(8., 2.3, -10.5), vec3(.4, 1.6, 1.5), .2);\n    \/\/if ( d2 < 0.1)  mat = gunMetal*dirt;\n    mat= mix(mat, gunMetal*dirt, clamp(-d2*10.0, 0.0, 1.0));\n    \n    d =  sphere(p+ vec3(.0, 5.6, -6.2), 3.2);\n    if ( d < 0.0)\n    {\n        mat = vec4(0);\n        emitionType = 3;\n    }\n\n    return mat;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat shadow( in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = .2;\n    for (int i = 0; i < 12; i++)\n\t{\n\t\tfloat h = mapDE( ro + rd*t );\n        if (h< -2.) break;\n\t\tres = min(10.*h \/ t, res);\n\t\tt += h+.2;\n\t}\n    return max(res, .3);\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat SphereRadius(in float t)\n{\n    t = t*.003+.01;\n\treturn min(t,256.0\/iResolution.x);\n}\n\n\/\/----------------------------------------------------------------------------------------\nvoid rayMarch(vec3 pos, vec3 dir)\n{\n    \/\/ Efficiently start the ray just in front of the drone...\n    float l = max(length(drone-pos)-14.2, .0);\n    float d =  l;\n    l+=23.;\/\/ ...and end it just after\n    int hits = 0;\n\t\/\/ Collect 4 of the closest scrapes on the tracing sphere...\n    for (int i = 0; i < 55; i++)\n    {\n        \/\/ Leave if it's gone past the drone or when it's found 7 stacks points...\n        if(d > l || hits == 6) break;\n        vec3 p = pos + dir * (d);\n\t\tfloat r= SphereRadius(d);\n\t\tfloat de = mapDE(p);\n        \/\/ Only store the closest ones (roughly), which means we don't\n        \/\/ have to render the 8 stack points, just the most relavent ones.\n        \/\/ This also prevents the banding seen when using small stacks.\n        if(de < r &&  de < eStack.x)\n        {\n            \/\/ Rotate the stack and insert new value!...\n\t\t\tdStack = dStack.wxyz; dStack.x = d; \n            eStack = eStack.wxyz; eStack.x = de;\n\t\t\thits++;    \n        }\n\t\td +=de*.9;\n    }\n    return;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 normal( in vec3 pos, in float r )\n{\n\tvec2 eps = vec2( r*1., 0.0);\n\tvec3 nor = vec3(\n\t    mapDE(pos+eps.xyy) - mapDE(pos-eps.xyy),\n\t    mapDE(pos+eps.yxy) - mapDE(pos-eps.yxy),\n\t    mapDE(pos+eps.yyx) - mapDE(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat terrain( in vec2 q )\n{\n    q *= .5;\n    q += 4.;\n\tfloat h = smoothstep( 0., 0.7, texture2D( iChannel1, 0.023*q,  -99.0).x )*6.0;\n    h +=  smoothstep( 0., 0.7, texture2D( iChannel2, 0.03*q, -99.0 ).y )*3.0;\n    \/\/h +=  smoothstep( 0., 1., texture2D( iChannel1, .01*q, 00.0 ).y )*1.0;\n    return h;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 skyUpper(in vec3 rd)\n{\n    vec3  sky;\n    float f = pow(max(rd.y, 0.0), .5);\n    sky = mix(vec3(.45, .5, .6), vec3(.7, .7, .7), f);\n    float sunAmount = pow(max( dot( rd, sunDir), 0.0 ), 8.0);\n    sky = sky + sunCol * sunAmount*.5;\n    rd.xz = rd.zx;rd.y-=.05;\n    sky -= (vec3(.65, .67, .75)-cubeMap(iChannel3, rd, 64.0).xyz)*.5;\n\n\treturn clamp(sky, 0.0, 1.0);\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 fogIt(in vec3 col, in vec3 sky, in float d)\n{\n    return mix (col, sky, clamp(1.0-exp(-d*0.001), 0.0, 1.0));\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 ground(vec3 sky, in vec3 rd, in vec3 pos)\n{\n  \n    if (rd.y > .0) return sky;\n \n\tfloat d = (-20.0-pos.y)\/rd.y;\n\tvec2 p = pos.xz+rd.xz * d;\n    \n\tvec3 tex1 = texture2D(iChannel1, p*.1).xyz;\n\tvec3 tex2 = texture2D(iChannel2, p*.0004).yyx*vec3(1.0, .8, .8);\n\n\tvec3 gro  = vec3(1.);\n    \n    d-=20.0;\n\tfloat a = .0004*d*d;\n        \n\tvec3 nor  \t= vec3(0.0,\t\t    terrain(p), 0.0);\n\tvec3 v2\t\t= nor - vec3(a,\t\tterrain(p+vec2(a, 0.0)), 0.0);\n\tvec3 v3\t\t= nor - vec3(0.0,\t\tterrain(p+vec2(0.0, a)), -a);\n\tnor = cross(v2, v3);\n\tnor = normalize(nor);\n\tgro = mix(tex1, tex2, nor.y*.8);\n\tfloat sha = shadow(vec3(p.x, 0.0, p.y),  sunDir);\n\tfloat z =max(dot(nor, sunDir), 0.1);\n    if (dStack[0] < 0.0) dStack[0]= d;\n    vec3 col = gro*z*sha;\n\n\treturn col = fogIt(col, sky, d);\n}\n\n\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ This is also used for the camera's delayed follow routine.\n\/\/ Which make the scene more dramitic because it's a human camera operator!\nvec3 dronePath(float ti)\n{\n    vec3 p = vec3(-2030, 500, 2400.0);\n    p = mix(p, vec3(-2030, 500, 2000.0),\t \tsmoothstep(cueINCLOUDS, cueFLYIN, ti));\n    p = mix(p, vec3(-30.0, 18.0, 300.0),\t\tsmoothstep(cueFLYIN, cueFLYIN+4.0, ti));\n    p = mix(p, vec3(-35.0, 25.0, 10.0), \t\tsmoothstep(cueFLYIN+2.0,cueFLYIN+8.0, ti));\n    p = mix(p, vec3(30.0, 0.0, 15.0), \t\t\tsmoothstep(cueFRONTOF+.5,cueFRONTOF+2.5, ti)); \/\/..\/ Move to front of cam.\n    \n    p = mix(p, vec3(0.0, 8.0, .0), \t\t\t\tsmoothstep(cueTHREAT, cueTHREAT+.5, ti)); \t\/\/ ...Threaten\n    p = mix(p, vec3(0.0, 8.0, -4.0), \t\t\tsmoothstep(cueTHREAT+2.0, cueTHREAT+2.3, ti)); \t\/\/ ...Threaten\n    p = mix(p, vec3(0.0, 8., -12.0), \t\t\tsmoothstep(cueTHREAT+3.0, cueTHREAT+3.3, ti)); \t\/\/ ...Threaten\n    \n    p = mix(p, vec3(0.0, 110.0, 0.0), \t\t\tsmoothstep(cueFLYOFF,cueFLYOFF+1.5, ti)); \/\/ ...Fly off\n    p = mix(p, vec3(4000.0, 110.0, -4000.0), \tsmoothstep(cueFLYOFF+2.6,cueFLYOFF+10.0, ti)); \n    return p; \n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 droneRotations(float ti)\n{\n    vec3 a = vec3(0);\n    \n    \n   \ta.x = mix(a.x, .2, smoothstep(cueFLYIN-3.0,cueFLYIN-1.5, ti));\n    a.x = mix(a.x, .0, smoothstep(cueFLYIN-1.5,cueFLYIN, ti));\n\n    a.y = mix(a.y, -.8,smoothstep(cueFLYIN-1.5,cueFLYIN, ti));\n\n    a.x = mix(a.x, .2,smoothstep(cueFLYIN+2.0,cueFLYIN+4.0, ti));\n    a.x = mix(a.x, 0.,smoothstep(cueFLYIN+4.0,cueFLYIN+6., ti));\n\n\ta.y = mix(a.y, 0.0, smoothstep(cueFLYIN+3.0,cueFLYIN+4.4, ti));\n    a.x = mix(a.x, .1,smoothstep(cueFLYIN+7.0,cueFLYIN+7.8, ti));\n    a.x = mix(a.x, 0.,smoothstep(cueFLYIN+7.8,cueFLYIN+8.3, ti));\n    \n\ta.y = mix(a.y, -1.5,smoothstep(cueFRONTOF,cueFRONTOF+.5, ti));\/\/ ..Turn to go right, infront\n\ta.y = mix(a.y, .6, \tsmoothstep(cueFRONTOF+3.,cueFRONTOF+4.5, ti));\n\n    a.y = mix(a.y, .0,  smoothstep(cueTHREAT,cueTHREAT+.5, ti));\n\n    a.x = mix(a.x, -.28,smoothstep(cueTHREAT, cueTHREAT+.3, ti)); \/\/ ...Threaten\n    \n    a.x = mix(a.x, 0.0, smoothstep(cueFLYOFF-2.0, cueFLYOFF, ti)); \/\/ Normalise position, relax!\n    a.x = mix(a.x, -0.5,smoothstep(cueFLYOFF, cueFLYOFF+.2, ti)); \t\/\/ ...Fly off\n    a.x = mix(a.x, 0.0, smoothstep(cueFLYOFF+.2, cueFLYOFF+.7, ti));\n    \n    a.y = mix(a.y, -.78,smoothstep(cueFLYOFF+2., cueFLYOFF+2.3, ti)); \n    \n    scannerOn = smoothstep(cueTHREAT+4.0,cueTHREAT+4.2, ti)* smoothstep(cueTHREAT+11.5,cueTHREAT+11.2, ti);\n    a.z = sin(ti*2.) * scannerOn;\n\n    return a;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec2 droneGunAni(float ti)\n{\n    vec2 a;\n   \tfloat mov = smoothstep(cueTHREAT+.5, cueTHREAT+1.5, ti);\n    mov = mov * smoothstep(cueFLYOFF-1., cueFLYOFF-3.0, ti);\n    mov = mov*3.1-1.4;\n    a.x = (sin(mov)+1.0)*1.5;\n    a.y = smoothstep(.3,.7,sin(mov))*3.0;\n    return a;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 cameraAni(float ti)\n{\n    vec3 p;\n    p = mix(drone-vec3(0.0,0.0, 10.0), drone-vec3(0.0,0.0, 20.0), smoothstep(cueINCLOUDS,cueINCLOUDS+2.0, ti));\n    p = mix(p, drone-vec3(17.0,-14.0, 35.0), smoothstep(cueINCLOUDS+2.0,cueFLYIN-3.0, ti));\n\n    p = mix(p, vec3(0.0, 0.0, -28.0), step(cueFLYIN, ti));\n\tp = vec3(p.xy, mix(p.z, -40.0, smoothstep(cueTHREAT,cueTHREAT+4.0, ti)));\n    return p;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat overlay(vec3 p, vec3 dir)\n{\n    float r = 0.0;\n    vec3 pos = drone.xyz+vec3(3.25, -.48, -8.0);\n    vec3 v = p-pos;\n    vec3 n = vec3(0.0, 1., 0.0);\n    n.zy = rot2D(n.zy, droneRots.z);\n    n = normalize(n);\n    float d = -dot(n, v)\/ dot(n, dir);\n    p = p + dir*d-pos;\n\n    if (p.z < .0 && p.z > -20.)\n    {\n        float d = abs(p.z) - abs(p.x)+.4;\n        r = step(.3, d)*.3;\n        r += smoothstep(-.3, -.2,p.x) * smoothstep(0., -.2, p.x)*r;\n        r += smoothstep(.3, .2,p.x) * smoothstep(0.0, .2, p.x)*r;\n        r += smoothstep(0.1, .2, d) * smoothstep(0.4, .2, d);\n    }\n    r += smoothstep(0.3, 0.0,abs(droneRots.z-.4))*1.5;\n\n    return r;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvoid heatHaze(vec3 p, inout vec3 dir, float t)\n{\n    if (t < cueFLYIN) return;\n    float r = 0.0;\n    vec3 pos = vec3(0.0, -4.8, 7.);\n    if (drone.y < 20.0)\n    \tpos.y += smoothstep(-.90, .5,droneRots.y)*smoothstep(.9, 0.5,droneRots.y)*-8.0;\n    pos.zx = rot2D(pos.zx, droneRots.y);\n    pos += drone.xyz;\n    vec3 v = p-pos;\n    vec3 n = vec3(0.0, 0., 1.0);\n\n    n = normalize(n);\n    float d = -dot(n, v)\/ dot(n, dir);\n    p = p + dir*d-pos;\n\n    if (p.y < .0 && p.y > -30.)\n    {\n        float l = abs(p.y) - abs(p.x*(1.1))+8.0;\n        r = smoothstep(.0, 14., l);\n        \/\/p.xy *= vec2(.5,.9);\n        t*= 23.0;\n        dir += r*(noise(p.xy*.8+vec2(0.0,t))-.5)*.001\/(.07+(smoothstep(10.0, 2500.0, d)*20.0));\n    }\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 cameraLookAt(in vec2 uv, in vec3 pos, in vec3 target, in float roll)\n{    \n\tvec3 cw = normalize(target-pos);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n\treturn normalize(-uv.x*cu + uv.y*cv +2.*cw );\n}\n\n\/\/----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 outColour, in vec2 coords )\n{\n\tvec2 xy = coords.xy \/ iResolution.xy;\n    vec2 uv = (xy-.5)*vec2( iResolution.x \/ iResolution.y, 1)*2.0;\n     \/\/ Multiply this time to speed up playback, but remember to do the sound as well!\n  \tfloat ti = mod(iGlobalTime, 57.);\n    \/\/float ti = mod(iGlobalTime, 5.)+cueFRONTOF;\t\/\/ ...Test cues..\n    \/\/float ti = mod(iGlobalTime, 15.0)+cueTHREAT+1.0;\n    \/\/float ti = mod(iGlobalTime, 5.)+cueFLYIN;\n    \/\/float ti = mod(iGlobalTime, 5.)+cueFLYOFF;\n\t\n    \/\/---------------------------------------------------------\n    \/\/ Animations...\n\tdrone = dronePath(ti);\n    droneRots = droneRotations(ti);\n    vec3 camPos = cameraAni(ti);\n    gunMovement = droneGunAni(ti);\n    float t = smoothstep(cueTHREAT, cueTHREAT+.5, ti) *smoothstep(cueTHREAT+15.5, cueTHREAT+14.7, ti);\n    \n    float e = -droneRots.y+t*texture2D(iChannel0, vec2(.3, ti*.02)).x*.25-.22;\n    e += texture2D(iChannel0, vec2(.4, ti*.005)).x*.5-.35;\n    vec3 eyeCam = normalize(vec3(0.3, -.4*t,  -1.0));\n    eyeCam.xz = rot2D(eyeCam.xz, e);\n    \n\t\/\/---------------------------------------------------------\n\tvec3 tar = dronePath(ti-.25);\n    \/\/ Cameraman gets shaky when the drone is close...oh no...\n    float l = 30.0 \/ length(tar-camPos);\n    tar += (noise3(ti*4.0)-.5)*l;\n    vec3 dir = cameraLookAt(uv, camPos, tar, 0.0);\n\t\n    \n    heatHaze(camPos, dir, ti);\n    \/\/--------------------------------------------------------\n    \/\/ Reset and fill the render stack through ray marching...\n    dStack = vec4(-1);\n    eStack = vec4(1000.0);\n    rayMarch(camPos, dir);\n\n    \/\/---------------------------------------------------------\n\t\/\/ Use the last stacked value to do the shadow, seems to be OK, phew!...\n    float lg = dStack[0];\n\tvec3 p = camPos + dir * lg;\n    float sha = shadow(p, sunDir);\n    vec3 sky = skyUpper(dir);\n\t\/\/---------------------------------------------------------\n\t\/\/ Render the stack...\n    float alphaAcc = .0;\n    vec3 col = vec3(0);\n    float spe;\n    for (int i = 0; i < 4; i++)\n    {\n        float d = dStack[i];\n\t\tif (d < 0.0) continue;\n        float de = eStack[i];\n        float s = SphereRadius(d);\n        float alpha = max((1.0 - alphaAcc) * min(((s-de) \/ s), 1.0),0.0);\n\t\t\n\t\tvec3 p = camPos + dir * d;\n\t\tvec3  nor = normal(p, s);\n\t\tvec4  mat = mapCE(p, nor);\n\t\tfloat amb = abs(nor.y)*.6; amb = amb*amb;\n\t\tvec3 c= mat.xyz * vec3(max(dot(sunDir, nor), 0.0))+ amb * mat.xyz;\n\t\tspe = pow(max(dot(sunDir, reflect(dir, nor)), 0.0), 18.0);\n            \n\t\tif (emitionType != 0)\n\t\t{\n\t\t\tif (emitionType == 1)\n\t\t\t{\n\t\t\t\ts = cos(pow(max(dot(eyeCam, nor), 0.0), 4.4)*9.0)*.14;\n\t\t\t\ts += pow(abs(dot(eyeCam, nor)), 80.)*18.0;\n\t\t\t\tc*= max(s, 0.0);\n\t        }\n            if (emitionType == 3)\n\t\t\t{\n                vec3 dp = p - drone;\n\t\t\t\ts = smoothstep(.0,-.1, nor.y) * smoothstep(-1.0,-.3, nor.y);\n\t\t\t\tc = vec3((smoothstep(-5.8,-5., dp.y) * smoothstep(-4.8,-5., dp.y))*.1);\n                float g = abs(sin((atan(nor.x, -nor.z))*TAU+ti*33.0))+.2;\n\t\t\t\tc += s*(texture2D(iChannel2, p.xy*vec2(.04, .01)+vec2(0.0, ti)).xyy)*vec3(1.5, 2.3,3.5)*g;\n        \t\t\n                alpha *= smoothstep(-9.,-4.5, dp.y) - g * smoothstep(-4.5,-10., dp.y)*.2;\n                \n            }          \n\n\t\t\tsha = 1.0;\n\t\t}\n        \n        c += sunCol * spe * mat.w;\n        \n        \n        col += c = fogIt(c *sha, sky, d)* alpha;\n        alphaAcc+= alpha;\n     }\n    \n\t\/\/---------------------------------------------------------\n    \/\/ Back drop...\n    \n    vec3 gro = ground(sky, dir, camPos);\n\t\n    col = mix(col, gro, clamp(1.0-alphaAcc, 0.0, 1.0));\n    \n    \n    if (dStack[0] < 0.0) dStack[0] = 4000.0;\n    col = clouds(col,camPos, dir, dStack[0], ti);\n    \n        \/\/ Overlay...\n    float scan = overlay(camPos, dir)*scannerOn;\n\tcol = min(col+vec3(scan*.6, scan*.75, scan), 1.0);\n\n    \n    \n\t\/\/---------------------------------------------------------\n\t\/\/ Post effects...\n    col = col*0.5 + 0.5*col*col*(3.0-2.0*col);\t\t\t\t\t\/\/ Slight contrast adjust\n    col = sqrt(col);\t\t\t\t\t\t\t\t\t\t\t\/\/ Adjust Gamma \n    \/\/ I can't decide if I like the added noise or not...\n    \/\/col = clamp(col+hash32(xy+ti)*.11, 0.0, 1.0); \t\t\t\t\t\/\/ Random film noise\n\n    \n    col *= .6+0.4*pow(50.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.2 );\t\/\/ Vignette\n    col *= smoothstep(0.0, .5, ti)*smoothstep(58.0, 53., ti);\n\toutColour = vec4(col,1.0);\n}\n","name":"","description":"","type":"image"},{"inputs":[{"id":10,"src":"\/presets\/tex09.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ [SIG15] Oblivion [sound code]\n\/\/ by David Hoskins.\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ The sound includes a vocoded 'aaah' and \"Tech 4-9, Jack Harper\" with formants collected straight from the film.\n\/\/ Speech coefficients created using Wavesurfer:\n\/\/ http:\/\/sourceforge.net\/projects\/wavesurfer\/\n\n\n#define TWO_PI \t\t\t6.2831\n#define MOD2 vec2(.16632,.17369)\n#define MOD3 vec3(.16532,.17369,.15787)\n#define PLAY_PHRASES\n\n#define cueINCLOUDS 0.0\n#define cueFLYIN 14.0\n#define cueFRONTOF cueFLYIN + 10.0\n#define cueTHREAT cueFRONTOF + 5.\n#define cueFLYOFF cueTHREAT + 19.0\n\nfloat n1 = 0.0;\nfloat n2 = 0.0;\nfloat fb_lp = 0.0;\nfloat lfb_lp = 0.0;\nfloat hp = 0.0;\nfloat p4=1.0e-24;\nfloat sample = 1.0 \/ iSampleRate;\nvec3 drone;\nfloat gTime;\nfloat speed, height;\n\n#define TAU  6.28318530718\n#define NT(a, b, c) if(t > a){x = a; n = b; ty = c;}\n#define P(a, b, c, d, e, f) if(t >= sec){x = sec; pit = ivec2(a, b), form = ivec4(c, d, e, f);} if(t+step >= sec){pit2 = ivec2(a, b),  form2 = ivec4(c, d, e, f);} sec+=step;\n\n\n#define N(a, b) if(t > a){x = a; n = b;}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  1 out, 1 in ...\nfloat hash11(float p)\n{\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);\n}\n\n\/\/----------------------------------------------------------------------------------\nfloat tract(float x, float f, float bandwidth)\n{\n    float ret = sin(TAU * f * x) * exp(-bandwidth * 3.14159265359 * x);\n    return ret;\n}\n\n\/\/----------------------------------------------------------------------------------\nfloat noise11(float x)\n{\n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix( hash11(p), hash11(p + 1.0), f)-.5;\n}\n\n\/\/----------------------------------------------------------------------------------\nfloat Fricative(float x, float f)\n{\n    float ret = hash11(floor(f * x)*20.0)-.5;\n\treturn ret*3.0;\n}\n\n\n\/\/----------------------------------------------------------------------------------\nfloat noteMIDI(float n)\n{\n\treturn 440.0 * pow(2.0, (n - 69.0) \/ 12.0);\n}\n\n\/\/----------------------------------------------------------------------------------\nfloat saw( float x, float a)\n{\n    float f = fract( x );\n\treturn (clamp(f\/a,0.0,1.0)-clamp((f-a)\/(1.0-a),0.0,1.0))*2.0-.5;\n}\n\n\/\/----------------------------------------------------------------------------------\nfloat sqr(float t)\n{\n\treturn step(fract(t), 0.5)-0.5;\n}\n\n\/\/----------------------------------------------------------------------------------\nfloat tri(float t)\n{\n\treturn (abs(fract(t)-0.5)*2.-0.5)*2.;\n}\n\n\/\/----------------------------------------------------------------------------------\nfloat sine(float t)\n{\n\treturn sin(t* 3.141*2.0);\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat softBeep(float t)\n{\n\tfloat n = 0.0;\n    float x = 0.0;\n    float ty = 0.0;\n \n    \/\/NT(cueFRONTOF-4.0, 61., .2);\n    NT(cueFRONTOF-4.0,56., .5);\n    \n    NT(cueFRONTOF+.7, 56., .4);\n    NT(cueFRONTOF+1., 61., .5);\n    \n    float asr = cueFLYOFF-.9;\n    NT(asr+.7, 69.0, .5);\n\n    n = noteMIDI(n);\n    \n    x = t-x;\n    \n\tfloat aud = 0.0;\n      \n    float vol = smoothstep(.0, .05, x) * smoothstep(1.0, .8, x\/ty);\n    aud += sine(x*n*2.0+t)*sine(x*n*.9+t)*smoothstep(0.0, .04, t)*vol*.3;\n    aud = clamp(aud*.9,-1., 1.);\n\n    return aud;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat beeDoop(float t)\n{\n\tfloat n = 0.0;\n    float x = 0.0;\n    float ty = 0.0;\n    \n    NT(cueTHREAT-1.0, 63.0, .14);\n    NT(cueTHREAT-1.0+.14, 51.0, .55);\n\n    NT(cueTHREAT+3.2, 63.0, .14);\n    NT(cueTHREAT+3.2+.14, 51.0, .55);\n\n    n = noteMIDI(n);\n    \n    x = t-x;\n    \n\tfloat aud = 0.0;\n    float vol = smoothstep(.0, .01, x) * smoothstep(1.0, .7, x\/ty);\n    aud = tri(x*n*4.0) * tri(x*n*.5) * sine(x*n*2.)*vol;\n    aud += sine(x*n*2.0+t)*smoothstep(0.0, .04, t)*vol*.3;\n    aud = clamp(aud*.7,-1., 1.);\n\n    return aud;\n}\n\n \/\/----------------------------------------------------------------------------------------\n\/\/ Speech Processing Based on a Sinusoidal Model\n\/\/ For the vocal part I analylised a sample from the film and extracted\n\/\/ the vocal formants, which of course turned out to be an 'aaaah!' :)\n\/\/ https:\/\/www.ll.mit.edu\/publications\/journal\/pdf\/vol01_no2\/1.2.3.speechprocessing.pdf\nfloat aaaah(float t)\n{\n\tfloat n = 0.0;\n    float x = 0.0;\n    float ty = 0.0;\n    \/\/t=  mod(t, 2.0)+cueTHREAT;\n    NT(cueTHREAT, 52., 1.1);\n    NT(cueFLYOFF+2.0, 52., 3.1);\n    \n    n = noteMIDI(n);\n    x = t-x;\n    float vol= smoothstep(.0, .03, x) * smoothstep(1.0, .9, x\/ty)*.5;\n    float pit = smoothstep(.0, .8, x) * smoothstep(1.0, .9, x\/ty);\n    float formSlide = (smoothstep(.3, .0, x) + smoothstep(.8, 1., x\/ty)) * 100.0;\n    pit = pow(pit,.1);\n    pit = (1.0-pit*.001)\/n;\n    \n    t += noise11(x*7.+45.0)*.0008; \/\/ ...Add a bit of random flutter to humanise it.\n\n    \/\/ Build the vocal tract with sine waves...\n    x = mod(t, pit);\n\tfloat aud =\ttract(x, 710.0-formSlide, 70.0) *.5 +\n       \t\t\ttract(x, 1000.0+formSlide, 90.0)  * .6 +\n\t       \t\ttract(x, 2450.0+formSlide, 140.0) * .4;\n   \t    \n    aud = clamp(aud * vol, -1.0, 1.0);\n    return aud;\n}\nfloat tech49(float t)\n{\n    \/\/t = mod(t, 7.0)+ cueTHREAT+4.5; \/\/ ...test\n    float step = .013;\n    float vol = .45;\n    float adjust = 1.0;\n    float sec = cueTHREAT+4.5;\n    if (t > cueTHREAT+6.5 && t < cueTHREAT+13.5)\n    {\n        t-=3.0;\n        vol = .7;\n        step = 0.023;\n        adjust = 1.18;\n    }\n    \n    ivec4 form = ivec4(271,2104,3152,4600), form2 = form;\n    ivec2 pit = ivec2(0\t,0), pit2 = pit;\n    float x = .0;\n\n\t\/\/ Pitch, intensity and formants for...\n    \/\/ \"Tech 4-9, Jack Harper\"\n    \/\/ Uses the output from free software called WaveSurfer:-\n    \/\/ http:\/\/sourceforge.net\/projects\/wavesurfer\/\n    \n    \/\/ It's still a little rough between the frames, but it's getting there.\n    \n    \/\/ I needed to hand edit some of these bastards!...\n   \n    \/\/ Pitch or fricative(0) , gain, f1, f2, f3, f4\n    P(0\t,42,\t271,\t2104,\t3152,\t4600);\n    P(0\t,30,\t515,\t1568,\t2589,\t3820);\n    P(0\t,20,\t650,\t1955,\t2644,\t3900);\n    P(154\t,40\t,650    ,1663,\t 2644\t,3900);\n    P(164\t,46\t,557\t,1663\t,2540\t,3532);\n    P(178\t,44\t,576\t,1641\t,2465\t,3399);\n    P(179\t,53\t,604\t,1677\t,2439\t,3368);\n    P(180\t,58\t,610\t,1751\t,2352\t,3272);\n    P(181\t,57\t,594\t,1805\t,2327\t,3211);\n    P(183\t,58\t,573\t,1847\t,2267\t,3195);\n    P(186\t,59\t,554\t,1594\t,1999\t,3120);\n    P(186\t,57\t,534\t,1611\t,1981\t,3097);\n    P(185\t,58\t,512\t,1762\t,1902\t,3205);\n    P(184\t,56\t,429\t,1848\t,2489\t,4087);\n    P(0\t,12\t,350,1600,1900,3900\t );\n    P(0\t,40\t,350,1600,1900,3900\t );\n    P(0\t,30\t,300,1950,2800,4400\t );\n    P(0\t,23\t,300,1950,2800,4400\t\t );\n    P(0\t,17\t,300,1950,2800,4400\t\t );\n    P(0\t,0\t,755\t,1825\t,2511\t,4083\t );\n    P(0\t,0\t,440\t,1811\t,2529\t,4099\t );\n    P(0\t,17\t,287\t,1223\t,2455\t,3977\t );\n    P(0\t,28\t,280\t,1259\t,2338\t,3707\t );\n    P(0\t,32\t,281\t,1288\t,2345\t,3719\t );\n    P(0\t,34\t,281, 1294, 2361,4166\t );\n    P(0\t,35\t,281, 1294, 2361,4166\t );\n    P(0\t,45\t,281, 1294, 2361,4166\t );\n    P(207\t,42\t,487\t,934\t,1791\t,3100);\n    P(214\t,48\t,489\t,993\t,1858\t,3159);\n    P(220\t,55\t,489\t,1005\t,1925\t,3233);\n    P(221\t,58\t,487\t,1014\t,1942\t,3252);\n    P(220\t,57\t,483\t,1038\t,1950\t,3234);\n    P(224\t,56\t,486\t,1057\t,1985\t,3227);\n    P(223\t,56\t,491\t,1058\t,1996\t,3205);\n    P(222\t,56\t,494\t,1078\t,2007\t,3101);\n    P(222\t,56\t,495\t,1320\t,2480\t,3186);\n    P(220\t,56\t,481\t,1523\t,2554\t,3497);\n    P(221\t,55\t,464\t,1539\t,2580\t,3525);\n    P(221\t,55\t,460\t,1547\t,2629\t,3550);\n    P(220\t,50\t,463\t,1562\t,2551\t,3523);\n    P(219\t,37\t,474\t,1573\t,2494\t,3562);\n    P(219\t,35\t,501\t,1604\t,2513\t,3596);\n    P(219\t,40\t,555\t,1650\t,2501\t,3624);\n    P(226\t,45\t,625\t,1598\t,2486\t,3676);\n    P(226\t,57\t,655\t,1562\t,2462\t,3752);\n    P(227\t,57\t,667\t,1552\t,2410\t,3852);\n    P(227\t,58\t,674\t,1552\t,2390\t,3900);\n    P(225\t,57\t,679\t,1549\t,2402\t,3900);\n    P(225\t,58\t,681\t,1537\t,2425\t,3877);\n    P(227\t,57\t,677\t,1513\t,2448\t,3850);\n    P(227\t,56\t,667\t,1504\t,2410\t,3823);\n    P(229\t,58\t,659\t,1536\t,2346\t,3766);\n    P(229\t,58\t,640\t,1604\t,2318\t,3611);\n    P(231\t,57\t,589\t,1791\t,2333\t,3433);\n    P(229\t,55\t,518\t,1852\t,2396\t,4156);\n    P(229\t,57\t,468\t,1907\t,2497\t,4151);\n    P(227\t,56\t,440\t,1973\t,2564\t,4113);\n    P(221\t,54\t,423\t,1970\t,2576\t,4053);\n    P(178\t,54\t,400\t,1857\t,2517\t,4033);\n    P(205\t,44\t,425\t,1690\t,2231\t,3986);\n    P(175\t,32\t,418\t,1566\t,2124\t,3959);\n    P(172\t,38\t,384\t,1569\t,2307\t,3983);\n    P(165\t,47\t,455\t,1783\t,2630\t,3942);\n    P(0,    0, 0, 0, 0, 0);\n    P(0,    0, 0, 0, 0, 0);\n    P(0,    0, 0, 0, 0, 0);\n    P(0,    0, 0, 0, 0, 0);\n\n    P(0,    0, 0, 0, 0, 0);\n    P(0,    20,480\t,1840\t,2697\t,3859);\n    P(177,  40,\t174,1914,3509,3900);\n    P(0\t,   34,\t174,1914,3509,3900);\n    P(0\t,\t25,\t174,\t1914,\t2609,3900);\n    P(0\t,\t 10\t,405\t,1843\t,2603\t,3851);\n    P(177\t,46\t,445\t,1807\t,2487\t,2996);\n    P(200\t,47\t,472\t,1780\t,2465\t,3037);\n    P(219\t,48\t,509\t,1755\t,2454\t,3096);\n    P(227\t,54\t,614\t,1746\t,2435\t,3143);\n    P(227\t,56\t,658\t,1747\t,2421\t,3163);\n    P(220\t,53\t,661\t,1747\t,2409\t,3153);\n    P(222\t,53\t,662\t,1732\t,2365\t,3132);\n    P(220\t,57\t,662\t,1730\t,2426\t,3162);\n    P(219\t,59\t,659\t,1739\t,2506\t,3271);\n    P(217\t,59\t,652\t,1732\t,2440\t,3288);\n    P(216\t,58\t,635\t,1728\t,2347\t,3236);\n    P(215\t,57\t,609\t,1748\t,2277\t,3221);\n    P(209\t,57\t,585\t,1798\t,2202\t,3301);\n    P(205\t,57\t,547\t,1860\t,2126\t,3292);\n    P(200\t,56\t,367\t,1952\t,3296\t,4100);\n    P(178\t,44\t,282\t,1943\t,3417\t,4117);\n    P(0\t,03\t,322\t,1959\t,2548\t,4132\t );\n    P(0\t,27\t,409\t,1826\t,2560\t,4125\t );\n    P(0\t,0\t,331,1761,2488,3921\t );\n    P(0\t,0\t,331,1761,2488,3921\t );\n    P(0\t,30\t,331,1761,2488,3921\t );\n    P(0\t,38\t,331,1761,2488,3921\t );\n    P(0\t,40\t,331,1761,2488,3921\t );\n    P(189\t,35\t,600\t,1300\t,2020\t,3912);\n    P(193\t,44\t,621\t,1290\t,2070\t,3972);\n    P(201\t,50\t,636\t,1203\t,2070\t,4011);\n    P(208\t,53\t,643\t,1097\t,2004\t,4119);\n    P(217\t,54\t,644\t,1084\t,1987\t,4227);\n    P(220\t,55\t,642\t,1095\t,2109\t,4224);\n    P(217\t,57\t,642\t,1115\t,2067\t,4193);\n    P(215\t,54\t,643\t,1120\t,1923\t,4078);\n    P(214\t,54\t,647\t,1138\t,1842\t,3808);\n    P(216\t,56\t,650\t,1169\t,1801\t,3762);\n    P(218\t,56\t,652\t,1237\t,1790\t,3768);\n    P(220\t,55\t,648\t,1275\t,1784\t,3763);\n    P(223\t,53\t,621\t,1256\t,1763\t,3629);\n    P(225\t,50\t,533\t,1123\t,1636\t,3516);\n    P(222\t,52\t,386\t,1006\t,1563\t,3361);\n    P(192\t,48\t,255\t,1203\t,2528\t,3211);\n    P(183\t,35\t,304\t,1151\t,2209\t,3086);\n    P(156\t,29\t,303\t,841\t,1900\t,2698);\n    P(154\t,7\t,260\t,895\t,1884\t,2635);\n    P(168\t,8\t,217\t,957\t,2642\t,3825);\n    P(0  \t,38\t,254\t,980\t,1873\t,2688);\n    P(148\t,28\t,338\t,1142\t,1659\t,3780);\n    P(143\t,26\t,436\t,1171\t,1594\t,3789);\n    P(179\t,25\t,464\t,1191\t,1585\t,3822);\n    P(162\t,31\t,465\t,1211\t,1574\t,3756);\n    P(231\t,44\t,462\t,1235\t,1567\t,3678);\n    P(229\t,53\t,461\t,1252\t,1557\t,3670);\n    P(229\t,53\t,461\t,1252\t,1557\t,3670);\n    P(226\t,52\t,459\t,1273\t,1548\t,3658);\n    P(224\t,57\t,468\t,1300\t,1597\t,3665);\n    P(222\t,56\t,492\t,1317\t,1605\t,3715);\n    P(217\t,52\t,492\t,1342\t,1587\t,3734);\n    P(209\t,49\t,444\t,1424\t,1612\t,3770);\n    P(198\t,46\t,399\t,1463\t,1755\t,2960);\n    P(179\t,38\t,303\t,1423\t,1831\t,2912);\n    P(0,    0, 0, 0, 0, 0);\n    P(0,    0, 0, 0, 0, 0);\n\n    x = t - x;\n    float sm = clamp(x\/step, 0.0,1.0);\n\n  \n    float aud = 0.0;\n    float fric = 0.0;\n    float intensity = pow(8.0, float(pit.y)\/19.0) * .001;\n    float intensity2 = pow(8.0, float(pit2.y)\/19.0) * .001;\n    \n    intensity = mix(intensity, intensity2, sm);\n    vec4 formants  = mix(vec4(form), vec4(form2), sm);\n    \n    if (pit.x > 0)\n    {\n\n  \t\tfloat p = 1.0\/(float(pit.x)*adjust);\n        if (pit2.x > 0)\n        {\n\t       \tfloat p2 = 1.0\/(float(pit2.x)*adjust);\n            p = max(mix(p, p2, sm), 0.);\n        }\n\n        float a = mod(x, p); \n\t\taud =\ttract(a, formants.x, 70.0) +\n      \t\t\ttract(a, formants.y, 90.0)  * .7 +\n\t       \t\ttract(a, formants.z, 140.0) * .6 + \n        \t\ttract(a, formants.w, 210.0) * .4;\n        aud *= intensity;\n    }\n    else\n    {\n         vec4 formants  = vec4(form);\n         fric += Fricative(t, formants.x) +\n      \t\t\tFricative(t, formants.y) +\n       \t\t\tFricative(t, formants.z)*1.8;\n        aud = fric*intensity*.25;\n    }\n  \n\n\taud = clamp(aud*vol, -1.0, 1.0);\n    \n    return aud;\n\n}\n\n\n\/\/----------------------------------------------------------------------------------------\nfloat beepPong(float t)\n{\n\tfloat n = 0.0, x = 0.0, ty = 0.0;\n    float asr = cueFLYOFF-4.;\n    \/\/t = mod(t, 3.0) + cueFLYOFF-3.5;\n    NT(asr, 93.0, .2);\n    NT(asr+0.1, 69.0, .3);\n    NT(asr+.3, 81.0, .55);\n    n = noteMIDI(n);\n    x = t-x;\n\tfloat aud = 0.0;\n    asr = min((t-asr)*18.0, 1.0);\n    float vol = smoothstep(.0, .002, x) * smoothstep(1.0, .1, x\/ty)*asr;\n    aud = sine(x*n)*vol;\n   \taud += sine(x*n*.99+t)*smoothstep(0.0, .04, t)*vol*.3;\n    aud = clamp(aud*.3,-1., 1.);\n\n    return aud;\/\/(1.5 * aud - 0.5 * aud * aud * aud);\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat boom(float t)\n{\n\tfloat n = 0.0, x = 0.0, ty = 0.0;\n    \/\/t = mod(t, 2.)+cueFLYOFF-.9;\n    float asr = cueFLYOFF-.9;\n\n    NT(asr+0.3, 33.0, .1);\n    NT(asr+.6, 29.0, .1);\n    NT(asr+.9, 26.0, .2);\n    \n    n = noteMIDI(n);\n    x = t-x;\n    \n\tfloat aud = 0.0;\n    float vol = smoothstep(.0, .002, x) * smoothstep(1.0, .9, x\/ty);\n    n-=x*50.0;\n    aud = tri(x*n);\n    aud += tri(x*n*2.0);\n    aud = clamp(aud*vol,-1., 1.);\n\n    return (1.5 * aud - 0.5 * aud * aud * aud)*.7;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat scanner(float t)\n{\n    float n = noteMIDI(21.0);\n     float   scannerOn = smoothstep(cueTHREAT+4.0,cueTHREAT+4.2, t)* smoothstep(cueTHREAT+11.5,cueTHREAT+11.2, t);\n    float r = sin(t*2.) * scannerOn;\n    float vol= (smoothstep(0.4, 0.0,abs(r-.4))+.2) * scannerOn;\n\tfloat b = abs(sin(t*8.0))*.3;\n    \n    float aud = (saw(t*n*2.0, 1.)+saw(t*n*2.1, 1.))*.2;\n    aud += saw(t*n*4.0, .6+b)+saw(t*n*4.01, .6+b);\n    aud = clamp(aud*vol,-1., 1.);\n    return aud;\/\/(1.5 * aud - 0.5 * aud * aud * aud);\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec2 deepFuzz(float t)\n{\n\tfloat n = 0.0;\n    float x = 0.0;\n    float ty = 0.0;\n    \n    NT(cueFRONTOF-2.2, 28., .5);\n    NT(cueFRONTOF-1.2, 28., .5);\n\n    NT(cueTHREAT+1.2, 28., .5);\n    NT(cueTHREAT+2.2, 28., .5);\n    \n    NT(cueTHREAT+10.+1.2, 28., .5);\n    NT(cueTHREAT+10.+2.2, 28., 1.5);\n   \n    n = noteMIDI(n);\n    x = t-x;\n    \n    float vol= smoothstep(.0, .0, x) * smoothstep(1.0, .98, x\/ty);\n    \n    vol *= smoothstep(cueFRONTOF, cueFRONTOF+.2, t)*.9+.1;\n    float pit = 1.0+sqr(t*250.0)*.02;\n    vec2 aud = vec2(0.0);\n    aud.x += saw(t*n*pit, 1.)+saw(t*n*1.01*pit, 1.)+saw(t*n*4.0*pit, 1.);\n    aud.y += saw(t*n*pit, 1.)+saw(t*n*.99*pit, 1.)+saw(t*n*4.0*pit, 1.);\n    aud = clamp(aud * vol*.5, -1.0, 1.0);\n    return aud;\/\/(1.5 * aud - 0.5 * aud * aud * aud);\n}\n    \n\/\/----------------------------------------------------------------------------------------\nvec3 dronePath(float ti)\n{\n    vec3 p = vec3(-2030, 340, 2200.0);\n    p = mix(p, vec3(-2030, 340, 2000.0),\t\tsmoothstep(cueINCLOUDS, cueFLYIN-.5, ti));\n    p = mix(p, vec3(-30.0, 18.0, 300.0),\t\tsmoothstep(cueFLYIN, cueFLYIN+4.0, ti));\n    p = mix(p, vec3(-35.0, 25.0, 10.0), \t\tsmoothstep(cueFLYIN+4.0,cueFLYIN+8.0, ti));\n    p = mix(p, vec3(30.0, 0.0, 15.0), \t\t\tsmoothstep(cueFRONTOF+.5,cueFRONTOF+2.5, ti)); \/\/..\/ Move to front of cam.\n    p = mix(p, vec3(0.0, 8.0, .0), \t\t\t\tsmoothstep(cueTHREAT, cueTHREAT+.5, ti)); \t\/\/ ...Threaten\n    p = mix(p, vec3(0.0, 8.0, -4.0), \t\t\tsmoothstep(cueTHREAT+2.0, cueTHREAT+2.3, ti)); \t\/\/ ...Threaten\n    p = mix(p, vec3(0.0, 8., -12.0), \t\t\tsmoothstep(cueTHREAT+3.0, cueTHREAT+3.3, ti)); \t\/\/ ...Threaten\n    p = mix(p, vec3(0.0, 110.0, 0.0), \t\t\tsmoothstep(cueFLYOFF,cueFLYOFF+1.5, ti)); \/\/ ...Fly off\n    p = mix(p, vec3(4000.0, 110.0, -4000.0), \tsmoothstep(cueFLYOFF+2.6,cueFLYOFF+10.0, ti)); \n    return p; \n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 cameraAni(float ti)\n{\n    vec3 p;\n    p = mix(drone-vec3(0.0,0.0, 10.0), drone-vec3(0.0,0.0, 20.0), smoothstep(cueINCLOUDS,cueINCLOUDS+2.0, ti));\n    p = mix(p, drone-vec3(17.0,-14.0, 35.0), smoothstep(cueINCLOUDS+2.0,cueFLYIN-3.0, ti));\n    p = mix(p, vec3(0.0, 0.0, -28.0), step(cueFLYIN, ti));\n\tp = vec3(p.xy, mix(p.z, -40.0, smoothstep(cueTHREAT,cueTHREAT+4.0, ti)));\n    return p;\n}\n\n\n\/\/----------------------------------------------------------------------------------------\nfloat engines(float ti)\n{\n\tfloat  t = ti+ sin(height*.7)*.3+1.0;\n\tfloat t1 = texture2D(iChannel1, vec2(t*(2.44),t*11.33), -4.0).x *  .5-.25;\n\tt1 += texture2D(iChannel1, vec2(t*(2.44),t*1.33), -99.0).x -.5;\n    float t2 = texture2D(iChannel0, vec2(ti*13.81,ti*4.73), -4.0).x * .5-.25;\n    t2 += texture2D(iChannel0, vec2(ti*13.81,ti*14.54), -99.0).x * .08-.04;\n\tfloat f = mix(t1, t2, speed);\n\tf+= clamp((texture2D(iChannel1, vec2(ti*5.44,t*12.33), -99.0).x*2.0-1.) *(smoothstep(cueFLYOFF+.0, cueFLYOFF+2.8, ti))*4.0, -1.,1.);\n    f += (texture2D(iChannel0, vec2(ti*2.4413,ti*4.1375), -3.).x*2.0-1.);\n\treturn clamp(f*(speed+.5), -1.0, 1.0);\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec2 droneGunAni(float ti)\n{\n    vec2 a;\n   \tfloat mov;\n    mov = smoothstep(cueFLYOFF-1., cueFLYOFF-3.0, ti);\n    mov = mov*3.1-1.4;\n    a.x = (sin(mov)+1.0)*1.5;\n    a.y = smoothstep(.3,.7,sin(mov))*3.0;\n    return a;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec2 guns(float ti)\n{\n\tvec2 a;\n    vec2 ga = droneGunAni(ti);\n    a = texture2D(iChannel0, vec2(ga.x*14.4,ga.x*21.33), -99.0).xy-.5;\n    a -= texture2D(iChannel0, vec2(ga.x*14.4,ga.x*21.33), -3.0).xy-.5;\n    a *= .3;\n    a += texture2D(iChannel1, vec2(ga.y*1.44,ga.y*1.03), -99.0).xy*2.0-1.;\n    return a*.5;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec2 allsounds(float t)\n{\n    vec2 audio = vec2(0);\n\taudio = vec2(beeDoop(t));\n    audio += vec2(aaaah(t));\n    audio += vec2(deepFuzz(t));\n    audio += vec2(beepPong(t));\n    audio += engines(t);\n    audio += vec2(scanner(t));\n    audio = clamp(audio, -1.0, 1.0);\n    audio *= smoothstep(cueFLYOFF-.3, cueFLYOFF-.8, t)+smoothstep(cueFLYOFF, cueFLYOFF+.3, t);\n    audio += vec2(boom(t));\n    audio += vec2(softBeep(t));\n    audio += guns(t);\n    audio *= smoothstep(cueFLYIN, cueFLYIN-.2, t)  + smoothstep(cueFLYIN, cueFLYIN+.2, t);\n    audio += vec2(tech49(t));\n    return audio*.8;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec2 mainSound(float time)\n{\n\t float ti = mod(time, 57.);\n     \/\/ Tests cues...\n\/\/   float ti = mod(time, 45.0);\n   \/\/float ti = mod(time, 6.5)+cueFRONTOF;\n   \/\/float ti = mod(time, 15.)+cueTHREAT+1.0;\n   \/\/float ti = mod(time, 8.5)+cueFLYOFF-2.5;\n    \n    drone = dronePath(ti);\n    vec3 camPos = cameraAni(ti);\n    float l = max(length(drone-camPos)-20.0, 1.);\n    speed = clamp(length(drone -dronePath(ti-.08)),0.0, 1.1);\n    height = drone.y;\n    float disAtten = clamp(7330.0\/(l*l), 0.0, 1.0);\n\n   \tvec2 audio = allsounds(ti)*disAtten;\n    \/\/ Echo, echo echo...\n\taudio += allsounds(ti-.3)*.12 * vec2(1.0, .3)*disAtten;\n    audio += allsounds(ti-.6)*.06 * vec2(.3, 1.)*disAtten;\n    audio += allsounds(ti-.9)*.03 * vec2(1., .3)*disAtten;\n    \/\/audio += allsounds(ti-.12)*.025 * vec2(.3, 1.)*disAtten;.\/\/ ...too much!\n    \n    return audio * smoothstep(0.0, 2., ti) * smoothstep(57.0, 55., time);\n}\n\n","name":"","description":"","type":"sound"}]}}