{"Shader":{"ver":"0.1","info":{"id":"Mlf3zl","date":"1434586328","viewed":995,"name":"Curvature - Parametric 2D","username":"iq","description":"Computes curvature for parametric curves (same formula works for 3D), and displays it with colors (red is high curvature, yellow is medium, green is low)","likes":11,"published":3,"flags":0,"tags":["2d","curve","parametric"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\/\/\n\/\/ Computes the curvature of a parametric curve f(x) as \n\/\/\n\/\/ c(f) = |f'|^3 \/ | f' x f''|\n\/\/\n\/\/ More info here: https:\/\/en.wikipedia.org\/wiki\/Curvature)\n\/\/\n\n\n\/\/----------------------------------------\n\nfloat a = 0.85 + 0.1*cos(5.0+0.7*iGlobalTime);\nfloat b = 0.60 + 0.1*cos(4.0+0.5*iGlobalTime);\nfloat c = 0.40 + 0.1*cos(1.0+0.3*iGlobalTime);\nvec2 m = cos( 0.11*iGlobalTime + vec2(2.0,0.0) );\nvec2 n = cos( 0.17*iGlobalTime + vec2(3.0,1.0) );\n\n\/\/ curve\nvec2 mapD0(float t)\n{\n    return a*cos(t+m)*(b+c*cos(t*7.0+n));\n}\n\/\/ curve derivative (velocity)\nvec2 mapD1(float t)\n{\n    return -7.0*a*c*cos(t+m)*sin(7.0*t+n) - a*sin(t+m)*(b+c*cos(7.0*t+n));\n}\n\/\/ curve second derivative (acceleration)\nvec2 mapD2(float t)\n{\n    return 14.0*a*c*sin(t+m)*sin(7.0*t+n) - a*cos(t+m)*(b+c*cos(7.0*t+n)) - 49.0*a*c*cos(t+m)*cos(7.0*t+n);\n}\n\n\/\/----------------------------------------\n\nfloat cross( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat curvature( float t )\n{\n    vec2 r1 = mapD1(t); \/\/ first derivative\n    vec2 r2 = mapD2(t); \/\/ second derivative\n    return pow(length(r1),3.0) \/ length(cross(r1,r2));\n}\n\n\/\/-----------------------------------------\n\nvec2 sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\nvec2 graph( vec2 p )\n{\n    float dt = 6.2831\/256.0;\n\tfloat t = 0.0;\n\n    float mint = 1e10;\n    \n    vec2  xb = mapD0(t);\n    \n    float d = length( p - xb );\n    \n    t += dt;\n    for( int i=0; i<256; i++ )\n    {\n        vec2 xc = mapD0(t);\n        float k = curvature(t);\n        vec2 ds = sdSegment( p, xb, xc );\n        if( ds.x < d ) \n        { \n            d = ds.x;\n            mint = (t-dt + dt*ds.y ); \n        }\n\t\tt += dt;\n        xb = xc;\n\t}\n    \n\treturn vec2( d, mint );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float px = 2.0\/iResolution.y;\n\tvec2 p = (-iResolution.xy+2.0*fragCoord.xy)\/iResolution.y;\n    \n    vec2  d = graph( p );\n    float c = curvature( d.y );\n        \n    \/\/ background (distance)\n    vec3 col = vec3(0.3);\n    col *= 1.0 - 0.1*smoothstep(-0.3,0.3,sin( 120.0*d.x ));\n    col *= 1.0 - 0.4*d.x;\n\n    \/\/ curve (curvature)\n    vec3 cc = clamp( 0.25 + 0.75*cos( -clamp(3.0*c,0.0,2.0) + 1.0 + vec3(0.0,1.5,2.0) ), 0.0, 1.0 );\n    col = mix( col, cc, 1.0 - smoothstep(1.0*px, 3.0*px, d.x ) );\n    \n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}