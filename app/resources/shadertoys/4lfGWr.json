{"Shader":{"ver":"0.1","info":{"id":"4lfGWr","date":"1420563049","viewed":1755,"name":"Bidirectional path tracer 2","username":"reinder","description":"My second try of creating a bidirectional path tracer. I really should read those articles <img src=\"\/img\/emoticonSad.png\"\/> (all weights of the paths are guessed)<br\/>The shader shows a scene with indirect lighting, using a bidirectional path tracer and a classical path tracer.","likes":16,"published":3,"flags":0,"tags":["lighting","indirect","tracer","path","bidirectional"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Bidirectional path tracer 2. Created by Reinder Nijhoff 2014\n\/\/ @reindernijhoff\n\/\/\n\/\/ https:\/\/www.shadertoy.com\/view\/4lfGWr\n\/\/\n\n#define eps 0.00001\n#define LIGHTPATHLENGTH 2\n#define EYEPATHLENGTH 3\n#define SAMPLES 8\n\n#define SHOWSPLITLINE\n#define FULLBOX\n\n#define DOF\n#define ANIMATENOISE\n#define MOTIONBLUR\n\n#define MOTIONBLURFPS 12.\n\n#define LIGHTCOLOR vec3(16.86, 10.76, 8.2)*100.\n#define WHITECOLOR vec3(.7295, .7355, .729)*0.7\n#define GREENCOLOR vec3(.117, .4125, .115)*0.7\n#define REDCOLOR vec3(.611, .0555, .062)*0.7\n\nfloat seed = iGlobalTime;\n\nfloat hash1() {\n    return fract(sin(seed += 0.1)*43758.5453123);\n}\n\nvec2 hash2() {\n    return fract(sin(vec2(seed+=0.1,seed+=0.1))*vec2(43758.5453123,22578.1459123));\n}\n\nvec3 hash3() {\n    return fract(sin(vec3(seed+=0.1,seed+=0.1,seed+=0.1))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\n\/\/-----------------------------------------------------\n\/\/ Intersection functions (by iq)\n\/\/-----------------------------------------------------\n\nvec3 nSphere( in vec3 pos, in vec4 sph ) {\n    return (pos-sph.xyz)\/sph.w;\n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n\n\tfloat s = sqrt(h);\n\tfloat t1 = -b - s;\n\tfloat t2 = -b + s;\n\t\n\treturn t1 < 0.0 ? t2 : t1;\n}\n\nvec3 nPlane( in vec3 ro, in vec4 obj ) {\n    return obj.xyz;\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pla ) {\n    return (-pla.w - dot(pla.xyz,ro)) \/ dot( pla.xyz, rd );\n}\n\n\/\/-----------------------------------------------------\n\/\/ scene\n\/\/-----------------------------------------------------\n\nvec3 cosWeightedRandomHemisphereDirection( const vec3 n ) {\n  \tvec2 r = hash2();\n    \n\tvec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );\n\tvec3  vv = cross( uu, n );\n\t\n\tfloat ra = sqrt(r.y);\n\tfloat rx = ra*cos(6.2831*r.x); \n\tfloat ry = ra*sin(6.2831*r.x);\n\tfloat rz = sqrt( 1.0-r.y );\n\tvec3  rr = vec3( rx*uu + ry*vv + rz*n );\n    \n    return normalize( rr );\n}\n\nvec3 randomSphereDirection() {\n    vec2 r = hash2()*6.2831;\n\tvec3 dr=vec3(sin(r.x)*vec2(sin(r.y),cos(r.y)),cos(r.x));\n\treturn dr;\n}\n\nvec3 randomHemisphereDirection( const vec3 n ) {\n\tvec3 dr = randomSphereDirection();\n\treturn dot(dr,n) * dr;\n}\n\n\/\/-----------------------------------------------------\n\/\/ light\n\/\/-----------------------------------------------------\n\nconst vec4 lightSphere = vec4( 3.0,7.5,2.5, .5 );\nvec4 movingSphere;\n\nvoid initMovingSphere( float time ) {\n\tmovingSphere = vec4( 1.+abs(1.0*sin(time*1.3)), 1.+abs(2.0*sin(time)), 7.-abs(6.*cos(time*0.4)), 1.0);\n}\n\nvec3 sampleLight( const in vec3 ro ) {\n    vec3 n = randomSphereDirection() * lightSphere.w;\n    return lightSphere.xyz + n;\n}\n\n\/\/-----------------------------------------------------\n\/\/ scene\n\/\/-----------------------------------------------------\n\nvec2 intersect( in vec3 ro, in vec3 rd, inout vec3 normal ) {\n\tvec2 res = vec2( 1e20, -1.0 );\n    float t;\n\t\n\tt = iPlane( ro, rd, vec4( 0.0, 1.0, 0.0,0.0 ) ); if( t>eps && t<res.x ) { res = vec2( t, 1. ); normal = vec3( 0., 1., 0.); }\n\tt = iPlane( ro, rd, vec4( 0.0, 0.0,-1.0,8.0 ) ); if( t>eps && t<res.x ) { res = vec2( t, 1. ); normal = vec3( 0., 0.,-1.); }\n    t = iPlane( ro, rd, vec4( 1.0, 0.0, 0.0,0.0 ) ); if( t>eps && t<res.x ) { res = vec2( t, 2. ); normal = vec3( 1., 0., 0.); }\n#ifdef FULLBOX\n    t = iPlane( ro, rd, vec4( 0.0,-1.0, 0.0,5.49) ); if( t>eps && t<res.x && ro.z+rd.z*t < 5.5 ) { res = vec2( t, 1. ); normal = vec3( 0.,-1., 0.); }\n    t = iPlane( ro, rd, vec4(-1.0, 0.0, 0.0,5.59) ); if( t>eps && t<res.x ) { res = vec2( t, 3. ); normal = vec3(-1., 0., 0.); }\n#endif\n\n\tt = iSphere( ro, rd, movingSphere             ); if( t>eps && t<res.x ) { res = vec2( t, 1. ); normal = nSphere( ro+t*rd, movingSphere ); }\n    t = iSphere( ro, rd, vec4( 4.0,1.0, 4.0, 1.0) ); if( t>eps && t<res.x ) { res = vec2( t, 5. ); normal = nSphere( ro+t*rd, vec4( 4.0,1.0, 4.0,1.0) ); }\n    t = iSphere( ro, rd, lightSphere ); if( t>eps && t<res.x ) { res = vec2( t, 0.0 );  normal = nSphere( ro+t*rd, lightSphere ); }\n\t\t\t\t\t  \n    return res;\t\t\t\t\t  \n}\n\nbool intersectShadow( in vec3 ro, in vec3 rd, in float dist ) {\n    float t;\n\t\n\tt = iSphere( ro, rd, movingSphere            );  if( t>eps && t<dist ) { return true; }\n    t = iSphere( ro, rd, vec4( 4.0,1.0, 4.0,1.0) );  if( t>eps && t<dist ) { return true; }\n#ifdef FULLBOX    \n    t = iPlane( ro, rd, vec4( 0.0,-1.0, 0.0,5.49) ); if( t>eps && t<dist && ro.z+rd.z*t < 5.5 ) { return true; }\n#endif\n    return false; \/\/ optimisation: other planes don't cast shadows in this scene\n}\n\n\/\/-----------------------------------------------------\n\/\/ materials\n\/\/-----------------------------------------------------\n\nvec3 matColor( const in float mat ) {\n\tvec3 nor = vec3(0., 0.95, 0.);\n\t\n\tif( mat<3.5 ) nor = REDCOLOR;\n    if( mat<2.5 ) nor = GREENCOLOR;\n\tif( mat<1.5 ) nor = WHITECOLOR;\n\tif( mat<0.5 ) nor = LIGHTCOLOR;\n\t\t\t\t\t  \n    return nor;\t\t\t\t\t  \n}\n\nbool matIsSpecular( const in float mat ) {\n    return mat > 4.5;\n}\n\nbool matIsLight( const in float mat ) {\n    return mat < 0.5;\n}\n\n\/\/-----------------------------------------------------\n\/\/ brdf\n\/\/-----------------------------------------------------\n\nvec3 getBRDFRay( in vec3 n, const in vec3 rd, const in float m, inout bool specularBounce ) {\n    specularBounce = false;\n    \n    vec3 r = cosWeightedRandomHemisphereDirection( n );\n    if(  !matIsSpecular( m ) ) {\n        return r;\n    } else {\n        specularBounce = true;\n        \n        float n1, n2, ndotr = dot(rd,n);\n        \n        if( ndotr > 0. ) {\n            n1 = 1.\/1.5; n2 = 1.;\n            n = -n;\n        } else {\n            n2 = 1.\/1.5; n1 = 1.;\n        }\n                \n        float r0 = (n1-n2)\/(n1+n2); r0 *= r0;\n\t\tfloat fresnel = r0 + (1.-r0) * pow(1.0-abs(ndotr),5.);\n        \n        vec3 ref;\n        \n        if( hash1() < fresnel || m > 6.5 ) {\n            ref = reflect( rd, n );\n        } else {\n            ref = refract( rd, n, n2\/n1 );\n        }\n        \n        return ref; \/\/ normalize( ref + 0.1 * r );\n\t}\n}\n\n\/\/-----------------------------------------------------\n\/\/ lightpath\n\/\/-----------------------------------------------------\n\nstruct LightPathNode {\n    vec3 color;\n    vec3 position;\n    vec3 normal;\n};\n\nLightPathNode lpNodes[LIGHTPATHLENGTH];\n\nvoid constructLightPath() {\n    vec3 ro = randomSphereDirection();\n    vec3 rd = cosWeightedRandomHemisphereDirection( ro );\n    ro = lightSphere.xyz - ro*lightSphere.w;\n    vec3 color = LIGHTCOLOR;\n \n    for( int i=0; i<LIGHTPATHLENGTH; ++i ) {\n        lpNodes[i].position = lpNodes[i].color = lpNodes[i].normal = vec3(0.);\n    }\n    \n    bool specularBounce;\n    float w = 0.;\n    \n    for( int i=0; i<LIGHTPATHLENGTH; i++ ) {\n\t\tvec3 normal;\n        vec2 res = intersect( ro, rd, normal );\n        \n        if( res.y > 0.5 && dot( rd, normal ) < 0. ) {\n            ro = ro + rd*res.x;            \n            color *= matColor( res.y );\n            \n            lpNodes[i].position = ro;\n            if( !matIsSpecular( res.y ) ) lpNodes[i].color = color;\/\/ * clamp( dot( normal, -rd ), 0., 1.);\n            lpNodes[i].normal = normal;\n            \n            rd = getBRDFRay( normal, rd, res.y, specularBounce );\n        } else break;\n    }\n}\n\n\/\/-----------------------------------------------------\n\/\/ eyepath\n\/\/-----------------------------------------------------\n\nfloat getWeightForPath( int e, int l ) {\n    return float(e + l + 2);\n}\n\nvec3 traceEyePath( in vec3 ro, in vec3 rd, const in bool bidirectTrace ) {\n    vec3 tcol = vec3(0.);\n    vec3 fcol  = vec3(1.);\n    \n    bool specularBounce = true; \n\tint jdiff = 0;\n    \n    for( int j=0; j<EYEPATHLENGTH; ++j ) {\n        vec3 normal;\n        \n        vec2 res = intersect( ro, rd, normal );\n        if( res.y < -0.5 ) {\n            return tcol;\n        }\n        \n        if( matIsLight( res.y ) ) {\n            if( bidirectTrace ) {\n            \tif( specularBounce ) tcol += fcol*LIGHTCOLOR;\n            } else {\n               tcol += fcol*LIGHTCOLOR;\n            }\n            return tcol; \/\/ the light has no diffuse component, therefore we can return col\n        }\n        \n        ro = ro + res.x * rd;   \n        vec3 rdi = rd;\n        rd = getBRDFRay( normal, rd, res.y, specularBounce );\n        \n        fcol *= matColor( res.y );\n                \n        if( bidirectTrace  ) {\n\t\t    vec3 ld = sampleLight( ro ) - ro;       \n            \n            \/\/ path of (j+1) eyepath-nodes, and 1 lightpath-node ( = direct light sampling )\n            vec3 nld = normalize(ld);\n            if( !specularBounce &&  !intersectShadow( ro, nld, length(ld)) ) {\n                float cos_a_max = sqrt(1. - clamp(lightSphere.w * lightSphere.w \/ dot(lightSphere.xyz-ro, lightSphere.xyz-ro), 0., 1.));\n                float weight = 2. * (1. - cos_a_max);\n\n                tcol += (fcol * LIGHTCOLOR) * (weight * clamp(dot( nld, normal ), 0., 1.))\n                    \/ getWeightForPath(jdiff,-1);\n            }\n\n            \n            if( !matIsSpecular( res.y ) ) {\n                for( int i=0; i<LIGHTPATHLENGTH; ++i ) {\n                    \/\/ path of (j+1) eyepath-nodes, and i+2 lightpath-nodes.\n                    vec3 lp = lpNodes[i].position - ro;\n                    vec3 lpn = normalize( lp );\n                    vec3 lc = lpNodes[i].color;\n\n                    if( !intersectShadow(ro, lpn, length(lp)) ) {\n                        \/\/ weight for going from (j+1)th eyepath-node to (i+2)th lightpath-node\n                        \n                        \/\/ IS THIS CORRECT ???\n                        \n                        float weight = \n                                 clamp( dot( lpn, normal ), 0.0, 1.) \n                               * clamp( dot( -lpn, lpNodes[i].normal ), 0., 1.)\n                               * clamp(1. \/ dot(lp, lp), 0., 1.)\n                            ;\n\n                        tcol += lc * fcol * weight \/ getWeightForPath(jdiff,i);\n                    }\n                }\n            }\n        }\n        \n        if( !specularBounce) jdiff++; else jdiff = 0;\n    }  \n    \n    return tcol;\n}\n\n\/\/-----------------------------------------------------\n\/\/ main\n\/\/-----------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n    \n\tfloat splitCoord = (iMouse.x == 0.0) ? iResolution.x\/2. + iResolution.x*cos(iGlobalTime*.5) : iMouse.x;\n    bool bidirectTrace = fragCoord.x < splitCoord;\n    \n    \/\/-----------------------------------------------------\n    \/\/ camera\n    \/\/-----------------------------------------------------\n\n    vec2 p = -1.0 + 2.0 * (fragCoord.xy) \/ iResolution.xy;\n    p.x *= iResolution.x\/iResolution.y;\n\n#ifdef ANIMATENOISE\n    seed = p.x + p.y * 3.43121412313 + fract(1.12345314312*iGlobalTime);\n#else\n    seed = p.x + p.y * 3.43121412313;\n#endif\n    \n    vec3 ro = vec3(2.78, 2.73, -8.00);\n    vec3 ta = vec3(2.78, 2.73,  0.00);\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \/\/-----------------------------------------------------\n    \/\/ render\n    \/\/-----------------------------------------------------\n\n    vec3 col = vec3(0.0);\n    vec3 tot = vec3(0.0);\n    vec3 uvw = vec3(0.0);\n    \n    for( int a=0; a<SAMPLES; a++ ) {\n\n        vec2 rpof = 4.*(hash2()-vec2(0.5)) \/ iResolution.xy;\n\t    vec3 rd = normalize( (p.x+rpof.x)*uu + (p.y+rpof.y)*vv + 3.0*ww );\n        \n#ifdef DOF\n\t    vec3 fp = ro + rd * 12.0;\n   \t\tvec3 rof = ro + (uu*(hash1()-0.5) + vv*(hash1()-0.5))*0.125;\n    \trd = normalize( fp - rof );\n#else\n        vec3 rof = ro;\n#endif        \n        \n#ifdef MOTIONBLUR\n        initMovingSphere( iGlobalTime + hash1() \/ MOTIONBLURFPS );\n#else\n        initMovingSphere( iGlobalTime );        \n#endif\n        \n        if( bidirectTrace ) {\n            constructLightPath();\n        }\n        \n        col = traceEyePath( rof, rd, bidirectTrace );\n\n        tot += col;\n        \n        seed = mod( seed*1.1234567893490423, 13. );\n    }\n    \n    tot \/= float(SAMPLES);\n    \n#ifdef SHOWSPLITLINE\n\tif (abs(fragCoord.x - splitCoord) < 1.0) {\n\t\ttot.x = 1.0;\n\t}\n#endif\n    \n\ttot = pow( clamp(tot,0.0,1.0), vec3(0.45) );\n\n    fragColor = vec4( tot, 1.0 );\n}","name":"","description":"","type":"image"}]}}