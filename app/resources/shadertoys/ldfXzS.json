{"Shader":{"ver":"0.1","info":{"id":"ldfXzS","date":"1403188726","viewed":3568,"name":"Wet Sand","username":"TekF","description":"Trying the nice surface shading tricks from my  on a landscape.><br\/>Toggle Ambient Occlusion: A, Toggle Reflection Occlusion: S. View modes:Q,W,L","likes":41,"published":3,"flags":0,"tags":["ambientocclusion","specularocclusion"],"hasliked":0},"renderpass":[{"inputs":[{"id":10,"src":"\/presets\/tex09.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Ben Quantock 2014\r\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n\/\/ artefacts from noise texture interpolation\r\n\/\/#define FAST\r\n\r\n\/\/ keys\r\nint kA=65,kB=66,kC=67,kD=68,kE=69,kF=70,kG=71,kH=72,kI=73,kJ=74,kK=75,kL=76,kM=77,kN=78,kO=79,kP=80,kQ=81,kR=82,kS=83,kT=84,kU=85,kV=86,kW=87,kX=88,kY=89,kZ=90;\r\nint k0=48,k1=49,k2=50,k3=51,k4=52,k5=53,k6=54,k7=55,k8=56,k9=57;\r\nint kSpace=32,kLeft=37,kUp=38,kRight=39,kDown=40;\r\n\r\n\r\n\/\/ TOGGLES:\r\n\r\n\/\/ demo mode - cycle through the effects\r\nint kDemoMode = kD;\r\n\r\n\/\/ aesthetic toggles\r\nint kAnimate = kA;  float pauseTime = 3.6;\r\n\/\/int kPrintedPaper = kP;\r\nint kLensFX = kL;\r\n\r\n\/\/ lighting\r\n\/\/int kLighting = k0; \/\/ turn all diffuse illumination on\/off (to see reflections better)\r\n\/\/int kAlbedo = k1;\r\n\/\/int kShadow = k2;\r\n\/\/int kDirectLight = k3;\r\n\/\/int kAmbientGradient = k4;\r\nint kAmbientOcclusion = kA;\r\nint kShowAmbientOcclusion = kQ;\r\n\r\n\/\/ specular\r\n\/\/int kSpecular = k9; \/\/ turn all specular on\/off (to see diffuse better)\r\n\/\/int kSpecularHighlight = kQ;\r\n\/\/int kFresnel = kW;\r\nint kReflectionOcclusion = kS;\r\n\/\/int kReflections = kR;\r\nint kShowSpecularOcclusion = kW;\r\n\r\n\r\n\/\/ key is javascript keycode: http:\/\/www.webonweboff.com\/tips\/js\/event_key_codes.aspx\r\nbool ReadKey( int key, bool toggle )\r\n{\r\n\tfloat keyVal = texture2D( iChannel3, vec2( (float(key)+.5)\/256.0, toggle?.75:.25 ) ).x;\r\n\treturn (keyVal>.5)?true:false;\r\n}\r\n\r\n\r\nbool Toggle( int val, int index )\r\n{\r\n\/\/ Toggles are breaking the compile! AARGH!\r\n\/\/ try removing a few of them, or something\r\n\/\/ mostly want to see spec\/amb occ\r\n\t\r\n\/*\tfloat cut = fract(iGlobalTime\/30.0)*11.0;\r\n\tif ( !ReadKey( kDemoMode, true ) && float(index) > cut )\r\n\t{\r\n\t\treturn false;\r\n\t}*\/\r\n\t\r\n\t\/\/ default everything to \"on\"\r\n\treturn !ReadKey( val, true );\r\n}\r\n\r\n\r\nvec2 Noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n\r\n\t\/\/ On Chrome 36 I get an artefact where the texture wraps, so do the wrap manually\t\r\n\tuv = fract(uv\/256.0)*256.0;\r\n\r\n#ifdef FAST\r\n\tvec4 rg = texture2D( iChannel0, (uv+0.5)\/256.0, -100.0 );\r\n#else\r\n\t\/\/ high precision interpolation, if needed\r\n\tvec4 rg = mix( mix(\r\n\t\t\t\ttexture2D( iChannel0, (floor(uv)+0.5)\/256.0, -100.0 ),\r\n\t\t\t\ttexture2D( iChannel0, (floor(uv)+vec2(1,0)+0.5)\/256.0, -100.0 ),\r\n\t\t\t\tfract(uv.x) ),\r\n\t\t\t\t  mix(\r\n\t\t\t\ttexture2D( iChannel0, (floor(uv)+vec2(0,1)+0.5)\/256.0, -100.0 ),\r\n\t\t\t\ttexture2D( iChannel0, (floor(uv)+1.5)\/256.0, -100.0 ),\r\n\t\t\t\tfract(uv.x) ),\r\n\t\t\t\tfract(uv.y) );\r\n#endif\t\t\t  \r\n\r\n\treturn mix( rg.yw, rg.xz, f.z );\r\n}\r\n\r\nfloat Granite( in vec3 x )\r\n{\r\n\treturn (\r\n\t\t\t abs(Noise(x* 1.0).x-.5)\/1.0\r\n\t\t\t+abs(Noise(x* 2.0).x-.5)\/2.0\r\n\t\t\t+abs(Noise(x* 4.0).x-.5)\/4.0\r\n\t\t\t+abs(Noise(x* 8.0).x-.5)\/8.0\r\n\t\t\t+abs(Noise(x*16.0).x-.5)\/16.0\r\n\t\t)*32.0\/31.0;\r\n\/\/\t\t\t+abs(Noise(x*32.0).x-.5)\/32.0\r\n\/\/\t\t\t+abs(Noise(x*64.0).x-.5)\/64.0\r\n\/\/\t\t)*128.0\/127.0;\r\n}\r\n\r\n\r\nfloat DistanceField( vec3 p, float t )\r\n{\r\n\t\/\/return p.y;\r\n\t\/\/return (p.y - max(.0,Granite(p.xzy*vec3(1,1,0))-.5)) \/ 1.2;\r\n\r\n\/\/ this doesn't get good occlusion, because the lumps don't have a gradient to their sides\r\n\t\/\/return min(p.y, ( p.y - (Granite(p.xzy*vec3(1,1,0))-.5) ) \/ 1.2);\r\n\r\n\treturn min(p.y, ( p.y - (Granite(p)-.5) ) * (.65-.2*2.0\/max(2.0,t)) ); \/\/ adjust accuracy with depth\r\n}\r\n\r\nfloat DistanceField( vec3 p )\r\n{\r\n\treturn DistanceField( p, 0.0 );\r\n}\r\n\r\n\r\nvec3 Sky( vec3 ray )\r\n{\r\n\treturn mix( vec3(.8), vec3(0), exp2(-(1.0\/max(ray.y,.01))*vec3(.4,.6,1.0)) );\r\n}\r\n\r\n\r\nvec3 Shade( vec3 pos, vec3 ray, vec3 normal, vec3 lightDir, vec3 lightCol, float shadowMask, float distance )\r\n{\r\n\tvec3 ambient = vec3(.5);\r\n\/\/\tif ( Toggle(kAmbientGradient,2) )\r\n\t\tambient = mix( vec3(.2,.27,.4), vec3(.4), (-normal.y*.5+.5) ); \/\/ ambient\r\n\/\/\t\tambient = mix( vec3(.03,.05,.08), vec3(.1), (-normal.y+1.0) ); \/\/ ambient\r\n\t\/\/ ambient occlusion, based on my DF Lighting: https:\/\/www.shadertoy.com\/view\/XdBGW3\r\n\tfloat aoRange = distance\/20.0;\r\n\t\r\n\tfloat occlusion = max( 0.0, 1.0 - DistanceField( pos + normal*aoRange )\/aoRange ); \/\/ can be > 1.0\r\n\/\/\tocclusion = min( 1.0, occlusion ); \/\/ prevent excessive occlusion\r\n\tocclusion = exp2( -2.0*pow(occlusion,2.0) ); \/\/ tweak the curve\r\n\/\/\tocclusion *= mix(.5,1.0,pow(grainq,.2));\r\n\tif ( Toggle(kAmbientOcclusion,1) )\r\n\t\tambient *= occlusion;\r\n\r\n\tfloat ndotl = max(.0,dot(normal,lightDir));\r\n\tfloat lightCut = smoothstep(.0,.1,ndotl);\/\/pow(ndotl,2.0);\r\n\tvec3 light = vec3(0);\r\n\r\n\/\/\tif ( Toggle(kDirectLight,3) )\r\n\t\t\tlight += lightCol*shadowMask*ndotl;\r\n\r\n\tlight += ambient;\r\n\r\n\r\n\t\/\/ And sub surface scattering too! Because, why not?\r\n\tfloat transmissionRange = .1;\/\/distance\/5.0;\r\n\tfloat transmission = max( 0.0, DistanceField( pos + lightDir*transmissionRange )\/transmissionRange );\r\n\tvec3 subsurface = vec3(1,.8,.5) * .5 * lightCol * transmission;\r\n\/\/\tcommented out because it's a little buggy with small distances, and sand shouldn't have a lot of sss\r\n\/\/\tlight += subsurface;\r\n\r\n\r\n\tfloat specularity = smoothstep( .5,1.0, texture2D( iChannel0, pos.xz\/256.0 ).r )\r\n\t\t\t\t\t\t*pow(smoothstep( 0.05, 0.0, pos.y ),2.0); \/\/ don't let the lumps be too shiny\r\n\t\r\n\tvec3 h = normalize(lightDir-ray);\r\n\tfloat specPower = exp2(3.0+6.0*specularity);\r\n\tvec3 specular = lightCol*shadowMask*pow(max(.0,dot(normal,h))*lightCut, specPower)*specPower\/32.0;\r\n\t\r\n\tvec3 rray = reflect(ray,normal);\r\n\tvec3 reflection = vec3(0);\r\n\t\r\n\/\/\tif ( Toggle(kReflections,6) )\r\n\t\treflection = Sky( rray );\r\n\t\r\n\t\r\n\t\/\/ specular occlusion, adjust the divisor for the gradient we expect\r\n\tfloat specOcclusion = max( 0.0, 1.0 - DistanceField( pos + rray*aoRange )\/(aoRange*max(.01,dot(rray,normal))) ); \/\/ can be > 1.0\r\n\tspecOcclusion = exp2( -2.0*pow(specOcclusion,2.0) ); \/\/ tweak the curve\r\n\t\r\n\t\/\/ prevent sparkles in heavily occluded areas\r\n\tspecOcclusion *= occlusion;\r\n\r\n\tif ( Toggle(kReflectionOcclusion,7) )\r\n\t\treflection *= specOcclusion; \/\/ could fire an additional ray for more accurate results\r\n\t\r\n\tfloat fresnel = pow( 1.0+dot(normal,ray), 5.0 );\r\n\tfresnel = mix( mix( .0, .05, specularity ), mix( .4, 1.0, specularity ), fresnel );\r\n\t\r\n\/\/\tif ( !Toggle(kFresnel,8) )\r\n\/\/\t\tfresnel = 1.0; \/\/ chrome\r\n\t\r\n\tvec3 albedo = vec3(.5,.3,.13);\r\n\t\r\n\/\/\tif ( !Toggle(kAlbedo,5) ) albedo = vec3(1);\r\n\t\r\n\tvec3 result = vec3(0);\r\n\/\/\tif ( Toggle(kLighting,-1) )\r\n\t\tresult = light*albedo;\r\n\r\n\/\/\tif ( Toggle(kSpecular,6) )\r\n\t{\r\n\t\tresult = mix( result, reflection, fresnel );\r\n\t\r\n\/\/\t\tif ( Toggle(kSpecularHighlight,9) )\r\n\t\t\tresult += specular;\r\n\t}\r\n\r\n\tif ( !Toggle(kShowAmbientOcclusion,-1) )\r\n\t\tresult = vec3(occlusion);\r\n\r\n\tif ( !Toggle(kShowSpecularOcclusion,-1) )\r\n\t\tresult = vec3(specOcclusion);\r\n\t\r\n\treturn result;\r\n}\r\n\r\n\r\n\r\n\r\n\/\/ Isosurface Renderer\r\n#ifdef FAST\r\nconst int traceLimit=40;\r\nconst float traceSize=.005;\r\n#else\r\nconst int traceLimit=60;\r\nconst float traceSize=.002;\r\n#endif\t\r\n\r\nfloat Trace( vec3 pos, vec3 ray, float traceStart, float traceEnd )\r\n{\r\n\tfloat t = traceStart;\r\n\tfloat h;\r\n\tfor( int i=0; i < traceLimit; i++ )\r\n\t{\r\n\t\th = DistanceField( pos+t*ray, t );\r\n\t\tif ( h < traceSize || t > traceEnd )\r\n\t\t\tbreak;\r\n\t\tt = t+h;\r\n\t}\r\n\t\r\n\tif ( t > traceEnd )\/\/|| h > .001 )\r\n\t\treturn 0.0;\r\n\t\r\n\treturn t;\r\n}\r\n\r\nfloat TraceMin( vec3 pos, vec3 ray, float traceStart, float traceEnd )\r\n{\r\n\tfloat Min = traceEnd;\r\n\tfloat t = traceStart;\r\n\tfloat h;\r\n\tfor( int i=0; i < traceLimit; i++ )\r\n\t{\r\n\t\th = DistanceField( pos+t*ray, t );\r\n\t\tMin = min(h,Min);\r\n\t\tif ( \/*h < .001 ||*\/ t > traceEnd )\r\n\t\t\tbreak;\r\n\t\tt = t+max(h,.1);\r\n\t}\r\n\t\r\n\treturn Min;\r\n}\r\n\r\nvec3 Normal( vec3 pos, vec3 ray, float t )\r\n{\r\n\t\/\/ in theory we should be able to get a good gradient using just 4 points\r\n\r\n\tfloat pitch = .5 * t \/ iResolution.x;\r\n#ifdef FAST\r\n\t\/\/ don't sample smaller than the interpolation errors in Noise()\r\n\tpitch = max( pitch, .005 );\r\n#endif\r\n\t\r\n\tvec2 d = vec2(-1,1) * pitch;\r\n\r\n\tvec3 p0 = pos+d.xxx; \/\/ tetrahedral offsets\r\n\tvec3 p1 = pos+d.xyy;\r\n\tvec3 p2 = pos+d.yxy;\r\n\tvec3 p3 = pos+d.yyx;\r\n\t\r\n\tfloat f0 = DistanceField(p0,t);\r\n\tfloat f1 = DistanceField(p1,t);\r\n\tfloat f2 = DistanceField(p2,t);\r\n\tfloat f3 = DistanceField(p3,t);\r\n\t\r\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3);\r\n\t\r\n\t\/\/ prevent normals pointing away from camera (caused by precision errors)\r\n\tfloat gdr = dot ( grad, ray );\r\n\tgrad -= max(.0,gdr)*ray;\r\n\t\r\n\treturn normalize(grad);\r\n}\r\n\r\n\r\n\/\/ Camera\r\n\r\nvec3 Ray( float zoom, in vec2 fragCoord )\r\n{\r\n\treturn vec3( fragCoord.xy-iResolution.xy*.5, iResolution.x*zoom );\r\n}\r\n\r\nvec3 Rotate( inout vec3 v, vec2 a )\r\n{\r\n\tvec4 cs = vec4( cos(a.x), sin(a.x), cos(a.y), sin(a.y) );\r\n\t\r\n\tv.yz = v.yz*cs.x+v.zy*cs.y*vec2(-1,1);\r\n\tv.xz = v.xz*cs.z+v.zx*cs.w*vec2(1,-1);\r\n\t\r\n\tvec3 p;\r\n\tp.xz = vec2( -cs.w, -cs.z )*cs.x;\r\n\tp.y = cs.y;\r\n\t\r\n\treturn p;\r\n}\r\n\r\n\r\n\/\/ Camera Effects\r\n\r\nvoid BarrelDistortion( inout vec3 ray, float degree )\r\n{\r\n\t\/\/ would love to get some disperson on this, but that means more rays\r\n\tray.z \/= degree;\r\n\tray.z = ( ray.z*ray.z - dot(ray.xy,ray.xy) ); \/\/ fisheye\r\n\tray.z = degree*sqrt(ray.z);\r\n}\r\n\r\nvec3 LensFlare( vec3 ray, vec3 light, float lightVisible, float sky, in vec2 fragCoord )\r\n{\r\n\tvec2 dirtuv = fragCoord.xy\/iResolution.x;\r\n\t\r\n\tfloat dirt = 1.0-texture2D( iChannel1, dirtuv ).r;\r\n\t\r\n\tfloat l = (dot(light,ray)*.5+.5);\r\n\t\r\n\treturn (((pow(l,30.0)+.05)*dirt*.1 + 1.0*pow(l,200.0))*lightVisible + sky*1.0*pow(l,5000.0))*vec3(1.05,1,.95);\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec3 ray = Ray(1.0, fragCoord);\r\n\t\r\n\tif ( Toggle(kLensFX,10) )\r\n\t\tBarrelDistortion( ray, .5 );\r\n\t\r\n\tray = normalize(ray);\r\n\tvec3 localRay = ray;\r\n\r\n\tvec2 mouse = vec2(0);\r\n\tif ( iMouse.z > 0.0 )\r\n\t\tmouse = .5-iMouse.yx\/iResolution.yx;\r\n\t\t\r\n\tfloat T = iGlobalTime*.1;\r\n\tvec3 pos = 2.0*Rotate( ray, vec2(.2,2.8-T)+vec2(-.5,-6.3)*mouse );\r\n\tpos += vec3(0,.3,0) + T*vec3(0,0,-1);\r\n\t\r\n\tfloat top = .5, bottom = .0;\r\n\t\r\n\tvec3 col;\r\n\r\n\tvec3 lightDir = normalize(vec3(3,1,-2));\r\n\t\r\n\tfloat topIntersection = (top-pos.y)\/ray.y;\r\n\tfloat bottomIntersection = (bottom-pos.y)\/ray.y;\r\n\t\r\n\tfloat traceStart = .5;\r\n\tfloat traceEnd = 40.0;\r\n\t\r\n\tif ( ray.y > 0.0 )\r\n\t\ttraceEnd = min(traceEnd,topIntersection);\r\n\telse if ( ray.y < 0.0 )\r\n\t{\r\n\t\ttraceEnd = min(traceEnd,bottomIntersection);\r\n\t\tif ( pos.y > top )\r\n\t\t\ttraceStart = min(traceEnd,topIntersection);\r\n\t}\r\n\t\r\n\tfloat t = Trace( pos, ray, traceStart, traceEnd );\r\n\tif ( t > .0 )\r\n\t{\r\n\t\tvec3 p = pos + ray*t;\r\n\t\t\r\n\t\t\/\/ shadow test\r\n\t\tfloat s = 0.0;\r\n\/\/\t\tif ( Toggle(kShadow,4) )\r\n\t\t\ts = Trace( p, lightDir, .05, (top-p.y)\/lightDir.y );\r\n\t\t\r\n\t\tvec3 n = Normal(p, ray, t);\r\n\t\tcol = Shade( p, ray, n, lightDir, vec3(1.1,1,.9), (s>.0)?0.0:1.0, t );\r\n\t\t\r\n\t\t\/\/ fog\r\n\t\tfloat f = 80.0;\r\n\t\tcol = mix( vec3(.8), col, exp2(-t*vec3(.4,.6,1.0)\/f) );\r\n\t}\r\n\telse\r\n\t{\r\n\t\tcol = Sky( ray );\r\n\t}\r\n\t\r\n\tif ( Toggle(kLensFX,10) )\r\n\t{\r\n\t\t\/\/ lens flare\r\n\t\tfloat sun = 1.0;\/\/TraceMin( pos, lightDir, .5, 40.0 );\r\n\t\tcol += LensFlare( ray, lightDir, smoothstep(-.04,.1,sun), step(t,.0),fragCoord );\r\n\t\r\n\t\t\/\/ vignetting:\r\n\t\tcol *= smoothstep( .5, .0, dot(localRay.xy,localRay.xy) );\r\n\t\r\n\t\t\/\/ compress bright colours, ( because bloom vanishes in vignette )\r\n\t\tvec3 c = (col-1.0);\r\n\t\tc = sqrt(c*c+.05); \/\/ soft abs\r\n\t\tcol = mix(col,1.0-c,.48); \/\/ .5 = never saturate, .0 = linear\r\n\t\t\r\n\t\t\/\/ grain\r\n\t\tvec2 grainuv = fragCoord.xy + floor(iGlobalTime*60.0)*vec2(37,41);\r\n\t\tvec2 filmNoise = texture2D( iChannel0, .5*grainuv\/iChannelResolution[0].xy ).rb;\r\n\t\tcol *= mix( vec3(1), mix(vec3(1,.5,0),vec3(0,.5,1),filmNoise.x), .1*filmNoise.y );\r\n\t}\r\n\t\r\n\tfragColor = vec4(pow(col,vec3(1.0\/2.6)),1);\r\n}\r\n","name":"","description":"","type":"image"}]}}