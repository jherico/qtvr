{"Shader":{"ver":"0.1","info":{"id":"ltXGWn","date":"1420600568","viewed":718,"name":"crazy stupid fractal","username":"pflowsoftware","description":"this is an abomination. used the linear interpolation from http:\/\/en.wikipedia.org\/wiki\/Mandelbrot_set#Histogram_coloring and the algorithm shown is (z^z+z)\/ln(z) + c<br\/><br\/>log(complex number) is confusing on wikipedia<br\/>tldr:<br\/>real: log(|c|)<br\/>imag: atan(i\/r)","likes":0,"published":3,"flags":0,"tags":["fractaljulia"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/Julia Set for (.285,.01)\n#define CREAL .268\n#define CIMAG .060\n#define DEPTH 1000\n#define R x\n#define I y\n\nvec3 hsv(float h,float s,float v) {\n\treturn mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)\/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n\nfloat cMag2(vec2 c){\n    return c.R*c.R+c.I*c.I;\n}\nfloat cArg(vec2 c){\n \treturn atan(c.I,c.R);   \n}\nfloat cMag(vec2 c){\n \treturn sqrt(c.R*c.R+c.I*c.I);   \n}\nvec2 cLog(vec2 c){\n \tfloat real = log(cMag(c));\n    float imag = cArg(c);\n    return vec2(real,imag);\n}\nvec2 cConj(vec2 c){\n\treturn vec2(c.R, -1.*c.I);   \n}\nvec2 cMult(vec2 c1, vec2 c2){\n    float real = c1.R*c2.R-c1.I*c2.I; \/\/real * real - imag * imag\n    float imag = c1.R*c2.I+c1.I*c2.R; \/\/real * imag + imag * real\n    return vec2(real,imag);\n}\nvec2 cDivScalar(vec2 c, float s){\n    return vec2(c.R\/s,c.I\/s);\n}\nvec2 cDiv(vec2 c1, vec2 c2){\n\tvec2 c2c = cConj(c2);\n    vec2 numerator = cMult(c1,c2c);\n    float denominator = cMult(c2,c2c).R;\n    return cDivScalar(numerator,denominator);\n}\nvec2 cSum(vec2 c1,vec2 c2){\n    return vec2(c1.R+c2.R,c1.I+c2.I);}\n\nvec2 cSqr(vec2 c){\n    return vec2(c.R*c.R-c.I*c.I,2.*c.R*c.I);}\n\nfloat julia(vec2 z, vec2 C){\n    float attSize = 0.; \/\/.01*(sin(iGlobalTime\/10.));\n    float iteration = 0.;\n    for( int i = 0; i < 10; i++){\n        \n        z = cSum(cDiv(cSum(cSqr(z),z),cLog(z)),C);\n        \n        \/\/if (cMag2(z)>4.){return float(DEPTH-i)\/float(DEPTH);} \/\/escape\n        \/\/if (cMag2(z)<attSize){return 1.;} \/\/creates Attractors (Spots)\n        iteration += 1.;\n        if (cMag2(z) > 16. || iteration>=float(DEPTH)){break;}\n    }\n    if ( iteration < float(DEPTH) ) {\n        float zn = cMag(z);\n        float nu = log( log(zn) \/ log(2.) ) \/ log(2.);\n        \/\/ Rearranging the potential function.\n        \/\/ Could remove the sqrt and multiply log(zn) by 1\/2, but less clear.\n        \/\/ Dividing log(zn) by log(2) instead of log(N = 1<<8)\n        \/\/ because we want the entire palette to range from the\n        \/\/ center to radius 2, NOT our bailout radius.\n        iteration = iteration + 1. - nu;\n  \t}\n    return float(iteration);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat2 rot;\n    float zoom = 1.; \/\/1.2*abs(sin(iGlobalTime\/8.));\n\t\n\tfloat deg = iGlobalTime\/4.+sin(iGlobalTime\/4.);;\n\t\n\trot[0] = vec2(cos(deg), sin(deg));\n\trot[1] = vec2(-sin(deg), cos(deg));\n    \n    float aspectRatio = iResolution.x\/iResolution.y;\n    float xMod = (fragCoord.x \/ iResolution.x - .5)*3.0*aspectRatio;\n    float yMod = (fragCoord.y \/ iResolution.y - .5)*3.0;\n    vec2 z = vec2(xMod,yMod)*rot*zoom;\n\t\n    \/\/float realSeed = .285+1.*tan(iGlobalTime\/tan(iGlobalTime\/2000.)); \/\/curly + stringy\n    float realSeed = CREAL+.01*tan(iGlobalTime\/2.)+.01*sin(iGlobalTime\/2.);\n    \/\/float realSeed = CREAL;\n    \/\/float imagSeed = CIMAG;\n    float imagSeed = CIMAG +.01*sin(iGlobalTime\/3.0);\n    vec2 C = vec2(realSeed,imagSeed);\n    \/\/vec2 C = vec2(0,0);\n\tfloat x = julia(z,C);\n\tfragColor = vec4(hsv(1.*x+sin(iGlobalTime\/10.), 1., .2+x), 1.0);   \n}\n\n\/\/hsv from gleurop \"The Pulse\", thanks\n\/\/rot from sander \"Texture spin & zoom\", thanks","name":"","description":"","type":"image"}]}}