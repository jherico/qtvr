{"Shader":{"ver":"0.1","info":{"id":"ldj3zG","date":"1391461640","viewed":978,"name":"Pack and Unpack","username":"iq","description":"The classic 32 bit float to 8 bit vec4 packing and unpacking functions that have been floating around the internet for 10 years now. Modified by me. Unkown source.","likes":11,"published":3,"flags":0,"tags":["utility","pack","unpack"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ the classic 1-32-bit-float to 4-8-bit-vec4 packing and unpacking functions that \n\/\/ have been floating around the internet for 10 years now. Unkown source, but\n\/\/ common sense.\n\n\/\/-------------------------------------------------------------------------\n\nconst vec4 bitShL = vec4(16777216.0, 65536.0, 256.0, 1.0);\nconst vec4 bitShR = vec4(1.0\/16777216.0, 1.0\/65536.0, 1.0\/256.0, 1.0);\n\nvec4 pack_F1_UB4( in float value )\n{\n    vec4 res = fract( value*bitShL );\n\tres.yzw -= res.xyz\/256.0;\n\treturn res;\n}\n\nfloat unpack_F1_UB4( in vec4 value )\n{\n    return dot( value, bitShR );\n}\n\n\/\/-------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\t\n\tfloat signal = 0.5 + 0.5*sin(uv.x*50.0 + sin(uv.y*50.0) )*sin(uv.y*40.0 + sin(uv.x*40.0+iGlobalTime) );\n\t\n\t\/\/ pack float to 8 bit vec4\n\tvec4 pa = pack_F1_UB4( signal );\n\n    \/\/ simulate that we are writing to a 8 bit color buffer\t\n\tvec4 buff = floor( 256.0*pa );\n\t\n\t\/\/ simulate that we are reading from a 8 bit color buffer\n\tvec4 unpa = buff \/ 256.0;\n\n    \/\/ unkack from an 8nit vec4, to a float\t \n\tfloat f = unpack_F1_UB4( unpa );\n\t\n\tfragColor = vec4(f,f,f,1.0);\n}","name":"","description":"","type":"image"}]}}