{"Shader":{"ver":"0.1","info":{"id":"4t2Sz3","date":"1445636962","viewed":508,"name":"Fractal Candy","username":"Klems","description":"Rotating candy landscape 3D fractal thingy.","likes":2,"published":3,"flags":0,"tags":["3d","fractal","raymarch"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\n#define PI 3.14159265\n#define FRACTAL_LEVELS 5\n#define OCTANTS 5.0\n\nfloat distToEnd = 0.0;\n\nfloat hash( in float n ) { return fract(sin(n)*753.5453123); }\n\nmat2 rot( in float a ) {\n    float c = cos(a);\n    float s = sin(a);\n\treturn mat2(c,s,-s,c);\t\n}\n\nfloat blend( in float a, in float b ) {\n    float unio = min(a, b);\n    float dist = distance(a, b);\n    float value = max(0.0, 1.0-dist);\n    value *= value;\n    value *= value;\n    value *= value;\n    return unio - value*0.1;\n}\n\nfloat sdSphere( in vec3 p, in float s ) {\n\treturn length(p)-s;\n}\n\n\/\/ this is a capped cone\nfloat sdCappedCone( in vec3 p, in float height, in float widthZero, in float widthHeight ) {\n    vec2 rev = vec2(length(p.xz), p.y);\n    float dist = max(rev.y-height, -rev.y);\n    vec2 norm = normalize(vec2(height, widthZero-widthHeight));\n    float plane = dot(norm, rev-vec2(widthZero, 0.0));\n    return max(dist, plane);\n}\n\nfloat fractal( in vec3 p, in vec2 uv ) {\n    float dist = 99999.9;\n    float scale = 1.0;\n    \n    float displace = dot(uv, vec2(0.1, 0.4));\n    float heightMore = sin(iGlobalTime*0.2+displace)*2.58;\n    mat2 r = rot(-iGlobalTime*0.2);\n    \n    for (int i = 0 ; i < FRACTAL_LEVELS ; i++) {\n        p.xz *= r;\n        float height = 2.0+float(i)*4.0;\n        height += heightMore;\n        height *= scale;\n        dist = blend(dist, sdCappedCone(p, height, 2.2*scale, 2.0*scale));\n        \/\/ set to polar coordinates, get the center;\n       \tfloat theta = (atan(p.z, p.x) \/ PI) * 0.5;\n        theta = (floor(theta*OCTANTS+0.5)\/OCTANTS)*2.0*PI;\n        float radius = -1.2*scale;\n        vec3 center = vec3(cos(theta)*radius, -height, sin(theta)*radius);\n        \/\/ change frame\n        p += center;\n        distToEnd = length(p.xz);\n        \n        p.xz *= rot(p.y-iGlobalTime*scale*0.7);\n        scale \/= 3.0;\n                   \n    }\n    \n   \treturn dist;\n}\n\n\/\/ main distance function\nfloat de(vec3 p) {\n    vec2 uv = floor(p.xz \/ 5.0)+0.5;\n    p.xz = mod(p.xz, 5.0)-2.5;\n    return blend(p.y, fractal( p, uv ));\n} \n\n\/\/ normal function\nvec3 normal(vec3 p) {\n\tvec3 e = vec3(0.0, 0.001, 0.0);\n    float d = de(p);\n\treturn normalize(vec3(\n\t\td-de(p-e.yxx),\n\t\td-de(p-e.xyx),\n\t\td-de(p-e.xxy)));\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = fragCoord.xy \/ iResolution.xy * 2.0 - 1.0;\n\tuv.y *= iResolution.y \/ iResolution.x;\n    \n    vec3 from = vec3(-35.0, 3.5, 0.0);\n\tvec3 dir = normalize(vec3(uv*0.4, 1.0));\n\tdir.xz *= rot(3.1415*.5);\n\t\n\tvec2 mouse=(iMouse.xy \/ iResolution.xy - 0.5) * 0.5;\n\tif (iMouse.z < 1.0) mouse = vec2(0.0);\n\t\n\tmat2 rotxz = rot(sin(iGlobalTime*0.05)*0.352+mouse.x*5.0);\n\tmat2 rotxy = rot(0.25-mouse.y*5.0);\n\t\n\tfrom.xy *= rotxy;\n\tfrom.xz *= rotxz;\n\tdir.xy  *= rotxy;\n\tdir.xz  *= rotxz;\n    \n    from += vec3(4.0, 0.0, 0.5)*iGlobalTime;\n\n\tfloat totdist = 0.0;\n\tbool set = false;\n\tvec3 norm = vec3(0);\n    float stepsCount = 0.0;\n\t\n\tvec3 light = normalize(vec3(1.0, 3.0, 2.0));\n\t\n\tfor (int steps = 0 ; steps < 200 ; steps++) {\n\t\tvec3 p = from + totdist * dir;\n\t\tfloat dist = max(0.0, de(p));\n\t\ttotdist += dist;\n\t\tif (dist < 0.01) {\n\t\t\tset = true;\n\t\t\tnorm = normal(p);\n            stepsCount = float(steps);\n            break;\n\t\t}\n\t}\n    \n    fragColor.a = 1.0;\n    fragColor.rgb = vec3(1);\n    \n    if (set) {\n        fragColor.rgb *= max(0.0, dot(light, norm)) * 0.5 + 0.5;\n        vec3 ref = reflect(light, norm);\n        float spec = max(0.0, dot(dir, ref));\n        spec *= spec; spec *= spec;\n        fragColor.rgb += spec*1.0;\n        fragColor.rgb += smoothstep(0.0, 200.0, stepsCount);\n        fragColor.gb -= distToEnd*4.1;\n    }\n    \n    \/\/ color correct the picture\n    fragColor.rgb = clamp(fragColor.rgb, 0.0, 1.0);\n    float r = fragColor.r;\n    float w = (fragColor.r+fragColor.g+fragColor.b)\/3.0;\n    fragColor.rgb = mix(vec3(0.0), vec3(0.6, 0.8, 0.5), w);\n    fragColor.rgb = mix(vec3(0.4, 0.7, 0.9), fragColor.rgb, r);\n\n}","name":"","description":"","type":"image"}]}}