{"Shader":{"ver":"0.1","info":{"id":"4tfSzS","date":"1437412045","viewed":787,"name":"simulating collisions - array","username":"FabriceNeyret2","description":"the less efficient simulator I ever coded.<br\/>The \"game\" was: GLSL ES only allows for static access 1D arrays. Try doing something with that ;-)<br\/>(that's why most demos are tricking events and their treatments by pure playback cinematics).","likes":0,"published":3,"flags":0,"tags":["simulation","arrays"],"hasliked":0},"renderpass":[{"inputs":[{"id":1,"src":"\/presets\/tex00.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":9,"src":"\/presets\/tex08.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":10,"src":"\/presets\/tex09.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ here: array implementation ( https:\/\/www.shadertoy.com\/view\/4tfSzS ). so slowwww...\n\/\/ simple brick particles : https:\/\/www.shadertoy.com\/view\/ltXXRS\n\/\/ sorted particles : https:\/\/www.shadertoy.com\/view\/llfXRS . the best !\n\n\nfloat time = floor(4.*iGlobalTime);\nfloat T    = mod(time,48.);\nfloat cycl = time-T-827.31; \/\/ floor(time\/48.);\n\nfloat rnd(float x) { return fract(1345.56*sin(876.654*x)); }\nfloat rnd(int i, int j) { return rnd(float(i)-47.45*float(j)); }\n\nint grid[30*20];\n#define grid(j,i) grid[20*int(j)+int(i)]\n#define valid(x,y) ( x>=0 && x<20 && y>=0 && y<30 )\n\n\n\/\/ --- value of grid(y,x)\nint testGrid(int y, int x) { \/\/ horribly greedy (because only static access for arrays)\n    \/\/return 0;\n    if ( !valid(x,y) ) return -1; \n      for (int j=0; j<30; j++)\n          if (j==y)\n       \t\t for (int i=0; i<20; i++)\n            \tif (i==x) return grid(j,i);\n    return -1;\n}\n\n\nvoid mainImage( out vec4 f, vec2 uv )\n{\n    vec2 r = iResolution.xy;\n\tuv = (2.*uv-r) \/ r.y; uv.y = -uv.y;\n\n    \/\/ --- init grid \n    for (int j=0; j<30; j++)\n        for (int i=0; i<20; i++)\n            grid(j,i) = rnd(i,j)>.9 ? 1 : 0;   \n    \n    \/\/ --- init particle\n \tivec2 p, pos = ivec2(10,0), vel=ivec2(0,1);\n\n    \/\/ --- simulation\n    \/\/ horribly greedy : yes, it replays whole time & pos for each pixel at each frame \n    for (float t=0.; t<48.; t++)\n        if (t>T) break; \/\/ future must be kept unknown for the sake of human beings. \n        else {\n            p = pos+vel; \/\/ target new position\n            p.x = p.x<0 ? 19 : p.x >19 ? 0 : p.x; \/\/ cyclical world\n            p.y = p.y<0 ? 29 : p.y >29 ? 0 : p.y;\n            if (testGrid(p.y,p.x)==0) \/\/ free space on trajectory: go, go !\n            { pos = p; vel = ivec2(0,1);}\n            else vel= ivec2(rnd(t+cycl)<.5?-1:1 ,0); \/\/ blocked: jiggle around\n        }\n    \n    \/\/ --- display\n    vec2 fuv = (uv-vec2(-.666,-1))\/2.*30.; \/\/ 20x30 grid, centered, (0,0) top left\n    ivec2 iuv = ivec2(fuv);\n    \n    int v = testGrid(iuv.y,iuv.x); \n    \n    \/\/ out of playfield\n    if (v<0) {  \n\t    \/\/ f = vec4(.5); \n    \tf = .2+.2*texture2D(iChannel1,uv);\n        return;\n    }\n   \n    \/\/ display blocks\n    \/\/ f = vec4(v);\n   \tif (v==0) f = .3*texture2D(iChannel2,uv); else f = texture2D(iChannel0,uv*2.5);\n       \n    \/\/ display particle\n    \/\/if ((pos.x==iuv.x) && (pos.y==iuv.y) )f = vec4(1,0,0,0);\n    f = mix(f, vec4(1,0,T\/48.,0), smoothstep(.5,.4,length(vec2(pos)+.5-fuv)));\n}","name":"","description":"","type":"image"}]}}