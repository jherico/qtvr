{"Shader":{"ver":"0.1","info":{"id":"XdXGW8","date":"1368568320","viewed":2431,"name":"Noise - gradient - 2D","username":"iq","description":"Gradient Noise (. Slightly more expensive than \"Value Noise\" (https:\/\/www.shadertoy.com\/view\/lsf3WH), but higher quality.","likes":34,"published":3,"flags":0,"tags":["procedural","2d","noise","perlin"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Gradient Noise (http:\/\/en.wikipedia.org\/wiki\/Gradient_noise), not to be confused with\n\/\/ Value Noise, and neither with Perlin's Noise (which is one form of Gradient Noise)\n\/\/ is probably the most convenient way to generate noise (a random smooth signal with \n\/\/ mostly all its energy in the low frequencies) suitable for procedural texturing\/shading,\n\/\/ modeling and animation.\n\/\/\n\/\/ It produces smoother and higher quality than Value Noise, but it's of course slighty more\n\/\/ expensive.\n\/\/\n\/\/ The princpiple is to create a virtual grid\/latice all over the plane, and assign one\n\/\/ random vector to every vertex in the grid. When querying\/requesting a noise value at\n\/\/ an arbitrary point in the plane, the grid cell in which the query is performed is\n\/\/ determined (line 32), the four vertices of the grid are determined and their random\n\/\/ vectors fetched (lines 37 to 40). Then, the position of the current point under \n\/\/ evaluation relative to each vertex is doted (projected) with that vertex' random\n\/\/ vector, and the result is bilinearly interpolated (lines 37 to 40 again) with a \n\/\/ smooth interpolant (line 33 and 35).\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\/\/ -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy \/ iResolution.xy;\n\n\tvec2 uv = p*vec2(iResolution.x\/iResolution.y,1.0);\n\t\n\tfloat f = 0.0;\n\t\n    \/\/ left: noise\t\n\tif( p.x<0.6 )\n\t{\n\t\tf = noise( 16.0*uv );\n\t}\n    \/\/ right: fractal noise (4 octaves)\n    else\t\n\t{\n\t\tuv *= 5.0;\n        mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\t\tf  = 0.5000*noise( uv ); uv = m*uv;\n\t\tf += 0.2500*noise( uv ); uv = m*uv;\n\t\tf += 0.1250*noise( uv ); uv = m*uv;\n\t\tf += 0.0625*noise( uv ); uv = m*uv;\n\t}\n\n\tf = 0.5 + 0.5*f;\n\t\n    f *= smoothstep( 0.0, 0.005, abs(p.x-0.6) );\t\n\t\n\tfragColor = vec4( f, f, f, 1.0 );\n}","name":"","description":"","type":"image"}]}}