{"Shader":{"ver":"0.1","info":{"id":"MtsSWM","date":"1437236906","viewed":784,"name":"RM Exp 29 Reduced (1308c)","username":"aiekick","description":"based on <a href=\"https:\/\/www.shadertoy.com\/view\/XlfXDM\"  class=\"regular\" target=\"_blank\">Ray Marching Experiment 29<\/a><br\/>Im trying to reduce the code to < 1000 chars<br\/>i can rename var and func name but the code may be un clear after that. so i search significant decrease","likes":11,"published":3,"flags":0,"tags":["rmexperiment29reduced"],"hasliked":0},"renderpass":[{"inputs":[{"id":27,"src":"\/presets\/cube05_0.png","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Stephane Cuillerdier - Aiekick\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define N normalize\n#define TC(a) textureCube(iChannel0, a)\n\n#define t iGlobalTime\n\n\nfloat gl=0.; \/\/ glow\n\nvec2 RMP = vec2(0.2, 0.05),\/\/ RM Precision L\/H\n    k,\/\/ k.x => ratio, k.y => Density\n    si; \n\nvec3 DP = vec3(1e-3, 12., 1e-8); \/\/ Map Precision Test L\/H\/VL\n\nvec4 map(vec3 p)\n{\n    gl += 1.5e-2;\n            \n    vec4 c = vec4(p,1);\n    \n    \/\/ pattern based on 104 shader https:\/\/www.shadertoy.com\/view\/ltlSW4 \n    vec2 i = c.xz*k.y\/c.y+t;\n    i-=c.xy=ceil(i+=i.x*=.577);\n    c.xy+=step(1.,c.z=mod(c.x+c.y,3.))-step(2.,c.z)*step(i,i.yx);\n    c.z=0.;\n    c=.5+.5*sin(c);     \n    \n    c.w = length(p) -4. + smoothstep(0., 1., dot(c,vec4(k.x))); \/\/ sphere + displace\n    return c.wxyz;\n}\n\n\/\/ c = precision\nvec3 nor( vec3 p, float c )\n{\n    vec2 e = vec2( c, 0. );\n    return N(vec3(\n    map(p+e.xyy).x - map(p-e.xyy).x,\n    map(p+e.yxy).x - map(p-e.yxy).x,\n    map(p+e.yyx).x - map(p-e.yyx).x ));\n}\n\nvec3 cam(vec2 uv, out vec3 ro)\n{\n    ro = vec3(sin(t*.2)*.5, 5.7, cos(t*.2)*.5);\/\/ pixel ray origine\n\tvec3 rov = N(-ro.xyz);\n    vec3 u =  N(cross(vec3(0,1,0), rov));\n    vec3 v =  N(cross(rov, u));\n    return N(rov + u*uv.x + v*uv.y);\n}\n\nvoid mainImage( out vec4 f, in vec2 g )\n{\n    k = vec2(sin(t*.5)*.5+.5,10);\n    \n    vec3 ro, rd = cam((g+g-(si = iResolution.xy))\/si.y, ro);\/\/ pixel ray direction\n    \n    vec3 d = ro*0.,n;\/\/ current \/\/ old \/\/ middle\n    vec3 p = ro+rd*d;\/\/ surface point to pixel ray  \n    vec3 s = vec3(DP.y, sign(map(p).x), 0.);\/\/ map result \/\/ ray march dir \/\/ count iter\n    \n    for(float i=0.;i<1.;i+=1e-3)\n    {      \n\t\tif(s.x<DP.x||s.x>DP.y) break;\n        d.y = d.x;\n        p = ro+rd*(d.x += s.x = map(p).x*(s.x>DP.x?RMP.x:RMP.y));\n        if (sign(s.x) != s.y) break;\n   \t}\n    \n    \/\/ remove artifacts\n    if (sign(s.x) == s.y)\n    {\n    \ts.y = sign(map(p).x);\n        for (float i = 0.; i < 1.; i+=.05)\n        {\n        \ts.z++;\n            p = ro+rd*(d.z = (d.x + d.y)*.5);\n           \td.x += s.x = abs(map(p).x*RMP.y);\n            if (s.x < DP.z) break;\n            (d.x * s.y < 0. )? (d.x = d.z ): (d.y = d.z);\n       \t}\n        d.x = (d.x + d.y) * .5;\n   \t}\n    \n    f = gl * \n        (\n        \td.x<DP.y\n        \t?(TC(reflect(rd, nor(p, 1.\/s.z))) * .6 + map(p).yzww) * .5\n        \t:TC(rd.xyz)\n    \t);\n}\n\n","name":"","description":"","type":"image"}]}}