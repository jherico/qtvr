{"Shader":{"ver":"0.1","info":{"id":"ltlGRX","date":"1423938069","viewed":286,"name":"Albert's Arches","username":"dr2","description":"When moving at relativistic speeds things appear a little different; speed is controlled by the mouse (more information in the source).","likes":5,"published":3,"flags":0,"tags":["einstein","relativity","lorentz"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ \"Albert's Arches\" by dr2 - 2015\n\/\/ License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n\/*\n   An earlier OpenGL version of this program (inspired by a\n   visit to the Einstein centenary exhibition in Berne) used\n   polygon rendering, after applying Lorentz contraction in\n   the direction of the observer's motion. In this raymarched\n   version, ray direction is altered by relativistic\n   aberration, as in iapafoto's \"Relativistic Starter\", but\n   the end result is exactly the same. Geometric aspects are\n   covered, but lighting effects are not included. The mouse\n   controls speed (default 0.9 c).\n*\/\n\nint idObj;\nvec3 qHit, ltDir;\nfloat tCur;\nconst float dstFar = 100.;\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float d, dHit;\n  float nArch = 12.;\n  dHit = dstFar;\n  d = dHit;\n  p.y -= 0.5;\n  q = p;\n  q.z = mod (q.z + 1., 2.) - 1.;\n  d = PrBoxDf (q, vec3 (2., 2., 0.25));\n  q.y -= - 0.5;\n  d = max (d, - PrBoxDf (q, vec3 (1.5, 2., 0.55)));\n  q = p;  q.z -= nArch - 1.;\n  d = max (d, PrBoxDf (q, vec3 (2.2, 2.2, nArch)));\n  if (d < dHit) { dHit = d;  idObj = 1; qHit = q; }\n  q = p;  q.y -= -2.1875;  q.z -= nArch - 1.;\n  d = PrBoxDf (q, vec3 (2.75, 0.0625, nArch));\n  if (d < dHit) { dHit = d;  idObj = 2; qHit = q; }\n  q.x = abs (q.x) - 1.75;  q.y -= 0.125;\n  d = PrBoxDf (q, vec3 (0.5, 0.0625, nArch));\n  if (d < dHit) { dHit = d;  idObj = 3; qHit = q; }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec3 e = 1e-5 * vec3 (1., -1., 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 200; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nfloat CheqCol (vec3 p, vec3 n)\n{\n  p = floor (mod (p, 2.));\n  return dot (abs (n), 0.5 * vec3 (1.) +\n     0.5 * mod (vec3 (p.y + p.z, p.x + p.z, p.x + p.y), 2.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstHit;\n  int idObjT;\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  if (idObj < 0) dstHit = dstFar;\n  if (dstHit >= dstFar) col = vec3 (0., 0., 0.15);\n  else {\n    ro += rd * dstHit;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    if (idObj == 1) col = vec3 (0.8, 0.2, 0.2) * CheqCol (4. * ro, vn);\n    else if (idObj == 2) col = vec3 (0.2, 0.8, 0.2) * CheqCol (ro, vn);\n    else col = vec3 (0.8, 0.8, 0.2) * CheqCol (2. * ro, vn);\n    col = col * (0.5 + 0.5 * max (dot (vn, ltDir), 0.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy \/ iResolution.xy - 1.;\n  vec2 uvs = uv;\n  uv.x *= iResolution.x \/ iResolution.y;\n  tCur = iGlobalTime;\n  vec4 mPtr = iMouse;\n  mPtr.xy = mPtr.xy \/ iResolution.xy - 0.5;\n  float beta, cPhi, w, cLen;\n  vec3 ro, rd, col;\n  ltDir = normalize (vec3 (1., 1., -1.));\n  w = (mPtr.z > 0.) ? clamp (0.5 + mPtr.y, 0.07, 1.) : 0.9;\n  beta = clamp (pow (w, 0.25), 0.1, 0.999);\n  rd = normalize (vec3 (uv, 4.5));\n  cPhi = (rd.z - beta) \/ (1. - rd.z * beta);\n  rd = vec3 (0., 0., cPhi) +\n     sqrt (1. - cPhi * cPhi) * normalize (rd - vec3 (0., 0., rd.z));\n  ro = vec3 (0.);\n  ro.z += (0.3 + 1.7 * beta) * mod (tCur, 10.) - 16. * (1. - beta) - 2.;\n  col = ShowScene (ro, rd);\n  cLen = 0.3;\n  uvs.x = abs (uvs.x - 0.96);\n  if (uvs.x < 0.02 && abs (uvs.y) < cLen) {\n    col = 0.3 * col + 0.5;\n    uvs.y += cLen;\n    if (uvs.x < 0.015 && uvs.y > 0.01 && uvs.y < (2. * cLen - 0.01) *\n       (2. * beta - 1.)) col = vec3 (1., 1., 0.5);\n  }\n  fragColor = vec4 (col, 1.);\n}\n","name":"","description":"","type":"image"}]}}