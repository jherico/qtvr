{"Shader":{"ver":"0.1","info":{"id":"4tl3RM","date":"1420221416","viewed":4114,"name":"Robin ","username":"Dave_Hoskins","description":"The winter Robin - a UK resident bird.<br\/>They occasionally sing at night next to street lights.<br\/>Despite their cute appearance, they are aggressively territorial.<br\/>Update: Background birds now answer back.","likes":77,"published":3,"flags":8,"tags":["3d","raymarching","sound","antialiasing","vr","robin"],"hasliked":0},"renderpass":[{"inputs":[{"id":3,"src":"\/presets\/tex02.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":26,"src":"\/presets\/cube04_0.png","ctype":"cubemap","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"id":27,"src":"\/presets\/cube05_0.png","ctype":"cubemap","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Robin\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ Created by David Hoskins.\n\n\/\/ The winter Robin - a UK resident bird.\n\/\/ They occasionally sing at night next to street lights.\n\/\/ Despite their cute appearance, they are aggressively territorial. \n\n\/\/ Sphere tracing based on eiffie's circle-of-confusion ideas.\n\/\/ Distance estimation shapes, like 'Segment' - thanks to iq.\n\n\/\/--------------------------------------------------------------------------\n#define SUN_COLOUR vec3(1., .76, .6)\n\nvec4 animParts; \/\/ .x = Puff Chest, head tilt, head nod, .w = tweet!\nvec4 body;  \t\/\/ .x = Tilt down, wings, jump, .w = crouching. \nvec2 zoomTurn;  \/\/ Zoom and turn hacked into a vec2 to keep the global vars low.\n\nvec4 aStack[2];\nvec4 dStack[2];\n\n\/\/ CubeMap OpenGL clamping fix, thanks to w23\/reinder...\nvec3 CubeMap(in samplerCube sam, in vec3 v, float size)\n{\n   float M = max(max(abs(v.x), abs(v.y)), abs(v.z));\n   float scale = (float(size) - 1.) \/ float(size);\n   if (abs(v.x) != M) v.x *= scale;\n   if (abs(v.y) != M) v.y *= scale;\n   if (abs(v.z) != M) v.z *= scale;\n   return textureCube(sam, v).xyz;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat Hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nfloat Hash(vec2 p)\n{\n\tp  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4337);\n}\n\n\/\/----------------------------------------------------------------------\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D( iChannel1, (uv+ 0.5)\/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\/\/----------------------------------------------------------------------\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 1.600*noise( p ); p = p*2.02;\n    f += 0.3500*noise( p ); p = p*2.33;\n    f += 0.2250*noise( p ); p = p*2.01;\n    return f;\n}\n\nvec2 Rot2(vec2 p, float a)\n{\n\tfloat si = sin(a);\n\tfloat co = cos(a);\n\treturn mat2(co, si, -si, co) * p;\n}\nfloat Noise(float n)\n{\n    float f = fract(n);\n    n = floor(n);\n    f = f*f*(3.0-2.0*f);\n    return mix(Hash(n), Hash(n+1.0), f);\n   \n}\n\nfloat NoiseSlope(float n, float loc)\n{\n    float f = fract(n);\n    n = floor(n);\n    f = smoothstep(0.0, loc, f);\n    return mix(Hash(n), Hash(n+1.0), f);\n   \n}\n\/\/----------------------------------------------------------------------------------------\nfloat  Sphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 TexCube(in vec3 p, in vec3 n )\n{\n\tvec3 x = texture2D(iChannel0, p.yz ).xzy;\n\tvec3 y = texture2D(iChannel0, p.zx ).xyz;\n    \/\/y = y*y;\n\tvec3 z = texture2D(iChannel1, p.xy, 2.0).yyy;\n\treturn (x*abs(n.x) + y*abs(n.y) + z*abs(n.z))\/(abs(n.x)+abs(n.y)+abs(n.z))*.9;\n}\n\nfloat Cylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat Segment(vec3 p,  vec3 a, vec3 b, float r1, float r2)\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r1 + r2*h;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat RoundBox( vec3 p, vec3 b, float r )\n{\n\treturn length(max(abs(p)-b,0.0))-r;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat sMin( float a, float b, float k )\n{\n    \n\tfloat h = clamp(0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.-h);\n}\n\/\/----------------------------------------------------------------------------------------\nvec3 Colour( vec3 p, vec3 nor, out float spec)\n{\n    vec3 post = p; \n    p.xz = Rot2(p.xz,  zoomTurn.x);\n    vec3 orig = p;\n    p.y-=body.z;\n    p.yz = Rot2(p.yz, body.x);\n    vec3 mat = TexCube(p*.5, nor).zxy * .45;\n    \n\tspec = 0.0;\n    \n    \/\/ Body\n\tfloat d = RoundBox(p-vec3(0.0, -1.4,-.3),vec3(.3+.1*animParts.x, .0, .1+.3*animParts.x), .3);\n    d = sMin(d, Sphere(p-vec3(0.0, -.25,0.0), 1.33), 2.2);\n    \n    \/\/ Wings...\n  \tvec3 p2 = p;\n    p2.x = abs(p2.x);\n    d = sMin(d,Segment(p2,vec3(1.5, -.2,1.7), vec3(1.5, -1.,-1.6), .3, .3), .4);\n    vec3 wing = vec3(.4, 0.32, 0.2)*texture2D(iChannel1, p2.zy*vec2(.05, .3)).x;\n    mat = mix(wing*wing, mat, clamp(Segment(p2,vec3(1.3, 0.2,.2), vec3(1.5+body.y, -1.,-1.6), .4, .4), 0., 1.0));\n    \n    \/\/ Tail...\n    vec3 tail = vec3(.4)*texture2D(iChannel1, p.zy*vec2(.05, .3)).x;\n    mat = mix(tail*tail, mat, clamp(Segment(p2,vec3(.1, -.5, -1.5), vec3(.15, -1.2, -8.0), .2, .2), 0.0, 1.0));\n    \n    p2 = p;\n    p2.xy = Rot2(p2.xy, animParts.y); \/\/ Tilt head\n    p2.zy = Rot2(p2.zy, animParts.z); \/\/ Nod\n   \n    \/\/ Red Breast and head...\n    d = sMin(d, Sphere(p2-vec3(0.0, 1.,1.4), .8), 1.0);\n    float f = Sphere(p-vec3(0.0, -.9, 2.1), 1.5);\n    f = min(f, Sphere(p2-vec3(0.0, .5, 1.9),1.2));\n    f += fbm(p*20.0)*.2;\n   \tf = max(f, -Sphere(p2-vec3(0.0, 2.0, 1.2), 1.1));\n    mat = mix(mat,vec3(.4, .1, 0.0) * (.8+fbm(p*12.)*.2), clamp((d-f)*3.0 - (1.0-step(-3.0, orig.y))*3.0,0.0, 1.0));\n \n    \/\/ Beak...\n    if (d > Segment(p2-vec3(0.0, .9,2.5),vec3(0.0, 0.0,-.4), vec3(.0, animParts.w*.2,.4), .15, .1))\n    {\n        spec = .1;\n        mat = vec3(0.15, 0.12, 0.1);\n    }\n    \/\/ Black shiny eyes\n    p2.x = abs(p2.x);\n    if (Sphere(p2-vec3(.35, 1.1,2.05), .11) < d)\n    {\n    \tmat = vec3(0.);\n        spec = .25;\n    }\n    \/\/ Post...\n    vec3 pCol = mix(vec3(.2), vec3(.05,.04, .0),fbm(post*2.0)*.5);\n    pCol = mix( pCol,vec3(.05), abs(sin( length(post.xz-vec2(0.2, .4))*34.0))*abs(nor.y));\n    mat = mix(pCol,mat, step(-3.4, post.y));\n    \n    \/\/ Legs...\n    orig.y-=body.w;\n    orig.x = abs(orig.x);\n    f = 1.0-clamp(Segment(orig,vec3(0.5, -2.0-body.z,-.5), vec3(.8, -3.5,0.6), .53, .03)+(1.0-step(-3.5,orig.y))*50.0, .0, 1.0);\n    mat = mix( mat, vec3(.05,.02, .02), f);\n    spec = mix(spec, .1, f);\n\n    return mat;\n\n    \n}\n\n\/\/--------------------------------------------------------------------------\n\nfloat Map( vec3 p )\n{\n\tfloat d;\n    vec3 post = p;\n    \n    p.xz = Rot2(p.xz,  zoomTurn.x);\n\tvec3 o = p;\n    \n    p.y-=body.z;\n    p.yz = Rot2(p.yz, body.x);\n    \/\/ Body \n    d = RoundBox(p-vec3(0.0, -1.4,-.3),vec3(.3+.1*animParts.x, .0, .1+.3*animParts.x), .3);\n    d = sMin(d, Sphere(p-vec3(0.0, -.25,0.0), 1.33), 2.2);\n    \n\t\/\/Wings...    \n\tvec3 p2 = p;\n    p2.x = abs(p2.x);\n    d = sMin(d,Segment(p2,vec3(1.3, 0.2,.2), vec3(1.5+body.y, -.5,-1.6), .2, .2), .4);\n  \n   \n    \/\/ Tail...\n    d = sMin(d,Segment(p2,vec3(.6, -.5, -1.5), vec3(.15, -1.2, -8.0), .2, .2), 2.4);\n    \n    \/\/ Rotate head..\n    p.xy = Rot2(p.xy, animParts.y);\n   \tp.zy = Rot2(p.zy, animParts.z);\n   \n    \/\/ Head...\n    d = sMin(d, Sphere(p-vec3(0.0, 1.,1.4), .8), 1.0);\n    \/\/animParts.w = .1;\n    \/\/ Beak...\n    d = sMin(d,Segment(p-vec3(0.0, 1.,2.5),vec3(0.0, 0.0,-.4), vec3(.0, animParts.w*.2,.15), .1, .096), .2);\n    d = sMin(d,Segment(p-vec3(0.0, 1.05,2.5),vec3(0.0, -animParts.w*.25,-1.5), vec3(.0, -animParts.w,.16), .1, .1), .05);\n    \/\/ Eyes...\n    p.x = abs(p.x);\n    d = min(d, Sphere(p-vec3(.35, 1.1,2.05), .11));\n    \/\/ Post...\n\td = min(d, Cylinder(post-vec3(0.2, -12.0, .4), vec2(1.8, 8.5)- fbm(post*5.0)*.1));\n    \/\/ Legs...\n    o.x = abs(o.x);\n    o.y-=body.w;\n    d = min(d, Segment(o,vec3(0.5, -2.+body.z+body.w,-.5), vec3(.8, -3.5,0.5), .09, .1));\n    d = min(d, Segment(o,vec3(.8, -3.5,0.5), vec3(.8, -3.5,1.2), .04, .04));\n    d = min(d, Segment(o,vec3(.8, -3.5,0.5), vec3(1.4, -3.5,0.8), .04, .04));\n    d = min(d, Segment(o,vec3(.8, -3.5,0.5), vec3(.1, -3.5,0.8), .04, .04));\n\n    return d;\n}\n\n\n\/\/--------------------------------------------------------------------------\nfloat Shadow( in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 0.01;\n\tfloat h;\n\t\n    for (int i = 0; i < 8; i++)\n\t{\n\t\th = Map( ro + rd*t );\n\t\tres = min(2.5*h \/ t, res);\n\t\tt += h*.5+.05;\n\t}\n    return max(res, 0.0);\n}\n\n\/\/\/\/--------------------------------------------------------------------------\nvec3 DoLighting(in vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float d, in float specular)\n{\n    vec3 sunLight  = normalize( vec3(  -.1, 0.4,  0.3 ) );\n\tfloat sh = Shadow(pos,  sunLight);\n    \/\/ Light surface with 'sun'...\n\tvec3 col = mat * SUN_COLOUR*(max(dot(sunLight,normal), 0.0)) *sh;\n    \/\/ Ambient...\n    col += mat * CubeMap(iChannel3, normal, 64.0)*.5;\n    \n    normal = reflect(eyeDir, normal); \/\/ Specular...\n    col += pow(max(dot(sunLight, normal), 0.0), 1.0)  * SUN_COLOUR* textureCube(iChannel3, normal).xyz * specular *sh;\n\treturn col;\n}\n\n\n\/\/--------------------------------------------------------------------------\nvec3 GetNormal(vec3 p, float sphereR)\n{\n\tvec2 eps = vec2(.01, 0.0);\n\treturn normalize( vec3(\n           Map(p+eps.xyy) - Map(p-eps.xyy),\n           Map(p+eps.yxy) - Map(p-eps.yxy),\n           Map(p+eps.yyx) - Map(p-eps.yyx) ) );\n}\n\n\/\/--------------------------------------------------------------------------\nfloat SphereRadius(in float t)\n{\n\treturn t*.012;\n\t\/\/return max(t, 4.0\/iResolution.x);\n}\n\n\/\/--------------------------------------------------------------------------\nfloat Scene(in vec3 rO, in vec3 rD, in vec2 fragCoord)\n{\n    \/\/float t = 0.0;\n\tfloat t = 2.+.1 * Hash(fragCoord.xy*fract(iGlobalTime));\n\tfloat  alphaAcc = 0.0;\n\tvec3 p = vec3(0.0);\n    int hits = 0;\n\n\tfor( int j=0; j < 40; j++ )\n\t{\n\t\tif (hits == 8 || alphaAcc >=1.0 || t > 45.0) break;\n\t\tp = rO + t*rD;\n\t\tfloat sphereR = SphereRadius(t);\n\t\tfloat h = Map(p);\n        \/\/ Is it within the sphere?...\n\t\tif( h < sphereR)\n\t\t{\n\t\t\t\/\/ Accumulate the alphas with the scoop of geometry from the sphere...\n            \/\/ Think of it as filling up an expanding ice-cream scoop flying out of the camera! \n\t\t\tfloat alpha = max((1.0 - alphaAcc) * min(((sphereR-h) \/ sphereR), 1.0),0.0);\n\t\t\t\/\/ put it on the 2 stacks, alpha and distance...\n\t\t\taStack[1].yzw = aStack[1].xyz; aStack[1].x = aStack[0].w; aStack[0].yzw = aStack[0].xyz; aStack[0].x = alpha;\n\t\t\tdStack[1].yzw = dStack[1].xyz; dStack[1].x = dStack[0].w; dStack[0].yzw = dStack[0].xyz; dStack[0].x = t;\n\t\t\talphaAcc += alpha;\n\t\t\thits++;\n\t\t}\n\t\tt +=  h*.8;\n\t}\n\treturn clamp(alphaAcc, 0.0, 1.0);\n}\n\n\n\/\/--------------------------------------------------------------------------\nvec3 PostEffects(vec3 rgb, vec2 xy)\n{\n\t\/\/ Gamma first...\n\trgb = sqrt(rgb);\n\n\t\/\/ Then...\n\t#define CONTRAST 1.1\n\t#define SATURATION 1.2\n\t#define BRIGHTNESS 1.15\n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\n\n\t\/\/ Vignette...\n\n\trgb *= .5 +.5* pow(100.0*xy.x*xy.y*(1.0-xy.x)* (1.0-xy.y), 0.4);\t\n\n        \n\treturn clamp(rgb, 0.0, 1.0);\n}\n\n\n\/\/--------------------------------------------------------------------------\nvec3 CameraPath( float t )\n{\n    \/\/t = sin(t*.3);\n    t+= 5.0;\n    vec3 p = vec3(1.4+sin(t)*3.5, -.2, 5.0-+sin(t)*2.5);\n\treturn p;\n} \n\nfloat TweetVolume(float t)\n{\n    float n = NoiseSlope(t*11.0, .1) * abs(sin(t*14.0))*.5;\n    n = (n*smoothstep(0.4, 0.9, NoiseSlope(t*.5+4.0, .1)));\n    return n;\n}\n    \n\n\/\/--------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat m = (iMouse.x\/iResolution.x)*20.0;\n\tfloat gTime = iGlobalTime;\n    vec2 xy = fragCoord.xy \/ iResolution.xy;\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x\/iResolution.y,1.0);\n    \n    float t = mod(gTime, 40.0);\n     zoomTurn.y = smoothstep(6.0, 0.0, t)+smoothstep(39.0, 40.0, t);\n\t\n\tvec3 cameraPos \t= CameraPath(gTime*.2);\n    cameraPos.z +=  zoomTurn.y*8.0;\n    \n\tvec3 camTarget \t= vec3(Noise(gTime*1.9-30.0)*.5-.25,Noise(gTime*2.0)*.5-.3,.0);\n  \n\n\tvec3 cw = normalize(camTarget-cameraPos);\n\tvec3 cp = vec3(0.0, 1.0, 0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = cross(cu,cw);\n\tvec3 dir = normalize(uv.x*cu + uv.y*cv + (1.0-  zoomTurn.y*.4)*cw);\n    \n   \t\/\/ Puff Chest...\n    animParts.x = Noise(gTime*2.0)+1.0;\n    \/\/ head tilt...\n    animParts.y = (NoiseSlope(gTime*1.2+sin(gTime*.3)*.7+.7, .05)-.5)* 1.5;\n    \/\/ Nod...\n    animParts.z = (NoiseSlope(gTime*.4-33.0, .05))* .5;\n    \/\/ Tweet...\n\n    animParts.w = TweetVolume(gTime)*.8+.02;\n    body.x  = sin(NoiseSlope(gTime*.5, .3)*4.14) *.25+.25;\n    body.y  = NoiseSlope(gTime*.73, .3);\n    t = mod(gTime*2., 15.0);\n    body.z = -(smoothstep(0.0, .5, t)* smoothstep(.6,.5, t )) * .5;\n    animParts.z -= body.z; \n    body.y = body.z;\n    float jump = smoothstep(0.4, .6, t)* smoothstep(.8,.6, t ) * .8;\n    body.z += jump;\n    body.w = jump;\n    zoomTurn.x = smoothstep(0.4, .8, t);\n    if (mod(gTime*2.0, 30.0) >= 15.0)\n    {\n\t\t zoomTurn.x = 1.0- zoomTurn.x;\n    }\n\tvec3 col = vec3(.0);\n\t\n    for (int i = 0; i <2; i++)\n    {\n\t\tdStack[i] = vec4(-20.0);\n        aStack[i] = vec4(0.0);\n    }\n\tfloat alpha = Scene(cameraPos, dir, fragCoord);\n    \n    \/\/ Render both stacks...\n    for (int s = 0; s < 2; s++)\n    {\n        for (int i = 0; i < 4; i++)\n        {\n            float specular = 0.0;\n            \n            float d = dStack[s][i];\n            if (d < 0.0) continue;\n            float sphereR = SphereRadius(d);\n            vec3 pos = cameraPos + dir * d;\n            vec3 normal = GetNormal(pos, sphereR);\n            vec3 alb = Colour(pos, normal, specular);\n            col += DoLighting(alb, pos, normal, dir, d, specular)* aStack[s][i];\n\t\t}\n    }\n    \/\/ Fill in the rest with woodland background...\n    float mi = smoothstep(1.9, .0,  zoomTurn.y);\n    vec3 back = mix(CubeMap(iChannel2, dir, 128.0), CubeMap(iChannel3, dir, 64.0)*.7, mi);\n    col += back* back*SUN_COLOUR*  (1.0-alpha);\n    \n\n\tcol = PostEffects(col, xy) * smoothstep(.0, 2.0, iGlobalTime);\t\n\t\n\tfragColor=vec4(col,1.0);\n}\n","name":"","description":"","type":"image"},{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Robin\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ Created by David Hoskins.\n\n\/\/ Random pitch movements plus a high speed warble cut into three phrases. \n\/\/ Background leafy wind noise plus stereo answer calls from the trees.\n\nfloat Hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\/\/----------------------------------------------------------------------------------------\nvec2 Hash(vec2 p)\n{\n\tp  = fract(p * vec2(1.3983, 1.4427));\n    p += dot(p.yx, p.xy +  vec2(3.5351, 4.3137));\n\treturn fract(vec2(p.x * p.y * 5.4337, p.x * p.y * 7.597));\n}\n\n\nfloat Noise(float n)\n{\n    float f = fract(n);\n    n = floor(n);\n    f = f*f*(3.0-2.0*f);\n    return mix(Hash(n), Hash(n+1.0), f)-.5;\n   \n}\n\nfloat NoiseSlope(float n, float loc)\n{\n    float f = fract(n);\n    n = floor(n);\n    f = smoothstep(0.0, loc, f);\n    return mix(Hash(n), Hash(n+1.0), f);\n}\n\n\/\/--------------------------------------------------------------------------\nvec2 Noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 res = mix(mix( Hash(p + 0.0), Hash(p + vec2(1.0, 0.0)),f.x),\n                   mix( Hash(p + vec2(0.0, 1.0) ), Hash(p + vec2(1.0, 1.0)),f.x),f.y);\n    return res-.5;\n}\n\n\/\/--------------------------------------------------------------------------\nvec2 FBM( vec2 p )\n{\n    p = mod(p, 200.0);\n    vec2 f;\n\tf  = 0.5000\t * Noise(p); p = p * 3.;\n\tf += 0.2500  * Noise(p); p = p * 3.;\n\tf += 0.1250  * Noise(p); p = p * 3.;\n    f += 0.062125 * Noise(p); p = p * 3.;\n    return f;\n}\n\n\nfloat TweetVolume(float t)\n{\n    float n = NoiseSlope(t*11.0, .1) * abs(sin(t*14.0))*.5;\n    n = (n*smoothstep(0.4, 0.9, NoiseSlope(t*.5+4.0, .1)));\n    return min(n*n * 2.0, 1.0);\n}\n\nfloat Tweet(float t)\n{\n    float which = mod(floor(t\/3.0), 3.0);\n    t = mod(t, 3.0);\n    float f;\n    \/\/ which = 1.5;\n    \/\/ Divided into three different phrases...\n    if (which >= 2.0)\n    {\n        t = 1.5-t;\n        f = sin(6.2831*2.5*t)*Noise(t*14.3+3.0)*100.0+5000.0;\n        f += cos(50.0*6.2831*t);\n        f = sin(6.2831*f*t);\n    }else\n    if (which >= 1.0)\n    {\n        t = 1.5-t;\n        f = (sin(6.2831*3.0*t)*Noise(t*12.5))*100.0+4500.0;\n        f += cos(50.0*6.2831*t);\n        f = sin(6.2831*f*t);\n    }else\n    {\n        t = t - 1.5;\n       \tf = sin(6.2831*2.0*t)*Noise(t*8.1-100.0)*100.0+5000.0;\n        f += cos(50.0*6.2831*t);\n        f = sin(6.2831*f*t);\n    }\n    return f;\n}\n\nvec2 mainSound(float time)\n{\n    \n    float gTime= time;\n    vec2 pos = vec2(gTime * (1250.5), gTime * (1200.2));\n    vec2 noise = FBM(pos)* .15 + FBM(pos*8.0)* (.1*Noise(gTime*.4)+.1);\n    \n    float volume = TweetVolume(gTime);\n    \n    vec2 audio =  (vec2(Tweet(gTime)) * volume + noise) * smoothstep(.0, 2.0, time) * smoothstep(60.0, 55.0, time);\n    audio += vec2( Tweet(gTime+300.0)* TweetVolume(gTime+300.0), Tweet(gTime+120.0)* TweetVolume(gTime+220.0))* .08;\n    return audio;\n}","name":"","description":"","type":"sound"}]}}