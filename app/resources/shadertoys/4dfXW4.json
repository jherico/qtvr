{"Shader":{"ver":"0.1","info":{"id":"4dfXW4","date":"1453087464","viewed":205,"name":"Feature Extraction","username":"paniq","description":"using techniques described in https:\/\/www.graphics.rwth-aachen.de\/media\/papers\/feature1.pdf and http:\/\/www.sandboxie.com\/misc\/isosurf\/isosurfaces.html to identify and extract surface features","likes":8,"published":3,"flags":0,"tags":["mattdamon"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ marching cube on dual grid visualization\n\/\/ -- @paniq\n\n#define GRIDRES 10\n\n#ifdef GLSLSANDBOX\n#ifdef GL_ES\nprecision mediump float;\n#endif\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define iGlobalTime time\n#define iResolution resolution\n#endif\n\n\/\/ interface\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ set color source for stroke \/ fill \/ clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source(sampler2D image);\n\n\/\/ set line width in normalized units for stroke\nvoid set_line_width(float w);\n\/\/ set line width in pixels for stroke\nvoid set_line_width_px(float w);\n\/\/ set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n\/\/ add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n\/\/ add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n\n\/\/ set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n\/\/ draw straight line from starting point to P,\n\/\/ and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n\/\/ draw quadratic bezier curve from starting point\n\/\/ over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n\/\/ connect current starting point with first\n\/\/ drawing point.\nvoid close_path();\n\n\/\/ clear screen in the current source color\nvoid clear();\n\/\/ fill paths and clear the path buffer\nvoid fill();\n\/\/ fill paths and preserve them for additional ops\nvoid fill_preserve();\n\/\/ stroke paths and clear the path buffer\nvoid stroke_preserve();\n\/\/ stroke paths and preserve them for additional ops\nvoid stroke();\n\/\/ clears the path buffer\nvoid new_path();\n\n\/\/ return rgb color for given hue (0..1)\nvec3 hue(float hue);\n\/\/ return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n\/\/ rotate the context by A in radians\nvoid rotate(float a);\n\/\/ uniformly scale the context by S\nvoid scale(float s);\n\/\/ translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n\/\/ clear all transformations for the active context\nvoid identity_matrix();\n\/\/ transform the active context by the given matrix\nvoid transform(mat3 mtx);\n\/\/ set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n\/\/ represents the current drawing context\n\/\/ you usually don't need to change anything here\nstruct Context {\n    vec2 position;\n    float scale;\n    float shape;\n    float line_width;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n};\n    \n\/\/ save current source color, stroke width and starting\n\/\/ point from active context.\nContext save();\n\/\/ restore source color, stroke width and starting point\n\/\/ to a context previously returned by save()\nvoid restore(Context ctx);\n\n\/\/ draws a half-transparent debug gradient for the\n\/\/ active path\nvoid debug_gradient();\n\nvoid paint();\n\n\/\/ implementation\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec2 aspect = vec2(iResolution.x \/ iResolution.y, 1.0);\nvec2 uv;\nvec2 position;\nfloat ScreenH = min(iResolution.x,iResolution.y);\nfloat AA = ScreenH*0.4;\nfloat AAINV = 1.0 \/ AA;\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec3 hue(float hue) {\n    return clamp( \n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, \n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define DEFAULT_SHAPE_V 1e+20\n    \nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    uv = fragCoord.xy \/ iResolution.xy;\n    \n     position = (uv*2.0-1.0)*aspect;\n    _stack = Context(\n        position, 1.0,\n        DEFAULT_SHAPE_V,\n        1.0,\n        vec2(AA,0.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0)\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nContext save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    \/\/ preserve shape\n    float shape = _stack.shape;\n    _stack = ctx;\n    _stack.shape = shape;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 \/ d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = position;\n    _stack.scale = 1.0;\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position = (mtx * vec3(position,1.0)).xy;\n    _stack.scale = length(vec2(mtx[0].x,mtx[1].y));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position = (mtx * vec3(_stack.position,1.0)).xy;\n    vec2 u = vec2(mtx[0].x, mtx[1].x);\n    _stack.scale *= length(u);\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(float s) {\n    transform(mat3(s,0.0,0.0,0.0,s,0.0,0.0,0.0,1.0));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid add(float d) {\n    _stack.shape = min(_stack.shape, d \/ _stack.scale);\n}\n\nvoid new_path() {\n    _stack.shape = DEFAULT_SHAPE_V;\n}\n\nvoid debug_gradient() {\n    _color = mix(_color, \n        hsl(_stack.shape * 6.0, \n            1.0, (_stack.shape>=0.0)?0.5:0.3), \n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(AA, 0.0);\n        return;\n    }\n    float a = 1.0 \/ max(AAINV, b);\n    _stack.blur = vec2(\n        a,\n        0.0); \/\/ 0 = blur ends at outline, 1 = blur starts at outline\n}\n\nvoid fill_preserve() {\n    float w = clamp(-_stack.shape*AA, 0.0, 1.0);\n    _color = mix(_color, _stack.source.rgb, w * _stack.source.a);\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*_stack.scale\/AA;\n}\n\nvoid stroke_preserve() {\n    float w = abs(_stack.shape)- _stack.line_width\/_stack.scale;\n    vec2 blur = _stack.blur;\/\/ \/ _stack.scale;\n    w = clamp(-w*blur.x + blur.y, 0.0, 1.0);\n    _color = mix(_color, _stack.source.rgb, w * _stack.source.a);\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nvoid set_source_rgba(vec4 c) {\n    _stack.source = c;\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) { \n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture2D(image, _stack.position));\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    s*=0.5;\n    o = o - _stack.position + s;\n    vec2 d = abs(o) - s;\n    add(min(max(d.x,d.y),0.0) + length(max(d,0.0)));\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rectangle(vec2(ox,oy), vec2(sx,sy));\n}\n\nvoid circle(vec2 p, float r) {\n    add(length(_stack.position - p) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n\/\/ stroke only\nvoid line_to(vec2 p) {\n    vec2 pa = _stack.position - _stack.last_pt;\n    vec2 ba = p - _stack.last_pt;\n    float h = clamp(dot(pa, ba)\/dot(ba,ba), 0.0, 1.0);\n    add(length(pa - ba*h));\n    \n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n\/\/ from \"Random-access rendering of general vector graphics\"\n\/\/ by Nehab and Hoppe\n\/\/ only quadratic, not cubic\nvoid curve_to(vec2 b1, vec2 b2)\n{\n    vec2 b0 = _stack.last_pt - _stack.position;\n\t_stack.last_pt = b2;\n    b1 -= _stack.position;\n    b2 -= _stack.position;\n    float a=det(b0,b2), b=2.0*det(b1,b0), d=2.0*det(b2,b1);\n    float f=b*d-a*a;\n    vec2 d21=b2-b1, d10=b1-b0, d20=b2-b0;\n    vec2 gf=2.0*(b*d21+d*d10+a*d20);\n    gf=vec2(gf.y,-gf.x);\n    vec2 pp=-f*gf\/dot(gf,gf);\n    vec2 d0p=b0-pp;\n    float ap=det(d0p,d20), bp=2.0*det(d10,d0p);\n    float t=clamp((ap+bp)\/(2.0*a+b+d), 0.0, 1.0);\n    add(length(mix(mix(b0,b1,t),mix(b1,b2,t),t)));\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init(fragCoord);\n    \n    paint();\n    \n    fragColor = vec4(_color.xyz, 1.0);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat box(vec3 p, vec3 size) {\n\tvec3 d = abs(p) - size;\n    \n\tvec3 dm = max(d, 0.0);\n    \n    return min(max(d.x,max(d.y,d.z)),0.0) + length(dm);\n}\n\nfloat sphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat plane(vec3 p, vec4 n) {\n\treturn dot(p,n.xyz) - n.w;\n}\n\n\/\/ c must be normalized\nfloat cone(vec3 p, vec2 a, float l) {\n    return max(max(a.x*length(p.xy)+a.y*p.z, p.z), abs(p.z)-l);\n}\n\nvec2 ms = ((iMouse.xy\/iResolution.xy)*2.0-1.0) * aspect;\n\nvec3 rotate(vec3 p, float a) {\n\tfloat sa = sin(a);\n\tfloat ca = cos(a);\n\treturn vec3(\n\t\tp.x*ca - p.z*sa,\n\t\t0.0,\n\t\tp.x*sa + p.z*ca\n\t);\n}\n\n#if 0 \/\/ R functions\n\nfloat r_min(float a, float b) {\n\treturn a + b - sqrt(a*a+b*b);\n}\n\nfloat r_max(float a, float b) {\n\treturn a + b + sqrt(a*a+b*b);\n}\n\n\n#else \/\/ boolean\n\nfloat r_min(float a, float b) {\n\treturn min(a,b);\n}\n\nfloat r_max(float a, float b) {\n\treturn max(a,b);\n}\n\n#endif\n\nfloat map(vec3 p) {\n\tfloat w = plane(p, vec4(0.0,0.0,1.0,-0.6));\n\tfloat s = sphere(p - vec3(1.0,0.0,0.0), 0.5);\n\tfloat s2 = sphere(p - vec3(0.67,0.0,0.0), 0.2);\n\tfloat c = cone(p - vec3(-0.5,0.0,-0.3), normalize(vec2(1.0,0.5)), 0.5);\n\tfloat b = box(rotate(p - vec3(-0.5,0.0,0.2),iGlobalTime), vec3(0.3,1.0,0.1));\n\treturn r_min(b, r_min(c, r_min(r_max(s,-s2),w)));\n}\n\nfloat map(vec2 p) {\n\treturn map(vec3(p.x, 0.0, p.y));\n}\n\nvec3 grad0(vec3 p, float e) {\n\tvec2 d = vec2(0.0, e);\n\treturn -vec3(\n\t\tmap(p + d.yxx) - map(p - d.yxx),\n\t\tmap(p + d.xyx) - map(p - d.xyx),\n\t\tmap(p + d.xxy) - map(p - d.xxy));\n}\n\nconst float ERR = 1e-2;\nvec3 grad(vec3 p) {\n\treturn grad0(p,ERR) \/ (2.0 * ERR);\n}\n\n\nvec2 grad2d(vec3 p) {\n\tvec2 d = vec2(0.0, 1e-3);\n\treturn normalize(vec2(\n\t\tmap(p + d.yxx) - map(p - d.yxx),\n\t\tmap(p + d.xxy) - map(p - d.xxy)));\n}\n\nvec2 grad2d(vec2 p) {\n\treturn grad2d(vec3(p.x,0.0,p.y));\n}\n\nvoid arrow(vec2 u, vec2 n) {\n\tvec2 o = vec2(n.y, -n.x);\n\tmove_to(u);\n\tu += n;\n\tline_to(u);\n\tmove_to(u - o*0.2);\n\tline_to(u + o*0.2);\n\tline_to(u + n*0.4);\n\tclose_path();\n}\n\nfloat mlen(vec2 c) {\n\tc = abs(c);\n\treturn max(c.x, c.y);\n}\n\nfloat mlen(vec3 c) {\n\tc = abs(c);\n\treturn max(c.x, max(c.y, c.z));\n}\n\nbool gravitymarch(vec3 ro, float maxt, out vec3 p) {\n\tfloat precis = 0.001;\n\tfloat h = 1000.0;\n\tp = ro;\n\tfor(int i = 0; i < 5; i++) {\n\t\tif(abs(h) < precis || length(p - ro) > maxt) break;\n\t\th = map(p);\n\t\tvec2 n = grad2d(p);\n\t\tp.xz -= n*h;\n\t}\t\n\treturn (abs(h) < precis);\n}\n\n\n\nvec3 sigcolor(float k) {\n\treturn hue(clamp(-k,-1.0,1.0)*0.3333+0.6667);\n}\n\n\/\/ minimal SVD implementation for calculating feature points from hermite data\n\/\/ works in C++ and GLSL\n\n\/\/ public domain\n\n#define USE_GLSL 1\n\n#define DEBUG_SVD 0\n\n#define SVD_NUM_SWEEPS 10\n\n\/\/ GLSL prerequisites\n\n#define IN(t,x) in t x\n#define OUT(t, x) out t x\n#define INOUT(t, x) inout t x\n#define rsqrt inversesqrt\n\n#define SWIZZLE_XYZ(v) v.xyz\n\n\/\/ SVD\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst float Tiny_Number = 1.e-20;\n\nvoid givens_coeffs_sym(float a_pp, float a_pq, float a_qq, OUT(float,c), OUT(float,s)) {\n    if (a_pq == 0.0) {\n        c = 1.0;\n        s = 0.0;\n        return;\n    }\n    float tau = (a_qq - a_pp) \/ (2.0 * a_pq);\n    float stt = sqrt(1.0 + tau * tau);\n    float tan = 1.0 \/ ((tau >= 0.0) ? (tau + stt) : (tau - stt));\n    c = rsqrt(1.0 + tan * tan);\n    s = tan * c;\n}\n\nvoid svd_rotate_xy(INOUT(float,x), INOUT(float,y), IN(float,c), IN(float,s)) {\n    float u = x; float v = y;\n    x = c * u - s * v;\n    y = s * u + c * v;\n}\n\nvoid svd_rotateq_xy(INOUT(float,x), INOUT(float,y), INOUT(float,a), IN(float,c), IN(float,s)) {\n    float cc = c * c; float ss = s * s;\n    float mx = 2.0 * c * s * a;\n    float u = x; float v = y;\n    x = cc * u - mx + ss * v;\n    y = ss * u + mx + cc * v;\n}\n\nvoid svd_rotate01(INOUT(mat3,vtav), INOUT(mat3,v)) {\n    if (vtav[0][1] == 0.0) return;\n    \n    float c, s;\n    givens_coeffs_sym(vtav[0][0], vtav[0][1], vtav[1][1], c, s);\n    svd_rotateq_xy(vtav[0][0],vtav[1][1],vtav[0][1],c,s);\n    svd_rotate_xy(vtav[0][2], vtav[1][2], c, s);\n    vtav[0][1] = 0.0;\n    \n    svd_rotate_xy(v[0][0], v[0][1], c, s);\n    svd_rotate_xy(v[1][0], v[1][1], c, s);\n    svd_rotate_xy(v[2][0], v[2][1], c, s);\n}\n\nvoid svd_rotate02(INOUT(mat3,vtav), INOUT(mat3,v)) {\n    if (vtav[0][2] == 0.0) return;\n    \n    float c, s;\n    givens_coeffs_sym(vtav[0][0], vtav[0][2], vtav[2][2], c, s);\n    svd_rotateq_xy(vtav[0][0],vtav[2][2],vtav[0][2],c,s);\n    svd_rotate_xy(vtav[0][1], vtav[1][2], c, s);\n    vtav[0][2] = 0.0;\n    \n    svd_rotate_xy(v[0][0], v[0][2], c, s);\n    svd_rotate_xy(v[1][0], v[1][2], c, s);\n    svd_rotate_xy(v[2][0], v[2][2], c, s);\n}\n\nvoid svd_rotate12(INOUT(mat3,vtav), INOUT(mat3,v)) {\n    if (vtav[1][2] == 0.0) return;\n    \n    float c, s;\n    givens_coeffs_sym(vtav[1][1], vtav[1][2], vtav[2][2], c, s);\n    svd_rotateq_xy(vtav[1][1],vtav[2][2],vtav[1][2],c,s);\n    svd_rotate_xy(vtav[0][1], vtav[0][2], c, s);\n    vtav[1][2] = 0.0;\n    \n    svd_rotate_xy(v[0][1], v[0][2], c, s);\n    svd_rotate_xy(v[1][1], v[1][2], c, s);\n    svd_rotate_xy(v[2][1], v[2][2], c, s);\n}\n\nvoid svd_solve_sym(IN(mat3,a), OUT(vec3,sigma), INOUT(mat3,v)) {\n    \/\/ assuming that A is symmetric: can optimize all operations for \n    \/\/ the upper right triagonal\n    mat3 vtav = a;\n    \/\/ assuming V is identity: you can also pass a matrix the rotations\n    \/\/ should be applied to\n    \/\/ U is not computed\n    for (int i = 0; i < SVD_NUM_SWEEPS; ++i) {\n        svd_rotate01(vtav, v);\n        svd_rotate02(vtav, v);\n        svd_rotate12(vtav, v);\n    }\n    sigma = vec3(vtav[0][0],vtav[1][1],vtav[2][2]);    \n}\n\nfloat svd_invdet(float x, float tol) {\n    return (abs(x) < tol || abs(1.0 \/ x) < tol) ? 0.0 : (1.0 \/ x);\n}\n\nvoid svd_pseudoinverse(OUT(mat3,o), IN(vec3,sigma), IN(mat3,v)) {\n    float d0 = svd_invdet(sigma[0], Tiny_Number);\n    float d1 = svd_invdet(sigma[1], Tiny_Number);\n    float d2 = svd_invdet(sigma[2], Tiny_Number);\n    o = mat3(v[0][0] * d0 * v[0][0] + v[0][1] * d1 * v[0][1] + v[0][2] * d2 * v[0][2],\n             v[0][0] * d0 * v[1][0] + v[0][1] * d1 * v[1][1] + v[0][2] * d2 * v[1][2],\n             v[0][0] * d0 * v[2][0] + v[0][1] * d1 * v[2][1] + v[0][2] * d2 * v[2][2],\n             v[1][0] * d0 * v[0][0] + v[1][1] * d1 * v[0][1] + v[1][2] * d2 * v[0][2],\n             v[1][0] * d0 * v[1][0] + v[1][1] * d1 * v[1][1] + v[1][2] * d2 * v[1][2],\n             v[1][0] * d0 * v[2][0] + v[1][1] * d1 * v[2][1] + v[1][2] * d2 * v[2][2],\n             v[2][0] * d0 * v[0][0] + v[2][1] * d1 * v[0][1] + v[2][2] * d2 * v[0][2],\n             v[2][0] * d0 * v[1][0] + v[2][1] * d1 * v[1][1] + v[2][2] * d2 * v[1][2],\n             v[2][0] * d0 * v[2][0] + v[2][1] * d1 * v[2][1] + v[2][2] * d2 * v[2][2]);\n}\n\nvoid svd_solve_ATA_ATb(\n    IN(mat3,ATA), IN(vec3,ATb), OUT(vec3,x)\n) {\n    mat3 V = mat3(1.0);\n    vec3 sigma;\n    \n    svd_solve_sym(ATA, sigma, V);\n    \n    mat3 Vinv;\n    svd_pseudoinverse(Vinv, sigma, V);\n    x = Vinv * ATb;\n}\n\nvec3 svd_vmul_sym(IN(mat3,a), IN(vec3,v)) {\n    return vec3(\n        dot(a[0],v),\n        (a[0][1] * v.x) + (a[1][1] * v.y) + (a[1][2] * v.z),\n        (a[0][2] * v.x) + (a[1][2] * v.y) + (a[2][2] * v.z)\n    );\n}\n\n\/\/ QEF\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvoid qef_add(\n    IN(vec3,n), IN(vec3,p),\n    INOUT(mat3,ATA), \n    INOUT(vec3,ATb),\n    INOUT(vec4,pointaccum))\n{\n    ATA[0][0] += n.x * n.x;\n    ATA[0][1] += n.x * n.y;\n    ATA[0][2] += n.x * n.z;\n    ATA[1][1] += n.y * n.y;\n    ATA[1][2] += n.y * n.z;\n    ATA[2][2] += n.z * n.z;\n\n    float b = dot(p, n);\n    ATb += n * b;\n    pointaccum += vec4(p,1.0);\n}\n\nfloat qef_calc_error(IN(mat3,A), IN(vec3, x), IN(vec3, b)) {\n    vec3 vtmp = b - svd_vmul_sym(A, x);\n    return dot(vtmp,vtmp);\n}\n\nfloat qef_solve(\n    IN(mat3,ATA), \n    IN(vec3,ATb),\n    IN(vec4,pointaccum),\n    OUT(vec3,x)\n) {\n    vec3 masspoint = SWIZZLE_XYZ(pointaccum) \/ pointaccum.w;\n    ATb -= svd_vmul_sym(ATA, masspoint);\n    svd_solve_ATA_ATb(ATA, ATb, x);\n    float result = qef_calc_error(ATA, x, ATb);\n    \n    x += masspoint;\n        \n    return result;\n}\n\nvoid find_contours(vec4 rc) {\n\tvec2 p[4];\n\tvec2 c[4];\n\tfloat d[4];\n\tfloat z[4];\n\tp[0] = rc.xy;\t\n\tp[1] = rc.zy;\t\n\tp[2] = rc.zw;\t\n\tp[3] = rc.xw;\t\n\tfor (int i = 0; i < 4; ++i) {\n\t\td[i] = map(p[i]);\n\t}\n\t\n\tz[0] = (-d[0] \/ (d[1]-d[0]));\n\tz[1] = (-d[1] \/ (d[2]-d[1]));\n\tz[2] = (-d[2] \/ (d[3]-d[2]));\n\tz[3] = (-d[3] \/ (d[0]-d[3]));\n\t\n\tc[0] = p[0] + (p[1]-p[0])*z[0];\n\tc[1] = p[1] + (p[2]-p[1])*z[1];\n\tc[2] = p[2] + (p[3]-p[2])*z[2];\n\tc[3] = p[3] + (p[0]-p[3])*z[3];\n\t\n\tvec2 mp[4];\n\tvec2 mg[4];\n\tint mc = 0;\n\t\n    mat3 ATA = mat3(0.0);\n    vec3 ATb = vec3(0.0);\n    vec4 pointaccum = vec4(0.0);\n    \n\tfor (int i = 0; i < 4; ++i) {\n\t\tif (z[i] < 0.0 || z[i] > 1.0) continue;\n\t\t\n\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\tif (k != mc) continue;\n\t\t\tmp[k] = c[i];\n\t\t\tvec2 g = grad2d(c[i]);\n\t\t\tmg[k] = g;\n\t\t\tarrow(c[i], g*0.1);\n\t\t\tstroke();\n\t\t\tmc += 1;\n            \n            qef_add(\n                vec3(g,0.0), vec3(c[i],0.0),\n                ATA, ATb, pointaccum);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tconst float O_sharp = 0.9;\n\tfloat min_ma = 1e+20;\n\tvec2 n0,n1;\n\t\n\t\n\tfor (int i = 0; i < 4; ++i) {\n\t\tfor (int j=0; j < 4; ++j) {\n\t\t\tif (i >= mc || j >= mc) continue;\n\t\t\tfloat ma = dot(mg[i].xy,mg[j].xy);\n\t\t\tif (ma < min_ma) {\n\t\t\t\tmin_ma = ma;\n\t\t\t\tn0 = mg[i];\n\t\t\t\tn1 = mg[j];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (min_ma < O_sharp) {\n \t\tvec3 x;\n        qef_solve(ATA, ATb, pointaccum, x);\n        \n        set_source_rgb(vec3(1.0,0.0,0.0));\n\t\tcircle(x.x, x.y, 0.01);\n\t\tstroke();\n        \n\t\tset_source_rgb(vec3(0.5,1.0,0.5));\n\t} else {\n\t\tset_source_rgb(vec3(1.0,1.0,0.5));\n\t}\n\t\n\trectangle(rc.xy, rc.zw-rc.xy);\n\tstroke();\n\t\n\t\n}\n\nvoid paint() {\n\tvec3 mp = vec3(position.x,0.0,position.y);\n\n\t\/\/ clear screen\n\t\n\tset_source_rgb(vec3(0.0,0.0,0.5));\n\tclear();\n\n\tset_line_width_px(1.0);\n\t\n\tfloat d = map(mp);\n\t_stack.shape = d;\n\tset_source_rgb(vec3(1.0));\n\t\/\/fill_preserve();\n\tstroke();\n\t\n\tset_source_rgb(vec3(0.5,0.5,1.0));\n\tset_line_width_px(1.0);\n\tfor (int i = 0; i < 5; ++i) {\n\t\t_stack.shape = d-float(i)*0.05-mod(iGlobalTime*0.01,0.05);\n\t\tstroke();\n\t}\n\t\n\tfloat fc = 0.05;\n\tvec4 rc = vec4(ms - fc, ms + fc);\n\t\n\tfind_contours(rc);\n}\n","name":"","description":"","type":"image"}]}}