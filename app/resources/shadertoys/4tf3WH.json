{"Shader":{"ver":"0.1","info":{"id":"4tf3WH","date":"1422724737","viewed":759,"name":"Crash Crystal 1","username":"janneasdf","description":"Crystal from Crash Bandicoot games","likes":0,"published":3,"flags":0,"tags":["3d","raytracing"],"hasliked":0},"renderpass":[{"inputs":[{"id":17,"src":"\/presets\/tex12.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Shader parameters\nfloat crystalScale = 0.1;\n\n\/\/ Material types\nconst int OBJECT_NONE = 0;\nconst int OBJECT_CRYSTAL = 1;\nconst int OBJECT_ICE = 2;\n\n\/\/ Helper variables and functions\nconst float INF = 1e10;\nbool debug = false;\nconst float PI = 3.14159265359;\n\nfloat perlin(vec2 coords, int octaves, float gain, float freq, float amplitude)\n{\n    float p = 0.0;\n    const int max_octaves = 20;\n    for (int i = 0; i < max_octaves; ++i)\n    {\n        if (i >= octaves)\n            break;\n        p += texture2D(iChannel0, vec2(coords.x * freq, coords.y * freq)).r * amplitude;\n        amplitude *= gain;\n        freq *= 1.0 \/ gain;\n    }\n    return p;   \n}\n\n\/\/ Shader initialization\nvec3 crystal[24 * 3];\nvec3 cv[14];\nvoid initCrystalGeometry()\n{\n    cv[0] = vec3(0.401617, 0.465089, -0.401617);\n\tcv[1] = vec3(-0.401617, 0.465089, 0.401617);\n\tcv[2] = vec3(1.000000, 5.081155, -0.999999);\n\tcv[3] = vec3(0.999999, 5.081155, 1.000001);\n\tcv[4] = vec3(-1.000000, 5.081155, 1.000000);\n\tcv[5] = vec3(-1.000000, 5.081155, -1.000000);\n\tcv[6] = vec3(0.401617, 0.465089, 0.401617);\n\tcv[7] = vec3(-0.401617, 0.465089, -0.401618);\n\tcv[8] = vec3(0.000000, -0.11153, -0.000000);\n\tcv[9] = vec3(0.000000, 6.290121, -1.166347);\n\tcv[10] = vec3(1.163836, 6.290121, 0.000001);\n\tcv[11] = vec3(-0.000000, 6.290121, 1.166347);\n\tcv[12] = vec3(-1.163836, 6.290121, 0.000000);\n\tcv[13] = vec3(-0.000000, 8.061562, 0.000000);\n    \n    crystal[0] = cv[10]; crystal[1] = cv[11]; crystal[2] = cv[3]; \n    crystal[3] = cv[10]; crystal[4] = cv[2]; crystal[5] = cv[9]; \n    crystal[6] = cv[9]; crystal[7] = cv[5]; crystal[8] = cv[12]; \n    crystal[9] = cv[11]; crystal[10] = cv[12]; crystal[11] = cv[4]; \n    crystal[12] = cv[5]; crystal[13] = cv[7]; crystal[14] = cv[12]; \n    crystal[15] = cv[11]; crystal[16] = cv[6]; crystal[17] = cv[3]; \n    crystal[18] = cv[10]; crystal[19] = cv[3]; crystal[20] = cv[6]; \n    crystal[21] = cv[2]; crystal[22] = cv[10]; crystal[23] = cv[0]; \n    crystal[24] = cv[2]; crystal[25] = cv[0]; crystal[26] = cv[9]; \n    crystal[27] = cv[9]; crystal[28] = cv[7]; crystal[29] = cv[5]; \n    crystal[30] = cv[1]; crystal[31] = cv[7]; crystal[32] = cv[8]; \n    crystal[33] = cv[6]; crystal[34] = cv[1]; crystal[35] = cv[8]; \n    crystal[36] = cv[7]; crystal[37] = cv[0]; crystal[38] = cv[8]; \n    crystal[39] = cv[0]; crystal[40] = cv[6]; crystal[41] = cv[8]; \n    crystal[42] = cv[12]; crystal[43] = cv[11]; crystal[44] = cv[13]; \n    crystal[45] = cv[11]; crystal[46] = cv[10]; crystal[47] = cv[13]; \n    crystal[48] = cv[9]; crystal[49] = cv[12]; crystal[50] = cv[13]; \n    crystal[51] = cv[10]; crystal[52] = cv[9]; crystal[53] = cv[13]; \n    crystal[54] = cv[7]; crystal[55] = cv[1]; crystal[56] = cv[12]; \n    crystal[57] = cv[12]; crystal[58] = cv[1]; crystal[59] = cv[4]; \n    crystal[60] = cv[11]; crystal[61] = cv[4]; crystal[62] = cv[1]; \n    crystal[63] = cv[1]; crystal[64] = cv[6]; crystal[65] = cv[11]; \n    crystal[66] = cv[0]; crystal[67] = cv[10]; crystal[68] = cv[6]; \n    crystal[69] = cv[0]; crystal[70] = cv[7]; crystal[71] = cv[9];\n    \n    for (int i = 0; i < 24; ++i)\n    {\n        crystal[i*3] = crystalScale * crystal[i*3];\n        crystal[i*3+1] = crystalScale * crystal[i*3+1];\n        crystal[i*3+2] = crystalScale * crystal[i*3+2];\n    }\n}\n\nstruct RayHit\n{\n\tfloat t;\n    vec3 rayDir;\n    vec3 n;\n    vec2 uv;\n    float mirror;\t\/\/ mirroring factor\n    int material;\n};\n    \nstruct TriangleHit\n{\n\tfloat t;\n    vec2 uv;\n    vec3 n;\n};\n\n\/\/ (Slightly modified) GLSL ray-triangle intersection code \n\/\/ from http:\/\/undernones.blogspot.fi\/2010\/12\/gpu-ray-tracing-with-glsl.html\nTriangleHit intersectTriangle(vec3 rayPos, vec3 rayDir, vec3 v0, vec3 v1, vec3 v2)\n{\n    TriangleHit hit;\n    vec3 u, v, n; \/\/ triangle vectors\n    vec3 w0, w;  \/\/ ray vectors\n    float r, a, b; \/\/ params to calc ray-plane intersect\n\n    \/\/ get triangle edge vectors and plane normal\n    u = v1 - v0;\n    v = v2 - v0;\n    n = cross(u, v);\n\n    w0 = rayPos - v0;\n    a = -dot(n, w0);\n    b = dot(n, rayDir);\n    if (abs(b) < 1e-5)\n    {\n        \/\/ ray is parallel to triangle plane, and thus can never intersect.\n        hit.t = INF;\n        return hit;\n    }\n\n    \/\/ get intersect point of ray with triangle plane\n    r = a \/ b;\n    if (r < 0.0)\n    {\n        hit.t = INF;\n        return hit; \/\/ ray goes away from triangle.\n    }\n\n    vec3 I = rayPos + r * rayDir;\n    float uu, uv, vv, wu, wv, D;\n    uu = dot(u, u);\n    uv = dot(u, v);\n    vv = dot(v, v);\n    w = I - v0;\n    wu = dot(w, u);\n    wv = dot(w, v);\n    D = uv * uv - uu * vv;\n\n    \/\/ get and test parametric coords\n    float s, t;\n    s = (uv * wv - vv * wu) \/ D;\n    if (s < 0.0 || s > 1.0)\n    {\n        hit.t = INF;\n        return hit;\n    }\n    t = (uv * wu - uu * wv) \/ D;\n    if (t < 0.0 || (s + t) > 1.0)\n    {\n        hit.t = INF;\n        return hit;\n    }\n\n    hit.uv = vec2(s, t);\n    hit.n = n;\n    hit.t = (r > 1e-5) ? r : INF;\n    return hit;\n}\n\nTriangleHit intersectPlane(vec3 rayPos, vec3 rayDir, vec3 planeNormal, vec3 planePoint)\n{\n    TriangleHit hit;\n    float nl = dot(planeNormal, rayDir);\n    if (abs(nl) < 0.001)\n        hit.t = INF;\n    else\n        hit.t = dot(planePoint - rayPos, planeNormal) \/ nl;\n    return hit;\n}\n\n\/\/ Shader specific functions\nRayHit traceRay(vec3 rayPos, vec3 rayDir)\n{\n    RayHit hit;\n    hit.rayDir = rayDir;\n    hit.mirror = 0.0;\n    TriangleHit triHit;\n    hit.material = OBJECT_NONE;\n    float tMin = INF;\n    float t;\n    \n    \/\/ Trace the ice\n    vec3 planeNormal = normalize(vec3(0.0, 1.0, 0.0));\n    vec3 planePoint = vec3(0.0, 0.0, 0.0);\t\/\/ any point on the plane\n    triHit = intersectPlane(rayPos, rayDir, planeNormal, planePoint);\n    vec3 p = rayPos + triHit.t * rayDir;\n    if (triHit.t >= 0.0 && triHit.t < tMin && abs(p.x) < 0.8 && abs(p.z) < 0.8)\n    {\n    \ttMin = triHit.t;\n        hit.uv = (rayPos + triHit.t * rayDir).xz; \/\/ todo: account for plane_n != 0,1,0\n        hit.n = planeNormal;\n        hit.material = OBJECT_ICE;\n        hit.mirror = 0.5;\n    }\n    \n    \/\/ Trace crystal triangles\n    for (int i = 0; i < 24; ++i)\n    {\n        triHit = intersectTriangle(rayPos, rayDir, crystal[i*3], crystal[i*3+1], crystal[i*3+2]);\n        if (triHit.t < tMin)\n        {\n        \ttMin = triHit.t;\n            hit.uv = triHit.uv;\n            hit.n = triHit.n;\n            hit.mirror = 0.0;\n            hit.material = OBJECT_CRYSTAL;\n        }\n    }\n    hit.n = normalize(hit.n);\n    hit.t = tMin;\n    return hit;\n}\n\nfloat uvDistanceFromEdge(vec2 uv)\n{\n\treturn min(uv.x, min(uv.y, 1.0 - uv.x - uv.y));\n}\n\nvec3 shadeCrystal(RayHit hit)\n{\n    vec3 c = vec3(0.5, 0.1, 0.3) * 1.25;\n    float nl = max(dot(hit.n, -hit.rayDir), 0.0);\n    c = nl * c;\n    \n    return c;\n}\n\nvec3 shadeIce(RayHit hit)\n{\n    vec3 c;\n\tvec3 blue = vec3(0.2, 0.4, 0.86) * 1.85;\n    \n    \/\/ Create the procedural texture\n    c = blue;\n    float angle = PI \/ 6.0;\n    vec2 coords = hit.uv;\n    coords.x = cos(angle) * coords.x - sin(angle) * coords.y;\n    coords.y = sin(angle) * coords.x + cos(angle) * coords.y;\n    coords = vec2(5.0 * coords.x, 1.4 * coords.y);\n    float p = perlin(coords, 6, 0.5, 1.0 \/ 256.0, 0.5);\n    p += perlin(coords, 10, 0.5, 1.0 \/ 256.0, 0.5);\n    p *= 0.5;\n    c *= p;\n    c *= 2.5;\n    c += 0.2;\n    float nl = max(dot(hit.n, -hit.rayDir), 0.0);\n    c = nl * c;\n    \n    return c;\n}\n\nvec3 shadeMaterial(RayHit hit)\n{\n    vec3 shade;\n    if (hit.material == OBJECT_NONE)\n    {\n    \tshade = vec3(0.0, 0.0, 0.0);\n    }\n    else if (hit.material == OBJECT_CRYSTAL)\n    {\n    \tshade = shadeCrystal(hit); \t   \n    }\n    else if (hit.material == OBJECT_ICE)\n    {\n        shade = shadeIce(hit);\n    }\n    return shade;\n}\n\nfloat distPointRay(vec3 p, vec3 rayPos, vec3 rayDir)\n{\n    return length(cross(rayDir, p - rayPos));\n}\n\nvec3 getColor(vec3 rayPos, vec3 rayDir)\n{\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    vec3 origRayPos = rayPos;\n    vec3 origRayDir = rayDir;\n    RayHit hit = traceRay(rayPos, rayDir);\n    float mirror = hit.mirror;\n    vec3 shade = shadeMaterial(hit);\n    color += shade;\n    if (hit.material == OBJECT_ICE)\n    {\n        rayPos = rayPos + hit.t * rayDir;\n        rayPos += 0.001 * hit.n;\n        rayDir = reflect(rayDir, hit.n);\n        hit = traceRay(rayPos, rayDir);\n        shade = shadeMaterial(hit);\n        color *= 1.0;\n        color += 0.8 * shade;\n    }\n    \/\/ Glow\n    float glow = 0.0;\n    float d;\n    float a = 100.0;\n    float b = 10.0;\n    float c = 10.0;\n    float g;\n    for (int i = 0; i < 14; ++i)\n    {\n        d = distPointRay(crystalScale * cv[i], origRayPos, origRayDir);\n        g = 1.0 \/ (a*d*d + b*d + c);\n        glow += g;\n    }\n    color += glow * vec3(0.5, 0.1, 0.3);\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    \n    float aspect = iResolution.x \/ iResolution.y;\n    uv -= .5;\n    uv.x *= aspect;\n    \n    float time = iGlobalTime;\n    float camDistance = 1.2;\n    if (iMouse.z > 0.0 || iMouse.w > 0.0) camDistance = 1.5;\n    float camSpeed = 0.4;\n    vec3 camDir = normalize(vec3(sin(time * camSpeed), -0.3, cos(time * camSpeed)));\n    vec3 camTarget = vec3(0.0, 0.4, 0.0);\n    vec3 camPos = camTarget - camDir * camDistance;\n    vec3 camUp = vec3(0.0, 1.0, 0.0);\n    vec3 camRight = normalize(cross(camUp, camDir));\n    camUp = normalize(cross(camDir, camRight));\n    \n    vec3 rayPos = camPos;\n    vec3 rayDir = normalize(camDir + uv.x * camRight + uv.y * camUp);\n    \n    initCrystalGeometry();\n    \n    vec3 c;\n    c = getColor(rayPos, rayDir);\n    \n    if (debug)\t\/\/ Debug activated during getColor\n    {\n        if (fract(iGlobalTime * 4.0) < 0.5)\n        \tc = vec3(0.0);\n        else\n        \tc = vec3(1.0);\n    }\n    \n    fragColor = vec4(c, 1.0);\n}","name":"","description":"","type":"image"}]}}