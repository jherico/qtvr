{"Shader":{"ver":"0.1","info":{"id":"XssGz8","date":"1362517016","viewed":2705,"name":"post: Barrel Blur Chroma","username":"hornet","description":"Simulates Chromatic Aberration by linearly interpolating blur-weights from red to green to blue.<br\/>Original idea by Kusma: https:\/\/github.com\/kusma\/vlee\/blob\/master\/data\/postprocess.fx","likes":45,"published":3,"flags":0,"tags":["chroma","blur","filter","post"],"hasliked":0},"renderpass":[{"inputs":[{"id":11,"src":"\/presets\/vid00.ogv","ctype":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"float linterp( float t ) {\n\treturn clamp( 1.0 - abs( 2.0*t - 1.0 ), 0.0, 1.0 );\n}\n\nfloat remap( float t, float a, float b ) {\n\treturn clamp( (t - a) \/ (b - a), 0.0, 1.0 );\n}\nvec2 remap( vec2 t, vec2 a, vec2 b ) {\n\treturn clamp( (t - a) \/ (b - a), 0.0, 1.0 );\n}\n\nvec3 spectrum_offset_rgb( float t ) {\n\tvec3 ret;\n\tfloat lo = step(t,0.5);\n\tfloat hi = 1.0-lo;\n\tfloat w = linterp( remap( t, 1.0\/6.0, 5.0\/6.0 ) );\n\tret = vec3(lo,1.0,hi) * vec3(1.0-w, w, 1.0-w);\n\n\treturn pow( ret, vec3(1.0\/2.2) );\n}\n\nconst float gamma = 2.2;\nvec3 lin2srgb( vec3 c )\n{\n    return pow( c, vec3(gamma) );\n}\nvec3 srgb2lin( vec3 c )\n{\n    return pow( c, vec3(1.0\/gamma));\n}\n\n\nvec3 yCgCo2rgb(vec3 ycc)\n{\n    float R = ycc.x - ycc.y + ycc.z;\n\tfloat G = ycc.x + ycc.y;\n\tfloat B = ycc.x - ycc.y - ycc.z;\n    return vec3(R,G,B);\n}\n\nvec3 spectrum_offset_ycgco( float t )\n{\n\t\/\/vec3 ygo = vec3( 1.0, 1.5*t, 0.0 ); \/\/green-pink\n    \/\/vec3 ygo = vec3( 1.0, -1.5*t, 0.0 ); \/\/green-purple\n    vec3 ygo = vec3( 1.0, 0.0, -1.25*t ); \/\/cyan-orange\n    \/\/vec3 ygo = vec3( 1.0, 0.0, 1.5*t ); \/\/brownyello-blue\n    return yCgCo2rgb( ygo );\n}\n\nvec3 yuv2rgb( vec3 yuv )\n{\n    vec3 rgb;\n    rgb.r = yuv.x + yuv.z * 1.13983;\n    rgb.g = yuv.x + dot( vec2(-0.39465, -0.58060), yuv.yz );\n    rgb.b = yuv.x + yuv.y * 2.03211;\n    return rgb;\n}\n\n\n\/\/ ====\n\n\/\/note: from https:\/\/www.shadertoy.com\/view\/XslGz8\nvec2 radialdistort(vec2 coord, vec2 amt)\n{\n\tvec2 cc = coord - 0.5;\n\treturn coord + 2.0 * cc * amt;\n}\n\n\/\/ Given a vec2 in [-1,+1], generate a texture coord in [0,+1]\nvec2 barrelDistortion( vec2 p, vec2 amt )\n{\n    p = 2.0 * p - 1.0;\n\n    \/*\n    const float maxBarrelPower = 5.0;\n\t\/\/note: http:\/\/glsl.heroku.com\/e#3290.7 , copied from Little Grasshopper\n    float theta  = atan(p.y, p.x);\n    vec2 radius = vec2( length(p) );\n    radius = pow(radius, 1.0 + maxBarrelPower * amt);\n    p.x = radius.x * cos(theta);\n    p.y = radius.y * sin(theta);\n\n\t\/*\/\n    \/\/ much faster version\n    \/\/const float maxBarrelPower = 5.0;\n    \/\/float radius = length(p);\n    const float maxBarrelPower = sqrt(5.0);\n    float radius = dot(p,p); \/\/faster but doesn't match above accurately\n    p *= pow(vec2(radius), maxBarrelPower * amt);\n\t\/* *\/\n\n    return p * 0.5 + 0.5;\n}\n\n\/\/note: from https:\/\/www.shadertoy.com\/view\/MlSXR3\nvec2 brownConradyDistortion(vec2 uv, float dist)\n{\n    uv = uv * 2.0 - 1.0;\n    \/\/ positive values of K1 give barrel distortion, negative give pincushion\n    float barrelDistortion1 = 0.1 * dist; \/\/ K1 in text books\n    float barrelDistortion2 = -0.025 * dist; \/\/ K2 in text books\n\n    float r2 = dot(uv,uv);\n    uv *= 1.0 + barrelDistortion1 * r2 + barrelDistortion2 * r2 * r2;\n    \/\/uv *= 1.0 + barrelDistortion1 * r2;\n    \n    \/\/ tangential distortion (due to off center lens elements)\n    \/\/ is not modeled in this function, but if it was, the terms would go here\n    return uv * 0.5 + 0.5;\n}\n\nvec2 distort( vec2 uv, float t, vec2 min_distort, vec2 max_distort )\n{\n    vec2 dist = mix( min_distort, max_distort, t );\n    \/\/return radialdistort( uv, 2.0 * dist );\n    \/\/return barrelDistortion( uv, 1.75 * dist ); \/\/distortion at center\n    return brownConradyDistortion( uv, 75.0 * dist.x );\n}\n\n\/\/ ====\n\nvec3 spectrum_offset_yuv( float t )\n{\n\t\/\/vec3 yuv = vec3( 1.0, 3.0*t, 0.0 ); \/\/purple-green\n    \/\/vec3 yuv = vec3( 1.0, 0.0, 2.0*t ); \/\/purple-green\n    vec3 yuv = vec3( 1.0, 0.0, -1.0*t ); \/\/cyan-orange\n    \/\/vec3 yuv = vec3( 1.0, -0.75*t, 0.0 ); \/\/brownyello-blue\n    return yuv2rgb( yuv );\n}\n\nvec3 spectrum_offset( float t )\n{\n    return spectrum_offset_rgb( t );\n    \/\/return spectrum_offset_ycgco( t );\n    \/\/return spectrum_offset_yuv( t );\n}\n\n\/\/ ====\n\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 uv = fragCoord.xy\/iResolution.xy;\n    \n    const float MAX_DIST_PX = 20.0;\n    float max_distort_px = MAX_DIST_PX * (1.0-iMouse.x\/iResolution.x);\n\tvec2 max_distort = vec2(max_distort_px) \/ iResolution.xy;\n    vec2 min_distort = 0.5 * max_distort;\n\n    \/\/vec2 oversiz = vec2(1.0);\n    vec2 oversiz = distort( vec2(1.0), 1.0, min_distort, max_distort );\n    uv = remap( uv, 1.0-oversiz, oversiz );\n    \n    \/\/debug oversiz\n    \/\/vec2 distuv = distort( uv, 1.0, max_distort );\n    \/\/if ( abs(distuv.x-0.5)>0.5 || abs(distuv.y-0.5)>0.5)\n    \/\/{\n    \/\/    fragColor = vec4( 1.0, 0.0, 0.0, 1.0 ); return;\n    \/\/}\n    \n\tvec3 sumcol = vec3(0.0);\n\tvec3 sumw = vec3(0.0);\n    float rnd = nrand( uv + fract(iGlobalTime) );\n    const int num_iter = 16;\n\tfor ( int i=0; i<num_iter;++i )\n\t{\n\t\tfloat t = (float(i)+rnd) \/ float(num_iter-1);\n\t\tvec3 w = spectrum_offset( t );\n\t\tsumw += w;\n\t\tsumcol += w * srgb2lin(texture2D( iChannel0, distort(uv, t, min_distort, max_distort ) ).rgb);\n\t}\n    sumcol.rgb \/= sumw;\n\t\n    vec3 outcol = lin2srgb(sumcol.rgb);\n    outcol += rnd\/255.0;\n    \n\tfragColor = vec4( outcol, 1.0);\n}\n","name":"","description":"","type":"image"}]}}