{"Shader":{"ver":"0.1","info":{"id":"XdXGRB","date":"1372701127","viewed":2442,"name":"Pangram","username":"Dave_Hoskins","description":"Some text display code I took from Sandbox, thanks Dan!<br\/>I've edited some of the letters and removed repeated line segments, and added a moving caret.<br\/>I was going to do more phrases, but it ran out of memory because of the same old Windows story.<br\/><br\/>","likes":63,"published":3,"flags":0,"tags":["2d","text","font","alphabet","pangram"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Source edited by David Hoskins - 2013.\n\n\/\/ I took and completed this http:\/\/glsl.heroku.com\/e#9743.20 - just for fun! 8|\n\/\/ Locations in 3x7 font grid, inspired by http:\/\/www.claudiocc.com\/the-1k-notebook-part-i\/\n\/\/ Had to edit it to remove some duplicate lines.\n\/\/ ABC  a:GIOMJL b:AMOIG c:IGMO d:COMGI e:OMGILJ f:CBN g:OMGIUS h:AMGIO i:EEHN j:GHTS k:AMIKO l:BN m:MGHNHIO n:MGIO\n\/\/ DEF  o:GIOMG p:SGIOM q:UIGMO r:MGI s:IGJLOM t:BNO u:GMOI v:GJNLI w:GMNHNOI x:GOKMI y:GMOIUS z:GIMO\n\/\/ GHI\n\/\/ JKL \n\/\/ MNO\n\/\/ PQR\n\/\/ STU\n\nvec2 coord;\n\n#define font_size 20. \n#define font_spacing .05\n#define STROKEWIDTH 0.05\n#define PI 3.14159265359\n\n#define A_ vec2(0.,0.)\n#define B_ vec2(1.,0.)\n#define C_ vec2(2.,0.)\n\n\/\/#define D_ vec2(0.,1.)\n#define E_ vec2(1.,1.)\n\/\/#define F_ vec2(2.,1.)\n\n#define G_ vec2(0.,2.)\n#define H_ vec2(1.,2.)\n#define I_ vec2(2.,2.)\n\n#define J_ vec2(0.,3.)\n#define K_ vec2(1.,3.)\n#define L_ vec2(2.,3.)\n\n#define M_ vec2(0.,4.)\n#define N_ vec2(1.,4.)\n#define O_ vec2(2.,4.)\n\n\/\/#define P_ vec2(0.,5.)\n\/\/#define Q_ vec2(1.,5.)\n\/\/#define R_ vec2(1.,5.)\n\n#define S_ vec2(0.,6.)\n#define T_ vec2(1.,6.)\n#define U_ vec2(2.0,6.)\n\n#define A(p) t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p) + t(M_,J_,p) + t(J_,L_,p)\n#define B(p) t(A_,M_,p) + t(M_,O_,p) + t(O_,I_, p) + t(I_,G_,p)\n#define C(p) t(I_,G_,p) + t(G_,M_,p) + t(M_,O_,p) \n#define D(p) t(C_,O_,p) + t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p)\n#define E(p) t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p) + t(I_,L_,p) + t(L_,J_,p)\n#define F(p) t(C_,B_,p) + t(B_,N_,p) + t(G_,I_,p)\n#define G(p) t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p) + t(I_,U_,p) + t(U_,S_,p)\n#define H(p) t(A_,M_,p) + t(G_,I_,p) + t(I_,O_,p) \n#define I(p) t(E_,E_,p) + t(H_,N_,p) \n#define J(p) t(E_,E_,p) + t(H_,T_,p) + t(T_,S_,p)\n#define K(p) t(A_,M_,p) + t(M_,I_,p) + t(K_,O_,p)\n#define L(p) t(B_,N_,p)\n#define M(p) t(M_,G_,p) + t(G_,I_,p) + t(H_,N_,p) + t(I_,O_,p)\n#define N(p) t(M_,G_,p) + t(G_,I_,p) + t(I_,O_,p)\n#define O(p) t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p) + t(M_,G_,p)\n#define P(p) t(S_,G_,p) + t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p)\n#define Q(p) t(U_,I_,p) + t(I_,G_,p) + t(G_,M_,p) + t(M_,O_, p)\n#define R(p) t(M_,G_,p) + t(G_,I_,p)\n#define S(p) t(I_,G_,p) + t(G_,J_,p) + t(J_,L_,p) + t(L_,O_,p) + t(O_,M_,p)\n#define T(p) t(B_,N_,p) + t(N_,O_,p) + t(G_,I_,p)\n#define U(p) t(G_,M_,p) + t(M_,O_,p) + t(O_,I_,p)\n#define V(p) t(G_,J_,p) + t(J_,N_,p) + t(N_,L_,p) + t(L_,I_,p)\n#define W(p) t(G_,M_,p) + t(M_,O_,p) + t(N_,H_,p) + t(O_,I_,p)\n#define X(p) t(G_,O_,p) + t(I_,M_,p)\n#define Y(p) t(G_,M_,p) + t(M_,O_,p) + t(I_,U_,p) + t(U_,S_,p)\n#define Z(p) t(G_,I_,p) + t(I_,M_,p) + t(M_,O_,p)\n#define STOP(p) t(N_,N_,p)\n\t\nvec2 caret_origin = vec2(3.0, .7);\nvec2 caret;\nfloat time = mod(iGlobalTime, 11.0);\n\n\/\/-----------------------------------------------------------------------------------\nfloat minimum_distance(vec2 v, vec2 w, vec2 p)\n{\t\/\/ Return minimum distance between line segment vw and point p\n  \tfloat l2 = (v.x - w.x)*(v.x - w.x) + (v.y - w.y)*(v.y - w.y); \/\/length_squared(v, w);  \/\/ i.e. |w-v|^2 -  avoid a sqrt\n  \tif (l2 == 0.0) {\n\t\treturn distance(p, v);   \/\/ v == w case\n\t}\n\t\n\t\/\/ Consider the line extending the segment, parameterized as v + t (w - v).\n  \t\/\/ We find projection of point p onto the line.  It falls where t = [(p-v) . (w-v)] \/ |w-v|^2\n  \tfloat t = dot(p - v, w - v) \/ l2;\n  \tif(t < 0.0) {\n\t\t\/\/ Beyond the 'v' end of the segment\n\t\treturn distance(p, v);\n\t} else if (t > 1.0) {\n\t\treturn distance(p, w);  \/\/ Beyond the 'w' end of the segment\n\t}\n  \tvec2 projection = v + t * (w - v);  \/\/ Projection falls on the segment\n\treturn distance(p, projection);\n}\n\n\/\/-----------------------------------------------------------------------------------\nfloat textColor(vec2 from, vec2 to, vec2 p)\n{\n\tp *= font_size;\n\tfloat inkNess = 0., nearLine, corner;\n\tnearLine = minimum_distance(from,to,p); \/\/ basic distance from segment, thanks http:\/\/glsl.heroku.com\/e#6140.0\n\tinkNess += smoothstep(0., 1., 1.- 14.*(nearLine - STROKEWIDTH)); \/\/ ugly still\n\tinkNess += smoothstep(0., 2.5, 1.- (nearLine  + 5. * STROKEWIDTH)); \/\/ glow\n\treturn inkNess;\n}\n\n\/\/-----------------------------------------------------------------------------------\nvec2 grid(vec2 letterspace) \n{\n\treturn ( vec2( (letterspace.x \/ 2.) * .65 , 1.0-((letterspace.y \/ 2.) * .95) ));\n}\n\n\/\/-----------------------------------------------------------------------------------\nfloat count = 0.0;\nfloat t(vec2 from, vec2 to, vec2 p) \n{\n\tcount++;\n\tif (count > time*20.0) return 0.0;\n\treturn textColor(grid(from), grid(to), p);\n}\n\n\/\/-----------------------------------------------------------------------------------\nvec2 r()\n{\n\tvec2 pos = coord.xy\/iResolution.xy;\n\tpos.y -= caret.y;\n\tpos.x -= font_spacing*caret.x;\n\treturn pos;\n}\n\n\/\/-----------------------------------------------------------------------------------\nvoid add()\n{\n\tcaret.x += 1.0;\n}\n\n\/\/-----------------------------------------------------------------------------------\nvoid space()\n{\n\tcaret.x += 1.5;\n}\n\n\/\/-----------------------------------------------------------------------------------\nvoid newline()\n{\n\tcaret.x = caret_origin.x;\n\tcaret.y -= .18;\n}\n\n\/\/-----------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat d = 0.;\n\tvec3 col = vec3(0.1, .07+0.07*(.5+sin(fragCoord.y*3.14159*1.1+time*2.0)) + sin(fragCoord.y*.01+time+2.5)*0.05, 0.1);\n    \n    coord = fragCoord;\n\t\n\tcaret = caret_origin;\n\n\t\/\/ the quick brown fox jumps over the lazy dog...\n\td += T(r()); add(); d += H(r()); add(); d += E(r()); space();\n\td += Q(r()); add(); d += U(r()); add(); d += I(r()); add(); d += C(r()); add(); d += K(r()); space();\n\td += B(r()); add(); d += R(r()); add(); d += O(r()); add(); d += W(r()); add(); d += N(r()); space();\n\tnewline();\n\td += F(r()); add(); d += O(r()); add(); d += X(r()); space();\n\td += J(r()); add(); d += U(r()); add(); d += M(r()); add(); d += P(r()); add(); d += S(r()); space();\n\td += O(r()); add(); d += V(r()); add(); d += E(r()); add(); d += R(r()); space();\n\tnewline();\n\td += T(r()); add(); d += H(r()); add(); d += E(r()); space();\n\td += L(r()); add(); d += A(r()); add(); d += Z(r()); add(); d += Y(r()); space();\n\td += D(r()); add(); d += O(r()); add(); d += G(r()); add(); d += STOP(r()); add(); d += STOP(r()); add(); d += STOP(r());\n\td = clamp(d* (.75+sin(fragCoord.x*PI*.5-time*4.3)*.5), 0.0, 1.0);\n      \n    col += vec3(d*.5, d, d*.85);\n\tvec2 xy = fragCoord.xy \/ iResolution.xy;\n\tcol *= vec3(.4, .4, .3) + 0.5*pow(100.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), .4 );\t\n    fragColor = vec4( col, 1.0 );\n}\n","name":"","description":"","type":"image"}]}}