{"Shader":{"ver":"0.1","info":{"id":"llsXD8","date":"1436516238","viewed":759,"name":"Cell Merge (prototype)","username":"W_Master","description":"very inefficient code, also contains glitches, want to make a better one with similar result.<br\/>click to interact.","likes":2,"published":3,"flags":0,"tags":["2d","circle","glitched","inefficient"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define sin60 0.86602540378\n\n#define clicksize 1.0\n\nvec3 color_bg = vec3(0.0,0.0,0.0);\nvec3 color_inner = vec3(1.0,1.0,0.0);\nvec3 color_outer = vec3(0.5,0.8,0.3);\n\nfloat getVolume(vec2 localPos, float radius)\n{\n    localPos = abs(localPos);\n    \n    vec2 maxPos = localPos + vec2(0.5);\n    \n    float rr2 = radius * radius;\n    \n    if( dot(maxPos, maxPos) <= rr2)\n    {\n        return 1.0;\n    }\n    \n    vec2 minPos = localPos - vec2(0.5);\n    if( dot(minPos, minPos) >= rr2)\n    {\n        return 0.0;\n    }\n    \n    vec2 pA, pB;\n    \/\/ pA\n    if( sqrt(radius * radius - minPos.x * minPos.x) > maxPos.y)\n    {\n        pA = vec2(sqrt(rr2 - maxPos.y * maxPos.y) , maxPos.y);\n    }\n    else\n    {\n        pA = vec2(minPos.x, sqrt(rr2 - minPos.x * minPos.x));\n    }\n    \/\/pB\n    if( sqrt(radius * radius - minPos.y * minPos.y) > maxPos.x)\n    {\n        pB = vec2( maxPos.x, sqrt(rr2 - maxPos.x * maxPos.x));\n    }\n    else\n    {\n        pB = vec2( sqrt(rr2 - minPos.y * minPos.y), minPos.y);\n    }\n    \n    vec2 block = abs(pB-pA);\n    float areaTri = (block.x * block.y) \/ 2.0;\n    \n    float areaBoxWidth = min(pA.x, pB.x) - minPos.x;\n    float areaBoxHeight = min(pA.y, pB.y) - minPos.y;\n    \n    float areaBoxOverlap = areaBoxWidth * areaBoxHeight;\n    \n    float areaTotal = areaTri + areaBoxWidth + areaBoxHeight - areaBoxOverlap ;\n    \n    return areaTotal;\n}\n\nvec2 getCellVolume(vec2 fragCoord, vec4 cell)\n{\n    vec2 volume = vec2(0.0);\n    volume.x = getVolume(cell.xy - fragCoord, cell.z);\n    if( volume.x == 0.0 )\n    {\n        volume.y = getVolume(cell.xy - fragCoord, cell.w);\n    }\n    else\n    {\n        volume.y = 1.0 - volume.x;\n    }\n    return volume;\n}\n\nvec2 getCellVolumeMerge(vec2 fragCoord, vec4 cell1, vec4 cell2)\n{\n    vec2 circleSize = (cell1.zw + cell2.zw) \/ 2.0; \/\/ average size \n    \n    float dis = distance(cell1.xy, cell2.xy);\n    \n    circleSize \/= (dis * 1.3 \/ circleSize);\n    \n    \n    vec2 forward = normalize(cell2.xy-cell1.xy);\n    vec2 right = vec2(forward.y, -forward.x);\n    \n    vec2 length1 = cell1.zw + circleSize;\n    vec2 length2 = cell2.zw + circleSize;\n    \n    vec2 volume = vec2(0.0);\n    \n    if( dis < length1.x + length2.x )\/\/ test inner\n    {\n        float L1 = length1.x;\n        float L2 = length2.x;\n        \n        float cosA = (dis*dis + L1*L1 - L2*L2) \/ (2.0 * dis * L1);\n        \n        float Lf = cosA * L1;\n        float Ls = sqrt(L1*L1 - Lf*Lf);\n        \n        if(Ls > circleSize.x)\n        {\n            vec2 pointRight = cell1.xy + forward * Lf + right * Ls;\n            vec2 pointLeft = cell1.xy + forward * Lf - right * Ls;\n\n            vec2 checkPR1 = normalize(cell1.xy - pointRight);\n            checkPR1 = vec2(checkPR1.y, -checkPR1.x); \/\/ rotate CW\n            vec2 checkPR2 = normalize(cell2.xy - pointRight);\n            checkPR2 = vec2(-checkPR2.y, checkPR2.x); \/\/ rotate CCW\n\n            vec2 checkPL1 = normalize(cell1.xy - pointLeft);\n            checkPL1 = vec2(-checkPL1.y, checkPL1.x); \/\/ rotate CCW\n            vec2 checkPL2 = normalize(cell2.xy - pointLeft);\n            checkPL2 = vec2(checkPL2.y, -checkPL2.x); \/\/ rotate CW\n\n            vec2 fromR = fragCoord - pointRight;\n            vec2 fromL = fragCoord - pointLeft;\n\n            if(dot(checkPR1,fromR) > 0.0 && dot(checkPR2, fromR) > 0.0 \n                && dot(checkPL1,fromL) > 0.0 && dot(checkPL2, fromL) > 0.0)\n            {\n                volume.x = 1.0 - getVolume(fromR, circleSize.x) - getVolume(fromL, circleSize.x);\n            }\n        }\n    }\n    \n    if( dis < length1.y + length2.y )\/\/ outer\n    {\n        float L1 = length1.y;\n        float L2 = length2.y;\n        \n        float cosA = (dis*dis + L1*L1 - L2*L2) \/ (2.0 * dis * L1);\n        \n        float Lf = cosA * L1;\n        float Ls = sqrt(L1*L1 - Lf*Lf);\n        \n        if(Ls > circleSize.y)\n        {\n            vec2 pointRight = cell1.xy + forward * Lf + right * Ls;\n            vec2 pointLeft = cell1.xy + forward * Lf - right * Ls;\n\n            vec2 checkPR1 = normalize(cell1.xy - pointRight);\n            checkPR1 = vec2(checkPR1.y, -checkPR1.x); \/\/ rotate CW\n            vec2 checkPR2 = normalize(cell2.xy - pointRight);\n            checkPR2 = vec2(-checkPR2.y, checkPR2.x); \/\/ rotate CCW\n\n            vec2 checkPL1 = normalize(cell1.xy - pointLeft);\n            checkPL1 = vec2(-checkPL1.y, checkPL1.x); \/\/ rotate CCW\n            vec2 checkPL2 = normalize(cell2.xy - pointLeft);\n            checkPL2 = vec2(checkPL2.y, -checkPL2.x); \/\/ rotate CW\n\n            vec2 fromR = fragCoord - pointRight;\n            vec2 fromL = fragCoord - pointLeft;\n\n            if(dot(checkPR1,fromR) > 0.0 && dot(checkPR2, fromR) > 0.0 \n                && dot(checkPL1,fromL) > 0.0 && dot(checkPL2, fromL) > 0.0)\n            {\n                volume.y = 1.0 - getVolume(fromR, circleSize.y) - getVolume(fromL, circleSize.y);\n            }\n        }\n    }\n    \n    \n    return volume;\n}\n\nvec3 volumeToColor(vec2 volume)\n{\n    if( volume.x != 0.0 )\n    {\n        return mix(color_outer, color_inner, min(1.0,volume.x));\n    }\n    return mix(color_bg, color_outer, min(1.0,volume.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cellSize = vec2( 40.0, 60.0);\n    \n    float s60r = sin60 * cellSize.y;\n    \n    vec2 center = iResolution.xy\/2.0;\n    \n    vec4 cell1 = vec4(center + vec2(cellSize.y,-s60r), cellSize);\n    vec4 cell2 = vec4(center + vec2(-cellSize.y,-s60r), cellSize);\n    vec4 cell3 = vec4(center + vec2(sin(iGlobalTime*0.25)*150.0, s60r), cellSize);\n    \n    vec4 cell4 = vec4(iMouse.xy, cellSize * clicksize);\n    \n    \n    vec2 volume = vec2(0.0); \/\/ x = inner, y = outer\n    \n    volume += getCellVolume(fragCoord.xy, cell1);\n    volume += getCellVolume(fragCoord.xy, cell2);\n    volume += getCellVolume(fragCoord.xy, cell3);\n    volume += getCellVolume(fragCoord.xy, cell4);\n    \n    volume += getCellVolumeMerge(fragCoord.xy, cell1, cell4);\n    volume += getCellVolumeMerge(fragCoord.xy, cell2, cell4);\n    volume += getCellVolumeMerge(fragCoord.xy, cell3, cell4);\n    volume += getCellVolumeMerge(fragCoord.xy, cell1, cell2);\n    volume += getCellVolumeMerge(fragCoord.xy, cell2, cell3);\n    volume += getCellVolumeMerge(fragCoord.xy, cell3, cell1);\n    \n    fragColor = vec4(volumeToColor(volume),1.0);\n}","name":"","description":"","type":"image"}]}}