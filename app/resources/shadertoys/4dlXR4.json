{"Shader":{"ver":"0.1","info":{"id":"4dlXR4","date":"1397553285","viewed":3113,"name":"Clover Tree","username":"iq","description":"Domain repetition. A (simple) clover shape is repeated over space. Clearly NOT the way to do it (super slow). I run out of instructions (and speed), so I couldn't add variation or detail or lighting really. But the basic technique is there.<br\/>","likes":35,"published":3,"flags":0,"tags":["procedural","3d","raymarching","distancefield"],"hasliked":0},"renderpass":[{"inputs":[{"id":26,"src":"\/presets\/cube04_0.png","ctype":"cubemap","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"id":27,"src":"\/presets\/cube05_0.png","ctype":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Domain repetition. A (simple) clover shape is repeated over space.\n\n\/\/ Clearly NOT the way to do it (super slow). I run out of instructions (and speed), so\n\/\/ I couldn't add variation or detail or lighting really. But the basic technique is there.\n\nfloat hash1( vec3 p )\n{\n    return fract(sin(dot(p,vec3(1.0,57.0,113.0)))*43758.5453);\n}\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\nvec3 hash3( vec3 p )\n{\n    return fract(sin(vec3( dot(p,vec3(1.0,57.0,113.0)), \n\t\t\t\t           dot(p,vec3(57.0,113.0,1.0)),\n\t\t\t\t           dot(p,vec3(113.0,1.0,57.0))))*43758.5453);\n}\n\n\/\/ simple clover shape\nfloat shape( in vec3 p, in float s )\n{\n\tfloat a = atan( p.x, p.y );\n\tfloat r = length( p.xy );\n\t\n\tfloat ra = 0.2 + 0.3*sqrt(0.5+0.5*sin( 3.0*a ));\n\tra *= s;\n    return min( max(length(p.xy)-0.04*(0.5+0.5*p.z),-p.z), max( length(p.xy)-ra, abs(p.z-0.2*r)-0.06*s*clamp(1.0-1.5*r,0.0,1.0) ) );\n}\n\n\/\/ df\nvec4 map( vec3 p )\n{\n\tp.x += 0.1*sin( 3.0*p.y );\n\t\n\tfloat rr = length(p.xz);\n\tfloat ma = 0.0;\n\tvec2 uv = vec2(0.0);\n\t\n\tfloat d1 = rr - 1.5;\n    if( d1<1.8 )\n\t{\n\t\t\n\t\tfloat siz = 6.0;\n\t\tvec3 x = p*siz + 0.5;\n\t\tvec3 xi = floor( x );\n\t\tvec3 xf = fract( x );\n\n\t\tvec2 d3 = vec2( 1000.0, 0.0 );\n\t\tfor( int k=-1; k<=1; k++ )\n        for( int j=-1; j<=1; j++ )\n        for( int i=-1; i<=1; i++ )\n        {\n            vec3 b = vec3( float(i), float(j), float(k) );\n\t\t\tvec3 c = xi + b;\n\t\t\t\n\t\t\tfloat ic = dot(c.xz,c.xz)\/(siz*siz);\n\t\t\t\n\t\t\tfloat re = 1.5;\n\t\t\t\n\t\t\tif( ic>(1.0*1.0) && ic < (re*re) )\n\t\t\t{\n            vec3 r = b - xf + 0.5 + 0.4*(-1.0+2.0*hash3( c ));\n\t\t\t\/\/vec3 r = c + 0.5 - x;\n\n\t\t\tvec3 ww = normalize( vec3(c.x,0.0,c.z) );\n\t\t\tww.y += 1.0; ww = normalize(ww);\n            ww += 0.25 * (-1.0+2.0*hash3( c+123.123 ));\n\t\t\t\t\n\t\t\tvec3 uu = normalize( cross( ww, vec3(0.0,1.0,0.0) ) );\n\t\t\tvec3 vv = normalize( cross( uu, ww ) );\n\t\t\tr = mat3(  uu.x, vv.x, ww.x,\n\t\t\t\t\t   uu.y, vv.y, ww.y,\n\t\t\t\t\t   uu.z, vv.z, ww.z )*r;\n            float s = 0.75 + 0.5*hash1( c+167.7 );\t\t\t\t\n\t\t\tfloat d = shape(r,s)\/siz;\n            if( d < d3.x )\n            {\n                d3 = vec2( d, 1.0 );\n\t\t\t\tma = hash1( c.yzx+712.1 );\n\t\t\t\tuv = r.xy;\n            }\n\t\t\t}\n        }\n\t\td1 = mix( rr-1.5, d3.x, d3.y );\n\t}\n\t\n\td1 = min( d1, rr - 1.0 );\n\n    return vec4(d1, ma, uv );\n\t\n}\n\n\nvec4 intersect( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 10.0;\n\t\n    float h = 1.0;\n    float t = 0.0;\n    float m = -1.0;\n\tvec2  u = vec2(0.0);\n    for( int i=0; i<50; i++ )\n    {\n        if( h<0.001||t>maxd ) continue;\/\/break;\n        t += h;\n\t    vec4 res = map( ro+rd*t );\n        h = res.x;\n\t    m = res.y;\n\t\tu = res.zw;\n    }\n\n    if( t>maxd ) m=-1.0;\n    return vec4( t, m, u );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 eps = vec2(0.001,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x\/iResolution.y;\n    vec2 m = iMouse.xy\/iResolution.xy;\n\t\n    \/\/ camera\n\tfloat an = 20.0 + 0.15*iGlobalTime - 7.0*m.x;\n    vec3  ro = 3.1*normalize(vec3(sin(an),0.5-0.4*m.y, cos(an)));\n    vec3  ta = vec3( 0.0, 0.8, 0.0 );\n\tfloat rl = 0.5*sin(0.35*an);\n    vec3  ww = normalize( ta - ro );\n    vec3  uu = normalize( cross(ww,vec3(sin(rl),cos(rl),0.0) ) );\n    vec3  vv = normalize( cross(uu,ww));\n    vec3  rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n\t\/\/ render\n    vec3 col = textureCube( iChannel2, rd ).xyz; col = col*col;\n\t\n\t\/\/ raymarch\n    vec4 tmat = intersect(ro,rd);\n    if( tmat.y>-0.5 )\n    {\n        \/\/ geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormal(pos);\n\t\tvec3 ref = reflect( rd, nor );\n\n        \/\/ material\n\t\tvec3 mate = vec3(0.3,0.5,0.1);\n\t\tmate = mix( mate, vec3(0.5,0.25,0.1), smoothstep( 0.9,0.91, tmat.y) );\n\t    mate += 0.1*sin( tmat.y*10.0  + vec3(0.0,2.0,2.0));\n\t\tmate *= 0.8+0.4*tmat.y;\n\t    vec2 uv = tmat.zw;\n\t\tfloat r = length(uv);\n\t\tfloat a = atan(uv.y,uv.x);\n\t\tmate += vec3(0.2,0.15,0.1)*smoothstep(0.8,1.0,-cos(3.0*a))*(1.0-1.5*r);\n\t\tmate *= 0.2+r;\n\t\t\n\t\t\/\/ lighting\n        float amb = clamp(0.5+0.5*nor.y,0.0,1.0);\n\t\tamb *= 0.1 + 0.9*pow( clamp( (length(pos.xz)-1.0)\/(1.5-1.0), 0.0, 1.0 ), 2.0 );\n\t\tvec3 snor = normalize( nor + normalize( vec3(pos.x,0.0,pos.y) ) );\n\t\tvec3 lin = 1.0*textureCube( iChannel1, snor ).xyz*amb;\n\t\tcol = mate*lin;\n\t\tfloat kd = pow(clamp(1.0+dot(rd,nor),0.0,1.0),3.0);\n\t\tcol += 0.2*kd*pow( textureCube( iChannel2, ref ).xyz, vec3(2.2) )*amb;\n\t}\n\n\t\/\/ gamma\n\tcol = pow( col, vec3(0.45) );\n\t\n\t\/\/ vigneting\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15 );\n\t\n    fragColor = vec4( col,1.0 );\n}","name":"","description":"","type":"image"}]}}