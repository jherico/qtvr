{"Shader":{"ver":"0.1","info":{"id":"XtfXzN","date":"1434791377","viewed":765,"name":"Julia rotation","username":"LeWiZ","description":"A pink quaternion julia !<br\/><br\/>Julia DE from Kindernoiser (https:\/\/www.shadertoy.com\/view\/MsfGRr)<br\/><br\/>Raymarching-related functions (soft shadows, ambiant occlusion, etc.) from iq's tutorials & other shaders (like https:\/\/www.shadertoy.com\/view\/ldfSWs)","likes":7,"published":3,"flags":0,"tags":["fractal","julia","quaternion"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"float plane(vec3 pos)\n{\n\treturn length(max(abs(pos)-vec3(4.0,0.05,4.0),0.0));\n}\n\nfloat julia(vec3 pos)\n{\n    float t = iGlobalTime \/ 3.0;\n    \n\tvec4 c = 0.5*vec4(cos(t),cos(t*1.1),cos(t*2.3),cos(t*3.1));\n    vec4 z = vec4( pos, 0.0 );\n\tvec4 nz;\n    \n\tfloat md2 = 1.0;\n\tfloat mz2 = dot(z,z);\n\n\tfor(int i=0;i<10;i++)\n\t{\n\t\tmd2*=4.0*mz2;\n\t    nz.x=z.x*z.x-dot(z.yzw,z.yzw);\n\t\tnz.yzw=2.0*z.x*z.yzw;\n\t\tz=nz+c;\n\n\t\tmz2 = dot(z,z);\n\t\tif(mz2>4.0)\n        {\n\t\t\tbreak;\n        }\n\t}\n\n\treturn 0.25*sqrt(mz2\/md2)*log(mz2);\n}\n\nfloat scene(vec3 pos)\n{\n    return min(julia(pos-vec3(0.0,1.5,0.0)), plane(pos));\n}\n\nfloat raymarcher( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 15.0;\n\tconst float precis = 0.0001;\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<100; i++ )\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = scene( ro+rd*t );\n        t += h * 1.0;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 normal( in vec3 pos )\n{\n    const float eps = 0.005;\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*scene( pos + v1*eps ) + \n\t\t\t\t\t  v2*scene( pos + v2*eps ) + \n\t\t\t\t\t  v3*scene( pos + v3*eps ) + \n\t\t\t\t\t  v4*scene( pos + v4*eps ) );\n}\n\nfloat softray( in vec3 ro, in vec3 rd , in float hn)\n{\n    float res = 1.0;\n    float t = 0.0005;\n\tfloat h = 1.0;\n    for( int i=0; i<40; i++ )\n    {\n        h = scene(ro + rd*t);\n        res = min( res, hn*h\/t );\n\t\tt += clamp( h, 0.02, 2.0 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat ambocc( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)\/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = scene( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 light( in vec3 lightdir, in vec3 lightcol, in vec3 tex, in vec3 norm, in vec3 camdir )\n{    \n    float cosa = pow(0.5 + 0.5*dot(norm, -lightdir),2.0);\n    float cosr = max(dot(-camdir, reflect(lightdir, norm)), -0.0);\n    \n    float diffuse = cosa;\n    float phong = pow(cosr, 128.0);\n    \n    return lightcol * (tex * diffuse + phong);\n}\n\nvec3 background( in vec3 rd )\n{\n\treturn vec3(1.0+2.0*rd.y);\n}\n\nvec3 material( in vec3 pos , in vec3 camdir )\n{    \n\tvec3 norm = normal(pos);\n    \n    vec3 d1 = -normalize(vec3(5.0,10.0,-20.0));\n    vec3 d2 = -normalize(vec3(-5,10.0,20.0));\n    vec3 d3 = -normalize(vec3(20,5.0,-5.0));\n    vec3 d4 = -normalize(vec3(-20.0,5.0,5.0));\n\t\n    vec3 tex = vec3(1.0);\n    float sha = 1.0;\n    float ao = 1.0;\n    \n    if (pos.y < 0.2)\n    {\n        tex = vec3(0.2);\n    \tsha = 0.3 + 0.7 * softray(pos, -d1,4.0) * (0.7+softray(pos, norm,2.0));\n    }\n    else\n    {\n        tex = vec3(0.3,0.1,0.2);\n    \tsha = 0.5 + 0.5 * softray(pos, norm, 2.0);\n        ao = ambocc(pos, norm);\n    }\n    \n    vec3 l1 = light(d1, vec3(1.5,1.4,1.2), tex, norm, camdir);\n    vec3 l2 = light(d2, vec3(1.2,1.1,0.9), tex, norm, camdir);\n    vec3 l3 = light(d3, vec3(0.6,0.7,0.9), tex, norm, camdir);\n    vec3 l4 = light(d4, vec3(0.2,0.2,0.2), tex, norm, camdir);\n    \n    vec3 amb = vec3(0.05);\n    \n    return amb*ao+(l1+l2+l3+l4)*sha;\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvec3 rayrender(vec3 pos, vec3 dir)\n{\n   vec3 col = vec3(0.0);\n    \n   float dist = raymarcher(pos, dir);\n    \n    if (dist==-1.0) col = background(dir);\n    else\n    {\n    \tvec3 inters = pos + dist * dir;\n    \tcol = material(inters, dir);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iGlobalTime;\n    \n    vec2 xy = (fragCoord.xy - iResolution.xy\/2.0) \/ max(iResolution.xy.x, iResolution.xy.y);\n    \n    vec3 campos = vec3(5.0*cos(t\/5.0),3.0,5.0*sin(t\/5.0));\n    vec3 camtar = vec3(0.0,1.5,0.0);\n    \n    mat3 camMat = calcLookAtMatrix( campos, camtar, 0.0 );\n\tvec3 camdir = normalize( camMat * vec3(xy,0.9) );\n    \n    vec3 col = rayrender(campos, camdir);\n    \n    col = pow(col, vec3(1.0\/2.2));\n    \n\tfragColor = vec4(col,1.0);\n}\n","name":"","description":"","type":"image"}]}}