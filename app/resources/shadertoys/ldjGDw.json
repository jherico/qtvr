{"Shader":{"ver":"0.1","info":{"id":"ldjGDw","date":"1389541048","viewed":861,"name":"Rendezvous","username":"Dave_Hoskins","description":"A Kleinian thing, breathing, and with pumping arteries! See defines at top for extra stuff.","likes":14,"published":3,"flags":64,"tags":["3d","raymarching","fractal","kleinian","rendezvoussoundcloud"],"hasliked":0},"renderpass":[{"inputs":[{"id":95,"src":"https:\/\/soundcloud.com\/christonia5\/podcast-2015","ctype":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Rendezvous. By David Hoskins. Jan 2014.\n\/\/ A Kleinian thingy, breathing, and with pumping arteries!\n\/\/ https:\/\/www.shadertoy.com\/view\/ldjGDw\n\n\/\/ Add crude reflections..\n\/\/ #define REFLECTIONS\n\n\/\/ For red\/cyan 3D. Red on the left.\n\/\/ #define STEREO\n\n\n#define CSize  vec3(.808, .8, 1.137)\n#define FogColour vec3(.05, .05, .05)\n\nvec3  lightPos;\nfloat intensity;\n\n\/\/----------------------------------------------------------------------------------------\nfloat Hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat Noise( in float x )\n{\n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix(Hash(p), Hash(p+1.0), f);\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat Map( vec3 p )\n{\n\tfloat scale = 1.0;\n\tfloat add = sin(iGlobalTime)*.2+.1;\n\n\tfor( int i=0; i < 9;i++ )\n\t{\n\t\tp = 2.0*clamp(p, -CSize, CSize) - p;\n\t\tfloat r2 = dot(p,p);\n\t\tfloat k = max((1.15)\/r2, 1.);\n\t\tp     *= k;\n\t\tscale *= k;\n\t}\n\tfloat l = length(p.xy);\n\tfloat rxy = l - 4.0;\n\tfloat n = l * p.z;\n\trxy = max(rxy, -(n) \/ (length(p))-.07+sin(iGlobalTime*2.0+p.x+p.y+23.5*p.z)*.02);\n\treturn (rxy) \/ abs(scale);\n}\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 Colour( vec3 p)\n{\n\tfloat col\t= 0.0;\n\tfloat r2\t= dot(p,p);\n\tfloat add = sin(iGlobalTime)*.2+.1;\n\t\n\tfor( int i=0; i < 10;i++ )\n\t{\n\t\tvec3 p1= 2.0 * clamp(p, -CSize, CSize)-p;\n\t\tcol += abs(p.z-p1.z);\n\t\tp = p1;\n\t\tr2 = dot(p,p);\n\t\tfloat k = max((1.15)\/r2, 1.0);\n\t\tp *= k;\n\t}\n\treturn (0.5+0.5*sin(col*vec3(.6 ,-.9 ,4.9)))*.75 + .15;\n    \/\/return pal(0.5+0.5*sin(col), vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    \/\/return pal(0.5+0.5*cos(col), vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) );\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat RayMarch( in vec3 ro, in vec3 rd )\n{\n\tfloat precis = 0.001;\n    float h\t\t = 0.0;\n    float t\t\t = .0;\n\tfloat res\t = 200.0;\n\tbool hit\t = false;\n\t\/\/ If I rearrange the loop in a more logical way,\n\t\/\/ I get a black screen on Windows.\n    for( int i = 0; i < 120; i++ )\n    {\n\t\tif (!hit && t < 12.0)\n\t\t{\n\t\t\th = Map(ro + rd * t);\n\t\t\tif (h < precis)\n\t\t\t{\n\t\t\t\tres = t;\n\t\t\t\thit = true;\n\t\t\t}\n\t\t\tt += h * .83;\n\t\t}\n    }\n\t\n    return res;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat Shadow(in vec3 ro, in vec3 rd, float dist)\n{\n\tfloat res = 1.0;\n    float t = 0.02;\n\tfloat h = 0.0;\n    \n\tfor (int i = 0; i < 14; i++)\n\t{\n\t\t\/\/ Don't run past the point light source...\n\t\tif(t < dist)\n\t\t{\n\t\t\th = Map(ro + rd * t);\n\t\t\tres = min(4.*h \/ t, res);\n\t\t\tt += 0.0 + h*.4;\n\t\t}\n\t}\n    return clamp(res, 0.0, 1.0);\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 Normal(in vec3 pos, in float t)\n{\n\tvec2  eps = vec2(t*t*.0075,0.0);\n\tvec3 nor = vec3(Map(pos+eps.xyy) - Map(pos-eps.xyy),\n\t\t\t\t\tMap(pos+eps.yxy) - Map(pos-eps.yxy),\n\t\t\t\t\tMap(pos+eps.yyx) - Map(pos-eps.yyx));\n\treturn normalize(nor);\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat LightGlow(vec3 light, vec3 ray, float t)\n{\n\tfloat ret = 0.0;\n\tif (length(light) < t)\n\t{\n\t\tlight = normalize(light);\n\t\tret = pow(max(dot(light, ray), 0.0), 2000.0)*.5;\n\t\tfloat a = atan(light.x - ray.x, light.z - ray.z);\n\t\tret = (1.0+(sin(a*10.0-iGlobalTime*4.3)+sin(a*13.141+iGlobalTime*3.141)))*(sqrt(ret))*.05+ret;\n\t\tret *= 3.0;\n\t}\n\t\t\n\treturn ret;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 RenderPosition(vec3 pos, vec3 ray, vec3 nor, float t)\n{\n\tvec3 col = vec3(0.0);\t\t\t\t\n\tvec3 lPos  = lightPos-pos;\n\tfloat lightDist = length(lPos);\n\tvec3 lightDir  = normalize(lPos);\n\n\tfloat bri = max( dot( lightDir, nor ), 0.0) * intensity;\n\tfloat spe = max(dot(reflect(ray, nor), lightDir), 0.0);\n\tfloat amb = max(abs(nor.z)*.04, 0.025);\n\tfloat sha = Shadow(pos, lightDir, lightDist);\n\tcol = Colour(pos);   \n\tcol = col * bri *sha+ pow(spe, 15.0) *sha*.7 +amb*col;\n\t\n\treturn col;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy\/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x\/iResolution.y;\n\t\n\t#ifdef STEREO\n\tfloat isRed = mod(fragCoord.x + mod(fragCoord.y,2.0),2.0);\n\t#endif\n\n\tfloat time = sin(1.6+iGlobalTime*.05 + iMouse.x*.005)*12.5;\n    \/\/ camera\n\tfloat height = (smoothstep(9.4, 11.5, abs(time))*.5);\n\tvec3 origin = vec3( 1.2, time+1.0, 2.5+height);\n\tvec3 target = vec3(.0+sin(time), 0.0, 2.5-height*4.0);\n\tlightPos = origin+vec3(-0.56-cos(time*2.0+2.8)*.3, -1.4, .24+cos(time*2.0+1.5)*.3);\n\tintensity = .8+.3*Noise(iGlobalTime*5.0);\n\t\n\tvec3 cw = normalize( target-origin);\n\tvec3 cp = normalize(vec3(0.0, sin(iGlobalTime*.25 + iMouse.x*.005), 1.80));\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = cross(cu,cw);\n\tvec3 ray = normalize( p.x*cu + p.y*cv + 2.6*cw );\t\n\t#ifdef STEREO\n\torigin += .008*cu*isRed; \/\/ move camera to the right - the rd vector is still good\n\t#endif\t\n\n\tvec3 col = vec3(0.0);\n\tfloat t = 0.0;\n\tt = RayMarch(origin, ray);\n\n\tif(t < 199.0)\n\t{\n\t\tvec3 pos = origin + t * ray;\n\t\tvec3 nor = Normal(pos, t);\n\t\tcol = RenderPosition(pos, ray, nor, t);\n\t\t\n\t\t#ifdef REFLECTIONS\n\t\tvec3 ray2    = reflect(ray, nor);\n\t\tvec3 origin2 = pos + nor*.01;\n\t\tfloat d = RayMarch(origin2, ray2);\n\t\tif(d < 199.0)\n\t\t{\n\t\t\tpos = origin2 + d * ray2;\n\t\t\tnor = Normal(pos, d);\n\t\t\tcol += RenderPosition(pos, ray, nor, d) * .2;\n\t\t}\n\t\t#endif\n\t}\n\t\n\t\/\/ Effects...\n\tcol = mix(FogColour, col, exp(-.6*max(t-3.0, 0.0)));\n    col = clamp(mix(col, vec3(.333), -.07), 0.0, 1.0);\n\tcol = pow(col, vec3(.45));\n\t\/\/col *= pow(20.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2);\n\tcol += LightGlow(lightPos-origin, ray, t) * intensity;\n\n\t#ifdef STEREO\t\n\tcol *= vec3( isRed, 1.0-isRed, 1.0-isRed );\t\n\t#endif\t\n\t\n\tfragColor=vec4(clamp(col, 0.0, 1.0),1.0);\n}","name":"","description":"","type":"image"}]}}