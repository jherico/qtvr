{"Shader":{"ver":"0.1","info":{"id":"ll2SWd","date":"1447458621","viewed":777,"name":"Above the clouds","username":"Duke","description":"In this shader i tried to combine techniques from \"Cloudy spikeball\" and IQ's \"Clouds\" for rendering clouds. I think that this combination will work a bit faster than original method.","likes":29,"published":3,"flags":0,"tags":["noise","volume","raymarch","cloud"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ \"Above the clouds\" by Duke\n\/\/----------------------------\n\/\/ Clouds lighting technique came from IQ's \"Clouds\" https:\/\/www.shadertoy.com\/view\/XslGRr shader\n\/\/ Raymarcher based on Shane's \"Fiery Spikeball\" https:\/\/www.shadertoy.com\/view\/4lBXzy shader (I think that his implementation is more understandable than the original :) ) \n\/\/ Some noises came from otaviogood's \"Alien Beacon\" https:\/\/www.shadertoy.com\/view\/ld2SzK shader\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\/\/ Comment this string to see different coloring technique\n#define IQCOLOUR\n\/\/ I am still not sure that this part works right. Commenting this string will improve performance a lot\n#define IQLIGHT\n\n#define DITHERING\n\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n\/\/ iq's noise\nfloat pn( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D( iChannel0, (uv+ 0.5)\/256.0, -100.0 ).yx;\n\treturn -1.0+2.4*mix( rg.x, rg.y, f.z );\n}\n\n\nfloat fpn(vec3 p) \n{\n   return pn(p*.06125)*.5 + pn(p*.125)*.25 + pn(p*.25)*.125;\n}\n\nfloat rand(vec2 co)\n{\/\/ implementation found at: lumina.sourceforge.net\/Tutorials\/Noise.html\n\treturn fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\/\/ otaviogood's noise from https:\/\/www.shadertoy.com\/view\/ld2SzK\n\/\/--------------------------------------------------------------\n\/\/ This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n\/\/ It should work the same on all computers since it's not based on a hash function like some other noises.\n\/\/ It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.739513;\t\/\/ size of perpendicular vector\nfloat normalizer = 1.0 \/ sqrt(1.0 + nudge*nudge);\t\/\/ pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p)\n{\n    float n = 0.0;\t\/\/ noise amount\n    float iter = 1.0;\n    for (int i = 0; i < 8; i++)\n    {\n        \/\/ add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) \/ iter;\t\/\/ abs for a ridged look\n        \/\/ rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        \/\/ rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        \/\/ increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\n\nfloat SpiralNoise3D(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    for (int i = 0; i < 5; i++)\n    {\n        n += (sin(p.y*iter) + cos(p.x*iter)) \/ iter;\n        \/\/p.xy += vec2(p.y, -p.x) * nudge;\n        \/\/p.xy *= normalizer;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.33733;\n    }\n    return n;\n}\n\nfloat Clouds(vec3 p)\n{\n\tfloat final = p.y + 4.5;\n    \/\/final -= SpiralNoiseC(p.xyz);\t\/\/ mid-range noise\n    final += SpiralNoiseC(p.zxy*0.123+100.0)*3.0;\t\/\/ large scale terrain features\n    final -= SpiralNoise3D(p);\t\/\/ more large scale features, but 3d, so not just a height map.\n    \/\/final -= SpiralNoise3D(p*49.0)*0.0625*0.125;\t\/\/ small scale noise for variation\n\n    return final;\n}\n\nfloat map(vec3 p) \n{\n   R(p.yz, -25.53);\/\/-0.4+iMouse.y*0.003); \/\/change this string to be able to find \"cloudy caves\" :)\n   R(p.xz, iMouse.x*0.008*pi+iGlobalTime*0.1);\n   return Clouds(p) +  fpn(p*50.+iGlobalTime*5.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n   \/\/ ro: ray origin\n   \/\/ rd: direction of the ray\n   vec3 rd = normalize(vec3((gl_FragCoord.xy-0.5*iResolution.xy)\/iResolution.y, 1.));\n   vec3 ro = vec3(0., 0., -11.);\n   \n   \/\/ ld, td: local, total density \n   \/\/ w: weighting factor\n   float ld=0., td=0., w;\n\n   \/\/ t: length of the ray\n   \/\/ d: distance function\n   float d=1., t=0.;\n   \n   \/\/ Distance threshold.\n   const float h = .1;\n    \n   \tvec3 sundir = normalize( vec3(-1.0,0.75,1.0) );\n    \/\/ background sky     \n\tfloat sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n\tvec3 col = vec3(0.6,0.71,0.75) - rd.y*0.2*vec3(1.0,0.5,1.0) + 0.15*0.5;\n\tcol += 0.2*vec3(1.0,.6,0.1)*pow( sun, 8.0 );\n    \/\/ clouds  \n    vec3 bgcol = col;\n\tvec4 sum = vec4(0.0);\n   \n   #ifdef DITHERING\n   vec2 pos1 = ( fragCoord.xy \/ iResolution.xy );\n   vec2 seed = pos1 + fract(iGlobalTime);\n   t=(1.+0.2*rand(seed*vec2(1)));\n   #endif \n   \n   \/\/ rm loop\n   for (int i=0; i<64; i++) {\n\t \n      vec3 pos = ro + t*rd;\n       \n      \/\/ Loop break conditions.\n      if(td>(1.-1.\/80.) || d<0.0006*t || t>120. || pos.y<-5.0 || pos.y>30.0 || sum.a > 0.99) break;\n       \n      \/\/ evaluate distance function\n      d = map(pos)*0.326; \n      \n      \/\/ fix holes deep inside clouds\n      d=max(d,-.4);\n       \n      \/\/ check whether we are close enough\n      if (d<0.4) \n      {\n        \/\/ compute local density and weighting factor \n      \tld = 0.1 - d;\n        \n        #ifdef IQLIGHT\n      \tld *= clamp((ld - map(pos+0.3*sundir))\/0.6, 0.0, 1.0 );\n        const float kmaxdist = 0.6;\n      \t#else\n        ld *= 0.15;\n        const float kmaxdist = 0.6;\n        #endif\n          \n        w = (1. - td) * ld;   \n     \n      \t\/\/ accumulate density\n      \ttd += w;\/\/ + 1.\/90.;\n              \n      \tvec3 lin = vec3(0.65,0.68,0.7)*1.3 + 0.5*vec3(0.7, 0.5, 0.3)*ld;\n      \n      \t#ifdef IQCOLOUR\n      \tvec4 col = vec4( mix( 1.15*vec3(1.0,0.95,0.8), vec3(0.765), d ), max(kmaxdist,d) );\n      \t#else\n      \tvec4 col = vec4(vec3(1.\/exp( d * 0.2 ) * 1.05), max(kmaxdist,d));\n\t  \t#endif\n      \n      \tcol.xyz *= lin;\n        col.xyz = mix( col.xyz, bgcol, 1.0-exp(-0.0004*t*t) );\n      \t\/\/ front to back blending    \n      \tcol.a *= 0.4;\n      \tcol.rgb *= col.a;\n      \tsum = sum + col*(1.0-sum.a);\n        \n      }\n      \n      td += 1.\/70.;\n       \n      \/\/ enforce minimum stepsize\n      d = max(d, 0.04); \n      \n\t  #ifdef DITHERING\n      \/\/ add in noise to reduce banding and create fuzz\n      d=abs(d)*(1.+0.28*rand(seed*vec2(i)));\n      #endif \n\t  \n      \/\/ step forward\n      t += d*.5;\n      \n   }\n \n   \tsum = clamp( sum, 0.0, 1.0 );\n    col = vec3(0.6,0.71,0.75) - rd.y*0.2*vec3(1.0,0.5,1.0) + 0.15*0.5;\n    col = col*(1.0-sum.w) + sum.xyz;\n    \n    \/\/ sun glare    \n\tcol += 0.1*vec3(1.0,0.4,0.2)*pow( sun, 3.0 );\n   \n   fragColor = vec4(col, 1.0); \n}","name":"","description":"","type":"image"}]}}