{"Shader":{"ver":"0.1","info":{"id":"Xsf3Dr","date":"1366995581","viewed":1946,"name":"Texture - HW interpolation","username":"iq","description":"HW linear interpolation vs manual interpolation. Depending on your display the two might or might not look the same. However, taking derivatives highlights the problem - HW interpolation does not produce the expected constant derivative.","likes":10,"published":3,"flags":0,"tags":["2d","interpolation","hw"],"hasliked":0},"renderpass":[{"inputs":[{"id":16,"src":"\/presets\/tex11.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/\n\/\/\n\/\/ HW linear interpolation vs manual interpolation. \n\/\/\n\/\/ Depending on your display the two might or might look to be similar or\n\/\/ even the same. However, taking derivatives  highlights the problem: HW \n\/\/ interpolation does not produce the expected constant derivative, but a \n\/\/ series of discrete jumps.\n\/\/\n\/\/ You can undefine the USE8BIT below and check that indeed HW is using 8 \n\/\/ bit point arighmetic.\n\n\n\/\/#define USE8BIT\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy \/ iResolution.xy;\n\t\n\t\/\/ texture resolution\n\tfloat texRes = 64.0;\n\t\n\t\/\/ pixel under examination\n    vec2 pixOff = vec2(430.5,40.5)\/texRes;\n\t\n    \/\/ linear interpolation done by the hardware\t\n\tvec3 c = texture2D( iChannel0, pixOff+vec2(p.x\/texRes,0.0) ).xyz;\n\n\t\/\/ linear interpolation made by hand\n\tvec3 d = mix( texture2D( iChannel0, pixOff+vec2(0.0\/texRes,0.0) ).xyz, \n\t\t\t\t  texture2D( iChannel0, pixOff+vec2(1.0\/texRes,0.0) ).xyz, \n#ifdef USE8BIT\n                  floor(p.x*256.0-0.5)\/256.0\t );\n#else\n\t\t\t\t  p.x );\n#endif\n\n\t\/\/ compare both. upper half: HW, lower half: manual\n\tvec3 r = c; if( p.y<0.5 ) r=d;\n\t\n    \/\/ show derivatives\n\tif( abs(p.y-0.5)>0.3 ) r = 2.0*abs(dFdx(r))*iResolution.x;\n\t\n\tr *= smoothstep( 0.002, 0.004, abs(p.y-0.5) );\n\tr *= smoothstep( 0.002, 0.004, abs(p.y-0.2) );\n\tr *= smoothstep( 0.002, 0.004, abs(p.y-0.8) );\n\t\n\tfragColor = vec4(r,1.0);\n}","name":"","description":"","type":"image"}]}}