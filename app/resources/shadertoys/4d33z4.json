{"Shader":{"ver":"0.1","info":{"id":"4d33z4","date":"1448268262","viewed":423,"name":"My first ShaderToy: Learning SDF","username":"sagarpatel","description":"Hacked on top of @cabbibo's awesome SDF tutorial ( https:\/\/www.shadertoy.com\/view\/Xl2XWt ) and uses funcs from IQ's SDF page (http:\/\/iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm)<br\/>Did the tut + this on the bus ride from Ha Long Bay to Hanoi","likes":3,"published":3,"flags":0,"tags":["sdf"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ @sagzorz\n\/\/ My first shader on ShaderToy!\n\n\n\n\/\/ The stuff below is pretty much all of the amazing @cabbibo's SDF tutorial \n\/\/ https:\/\/www.shadertoy.com\/view\/Xl2XWt\n\n\/\/ I read thorugh it then looked at IQ's page on distance functions \n\/\/ http:\/\/iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\n\n\/\/ got inspired and remixed stuff in really messy code\n\/\/ my only excuse was that I was in a rush since I did the tutorial and my hack all in a bus ride\n\/\/ from Ha Long Bay to Hanoi and batteries were starting to run out :\/\n\n\/*\n\n    CC0 1.0\n\n\t@vrtree\n\twho@tree.is\n\thttp:\/\/tree.is\n\t\n\t\n\tI dont know if this is going to work, or be interesting, \n\tor even understandable, But hey! Why not try!\n\n\tTo start, get inspired by some MAGICAL creations made by raytracing:\n\n\tVolcanic by IQ\n\thttps:\/\/www.shadertoy.com\/view\/XsX3RB\n\n\tRemnant X by Dave_Hoskins ( Audio Autoplay warnings )\n\thttps:\/\/www.shadertoy.com\/view\/4sjSW1\n\n\tCloud Ten by Nimitz\n\thttps:\/\/www.shadertoy.com\/view\/XtS3DD\n\n\tSpectacles by MEEEEEE\n    https:\/\/www.shadertoy.com\/view\/4lBXWt\n\n\t[2TC 15] Mystery Mountains by Dave_Hoskins\n\thttps:\/\/www.shadertoy.com\/view\/llsGW7\n\n\tRaytracing graphics is kinda like baking cakes. \n\t\n\tI want yall to first see how magical \n\tthe cake can be before trying to learn how to make it, because the thing we \n\tmake at first isn't going to be one of those crazy 10 story wedding cakes. its just\n\tgoing to be some burnt sugar bread. \n\t\n\tMaking art using code can be so fufilling, and so infinite, but to get there you \n\tneed to learn some techniques that might not seem that inspiring. To bake a cake,\n\tyou first need to turn on an oven, and need to know what an oven even is. In this\n\ttutorial we are going to be learning how to make the oven, how to turn it on, \n\tand how to mix ingredients. as you can see on our left, our cake isn't very pretty\n\tbut it is a cake. and thats pretty crazy for just one tutorial!\n\n\tOnce you have gone through this tutorial, you can see a 'minimized' version\n\there: https:\/\/www.shadertoy.com\/view\/Xt2XDt\n\n\twhere I've rewritten it using the varibles and functions that\n\tare used alot throughout shadertoy. The inspiration examples above\n\tprobably seem completely insane, because of all the single letter variable\n\tnames, but keep in mind, that they all start with most of the same ingredients \n\tand overn that we will learn about right now!\n\n\t\n\tI've tried to break up the code into 'sections'\n\twhich have the 'SECTION 'BLAH'' label above them. Not sure\n\tif thats gonna help or not, but please leave comments \n\tif you think something works or doesn't work, slash you \n\thave any questions!!!\n\n\tor contact me at @vrtree || @cabbibo\n\n\n\tCheat sheet for vectors:\n\n    x = left \/ right\n\ty = up \/ down\n\tz = forwards \/ backwards\n\n\talso, for vectors labeled 'color'\n\n\tx = red\n\ty = green\n\tz = blue\n\n\n\n\t\/\/---------------------------------------------------\n    \/\/ SECTION 'A' : ONE PROGRAM FOR EVERY PIXEL!\n    \/\/---------------------------------------------------\n\n\tThe best metaphor that I can think of for raytracing is\n\tthat the rectangle to our left is actually just a small window\n\tinto a fantastic world. We need to describe that world, \n\tso that we can see it. BUT HOW ?!?!?!\n\n\tWhat we are doing below is describing what color each pixel\n\tof the window is, however because of the way that shader \n\tprograms work, we need to give the same instruction to every\n\tsingle PIXEL ( or in shadertoy terms, FRAGMENT )\n\tin the window. This is where the term SIMD comes \n\tfrom : Same Instruction Multiple Data \n\n\tIn this case, the same instruction is the program below,\n\tand the multiple data is the marvelous little piece of magic\n\tcalled 'fragCoord' which is just the position of the pixel in \n\twindow. lets rename some things to look prettier.\n\n\t\n\t\/\/---------------------------------------------------\n    \/\/ SECTION 'B' : BUILDING THE WINDOW\n    \/\/---------------------------------------------------\n\n\tIf you think about what happens with an actual window, you \n\tcan begin to get an idea of how the magic of raytracing works\n\tbasically a bunch of rays come from the sun ( and or other\n\tlight sources ) , bounce around a bunch ( or a little ), and\n\teventually make it through the window, and into our eyes.\n\n\tNow the number of rays are masssiveeee that come from the sun\n\tand alot of them that are bouncing around, will end up going \n\tdirections that aren't even close to the window, or maybe\n\twill hit the wall instead of the window. \n\n\tWe only care about the rays that go through the window \n\tand make it to our eyeballs!\n\n\tThis means that we can be a bit intelligent. Instead of \n\tfiguring out the rays that come from the sun and bounce around\n\tlets start with out eyes, and work backwards!!!!\n\n\n\t\/\/---------------------------------------------------\n    \/\/ SECTION 'C' : NAVIGATING THE WORLD\n    \/\/---------------------------------------------------\n\n\tAfter setting up all the neccesary ray information,\n\twe FINALLY get to start building the scene. Up to this point, \n\twe've only built up the window, and the rays that go from our\n\teyes through the window, but now we need to describe to the rays\n    if they hit anything and what they hit!\n\n\n\tNow this part has some pretty scary code in it ( whenever I look\n\tat it at least, my eyes glaze over ), so feel free to skip over \n\tthe checkRayHit function. I tried to explain it as best as I could\n\tdown below, and you might want to come back to it after going\n\tthrought the rest of the tutorial, but the important thing to\n\tremember is the following:\n\n\n\tThese 'rays' that we've been talking about will move through the\n\tscene along their direction. They do this iteratively, and at each\n\tstep will basically ask the question :\n\t\n\t'HOW CLOSE AM I TO THINGS IN THE WORLD???'\n\n\tbecause well, rays are lonely, and want to be closer to things in\n\tthe world. We provide them an answer to that question using our\n\tdescription of the world, and they use this information to tell\n\tthem how much further along their path they should move. If the\n\tanswer to the question is:\n\t\t\n\t'Lovely little ray, you are actually touching a thing in the world!'\n\t\n\tWe know what that the ray hit something, and can begin with our next\n\tstep!\n\t\n\tThe tricky part about this is that we have to as accuratly as \n\tpossible provide them an answer to their question 'how close??!!'\n\t\n\n\n\t\/\/--------------------------------------------------------------\n    \/\/ SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n    \/\/--------------------------------------------------------------\n\n\tTo answer the above concept, we are going to use this magical \n\tconcept called: \n\n\t'Signed Distance Fields'\n\t-----------------------\n\n\tThese things are the best, and very basically can be describe as \n\ta function that takes in a position, and feeds back a value of\n\thow close you are to a thing. If the value of this distance is negative\n\tyou are inside the thing, if it is positive, you are outside the thing\n\tand if its 0 you are at the surface of the thing! This positive or negative\n\tgives us the 'Signed' in 'Signed Distance Field'\n\n\tFor a super intensive description of many of the SDFs out there\n\tcheck out Inigo Quilez's site:\n\n\thttp:\/\/www.iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\n\n\tAlso, if you want a deep dive into why these functions are the \n\tultimate magic, check out this crazy paper by the geniouses\n\tover at Media Molecule about their new game: 'DREAMS' \n\n    http:\/\/media.lolrus.mediamolecule.com\/AlexEvans_SIGGRAPH-2015.pdf\n\n\tNeedless to say, these lil puppies are super amazing, and are\n\there to free us from the tyranny of polygons.\n\n\n\t---------\n\n\tWe are going to put all of our SDFs into a single function called\n\t\n\t'mapTheWorld' \n\t\n\twhich will take in a position, and feed back two values.\n\tThe first value is the Distance of Signed Distance Field, and the\n\tsecond value will tell us what we are closest too, so that if \n\twe actually hit something, we can tell what it is. We will denote this\n\tby an 'ID' value.\n\n\tThe hardest part for me to wrap my head around for this was the fact that\n\tthese fields do not just describe where the surface of an object is,\n\tthey actually describe how far you are from the object from ANYWHERE \n\tin the world. \n\n\tFor example, if I was hitting a round ballon ( AKA a sphere :) ) \n\tI wouldn't just know if I was on the surface of the ballon, I would have\n\tto know how close I was to the balloon from anywhere in space.\n\n\tCheck out the 'TAG : BALLOON' in the mapTheWorld function for more detail :)\n\n\tI've also made a function for a box, that is slightly more complex, and to be\n\thonest, I don't exactly understand the math of it, but the beauty of programming\n\tis that someone else ( AKA Inigo ) does, and I can steal his knowledge, just by\n\tlooking at the functions from his website!\n\t\n\t---------\n\n\tOne of the magical properties of SDFs is how easily they can be combined \n\tcontorted, and manipulated. They are just these lil functions that take \n\tin a position and give back a distance value, so we can do things like play with the\n\tinput position, play with the output distance value, or just about anything\n\telse.\n\n\tWe'll start by combining two SDFs by asking the simple question\n\t\n\t'Which thing am I closer to?'\n\t\n\twhich is as simple as a '>' because we already know exactly how close we are \n\tto each thing!\n\n\tcheck out 'TAG : WHICH AM I CLOSER TO?'  for more enough\n\n\tWe use these function to create a map of the world for the rays to navigate,\n\tand than pass that map to the checkRayHit, which propates the rays throughout\n\tthe world and tells us what they hit.\n\n\tOnce they know that, we can FINALLY do our last step:\n\n\n\t\/\/--------------------------------------------------------------\n    \/\/ SECTION 'E' : COLORING THE WORLD!\n    \/\/--------------------------------------------------------------\n\n\tAt the end of our checkRayHit function we return a vec2 with two values:\n\t.x is the distance that our ray traveled before hitting\n\t.y is the ID of the thing that we hit.\n\n\tif .y is less that 0.0 that means that our ray went as far as we allowed it\n\tto go without hitting anything. thats one lonely ray :(\n\t\n\thowever, that doesn't mean that the ray didn't hit anything. It just meant \n\tthat it is part of the background. \n\t\n\tThanks little ray! \n\tYou told us important information about our scene, \n\tand your hard work is helping to create the world!\n\n\tWe can get reallly crazy with how we color the background of the scene,\n\tbut for this tutorial lets just keep it black, because who doesn't love \n\tthe void.\n\n\twe will use the function 'doBackgroundColor' to accomplish this task!\n\n\tThat tells us about the background, but what if .y is greater than 0.0?\n\tthen we get to make some stuff in the scene!\n\n\tif the ID is equal to balloon id, then we 'doBalloonColor'\n\tand if the ID is equal to the box , then we 'doBoxColor'\n\t\n\tThis is all that we need if we want to color simple solid objects,\n\tbut what if we want to add some shading, by doing what we originally\n\ttalked about, that is, following the ray to the sun?\n\n\tFor this first tutorial, we will keep it to a very naive approach,\n\tbut once you get the basics of sections A - D, we can get SUPER crazy\n\twith this 'color' the world section. \n\n\tFor example, we could reflect the\n\tray off the surface, and than repeat the checkRayHit with this new information\n\tcontinuing to follow this ray through more and more of the world. we could \n\trepeat this process again and again, and even though our gpu would hate us\n\twe could continue bouncing around until we got to a light source! \n\n\tIn a later tutorial we will do exactly this, but for now, \n\twe are going to do 1 simple task:\n\n\n\tSee how much the surface that we hit, faces the sun.\n\n\n\tto do that we need to do 2 things. \n\n\tFirst, determine which way the surface faces\n\tSecond, determine which way rays go from the surface to get to the sun\n\n\t1) To determine the way that the surface faces, we will use a function called\n\t'getNormalOfSurface' This function will either make 100% sense, or 0% sense\n\tdepending on how often you have played with fields, but it made 0% sense to me\n\tfor many years, so don't worry if you don't get it! Whats important is that\n\tit gives us the direction that the surface faces, which we call its 'Normal'\n\tYou can think of it as a vector that is perpendicular to the surface at a specific point\n\t\n\tSo that it is easier to understand what this value is, we are actually going to color our\n\tbox based on this value. We will map the X value of the normal to red, the Y value of the \n\tnormal to green and the Z value of the normal to blue. You can see this more in the \n\t'doBoxColor' function\n\n\t\n\t2) To get the direction the rays go to get to the sun, we just need to subtract the sun\n\tposition from the position of where we hit. This will provide us a direction from the sun\n\tto the position. Look inside the doBalloonColor to see this calculation happen.\n\tthis will give us the direction of the rays from the sun to the surface!\n\n\n\tNow that we have these 2 pieces of information, the last thing we need to do is see \n\thow much the two vectors ( the normal and the light direction ) 'Face' each other. \n\t\n\tthat word 'Face', might not make much sense in this context, but think about it this way.\n\n\tIf you have a table, and a light above the table, the top of the table will 'Face',\n\tthe light, and the bottom of the table will 'Face' away from the light. The surface\n\tthat 'Faces' the light will get hit by the rays from the light, while the surface\n\tthat 'Faces' away from the light will be totally dark!\n\n\tso how do we get this 'Face' value ( pun intended :p ) ?\n\n\tThere is a magical function called a 'dot product' which does exactly this. you \n\tcan read more here:\n\n\thttps:\/\/en.wikipedia.org\/wiki\/Dot_product\n\n\tbasically this function takes in 2 vectors, and feeds back a value from -1 -> 1.\n\n\tif the value is -1 , the two vectors face in exact opposite directions, and if\n\tthe value is 1 , the two vectors face in exactly the same direction. if the value is\n\t0, than they are perpendicular!\n\n\tBy using the dot product, we take get the ballon's 'Face' value and color it depending\n\ton this value!\n\n\tcheck out the doBallonColor to see all this craziness in action\n\n\n\t\/\/--------------------------------------------------------------\n    \/\/ SECTION 'F' : Wrapping up\n    \/\/--------------------------------------------------------------\n\n\tWhat a journey it has been. Remember back when we were talking about\n\tsending rays through the window? Remember them moving all through the \n\tworld trying to be closer to things?\n\n\tSo much has happened, and at the end of that journey, we got a color for each ray!\n\n\tnow all we need to do is output that color onto the screen , which is a single call,\n\tand we've made our world.\n\n\n\tI know this stuff might seem too dry or too complex at times, too confusing, \n\ttoo frustrating, but I promise, if you stick with it, you'll soon be making some of the\n\tother magical structures you see throughout the rest of this site.\n\n\tI'll be trying to do some more of these tutorials, and you'll see that VERY\n\tquickly, you get from this hideous monstrosity to our left, to marvelous worlds\n\tfilled with lights, colors, and love.\n\n\tThanks for staying around, and please contact me:\n\n\t@vrtree , @cabbibo with questions, concerns , and improvments. Or just comment!\n\n\n\n*\/\n\n\n\n\/\/---------------------------------------------------\n\/\/ SECTION 'B' : BUILDING THE WINDOW\n\/\/---------------------------------------------------\n\n\/\/ Most of this is taken from many of the shaders\n\/\/ that @iq have worked on. Make sure to check out\n\/\/ more of his magic!!!\n\n\n\/\/ This calculation basically gets a way for us to \n\/\/ transform the rays coming out of our eyes and going through the window.\n\/\/ If it doesn't make sense, thats ok. It doesn't make sense to me either :)\n\/\/ Whats important to remember is that this basically gives us a way to position\n\/\/ our window. We could you it to make the window look north, south, east, west, up, down\n\/\/ or ANYWHERE in between!\nmat3 calculateEyeRayTransformationMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n\n\n\n\n\n\n\/\/--------------------------------------------------------------\n\/\/ SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n\/\/--------------------------------------------------------------\n\n\n\/\/'TAG: BALLOON'\nvec2 sdfBalloon( vec3 currentRayPosition ){\n  \n  float ballOrbitSpeed = 0.85;\n  float ballOrbitRadius = 1.0;\n  vec3 ballOrbitOffset = vec3(1.0,0,0);\n    \n  float balloonPosX = ballOrbitRadius * cos( ballOrbitSpeed * iGlobalTime);\n  float balloonPosY = ballOrbitRadius * sin( ballOrbitSpeed * iGlobalTime);\n    \n  \/\/ First we define our balloon position\n  vec3 balloonPosition = ballOrbitOffset + vec3(balloonPosX,balloonPosY,0); \/\/vec3( -1.3 , .3 , -0.4 );\n    \n  \/\/ than we define our balloon radius\n  float balloonRadius = 0.51;\n    \n  \/\/ Here we get the distance to the surface of the balloon\n  float distanceToBalloon = length( currentRayPosition - balloonPosition );\n    \n  \/\/ finally we get the distance to the balloon surface\n  \/\/ by substacting the balloon radius. This means that if\n  \/\/ the distance to the balloon is less than the balloon radius\n  \/\/ the value we get will be negative! giving us the 'Signed' in\n  \/\/ Signed Distance Field!\n  float distanceToBalloonSurface = distanceToBalloon - balloonRadius;\n    \n  \n  \/\/ Finally we build the full balloon information, by giving it an ID\n  float balloonID = 1.;\n    \t\n  \/\/ And there we have it! A fully described balloon!\n  vec2 balloon = vec2( distanceToBalloonSurface,  balloonID );\n    \n  return balloon;\n    \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat opTwist_Torus( vec3 p , vec2 torusS)\n{\n    float twistSpedd = 0.35;\n    float c = cos( 15.0 * (sin( twistSpedd * iGlobalTime)) *p.y );\n    float s = sin( 15.0 * (sin( twistSpedd * iGlobalTime)) *p.y );\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return sdTorus(q, torusS);\n}\n\nvec2 sdfTorus( vec3 currentRayPos )\n{\n    vec3 torusPos = vec3( 0.0, 0.0, 0.0);\n    vec2 torusSpec = vec2(0.6, 0.23);\n    \n    vec3 adjustedRayPos = currentRayPos - torusPos;\n    float distToTorusSurface = opTwist_Torus(adjustedRayPos, torusSpec); \/\/sdTorus(adjustedRayPos, torusSpec);\n    \n    float torusID = 3.;\n    vec2 torus = vec2( distToTorusSurface, torusID);\n    return torus;\n}\n\nfloat smin( float a, float b)\n{\n    float k = 0.77521;\n    float h = clamp( 0.5+0.5*(b-a)\/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opBlend( float d1, float d2)\n{\n    \/\/float d1 = primitiveA(p);\n    \/\/float d2 = primitiveB(p);\n    return smin( d1, d2 );\n}\n\n\nvec2 sdfBox( vec3 currentRayPosition ){\n  \n  \/\/ First we define our box position\n  vec3 boxPosition = vec3( -.8 , -.4 , 0.2 );\n    \n  \/\/ than we define our box dimensions using x , y and z\n  vec3 boxSize = vec3( .4 , .3 , .2 );\n    \n  \/\/ Here we get the 'adjusted ray position' which is just\n  \/\/ writing the point of the ray as if the origin of the \n  \/\/ space was where the box was positioned, instead of\n  \/\/ at 0,0,0 . AKA the difference between the vectors in\n  \/\/ vector format.\n  vec3 adjustedRayPosition = currentRayPosition - boxPosition;\n    \n  \/\/ finally we get the distance to the box surface.\n  \/\/ I don't get this part very much, but I bet Inigo does!\n  \/\/ Thanks for making code for us IQ !\n  vec3 distanceVec = abs( adjustedRayPosition ) - boxSize;\n  float maxDistance = max( distanceVec.x , max( distanceVec.y , distanceVec.z ) ); \n  float distanceToBoxSurface = min( maxDistance , 0.0 ) + length( max( distanceVec , 0.0 ) );\n  \n  \/\/ Finally we build the full box information, by giving it an ID\n  float boxID = 2.;\n    \t\n  \/\/ And there we have it! A fully described box!\n  vec2 box = vec2( distanceToBoxSurface,  boxID );\n    \n  return box;\n    \n}\n\n\n\/\/ 'TAG : WHICH AM I CLOSER TO?'\n\/\/ This function takes in two things\n\/\/ and says which is closer by using the \n\/\/ distance to each thing, comparing them\n\/\/ and returning the one that is closer!\nvec2 whichThingAmICloserTo( vec2 thing1 , vec2 thing2 ){\n \n   vec2 closestThing;\n    \n   \/\/ Check out the balloon function\n   \/\/ and remember how the x of the returned\n   \/\/ information is the distance, and the y \n   \/\/ is the id of the thing!\n   if( thing1.x <= thing2.x ){\n       \n   \t   closestThing = thing1;\n       \n   }else if( thing2.x < thing1.x ){\n       \n       closestThing = thing2;\n       \n   }\n \n   return closestThing;\n    \n}\n\n    \n\n\/\/ Takes in the position of the ray, and feeds back\n\/\/ 2 values of how close it is to things in the world\n\/\/ what thing it is closest two in the world.\nvec2 mapTheWorld( vec3 currentRayPosition ){\n\n\n  vec2 result;\n    \n  vec2 balloon = sdfBalloon( currentRayPosition );\n  \/\/vec2 box     = sdfBox( currentRayPosition );\n  vec2 torus = sdfTorus( currentRayPosition );\n    \n  result = whichThingAmICloserTo( balloon , torus); \/\/box );\n  result.x = opBlend( balloon.x, torus.x);\n    \n    \n  return result;\n\n\n}\n\n\n\n\/\/---------------------------------------------------\n\/\/ SECTION 'C' : NAVIGATING THE WORLD\n\/\/---------------------------------------------------\n\n\/\/ We want to know when the closeness to things in the world is\n\/\/ 0.0 , but if we wanted to get exactly to 0 it would take us\n\/\/ alot of time to be that precise. Here we define the laziness\n\/\/ our navigation function. try chaning the value to see what it does!\n\/\/ if you are getting too low of framerates, this value will help alot,\n\/\/ but can also make your scene look very different\n\/\/ from how it should\nconst float HOW_CLOSE_IS_CLOSE_ENOUGH = 0.0001;\n\n\/\/ This is basically how big our scene is. each ray will be shot forward\n\/\/ until it reaches this distance. the smaller it is, the quicker the \n\/\/ ray will reach the edge, which should help speed up this function\nconst float FURTHEST_OUR_RAY_CAN_REACH = 10.75;\n\n\/\/ This is how may steps our ray can take. Hopefully for this\n\/\/ simple of a world, it will very quickly get to the 'close enough' value\n\/\/ and stop the iteration, but for more complex scenes, this value\n\/\/ will dramatically change not only how good the scene looks\n\/\/ but how fast teh scene can render. \n\n\/\/ remember that for each pixel we are displaying, the 'mapTheWorld' function\n\/\/ could be called this many times! Thats ALOT of calculations!!!\nconst int HOW_MANY_STEPS_CAN_OUR_RAY_TAKE = 2000;\n\n\nvec2 checkRayHit( in vec3 eyePosition , in vec3 rayDirection ){\n\n  \/\/First we set some default values\n \n  \n  \/\/ our distance to surface will get overwritten every step,\n  \/\/ so all that is important is that it is greater than our\n  \/\/ 'how close is close enough' value\n  float distanceToSurface \t\t\t= HOW_CLOSE_IS_CLOSE_ENOUGH * 2.;\n    \n  \/\/ The total distance traveled by the ray obviously should start at 0\n  float totalDistanceTraveledByRay \t= 0.;\n    \n  \/\/ if we hit something, this value will be overwritten by the\n  \/\/ totalDistance traveled, and if we don't hit something it will\n  \/\/ be overwritten by the furthest our ray can reach,\n  \/\/ so it can be whatever!\n  float finalDistanceTraveledByRay \t= -1.;\n    \n  \/\/ if our id is less that 0. , it means we haven't hit anything\n  \/\/ so lets start by saying we haven't hit anything!\n  float finalID = -1.;\n\n    \n    \n  \/\/here is the loop where the magic happens\n  for( int i = 0; i < HOW_MANY_STEPS_CAN_OUR_RAY_TAKE; i++ ){\n      \n    \/\/ First off, stop the iteration, if we are close enough to the surface!\n    if( distanceToSurface < HOW_CLOSE_IS_CLOSE_ENOUGH ) break;\n      \n    \/\/ Second off, stop the iteration, if we have reached the end of our scene! \n    if( totalDistanceTraveledByRay > FURTHEST_OUR_RAY_CAN_REACH ) break;\n    \n    \/\/ To check how close we are to things in the world,\n    \/\/ we need to get a position in the scene. to do this, \n    \/\/ we start at the rays origin, AKA the eye\n    \/\/ and move along the ray direction, the amount we have already traveled.\n    vec3 currentPositionOfRay = eyePosition + rayDirection * totalDistanceTraveledByRay;\n    \n    \/\/ Distance to and ID of things in the world\n    \/\/--------------------------------------------------------------\n\t\/\/ SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n\t\/\/--------------------------------------------------------------\n    vec2 distanceAndIDOfThingsInTheWorld = mapTheWorld( currentPositionOfRay );\n      \n      \n \t\/\/ we get out the results from our mapping of the world\n    \/\/ I am reassigning them for clarity\n    float distanceToThingsInTheWorld = distanceAndIDOfThingsInTheWorld.x;\n    float idOfClosestThingInTheWorld = distanceAndIDOfThingsInTheWorld.y;\n     \n    \/\/ We save out the distance to the surface, so that\n    \/\/ next iteration we can check to see if we are close enough \n    \/\/ to stop all this silly iteration\n    distanceToSurface           = distanceToThingsInTheWorld;\n      \n    \/\/ We are also finalID to the current closest id,\n    \/\/ because if we hit something, we will have the proper\n    \/\/ id, and we can skip reassigning it later!\n    finalID = idOfClosestThingInTheWorld;  \n     \n    \/\/ ATTENTION: THIS THING IS AWESOME!\n   \t\/\/ This last little calculation is probably the coolest hack\n    \/\/ of this entire tutorial. If we wanted too, we could basically \n    \/\/ step through the field at a constant amount, and at every step\n    \/\/ say 'am i there yet', than move forward a little bit, and\n    \/\/ say 'am i there yet', than move forward a little bit, and\n    \/\/ say 'am i there yet', than move forward a little bit, and\n    \/\/ say 'am i there yet', than move forward a little bit, and\n    \/\/ say 'am i there yet', than move forward a little bit, and\n    \/\/ that would take FOREVER, and get really annoying.\n      \n    \/\/ Instead what we say is 'How far until we are there?'\n    \/\/ and move forward by that amount. This means that if\n    \/\/ we are really far away from everything, we can make large\n    \/\/ movements towards the surface, and if we are closer\n    \/\/ we can make more precise movements. making our marching functino\n    \/\/ faster, and ideally more precise!!\n      \n    \/\/ WOW!\n      \n    totalDistanceTraveledByRay += 0.05 * distanceToThingsInTheWorld; \/\/0.001 + distanceToThingsInTheWorld * abs(sin(iGlobalTime)); \/\/distanceToThingsInTheWorld;\n      \n\n  }\n\n  \/\/ if we hit something set the finalDirastnce traveled by\n  \/\/ ray to that distance!\n  if( totalDistanceTraveledByRay < FURTHEST_OUR_RAY_CAN_REACH ){\n  \tfinalDistanceTraveledByRay = totalDistanceTraveledByRay;\n  }\n    \n    \n  \/\/ If the total distance traveled by the ray is further than\n  \/\/ the ray can reach, that means that we've hit the edge of the scene\n  \/\/ Set the final distance to be the edge of the scene\n  \/\/ and the id to -1 to make sure we know we haven't hit anything\n  if( totalDistanceTraveledByRay > FURTHEST_OUR_RAY_CAN_REACH ){ \n  \tfinalDistanceTraveledByRay = FURTHEST_OUR_RAY_CAN_REACH;\n    finalID = -1.;\n  }\n\n  return vec2( finalDistanceTraveledByRay , finalID ); \n\n}\n\n\n\n\n\n\n\n\/\/--------------------------------------------------------------\n\/\/ SECTION 'E' : COLORING THE WORLD\n\/\/--------------------------------------------------------------\n\n\n\n\/\/ Here we are calcuting the normal of the surface\n\/\/ Although it looks like alot of code, it actually\n\/\/ is just trying to do something very simple, which\n\/\/ is to figure out in what direction the SDF is increasing.\n\/\/ What is amazing, is that this value is the same thing \n\/\/ as telling you what direction the surface faces, AKA the\n\/\/ normal of the surface. \nvec3 getNormalOfSurface( in vec3 positionOfHit ){\n    \n\tvec3 tinyChangeX = vec3( 0.001, 0.0, 0.0 );\n    vec3 tinyChangeY = vec3( 0.0 , 0.001 , 0.0 );\n    vec3 tinyChangeZ = vec3( 0.0 , 0.0 , 0.001 );\n    \n   \tfloat upTinyChangeInX   = mapTheWorld( positionOfHit + tinyChangeX ).x; \n    float downTinyChangeInX = mapTheWorld( positionOfHit - tinyChangeX ).x; \n    \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    \n    float upTinyChangeInY   = mapTheWorld( positionOfHit + tinyChangeY ).x; \n    float downTinyChangeInY = mapTheWorld( positionOfHit - tinyChangeY ).x; \n    \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n    \n    float upTinyChangeInZ   = mapTheWorld( positionOfHit + tinyChangeZ ).x; \n    float downTinyChangeInZ = mapTheWorld( positionOfHit - tinyChangeZ ).x; \n    \n    float tinyChangeInZ = upTinyChangeInZ - downTinyChangeInZ;\n    \n    \n\tvec3 normal = vec3(\n         \t\t\ttinyChangeInX,\n        \t\t\ttinyChangeInY,\n        \t\t\ttinyChangeInZ\n    \t \t\t  );\n    \n\treturn normalize(normal);\n}\n\n\n\n\n\n\/\/ doing our background color is easy enough,\n\/\/ just make it pure black. like my soul.\nvec3 doBackgroundColor(){\n\treturn vec3( 0.75 );\n}\n\n\n\n\nvec3 doBalloonColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 sunPosition = vec3( 1. , 4. , 3. );\n    \n    \/\/ the direction of the light goes from the sun\n    \/\/ to the position of the hit\n    vec3 lightDirection = sunPosition - positionOfHit;\n   \t\n    \n    \/\/ Here we are 'normalizing' the light direction\n   \t\/\/ because we don't care how long it is, we\n    \/\/ only care what direction it is!\n    lightDirection = normalize( lightDirection );\n    \n    \n    \/\/ getting the value of how much the surface\n    \/\/ faces the light direction\n    float faceValue = dot( lightDirection , normalOfSurface );\n\t\n    \/\/ if the face value is negative, just make it 0.\n    \/\/ so it doesn't give back negative light values\n    \/\/ cuz that doesn't really make sense...\n    faceValue = max( 0. , faceValue );\n    \n    vec3 balloonColor = vec3( 1. , 0. , 0. );\n    \n   \t\/\/ our final color is the balloon color multiplied\n    \/\/ by how much the surface faces the light\n    vec3 color = balloonColor * faceValue;\n    \n    \/\/ add in a bit of ambient color\n    \/\/ just so we don't get any pure black\n    color += vec3( .3 , .1, .2 );\n    \n    \n\treturn color;\n}\n\n\n\nvec3 doTorusColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 sunPosition = vec3( 1. , 4. , 3. );\n    \n    \/\/ the direction of the light goes from the sun\n    \/\/ to the position of the hit\n    vec3 lightDirection = sunPosition - positionOfHit;\n   \t\n    \n    \/\/ Here we are 'normalizing' the light direction\n   \t\/\/ because we don't care how long it is, we\n    \/\/ only care what direction it is!\n    lightDirection = normalize( lightDirection );\n    \n    \n    \/\/ getting the value of how much the surface\n    \/\/ faces the light direction\n    float faceValue = dot( lightDirection , normalOfSurface );\n\t\n    \/\/ if the face value is negative, just make it 0.\n    \/\/ so it doesn't give back negative light values\n    \/\/ cuz that doesn't really make sense...\n    faceValue = max( 0. , faceValue );\n    \n    vec3 torusColor = vec3( 0.25 , 0.95 , 0.25 );\n    \n   \t\/\/ our final color is the balloon color multiplied\n    \/\/ by how much the surface faces the light\n    vec3 color = torusColor * faceValue;\n    \n    \/\/ add in a bit of ambient color\n    \/\/ just so we don't get any pure black\n    color += vec3( .3 , .1, .2 );\n    \n    \n\treturn color;\n}\n\n\n\/\/ Here we are using the normal of the surface,\n\/\/ and mapping it to color, to show you just how cool\n\/\/ normals can be!\nvec3 doBoxColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 color = vec3( normalOfSurface.x , normalOfSurface.y , normalOfSurface.z );\n    \n    \/\/could also just write color = normalOfSurce\n    \/\/but trying to be explicit.\n    \n\treturn color;\n}\n\n\n\n\n\/\/ This is where we decide\n\/\/ what color the world will be!\n\/\/ and what marvelous colors it will be!\nvec3 colorTheWorld( vec2 rayHitInfo , vec3 eyePosition , vec3 rayDirection ){\n   \n  \/\/ remember for color\n  \/\/ x = red , y = green , z = blue\n  vec3 color;\n    \n  \/\/ THE LIL RAY WENT ALL THE WAY\n  \/\/ TO THE EDGE OF THE WORLD, \n  \/\/ AND DIDN'T HIT ANYTHING\n  if( rayHitInfo.y < 0.0 ){\n      \n  \tcolor = doBackgroundColor();  \n     \n      \n  \/\/ THE LIL RAY HIT SOMETHING!!!!\n  }else{\n      \n      \/\/ If we hit something, \n      \/\/ we also know how far the ray has to travel to hit it\n      \/\/ and because we know the direction of the ray, we can\n      \/\/ get the exact position of where we hit the surface\n      \/\/ by following the ray from the eye, along its direction\n      \/\/ for the however far it had to travel to hit something\n      vec3 positionOfHit = eyePosition + rayHitInfo.x * rayDirection;\n      \n      \/\/ We can then use this information to tell what direction\n      \/\/ the surface faces in\n      vec3 normalOfSurface = getNormalOfSurface( positionOfHit );\n      \n      \n      \/\/ 1.0 is the Balloon ID\n      if( rayHitInfo.y == 1.0 ){\n          \n  \t\tcolor = doBalloonColor( positionOfHit , normalOfSurface ); \n       \n          \n      \/\/ 2.0 is the Box ID\n      }else if( rayHitInfo.y == 2.0 ){\n          \n      \tcolor = doBoxColor( positionOfHit , normalOfSurface );   \n          \n      }\n      else if( rayHitInfo.y == 3.0)\n      {\n          color = doTorusColor( positionOfHit , normalOfSurface );\n      }\n \n  \n  }\n    \n    \n    return color;\n    \n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \/\/---------------------------------------------------\n    \/\/ SECTION 'A' : ONE PROGRAM FOR EVERY PIXEL!\n    \/\/---------------------------------------------------\n    \n    \/\/ Here we are getting our 'Position' of each pixel\n    \/\/ This section is important, because if we didn't\n    \/\/ divied by the resolution, our values would be masssive\n    \/\/ as fragCoord returns the value of how many pixels over we \n    \/\/ are. which is alot :)\n\tvec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) \/ iResolution.y;\n     \n    \/\/ thats a super long name, so maybe we will \n    \/\/ keep on using uv, but im explicitly defining it\n    \/\/ so you can see exactly what those two letters mean\n    vec2 xyPositionOfPixelInWindow = p;\n    \n    \n    \n    \/\/---------------------------------------------------\n    \/\/ SECTION 'B' : BUILDING THE WINDOW\n    \/\/---------------------------------------------------\n    \n    \/\/ We use the eye position to tell use where the viewer is\n    float camRotSpeed = 0.5;\n    float rotRadius = 2.75;\n    float eyePosX = rotRadius * cos( camRotSpeed * iGlobalTime);\n    float eyePosZ = rotRadius * sin( camRotSpeed * iGlobalTime);\n    vec3 eyePosition = vec3( eyePosX, 0.5, eyePosZ); \/\/vec3( 0., 0.5, 2.);\n    \n    \/\/ This is the point the view is looking at. \n    \/\/ The window will be placed between the eye, and the \n    \/\/ position the eye is looking at!\n    vec3 pointWeAreLookingAt = vec3( 0. , 0. , 0. );\n  \n\t\/\/ This is where the magic of actual mathematics\n    \/\/ gives a way to actually place the window.\n    \/\/ the 0. at the end there gives the 'roll' of the transformation\n    \/\/ AKA we would be standing so up is up, but up could be changing \n    \/\/ like if we were one of those creepy dolls whos rotate their head\n    \/\/ all the way around along the z axis\n    mat3 eyeTransformationMatrix = calculateEyeRayTransformationMatrix( eyePosition , pointWeAreLookingAt , 0. ); \n   \n    \n    \/\/ Here we get the actual ray that goes out of the eye\n    \/\/ and through the individual pixel! This basically the only thing\n    \/\/ that is different between the pixels, but is also the bread and butter\n    \/\/ of ray tracing. It should be since it has the word 'ray' in its variable name...\n    \/\/ the 2. at the end is the 'lens length' . I don't know how to best\n    \/\/ describe this, but once the full scene is built, tryin playing with it\n    \/\/ to understand inherently how it works\n    vec3 rayComingOutOfEyeDirection = normalize( eyeTransformationMatrix * vec3( p.xy , 2. ) ); \n\n    \n    \n    \/\/---------------------------------------------------\n\t\/\/ SECTION 'C' : NAVIGATING THE WORLD\n\t\/\/---------------------------------------------------\n    vec2 rayHitInfo = checkRayHit( eyePosition , rayComingOutOfEyeDirection );\n    \n    \n    \/\/--------------------------------------------------------------\n\t\/\/ SECTION 'E' : COLORING THE WORLD\n\t\/\/--------------------------------------------------------------\n\tvec3 color = colorTheWorld( rayHitInfo , eyePosition , rayComingOutOfEyeDirection );\n    \n   \n   \t\/\/--------------------------------------------------------------\n    \/\/ SECTION 'F' : Wrapping up\n    \/\/--------------------------------------------------------------\n\tfragColor = vec4(color,1.0);\n    \n    \n    \/\/ WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW!\n    \/\/ WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    \/\/ WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    \/\/ WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    \/\/ WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    \n    \n}\n\n","name":"","description":"","type":"image"}]}}