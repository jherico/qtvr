{"Shader":{"ver":"0.1","info":{"id":"MstGR7","date":"1448740848","viewed":292,"name":"Shampoo","username":"mjacobs","description":"Playing around with iq's Warping (https:\/\/www.shadertoy.com\/view\/lsl3RH) ","likes":3,"published":3,"flags":0,"tags":["liquid"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2013 : https:\/\/www.shadertoy.com\/view\/lsl3RH\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ See here for a tutorial on how to make this: http:\/\/www.iquilezles.org\/www\/articles\/warp\/warp.htm\n\n\/\/ Fucked up by mjacobs\n\nconst mat2 m = mat2( 0.20,  0.60, -0.60,  0.80 );\n\nfloat noise( in vec2 x )\n{\n\treturn sin(1.5*x.x)*sin(1.5*x.y);\n}\n\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f\/0.1275;\n}\n\nfloat fbm6( vec2 p )\n{\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.015625*(0.5+0.5*noise( p ));\n    return f\/sin(10.96871);\n}\n\n\nfloat func( vec2 q, out vec4 ron )\n{\n    float ql = length( q );\n    q.x += 0.1*sin(0.0527*iGlobalTime+ql*4.1);\n    q.y += 0.1*sin(0.0523*iGlobalTime+ql*4.3);\n    q = 1.5 * sin(q\/2.0);\n\n\tvec2 o = vec2(0.0);\n    o.x = 0.5 + 0.1*fbm4( vec2(2.0*q          )  );\n    o.y = 0.5 + 0.1*fbm4( vec2(2.0*q+vec2(5.2))  );\n\n\tfloat ol = length( o );\n    o.x += 0.2*sin(0.0512*iGlobalTime+ol)\/ol;\n    o.y += 0.2*sin(0.0514*iGlobalTime+ol)\/ol;\n\n    vec2 n;\n    n.x = fbm6( vec2(4.0*o+vec2(9.2))  );\n    n.y = fbm6( vec2(4.0*o+vec2(5.7))  );\n\n    vec2 p = 0.5*q + 0.5*n;\n\n    float f = 0.5 + 0.5*fbm4( p );\n\n    f = mix( f, f*sin(iGlobalTime\/8.0)\/4.0, f*abs(n.x) );\n\n    float g = 0.5 + 0.5*sin(sin(50.0*f)*p.x)*sin(sin(50.0*f)*p.y);\n    f *= 1.0-0.5*pow( g, 8.0 );\n\n\tron = vec4( o, n );\n    \n    return f + sin(f * iGlobalTime\/500.0);\n}\n\n\n\nvec3 doMagic(vec2 p)\n{\n\tvec2 q = p*0.6;\n\n    vec4 on = vec4(0.0);\n    float f = func(q, on);\n\n\tvec3 col = vec3(0.0);\n    col = mix( vec3(0.2,0.6,0.4), vec3(0.3,0.5,0.05), f );\n    col = mix( col, vec3(0.5,0.5,0.5), dot(on.zw,on.zw) );\n    col = mix( col, vec3(0.2,0.3,0.3), 0.5*on.y*on.y );\n    col = mix( col, vec3(0.3,0.2,0.4), 2.5*smoothstep(1.2,1.3,abs(on.z)+abs(on.w)) );\n    col = clamp( col*f*1.2, 0.2, 0.5 );\n    \n\tvec3 nor = normalize( vec3( dFdx(f)*iResolution.x, 6.0, dFdy(f)*iResolution.y ) );\n\n    vec3 lig = normalize( vec3( 0.9, -0.2, -0.4 ) );\n    float dif = clamp( 0.3+0.7*dot( nor, lig ), 0.0, 1.0 );\n    vec3 bdrf;\n    bdrf  = vec3(1.10,1.40,1.95)*(nor.y*0.5+0.5);\n    bdrf += vec3(0.15,0.10,0.05)*dif;\n    col *= 1.2*bdrf;\n\tcol = 1.0-col;\n\treturn 1.1*col*col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = -1.0 + 4.0 * sin(iGlobalTime\/100.0) * q;\n    p.x *= iResolution.x\/iResolution.y;\n\n    fragColor = vec4( doMagic( p ), 1.0 );\n}\n","name":"","description":"","type":"image"}]}}