{"Shader":{"ver":"0.1","info":{"id":"XsBXRV","date":"1418144790","viewed":2135,"name":"Trace cone with CRT effect","username":"klk","description":"raytrace cone, cylinder, sphere, ellips and plane with shadows and reflections<br\/>Keys:<br\/>'A' - dither<br\/>'B' - CRT effect<br\/>'D', 'E' - number of colours if dither is on<br\/>'F' - pixelization<br\/>'G' - antialiasing<br\/>'H' - C64 palette<br\/>'I' - color weights for C64<br\/>","likes":14,"published":3,"flags":0,"tags":["c64","raytrace","palette","cone","256colors","vga","arrows","nostalgia"],"hasliked":0},"renderpass":[{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"precision lowp float;\n#define PI 3.1415926535897932384626433832795\n\n#define KEY_A 65\n#define KEY_B 66\n#define KEY_C 67\n#define KEY_D 68\n#define KEY_E 69\n#define KEY_F 70\n#define KEY_G 71\n#define KEY_H 72\n#define KEY_I 73\n#define KEY_J 74\n#define KEY_K 75\n#define KEY_L 76\n#define KEY_M 77\n#define KEY_N 78\n#define KEY_O 79\n#define KEY_P 80\n#define KEY_Q 81\n#define KEY_R 82\n#define KEY_S 83\n#define KEY_T 84\n#define KEY_U 85\n#define KEY_V 86\n#define KEY_W 87\n#define KEY_X 88\n#define KEY_Y 89\n#define KEY_Z 90\n#define KEY_0 48\n#define KEY_1 49\n#define KEY_2 50\n#define KEY_3 51\n#define KEY_4 52\n#define KEY_5 53\n#define KEY_6 54\n#define KEY_7 55\n#define KEY_8 56\n#define KEY_9 57\n\n\n#define float3 vec3\n#define float2 vec2\n#define float4 vec4\n#define float3x3 mat3\n\nfloat3 campos=float3(-10.0,2.0,0.0);\nfloat3 look_at=float3(0.0,1.0,0.0);\nfloat3 up=float3(0,1,0);\nfloat3 forward;\nfloat3 right;\n\nfloat3 light=float3(0,10,10);\n\nconst float MAX_RAY_LENGTH=10000.0;\n\nvoid RP(float3 tp0, float3 dp1, float3 dp2, float3 rp0, float3 rd, out float t, out float3 uv, out float3 n)\n{\n\tfloat3 dp0=rp0-tp0;\n\n\tfloat3 dett =cross(dp1,dp2);\n\tfloat3 detuv=cross(dp0,rd);\n\n\tfloat det=(-1.0)\/dot(dett,rd);\n\n\tfloat u=(dot(detuv,dp2))*det;\n\tfloat v=(dot(detuv,dp1))*det;\n\tt=(dot(dett ,dp0))*det;\n    if(t<0.0)\n    {\n        t=MAX_RAY_LENGTH;\n        return;\n    }\n    \n   \n\tuv=float3(u,v,0.0);\n    n=normalize(dett);\n}\n\nvoid RDisk(float3 tp0, float3 dp1, float3 dp2, float3 rp0, float3 rd, out float t, out float3 uv, out float3 n)\n{\n\tfloat3 dp0=rp0-tp0;\n\n\tfloat3 dett =cross(dp1,dp2);\n\tfloat3 detuv=cross(dp0,rd);\n\n\tfloat det=(-1.0)\/dot(dett,rd);\n\n\tfloat u=(dot(detuv,dp2))*det;\n\tfloat v=(dot(detuv,dp1))*det;\n\tt=(dot(dett ,dp0))*det;\n    if(t<0.0)\n    {\n        t=MAX_RAY_LENGTH;\n        return;\n    }\n    \n    if((u*u+v*v)>1.0)\n    {\n        t=MAX_RAY_LENGTH;\n        return;\n    }\n        \n\tuv=float3(u,v,0);    \n    n=normalize(dett);\n}\n\nvoid RDDisk(float3 tp0, float3 np0, float r, float3 rp0, float3 rd, out float t, out float3 uv, out float3 n)\n{\n\tfloat3 dp0=rp0-tp0;\n\n\tfloat3 dp1;\n\tfloat3 dp2;\n    np0=normalize(np0);\n\n\tif(abs(np0.x)<abs(np0.y))\n\t\tdp2=float3(1,0,0);\n\telse\n\t\tdp2=float3(0,1,0);\n\t\t\n\tdp1=normalize(cross(dp2,np0))*r;\n\tdp2=normalize(cross(dp1,np0))*r;\n    \n    \n\tfloat3 dett =cross(dp1,dp2);\n\tfloat3 detuv=cross(dp0,rd);\n\n\tfloat det=(-1.0)\/dot(dett,rd);\n\n\tfloat u=(dot(detuv,dp2))*det;\n\tfloat v=(dot(detuv,dp1))*det;\n\tt=(dot(dett ,dp0))*det;\n    if(t<0.0)\n    {\n        t=MAX_RAY_LENGTH;\n        return;\n    }\n    \n    if((u*u+v*v)>1.0)\n    {\n        t=MAX_RAY_LENGTH;\n        return;\n    }\n        \n\tuv=float3(u,v,0);    \n    n=normalize(dett);\n}\n\nvoid RCone(float3 p0, float r0, float3 p1, float r1, float3 rp0, float3 rd, out float t, out float3 uv, out float3 n)    \n{\n\tfloat3 locX;\n\tfloat3 locY;\n\tfloat3 locZ=-(p1-p0)\/(1.0-r1\/r0);\n\n    rp0-=p0-locZ;\n\n\tif(abs(locZ.x)<abs(locZ.y))\n\t\tlocX=float3(1,0,0);\n\telse\n\t\tlocX=float3(0,1,0);\n\t\t\n\tfloat len=length(locZ);\n\tlocZ=normalize(locZ)\/len;\n\tlocY=normalize(cross(locX,locZ))\/r0;\n\tlocX=normalize(cross(locY,locZ))\/r0;\n\n\tfloat3x3 tm;\n\ttm[0]=locX;\n\ttm[1]=locY;\n\ttm[2]=locZ;\n\n    rd=rd*tm;\t\n    rp0=rp0*tm;\n    \t\n\tfloat dx=rd.x;\n\tfloat dy=rd.y;\n\tfloat dz=rd.z;\n\n\tfloat x0=rp0.x;\n\tfloat y0=rp0.y;\n\tfloat z0=rp0.z;\n\n\tfloat x02=x0*x0;\n\tfloat y02=y0*y0;\n\tfloat z02=z0*z0;\n\n\tfloat dx2=dx*dx;\n\tfloat dy2=dy*dy;\n\tfloat dz2=dz*dz;\n\n\tfloat det=(\n\t\t-2.0*x0*dx*z0*dz\n        +2.0*x0*dx*y0*dy\n        -2.0*z0*dz*y0*dy\n        +dz2*x02\n        +dz2*y02\n        +dx2*z02\n        +dy2*z02\n        -dy2*x02\n        -dx2*y02\n        );\n    \n\n    if(det<0.0)\n    {\n\t\tt=MAX_RAY_LENGTH;\n        return;\n    }\n\n\tfloat t0=(-x0*dx+z0*dz-y0*dy-sqrt(abs(det)))\/(dx2-dz2+dy2);\n\tfloat t1=(-x0*dx+z0*dz-y0*dy+sqrt(abs(det)))\/(dx2-dz2+dy2);\n\n\tt=t0;\n\tif(t<0.0)\n    {\n\t\tt=MAX_RAY_LENGTH;\n        return;\n    }\n\n\tfloat3 pt=rp0+t*rd;\n\n\tif(pt.z>1.0)\n    {\n\t\tt=MAX_RAY_LENGTH;\n        return;\n    }\n        \n    if(pt.z<r1\/r0)\n    {\n\t\tt=MAX_RAY_LENGTH;\n        return;\n    }\n\n\tn=float3(pt);\n    uv.z=0.0;\n    uv.y=n.z;\n\tn.z=0.0;\n\tn=normalize(n);\n    uv.x=atan(n.x,n.y)\/2.0\/PI;\n\tn.z=-pt.z\/abs(pt.z);\n\tn=normalize(n);\n    n=tm*n;\n    n=normalize(n);\n}\n\nvoid RSph(float3 p0, float r, float3 rp0, float3 rd, out float t, out float3 uv, out float3 n)\n{\n\tfloat3 l=p0-rp0;\n\tfloat tc=dot(l,rd);\n\tif(tc<0.0)\n    {\n        t=MAX_RAY_LENGTH;\n        return;\n    };\n\n    float d2=r*r+tc*tc-dot(l,l);\n\n\tif(d2<0.0)\n    {\n        t=MAX_RAY_LENGTH;\n        return;\n    };\n\n\tfloat thc=sqrt(d2);\n    t=tc-thc;\n    float3 p=rp0+rd*t;\n    n=normalize(p-p0);\n    uv.x=atan(n.x,n.z)\/2.0\/PI;\n    uv.y=asin(n.y)\/PI;\n    uv.z=0.0;\n}\n\nvoid RCyl(float3 p0, float3 p1, float r, float3 rp0, float3 rd, out float t, out float3 uv, out float3 n)\n{\n\tfloat r2=r*r;\n\n\n\tfloat3 dp=p1-p0;\n\tfloat3 dpt=dp\/dot(dp,dp);\n\n\tfloat3 ao=rp0-p0;\n\tfloat3 aoxab=cross(ao,dpt);\n\tfloat3 vxab=cross(rd,dpt);\n\tfloat ab2=dot(dpt,dpt);\n\tfloat a=2.0*dot(vxab,vxab);\n\tfloat ra=1.0\/a;\n\tfloat b=2.0*dot(vxab,aoxab);\n\tfloat c=dot(aoxab,aoxab)-r2*ab2;\n\n\tfloat det=b*b-2.0*a*c;\n\n\tif(det<0.0)\n    {\n\t\tt=MAX_RAY_LENGTH;\n        return;\n     }\n\n\n\tdet=sqrt(det);\n\n    float t0=(-b+det)*ra;\n\tfloat t1=(-b-det)*ra;\n\n\tif(t0>t1)\n\t{\n\t\tfloat temp=t1;\n\t\tt1=t0;\n\t\tt0=temp;\n\t}\n\tfloat d=t0;\n\tif(d<0.0)\n    {\n\t\tt=MAX_RAY_LENGTH;\n        return;\n    }\n\n\tfloat3 ip=rp0+rd*d;\n\tfloat3 lp=ip-p0;\n\tfloat ct=dot(lp,dpt);\n\tif((ct<0.0)||(ct>1.0))\n\t{\n\t\td=t1;\n\t\tif(d<0.0)\n        {\n            t=MAX_RAY_LENGTH;\n            return;\n        }\n\n\t\tip=rp0+rd*d;\n\t\tfloat3 lp=ip-p0;\n        float ct=dot(lp,dpt);\n\t\tif((ct<0.0)||(ct>1.0))\n        {\n        \tt=MAX_RAY_LENGTH;\n            return;\n        }\n\t}\n\n\tt=d;\n    n=normalize(ip-(p0+dp*ct));\n    uv.y=ct;\n\tuv.x=n.x;\n    uv.z=0.0;\n}\n\nvoid RRCone(float3 p0, float r0, float3 p1, float r1, float3 rp0, float3 rd, out float t, out float3 uv, out float3 n)\n{\n float3 l  = p1-p0;\n float ld = length(l);\n l=l\/ld;\n float d=r0-r1;\n float sa = d\/ld;\n float h0=r0*sa;\n float h1=r1*sa;\n float cr0 = sqrt(r0*r0-h0*h0);\n float cr1 = sqrt(r1*r1-h1*h1);\n float3 coneP0=p0+l*h0;\n float3 coneP1=p1+l*h1;\n    \n    float t0=MAX_RAY_LENGTH;\n    {\n        float t1;\n        float3 uv1;\n        float3 n1;\n\t    RCone(coneP0,cr0,coneP1,cr1,rp0,rd,t1,uv1,n1);\n        if(t1<t0)\n        {\n            t0=t1;\n            uv=uv1;\n            n=n1;\n        }\n\t    RSph(p0,r0,rp0,rd,t1,uv1,n1);\n        if(t1<t0)\n        {\n            t0=t1;\n            uv=uv1;\n            n=n1;\n        }\n\t    RSph(p1,r1,rp0,rd,t1,uv1,n1);\n        if(t1<t0)\n        {\n            t0=t1;\n            uv=uv1;\n            n=n1;\n        }\n    }\n    t=t0;\n    \n}\n\nfloat3x3 Transpose(in float3x3 m)\n{\n\tfloat3 i0 = m[0];\n\tfloat3 i1 = m[1];\n\tfloat3 i2 = m[2];\n\tfloat3x3 o=float3x3(\n                 float3(i0.x, i1.x, i2.x),\n                 float3(i0.y, i1.y, i2.y),\n                 float3(i0.z, i1.z, i2.z)\n                 );\n\treturn o;\n}\nvoid REll(float3 p0, float3 r0, float3 r1, float3 r2, float3 rp0, float3 rd, out float t, out float3 uv, out float3 n)\n{\n    float3 irp0=rp0-p0;\n\/\/\tfloat3 ir0=r0;\n\/\/\tfloat3 ir1=r1;\n\/\/\tfloat3 ir2=r2;\n\n    float3 ir0=r0\/dot(r0,r0);\n\tfloat3 ir1=r1\/dot(r1,r1);\n\tfloat3 ir2=r2\/dot(r2,r2);\n\/\/\tr0=normalize(r0)\/length(r0);\n\/\/\tr1=normalize(r1)\/length(r1);\n\/\/\tr2=normalize(r2)\/length(r2);\n\n\tfloat3x3 tm;\n\ttm[0]=ir0;\n\ttm[1]=ir1;\n\ttm[2]=ir2;\n\n\/\/    tm=Transpose(tm);\n    \n    float3 ird=rd*tm;\t\n    irp0=irp0*tm;\t\n    float t1=MAX_RAY_LENGTH;\n    float3 uv1;\n    float3 n1;\n    float lr=length(ird);\n    ird=normalize(ird);\n    RSph(float3(0.0,0.0,0.0),1.0,irp0,ird,t1,uv1,n1);\n    n=normalize(tm*n1);\n    t=t1\/lr;\n    uv=uv1;\n}\n\nvoid trace(float3 rp0, float3 rd, out float t, out float3 col, out float3 n)\n{\n    float t1=MAX_RAY_LENGTH;\n    float3 col1;\n    float3 n1;\n\n    {\n    \tRP(float3(0.0,-1.0,0.0),float3(-1.0,0.0,0.0),float3(0.0,0,1.0),rp0, rd, t1, col1, n1);\n        float3 p=rp0+rd*t1;\n    \tcol1=float3(floor(mod(floor(p.z), 2.0)));\n        if(mod(floor(p.x),2.0)==0.0)\n        {\n            p\/=2.0;\n    \t\tcol1=float3(floor(mod(floor(p.x+p.z+0.25)+floor(p.z-p.x+0.25), 2.0)));\n        }\n            \n    }\n\n    t=t1;\n    col=col1;\n    n=n1;\n\n\n    float3 coneP0=float3(0.0,0.0,0.0);\n    float3 coneP1=float3(0.0,0.0,3.0);\n    {\n        float t1;\n        float3 col1;\n        float3 n1;\n\t    RCone(coneP0,2.0,coneP1,1.0,rp0,rd,t1,col1,n1);\n        if(t1<t)\n        {\n            col=float3(1.0,0.5,0.0);\n            float x=mod(floor(col1.x*8.0)+floor(col1.y*4.0),2.0);\n            col=float3(x,x,x);\n            t=t1;\n            n=n1;\n        }\n    }\n    \n    {\n        float t2=MAX_RAY_LENGTH;\n        float3 col2;\n        float3 n2;\n\/\/\t    RSph(float3(-1.0,1.0,sin(iGlobalTime)*4.0),1.0,rp0,rd,t1,col1,n1);\n        REll(\n            \/\/float3(-1.0,1.0,sin(iGlobalTime)*4.0),\n            float3(0.0,3.0,0.0),\n             float3(1.0,0.0,0.0),\n             float3(0.0,2.0,0.0),\n             float3(0.0,0.0,1.0),\n             rp0,rd,t2,col2,n2);\n        if(t2<t)\n        {\n            float x=mod(floor(col2.x*8.0)+floor(col2.y*4.0),2.0);\n            col=float3(x,x,x);\n            t=t2;\n            n=n2;\n        }\n    }\n    \n\/\/return;\n    \n    {\n        float t1;\n        float3 col1;\n        float3 n1;\n\t    RDDisk(coneP0,coneP1-coneP0,2.0,rp0,rd,t1,col1,n1);\n        if(t1<t)\n        {\n            col=float3(1.0,0.5,0.0);\n            t=t1;\n            n=n1;\n        }\n    }\n\n    {\n        float t1;\n        float3 col1;\n        float3 n1;\n\t    RDDisk(coneP1,coneP0-coneP1,1.0,rp0,rd,t1,col1,n1);\n        if(t1<t)\n        {\n            col=float3(1.0,0.5,0.0);\n            t=t1;\n            n=n1;\n        }\n    }\n    \n    \n\n    {\n        float t1;\n        float3 col1;\n        float3 n1;\n\t    RSph(float3(1.0,3.0,3.0),0.4,rp0,rd,t1,col1,n1);\n        if(t1<t)\n        {\n            col=float3(1.0,0.0,0.0);\n            t=t1;\n            n=n1;\n        }\n    }\n\n    {\n        float t1;\n        float3 col1;\n        float3 n1;\n\t    RDisk(float3(0.0,0.0,1.0),float3(0.0,-1.0,0.0),float3(1.0,0.0,0.0),rp0,rd,t1,col1,n1);\n        if(t1<t)\n        {\n            col=float3(1.0,0.5,0.0);\n            t=t1;\n            n=n1;\n        }\n    }\n    \n    {\n        float t1;\n        float3 col1;\n        float3 n1;\n\t    RCyl(float3(0.0,0.0,1.0),float3(0.0,0.0,-1.0),1.0,rp0,rd,t1,col1,n1);\n        if(t1<t)\n        {\n            col=float3(1.0,0.5,0.0);\n            t=t1;\n            n=n1;\n        }\n    }\n\n    {\n        float t1;\n        float3 col1;\n        float3 n1;\n\t    RRCone(float3(3.0,0.0,2.0),1.0,float3(3.0,0.0,1.0),0.5,rp0,rd,t1,col1,n1);\n        if(t1<t)\n        {\n            col=float3(0.0,1.0,0.0);\n            t=t1;\n            n=n1;\n        }\n    }\n    \n    {\n        float t1;\n        float3 col1;\n        float3 n1;\n\t    RSph(float3(0.0,0.0,-1.0),1.0,rp0,rd,t1,col1,n1);\n        if(t1<t)\n        {\n            col=float3(1.0,0.5,0.0);\n            t=t1;\n            n=n1;\n        }\n    }\n}\n\n\nvoid lit(in float3 p, in float3 rd, in float3 n, in float3 icol, out float3 col)\n{\n    float3 tolight=normalize(light-p);\n\n    float diffuse=clamp(dot(tolight,n),0.0,1.0);\n    \n    float3 halfNormal=normalize(tolight-rd);\n\n    float3 nr=n*dot(n,-rd);\n    float3 refl=normalize(-rd+(nr+rd)*2.0);\n    \n    float fresnel=(1.0-dot(-rd,n));\n    float RF=0.2;\n    fresnel=RF+(1.0-RF)*pow(1.0-dot(-rd,n),5.0);\n    diffuse*=1.0-fresnel;\n    \n    float spec1=clamp(dot(n,halfNormal),0.0,1.0);\n    float spec2=clamp(dot(tolight,refl),0.0,1.0);\n    \n    spec1=pow(spec1,20.0);\n    spec2=pow(spec2,80.0)*2.0;\n    float spec=spec1+(1.0-spec1)*spec2;\n    \n    diffuse=pow(diffuse,1.5);\n\n    float shadow=1.0;\n    float t1=MAX_RAY_LENGTH;\n    float3 cols;\n    float3 ns;\n    trace(p+tolight*0.01,tolight,t1,cols,ns);\n    if(t1<1000.0)\n    {\n       shadow=0.0;\n       spec=0.0;\n    }\n    diffuse*=shadow;\n    \n    col=icol;\n    \n    col*=(0.2+diffuse*0.8);\n    col=clamp(col+(0.5+col*0.5)*spec1*(0.2+fresnel),0.0,1.0);\n    col=mix(col,float3(1.0,1.0,1.0), clamp(spec2*diffuse*(1.0+fresnel),0.0,1.0));\n}\n\nvoid shade(float3 rp0, float3 rd, out float t, out float3 col, out float3 n)\n{\n    trace(rp0,rd,t,col,n);\n\/\/\tcol=n*0.5+0.5;\n    float3 tolight=normalize(light-(rp0+rd*t));\n    float diffuse=clamp(dot(tolight,n),0.0,1.0);\n    \n    float3 halfNormal=normalize(tolight-rd);\n\n    float3 nr=n*dot(n,-rd);\n    float3 refl=normalize(-rd+(nr+rd)*2.0);\n    \n    float fresnel=(1.0-dot(-rd,n));\n    float RF=0.2;\n    fresnel=RF+(1.0-RF)*pow(1.0-dot(-rd,n),5.0);\n    diffuse*=1.0-fresnel;\n    \n    float spec1=clamp(dot(n,halfNormal),0.0,1.0);\n    float spec2=clamp(dot(tolight,refl),0.0,1.0);\n    \n    spec1=pow(spec1,20.0);\n    spec2=pow(spec2,80.0)*2.0;\n    float spec=spec1+(1.0-spec1)*spec2;\n\/\/\tspec=spec*1.2;\n    float3 pos;\n\/\/    pos=n;col=fract(pos*0.5+0.5);\n\/\/    pos=rp0+rd*t;col=fract(pos*4.0);\n\/\/    return;\n    \n\tfloat shadow=1.0;\n\/\/    if(false)\n    {\n\t    float t1=MAX_RAY_LENGTH;\n    \tfloat3 col1;\n    \tfloat3 n1;\n        float3 pos=rp0+t*rd+n*0.001;\n        trace(pos,normalize(light-pos), t1, col1, n1);\n        if(t1<MAX_RAY_LENGTH)\n        {\n            shadow=0.0;\n            spec=0.0;\n        }\n    }\n    spec1*=shadow;\n    spec2*=shadow;\n    diffuse=pow(diffuse,1.5);\n    diffuse*=shadow;\n    col*=(0.2+diffuse*0.8);\n\/\/\treturn;\n\/\/    if(false)\n    {\n        \n\t    float t1=MAX_RAY_LENGTH;\n    \tfloat3 col1;\n    \tfloat3 n1;\n        float3 pos=rp0+t*rd+n*0.001;\n        trace(pos,refl, t1, col1, n1);\n        float3 fogcol=mix(float3(0.87,0.8,0.83),float3(0.3,0.6,1.0),1.0-(1.0-refl.y)*(1.0-refl.y));\n        float fogf=clamp(1.8\/(exp(t1*0.25)),0.0,1.0);\n        float3 col2=col1;\n        lit(pos+refl*t1, refl, n1, col2, col1);\n    \tcol1=mix(fogcol,col1,fogf);\n\t    \n        \n\/\/        if(t1<MAX_RAY_LENGTH)\n        {\n\/\/            col+=(col*0.5+0.5)*col1\/exp(t1*0.05)*clamp(dot(tolight,n1),0.0,1.0)*fresnel;\n            col+=col1*(0.3+fresnel*0.7);\n        }\n    }\n\n    col=clamp(col+(0.5+col*0.5)*spec1*(0.2+fresnel),0.0,1.0);\n    col=mix(col,float3(1.0,1.0,1.0), clamp(spec2*diffuse*(1.0+fresnel),0.0,1.0));\n\n    float3 fogcol=mix(float3(0.87,0.8,0.83),float3(0.3,0.6,1.0),1.0-(1.0-rd.y)*(1.0-rd.y));\n    float sun=clamp(dot(normalize(light-rp0),rd),0.0,1.0);\n    fogcol+=\n        pow(sun,1200.0)*float3(1.0,0.7,0.3)*0.5\n        +pow(sun,5.0)*float3(1.0,0.7,0.5)*0.15;\n    col=mix(fogcol,col,clamp(1.8\/(exp(t*0.025)),0.0,1.0));\n    \n    \n\/\/    col*=(0.5+shadow*0.5);\n}\n\nfloat scurve(float x)\n{\n    return (3.0-2.0*x)*x*x;\n}\n\nfloat tooth(float x)\n{\n    x=fract(x);\n    x=abs(x-0.5)*2.0;\n    x=scurve(x);\n    return x;\n}\n\nvec4 crt(vec2 pos)\n{\n   float l=0.5+tooth(pos.y\/3.0+0.5)*0.75;\n   float dx=tooth(pos.y\/3.0*1.6+1.0\/4.0);\n   vec3 rgb=vec3(\n    tooth(pos.x\/3.0*1.6+dx        ),\n    tooth(pos.x\/3.0*1.6+dx+1.0\/3.0),\n    tooth(pos.x\/3.0*1.6+dx+2.0\/3.0)\n    )*0.8+0.6;\n   return vec4(rgb*l, 1.0);\n}\n\/*\nint dp(int i)\n{\n    if(i==0)\n        return 0;\n    else if(i==1)\n        return 2;\n    else if(i==2)\n        return 3;\n    else if(i==3)\n        return 1;\n    else return 0;\n}\n\n\nfloat dith(float2 xy)\n{\n    int x=int(floor(xy.x));\n    int y=int(floor(xy.y));\n    int v=0;\n    int sz=8;\n    int mul=1;\n    for(int i=0;i<4;i++)\n    {\n    \tv+=dp(((x\/sz)%2+2*((y\/sz)%2))%4)*mul;\n        sz\/=2;\n        mul*=4;\n    }\n\treturn float(v)\/float(mul-1);\n}\n\n*\/\n\n\nfloat dp(float i)\n{ \n    i=floor(i);\n    return i*2.0-floor(i\/2.0)-floor(i\/3.0)*4.0;\n}\n\nfloat fmod(float x, float m)\n{\n    return fract(x\/m)*m;\n}\n\n\nfloat dith(float2 xy)\n{\n    float x=floor(xy.x);\n    float y=floor(xy.y);\n    float v=0.0;\n    float sz=16.0;\n    float mul=1.0;\n    for(int i=0;i<5;i++)\n    {\n    \t\tv+=dp(\n                fmod(fmod(x\/sz,2.0)+2.0*fmod(y\/sz,2.0),4.0)\n            )*mul;\n        sz\/=2.0;\n        mul*=4.0;\n    }\n\treturn float(v)\/float(mul-1.0);\n}\n\nbool keyPressed(int key)\n{\n\treturn texture2D(iChannel2,float2((float(key)+0.5)\/256.0,0.25)).x>0.0;\n}\n\nbool keyToggled(int key)\n{\n\treturn texture2D(iChannel2,float2((float(key)+0.5)\/256.0,0.75)).x>0.0;\n}\n\nfloat3 c64col(int c)\n{\n    float3 col = float3(  0.0,   0.0,   0.0);\n    if      (c ==  0)col = float3(  0.0,   0.0,   0.0);\n    else if (c ==  1)col = float3(  1.0,   1.0,   1.0);\n    else if (c ==  2)col = float3(103.7,  55.4,  43.0)\/255.0;\n    else if (c ==  3)col = float3(111.9, 163.5, 177.9)\/255.0;\n    else if (c ==  4)col = float3(111.4,  60.7, 133.6)\/255.0;\n    else if (c ==  5)col = float3( 88.1, 140.6,  67.1)\/255.0;\n    else if (c ==  6)col = float3( 52.8,  40.3, 121.4)\/255.0;\n    else if (c ==  7)col = float3(183.9, 198.7, 110.6)\/255.0;\n    else if (c ==  8)col = float3(111.4,  79.2,  37.2)\/255.0;\n    else if (c ==  9)col = float3( 66.9,  57.4,   0.0)\/255.0;\n    else if (c == 10)col = float3(153.7, 102.6,  89.1)\/255.0;\n    else if (c == 11)col = float3( 67.9,  67.9,  67.9)\/255.0;\n    else if (c == 12)col = float3(107.8, 107.8, 107.8)\/255.0;\n    else if (c == 13)col = float3(154.2, 209.8, 131.6)\/255.0;\n    else if (c == 14)col = float3(107.8,  94.1, 180.9)\/255.0;\n    else             col = float3(149.5, 149.5, 149.5)\/255.0;\n    return col;\n}\n\nfloat3 cgacol(int c)    \n{\n    float3 col;\n\/*\n    col = float3(  0.0,   0.0,   0.0);\n    if      (c ==  1)col = float3(  1.0,   1.0,   1.0);\n    return col;\n\n  col = float3(  0.0,   0.0,   0.5);\n    if      (c ==  1)col = float3(  0.0,   0.5,   0.25);\n    else if (c ==  2)col = float3(  1.0,  0.65,  0.0);\n    else if (c ==  3)col = float3(  1.0,   0.85,   0.85);\n    return col;\n*\/\n    col = float3(  0.0,   0.0,   0.0);\n    if      (c ==  1)col = float3(  0.0,   1.0,   1.0);\n    else if (c ==  2)col = float3(  1.0,   0.0,   1.0);\n    else if (c ==  3)col = float3(  1.0,   1.0,   1.0);\n    return col;\n}  \n\nfloat3 simple8col(int c)    \n{\n    float3 col = float3(  0.0,   0.0,   0.0);\n    if      (c ==  0)col = float3(  0.0,   0.0,   0.0);\n    else if (c ==  1)col = float3(  0.0,   0.0,   1.0);\n    else if (c ==  2)col = float3(  0.0,   1.0,   0.0);\n    else if (c ==  3)col = float3(  0.0,   1.0,   1.0);\n    else if (c ==  4)col = float3(  1.0,   0.0,   0.0);\n    else if (c ==  5)col = float3(  1.0,   0.0,   1.0);\n    else if (c ==  6)col = float3(  1.0,   1.0,   0.0);\n    else if (c ==  7)col = float3(  1.0,   1.0,   1.0);\n    return col;\n}\nfloat3 egacol(int c)    \n{\n    float3 col = float3(  0.0,   0.0,   0.0);\n    if      (c ==  0)col = float3(  0.0,   0.0,   0.0);\n    else if (c ==  1)col = float3(170.0,   0.0,   0.0);\n    else if (c ==  2)col = float3(  0.0, 170.0,   0.0)\/255.0;\n    else if (c ==  3)col = float3(170.0,  85.0,   0.0)\/255.0;\n    else if (c ==  4)col = float3(  0.0,   0.0, 170.0)\/255.0;\n    else if (c ==  5)col = float3(170.0,   0.0, 170.0)\/255.0;\n    else if (c ==  6)col = float3(  0.0, 170.0, 170.0)\/255.0;\n    else if (c ==  7)col = float3(170.0, 170.0, 170.0)\/255.0;\n    else if (c ==  8)col = float3( 85.0,  85.0,  85.0)\/255.0;\n    else if (c ==  9)col = float3(255.0,  85.0,  85.0)\/255.0;\n    else if (c == 10)col = float3( 85.0, 255.0,  85.0)\/255.0;\n    else if (c == 11)col = float3(255.0, 255.0,  85.0)\/255.0;\n    else if (c == 12)col = float3( 85.0,  85.0, 255.0)\/255.0;\n    else if (c == 13)col = float3(255.0,  85.0, 255.0)\/255.0;\n    else if (c == 14)col = float3( 85.0, 255.0, 255.0)\/255.0;\n    else             col = float3(255.0, 255.0, 255.0)\/255.0;\n    return col;\n}\n\nfloat3 amiga4col(int c)\n{\n    float3 col = float3(  0.0,   0.0,   0.0);\n    if      (c ==  0)col = float3(  0.0,   0.4,   1.0);\n    else if (c ==  1)col = float3(  1.0,   0.6,   0.0);\n    else if (c ==  2)col = float3(  1.0,   1.0,   1.0);\n    return col;\n}\n\nfloat3 palette(int c)\n{\n    if(keyToggled(KEY_J))\n    \treturn simple8col(c);\n    else if(keyToggled(KEY_K))\n    \treturn egacol(c);\n    else if(keyToggled(KEY_L))\n    \treturn cgacol(c);\n    return c64col(c);\n    return amiga4col(c);\n}\n\nfloat3 nearestcol(float3 col)\n{\n    const float3 W=float3(0.299,0.587,0.114);\n\/\/    const float3 W=float3(0.21,0.72,0.07);\n    float3 res;\n    float rv=100.0;\n    float luma0=dot(col,W);\n    for(int i=0;i<16;i++)\n    {\n        float3 icol=palette(i);\n        float3 dist=col-icol;\n\/\/        dist*=dist;\n\t\tif(keyToggled(KEY_I))\n        \tdist*=W;\n        \n        float d=dot(dist,dist);\n        float luma=luma0-dot(icol,W);\n\t\tif(keyToggled(KEY_O))\n\t        d=d*0.75+luma*luma*0.25;\n        if(d<rv)\n        {\n            res=icol;\n            rv=d;\n        }\n    }\n    return res;\n}\n\n\nfloat3 pixelRay(float2 uv)\n{\n    if(!keyToggled(KEY_R))\n    {\n\t\tuv*=0.75;\n\t  \treturn normalize(forward+up*uv.y+right*uv.x);\n    }\n    else\n    {\n\t\tuv*=0.65;\n        if(dot(uv,uv)>1.0)\n            return float3(0.0);\n        \n        float z=sqrt(1.0-uv.x*uv.x-uv.y*uv.y)*1.95-0.95;\n        float3 uvz=float3(uv,z);\n        uvz=normalize(uvz);\n        return normalize(forward*uvz.z+up*uvz.y+right*uvz.x);\n    }\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float T=iGlobalTime*0.45;\n    \n    light.x=cos(T)*10.0;\n    light.z=sin(T)*10.0;\n    light.y=5.0;\n    \n    float mposx=iMouse.x;\n    float mposy=iMouse.y;\n    if(iMouse.z<0.0)mposx=-iMouse.z;\n    if(iMouse.w<0.0)mposy=-iMouse.w;\n    \n    float a1=-(mposy\/iResolution.y)*PI\/2.1+0.1;\n    float a2=mposx\/iResolution.x*PI*2.0-0.3;\n    campos.y=sin(a1)*campos.x;\n    float camx=cos(a1)*6.0;\n    campos.x=cos(a2)*camx;\n    campos.z=sin(a2)*camx;\n    campos+=look_at;\n    \n    forward=normalize(look_at-campos);\n    right=normalize(cross(up,forward));\n    up=normalize(cross(forward,right));\n    \n\tfloat2 scr = fragCoord.xy \/iResolution.xy;\n\/\/    scr.x+=sin(iGlobalTime*140.0+scr.y*0.1)*0.001;\n    scr=2.0*scr-1.0;\n\/\/    scr.x*=(iResolution.x\/iResolution.y);\n    \n    float2 dscr;\n    dscr=floor(scr*iResolution.xy\/6.0)*6.0;\n    if(keyToggled(KEY_F))\n        dscr=scr*iResolution.xy;\n\n    scr=dscr\/iResolution.xy;\n    float2 scruv=scr;\n    \n    float2 scr2ray=scruv;\n    float ratio=(iResolution.x\/iResolution.y);\n    scr2ray.x*=ratio;\n\n    float3 ray=pixelRay(scr2ray);\n\n    float3 col=float3(0.0,0.0,0.0);\n    float3 n;\n\n    \n\/\/    shade(campos, ray, t, col, n);\n    float w=0.0;\n    float3 col1;\n    const float nx=3.0;\n    const float ny=2.0;\n    \n    if(keyToggled(KEY_G))\n    {\n\t    float t=MAX_RAY_LENGTH;\n    \tshade(campos, pixelRay(scr2ray), t, col, n);\n        w=1.0;\n    }\n\telse        \n\tfor(float i=0.0;i<ny;i+=1.001)\n    {\n\t\tfor(float j=0.0;j<nx;j+=1.001)\n        {\n\t\t    float t=MAX_RAY_LENGTH;\n\t    \tshade(campos, pixelRay(scr2ray\n                                   +3.0*float2((j*1.0\/(nx+0.0))\/iResolution.y,\n                                               (i*1.0\/(ny+0.0))\/iResolution.y)), t, col1, n);\n            w=w+1.0;\n            col+=col1;\n        }\n    }\n  \tcol=col\/w;\n\n    \n    float3 suncol=float3(0.0,0.0,0.0);\n    float sunvis=0.0;\n    for(int i=-4;i<5;i++)\n    {\n        float t;\n        float3 col1;\n        float3 n; \n    \ttrace(campos,normalize(light-campos+0.05*right*(float(i))),t,col1,n);\n        if(t==MAX_RAY_LENGTH)\n        {\n\t\t\tfloat sun=clamp(dot(normalize(light-campos),pixelRay(scr2ray)),0.0,1.0);\n\t\t\tsuncol+=pow(sun,25.0)*float3(1.0,0.7,0.5)*0.1;\n            sunvis+=1.0;\n        }\n            \n    }\n    for(int i=-3;i<3;i++)\n    {\n        float t;\n        float3 col1;\n        float3 n;\n        float3 tolight=normalize(light-campos);\n        float3 tolight0=tolight;\n        \n        tolight=normalize(forward+(-up*dot(up,tolight)-right*dot(right,tolight)*ratio)*(1.0+float(i)*0.15));\n\/\/        tolight=normalize(forward-(tolight-forward));\n    \ttrace(campos,tolight0,t,col1,n);\n        if(t==MAX_RAY_LENGTH)\n        {\n\t\t\tfloat sun=clamp(dot(tolight,pixelRay(scr2ray)),0.0,1.0);\n\t\t\tsuncol+=clamp(pow(sun,350.0-float(i)*30.0),0.0,0.25)*float3(1.0,0.7,0.5);\n        }\n            \n    }\n\tcol=col*(1.0-sunvis\/25.0)+suncol;\n    \n  \n    col=col-0.25*dot(scruv.xy*abs(scruv.xy),scruv.xy);\n\n    \n    \n    \n\/\/    fragColor = float4(col,1.0);return;\n\tif(keyToggled(KEY_Z))\n    {\n        vec2 uv = (fragCoord.xy-iMouse.xy) \/ max(iResolution.x,iResolution.y)*4.0-0.5;\n        float t=iGlobalTime;\n        float r=length(uv)-t;\n        float a=atan(uv.x,uv.y)\/PI\/2.0+sin(r+t)*0.1;\n\n        col.r+=(0.5+0.5*sin(r*2.915+150.0))+(0.5+0.5*sin(-r*3.915+150.0));\n        col.g+=(0.5+0.5*sin(r*2.533- 11.0))+(0.5+0.5*sin(-r*3.213+ 57.0));\n        col.b+=(0.5+0.5*sin(r*2.107      ))+(0.5+0.5*sin(-r*3.515+150.0));\n        col.r+=(0.5+0.5*sin(r*6.315+150.0))+(0.5+0.5*sin(-r*7.915+ 50.0));\n        col.g+=(0.5+0.5*sin(r*6.533- 11.0))+(0.5+0.5*sin(-r*7.213+ 77.0));\n        col.b+=(0.5+0.5*sin(r*6.107      ))+(0.5+0.5*sin(-r*7.515+150.0));\n        col*=0.25;\n    }\n    \n    \n\n\/\/    float2 dscr=floor((fragCoord.xy)\/3.0)*3.0;\n    float vd=dith(fragCoord.xy)-0.5;\n    vd=(dith(dscr\/2.0)-0.5);\n\/\/    vd=dith(scr*iResolution.xy\/2.0    )-0.5;\n    \n    float lvlsR=1.0;\/\/floor(mposx\/4.0)+1.0;\n    if(keyToggled(KEY_C))\n        lvlsR+=1.0;\n    if(keyToggled(KEY_D))\n        lvlsR+=2.0;\n    if(keyToggled(KEY_E))\n        lvlsR+=4.0;\n    float lvlsG=lvlsR;\/\/floor(mposx\/4.0)+1.0;\n    float lvlsB=lvlsR;\/\/floor(mposx\/4.0)+1.0;\n\/\/    if(fragCoord.x<iMouse.x)\n    if(keyToggled(KEY_A))\n    {\n        if(keyToggled(KEY_H))\n        {\n\t        if(keyToggled(KEY_M))\n    \t        vd*=1.5;\n            col=float3(col.x+vd\/(lvlsR),col.y+vd\/(lvlsG),col.z+vd\/(lvlsB));\n            col=nearestcol(col);\n\t\t    if(fragCoord.y<25.0)\n\t\t        col=palette(int(fragCoord.x\/iResolution.x*16.0));\n        }\n        else\n\t    col=float3(\n    \t    floor((col.x+vd\/(lvlsR))*(lvlsR)+0.5)\/(lvlsR),\n        \tfloor((col.y+vd\/(lvlsG))*(lvlsG)+0.5)\/(lvlsG),\n        \tfloor((col.z+vd\/(lvlsB))*(lvlsB)+0.5)\/(lvlsB)\n    \t);\n    }\n    fragColor = float4(col,1.0);\n    if(keyToggled(KEY_B))\n\t    fragColor = clamp(fragColor,0.0,1.0)*crt(fragCoord.xy);\n}\n\n","name":"","description":"","type":"image"}]}}