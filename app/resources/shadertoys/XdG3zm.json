{"Shader":{"ver":"0.1","info":{"id":"XdG3zm","date":"1453656261","viewed":119,"name":"2D Radial Repeat : Hex RadClick","username":"aiekick","description":"radial grid click<br\/>ckicl on cells for fullscreen","likes":7,"published":3,"flags":0,"tags":["2d","radial","hex","repeat","gridclick"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Stephane Cuillerdier - @Aiekick\/2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ Tuned via XShade (http:\/\/www.funparadigm.com\/xshade\/)\n\/\/ based on https:\/\/www.shadertoy.com\/view\/XdKGRD\n\nconst float sections = 9.; \/\/ count radial section\nconst vec3 startColor = vec3(1,0.26,0);\nconst vec3 endColor = vec3(0.33,0.2,0.49);\nconst float zoom = 1.6; \/\/ screen coord zoom\nconst float neutralSection = 5.; \/\/ if of central section\nconst float neutralZone = 0.5; \/\/ radius of neutral zone (in center) wich show the neutralSection id\n\n#define SHOW_SECTION_ID_NUMBER\n\n\/\/ based on iq Bricks Game PrintInt Func : https:\/\/www.shadertoy.com\/view\/MddGzf\n\/\/ himself based on P_Malin (https:\/\/www.shadertoy.com\/view\/4sf3RN)\nfloat PrintInt( in vec2 uv, in float value )\n{\n    float res = 0.0;\n    float maxDigits = 1.0+ceil(.01+log2(value)\/log2(10.0));\n    float digitID = floor(uv.x);\n    if( digitID>0.0 && digitID<maxDigits )\n    {\n        float digitVa = mod( floor( value\/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n\t\tvec2 uv = vec2(fract(uv.x), uv.y);\n\t\tif( abs(uv.x-0.5)>0.5 || abs(uv.y-0.5)>0.5 ) return 0.0;\n\t\tfloat data = 0.0;\n\t\tif(digitVa < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n        else if(digitVa < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n        else if(digitVa < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n        else if(digitVa < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n        else if(digitVa < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n        else if(digitVa < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n        else if(digitVa < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n        else if(digitVa < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n        else if(digitVa < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n        else if(digitVa < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\t\tvec2 vPixel = floor(uv * vec2(4.0, 5.0));\n\t\tfloat fIndex = vPixel.x + (vPixel.y * 4.0);\n\t\tres = mod(floor(data \/ pow(2.0, fIndex)), 2.0);\n    }\n    return res;\n}\n\n\/\/ uv:screenCoord \n\/\/ v:vec3(hex width, hex height, hex height limit, hex scale)  \n\/\/ k:vec3(Alternance, Density, Glow)\nvec3 GetHexPattern(vec2 uv, vec4 v, vec3 k) \n{\n    \/\/ transfrom cartesian to polar\n\tfloat a = atan(uv.x, uv.y)\/3.14159*floor(k.y); \n\tfloat r = length(uv)*4.; \n\tuv = vec2(a,r);\/\/ polar uv\n    \n    \/\/ homogeneise cells\n\tuv.x *= floor(uv.y)-k.x; \/\/along r with alternance\n\tuv.x += iDate.w ; \/\/ rotate each radius offset with constant speed\n    \n    \/\/ apply 4 gradiant color along radius offset\n\tvec3 color = mix(startColor, endColor, vec3(floor(uv.y)\/4.));\n    \n    \/\/ repeat without dommain break (mod)\n\tuv = abs(fract(uv)-0.5);\n    \n    \/\/ apply pattern\n\tfloat x = uv.x*v.x;\n\tfloat y = uv.y*v.y;\n\tfloat z = uv.y*v.z;\n\treturn color \/ (abs(max(x + y,z) - v.w)*k.z);\n}\n\n\/\/ return central uv from h \/ h can be mouse or gl_FragCoord\n\/\/ s:screenSize \/ h:pixelCoord \/ z:zoom\nvec2 GetUV(vec2 s, vec2 h, float z) \n{\n\treturn z * (h+h-s)\/s.y; \/\/ central uv\n}\n\n\/\/ return id of region pointed by h \/ h can be mouse or gl_FragCoord\n\/\/ s:screenSize \/ h:pixelCoord\nfloat GetID(vec2 s, vec2 h) \n{\n\tvec2 uv = GetUV(s, h, zoom);\n\tfloat a = 0.;\n\tif (uv.x >= 0.) a = atan(uv.x, uv.y);\n    if (uv.x < 0.) a = 3.14159 - atan(uv.x, -uv.y);\n\ta = ceil(a *  (floor(sections)*0.5)\/3.14159);\n\tfloat r = length(uv);\n    return ( r < neutralZone ? neutralSection : a);\n}\n\nvoid mainImage( out vec4 f, in vec2 g )\n{\n\tvec2 pos = g;\n    \n\tvec2 uv = GetUV(iResolution.xy, pos, zoom);\n\t\n\tif(iMouse.z>0.) pos = iMouse.xy;\n    \n\tfloat cellID = GetID(iResolution.xy, pos);\n\n\tvec4 p = vec4(0); \/\/ hex width, hex height, hex height limit, hex scale  \n\tvec3 k = vec3(-.3, 5, 4); \/\/ Alternance, Density, Glow\n\n\tif (cellID == 1.) {p = vec4(1.2,0.92,1.88,0.8);}\n\tif (cellID == 2.) {p = vec4(2.2,0,1.88,0.8);}\n\tif (cellID == 3.) {p = vec4(2.2,0,4,0.8);}\n\tif (cellID == 4.) {p = vec4(1,0,4,0.8);}\n\tif (cellID == 5.) {p = vec4(1.2,0,2.12,0.64);}\n\tif (cellID == 6.) {p = vec4(4,4,1,0.8);}\n\tif (cellID == 7.) {p = vec4(1,2.96,4,0.8);}\n\tif (cellID == 8.) {p = vec4(1.5,0.96,1.8,0.4);}\n\tif (cellID == 9.) {p = vec4(1.2,2.24,0,0.68);}\n\t\n\tvec3 hexPattern = GetHexPattern(uv, p, k);\n\t\n\tvec3 col = clamp(hexPattern, 0., 1.); \/\/ intensity limit for glow\n\t\n#ifdef SHOW_SECTION_ID_NUMBER\n    \/\/ show scetion id on top left of the screen\n\tif(iMouse.z>0.) \n\t\tcol += PrintInt((uv-vec2(-2.5,1.))*5., cellID);\n#endif\n    \n\tf = vec4(col, 1);\n}\n","name":"","description":"","type":"image"}]}}