{"Shader":{"ver":"0.1","info":{"id":"ltjSRV","date":"1445127218","viewed":488,"name":"Kids Game Color Wheel","username":"freerunnering","description":"An improved version of my simple color wheel designed for kids games.","likes":0,"published":3,"flags":0,"tags":["simple","hue","hsl","colorwheel"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"const float M_PI = 3.14159265359;\nconst float BLOCKY = (M_PI * 0.2);\n\nconst float circleWidth = 1.;\nconst float center = 0.375;\n\n\/\/ HSL to RGB conversion\nvec3 hsl2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0,1.0);\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \/\/ Lightness\n    float l = 0.5;\n    \/\/ Alpha\n    float a = 1.0;\n    \n    \/\/ Position normalised into (0, 1)\n    vec2 position = fragCoord.xy\/iResolution.xy;\n    \/\/position.y = 1.0-position.y; \/\/ Flip y for my brain\n    \n    \/\/ Position normalised into (-1, 0, 1)\n    vec2 d = 1.0 - (position * 2.0);\n    \/\/ Distance from center\n    float dist = sqrt((d.x*d.x) + (d.y*d.y));\n    \n    \n    \/\/ Make this whole thing a circle\n    float delta = fwidth(dist);\n    a = 1.-smoothstep(circleWidth-delta, circleWidth, dist);\n    \n    \/\/ Anti alias the circle\n    if (abs(dist) < center) {\n        l = (1. - ((smoothstep(center-delta, center, (dist*1.)) \/ 2.)));\n    }\n    \n    \/\/TODO: Anti alias the color edges by averaging the current pixel color and the next pixel over in the direction of the nearest edge boundary .\n    \n    \/\/ Get the rotation\n    float r = acos(d.x \/ dist);\n    \/\/ Sort out the bottom half (y=-1)\n    if (d.y < 0.0) { r = M_PI-(r + M_PI); }\n    \/\/ Make it blocky (TODO: anti alias)\n    r = (ceil((r\/BLOCKY)-0.5) * BLOCKY);\n    r += (M_PI * 0.5); \/\/ Rotate by 90 degrees (red on top)\n    \n    float hue = (r \/ M_PI) \/ 2.0; \/\/ Normalise from (0 - 2_PI) to (0 - 1)\n    \n    fragColor = vec4( hsl2rgb( vec3(hue, 1.0, l*a) ), 1.0); \/\/ l*a compensated for lack of alpha support\n}\n","name":"","description":"","type":"image"}]}}