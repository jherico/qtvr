{"Shader":{"ver":"0.1","info":{"id":"4ljXWR","date":"1442869135","viewed":1150,"name":"Repeat by Cos and Sin","username":"aiekick","description":"A simple sphere with the shane func \"voronesque\" as displaced.<br\/>The sphere is repeated with some deformation due to the use of cos and sin instead of mod.<br\/>click on cell to see it fullscreen","likes":15,"published":3,"flags":0,"tags":["3d","raymarching","sin","cos","mod","repeat","voronesque"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Stephane Cuillerdier - Aiekick\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/*\nA simple sphere with the shane func \"voronesque\" as displaced.\nThe sphere is repeated with some deformation due to the use of cos and sin instead of mod.\nclick on cell to see it fullscreen\n*\/\n\nconst vec2 gridSize = vec2(5.,4.);\/\/grid size (columns, rows)\nconst vec3 lightDir = vec3(0.,1., 0.5);\nconst float mPi = 3.14159;\nconst float m2Pi = 6.28318;\n\nfloat cellID = 0.;\/\/global var for pilot hex func\nfloat t = 0.;\n\nvec3 OrenNayarLightModel(vec3 rd, vec3 ld, vec3 n)\n{\n\tvec3 col = vec3(0.);\n\tfloat RDdotN = dot(-rd, n);\n\tfloat NdotLD = dot(n, ld);\n    float aRDN = acos(RDdotN);\n\tfloat aNLD = acos(NdotLD);\n\tfloat mu = .33;\n\tfloat A = 1.-.5*mu*mu\/(mu*mu+0.57);\n    float B = .45*mu*mu\/(mu*mu+0.09);\n\tfloat alpha = max(aRDN, aNLD);\n\tfloat beta = min(aRDN, aNLD);\n\tfloat albedo = 1.1;\n\tfloat e0 = 3.1;\n\tcol = vec3(albedo \/ mPi) * cos(aNLD) * (A + ( B * max(0.,cos(aRDN - aNLD)) * sin(alpha) * tan(beta)))*e0;\n\treturn col;\n}\n\n\/\/ from shane sahder : https:\/\/www.shadertoy.com\/view\/4lSXzh\nfloat Voronesque( in vec3 p )\n{\n    vec3 i  = floor(p + dot(p, vec3(0.333333)) );  p -= i - dot(i, vec3(0.166666)) ;\n    vec3 i1 = step(0., p-p.yzx), i2 = max(i1, 1.0-i1.zxy); i1 = min(i1, 1.0-i1.zxy);    \n    vec3 p1 = p - i1 + 0.166666, p2 = p - i2 + 0.333333, p3 = p - 0.5;\n    vec3 rnd = vec3(7, 157, 113); \n    vec4 v = max(0.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);\n    vec4 d = vec4( dot(i, rnd), dot(i + i1, rnd), dot(i + i2, rnd), dot(i + 1., rnd) ); \n    d = fract(sin(d)*262144.)*v*2.; \n    v.x = max(d.x, d.y), v.y = max(d.z, d.w); \n    return max(v.x, v.y); \n}\n\nvec2 df(vec3 p)\n{\n\tvec2 res = vec2(1000.);\n\t\n\t\/\/ mat 1\n\tfloat plane = p.y + 1.;\n\tif (plane < res.x)\n\t\tres = vec2(plane, 1.);\n\t\t\n\t\/\/ mat 2\n\tvec3 q = p; \/\/ repeat by cos, sin instead of mod\n\tif (cellID == 0.) q = vec3(cos(p.x), p.y, p.z + sin(p.x));\n\tif (cellID == 1.) q = vec3(cos(p.x), p.y * 3., cos(p.z));\n\tif (cellID == 2.) q = vec3(cos(p.x - sin(p.y - t)), p.y, cos(p.z));\n\tif (cellID == 3.) q = vec3(cos(p.x + p.z), p.y, cos(p.z));\n\tif (cellID == 4.) q = vec3(cos(p.x + sin(p.z + t)), p.y * 3., cos(p.z));\n\tif (cellID == 5.) q = vec3(cos(p.x + sin(p.z + t)), p.y, cos(p.z * 3.));\n\tif (cellID == 6.) q = vec3(cos(p.x + sin(p.z)), p.y, cos(p.z) + sin(p.y + t));\n\tif (cellID == 7.) q = vec3(cos(p.x + cos(p.z)), p.y, cos(p.z) + sin(p.y + t));\n\tif (cellID == 8.) q = vec3(cos(p.x + cos(p.z)), p.y, cos(p.z + sin(p.x)) + sin(p.y + t));\n\tif (cellID == 9.) q = vec3(cos(p.x + sin(p.z)), p.y, cos(p.z + sin(p.z)));\n\tif (cellID == 10.) q = vec3(cos(p.x \/ 2. + sin(p.z)), p.y + cos(p.x) + sin(p.y), cos(p.z \/ 2. + sin(p.z \/ 2.)));\n\tif (cellID == 11.) q = vec3(cos(p.x \/ 2. + sin(p.z)), p.y + cos(p.x) + sin(p.y), cos(p.z \/ 2. + sin(p.z + p.x + t)));\n\tif (cellID == 12.) q = vec3(cos(p.x \/ 2. + sin(p.z + t)), p.y + cos(p.x) * sin(p.y + t), cos(p.z \/ 2. + sin(p.z \/ 2.)));\n\tif (cellID == 13.) q = vec3(cos(p.x), p.y + sin(p.x + t) + cos(p.z + t), cos(p.z));\n\tif (cellID == 14.) q = vec3(cos(p.x - t), p.y + cos(p.x), cos(p.z));\n\tif (cellID == 15.) q = vec3(cos(p.x - t), p.y + cos(p.x), cos(p.z + sin(p.z + t)));\n    if (cellID == 16.) q = vec3(cos(p.x), p.y, cos(log(abs(p.z))+t));\n    if (cellID == 17.) q = vec3(cos(p.x), p.y, cos(log2(abs(p.z))+t + sin(p.x)));\n  \tif (cellID == 18.) q = vec3(cos(log(abs(p.x))), p.y, cos(log2(abs(p.z))+t + sin(p.x)));\n   \tif (cellID == 19.) q = vec3(log(cos(abs(p.x))), p.y, log(cos(abs(p.z))));\n   \n\tfloat voro = Voronesque(q);\n\tfloat sphere = length(q) - 1. + voro * (sin(-t * .05)*1.2-.6);\n\tif (sphere < res.x)\n\t\tres = vec2(sphere, 2.);\n\t\n\treturn res;\n}\n\nvec3 nor( vec3 p, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n\t\tdf(p+e.xyy).x - df(p-e.xyy).x,\n\t\tdf(p+e.yxy).x - df(p-e.yxy).x,\n\t\tdf(p+e.yyx).x - df(p-e.yyx).x );\n    return normalize(n);\n}\n\n\n\/\/ from iq code\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = df( ro + rd*t ).x;\n        res = min( res, 8.0*h\/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\/\/ from iq code\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)\/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = df( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\/\/ from iq code\nvec3 lighting(vec3 col, vec3 p, vec3 n, vec3 rd, vec3 ref, float t)    \n{\n\tfloat occ = calcAO( p, n );\n\tfloat amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n\tfloat dif = clamp( dot( n, lightDir ), 0.0, 1.0 );\n\tfloat bac = clamp( dot( n, normalize(vec3(-lightDir.x,0.0,-lightDir.z))), 0.0, 1.0 )*clamp( 1.0-p.y,0.0,1.0);\n\tfloat dom = smoothstep( -0.1, 0.1, ref.y );\n\tfloat fre = pow( clamp(1.0+dot(n,rd),0.0,1.0), 2.0 );\n\tfloat spe = pow(clamp( dot( ref, lightDir ), 0.0, 1.0 ),16.0);\n        \n\tdif *= softshadow( p, lightDir, 0.02, 2.5 );\n\tdom *= softshadow( p, ref, 0.02, 2.5 );\n\n\tvec3 brdf = vec3(0.0);\n\tbrdf += 1.20*dif*vec3(1.00,0.90,0.60);\n\tbrdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n\tbrdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n\tbrdf += 0.40*dom*vec3(0.50,0.70,1.00)*occ;\n\tbrdf += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n\tbrdf += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\tbrdf += 0.02;\n\tcol = col * brdf;\n\n\tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0005*t*t ) );\n\t\n\treturn col;\n}\n\n\/\/ encode id from coord \/\/ s:screenSize \/ h:pixelCoord \/ sz=gridSize\nfloat EncID(vec2 s, vec2 h, vec2 sz) \n{\n    float cx = floor(h.x\/(s.x\/sz.x));\n    float cy = floor(h.y\/(s.y\/sz.y));\n    return cy*sz.x+cx;\n}\n\n\/\/ return id \/ uv \/\/ s:screenSize \/ h:pixelCoord \/ sz=gridSize\nvec3 getcell(vec2 s, vec2 h, vec2 sz) \n{\n    float cx = floor(h.x\/(s.x\/sz.x));\n    float cy = floor(h.y\/(s.y\/sz.y));\n    \n    float id = cy*sz.x+cx;\n    \n    vec2 size = s\/sz;\n    float ratio = size.x\/size.y;\n    vec2 uv = (2.*(h)-size)\/size.y - vec2(cx*ratio,cy)*2.;\n    uv*=1.5;\n    \n    return vec3(id, uv);\n}\n\nvoid mainImage( out vec4 f, in vec2 g )\n{\t\n\tvec2 si = iResolution.xy;\n\tvec2 mo = iMouse.xy;\n    \n\tvec2 uv = (2.*g-si)\/min(si.x, si.y);\n\t\n\tvec3 cell = getcell(si,g,gridSize);\n    if(iMouse.z>0.) \n    {\n        cell.x = EncID(si,mo,gridSize);\n        cell.yz = uv;\n    }\n    \n\tt = iGlobalTime - 10.;\n    \n    cellID = cell.x; \/\/ global var : current cell used by mouse\n\t\n\tvec3 rayOrg = vec3(t,5,0);\n\tvec3 camUp = vec3(0,1,0);\n\tvec3 camOrg = rayOrg + vec3(1,-1,0); \/\/ translate the cam along the x axis\n\t\n\tfloat fov = .5;\/\/ fov seen in code from shane\n\tvec3 axisZ = normalize(camOrg - rayOrg);\n\tvec3 axisX = normalize(cross(camUp, axisZ));\n\tvec3 axisY = normalize(cross(axisZ, axisX));\n\tvec3 rayDir = normalize(axisZ + fov * cell.y * axisX + fov * cell.z * axisY);\n\t\n    float dMax = 20.;\n\tfloat sMin = 0.01;\n\t\n\tvec2 s = vec2(sMin);\n\tfloat d = 0.;\n    \n\tvec3 p = rayOrg + rayDir * d;\n\t\n\tfor (int i=0; i<150; i++)\n\t{\n\t\tif (s.x<sMin || d>dMax) break;\n\t\ts = df(p);\n\t\td += s.x * .2;\n\t\tp = rayOrg + rayDir * d;\t\n\t}\n\t\n\tif (d<dMax)\n\t{\n\t\tvec3 p = rayOrg + rayDir * d;\n\t\tvec3 n = nor(p, 0.001);\n\t\t\n\t\tif (s.y < 1.5) \/\/ mat 1 : plane\n\t\t{\n\t\t\t\/\/ \tiq primitive shader : https:\/\/www.shadertoy.com\/view\/Xds3zN\n\t\t\tfloat r = mod( floor(5.0*p.z) + floor(5.0*p.x), 2.0);\n            f.rgb = 0.4 + 0.1*r*vec3(1.0);\n\t\t}\t\n\t\telse if (s.y < 2.5) \/\/ mat 2 : sphere\n\t\t{\t\n\t\t\tf.rgb = OrenNayarLightModel(n, lightDir, vec3(.33));\t\t\t\n\t\t}\t\n\n\t\tf.rgb = lighting(f.rgb, p, n, rayDir, rayDir, d); \/\/ lighting    \n\t}\n}","name":"","description":"","type":"image"}]}}