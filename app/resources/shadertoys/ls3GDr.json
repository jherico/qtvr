{"Shader":{"ver":"0.1","info":{"id":"ls3GDr","date":"1448975368","viewed":324,"name":"13_gearssss","username":"yiwenl","description":"more gears","likes":9,"published":3,"flags":0,"tags":["raymarch"],"hasliked":0},"renderpass":[{"inputs":[{"id":22,"src":"\/presets\/cube00_0.jpg","ctype":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"id":23,"src":"\/presets\/cube01_0.png","ctype":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"const int NUM_ITER = 100;\nconst float maxDist  = 4.0;\n\nfloat time = iGlobalTime * 2.0;\nconst float PI      = 3.141592657;\n\nconst vec3 grdColor0 = vec3(0.16, 0.537, 0.8);\nconst vec3 grdColor1 = vec3(1.0, 1.0, 1.0);\nconst vec3 grdColor2 = vec3(0.564, 0.415, 0.0);\nconst vec3 grdColor3 = vec3(0.851, 0.623, 0.0);\nconst vec3 grdColor4 = vec3(1.0, 1.0, 1.0);\n\n\nvec3 getGradient(float x) {\n    float p = 0.0;\n    if(x < 0.5) {\n        p = x\/0.5;\n        return mix(grdColor0, grdColor1, p);\n    } else if(x < 0.52) {\n        p = (x-0.5)\/0.02;\n        return mix(grdColor1, grdColor2, p);\n    } else if(x < 0.64) {\n        p = (x-0.52)\/0.12;\n        return mix(grdColor2, grdColor3, p);\n    } else {\n        p = (x-0.64)\/0.36;\n        return mix(grdColor3, grdColor4, p);\n    }\n    \n    return vec3(0.0);\n}\n\n\/\/\tTOOLS\nvec2 rotate(vec2 pos, float angle) {\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\n\treturn mat2(c, s, -s, c) * pos;\n}\n\nfloat smin( float a, float b, float k ) {\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )\/k;\n}\n\nfloat smin( float a, float b ) {\treturn smin(a, b, 7.0);\t}\n\n\/\/\tGEOMETRY\nfloat sphere(vec3 pos, float radius) {\n\treturn length(pos) - radius;\n}\n\nfloat rep(float p, float c) {\treturn mod(p, c) - 0.5*c;\t}\nvec2 rep(vec2 p, float c) {\t\treturn mod(p, c) - 0.5*c;\t}\nvec3 rep(vec3 p, float c) {\t\treturn mod(p, c) - 0.5*c;\t}\n\nvec2 repAng(vec2 p, float n) {\n    float ang = 2.0*PI\/n;\n    float sector = floor(atan(p.x, p.y)\/ang + 0.5);\n    p = rotate(p, sector*ang);\n    return p;\n}\n\nvec3 repAngS(vec2 p, float n) {\n    float ang = 2.0*PI\/n;\n    float sector = floor(atan(p.x, p.y)\/ang + 0.5);\n    p = rotate(p, sector*ang);\n    return vec3(p.x, p.y, mod(sector, n));\n}\n\nfloat box( vec3 p, vec3 b ) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat cylinder( vec3 p, vec2 h ) {\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - h;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat torus(vec3 p, float ri, float ro) {\n    vec2 q = vec2(length(p.xz) - ri, p.y);\n    return length(q) - ro;\n}\n\nconst float size = 2.0;\n\nfloat displacement(vec3 p) {\n\treturn sin(20.0*p.x+time*.232)*sin(20.0*p.y+time*.25)*sin(20.0*p.z+time*.33);\n}\n\n\nfloat exponentialIn(float t) {\n  return t == 0.0 ? t : pow(2.0, 10.0 * (t - 1.0));\n}\n\nfloat exponentialInOut(float t) {\n  return t == 0.0 || t == 1.0\n    ? t\n    : t < 0.5\n      ? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n      : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nfloat boxSize = .06;\nfloat ringSize = .65;\nfloat numTeeth = 12.0;\nfloat rotateAngle = .25*sin(time*.5);\n\nfloat getRotation(float rotation) {\n\tfloat t = fract(time * .15);\n\tt = exponentialInOut(t);\n\treturn t * rotation * PI \/ 2.0;\n}\n\nvec2 gearH(vec3 p, float rotation) {\n\tfloat colorIndex = 1.0;\n\t\n\tvec3 p0 = p;\n\tfloat rot = getRotation(rotation);\n\t\n\tp0.xz = rotate(p0.xz, rot);\n\tif(rotation < 0.0) {\n\t\tp0.xz = rotate(p0.xz, PI\/numTeeth);\n\t}\n\tp0.xz = repAng(p0.xz, numTeeth);\n\n\tp0.z -= ringSize+boxSize;\n\n\tfloat d = box(p0+vec3(0.0, 0.0, -.055), vec3(boxSize, boxSize, boxSize));\n\tfloat dTorus = torus(p, ringSize, boxSize-.01);\n\n\tif(dTorus < d) {\n\t\tcolorIndex = 0.0;\n\t}\n\n\td = smin(d, dTorus, 12.0);\n\treturn vec2(d, colorIndex);\n}\n\n\nvec2 gearH(vec3 pos) {\n\tvec3 p0 = pos;\n\tp0.xy = repAng(p0.xy, 4.0);\n\tp0.y -= 2.0;\n\tp0.yz = rotate(p0.yz, rotateAngle);\n\tvec2 g0 = gearH(p0, 1.0);\n\n\tvec3 p1 = pos;\n\tp1.xy = rotate(p1.xy, PI\/4.0);\n\tp1.xy = repAng(p1.xy, 4.0);\n\tp1.y -= 2.0;\n\tp1.yz = rotate(p1.yz, -rotateAngle);\n\tvec2 g1 = gearH(p1, -1.0);\n\n\tif(g0.x < g1.x) {\n\t\treturn g0;\n\t} else {\n\t\treturn g1;\n\t}\n}\n\nvec2 gearV(vec3 p, float rotation) {\n\tfloat colorIndex = 1.0;\n\t\n\tvec3 p0 = p;\n\tfloat rot = getRotation(rotation);\n\n\tp0.xy = rotate(p0.xy, rot);\n\tif(rotation < 0.0) {\n\t\tp0.xy = rotate(p0.xy, PI\/numTeeth);\n\t}\n\tp0.xy = repAng(p0.xy, numTeeth);\n\n\tp0.y -= ringSize+boxSize;\n\n\tfloat d = box(p0+vec3(0.0, -.055, 0.0), vec3(boxSize, boxSize, boxSize));\n\tp.yz = rotate(p.yz, PI * .5);\n\tfloat dTorus = torus(p, ringSize, boxSize-.01);\n\n\tif(dTorus < d) {\n\t\tcolorIndex = 0.0;\n\t}\n\n\td = smin(d, dTorus, 12.0);\n\treturn vec2(d, colorIndex);\n}\n\nvec2 gearV(vec3 pos) {\n\tpos.xy = rotate(pos.xy, PI\/8.0);\n\n\tvec3 p0 = pos;\n\tp0.xy = repAng(p0.xy, 4.0);\n\tp0.y -= 2.0;\n\tp0.xz = rotate(p0.xz, rotateAngle);\n\tvec2 g0 = gearV(p0, 1.0);\n\n\tvec3 p1 = pos;\n\tp1.xy = rotate(p1.xy, PI\/4.0);\n\tp1.xy = repAng(p1.xy, 4.0);\n\tp1.y -= 2.0;\n\tp1.xz = rotate(p1.xz, -rotateAngle);\n\tvec2 g1 = gearV(p1, -1.0);\n\n\tif(g0.x < g1.x) {\n\t\treturn g0;\n\t} else {\n\t\treturn g1;\n\t}\n}\n\nvec2 map(vec3 pos) {\n\tfloat t = time * .05;\n\tpos.xy = rotate(pos.xy, t);\n    pos.xz = rotate(pos.xz, t);\n\n\tvec2 _gearH = gearH(pos);\n\tvec2 _gearV = gearV(pos);\n\n\tif(_gearH.x < _gearV.x) {\n\t\treturn _gearH;\n\t} else {\n\t\treturn _gearV;\t\n\t}\n    \n}\n\nvec3 computeNormal(vec3 pos) {\n\tvec2 eps = vec2(0.001, 0.0);\n\n\tvec3 normal = vec3(\n\t\tmap(pos + eps.xyy).x - map(pos - eps.xyy).x,\n\t\tmap(pos + eps.yxy).x - map(pos - eps.yxy).x,\n\t\tmap(pos + eps.yyx).x - map(pos - eps.yyx).x\n\t);\n\treturn normalize(normal);\n}\n\n\n\/\/\tLIGHTING\nconst vec3 lightPos0 = vec3(-0.6, 0.7, -0.5);\nconst vec3 lightColor0 = vec3(1.0, 1.0, .96);\nconst float lightWeight0 = 0.5;\n\nconst vec3 lightPos1 = vec3(-1.0, -0.75, -.6);\nconst vec3 lightColor1 = vec3(.96, .96, 1.0);\nconst float lightWeight1 = 0.25;\n\nfloat ao( in vec3 pos, in vec3 nor ){\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.06*float(i)\/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 envLight(vec3 normal, vec3 dir, samplerCube tex) {\n\tvec3 eye    = -dir;\n\tvec3 r      = reflect( eye, normal );\n\tvec3 color  = textureCube( tex, r ).rgb;\n\tfloat power = 10.0;\n\tcolor.r     = pow(color.r, power);\n\tcolor       = color.rrr;\n    return color;\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax ) {\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ ) {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h\/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\nfloat diffuse(vec3 normal, vec3 light) {\n\treturn max(dot(normal, light), 0.0);\n}\n\nvec4 getColor(vec3 pos, vec3 dir, vec3 normal, float colorIndex, mat3 ca) {\n\tvec3 p = pos + vec3(sin(time*.25) * .5, cos(time*.05), .0);\n\tfloat n = displacement(pos);\n\tvec3 baseColor = vec3(0.0);\n\tvec3 env = vec3(0.0);\n\tfloat shadowOffset = 1.0;\n\tif(colorIndex < .5) {\n\t\tbaseColor = vec3(1.0, 1.0, .96)*.4;\n\t\tenv \t = envLight(normal, dir, iChannel1);\n\t} else {\n\t\tvec3 p = ca*pos;\n\t\tshadowOffset = 0.0;\n\t\tenv \t = envLight(normal, dir, iChannel0);\n\t\tbaseColor = vec3(1.0, 1.0, .96);\n\t}\n\n\t\n\tvec3  lig     = normalize( lightPos0 );\tfloat shadow  = softshadow(pos, lig, 0.02, 2.5 );\n\tshadow        = mix(shadow, 1.0, .75);\n\tfloat _ao     = ao(pos, normal);\n\treturn vec4(vec3(baseColor + env)*_ao*shadow, 1.0);\t\n\t\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    uv = -1.0 + uv * 2.0;\n    uv.x *= iResolution.x \/ iResolution.y;\n    \n    \/\/\tGRADIENT BACKGROUND\n    float g = 1.0 - clamp(length(uv)\/2.0, 0.0, 1.0);\n    g *= .25;\n    \n    \/\/\tCAMERA POSITION\/LOOK AT CENTER\n    float r = 6.0;\n    float t = 4.0+iMouse.x*.05;\n    float y = sin(time*.25) * .5 + .65;\n    vec3 pos = vec3( cos(t)*r, y, 0.5 + sin(t)*r );\n\tvec3 ta = vec3( 0.0, 0.0, 0.0 );\n    mat3 ca = setCamera( pos, ta, 0.0 );\n\tvec3 dir = ca * normalize( vec3(uv,1.5) );\n    \n\tvec4 color = vec4(vec3(g), 1.0);\n\tfloat prec = pow(.1, 7.0);\n\tfloat d;\n\tfloat colorIndex = 0.0;\n\tbool hit = false;\n\t\n\tfor(int i=0; i<NUM_ITER; i++) {\n\t\tvec2 result = map(pos);\t\t\t\t\t\t\/\/\tdistance to object\n\t\td = result.x;\n\t\tcolorIndex = result.y;\n\n\t\tif(d < prec) {\t\t\t\t\t\t\/\/ \tif get's really close, set as hit the object\n\t\t\thit = true;\n\t\t}\n\n\t\tpos += d * dir;\t\t\t\t\t\t\/\/\tmove forward by\n\t\tif(length(pos) > maxDist) break;\n\t}\n\n\n\tif(hit) {\n\t\tcolor = vec4(1.0);\n\t\tvec3 normal = computeNormal(pos);\n\t\tcolor = getColor(pos, dir, normal, colorIndex, ca);\n\t}\n    \n\tfragColor = color;\n}","name":"","description":"","type":"image"}]}}