{"Shader":{"ver":"0.1","info":{"id":"ltfXWr","date":"1436030669","viewed":992,"name":"Terrain Mesh Test","username":"Flyguy","description":"Testing ray-marched heightmap terrain made up of vertical triangular prisms to mimic the look of low-poly, flat-shaded mesh terrain. <br\/>Increase\/decrease QUAD_SIZE to make the terrain less\/more detailed.","likes":11,"published":3,"flags":0,"tags":["terrain","raymarch","triangles","heightmap","mesh"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define MIN_DIST 0.001\n#define MAX_STEPS 96\n#define STEP_MULT 0.5\n#define NORMAL_OFFS 0.01\n#define QUAD_SIZE 0.5\n\nfloat pi = atan(1.0)*4.0;\nfloat tau = atan(1.0)*8.0;\n\n\/\/Returns the height at a given position.\nfloat Height(vec2 p)\n{\n    p *= QUAD_SIZE;\n    p *= 8.0;\n    \n    float h = 0.0;\n    \n\th += 0.5 * sin(p.x * 0.10 + 0.0);\n    h += 0.2 * sin(p.x * 0.60 + 0.5 - iGlobalTime);\n    h += 1.0 * sin(p.x * 0.02 + 1.2 + iGlobalTime);\n    h += 0.6 * sin(p.y * 0.30 + 0.8);\n    h += 0.4 * sin(p.y * 0.10 + 1.2 + iGlobalTime);\n    h += 1.0 * sin(p.y * 0.05 + 1.2 + iGlobalTime);\n    \n    h *= smoothstep(8.0,16.0,length(p));\n    \n\treturn h * 0.5;\n}\n\n\/\/Returns a rotation matrix for the given angles around the X,Y,Z axes.\nmat3 Rotate(vec3 angles)\n{\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\n    return rotX*rotY*rotZ;\n}\n\n\/\/==== Distance field operators\/functions by iq. ====\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\/\/Modified to create a plane from 3 points.\nfloat sdPlane( vec3 p, vec3 p0, vec3 p1, vec3 p2 )\n{\n  return dot(p - p0,normalize(cross(p0 - p1, p0 - p2)));\n}\n\/\/===================================================\n\n\/*\nDistance to a vertical quad comprised of two triangles.\n\n1-----2\n| 0  \/|\n|  \/  |\n|\/  1 |\n0-----3\n*\/\nfloat sdVQuad( vec3 p, float h0, float h1, float h2, float h3)\n{\n    float s = QUAD_SIZE;\n       \n    float diag = sdPlane(p, vec3(0,0,0),vec3(s,s,0),vec3(0,0,s));\n    \n    float tri0 = sdPlane(p, vec3(0,0,-h0),vec3(0,s,-h1),vec3(s,s,-h2)); \/\/Triangle 0 (0,1,2)\n    tri0 = opS(-diag, tri0);\n    \n    float tri1 = sdPlane(p, vec3(0,0,-h0),vec3(s,s,-h2),vec3(s,0,-h3)); \/\/Triangle 1 (0,2,3)\n    tri1 = opS(diag, tri1);\n    \n    float d = min(tri0,tri1);\n    \n    return d;\n}\n\nfloat Scene(vec3 p)\n{\n    float d = 1000.0;\n    \n    vec3 pm = vec3(mod(p.xy,vec2(QUAD_SIZE)),p.z);\n    \n    vec2 uv = floor(p.xy\/QUAD_SIZE);\n    \n    d = sdVQuad(pm - vec3(0,0,1.0), Height(uv+vec2(0,0)),Height(uv+vec2(0,1)),Height(uv+vec2(1,1)),Height(uv+vec2(1,0)));\n    \n    d = opU(d, -sdSphere(p,12.0));\n    \n\treturn d;\n}\n\nvec3 MarchRay(vec3 origin,vec3 dir)\n{\n    vec3 marchPos = origin;\n    for(int i = 0;i < MAX_STEPS;i++)\n    {\n        float sceneDist = Scene(marchPos);\n        \n        marchPos += dir * sceneDist * STEP_MULT;\n        \n        if(sceneDist < MIN_DIST)\n        {\n            break;\n        }\n    }\n    \n    return marchPos;\n}\n\nvec3 Normal(vec3 p)\n{\n    vec3 off = vec3(NORMAL_OFFS,0,0);\n    return normalize\n    ( \n        vec3\n        (\n            Scene(p+off.xyz) - Scene(p-off.xyz),\n            Scene(p+off.zxy) - Scene(p-off.zxy),\n            Scene(p+off.yzx) - Scene(p-off.yzx)\n        )\n    );\n}\n\nvec3 Shade(vec3 position, vec3 normal, vec3 direction, vec3 camera)\n{\n    vec3 color = vec3(1.0);\n    \n    vec2 gridRep = mod(position.xy, vec2(QUAD_SIZE)) \/ float(QUAD_SIZE) - 0.5;\n    \n    float grid = 0.5 - max(abs(gridRep.x), abs(gridRep.y));\n    grid = min(grid,abs(dot(gridRep.xy, normalize(vec2(-1, 1)))));\n        \n    float lineSize = 0.8 * length(fwidth(position)) \/ float(QUAD_SIZE);\n    \n    color *= smoothstep(lineSize,0.0,grid);\n    color = color * 0.75 + 0.25;\n    \n    float ambient = 0.1;\n    float diffuse = 0.5 * -dot(normal,direction);\n    float specular = 1.1 * max(0.0, -dot(direction, reflect(direction,normal)));\n    \n    color *= vec3(ambient + diffuse + pow(specular,5.0));\n\n    color *= smoothstep(12.0,6.0,length(position));\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy \/ iResolution.y;\n\tvec2 uv = fragCoord.xy \/ iResolution.y;\n    \n    vec3 angles = vec3((iMouse.xy\/iResolution.xy)*pi,0);\n    \n    angles.xy *= vec2(2.0,1.0);\n    angles.y = clamp(angles.y,0.0,tau\/4.0);\n    \n    mat3 rotate = Rotate(angles.yzx);\n    \n    vec3 orig = vec3(0,0,-2) * rotate;\n    vec3 dir = normalize(vec3(uv - res\/2.0,0.5)) * rotate;\n    \n    vec3 hit = MarchRay(orig,dir);\n    vec3 norm = Normal(hit);\n    \n    vec3 color = Shade(hit,norm,dir,orig);\n    \n\tfragColor = vec4(color,1.0);\n}","name":"","description":"","type":"image"}]}}