{"Shader":{"ver":"0.1","info":{"id":"4t2SzR","date":"1441051744","viewed":1413,"name":"Normal Map Blending","username":"ZigguratVertigo","description":"Reoriented Normal Mapping (vs other techniques). Hopefully another step in convincing people to stop using Overlay to combine normal maps ;) We spend so much math on awesome lighting (ie.: PBR), source content matters. Please tell your artists! <3","likes":17,"published":3,"flags":0,"tags":["blending","normal","detail","reorientednormalmapping","rnm"],"hasliked":0},"renderpass":[{"inputs":[{"id":4,"src":"\/presets\/tex03.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/\n\/\/ Reoriented Normal Mapping (vs other techniques)\n\/\/\n\/\/ Hopefully another step in convincing people to stop using overlay to combine normal maps ;)\n\/\/ Please tell your artists! We spend so much math on awesome lighting (with PBR), source content matters.\n\/\/\n\/\/ Based on \"Blending in Detail\" by Stephen Hill and myself: \n\/\/ http:\/\/blog.selfshadow.com\/publications\/blending-in-detail\/\n\/\/ http:\/\/blog.selfshadow.com\/sandbox\/normals.html\n\/\/\n\/\/ [References]:\n\/\/ Text rendering: \t\thttps:\/\/www.shadertoy.com\/view\/Mt2GWD\n\/\/ Normal generation: \thttps:\/\/www.shadertoy.com\/view\/llS3WD\n\/\/ \t\t\t\t\t\thttps:\/\/www.shadertoy.com\/view\/MsSXzG\n\/\/\n\/\/ Cycles between the techniques and RNM. If you want to stop on a specific technique, override the following.\n\/\/ Override to force a specific technique (automatic or manual)\n\n#define TECHNIQUE\t\t\t\t\t TECHNIQUE_CycleCompare\n\n\/\/ Automatic\n#define TECHNIQUE_CycleCompare\t\t-1\n\n\/\/ Manual\n#define TECHNIQUE_RNM \t\t\t\t 0\n#define TECHNIQUE_PartialDerivatives 1\n#define TECHNIQUE_Whiteout \t\t\t 3\n#define TECHNIQUE_UDN\t\t\t\t 5\n#define TECHNIQUE_Unity\t\t\t\t 7\n#define TECHNIQUE_Linear\t\t     9\n#define TECHNIQUE_Overlay\t\t     11\n\n\/\/---------------------------------------------------------------------------------------------\n\/\/ Helper Functions\n\/\/---------------------------------------------------------------------------------------------\nfloat saturate(float v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\nfloat overlay(float x, float y)\n{\n    if (x < 0.5)\n        return 2.0*x*y;\n    else\n        return 1.0 - 2.0*(1.0 - x)*(1.0 - y);\n}\n\n\n\/\/---------------------------------------------------------------------------------------------\n\/\/ Normal Blending Techniques\n\/\/---------------------------------------------------------------------------------------------\n\n\/\/ RNM\nvec3 NormalBlend_RNM(vec3 n1, vec3 n2)\n{\n    \/\/ Unpack (see article on why it's not just n*2-1)\n\tn1 = n1*vec3( 2,  2, 2) + vec3(-1, -1,  0);\n    n2 = n2*vec3(-2, -2, 2) + vec3( 1,  1, -1);\n    \n    \/\/ Blend\n    return n1*dot(n1, n2)\/n1.z - n2;\n}\n\n\/\/ RNM - Already unpacked\nvec3 NormalBlend_UnpackedRNM(vec3 n1, vec3 n2)\n{\n\tn1 += vec3(0, 0, 1);\n\tn2 *= vec3(-1, -1, 1);\n\t\n    return n1*dot(n1, n2)\/n1.z - n2;\n}\n\n\/\/ Partial Derivatives\nvec3 NormalBlend_PartialDerivatives(vec3 n1, vec3 n2)\n{\t\n    \/\/ Unpack\n\tn1 = n1*2.0 - 1.0;\n    n2 = n2*2.0 - 1.0;\n    \n    return normalize(vec3(n1.xy*n2.z + n2.xy*n1.z, n1.z*n2.z));\n}\n\n\/\/ Whiteout\nvec3 NormalBlend_Whiteout(vec3 n1, vec3 n2)\n{\n    \/\/ Unpack\n\tn1 = n1*2.0 - 1.0;\n    n2 = n2*2.0 - 1.0;\n    \n\treturn normalize(vec3(n1.xy + n2.xy, n1.z*n2.z));    \n}\n\n\/\/ UDN\nvec3 NormalBlend_UDN(vec3 n1, vec3 n2)\n{\n    \/\/ Unpack\n\tn1 = n1*2.0 - 1.0;\n    n2 = n2*2.0 - 1.0;    \n    \n\treturn normalize(vec3(n1.xy + n2.xy, n1.z));\n}\n\n\/\/ Unity\nvec3 NormalBlend_Unity(vec3 n1, vec3 n2)\n{\n    \/\/ Unpack\n\tn1 = n1*2.0 - 1.0;\n    n2 = n2*2.0 - 1.0;\n    \n    mat3 nBasis = mat3(vec3(n1.z, n1.y, -n1.x), \/\/ +90 degree rotation around y axis\n        \t\t\t   vec3(n1.x, n1.z, -n1.y), \/\/ -90 degree rotation around x axis\n        \t\t\t   vec3(n1.x, n1.y,  n1.z));\n\t\n    return normalize(n2.x*nBasis[0] + n2.y*nBasis[1] + n2.z*nBasis[2]);\n}\n\n\/\/ Linear Blending\nvec3 NormalBlend_Linear(vec3 n1, vec3 n2)\n{\n    \/\/ Unpack\n\tn1 = n1*2.0 - 1.0;\n    n2 = n2*2.0 - 1.0;\n    \n\treturn normalize(n1 + n2);    \n}\n\n\/\/ Overlay\nvec3 NormalBlend_Overlay(vec3 n1, vec3 n2)\n{\n    vec3 n;\n    n.x = overlay(n1.x, n2.x);\n    n.y = overlay(n1.y, n2.y);\n    n.z = overlay(n1.z, n2.z);\n\n    return normalize(n*2.0 - 1.0);\n}\n\n\/\/ Combine normals\nvec3 CombineNormal(vec3 n1, vec3 n2, int technique)\n{\n \tif (technique == TECHNIQUE_RNM)\n        return NormalBlend_RNM(n1, n2);\n    else if (technique == TECHNIQUE_PartialDerivatives)\n        return NormalBlend_PartialDerivatives(n1, n2);\n    else if (technique == TECHNIQUE_Whiteout)\n        return NormalBlend_Whiteout(n1, n2);\n    else if (technique == TECHNIQUE_UDN)\n        return NormalBlend_UDN(n1, n2);\n    else if (technique == TECHNIQUE_Unity)\n        return NormalBlend_Unity(n1, n2);\n    else if (technique == TECHNIQUE_Linear)\n        return NormalBlend_Linear(n1, n2);\n    else\n        return NormalBlend_Overlay(n1, n2);\n}\n\n\/\/ Compute base normal (since we don't have a texture)\nvec3 ComputeBaseNormal(vec2 uv) \n{\n    uv = fract(uv) * 2.0 - 1.0;    \n        \n    vec3 ret;\n    ret.xy = sqrt(uv * uv) * sign(uv);\n    ret.z = sqrt(abs(1.0 - dot(ret.xy,ret.xy)));\n    \n    ret = ret * 0.5 + 0.5;\n    return mix(vec3(0.5,0.5,1.0), ret, smoothstep(1.0,0.95,dot(uv,uv)));\n}\n\n\/\/ Compute a detail normal (since we don't have a texture)\nvec3 ComputeDetailNormal(vec2 uv)\n{\n    const vec4 avgRGB0 = vec4(1.0\/3.0, 1.0\/3.0, 1.0\/3.0, 0.0);\n    const float scale = 0.02;\n    const vec2 du = vec2(1.0\/512.0, 0.0);\n    const vec2 dv = vec2(0.0, 1.0\/512.0);\n\n    float h0  = dot(avgRGB0, texture2D(iChannel0, uv)) * scale;\n    float hpx = dot(avgRGB0, texture2D(iChannel0, uv + du)) * scale;\n    float hmx = dot(avgRGB0, texture2D(iChannel0, uv - du)) * scale;\n    float hpy = dot(avgRGB0, texture2D(iChannel0, uv + dv)) * scale;\n    float hmy = dot(avgRGB0, texture2D(iChannel0, uv - dv)) * scale;\n    \n    float dHdU = (hmx - hpx) \/ (2.0 * du.x);\n    float dHdV = (hmy - hpy) \/ (2.0 * dv.y);\n    \n    return normalize(vec3(dHdU, dHdV, 1.0)) * 0.5 + 0.5;\n}\n\n\/\/---------------------------------------------------------------------------------------------\n\/\/ Text Rendering\n\/\/---------------------------------------------------------------------------------------------\n\/\/ Text from: \n#define DOWN_SCALE 1.0\n#define MAX_INT_DIGITS 4\n#define CHAR_SIZE vec2(8, 12)\n#define CHAR_SPACING vec2(8, 12)\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n#define NORMAL 0\n#define INVERT 1\n#define UNDERLINE 2\n\nint TEXT_MODE = NORMAL;\n\nvec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000);\nvec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000);\nvec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000);\nvec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000);\nvec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000);\nvec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000);\nvec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000);\nvec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000);\nvec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000);\nvec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000);\nvec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000);\nvec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000);\nvec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000);\nvec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000);\nvec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000);\nvec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000);\nvec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000);\nvec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000);\nvec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000);\nvec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000);\nvec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000);\nvec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000);\nvec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000);\nvec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000);\nvec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000);\nvec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000);\nvec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000);\nvec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000);\nvec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000);\nvec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000);\nvec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000);\nvec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000);\nvec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000);\nvec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000);\nvec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000);\nvec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000);\nvec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000);\nvec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000);\nvec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000);\nvec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000);\nvec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000);\nvec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000);\nvec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000);\nvec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000);\nvec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000);\nvec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000);\nvec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000);\nvec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000);\nvec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000);\nvec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00);\nvec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000);\nvec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000);\nvec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000);\nvec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000);\nvec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000);\nvec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000);\nvec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000);\nvec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000);\nvec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000);\nvec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000);\nvec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000);\nvec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000);\nvec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000);\nvec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00);\nvec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000);\nvec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000);\nvec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000);\nvec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000);\nvec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000);\nvec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000);\nvec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78);\nvec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000);\nvec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000);\nvec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78);\nvec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000);\nvec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000);\nvec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000);\nvec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000);\nvec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000);\nvec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0);\nvec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E);\nvec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000);\nvec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000);\nvec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000);\nvec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000);\nvec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000);\nvec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000);\nvec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000);\nvec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0);\nvec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000);\nvec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000);\nvec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000);\nvec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000);\nvec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000);\nvec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\nvec2 print_pos = vec2(0);\n\n\/\/Extracts bit b from the given number.\n\/\/Shifts bits right (num \/ 2^bit) then ANDs the result with 1 (mod(result,2.0)).\nfloat extract_bit(float n, float b)\n{\n    b = clamp(b,-1.0,24.0);\n\treturn floor(mod(floor(n \/ pow(2.0,floor(b))),2.0));   \n}\n\n\/\/Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(vec4 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    \n    \/\/Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    \/\/Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));\n    \n    float pixels = 0.0;\n    pixels += extract_bit(spr.x, bit - 72.0);\n    pixels += extract_bit(spr.y, bit - 48.0);\n    pixels += extract_bit(spr.z, bit - 24.0);\n    pixels += extract_bit(spr.w, bit - 00.0);\n    \n    return bounds ? pixels : 0.0;\n}\n\n\/\/Prints a character and moves the print position forward by 1 character width.\nfloat char(vec4 ch, vec2 uv)\n{\n    if( TEXT_MODE == INVERT )\n    {\n      \/\/Inverts all of the bits in the character.\n      ch = pow(2.0,24.0)-1.0-ch;\n    }\n    if( TEXT_MODE == UNDERLINE )\n    {\n      \/\/Makes the bottom 8 bits all 1.\n      \/\/Shifts the bottom chunk right 8 bits to drop the lowest 8 bits,\n      \/\/then shifts it left 8 bits and adds 255 (binary 11111111).\n      ch.w = floor(ch.w\/256.0)*256.0 + 255.0;  \n    }\n\n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\nfloat PrintText(vec2 uv, int technique)\n{\n    float col = 0.0;\n    TEXT_MODE = NORMAL;  \n    \n    \/\/ RNM\n    if (technique == TECHNIQUE_RNM)\n    {\n        print_pos = vec2(iResolution.x*0.5 - 0.5*STRHEIGHT(16.0), 2.0 + STRHEIGHT(0.0));\n\n        col += char(ch_R,uv);\n        col += char(ch_e,uv);\n        col += char(ch_o,uv);\n        col += char(ch_r,uv);\n        col += char(ch_i,uv);\n        col += char(ch_e,uv);\n        col += char(ch_n,uv);\n        col += char(ch_t,uv);\n        col += char(ch_e,uv);\n        col += char(ch_d,uv);\n\n        col += char(ch_spc,uv);\n\n        col += char(ch_N,uv);\n        col += char(ch_o,uv);\n        col += char(ch_r,uv);\n        col += char(ch_m,uv);\n        col += char(ch_a,uv);\n        col += char(ch_l,uv);\n\n        col += char(ch_spc,uv);\n\n        col += char(ch_M,uv);\n        col += char(ch_a,uv);\n        col += char(ch_p,uv);\n        col += char(ch_p,uv);\n        col += char(ch_i,uv);\n        col += char(ch_n,uv);\n        col += char(ch_g,uv);\n    }\n    else if (technique == TECHNIQUE_PartialDerivatives)\n    {\n        print_pos = vec2(iResolution.x*0.5 - STRHEIGHT(6.0), 2.0 + STRHEIGHT(0.0));\n\n        col += char(ch_P,uv);\n        col += char(ch_a,uv);\n        col += char(ch_r,uv);\n        col += char(ch_t,uv);\n        col += char(ch_i,uv);\n        col += char(ch_a,uv);\n        col += char(ch_l,uv);\n\n        col += char(ch_spc,uv);\n\n        col += char(ch_D,uv);\n        col += char(ch_e,uv);\n        col += char(ch_r,uv);\n        col += char(ch_i,uv);\n        col += char(ch_v,uv);\n        col += char(ch_a,uv);\n        col += char(ch_t,uv);\n        col += char(ch_i,uv);\n        col += char(ch_v,uv);\n        col += char(ch_e,uv);\n        col += char(ch_s,uv);\n    }\n    else if (technique == TECHNIQUE_Whiteout)\n    {\n        print_pos = vec2(iResolution.x*0.5 - STRHEIGHT(2.0), 2.0 + STRHEIGHT(0.0));\n\n        col += char(ch_W,uv);\n        col += char(ch_h,uv);\n        col += char(ch_i,uv);\n        col += char(ch_t,uv);\n        col += char(ch_e,uv);\n        col += char(ch_o,uv);\n        col += char(ch_u,uv);\n        col += char(ch_t,uv);\n    }    \n    else if (technique == TECHNIQUE_UDN)\n    {\n        print_pos = vec2(iResolution.x*0.5 - STRHEIGHT(1.0), 2.0 + STRHEIGHT(0.0));\n\n        col += char(ch_U,uv);\n        col += char(ch_D,uv);\n        col += char(ch_N,uv);\n    }    \n    else if (technique == TECHNIQUE_Unity)\n    {\n        print_pos = vec2(iResolution.x*0.5 - STRHEIGHT(2.0), 2.0 + STRHEIGHT(0.0));\n\n        col += char(ch_U,uv);\n        col += char(ch_n,uv);\n        col += char(ch_i,uv);\n        col += char(ch_t,uv);\n        col += char(ch_y,uv);\n    } \n    else if (technique == TECHNIQUE_Linear)\n    {\n        print_pos = vec2(iResolution.x*0.5 - STRHEIGHT(2.0), 2.0 + STRHEIGHT(0.0));\n\n        col += char(ch_L,uv);\n        col += char(ch_i,uv);\n        col += char(ch_n,uv);\n        col += char(ch_e,uv);\n        col += char(ch_a,uv);\n        col += char(ch_r,uv);\n    } \n    else\/\/ if (technique == TECHNIQUE_Overlay)\n    {\n        print_pos = vec2(iResolution.x*0.5 - STRHEIGHT(2.0), 2.0 + STRHEIGHT(0.0));\n\n        col += char(ch_O,uv);\n        col += char(ch_v,uv);\n        col += char(ch_e,uv);\n        col += char(ch_r,uv);\n        col += char(ch_l,uv);\n        col += char(ch_a,uv);\n        col += char(ch_y,uv);\n    }    \n    \n    return col;\n}\n\n\n\/\/---------------------------------------------------------------------------------------------\n\/\/ Main\n\/\/---------------------------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n\tint iTechnique = TECHNIQUE;\n    if (iTechnique == TECHNIQUE_CycleCompare)\n    {\n\t\tiTechnique = int(mod(iGlobalTime\/4.0, 11.0));    \n    \n        if (int(mod(float(iTechnique), 2.0)) == 0)\n\t\t\tiTechnique = 0;\n    }\n   \n    vec2 uv = fragCoord.xy \/ iResolution.x;\n    \n    \/\/---------------------------------------------------------------------------------------------------------\n    \/\/ [LEFT SIDE] - Combined normal, switches between technique\n    \/\/---------------------------------------------------------------------------------------------------------\n    \/\/ Base Normal (Disk)\n    vec2 uvN = uv;\n    uvN *= (iResolution.x\/iResolution.y);\n    uvN = uvN * 1.2 - vec2(0.12, 0.16);\n\n  \tvec3 BN = vec3(0.5, 0.5, 1.0);\n    if (uvN.x > 0.0 && uvN.x < 0.83 && uvN.y < 0.83 && uvN.y > 0.0)\n    {\n        BN = ComputeBaseNormal(uvN * vec2(1.2,1.2));\n    }\n    \n    \/\/ Detail Normal\n\tvec2 uvDN = uvN;\n    vec3 n1 = ComputeDetailNormal(uvDN);\n \n\t\/\/ Combined Normal\n    vec3 N = CombineNormal(BN, n1, iTechnique);\n\n    \/\/---------------------------------------------------------------------------------------------------------\n    \/\/ [RIGHT SIDE] - Combined normal with lighting, switches between technique\n    \/\/---------------------------------------------------------------------------------------------------------\n    \/\/ Base Normal (Disk)\n    uvN = uv + vec2(0.28, 0.0);\n    uvN *= (iResolution.x\/iResolution.y);\n    uvN = uvN * 1.2 - vec2(0.12, 0.16);\n\n  \tBN = vec3(0.5, 0.5, 1.0);\n    if (uvN.x > 1.66 && uvN.y > 0.0 && uvN.y < 0.83 && uvN.x < 2.50)\n    {\n        BN = ComputeBaseNormal(uvN * vec2(1.2,1.2));\n    }\n    \n    \/\/ Detail Normal\n\tuvDN = uvN+vec2(0.33,0);\n    n1 = ComputeDetailNormal(uvDN);\n \n\t\/\/ Combined Normal\n    vec3 N2 = CombineNormal(BN, n1, iTechnique);\n   \t\n    vec3 color = N; \n    \n\tfloat Time = iGlobalTime;\n    vec3 light = normalize(vec3(sin(Time),0,  1));\n\tlight = normalize(vec3(cos(iGlobalTime), sin(iGlobalTime), 1.0));    \n    vec3 lit = vec3(saturate(dot(light, N2)));\n\n    \/\/---------------------------------------------------------------------------------------------------------\n    \/\/ [BORDERS AND TEXT]\n    \/\/---------------------------------------------------------------------------------------------------------\n    \/\/ Mix normal and lit result\n\tcolor = mix(N*0.5 + 0.5, lit, float(uv.x > 0.5));\n\n    \/\/ Borders\n    color *= float((uv.y > 0.02));\n    color *= float((uv.y < 0.54));\n    color *= float((uv.x < 0.49) || (uv.x > 0.51));\n    color *= float((uv.x > 0.02) && (uv.x < 0.98));\n    \n    \/\/ Text\n    uv = fragCoord.xy \/ DOWN_SCALE;\n    vec3 textColor = vec3((1.-distance(mod(uv,vec2(1.0)),vec2(0.65)))*1.2) * PrintText(floor(uv), iTechnique);\n    \n\tfragColor = vec4(color+textColor, 1.0);\n}","name":"","description":"","type":"image"}]}}