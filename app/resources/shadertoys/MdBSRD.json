{"Shader":{"ver":"0.1","info":{"id":"MdBSRD","date":"1409537743","viewed":1163,"name":"multitrack","username":"Sebbert","description":"Aaaaand it's 4am...","likes":24,"published":3,"flags":8,"tags":["sound","music","oscillator"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"precision highp float;\n\nconst float TAU = 6.2831;\n\nconst float TEMPO = 130.0;\n\nconst float b1_4 = 60.0 \/ TEMPO;\nconst float b1_1   = b1_4  * 4.0;\nconst float b1_8   = b1_4  \/ 2.0;\nconst float b1_16  = b1_8  \/ 2.0;\nconst float b1_32  = b1_16 \/ 2.0;\n\nconst float b1_4t  = b1_1  \/ 3.0;\nconst float b1_8t  = b1_4  \/ 3.0;\nconst float b1_16t = b1_8  \/ 3.0;\nconst float b1_32t = b1_16 \/ 3.0;\n\nvec2 coord;\n\nfloat clamp_c(float mn, float mx, float n)\n{\n    return max(mn, min(mx, n));\n}\n\nfloat map(float n, float a, float b, float c, float d)\n{\n    return (n-a)\/(b-a) * (d-c) + c;\n}\n\nvec2 map(vec2 n, float a, float b, float c, float d)\n{\n    return vec2(map(n.x, a, b, c, d), map(n.y, a, b, c, d));\n}\n\nvec2 map(vec2 n, vec2 a, vec2 b, vec2 c, vec2 d)\n{\n    return (n-a)\/(b-a) * (d-c) + c;\n}\n\nfloat adsr(vec4 adsr, float t)\n{\n    float a = adsr.x;\n    float d = adsr.y;\n    float s = adsr.z;\n    float r = adsr.w;\n    \n    \/\/ Note off\n    if(t <= 0.0)\n    {\n        return 0.0;\n    }\n    \n    \/\/ Attack\n    if(t < a)\n    {\n        return t \/ a;\n    }\n    \n    \/\/ Decay\/sustain\n    if(t < a + d)\n    {\n        return map(t - a, 0.0, d, 1.0, s);\n    }\n    \n    \/\/ Release\n    return max(map(t - a - d, 0.0, r, s, 0.0), 0.0);\n}\n\nfloat circle(vec2 p, float r, float smooth)\n{\n    return smoothstep(-abs(smooth), 0.0, clamp(0.0, 1.0, (r - distance(coord, p)) \/ r));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    coord = vec2(\n        (fragCoord.x - iResolution.x \/ 2.0) \/ iResolution.y,\n        (fragCoord.y \/ iResolution.y) - 0.5);\n    \n    float total = 0.0;\n    \n    float period = mod(iGlobalTime, b1_1) \/ b1_1;\n    \n    for(int i = 0; i < 16; ++i)\n    {\n        float n = float(i);\n        float a = n \/ 16.0;\n        float pt = mod(period + 0.06 - a, 1.0);\n        float env = adsr(vec4(0.06, 0.3, 0.2, 0.2), pt);\n        \n        float am;\n        am = clamp_c(0.0, 1.0, env) * 0.6;\n        \n        if(mod(n + 4.0, 4.0) == 0.0)\n            am += adsr(vec4(0.06, 0.25, 0.15, 0.2), pt) * 3.5;\n        \n        vec2 p = vec2(\n             cos(TAU * (a - 90.0 + sin(iGlobalTime))),\n            -sin(TAU * (a - 90.0 + cos(iGlobalTime)))\n            );\n        \n        p *= 0.3;\n        \n        float o = 0.0;\n        o += circle(p * 1.5, 0.03 * am, 0.6);\n        o += circle(p, 0.03, map(am, 0.0, 1.0, -0.0, 8.0));\n        \n        o *= am;\n        \n        total += o;\n    }\n    \n     vec4 oc = vec4(total, total, total, 1.0);\n    vec4 bg = vec4(coord.x + 1.0, coord.y + 1.0, 1.0, 1.0);\n    oc *= bg * 0.5;\n    fragColor = oc;\n}","name":"","description":"","type":"image"},{"inputs":[],"outputs":[{"channel":"0"}],"code":"precision highp float;\n\n\/\/ PRNG\nvec3 mod289(vec3 x) {return x - floor(x * (1.0 \/ 289.0)) * 289.0;}vec2 mod289(vec2 x) {return x - floor(x * (1.0 \/ 289.0)) * 289.0;}vec3 permute(vec3 x) {return mod289(((x*34.0)+1.0)*x);}float snoise(vec2 v){const vec4 C = vec4(0.211324865405187,0.366025403784439,-0.577350269189626,0.024390243902439); vec2 i= floor(v + dot(v, C.yy) );vec2 x0 = v - i + dot(i, C.xx);vec2 i1;i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);vec4 x12 = x0.xyxy + C.xxzz;x12.xy -= i1;i = mod289(i); vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))+ i.x + vec3(0.0, i1.x, 1.0 ));vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);m = m*m ;m = m*m ;vec3 x = 2.0 * fract(p * C.www) - 1.0;vec3 h = abs(x) - 0.5;vec3 ox = floor(x + 0.5);vec3 a0 = x - ox;m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );vec3 g;g.x= a0.x* x0.x+ h.x* x0.y;g.yz = a0.yz * x12.xz + h.yz * x12.yw;return 130.0 * dot(m, g);}\n\nfloat random(float x)\n{\n    return snoise(vec2(x * 85000.0, sin(x) * 940000.0));\n}\n\nfloat clamp_c(float mn, float mx, float n)\n{\n    return max(mn, min(mx, n));\n}\n\nconst float TAU = 6.2831;\nconst float TEMPO = 130.0;\nconst float SMOOTH = 0.01;\n\n\/\/ The number of harmonics for additive oscillators.\nconst int OSCRES = 32;\n\n\/\/ Define note lengths\nconst float b1_4   = 60.0  \/ TEMPO;\nconst float b1_1   = b1_4  * 4.0;\nconst float b1_8   = b1_4  \/ 2.0;\nconst float b1_16  = b1_8  \/ 2.0;\nconst float b1_32  = b1_16 \/ 2.0;\n\nconst float b1_4t  = b1_1  \/ 3.0;\nconst float b1_8t  = b1_4  \/ 3.0;\nconst float b1_16t = b1_8  \/ 3.0;\nconst float b1_32t = b1_16 \/ 3.0;\n\n\/\/ Define note values\nconst float nC  = 261.63;\nconst float nCs  = 277.18;\nconst float nDb  = nCs;\nconst float nD  = 293.66;\nconst float nDs  = 311.13;\nconst float nEb  = nDs;\nconst float nE  = 329.63;\nconst float nF  = 349.23;\nconst float nFs = 369.99;\nconst float nGb = nFs;\nconst float nG  = 392.0;\nconst float nGs  = 415.30;\nconst float nAb  = nGs;\nconst float nA  = 440.0;\nconst float nAs  = 466.16;\nconst float nBb  = nAs;\nconst float nB  = 493.88;\n\nfloat map(float n, float a, float b, float c, float d)\n{\n    return (n-a)\/(b-a) * (d-c) + c;\n}\n\nfloat maplimit(float n, float a, float b, float c, float d)\n{\n    float o = map(n, a, b, c, d);\n    \n    if(n <  a) return 0.0;\n    if(n >= b) return 0.0;\n    \n    return o;\n}\n\nfloat adsr(vec4 adsr, float t)\n{\n    float a = adsr.x;\n    float d = adsr.y;\n    float s = adsr.z;\n    float r = adsr.w;\n    \n    \/\/ Note off\n    if(t < 0.0)\n    {\n        return 0.0;\n    }\n    \n    \/\/ Attack\n    if(t < a)\n    {\n        return t \/ a;\n    }\n    \n    \/\/ Decay\/sustain\n    if(t < a + d)\n    {\n        return map(t - a, 0.0, d, 1.0, s);\n    }\n    \n    \/\/ Release\n    return max(map(t - a - d, 0.0, r, s, 0.0), 0.0);\n}\n\n\/\/ A 4-point envelope that takes 4 vec2's (and time) in the format:\n\/\/     x = time from previous value to target value\n\/\/    y = target value\n\/\/ Starts at 0.\nfloat env4(vec2 a, vec2 b, vec2 c, vec2 d, float t)\n{\n    float tb = t  - a.x;\n    float tc = tb - b.x;\n    float td = tc - c.x;\n    \n    return\n        maplimit(t , 0.0, a.x, 0.0, a.y) + \/\/ Point A\n        maplimit(tb, 0.0, b.x, a.y, b.y) + \/\/ Point B\n        maplimit(tc, 0.0, c.x, b.y, c.y) + \/\/ Point C\n        maplimit(td, 0.0, d.x, c.y, d.y);\n}\n\nfloat oct_down(float freq, float octaves)\n{\n    return freq * (1.0 \/ pow(2.0, octaves));\n}\n\nfloat oct_up(float freq, float offset)\n{\n    return freq * pow(2.0, offset);\n}\n\nfloat sine_gen(float freq, float t)\n{\n    return sin(TAU * freq * t);\n}\n\n\/\/ Generates a sine wave with n harmonics\nfloat sinharm(float freq, int first, int stride, float fshift, float fmul, float t)\n{\n    float s = sine_gen(freq, t);\n    \n    int st = stride + 1;\n    \n    for(int i = 0; i < OSCRES; ++i)\n    {\n        float harm = float(first + (i) * (stride + 1));\n        s += sine_gen(fshift + freq * harm * fmul, t) \/ harm;\n    }\n    \n    return s;\n}\n\nfloat sinharm(float freq, int first, int stride, float t)\n{\n    return sinharm(freq, first, stride, 0.0, 1.0, t);\n}\n\nfloat bitcrush(float s, float res)\n{\n    return floor(s * res) \/ res;\n}\n\nfloat saw_gen(float freq, float t)\n{\n    return sinharm(freq, 1, 0, t);\n}\n\nfloat sq_gen(float freq, float t)\n{\n    return sinharm(freq, 1, 1, t);\n}\n\nfloat noise_gen(float t)\n{\n    return mix(-1.0, 1.0, random(t));\n}\n\nfloat simple_dist(float s, float e)\n{\n    return s \/ abs(s) * pow(1.0-e, pow(s, 2.0 \/ abs(s)));\n}\n\n\/\/ Returns a 3d vector where:\n\/\/     x = 1.0 or 0.0, depending on if the note is on or off\n\/\/    y = time since note started, or 0.0 if note is off.\n\/\/    z = frequency of the note\nvec3 note(float freq, float off, float len, float t)\n{\n    float note_on = (t >= off && t < (off + len)) ? 1.0 : 0.0;\n    \n    float note_t = 0.0;\n    float outfreq = 0.0;\n    \n    \n    if(note_on > 0.0) {\n        note_t = t - off;\n        outfreq = freq;\n    }\n    \n    return vec3(note_on, note_t, outfreq);\n}\n\nvec3 bass_pattern(float t)\n{\n    float lt = mod(t, b1_1);\n    \n    int r = int(mod(t, b1_1 * 4.0) \/ b1_1);\n    \n    float n = nB;\n    if(r >= 1)\n        n = nG;\n    if(r >= 2)\n        n = nA;\n    if(r >= 3)\n        n = nE;\n    \n    float b1 = oct_down(n, 3.0);\n    float e2 = oct_down(nD, 2.0);\n    float b2 = oct_down(nB, 2.0);\n    \n    return\n        note(b1, b1_8,             b1_8t,  lt) +\n        note(b1, b1_8 * 3.0,        b1_8t,  lt) +\n        note(b1, b1_8 * 5.0,        b1_8t,  lt) +\n        \n        note(b1, b1_4 * 3.0 + b1_16,      b1_16,  lt) +\n        note(e2, b1_4 * 3.0 + b1_16 * 2.0,  b1_16,  lt) +\n        note(b2, b1_4 * 3.0 + b1_16 * 3.0,  b1_16,  lt);\n}\n\nvec3 sub_pattern(float t)\n{\n    float lt = mod(t, b1_1 * 4.0);\n    \n    float n1 = oct_down(nB, 3.0);\n    float n2 = oct_down(nG, 3.0);\n    float n3 = oct_down(nA, 3.0);\n    float n4 = oct_down(nE, 3.0);\n    \n    return\n        note(n1, 0.0, b1_1, lt) +\n        note(n2, b1_1, b1_1, lt) +\n        note(n3, b1_1 * 2.0, b1_1, lt) +\n        note(n4, b1_1 * 3.0, b1_1, lt);\n}\n\nfloat kick_gen(float t)\n{\n    vec4 noise_env = vec4(0.001, 0.05, 0.05, 0.1);\n    float noise = adsr(noise_env, t) * noise_gen(t) * 0.003;\n    \n    vec4 vol_env   = vec4(0.0, 0.1, 0.5, 0.2);\n    float pitch    = env4(\n        vec2(0.0007, nB * 3.0),\n        vec2(0.0005, oct_down(nB, 1.0)),\n        vec2(0.06 , oct_down(nB, 3.0)),\n        vec2(0.9 , oct_down(nB, 4.0)),\n        t);\n        \n    float sub = sine_gen(pitch, t) * adsr(vol_env, t);\n    \n    return sub + noise;\n}\n\nfloat kick_pattern(float t)\n{\n    return mod(t, b1_4);\n}\n\nfloat hh_pattern(float t)\n{\n    return mod(t, b1_16);\n}\n\nvec3 arp_pattern(float t)\n{\n    float lt = mod(t, b1_4);\n    \n    int r = int(mod(t, b1_1 * 4.0) \/ b1_1);\n    \n    float n4 = nB;\n    if(r >= 1)\n        n4 = oct_up(nCs, 1.0);\n    if(r >= 2)\n        n4 = oct_up(nD, 1.0);\n    if(r >= 3)\n        n4 = oct_up(nE, 1.0);\n    \n    \n    float n1 = oct_down(nB, 1.0);\n    float n2 = nCs;\n    float n3 = nD;\n    \n    return\n        note(n1, 0.0,       b1_16 + 0.001, lt) +\n        note(n2, b1_16,     b1_16 + 0.01, lt) +\n        note(n3, b1_16 * 2.0,   b1_16 + 0.001, lt) +\n        note(n4, b1_16 * 3.0,   b1_16 + 0.01, lt);\n}\n\nfloat snare_gen(float t)\n{\n    return noise_gen(t * 0.0065) * adsr(vec4(0.0, 0.08, 0.4, 0.0), t);\n}\n\nfloat snare_pattern(float t)\n{\n    float lt = mod(t, b1_4 * 2.0);\n    return note(0.0, b1_4, b1_8, lt).y;\n}\n\nfloat hardclip(float s, float g)\n{\n    return clamp_c(-1.0, 1.0, s * g);\n}\n\nvec2 mainSound(float time)\n{\n    vec3 bpatt = bass_pattern(time);\n    \n    vec4 env = vec4(0.0, b1_16, 0.0, b1_32t);\n    float shaper_env = adsr(env, bpatt.y);\n    \n    float bass = sinharm(oct_down(bpatt.z, 1.0), 1, 0, 0.0, 3.0, time);\n    \n    bass = sine_gen(bass, 1.0);\n    bass = saw_gen(bass, sine_gen(time \/ 4.0, b1_1));\n    \n    bass *= bpatt.x;\n    \/\/bass = hardclip(bass, 50.0);\n    bass *= 0.2;\n    \n    vec3 spatt = sub_pattern(time);\n    float sub_bass = sine_gen(spatt.z, time);\n    \n    vec4 subenv = vec4(0.01, b1_1 - 0.02, 1.0, 0.01);\n    sub_bass *= adsr(subenv, spatt.y);\n    \n    \/\/sub_bass = saw_gen(sub_bass, (1.0 \/ 16.0));\n    \n    float kpatt = kick_pattern(time);\n    float kick = kick_gen(kpatt) * 1.5;\n    \n    float hh = noise_gen(time) * adsr(vec4(0.0, 0.05, 0.0, 0.0), hh_pattern(time)) * 0.04;\n    float sn = snare_gen(snare_pattern(time));\n    \n    float sample = 0.0;\n    sample += bass;\n    sample += sub_bass * 1.5;\n    \n    sample += clamp_c(-1.0, 1.0, kick * 4.0);\n    sample += hh;\n    sample += sn * 0.4;\n     \n    \n    \n    vec3 apatt = arp_pattern(time);\n    vec4 arp_env = vec4(0.0, 0.2, b1_16t, 0.1);\n    \n    vec2 arp = vec2(0.0);\n    arp.x = sq_gen(apatt.z - 1.4, time);\n    arp.y = sq_gen(apatt.z + 1.4, time);\n    \n    float m = 0.05;\n    arp = vec2(\n        mix(arp.x, arp.y, m),\n        mix(arp.y, arp.x, m)\n        );\n    \n    float arpEnv = adsr(vec4(0.0, 0.1, 0.5, 0.1), mod(time, b1_16));\n    \n    arp *= arpEnv;\n    \n    vec2 ssample = vec2(0.0);\n    ssample += arp;\n    \n    ssample *= 0.13;\n    \n    vec2 master = vec2(sample) + ssample;\n    master *= 0.3;\n    \n   \n    \/\/ lol limiter on master bus\n    return vec2(clamp_c(-1.0, 1.0, master.x), clamp_c(-1.0, 1.0, master.y));\n}","name":"","description":"","type":"sound"}]}}