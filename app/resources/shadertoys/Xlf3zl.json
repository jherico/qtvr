{"Shader":{"ver":"0.1","info":{"id":"Xlf3zl","date":"1424149610","viewed":1343,"name":"Parametric graph by curvature","username":"iq","description":"An attempt to find a way to compute the distance to a parametric curve map(t) that is better than linear search, based on curvature. An intuition really, need to think about this deeply. Inspired by eiffie's shaders.","likes":13,"published":3,"flags":0,"tags":["2d","graph","parametric"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\/\/ An attempt to find a way to compute the distance to a parametric curve p(t) that is\n\/\/ better than linear search. In this case, I'm trying to measure curvature to concentrate\n\/\/ the samples in highly curved areas.\n\/\/\n\/\/ The shader switches between the linear search and the optimized version, showing how for the\n\/\/ same amount of steps \/ complexity, the new method produces better results.\n\/\/\n\/\/ I need to work on this more, I am not sure yet the right way to do this really, all I got was\n\/\/ an intuition inspired by eiffie's shader https:\/\/www.shadertoy.com\/view\/4tfGRl.\\\n\n\nvec2 map(float t)\n{\n    return 0.85*cos( t + vec2(0.0,1.0) )*(0.6+0.4*cos(t*7.0+vec2(0.0,1.0)));\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a, ba = b - a;\n\treturn length( pa - ba*clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 ) );\n}\n\nfloat graph( vec2 p, bool doOptimized )\n{\n    float h = doOptimized ? 0.05 : 6.2831\/70.0;\n\tfloat t = 0.0;\n    \n    vec2  a = map(t);\n    float d = length( p - a );\n    \n    t += h;\n    for( int i=0; i<70; i++ )\n    {\n        vec2  b = map(t);\n        d = min( d, sdSegment( p, a, b ) );\n        \n\t\tt += (doOptimized) ? clamp( 0.026*length(a-p)\/length(a-b), 0.02, 0.1 ) : h;\n        a = b;\n\t}\n    \n\treturn d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy+2.0*fragCoord.xy)\/iResolution.y;\n    \n    bool doOptimized = sin(2.0*iGlobalTime) > 0.0;\n\n    float d = graph( p, doOptimized );\n        \n    vec3 col = vec3(0.9);\n    col *= 1.0 - 0.03*smoothstep(-0.3,0.3,sin( 120.0*d ));\n    col *= smoothstep(0.0, 0.01, d );\n    col *= 1.0 - 0.1*dot(p,p);\n\n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}