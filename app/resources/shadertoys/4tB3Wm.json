{"Shader":{"ver":"0.1","info":{"id":"4tB3Wm","date":"1429920446","viewed":794,"name":"Rocky Pools","username":"Xor","description":"3D Water test.","likes":2,"published":3,"flags":0,"tags":["procedural","3d","raymarching","reflection","sun","refraction","water","sky","rocks","xor","rocky","pools"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define steps 120\n\n#define clarity 0.8\n#define waterc vec3(0.06,0.2,0.3)\n#define refraction 0.8\n\n#define sund normalize(vec3(1.0,0.2,0.4))\n#define sunc vec3(2.0,0.85,0.2)\n\nfloat s(float n)\n{\n \treturn smoothstep(0.0,1.0,n);\n}\nfloat rand(vec3 p)\n{\n \treturn fract(abs(cos(dot(p,vec3(8.53,9.38,7.26)))*46.35));\n}\nfloat srand(vec3 p)\n{\n \tvec3 f = floor(p);\n    vec3 s = smoothstep(vec3(0.0),vec3(1.0),fract(p));\n    \n    return mix(mix(mix(rand(f),rand(f+vec3(1.0,0.0,0.0)),s.x),\n           mix(rand(f+vec3(0.0,1.0,0.0)),rand(f+vec3(1.0,1.0,0.0)),s.x),s.y),\n           mix(mix(rand(f+vec3(0.0,0.0,1.0)),rand(f+vec3(1.0,0.0,1.0)),s.x),\n           mix(rand(f+vec3(0.0,1.0,1.0)),rand(f+vec3(1.0,1.0,1.0)),s.x),s.y),s.z);\n}\nvec3 model(vec3 p)\n{\n    float T = iGlobalTime\/4.0;\n    float ground = (pow((srand(p)*0.95+srand(p*8.0)*0.05),2.0)+p.y*0.2)*1.6;\n    float water = ((srand(vec3(p.xz*3.0,T))*0.6+srand(vec3(p.xz*5.0,T*2.0))*0.4)*0.05+1.2+p.y)*0.7;\n \treturn vec3(ground,water,min(ground,water));\n}\nfloat dist(vec3 p, vec3 d)\n{\n    float h = 1.0;\n    float r = 1.0;\n    float dis = -1.0;\n    for(int i = 0;i<steps;i++)\n    {\n\t    h = model( p+d*r ).z;\n        r += h;\n        if (h < 0.0 || r > 20.0 ) break; \n    }\n    if( r < 20.0 ) dis = r;\n    return dis;\n}\nfloat dist2(vec3 p, vec3 d)\n{\n    float h = 0.1;\n    float r = 0.0;\n    float dis = -1.0;\n    for(int i = 0;i<80;i++)\n    {\n\t    h = model( p+d*r ).x;\n        r += h;\n        if (h < 0.0 || r > 10.0 ) break; \n    }\n    if( r < 10.0 ) dis = r;\n    return dis;\n}\nvec3 normal1(vec3 pos )\/\/Fucntion by Iq\n{\n    const float eps = 0.0002;\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*model( pos + v1*eps ).z + \n\t\t\t\t\t  v2*model( pos + v2*eps ).z + \n\t\t\t\t\t  v3*model( pos + v3*eps ).z + \n\t\t\t\t\t  v4*model( pos + v4*eps ).z );\n}\nvec3 normal2(vec3 pos )\/\/Fucntion by Iq\n{\n    const float eps = 0.01;\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*model( pos + v1*eps ).x + \n\t\t\t\t\t  v2*model( pos + v2*eps ).x + \n\t\t\t\t\t  v3*model( pos + v3*eps ).x + \n\t\t\t\t\t  v4*model( pos + v4*eps ).x );\n}\nvec3 background(vec3 d)\n{\n    float up = d.y*0.5+0.5;\n    float sun = pow(dot(d,sund)*0.5+0.5,128.0);\n    vec3 sky = mix(vec3(0.6,0.7,0.8),vec3(0.5,0.8,0.9),up);\n    \n    return sky+pow(vec3(sun),1.0\/sunc);\n}\nvec3 ground(vec3 p,vec3 norm)\n{\n    float s = srand(p)*0.4+srand(p*16.0)*0.07+srand(p*32.0)*0.02+srand(p*64.0)*0.01;\n    vec3 n = normalize(norm+cos(vec3(s*254.0,s*234.0-436.0,s*267.0))*0.2);\n    vec3 l = mix(vec3(0.5),normalize(sunc+1.0),pow(dot(n,sund)*0.5+0.75,2.0));\n \treturn s*l;   \n}\nvec3 water(vec3 p,vec3 norm, vec3 d)\n{\n    vec3 r = reflect(d,norm);\n    float a = 1.0-abs(dot(r,norm));\n    vec3 rl = background(r);\n    vec3 rf = waterc;\n    \n    float dis = dist2(p,r);\n    if (dis>0.0)\n    {\n    \trl = ground(p+dis*r,normal2(p+dis*r));\n    }\n    r = refract(d,norm,refraction);\n    dis = dist2(p,r);\n    if (dis>0.0)\n    {\n        rf = mix(ground(p+dis*r,normal2(p+dis*r)*0.5),rf,pow(dis\/10.0,clarity));\n    }\n \treturn mix(mix(rf,rl,pow(dot(rl,vec3(a\/3.0)),2.0)),waterc,a*0.2);   \n}\nvec3 color(vec3 p,vec3 norm, vec3 d)\n{\n  \tvec3 c = vec3(0.2,0.1,0.05);\n    if (model(p).y>model(p).x)\n    {\n    \tc = ground(p,norm);\n    }\n    else\n    {\n    \tc = water(p,norm,d);\n    }\n \treturn c;  \n}\nmat3 calcLookAtMatrix(vec3 ro, vec3 ta, float roll)\/\/Function by Iq\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = ( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = ( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\nvec3 scene(vec3 p, vec3 d)\n{\n    float dis = dist(p,d);\/\/Ray distance\n    vec3 c = background(d);\/\/Background Color\n    if (dis>0.0)\n    {\n    \tc = mix(color(p+d*dis,normal1(p+d*dis),d),c,pow(dis\/40.0,16.0));\/\/Material color and fade\n    }\n    return c;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 f = (-iResolution.xy + 2.0*fragCoord.xy)\/iResolution.y;\/\/2D Position\n    float t = iGlobalTime*0.2;\/\/Time\n    vec2 a = (iMouse.xy\/iResolution.xy)*vec2(6.2831,-3.14159);\n    vec3 r = vec3(cos(a.x)*cos(a.y),sin(a.y),sin(a.x)*cos(a.y));\n    vec3 p = vec3(cos(t),0.0,sin(t))*16.0;\/\/3D Position\n    mat3 cm = calcLookAtMatrix(p,(p+r)*sign(iMouse.z),0.0);\/\/Camera matrix\n    vec3 d = normalize( cm * vec3(f.xy,2.0) );\/\/Ray direction\n    \n    vec3 c = scene(p,d);\n\tfragColor = vec4(c,1.0);\n}\n\/*void mainV( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec3 p = fragRayOri + vec3( 1.0, 0.0, 1.0 );\n    vec3 d = fragRayDir;\n    vec3 c = scene( p, d);\n    \n\tfragColor = vec4( c, 1.0 );\n}*\/","name":"","description":"","type":"image"}]}}