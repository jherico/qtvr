{"Shader":{"ver":"0.1","info":{"id":"lljXWG","date":"1446231051","viewed":625,"name":"Clouds mod experiment","username":"Duke","description":"Frankly I'm not sure whether it was necessary to publish this shader, as changes in comparison with the original are small. But perhaps it will seem interesting to someone. Main code is from iq's \"Clouds\" demo and noises from otaviogood's \"Alien Beacon\"","likes":8,"published":3,"flags":1,"tags":["clouds"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Clouds come from https:\/\/www.shadertoy.com\/view\/XslGRr\n\/\/ Noises come from https:\/\/www.shadertoy.com\/view\/ld2SzK\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#define CLOUDTYPE3\n\n#ifdef CLOUDTYPE1\n\/\/ default noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D( iChannel0, (uv+ 0.5)\/256.0, -100.0 ).yx;\n\treturn -1.0+2.0*mix( rg.x, rg.y, f.z );\n}\n#endif\n\nconst float nudge = 0.739513;\t\/\/ size of perpendicular vector\nfloat normalizer = 1.0 \/ sqrt(1.0 + nudge*nudge);\t\/\/ pythagorean theorem on that perpendicular to maintain scale\n\n#ifdef CLOUDTYPE2\nfloat noise(vec3 p)\n{\n    float n = 0.0;\t\/\/ noise amount\n    float iter = 1.0;\n    for (int i = 0; i < 4; i++)\n    {\n        \/\/ add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) \/ iter;\t\/\/ abs for a ridged look\n        \/\/ rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        \/\/ rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        \/\/ increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\n#endif\n\n#ifdef CLOUDTYPE3\nfloat noise(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    for (int i = 0; i < 4; i++)\n    {\n        n += (sin(p.y*iter) + cos(p.x*iter)) \/ iter;\n        p.xy *= normalizer;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.33733;\n    }\n    return n;\n}\n#endif\n#ifdef CLOUDTYPE4\nfloat noise(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    for (int i = 0; i < 4; i++)\n    {\n        n += (sin(p.y*iter) + cos(p.x*iter)) \/ iter;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.33733;\n    }\n    return n;\n}\n#endif\n#ifdef CLOUDTYPE5\nfloat noise(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    for (int i = 0; i < 4; i++)\n    {\n        n += (sin(p.y*iter) + cos(p.x*iter)) \/ iter;\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.33733;\n    }\n    return n;\n}\n#endif\n\nfloat map5( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*iGlobalTime;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q ); q = q*2.02;\n    f += 0.03125*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n\nfloat map4( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*iGlobalTime;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\nfloat map3( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*iGlobalTime;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\nfloat map2( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*iGlobalTime;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q );;\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n\nvec3 sundir = normalize( vec3(-1.0,0.75,-1.0) );\n\n\nvec4 integrate( in vec4 sum, in float dif, in float den, in vec3 bgcol, in float t )\n{\n    \/\/ lighting\n    vec3 lin = vec3(0.65,0.68,0.7)*1.3 + 0.5*vec3(0.7, 0.5, 0.3)*dif; \n    \/\/ original\n    \/\/vec4 col = vec4( mix( 1.15*vec3(1.0,0.95,0.8), vec3(0.65), den ), den );\n    \/\/ scattering approximation\n    \/\/vec4 col = vec4(vec3(1.\/exp( den * 0.2 ) * clamp(sin(iGlobalTime)*2.5,0.4,1.05)), den);\/\/ * 2.5);\n    vec4 col = vec4(vec3(1.\/exp( den * 0.2 ) * 1.05), den);\/\/ * 2.0);\n    col.xyz *= lin;\n    col.xyz = mix( col.xyz, bgcol, 1.0-exp(-0.003*t*t) );\n    \/\/ front to back blending    \n    col.a *= 0.4;\n    col.rgb *= col.a;\n    return sum + col*(1.0-sum.a);\n}\n\n#define MARCH(STEPS,MAPLOD) for(int i=0; i<STEPS; i++) { vec3  pos = ro + t*rd; if( pos.y<-3.0 || pos.y>2.0 || sum.a > 0.99 ) break; float den = MAPLOD( pos ); if( den>0.01 ) { float dif =  clamp((den - MAPLOD(pos+0.3*sundir))\/0.6, 0.0, 1.0 ); sum = integrate( sum, dif, den, bgcol, t ); } t += max(0.1,0.02*t); }\n\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol )\n{\n\tvec4 sum = vec4(0.0);\n\n\tfloat t = 0.0;\n\n    MARCH(30,map5);\n    MARCH(30,map4);\n    MARCH(30,map3);\n    MARCH(30,map2);\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec4 render( in vec3 ro, in vec3 rd )\n{\n    \/\/ background sky     \n\tfloat sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n\tvec3 col = vec3(0.6,0.71,0.75) - rd.y*0.2*vec3(1.0,0.5,1.0) + 0.15*0.5;\n\tcol += 0.2*vec3(1.0,.6,0.1)*pow( sun, 8.0 );\n\n    \/\/ clouds    \n    vec4 res = raymarch( ro, rd, col );\n    col = col*(1.0-res.w) + res.xyz;\n    \n    \/\/ sun glare    \n\tcol += 0.1*vec3(1.0,0.4,0.2)*pow( sun, 3.0 );\n\n    return vec4( col, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)\/ iResolution.y;\n\n    vec2 m = iMouse.xy\/iResolution.xy;\n    \n    \/\/ camera\n    vec3 ro = 4.0*normalize(vec3(sin(3.0*m.x), 0.4*m.y, cos(3.0*m.x)));\n\tvec3 ta = vec3(0.0, -1.0, 0.0);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \/\/ ray\n    vec3 rd = ca * normalize( vec3(p.xy,1.5));\n    \n    fragColor = render( ro, rd );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    fragColor = render( fragRayOri, fragRayDir );\n}","name":"","description":"","type":"image"}]}}