{"Shader":{"ver":"0.1","info":{"id":"lljGDm","date":"1433092604","viewed":751,"name":"red Only","username":"ManuManu","description":"A try to have a sin city like effect.<br\/>Actually, I tried 2 different technics, but the simplest one looks better...<br\/>Not sure what is the real technic ( beside manual edition )","likes":0,"published":3,"flags":2,"tags":["red","webcam","sincity"],"hasliked":0},"renderpass":[{"inputs":[{"id":31,"src":"\/presets\/webcam.png","ctype":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/*void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iGlobalTime),1.0);\n}*\/\n\nconst float HugeDist = 100.0;\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 \/ 3.0, 2.0 \/ 3.0, -1.0);\n    vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n    vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) \/ (6.0 * d + e)), d \/ (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n#define RGB_VERSION\n\n#ifdef RGB_VERSION\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 wantedColor=  vec3( 1.0, .0, .0 );\n    \/\/vec3 wantedColor=  vec3( 0.0, 1.0, .0 );\n    \/\/vec3 wantedColor=  vec3( .0, .0, 1.0 );\n    float minDist = .0;\n    float maxDist = 1.6;\n  vec2 uv = fragCoord.xy \/ iResolution.xy;\n  vec4 color = texture2D(iChannel0, uv);\n    \/\/ Funky test :\n  \/*\n\tvec4 color2 = color;\n  color2.rgb = 1.0 - color.rgb;\n  color2.r = max(color.r, color2.r);\n*\/\n  float gray = dot(vec3( color), vec3(0.299, 0.587, 0.114) );\n  \/\/fragColor = color2.brga;\n   float distToColor = distance( color.rgb, wantedColor ) ;\n    \n    \/\/ only take care of color with a low red component :\n    if ( color.r <.8 ) distToColor = HugeDist;\n    \n    \/\/vec4 red = vec4(1.0, .0, .0, 1.);\/\/color * vec4( 2.0, .0, .0, 1. );\n    vec4 red = color;\n    \/\/ to uncomment to push the red even more :\n    \/\/red = red * vec4( 2.0, .0, .0, 1. );\n    \n    float param = smoothstep( minDist, maxDist, distToColor);\n    \/\/fragColor.rgb= vec3(param);\n\n    fragColor = mix( red, vec4(vec3(gray), 1.0 ), param );\n}\n\n\n#else\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float WantedHue = .0;\n    float dist = .01;\n   \tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec3 color = rgb2hsv( vec3( texture2D(iChannel0, uv) ) );\n    vec3 colorgrey = color;\n    colorgrey.g = .0;\n    vec3 colorFul = color;\n    \/\/colorFul.r = WantedHue;\n    \/\/colorFul.g *= 1.5;\n    \/\/colorFul.b *= 1.5;\n    \/\/colorFul.g = 1.;\n    color = mix( colorFul, colorgrey, smoothstep( .0, dist,mod( color.r - WantedHue,1. ) ) );\n    fragColor = vec4( hsv2rgb(color), 1.0);\n    \/\/fragColor = vec4( hsv2rgb(colorFul), 1.0);\n}\n\n#endif\n","name":"","description":"","type":"image"}]}}