{"Shader":{"ver":"0.1","info":{"id":"XlsSDM","date":"1438265929","viewed":1087,"name":"[SIG15]IWantToPlayAGame","username":"EvilRyu","description":"Jigsaw puppet mask from movie \"saw\"<br\/>","likes":14,"published":3,"flags":0,"tags":["raymarching","scary","head","saw","siggraph","sig15","jigsaw"],"hasliked":0},"renderpass":[{"inputs":[{"id":10,"src":"\/presets\/tex09.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":23,"src":"\/presets\/cube01_0.png","ctype":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/\n\/\/ [SIG15] I want to play a game\n\/\/         \n\/\/ by EvilRyu.\n\n\/\/ \"I want to play a game\": A line in the movie <Saw> attributed to the \n\/\/ serial killer jigsaw. He would often greet his victims via a sound recording and this\n\/\/ mask on TV.\n\n\n\n#define MTL_EYE 2.0\n#define MTL_CHEEK 3.0\n#define MTL_JAW 4.0\n#define MTL_HAIR 5.0\n#define MTL_ORBIT 6.0\n\nfloat g_d;\nfloat g_mtl_id;\nvec3 g_eye_pos;\nvec3 g_upper_lip_pos;\nvec3 g_lower_lip_pos;\nvec3 g_cheek_pos;\nvec3 g_hair_offset = vec3(0.0, -2.2, 0.8);\nfloat g_hair_scale = 2.0;\n\nvoid rp_rotate_y(inout vec3 p, float a)\n { \n    float c,s;vec3 q=p; \n    c = cos(a); s = sin(a); \n    p.x = c * q.x + s * q.z; \n    p.z = -s * q.x + c * q.z;\n } \n\nvoid rp_rotate_z(inout vec3 p, float a) \n{ \n    float c,s;vec3 q=p; \n    c = cos(a); s = sin(a); \n    p.x = c * q.x - s * q.y; \n    p.y = s * q.x + c * q.y;\n} \n\n\nvoid rp_rotate_x(inout vec3 p, float a) \n{ \n    float c,s;vec3 q=p; \n    c = cos(a); s = sin(a);\n    p.y = c * q.y - s * q.z; \n    p.z = s * q.y + c * q.z; \n} \n\n\n\/\/-----------distance functions from iq----------------\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat round_box( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5+0.5*(b-a)\/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat torus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat tri_prism(vec3 p, vec2 h)\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat box(vec3 p, vec3 b)\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat capsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\/\/----------------------------------------------------------------------\n\n\n\/\/---------------------fur shader from simesgreen-----------------------\n\/\/https:\/\/www.shadertoy.com\/view\/XsfGWN#\nconst float g_uv_scale = 1.0;\nconst float g_fur_depth = 0.2;\nconst int g_fur_layers = 64;\nconst float g_ray_step = g_fur_depth*2.0 \/ float(g_fur_layers);\nconst float g_fur_threshold = 0.7;\nconst float g_shininess = 50.0;\nfloat hair(vec3 p);\n\nvec2 cartesian2spherical(vec3 p)\n{       \n    float r = length(p);\n    float t = (r - (1.0 - g_fur_depth)) \/ g_fur_depth;    \n    p \/= r; \n    vec2 uv = vec2(atan(p.y, p.x), acos(p.z));\n    uv.y -= t*0.3;  \/\/ curl down\n    return uv;\n}\n\nfloat fur_density(vec3 pos, out vec2 uv)\n{\n     \/\/ should to apply the same transformation in distance function\n    vec3 p = pos;\n    rp_rotate_y(p, -floor(4.0*sin(3.0-3.0*smoothstep(3.,6.,mod(iGlobalTime,24.0)))) * 0.1);\n    p+=g_hair_offset;\n    p.z*=3.0;\n    \n    \n    uv = cartesian2spherical(p.xzy); \n    vec4 tex = texture2D(iChannel0, uv*g_uv_scale);\n   \n    \/\/ thin out hair\n    float density = smoothstep(g_fur_threshold, 1.0, tex.x);\n    \n    float r = (length(p) - g_hair_scale)*0.5;\n    float t = (r - (1.0 - g_fur_depth)) \/ g_fur_depth;\n    \n    \/\/ fade out along length\n    float len = tex.y;\n    density *= smoothstep(len, len-0.2, t);\n\n    return density; \n}\n\nvec3 fur_normal(vec3 pos, float density)\n{\n    float eps = 0.01;\n    vec3 n;\n    vec2 uv;\n    n.x = fur_density(vec3(pos.x+eps, pos.y, pos.z), uv ) - density;\n    n.y = fur_density(vec3(pos.x, pos.y+eps, pos.z), uv ) - density;\n    n.z = fur_density(vec3(pos.x, pos.y, pos.z+eps), uv ) - density;\n    return normalize(n);\n}\n\nvec3 fur_shade(vec3 pos, vec2 uv, vec3 ro, float density)\n{\n    \/\/ lighting\n    const vec3 L = vec3(0, 1, 0);\n    vec3 V = normalize(ro - pos);\n    vec3 H = normalize(V + L);\n\n    vec3 N = -fur_normal(pos, density);\n    float diff = max(0.0, dot(N, L)*0.5+0.5);\n    float spec = pow(max(0.0, dot(N, H)), g_shininess);\n    \n    \/\/ base color\n    vec3 color = vec3(0.1);\n\n    \/\/ darken with depth\n    float r = length(pos);\n    float t = (r - (1.0 - g_fur_depth)) \/ g_fur_depth;\n    t = clamp(t, 0.0, 1.0);\n    float i = t*0.5+0.5;\n        \n    return color*diff*i + vec3(spec*i);\n}       \n\/\/---------------------------------------------------------------------\n\nfloat hash(vec2 p)\n{\n    p=fract(p*vec2(5.3983,5.4472));\n    p+=dot(p.yx,p.xy+vec2(21.5351,14.3137));\n    return fract(p.x*p.y*95.4337);\n}\n\nfloat noise(vec2 p)\n{\n    vec2 f;\n    f=fract(p);\n    p=floor(p);\n    f=f*f*(3.0-2.0*f);\n    return mix(mix(hash(p),hash(p+vec2(1.0,0.0)),f.x),\n               mix(hash(p+vec2(0.0,1.0)),hash(p+vec2(1.0,1.0)),f.x),f.y);\n}\n\n\nfloat jaw(vec3 p, vec3 ds, float s)\n{\n    p.y += 1.73;\n    p.z -= 1.37;\n    rp_rotate_x(p, 0.3);\n    float d0 = round_box(p, vec3(s*sin((1.0-p.y)), 0.4, 1.0)+ds, 0.1);\n    p.x = abs(p.x) - 0.18;\n    p.z -= 0.3;\n    p.y +=0.3;\n    float d1 = capsule(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.5, -0.23), 0.07);\n    \n    return smin(d0, d1, 0.2);\n}\n\nfloat nose(vec3 p)\n{\n    p.y += 0.6;\n    p.z -= 1.25;\n    float d0 = round_box(p, vec3(0.01, \n                                 0.4, \n                                 atan((1.0-p.y*2.)*(1.0-p.y*p.y*2.))*0.45), 0.05);\n   \n    p.z -= 0.3;\n    p.y += 0.4;\n    p.x = abs(p.x) - 0.02;\n    float d1 = capsule(p, vec3(0.0, 0.0, 0.0), vec3(0.3, 0.15, -0.4)*0.4, 0.07);\n    return smin(d0\/2., d1, 0.2);\n}\n\nfloat cheek(vec3 p)\n{\n    p.y += 0.7;\n    p.z -= 1.1;\n    p.x = abs(p.x) - 0.7;\n    float d0 = capsule(p + vec3(1.0, -0.15, 0.0), vec3(0.0, 0.0, -0.1), vec3(1.1, -0.1, 0.0), 0.35);\n    return d0;\n}\n\nfloat orbit(vec3 p)\n{\n    p.y += 0.16;\n    p.z -= 1.23;\n    p.x = abs(p.x) - 0.5;\n    rp_rotate_z(p, -0.2);\n    rp_rotate_y(p, -0.4);\n    float d0 = round_box(p, vec3(0.24, 0.04, 0.24), 0.13);\n    \n    return d0;\n}\n\nfloat eye(vec3 p)\n{\n    p.y += 0.19;\n    p.z -= 0.9;\n    p.x = abs(p.x) - 0.47;\n    float d0 = sphere(p, 0.28);\n    return d0;\n}\n\nfloat brow_ridge(vec3 p)\n{\n    p.y += 0.2;\n    p.z -= 0.4;\n    p.x = abs(p.x) - 0.2;\n    rp_rotate_z(p, -0.3);\n    rp_rotate_x(p, 0.3);\n    \n    float d0 = torus(p, vec2(0.83, 0.07));\n    return d0;\n}\n\n\nfloat hair(vec3 p)\n{\n    return (length(p*vec3(1.0, 1.0, 3.0)) - g_hair_scale)*0.5;\n}\n\nfloat head(vec3 p)\n{\n    vec3 tp = p;\n    rp_rotate_x(tp, 0.3);\n    tp.y -= 1.7;\n    tp.z -= 0.6;\n    float d0 = round_box(tp, vec3(0.87*(0.3*sin(tp.y)+0.5), \n                                 0.6,\n                                 0.04+(tp.y*0.15+0.1)), 0.4);\n    tp = p;\n    tp.y -= 3.0;\n    tp.z += .599;\n    float d1 = sphere(tp, 1.0);\n    float d2 = brow_ridge(tp);\n    float d3 = orbit(tp);\n    float d4 = cheek(tp);\n    float d5 = nose(tp);\n    float d6 = jaw(tp, vec3(0.0), 0.4);\n    \n    \/\/ movement of jaw\n    vec3 jp = tp + vec3(0.0, \n                        0.015*floor(2.0*sin(46.0*smoothstep(7.0,12.0,mod(iGlobalTime,12.0)))),\n                        0.2);\n    float d7 = jaw(jp, vec3(-0.01, -0.1, -0.9), 0.3);\n    float d8 = eye(tp);\n    float d10 = sphere(p + vec3(0.0, -2.2, 2.2), 2.25);\n    float d9 = hair(p + g_hair_offset);\n    \n    float d = smin(d1, d0, 0.5);\n    d = smin(d, d2, 0.3);\n    if(d4 < d) { g_mtl_id = MTL_CHEEK;g_cheek_pos = p;}\n     d = smin(d, d4, 0.2);\n    d = max(d, -d3);\n    d = max(d, -d6);\n    if(d7 < d) { d = d7; g_mtl_id = MTL_JAW; g_lower_lip_pos = jp;}\n    d = max(d, -d10);\n    d-=  texture2D(iChannel0, tp.xy*0.1-vec2(0.3, 0.3)).y*0.025;\n    if(d5 < d) { g_mtl_id = 1.0;}\n    d = smin(d, d5, 0.2);\n    \n    if(d8 < d) {d = d8; g_mtl_id = MTL_EYE; g_eye_pos = p;}\n    g_upper_lip_pos = p;\n        \n    if(d9 < d) {d = d9;g_mtl_id = MTL_HAIR;}\n    \n    return d;\n}\n\nfloat f(vec3 p)\n{ \n    g_mtl_id = 1.0;\n    rp_rotate_y(p, -floor(4.0*sin(3.0-3.0*smoothstep(3.,6.,mod(iGlobalTime,24.0))))*0.1);\n    float d0 = head(p); \n   \n    return d0;\n} \n\nvec3 normal(in vec3 pos)\n{\n    vec3 eps = vec3(0.001,0.0,0.0);\n    return normalize(vec3(\n           f(pos+eps.xyy) - f(pos-eps.xyy),\n           f(pos+eps.yxy) - f(pos-eps.yxy),\n           f(pos+eps.yyx) - f(pos-eps.yyx)));\n}\n\n\nfloat softshadow(vec3 ro, vec3 rd, float k )\n{ \n    float s=1.0,h=0.0; \n    float t = 0.01;\n    for(int i=0; i < 30; ++i)\n    { \n        h=f(ro+rd*t); \n        if(h<0.001)return 0.02; \n        s=min(s, k*max(h, 0.0)\/t); \n        t+=h; \n    } \n    return s; \n} \n\nvec3 lighting(vec3 ro, vec3 rd, vec3 pos,\n    vec3 upper_lip_pos, vec3 lower_lip_pos,\n    vec3 cheek_pos, vec3 eye_pos, float mtl_id)\n{\n    vec3 l0_dir = normalize(vec3(0.6, -0.5, 0.5));\n    vec3 l0_col = vec3(1.0, 1.0, 1.0);\n    vec3 n = normal(pos);\n    vec3 material = vec3(1.0);\n\n    vec3 col = vec3(0.0);\n\n    float sha = softshadow(pos+l0_dir*0.01, l0_dir, 20.0);\n    float dif = max(0.0, dot(l0_dir, n)); \n    float spe = max(0.0, pow(clamp(dot(l0_dir, reflect(rd, n)), 0.0, 1.0), 20.0)); \n\n    \/\/ texturing for different parts\n    if(upper_lip_pos.y < 1.8 && upper_lip_pos.y > 1.68 &&\n      upper_lip_pos.x > -0.8 && upper_lip_pos.x < 0.8 && upper_lip_pos.z > 0.0)\n    {\n        upper_lip_pos.x=abs(upper_lip_pos.x);\n        material -= vec3(0.5, 1.0, 1.0)*pow(smoothstep(0.0, 0.05, (upper_lip_pos.y-1.6)*\n                                                 pow((1.2-upper_lip_pos.x), 4.0)), 10.0);\n        clamp(material, 0.0, 1.0);\n    }\n\n    if(mtl_id == MTL_JAW)\n    {\n        float t = mod(lower_lip_pos.y, 2.3)-0.92;\n        material -= vec3(0.5, 1.0, 1.0)*\n                    pow(smoothstep(0.00, 0.005, t) * smoothstep(0.085, .08, t), 40.0);\n            clamp(material, 0.0, 1.0);\n    }\n    \n    if(mtl_id == MTL_CHEEK)\n    {\n        cheek_pos.x = abs(cheek_pos.x) - 0.7;\n        rp_rotate_y(cheek_pos, -0.7);\n        \n        if(cheek_pos.z > 0.62)\n        {\n            float t=mod(cheek_pos.z, 0.0554); \n            material -= vec3(0.5, 1.0, 1.0)*\n                    pow(smoothstep(0.00, 0.03, t) * smoothstep(0.085, .08, t), 40.0);\n            clamp(material, 0.0, 1.0);\n        }\n    }\n    \n    col += 4.0 * l0_col * dif * material * sha;\n    col += 3.0 * spe * vec3(1.0);\n    col += textureCube(iChannel1, n).xyz;\n   \n    if(mtl_id == MTL_EYE)\n    {\n        float t=mod(eye_pos.z, 0.493);\n \n        col = vec3(1.7, 0.2, 0.0)*\n              pow(smoothstep(0.0, 0.065, t) * smoothstep(0.085, .08, t), 10.0);\n        col += vec3(4.0)*spe;\n    }\n    \n    \n    return col;\n}\n\n\nvec4 scene(vec3 ro, vec3 rd)\n{\n    vec3 bg = vec3(0.0);\n    vec3 p=ro; \n    \n    vec4 c = vec4(0.0);\n    float t = 1.0;\n    float d = 1.0;\n    \n    \/\/ raymarching\n    for(int i = 0; i < 48; i++)\n    {\n        if( d < 0.003 || t > 20.0 )\n            break;\n        d = f(ro + rd*t);\n        t += d;\n    }\n    if( t>20.0) t=-1.0;\n    \n     if(t > 0.0)\n     {\n         \/\/ raymarching for hair\n         if(g_mtl_id == MTL_HAIR)\n         {\n             c=vec4(0.0);\n             vec3 pos = ro + rd * t;\n            \/\/ ray-march into volume\n            for(int i=0; i<g_fur_layers; i++) \n            {\n                vec4 sample_col;\n                vec2 uv;\n                \n                sample_col.a = fur_density(pos, uv);\n                if (sample_col.a > 0.0) \n                {\n                    if (c.a > 0.95) {} \/\/ for windows...\n                    else\n                    {\n                    \tsample_col.rgb = fur_shade(pos, uv, ro, sample_col.a);\n                    \tsample_col.rgb *= sample_col.a;\n                    \tc = c + sample_col*(1.0 - c.a);\n                    }\n                }\n                pos += rd*g_ray_step;\n            }\n         }\n         else\n         {\n               p = ro + t * rd;\n              \n               c.xyz = lighting(ro, rd, p, \n                              g_upper_lip_pos, g_lower_lip_pos,\n                              g_cheek_pos, g_eye_pos, g_mtl_id);\n               c.xyz *= 0.2;\n                \n               c.xyz=mix(c.xyz,bg, 1.0-exp(-0.01*t*t)); \n         }\n    } \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{ \n    vec2 q=fragCoord.xy\/iResolution.xy; \n    vec2 uv = -1.0 + 2.0*q; \n    uv.x*=iResolution.x\/iResolution.y; \n     \n    vec3 ro = vec3(0.0, 0.55, 1.0)*5.5;\n    vec3 ta = vec3(0.0, 0.0, -20.0);\n\n    vec3 cf = normalize(ta - ro); \n    vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n    vec3 cu = normalize(cross(cs,cf)); \n    vec3 rd = normalize(uv.x*cs + uv.y*cu + 3.0*cf); \n\n    vec4 c = scene(ro, rd);\n    vec3 col = c.xyz;\n    \/\/ post\n    col = clamp(col*0.5+0.5*col*col*1.6,0.0,1.0);\n    col *= vec3(0.95,1.35,1.05);\n    col *= 0.7+0.3*sin(10.0*iGlobalTime+q.y*1000.0);\n    col *= 0.8+0.2*sin(1100.0*iGlobalTime);\n    col += hash(q*iGlobalTime) * 0.05;\n    col=pow(clamp(col,0.0,1.0),vec3(0.45)); \n    col=mix(col, vec3(dot(col, vec3(0.33))), -0.5);  \/\/ satuation\n    col*=1.5 * pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  \/\/ vigneting\n \tcol *= smoothstep( 0.0, 8.0, iGlobalTime );\t\n    if(abs(uv.x)>1.2) col=vec3(0.0);\n    fragColor = vec4(col,c.a);\n}","name":"","description":"","type":"image"}]}}