{"Shader":{"ver":"0.1","info":{"id":"XtjSRm","date":"1442495185","viewed":2234,"name":"Weird Canyon","username":"aiekick","description":"it was an attempt in my terrain experiment study to do an antelope canyon<br\/>but failed to sculpt it realistic, and failed to do a good lighting.<br\/>the sand is weird also ^^<br\/>I must deepen the learning of light technics<img src=\"\/img\/emoticonHappy.png\"\/>","likes":22,"published":3,"flags":0,"tags":["weird","canyon"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Stephane Cuillerdier - Aiekick\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ Tuned via XShade (http:\/\/www.funparadigm.com\/xshade\/)\n\n\/* Weird Canyon\nit was an attempt in my terrain experiment study to do an antelope canyon\nbut failed to sculpt it realistic, and failed to do a good lighting.\nthe sand is weird also ^^\nI must deepen the learning of light technics:)\nthe screenshot is at 44.93s\nthe mouse axis y control the vertical angle of the cam\n*\/ \n\n#define mPi 3.14159\n#define m2Pi 6.28318\n\nfloat dstepf = 0.0;\n\nconst vec2 NoiseVar = vec2(950.,200.);\n    \nconst vec2 RMPrec = vec2(.3, 0.0001); \nconst vec2 DPrec = vec2(0.001, 40.); \n\nfloat random(float p) {return fract(sin(p)*NoiseVar.x);}\nfloat mynoise(vec2 p) {return random(p.x + p.y*NoiseVar.y);}\nvec2 sw(vec2 p) {return vec2( floor(p.x) , floor(p.y) );}\nvec2 se(vec2 p) {return vec2( ceil(p.x)  , floor(p.y) );}\nvec2 nw(vec2 p) {return vec2( floor(p.x) , ceil(p.y)  );}\nvec2 ne(vec2 p) {return vec2( ceil(p.x)  , ceil(p.y)  );}\nfloat snoise(vec2 p) {\n  \tvec2 inter = smoothstep(0., 1., fract(p));\n  \tfloat s = mix(mynoise(sw(p)), mynoise(se(p)), inter.x);\n  \tfloat n = mix(mynoise(nw(p)), mynoise(ne(p)), inter.x);\n  \treturn mix(s, n, inter.y);\n}\n\n\/\/https:\/\/www.shadertoy.com\/view\/llsXzB\n\/\/https:\/\/en.wikipedia.org\/wiki\/Oren%E2%80%93Nayar_reflectance_model\nvec3 OrenNayarLightModel(vec3 rd, vec3 ld, vec3 n, float albedo)\n{\n\tvec3 col = vec3(0.);\n\tfloat RDdotN = dot(-rd, n);\n\tfloat NdotLD = dot(n, ld);\n    float aRDN = acos(RDdotN);\n\tfloat aNLD = acos(NdotLD);\n\tfloat mu = 5.; \/\/ roughness\n\tfloat A = 1.-.5*mu*mu\/(mu*mu+0.57);\n    float B = .45*mu*mu\/(mu*mu+0.09);\n\tfloat alpha = max(aRDN, aNLD);\n\tfloat beta = min(aRDN, aNLD);\n\tfloat e0 = 4.8;\n\tcol = vec3(albedo \/ mPi) * cos(aNLD) * (A + ( B * max(0.,cos(aRDN - aNLD)) * sin(alpha) * tan(beta)))*e0;\n\treturn col;\n}\n\n\/\/https:\/\/www.shadertoy.com\/view\/Xl23Rc\nvec3 strate(vec2 uv)\n{\n    vec3 col1 = vec3(.94,.7,.25);\n    vec3 col2 = vec3(.91,.67,.11);\n    float y = uv.y+.85*sin(-uv.x);\n    y\/=.85;\n    float r = sin(25.*y)+cos(16.*y)+cos(19.*y);\n    vec3 col = mix(col1, col2, r);\n    return col;\n}\n\n\/\/ shane code\nfloat Voronesque( in vec3 p )\n{\n    vec3 i  = floor(p + dot(p, vec3(0.333333)) );  p -= i - dot(i, vec3(0.166666)) ;\n    vec3 i1 = step(0., p-p.yzx), i2 = max(i1, 1.0-i1.zxy); i1 = min(i1, 1.0-i1.zxy);    \n    vec3 p1 = p - i1 + 0.166666, p2 = p - i2 + 0.333333, p3 = p - 0.5;\n    vec3 rnd = vec3(7, 157, 113); \n    vec4 v = max(0.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);\n    vec4 d = vec4( dot(i, rnd), dot(i + i1, rnd), dot(i + i2, rnd), dot(i + 1., rnd) ); \n    d = fract(sin(d)*262144.)*v*2.; \n    v.x = max(d.x, d.y), v.y = max(d.z, d.w); \n    return max(v.x, v.y); \n}\n\n\/\/ used to compute campath and plane deformation along z\nfloat sinPath(vec3 p, float dec){return 6.4 * sin(p.z * .33 + dec);}\n\nvec2 map(vec3 p)\n{\n    vec2 res = vec2(0.);\n\n\tdstepf += .0007;\n\t\n\tfloat pathLeft = sinPath(p, 0.);\n\tfloat pathRight = sinPath(p, 19.5);\n\t\n\tfloat voro = Voronesque(p\/12.) * 7.6;\n\tfloat strateDisp = dot(strate(p.zy), vec3(.043));\n\tfloat strateNoise = snoise(p.zy\/.5) *.2;\n    float microNoise = snoise(p.zy\/.01) *.02;\n\t\n    float disp =  voro - strateDisp - strateNoise + microNoise;\n    \n\tfloat bottom = p.y + 2. - snoise(p.xz) * .38- snoise(p.xz\/.039) * .05;\n\tres = vec2(bottom, 1.);\n\t\n\tfloat left = p.x + pathLeft + 2. + disp;\n\tif (left < res.x)\n\t\tres = vec2(left, 2.);\n\t\n\tfloat right = 2. - p.x - pathRight + disp;\n\tif (right < res.x)\n\t\tres = vec2(right, 3.);\n\t\n\treturn res;\n}\n\nvec3 nor( vec3 pos, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n\t\tmap(pos+e.xyy).x - map(pos-e.xyy).x,\n\t\tmap(pos+e.yxy).x - map(pos-e.yxy).x,\n\t\tmap(pos+e.yyx).x - map(pos-e.yyx).x );\n    return normalize(n);\n}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cu, vec3 cv)\n{\n\tvec3 rov = normalize(cv-ro);\n    vec3 u =  normalize(cross(cu, rov));\n    vec3 v =  normalize(cross(rov, u));\n    vec3 rd = normalize(rov + u*uv.x + v*uv.y);\n    return rd;\n}\n\n\/\/ from iq code\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h\/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n\/\/ from iq code\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)\/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 lighting(vec3 col, vec3 p, vec3 n, vec3 rd, vec3 ref, float t) \/\/ lighting    \n{\n\t\/\/ from iq code\n\tfloat occ = calcAO( p, n );\n\tvec3  lig = normalize( vec3(0., 1., 0.) );\n\tfloat amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n\tfloat dif = clamp( dot( n, lig ), 0.0, 1.0 );\n\tfloat bac = clamp( dot( n, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-p.y,0.0,1.0);\n\tfloat dom = smoothstep( -0.1, 0.1, ref.y );\n\tfloat fre = pow( clamp(1.0+dot(n,rd),0.0,1.0), 2.0 );\n\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n\tdif *= softshadow( p, lig, 0.02, 2.5 );\n\tdom *= softshadow( p, ref, 0.02, 2.5 );\n\n\tvec3 brdf = vec3(0.0);\n\tbrdf += 1.20*dif*vec3(1.00,0.90,0.60);\n\tbrdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n\tbrdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n\tbrdf += 0.40*dom*vec3(0.50,0.70,1.00)*occ;\n\tbrdf += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n\tbrdf += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\tbrdf += 0.02;\n\tcol = col*brdf;\n\n\tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0005*t*t ) );\n\t\n\treturn col;\n}\n\nvoid mainImage( out vec4 f, in vec2 g )\n{\n    vec2 si = iResolution.xy;\n\tvec2 uv = (g+g-si)\/min(si.x, si.y);\n\tvec2 q = g\/si;\n    \n    float t = iGlobalTime*3.;\n\t\n\tvec4 gp = vec4(0.); \/\/uGamePad360;\n\t\n    vec3 cu = vec3(0,1,0);\n    vec3 ro = vec3(0., gp.y + 1., t);\n\tvec3 cv = vec3(gp.zw,.08); \n    if (iMouse.z>0.) \n    {\n        cv.y = iMouse.y\/iResolution.y*.8 - .5;\n        cv.x = iMouse.x\/iResolution.x*.8 - .5;\n    }\n    float cx = (sinPath(ro + cv, 0.) + sinPath(ro + cv, 19.5))\/2.;\n\tro.x -= cx;\n\tvec3 rd = cam(uv, ro, cu, ro + cv);\n\t\n    vec3 d = vec3(0.);\n    vec3 p = ro+rd*d.x;\n    vec2 s = vec2(DPrec.y,0.);\n\t\n    for(int i=0;i<200;i++)\n\t{      \n\t\tif(s.x<DPrec.x||s.x>DPrec.y) break;\n        s = map(p);\n\t\ts.x *= (s.x>DPrec.x?RMPrec.x:RMPrec.y);;\n\t\td.x += s.x;\n        p = ro+rd*d.x;\n   \t}\n\t\n\tif (d.x<DPrec.y)\n\t{\n\t\tvec3 n = nor(p, .05);\n        if(s.y < 3.5)\n\t\t{\n\t\t\tf.rgb = OrenNayarLightModel(rd, rd, n, 0.3);\t\n\t\t\tf.rgb += vec3(.94, .71, .53);\t\t\n\t\t}\n\t\tif (s.y < 1.5) \/\/ bottom\n        {\n\t\t\tf.rgb = OrenNayarLightModel(reflect(rd,n), rd, n, .75);\t\n\t\t\tf.rgb += vec3(.98,.76,.24);\n\t\t}\n\t\t\n\t\t\n\t\tf.rgb = lighting(f.rgb, p, n, rd, rd, d.x); \/\/ lighting    \n   \t}\n    else\n    {\n        \/\/https:\/\/www.shadertoy.com\/view\/4ssXW2\n        vec3 sun = vec3(1.0, .88, .75);;\n        float v = pow(1.0-max(rd.y,0.0),10.);\n\t\tf.rgb = vec3(v*sun.x*0.42+.04, v*sun.y*0.4+0.09, v*sun.z*0.4+.17);\n    }\n\n\t\/\/ vigneting  https:\/\/www.shadertoy.com\/view\/MsXGWr\n    f.rgb *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.25 );\t   \n}\n","name":"","description":"","type":"image"}]}}