{"Shader":{"ver":"0.1","info":{"id":"MdlXD4","date":"1401919207","viewed":3126,"name":"Waterfalls","username":"P_Malin","description":"Some waterfalls and a rainbow.<br\/>Made with so many hacks I don't know what is real any more.<br\/>...I still need to work on the camera.","likes":51,"published":3,"flags":8,"tags":["water","rainbow","waterfall","droplets"],"hasliked":0},"renderpass":[{"inputs":[{"id":7,"src":"\/presets\/tex06.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":10,"src":"\/presets\/tex09.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Waterfalls - @P_Malin\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Some waterfalls and a rainbow.\n\/\/ Made with so many hacks I don't know what is real any more.\n\/\/ I still need to work on the camera.\n\n\/\/ If you are lucky you can try to enable high quality...\n\/\/ If you are unlucky you may get \"Unkown error\"\n\/\/#define HIGH_QUALITY\n\n#ifdef HIGH_QUALITY\n\t#define ENABLE_SCENERY_REFLECTION\n#endif\n\n\n#define MORE_WATERFALLS\n#define ENABLE_WATERFALL\n#define ENABLE_WATER_REFLECTIONS\n\n#define ENABLE_WATERFALL_REFLECTION\n\n\/\/#define PREVIEW_MODE\n\n#ifndef PREVIEW_MODE\n\n\t#define ENABLE_ATMOSPHERE\n\t#define ENABLE_WATER_PLANE\n\t#define ENABLE_DROPLETS\n\n#endif\n\nconst float kFarClip = 1000.0;\n\nstruct S_Waterfall\n{\n\tmat3 mRot;\n\tvec3 vTrans;\n\tfloat fWidth;\n\tfloat fHeight;\n\tfloat fRadius;\n\tfloat fZMax;\n\tfloat fQuadraticA;\n\tfloat fQuadraticB;\n\tfloat fNoiseOffset;\n};\n\nvec3 vSunColour = vec3(1.0, 0.9, 0.8) * 5.0;\n\nconst vec3 vSkyBase = vec3(0.05, 0.2, 1.0);\n\nvec3 vSkyColourA = vSkyBase * 1.5;\nvec3 vSkyColourB = vSkyBase * 0.5;\n\nconst vec3 vAmbientLight = (vSkyBase + vec3(0.5));\n\n\/\/const vec3 vWaterExtinction = (vec3(1.0) - vec3(0.1, 0.6, 0.8)) * 1.0; \/\/ clear water\nconst vec3 vWaterExtinction = (vec3(1.0) - vec3(0.7, 0.6, 0.2)) * 1.5; \/\/ murky water\n\nvec3 vSunDir = normalize(vec3(-0.5, -1.5, 1.0));\n\n#ifdef MORE_WATERFALLS\nconst int kWaterfallCount=2;\n#else\nconst int kWaterfallCount=1;\n#endif \n\t\nS_Waterfall g_Waterfall[kWaterfallCount];\n\nfloat gPixelRand;\n\nfloat Checker(const in vec2 vUV)\n{\n\treturn step(fract((floor(vUV.x) + floor(vUV.y)) * 0.5), 0.25);\n}\n\nfloat hash( const in float n ) {\n\treturn fract(sin(n)*4378.5453);\n}\n\nvec2 GetWindowCoord( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x \/ iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvec3 GetCameraRayDir( const in vec2 vWindow, inout vec3 vCameraPos, const in vec3 vCameraTarget, const in float fFov )\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\t\n\t\n\tvec3 vDir = normalize(vWindow.x * vRight * fFov + vWindow.y * vUp * fFov + vForward);\n\n#ifdef ENABLE_DROPLETS\t\n\t\/\/vCameraPos = vCameraPos + vDir * dot(vDir, vForward) * 0.5; \/\/ Why does this break the sky?!\n\t\n\tconst vec3 vSplashPos = vec3(0.0, 1.0, -1.0);\n\tvec3 vSplashOffset = vCameraPos - vSplashPos;\n\tfloat fSplashAmount = 1.0 - (clamp(dot(vSplashOffset, vSplashOffset) * 0.005, 0.0, 1.0));\n\t\n\tconst float fRepeat = 25.0;\n\tfloat t = floor(vWindow.x * fRepeat);\n\tfloat r = hash(t);\n\tfloat fRadiusSeed = fract(r * 100.0);\n\tfloat radius = fRadiusSeed * fRadiusSeed * 0.02 + 0.001;\n\tfloat fYpos = r * r - clamp(mod(iGlobalTime * radius * 2.0, 1.2) - 0.2, 0.0, 1.0);\n\tradius *= fSplashAmount;\n\tvec2 vPos = vec2((t + 0.5) * (1.0 \/ fRepeat), fYpos * 2.0 - 1.0);\n\tvec2 vDelta = vWindow - vPos;\n\tconst float fInvMaxRadius = 1.0 \/ (0.02 + 0.001);\n\tvDelta.x \/= (vDelta.y * fInvMaxRadius) * -0.15 + 0.85; \/\/ big droplets tear shaped\n\tvec2 vDeltaNorm = normalize(vDelta);\n\tfloat l = length(vDelta);\n\tif(l < radius)\n\t{\t\t\n\t\tl = l \/ radius;\n\t\t\n\t\tfloat lz = sqrt(1.0 - l * l);\t\t\n\t\t\t\t\n\t\tvec3 vNormal = l * vDeltaNorm.x * vRight + l* vDeltaNorm.y * vUp - lz * vForward;\n\t\t\/\/vNormal = mix(vNormal, -vDir, (l * l * l * 0.9 + 0.1)); \/\/ flatten normal and fade out at edge\n\t\tvNormal = normalize(vNormal);\n\t\tvDir = refract(vDir, vNormal, 0.7);\n\t}\n\t\/*else\n\t{\n\t\tvDir.x += (fract(sin(gPixelRand * 123.456) * 789.0) - 0.5) * fSplashAmount * 0.025;\n\t\tvDir.y += (fract(sin(gPixelRand * 234.567) * 890.1) - 0.5) * fSplashAmount * 0.025;\n\t}*\/\n#endif \/\/ ENABLE_DROPLETS\t\n\t\n\treturn vDir;\n}\n\nvec3 ApplyVignetting( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0);\n\t\n\tfloat fDist = dot(vOffset, vOffset);\n\t\n\tconst float kStrength = 0.95;\n\tconst float kPower = 1.5;\n\n\treturn vInput * ((1.0 - kStrength) +  kStrength * pow(1.0 - fDist, kPower));\n}\n\nvec3 ApplyTonemap( const in vec3 vLinear )\n{\t\n\tconst float kWhitePoint = 4.0;\n\tfloat kWhitePointScale = 1.0 \/ (1.0 - exp2(-kWhitePoint));\t\n\treturn clamp((1.0 - exp2(-vLinear)) * kWhitePointScale, 0.0, 1.0);\t\n}\n\nvec3 ApplyGamma( const in vec3 vLinear )\n{\n\tconst float kGamma = 2.2;\n\n\treturn pow(vLinear, vec3(1.0\/kGamma));\t\n}\n\nfloat SunShadow(const in vec3 p)\n{\n\tfloat f = -p.x * 1.1 + p.y - 1.5 - p.z;\n\tfloat fSpread = 4.0 \/ (abs(p.y -10.0)* 0.5);\n\treturn f * fSpread;\n}\n\nfloat SunShadowClamped(const in vec3 p)\n{\n\treturn clamp(SunShadow(p), 0.0, 1.0);\n}\n\nfloat RainbowShadow(const in vec3 p)\n{\n\tfloat f = -p.x * 1.1 + p.y - 1.5 - p.z;\n\tfloat fSpread = 0.05;\n\treturn clamp(f * fSpread + 0.1, 0.0, 1.0);\n}\n\n\nfloat SmoothNoise( vec3 p );\nfloat SmoothNoise( float p );\n\nfloat GetRoundedBoxDistance( const in vec3 vPos, const in vec3 vMin, const in vec3 vMax, const in float fRadius )\n{\n\tvec3 vCentre = (vMin + vMax) * 0.5;\n\tvec3 vSize = abs(vMax - vMin) * 0.5;\n\treturn length(max(abs(vPos-vCentre)-vSize,0.0))-fRadius;\n\t\n\t\/\/ signed version\n\t\/\/vec3 d = abs(vPos - (vMin + vMax) * 0.5) - (vMax - vMin) * 0.5;\n\t\/\/return min(max(d.x,max(d.y,d.z)),0.0) +\n\t\/\/\tlength(max(d,0.0)) - fRadius;\t\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)\/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k)\n{\n\treturn -smin(-a, -b, k);\n}\n\nfloat GetSceneDistance( const in vec3 vPos )\n{\n\tfloat fFloorHeight = -2.0;\n\t\n\tfloat fFloorDist = vPos.y - fFloorHeight;\n\t\n\tfloat fRiverDist = GetRoundedBoxDistance( vPos, vec3(-8.0, 1.5, -kFarClip), vec3(4.0, 1.5, -0.5), 6.0);\n\t\n\tfloat fCliffDist = -GetRoundedBoxDistance( vPos, vec3(0.0, -kFarClip, -1000.0), vec3(0.0, kFarClip, -20.0 + 7.5), 20.0);\t\n\tfCliffDist = max(fCliffDist, -11.0 + vPos.y - vPos.z * 0.05);\n\t\n\tfloat fTopRiverDist = GetRoundedBoxDistance( vPos, vec3(-4.0, 12.0, -100.0), vec3(4.0, 12.0, kFarClip), 3.0);\n\n\t\/\/ match floor of top river to waterfall intensity\n\tfloat n = SmoothNoise(vPos.x + g_Waterfall[0].fNoiseOffset);\n\tfTopRiverDist += n * n * n + 1.0;\n\t\n\tfloat fResult = smax(fFloorDist, -fRiverDist, 0.75);\n\tfResult = smin(fCliffDist, fResult, 0.9);\n#ifdef MORE_WATERFALLS\n\tfloat fTopRiver2Dist = GetRoundedBoxDistance( vPos, vec3(-kFarClip, 11.0, -5.0), vec3(0.0, 100.0, -5.0), 2.0);\n\tfResult = max(fResult, -fTopRiver2Dist);\n#endif\n\tfResult -= SmoothNoise(vPos * vec3(0.5, 1.25, 0.5) + vec3(0.0, -vPos.z * 0.25, 0.0));\n \tfResult = smax(fResult, -fTopRiverDist, 0.05);\n\t\n\treturn fResult;\n}\n\nvec2 RaymarchScene( const in vec3 vRayOrigin, const in vec3 vRayDir )\n{\n\tfloat fTClosest = kFarClip;\t\n\tfloat fClosest = kFarClip;\n\n\tfloat d = 0.0;\n\tfloat fScaledD = 0.0;\n\tfloat t = 0.01;\n\t\n\tfor(int i=0; i<64; i++)\n\t{\n\t\td = GetSceneDistance(vRayOrigin + vRayDir * t);\n\t\tfScaledD = d \/ t;\n\t\tif(fScaledD < fClosest)\n\t\t{\n\t\t\tfTClosest = t;\n\t\t\tfClosest = fScaledD;\n\t\t}\n\t\tif( d < 0.01 )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tt = t + d * 0.95;\n\t\tif( t > kFarClip)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif( t > kFarClip )\n\t\treturn vec2(fTClosest, fClosest);\n\t\t\n\treturn vec2(t, 0.0);\n}\n\nvec3 GetTerrainTexture( const in vec3 vPos, const float fNormalY )\n{\n\tvec3 vSample0 = texture2D(iChannel0, vPos.xz * 0.25).rgb;\n\tvSample0 = vSample0 * vSample0;\n\tvSample0 *= vec3(0.2, 0.22, 0.05);\n\t\n\tvec2 vUV1 = vec2(atan(vPos.x, vPos.z) * 15.0, vPos.y - vPos.z * 0.25) * 0.1;\n\tvec3 vSample1 = texture2D(iChannel0, vUV1).rgb;\n\tvSample1 = vSample1 * vSample1;\n\tvSample1 *= vec3(0.6, 0.4, 0.1);\n\t\n\tfloat fBlend = clamp((fNormalY), 0.0, 1.0);\n\tvec3 vResult = mix(vSample1, vSample0, fBlend * fBlend);\n\t\n\treturn vResult;\n}\n\nvec3 GetSkyColour( const in vec3 vRayOrigin, const in vec3 vRayDir )\n{\n\tvec3 vSkyColour = mix(vSkyColourA, vSkyColourB, vRayDir.y);\n\tvec2 vCloudUV = 0.01 * vRayDir.xz \/ -vRayDir.y;\n\tvCloudUV += iGlobalTime * 0.0001;\n\tvec3 vCloud = texture2D(iChannel1, vCloudUV).rgb;\n\t\n\tfloat fBlend = vCloud.r * vCloud.r * 3.0;\n\tvSkyColour = vSkyColour * clamp(1.0 - fBlend, 0.0, 1.0) + fBlend;\n\n\treturn vSkyColour;\t\n}\n\n\/\/ return (rgb, distance)\nvec4 TraceScene( const in vec3 vRayOrigin, const in vec3 vRayDir )\n{\n\tvec2 vRaymarch = RaymarchScene( vRayOrigin, vRayDir );\n\tfloat t = vRaymarch.x;\n\n\tfloat blurRadius = 0.01;\n\n\tvec3 vPos = vRayOrigin + vRayDir * t;\n\n\tconst float fEpsilon = 0.1;\n\tfloat fSceneDist = GetSceneDistance(vPos);\n\tfloat fSceneDistSun = GetSceneDistance(vPos - vSunDir * fEpsilon);\n\tfloat fSunIntensity = clamp( (fSceneDistSun - fSceneDist) * (1.0 \/ fEpsilon), 0.0, 1.0);\n\n\tfloat fSceneDistAmbient = GetSceneDistance(vPos + vec3(0.0, 1.0, 0.0) * fEpsilon);\n\tfloat fNormalY = (fSceneDistAmbient - fSceneDist) \/ fEpsilon;\n\tfloat fAmbientIntensity = clamp( (fNormalY * 0.5 + 0.5) * (vPos.y + 3.0) * 0.15, 0.0, 1.0);\n\t\n\tvec3 vResult = GetTerrainTexture(vPos, fNormalY);\n\t\n\tvResult *= vSunColour * SunShadowClamped(vPos) * fSunIntensity + vAmbientLight * fAmbientIntensity;\n\t\n\tvec4 vReturnValue = vec4(vResult, t);\n\t\t\n\t\/\/ blur terrain over sky\n\t{\n\t\tvec3 vSkyColour = GetSkyColour( vRayOrigin, vRayDir );\n\t\t\n\t\tfloat fBlend = 1.0 - clamp(vRaymarch.y \/ blurRadius, 0.0, 1.0);\n\t\tfBlend = fBlend * fBlend;\n\t\tfBlend = 1.0 - fBlend * fBlend;\n\t\tvReturnValue = mix(vReturnValue, vec4(vSkyColour, kFarClip), fBlend);\n\t}\n\t\n\treturn vReturnValue;\n}\n\nfloat TraceWater( const in vec3 vRayOrigin, const in vec3 vRayDir )\n{\n\tif( vRayDir.y >= 0.0 )\n\t{\n\t\treturn kFarClip;\n\t}\n\t\n\tfloat fHeight = -2.5;\n\treturn -(vRayOrigin.y - fHeight) \/ vRayDir.y;\n}\n\n\nfloat Quadratic( const in float x, const in float a, const in float b )\n{\n\treturn a * x * x + b * x;\n}\n\nfloat SolveQuadratic( const in float a, const in float b, const in float c )\n{\n\treturn (-b - sqrt( b * b - 4.0 * a * c )) \/ (2.0 * a);\n}\n\n\nfloat QuadraticDiff( const in float x, const in float a, const in float b )\n{\n\treturn 2.0 * a * x + b;\n}\n\nvec2 StepQuadratic( const in vec2 vCurr, const in vec2 vPos, const in float a, const in float b )\n{\n\tfloat x = vCurr.x;\n\tfloat y = Quadratic(x, a, b);\n\tfloat dy_dx = QuadraticDiff(x, a, b);\n\t\n\tvec2 vNormal = normalize(vec2(dy_dx, -1.0));\n\tfloat d = dot(vNormal, vec2(x, y) - vCurr);\n\t\n\tvec2 newp = vCurr + vNormal * d;\n\t\n\treturn newp;\n}\n\n\nvec2 ClosestPointOnQuadratic( vec2 vPos, float a, float b)\n{\n\tvec2 vPos2 = StepQuadratic( vPos, vPos, a, b);\n\t\n\tvPos2.y = Quadratic( vPos2.x, a, b );\n\t\n\treturn vPos2;\n}\n\nvec4 GetWaterfallSprayDistance( const in S_Waterfall waterfall, vec3 vPos )\n{\t\n\tvec3 vLocalPos = (vPos - waterfall.vTrans) * waterfall.mRot;\n\t\n\tvec2 vQuadraticPos = vLocalPos.zy;\n\tvQuadraticPos.x = clamp(vQuadraticPos.x, 0.0, 1000.0);\n\n\tvec2 quadraticResult = ClosestPointOnQuadratic( vQuadraticPos, waterfall.fQuadraticA, waterfall.fQuadraticB);\n\t\n\tvec3 vClosestPos = vLocalPos;\n\tvClosestPos.y = quadraticResult.y;\n\tvClosestPos.z = quadraticResult.x;\n\t\n\tvClosestPos.x = clamp(vClosestPos.x, -waterfall.fWidth, waterfall.fWidth);\n\t\n\tvec3 vUVW = vec3(vLocalPos.x, -length(vClosestPos.yz), vLocalPos.y - vClosestPos.y);\n\t\n\tif(\tvClosestPos.y < -waterfall.fHeight)\n\t{\n\t\tvClosestPos.y = -waterfall.fHeight;\n\t\tvClosestPos.z = waterfall.fZMax;\n\t}\n\n\tfloat fDist = length(vLocalPos - vClosestPos) - waterfall.fRadius;\n\n\treturn vec4(fDist, vUVW);\n}\n\nvec4 GetSprayDistance( out S_Waterfall waterfall, const in vec3 vPos )\n{\n\tvec4 vResult = vec4(10000.0);\n\t\n\twaterfall = g_Waterfall[0];\n\t\n\tfor(int i=0; i<kWaterfallCount; i++)\n\t{\n\t\tvec4 vInt = GetWaterfallSprayDistance(g_Waterfall[i], vPos);\n\t\t\n\t\tif(vInt.x < vResult.x)\n\t\t{\n\t\t\tvResult = vInt;\n\t\t\twaterfall = g_Waterfall[i];\n\t\t}\t\t\n\t}\n\t\n\treturn vResult;\n}\n\nvec2 TraceWaterfall( out S_Waterfall waterfall, out vec3 vUVW1, out vec3 vUVW2, const in vec3 vRayOrigin, const in vec3 vRayDir )\n{\n\twaterfall = g_Waterfall[0];\n\n\tfloat t1 = 0.0;\n\tvec4 i1 = vec4(0.0);\n\n\tfor(int i=0; i<16; i++)\n\t{\n\t\tvec3 vPos = vRayOrigin + vRayDir * t1;\n\t\ti1 = GetSprayDistance(waterfall, vPos);\n\t\tif( i1.x < 0.01 )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tt1 = t1 + min(i1.x, 5.0); \/\/ min is a hacky fix for my bad quadratic distance function\n\t\tif( t1 > 1000.0)\n\t\t{\n\t\t\treturn vec2(1.0, -1.0);\n\t\t}\n\t}\n\n\t\n\tfloat kMaxWaterfallDepth = 4.0;\n\t\n\tfloat t2 = t1 + kMaxWaterfallDepth;\n\tvec4 i2;\n\t\n\tfor(int i=0; i<16; i++)\n\t{\n\t\tvec3 vPos = vRayOrigin + vRayDir * t2;\n\t\ti2 = GetWaterfallSprayDistance(waterfall, vPos);\n\t\tif( i2.x < 0.01 )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tt2 = t2 - i2.x;\n\t\tif( t2 < 0.0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tvUVW1 = i1.yzw;\n\tvUVW2 = i2.yzw;\n\t\n\treturn vec2(t1, t2);\n}\n\nfloat noise(in float o) \n{\n\tfloat p = floor(o);\n\tfloat fr = fract(o);\n\t\t\n\tfloat n = p;\n\n\tfloat a = hash(n);\n\tfloat b = hash(n+  1.0);\n\n\tfloat fr2 = fr * fr;\n\tfloat fr3 = fr2 * fr;\n\t\n\tfloat t = 3.0 * fr2 - 2.0 * fr3;\t\n\n\treturn a * (1.0 - t) + b * t;\n}\n\nfloat noise(in vec3 o) \n{\n\tvec3 p = floor(o);\n\tvec3 fr = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0 + p.z * 1009.0;\n\n\tfloat a = hash(n+  0.0);\n\tfloat b = hash(n+  1.0);\n\tfloat c = hash(n+ 57.0);\n\tfloat d = hash(n+ 58.0);\n\t\n\tfloat e = hash(n+  0.0 + 1009.0);\n\tfloat f = hash(n+  1.0 + 1009.0);\n\tfloat g = hash(n+ 57.0 + 1009.0);\n\tfloat h = hash(n+ 58.0 + 1009.0);\n\t\n\t\n\tvec3 fr2 = fr * fr;\n\tvec3 fr3 = fr2 * fr;\n\t\n\tvec3 t = 3.0 * fr2 - 2.0 * fr3;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\tfloat w = t.z;\n\n\t\/\/ this last bit should be refactored to the same form as the rest :)\n\tfloat res1 = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n\tfloat res2 = e + (f-e)*u +(g-e)*v + (e-f+h-g)*u*v;\n\t\n\tfloat res = res1 * (1.0- w) + res2 * (w);\n\t\n\treturn res;\n}\n\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat SmoothNoise( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); \/\/p = m*p*2.02;\n    \/\/f += 0.1250*noise( p );\n\t\n    return f * (1.0 \/ (0.5000 + 0.2500));\n}\n\nfloat SmoothNoise( float p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); \n\t\n    return f * (1.0 \/ (0.5000 + 0.2500 + 0.1250));\n}\n\n\nfloat GetWaterfallNoise( const vec3 vPos )\n{\n\tfloat f = SmoothNoise( vPos * vec3(16.0, 2.0, 16.0) + vec3(0.0, mod(iGlobalTime * 20.0, 1000.0), 0.0) );\n\treturn f * f;\n}\n\nvec4 ApplyWaterfall( const in vec3 vRayOrigin, const in vec3 vRayDir, const in vec4 vPrev )\n{\n\tvec4 vResult = vPrev;\n\t\/\/ intersect entry + exit, get uvw in waterfall space and pos in world space, trace through noise\n\t\n\tvec3 vParam = vec3(0.0, 0.0, 10.0);\n\tvec3 vUVW0, vUVW1;\n\t\n\tS_Waterfall waterfall;\t\n\t\n\tvec2 vIntT = TraceWaterfall( waterfall, vUVW0, vUVW1, vRayOrigin, vRayDir );\n\t\n\tif( vIntT.x >= vIntT.y )\n\t{\n\t\treturn vPrev;\n\t}\n\n\tvec3 vPos0 = vRayOrigin + vRayDir * vIntT.x;\n\tvec3 vPos1 = vRayOrigin + vRayDir * vIntT.y;\n\n\t\/\/ trace noise\t\n\tfloat fFraction = 0.0;\n\tconst int kTraceIter = 12;\t\n\tfloat fFractionDelta = 1.0 \/ float(kTraceIter);\n\t\n\tfloat fBlend = 0.5 * abs(vIntT.y - vIntT.x) \/ waterfall.fRadius;\n\t\n\tfFraction += fFractionDelta * gPixelRand; \/\/ randomize to hide shells\n\tfor(int i=0; i<kTraceIter; i++)\n\t{\n\t\tfloat tCurr = mix( vIntT.y, vIntT.x, fFraction);\n\t\tif(tCurr < vPrev.w)\n\t\t{\n\t\t\tvec3 vPosCurr = mix(vPos1, vPos0, fFraction);\n\t\t\tvec3 vUVWCurr = mix( vUVW1, vUVW0, fFraction);\n\t\t\tfloat fNoise = GetWaterfallNoise(vUVWCurr);\n\t\t\t\n\t\t\tvec2 vClosest;\n\t\t\tvClosest.x = clamp(vUVWCurr.x, -waterfall.fWidth, waterfall.fWidth);\n\t\t\tvClosest.y = 0.0;\n\n\t\t\tfloat fFade = 0.0;\n\t\t\t\n\t\t\tconst float fHack = 0.5; \/\/ a hacky fix for my bad quadratic distance function\n\t\t\tfFade += (length(vClosest - vUVWCurr.xz) \/ (waterfall.fRadius * fHack));\n\t\t\tfFade = fFade * fFade * fFade;\n\t\t\tfFade = fFade;\n\t\t\t\t\t\t\n\t\t\t\/\/ amount of spray based on x position along waterfall\n\t\t\tfloat n = SmoothNoise(vUVWCurr.x + waterfall.fNoiseOffset);\n\t\t\tfFade += n * n * n;\t\t\t\n\t\t\t\n\t\t\t\/\/fFade = 0.0;\t\t\t\n\t\t\tfNoise = clamp(fNoise - fFade, 0.0, 1.0);\n\n\t\t\tfloat fShadeFactor = clamp(vUVWCurr.z \/ waterfall.fRadius, 0.0, 1.0);\n\t\t\tfloat fShade = 0.3 + sqrt(fShadeFactor) * 0.5;\n\t\t\t\n\t\t\tfShade *= fNoise * 0.5 + 0.5;\n\t\t\t\n\t\t\tconst float kEpsilon = 0.01;\n\t\t\tfloat d1 = GetSprayDistance( waterfall, vPosCurr ).x;\n\t\t\tfloat d2 = GetSprayDistance( waterfall, vPosCurr + vSunDir * kEpsilon ).x;\n\t\t\tfloat fSunIntensity = clamp((d1 - d2) * (1.0 \/ kEpsilon) * 0.5 + 0.5, 0.0, 1.0);\n\n\t\t\tvec3 vCol =  (fSunIntensity * vSunColour * SunShadowClamped(vPosCurr) + fShade * vAmbientLight);\n\n\t\t\tvResult.xyz = mix(vResult.xyz, vCol, clamp(fNoise * fBlend, 0.0, 1.0));\n\t\t\tvResult.w = min(vResult.w, tCurr \/ (fNoise)); \/\/ hack depth to make fog work later?!\n\t\t}\n\t\t\n\t\tfFraction += fFractionDelta;\n\t}\n\t\n\treturn vResult;\n}\n\nvec3 noise_dxy(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = hash(n+  0.0);\n\tfloat b = hash(n+  1.0);\n\tfloat c = hash(n+ 57.0);\n\tfloat d = hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\tvec2 dt = 6.0 * f - 6.0 * f2;\n\t\n\tfloat u = t.x;\n\tfloat du = dt.x;\t\n\tfloat v = t.y;\n\tfloat dv = dt.y;\t\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n\t\n\tfloat dx = (b-a)*du + (a-b+d-c)*du*v;\n\tfloat dy = (c-a)*dv + (a-b+d-c)*u*dv;\n\t\n\treturn vec3(dx, dy, res);\n}\n\nvec3 fbm_dxy( vec2 p, vec2 d ) {\n\tvec3 f;\n\tp += d * 1.0;\n\tf  =      0.5000*noise_dxy( p );\n\tp = p * 2.0;\n\tp += d * 1.0;\n\tp += f.xy * 0.75;\n\tf +=      0.2500*noise_dxy( p);\n\tp = p * 2.0;\n\tp += d * 1.0;\n\tp += f.xy * 0.75;\n\tf +=      0.1250*noise_dxy( p );\t\n\treturn f * (1.0\/(0.5000 + 0.2500 + 0.1250));\n}\n\nvec3 GetSpectrum( float x, const in vec3 vBrightness, const in vec3 vPeak, const in vec3 vRange )\n{\n\tvec3 vTemp = 1.0 - abs((vPeak - x) * vRange);\n\tvTemp = clamp(vTemp, 0.0, 1.0);\n\tvec3 vTemp2 = vTemp  * vTemp;\t\n\treturn (3.0 * vTemp2 - 2.0 * vTemp * vTemp2) * vBrightness;\t\n}\n\nvec4 GetRainbowRGBA( float theta )\n{\n\tvec4 vResult = vec4(0.0);\n\n\t\/\/ red0 = 137.7 deg\n\t\/\/ violet0 = 139.6 deg\n\t\/\/ red1 = 129.5 deg\n\t\/\/ violet1 = 126.1 deg\n\t\n\tconst vec3 vPeak0 = vec3(180.0 - 137.7, 180.0 - (137.7 + 139.6)*0.5, 180.0 - 139.6);\n\tconst vec3 vRange0 = 1.0 \/ vec3(vPeak0.b - vPeak0.r);\n\tconst vec3 vBrightness0 = vec3(1.0);\n\n\tvResult.xyz += GetSpectrum(theta, vBrightness0, vPeak0, vRange0);\t\n\n\tconst vec3 vPeak1 = vec3(180.0 - 129.5, 180.0 - (129.5 + 126.1) * 0.5, 180.0 - 126.1);\n\tconst vec3 vRange1 = 1.0 \/ vec3(vPeak1.b - vPeak1.r);\n\tconst vec3 vBrightness1 = vec3(0.25);\n\t\n\tvResult.xyz += GetSpectrum(theta, vBrightness1, vPeak1, vRange1);\t\n\t\n\tfloat aFactor = max(smoothstep(vPeak0.r + 1.0, vPeak0.b - 1.0, theta), smoothstep(vPeak1.r - 1.0, vPeak1.b + 1.0, theta) * 0.2);\n\tvResult.a = 1.0 - aFactor;\t\n\t\n\treturn vResult;\n}\n\nvec4 ApplyAtmosphere( const in vec3 vRayOrigin, const in vec3 vRayDir, in vec4 vResult )\n{\n\tvec3 vCentre = vec3(0.0, -5.0, 1.0);\n\t\n\tvec3 vOffset = vCentre - vRayOrigin;\n\tfloat d = dot(vRayDir, vOffset);\n\tvec3 vClosest = vRayOrigin + vRayDir * d;\n\tfloat l = length(vClosest - vCentre);\n\t\n\t\/\/ fog\n\tvec3 cFogColour = vAmbientLight;\n\tvResult.xyz = mix(vResult.xyz, cFogColour, 1.0 - exp2(vResult.w * -0.001));\n\t\n\t\/\/ mist and rainbows\n\tfloat r = 12.0;\n\tif( l < r )\n\t{\n\t\t\n\t\tfloat hcl = sqrt(r * r - l * l);\n\t\t\n\t\tfloat t0 = d - hcl;\n\t\t\n\t\tfloat dt = vResult.w - t0;\n\t\tfloat fAmount = 0.0;\n\t\tif(dt > 0.0)\n\t\t{\n\t\t\tfloat f = (r - l)\/r;\n\t\t\tf = f * f * f;\n\t\t\tfloat fOpticalDepth = dt * f * 0.1;\n\t\t\tfloat fAmount = 1.0 - exp2(-fOpticalDepth);\n\t\t\t\n\t\t\tvec3 cMistColour = vAmbientLight * 0.7 + length(vAmbientLight) * vec3(0.3);\n\t\t\tfloat fYPos = vRayOrigin.y + vRayDir.y * vResult.w;\n\t\t\t\/\/cMistColour *= clamp((fYPos + 2.5) * 0.25, 0.0, 1.0) * 0.5 + 0.5;\n\t\t\tvResult.xyz = mix(vResult.xyz, cMistColour, fAmount);\n\t\t\t\n\t\t\tfloat fCameraShadow = RainbowShadow(vRayOrigin) * 0.75 + 0.25;\n\t\t\t\n\t\t\tfloat fRainbowAmount = clamp(fAmount * fCameraShadow * 1.0, 0.0, 1.0);\n\t\t\tfloat fRainbowDarkenAmount = clamp(fAmount * fCameraShadow * 1.5, 0.0, 1.0);\n\t\t\t\n\t\t\tfloat fDp = dot(vSunDir, vRayDir);\n\t\t\tvec4 vRainbow = GetRainbowRGBA(degrees(acos(fDp)) + 0.5);\n\t\t\tvResult.xyz *= 1.0 - vRainbow.a * fRainbowDarkenAmount;\n\t\t\tvResult.xyz += vRainbow.xyz * fRainbowAmount;\n\t\t\t\n\t\t}\n\t}\t\t\t\n\n\treturn vResult;\t\n}\n\nvec3 GetSceneColour( const in vec3 vRayOrigin,  const in vec3 vRayDir )\n{\n\tfloat fWaterT = TraceWater( vRayOrigin, vRayDir );\n\t\n\tvec4 vResult = TraceScene( vRayOrigin, vRayDir );\n\tfloat fOriginalT = vResult.w;\n\n#ifdef ENABLE_WATER_PLANE\t\n\tfloat fSplashMin = -3.0;\n\tfloat fSplashMax =  3.0;\n\tfloat fSplashZ = -0.5;\n\t\n\tif(fWaterT < vResult.w)\t\n\t{\n\t\tvec3 vWaterPos = vRayOrigin + vRayDir * fWaterT;\n\t\tvec2 vWaterUV = vWaterPos.xz;\t\t\n\t\t\n\t\tfloat fNormalStrength = 0.0;\n\t\tvec2 vDistortPos = vec2(clamp(vWaterPos.x, fSplashMin, fSplashMax), fSplashZ);\n\t\tvec2 vDelta = vWaterUV - vDistortPos;\n\t\tfloat fLen = length(vDelta);\n\t\tvec2 vNorm = normalize(vDelta);\n\t\tfLen = fLen \/ 4.0;\n\t\tif(fLen < 1.0)\n\t\t{\n\t\t\tfNormalStrength = 1.0 - fLen;\n\t\t\tfloat fBlend = fNormalStrength * fNormalStrength;\n\t\t\tfLen = mix(fLen, fLen * 3.0, fBlend);\n\t\t}\n\t\tfLen = fLen * 4.0;\t\t\n\t\tvWaterUV = vDistortPos + vNorm * fLen;\n\t\t\n\t\tvWaterUV *= 3.0;\n\t\tvec2 vWaterSpeed = vec2(0.0, iGlobalTime) * 4.0;\n\t\tvec3 vWaterFBM = fbm_dxy(vWaterUV, vWaterSpeed);\n\n\t\tvec3 vWaterNormal = vec3(0.0, 0.25 + (1.0 - fNormalStrength) * 3.0, 0.0);\n\t\tvWaterNormal.xz += vWaterFBM.yz;\t\t\n\t\tvWaterNormal = normalize(vWaterNormal);\n\t\t\t\t\n\t\t#ifdef ENABLE_WATER_REFLECTIONS\n\t\tvec3 vReflectDir = reflect(vRayDir, vWaterNormal);\n\t\t#ifdef ENABLE_SCENERY_REFLECTION\n\t\tvec4 vReflectResult = TraceScene( vWaterPos, vReflectDir );\n\t\t#else\n\t\tvec4 vReflectResult = vec4(0.1, 0.1, 0.05, kFarClip);\n\t\t#endif\n\t\t\n\t\t#ifdef ENABLE_WATERFALL_REFLECTION\n\t\tvReflectResult = ApplyWaterfall( vWaterPos, vReflectDir, vReflectResult );\n\t\t#endif \/\/ ENABLE_WATERFALL_REFLECTION\n\t\t\n\t\t\/\/ Apply water\n\t\tvec3 vHalfVec = normalize(vReflectDir + -vRayDir);\n\t\tfloat fFresnelDot = 1.0 - clamp(dot(vHalfVec, -vRayDir), 0.0, 1.0);\t\n\t\tfloat fFresnel = pow(fFresnelDot, 5.0);\n\t\tfFresnel = mix(0.02, 1.0, fFresnel);\n\t\t#endif\n\t\t\/\/ Water extinction\n\t\tvResult.xyz *= exp( (fOriginalT - fWaterT) * -vWaterExtinction);\n\t\t\n\t\t#ifdef ENABLE_WATER_REFLECTIONS\n\t\tvResult.xyz = mix(vResult.xyz, vReflectResult.xyz, fFresnel);\n\t\t#endif\n\t\t\n\t\tfloat fFoam = sqrt(1.0 - vWaterFBM.z);\n\t\tvec2 vFoamSplashClosest = vec2(clamp(vWaterPos.x, fSplashMin, fSplashMax), fSplashZ);\n\t\tfloat fFoamSplashFade = clamp(length(vFoamSplashClosest - vWaterPos.xz) * 0.2, 0.0, 1.0);\n\n\t\tfloat fWaterToSceneryDist = GetSceneDistance(vWaterPos);\n\t\tfFoam -= min(clamp(fWaterToSceneryDist * .5, 0.0, 1.0), fFoamSplashFade);\n\t\t\n\t\tfFoam *= clamp(fWaterToSceneryDist * (1.0 \/ 0.4), 0.0, 1.0); \/\/ softer edges\n\t\t\n\t\tfFoam = clamp(fFoam, 0.0, 1.0);\n\n\t\t\/\/fFoam = Checker(vWaterUV * 0.25);\n\t\t\n\t\tvec3 vFoamCol = vec3(0.5, 0.45, 0.4);\n\t\tfloat fSunIntensity = clamp( dot(vWaterNormal, -vSunDir), 0.0, 1.0);\n\t\tfloat fAmbientIntensity = clamp(fWaterToSceneryDist + 0.25, 0.0, 1.0);\n\t\tvFoamCol *= (vSunColour * SunShadowClamped(vWaterPos) * fSunIntensity + vAmbientLight * fAmbientIntensity);\n\t\t\n\t\tvResult.xyz = mix(vResult.xyz, vFoamCol, fFoam); \/\/ foam\n\t\tvResult.w = min(vResult.w, fWaterT);\n\t}\n#endif \/\/ ENABLE_WATER_PLANE\t\n\t\n#ifdef ENABLE_WATERFALL\n\tvResult = ApplyWaterfall( vRayOrigin, vRayDir, vResult );\n#endif \/\/ ENABLE_WATERFALL\n\n#ifdef ENABLE_ATMOSPHERE\t\n\tvResult = ApplyAtmosphere( vRayOrigin, vRayDir, vResult );\n#endif \/\/ ENABLE_ATMOSPHERE\n\t\n\treturn vResult.xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tgPixelRand = hash(fract(iGlobalTime) + fragCoord.x + fragCoord.y * 1009.0);\n\t\n\t\/\/ setup positions\n\tvec3 vDir = normalize(vec3(0.0, 0.0, -1.0));\n\tconst vec3 vUp = vec3(0.0, 1.0, 0.0);\t\n\tvec3 vPerp = cross(vDir, vUp);\n\t\n\tg_Waterfall[0].mRot = mat3( vPerp, vUp, vDir );\t\n\tg_Waterfall[0].vTrans = vec3(0.0, 10.5, 8.0);\t\n\tg_Waterfall[0].fWidth = 4.0;\n\tg_Waterfall[0].fHeight = 14.0;\n\tg_Waterfall[0].fRadius = 1.0;\n\tg_Waterfall[0].fQuadraticA = -0.2;\n\tg_Waterfall[0].fQuadraticB = -0.1;\n\tg_Waterfall[0].fZMax = SolveQuadratic(g_Waterfall[0].fQuadraticA, g_Waterfall[0].fQuadraticB, g_Waterfall[0].fHeight);\n\tg_Waterfall[0].fNoiseOffset = 37.6;\n\t\n#ifdef MORE_WATERFALLS\n\tfloat fAngle2 = 2.0;\n\tvec3 vDir2 = normalize(vec3(sin(fAngle2), 0.0, cos(fAngle2)));\t\n\tvec3 vPerp2 = cross(vDir2, vUp);\n\n\tg_Waterfall[1].mRot = mat3( vPerp2, vUp, vDir2 );\t\n\tg_Waterfall[1].vTrans = vec3(-18.0, 10.0, -5.0);\t\n\tg_Waterfall[1].fWidth = 0.5;\n\tg_Waterfall[1].fHeight = 15.0;\n\tg_Waterfall[1].fRadius = 0.75;\n\tg_Waterfall[1].fQuadraticA = -0.2;\n\tg_Waterfall[1].fQuadraticB = -0.1;\n\tg_Waterfall[1].fZMax = SolveQuadratic(g_Waterfall[1].fQuadraticA, g_Waterfall[1].fQuadraticB, g_Waterfall[1].fHeight);\n\tg_Waterfall[1].fNoiseOffset = 1.0;\n\n#endif\t\t\n\n\tvec2 vUV = fragCoord.xy \/ iResolution.xy;\n\t\n\tvec2 vMouse = iMouse.xy \/ iResolution.xy;\n\n\tif(iMouse.x <= 0.0)\n\t{\n\t\tvMouse = vec2(0.85, 0.3); \n\t}\n\t\n\t\/\/float fExposure = 3.0;\n\tfloat fFov = 0.5;\n\tfloat fExposure = clamp(iGlobalTime * 0.5, 0.0, 3.0);\n\tvec3 vCameraPos = vec3(vMouse.x * 30.0 - 15.0, 5.0 * (1.0 - vMouse.y), -27.0 + vMouse.y * 30.0);\n\tvec3 vCameraTarget = vec3(-2.0, 1.5, -1.0);\n\t\n\tvec3 vRayOrigin = vCameraPos;\n\tvec3 vRayDir = GetCameraRayDir( GetWindowCoord(vUV), vRayOrigin, vCameraTarget, fFov );\n\tvec3 vResult = GetSceneColour(vRayOrigin, vRayDir);\n\tvResult = ApplyVignetting( vUV, vResult );\t\n\tvResult = ApplyGamma(ApplyTonemap(vResult * fExposure));\n\t\n\tfragColor = vec4(vResult, 1.0);\n}\n","name":"","description":"","type":"image"},{"inputs":[],"outputs":[{"channel":"0"}],"code":"float Hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nfloat SmoothNoise( float t )\n{\n\tfloat noiset = t * 32.0;\n\tfloat tfloor = floor(noiset);\n\tfloat ffract = fract(noiset);\n\t\n\tfloat n0 = Hash(tfloor);\n\tfloat n1 = Hash(tfloor + 1.0);\n\tfloat blend = ffract*ffract*(3.0 - 2.0*ffract);\n\treturn mix(n0, n1, blend) * 2.0 - 1.0;\n}\n\nfloat FBM( float t, float persistence )\n{\n    float result = 0.0;\n    \n    float a = 1.0;\n    float tot = 0.0;\n    result += SmoothNoise(t) * a; tot += a; t *= 2.02; a *= persistence;\n    result += SmoothNoise(t) * a; tot += a; t *= 2.02; a *= persistence; \n    result += SmoothNoise(t) * a; tot += a; \n    tot += a; \n    return result \/ tot;\n}\n\nvec2 mainSound(float time)\n{\n    return vec2(0.25, 0.4) * FBM(fract(time * 0.25) * 400.0, 0.4)\n        + vec2(0.15, 0.025) * FBM((fract(0.435+time * 0.25)) * 450.0, 0.3);\n}\n\n\n\/\/#define IMAGE_SHADER\n\n#ifdef IMAGE_SHADER\n\nfloat Function( float x )\n{\n\treturn mainSound( iGlobalTime + x \/ (44100.0 \/ 60.0) ).x * 0.5 + 0.5;\n}\n\nfloat Plot( vec2 uv )\n{\n\tfloat y = Function(uv.x);\n\t\n\treturn abs(y - uv.y) * iResolution.y;\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\t\n\tvec3 vResult = vec3(0.0);\n\t\n\tvResult += Plot(uv);\n\t\n\tfragColor = vec4((vResult),1.0);\n}\n#endif\n","name":"","description":"","type":"sound"}]}}