{"Shader":{"ver":"0.1","info":{"id":"MljSz1","date":"1441763260","viewed":1003,"name":"pool game physics","username":"archee","description":"continuously timed physics with collisions.<br\/>mouse.y = initial Y coordinate of white ball<br\/>mouse.x = angle of shooting the white ball<br\/><br\/>No iMouse input in sound shader -> no sound","likes":17,"published":3,"flags":0,"tags":["game","collision","balls","physics","pool"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ constants are changable :)\nconst int futureTrail = 0;  \/\/ 1 shows the trail until stop\nconst float bounceRatio = 0.75; \/\/ 1.0=fully elastic collisions   (min 0.0001)\nconst float diskrad = 0.066;\nconst float initialVelocity = 2.0;\nconst float timewrap = 10.01;\nconst int showSolution = 0;  \/\/ shows the final coordinates of the green ball with each input\nconst int ballCount = 4;  \/\/ be sure to adjust the code if increased\n\n\nfloat endtime=5.0; \/\/ fake air friction  ends movements at this virtual time\n\nvec4 balldatas[ballCount+99];\nvec3 ballcolors[ballCount+99];\nvec3 color=vec3(0.0);\nvec2 uv;\nvec2 mouse;\nfloat time;    \/\/ time of displayed state\nfloat simtime; \/\/ starts from zero\n\nfloat soundout=0.0; \/\/ ignored in the image shader file\n\nvoid disk(vec2 pos,float radius,vec3 color2) \/\/ AA disk\n{\n    color = mix(color2,color,clamp((length(pos-uv)-radius)*iResolution.y+0.5,0.0,1.0)); \n}\n\n\nint pass; \/\/ pass = 0   find earliest collision    pass = 1 update velocities at a the time of collision\nfloat  earliest;  \/\/ store the earliest collision time\n\n#define timeoffset(i,t) balldatas[i].xy-=balldatas[i].zw*t\n\nvoid ballvsball_func_unused() \/\/ needs to be #defined\n{\n    const int i=0;\n    const int j=1;\n    \n    vec2 startpt = balldatas[j].xy-balldatas[i].xy;\n    vec2 dir = balldatas[j].zw-balldatas[i].zw;\n    float f;\n    if ( (f=abs(dot(dir.yx*vec2(1.0,-1.0),startpt)))<2.0*diskrad*length(dir)) \/\/ hit or missed\n    {\n    \tfloat t = (-sqrt(  pow(2.0*diskrad*length(dir),2.0)-f*f)-dot(startpt,dir))\/dot(dir,dir);\n        \n        if (t>simtime)\n        {\n            if (pass==0)\n            {\n                earliest = min(earliest,t);\n            }\n            else\n            {\n                if (earliest==t)\n                {\n                    balldatas[i].xy+=balldatas[i].zw*t;\n                    balldatas[j].xy+=balldatas[j].zw*t;\n                    \n                    vec2 bouncenormal = (balldatas[i].xy-balldatas[j].xy)\/diskrad\/2.0;\n                    vec2 ch = bouncenormal*dot(bouncenormal,(balldatas[i].zw-balldatas[j].zw))*(1.0+bounceRatio)\/2.0;\n                    balldatas[i].zw-=ch;\n                    balldatas[j].zw+=ch;\n                    timeoffset(i,t);\n                    timeoffset(j,t);\n                    \n                }\n            }\n\/\/            disk(balldatas[i].xy+balldatas[i].zw*t,diskrad,ballcolors[i]*0.5);\n        }\n        \n    }\n}\n\n#define ballvsball(i,j)   { vec2 startpt = balldatas[j].xy-balldatas[i].xy;    vec2 dir = balldatas[j].zw-balldatas[i].zw;    float f;    if ( (f=abs(dot(dir.yx*vec2(1.0,-1.0),startpt)))<2.0*diskrad*length(dir))   {    \tfloat t = (-sqrt(  pow(2.0*diskrad*length(dir),2.0)-f*f)-dot(startpt,dir))\/dot(dir,dir);                if (t>simtime)        {            if (pass==0)            {                earliest = min(earliest,t);            }            else            {                if (earliest==t)                {                    balldatas[i].xy+=balldatas[i].zw*t;                    balldatas[j].xy+=balldatas[j].zw*t;                                        vec2 bouncenormal = (balldatas[i].xy-balldatas[j].xy)\/diskrad\/2.0;                    vec2 ch = bouncenormal*dot(bouncenormal,(balldatas[i].zw-balldatas[j].zw))*(1.0+bounceRatio)\/2.0;                    balldatas[i].zw-=ch;                    balldatas[j].zw+=ch;                    timeoffset(i,t);                    timeoffset(j,t);                                    }            }        }            }}\n\n\nvoid render()\n{\n    \/\/ render balls\n    for(int i=0;i<ballCount;i++)\n    {\n        disk(balldatas[i].xy+balldatas[i].zw*time,diskrad,ballcolors[i]);\n    }\n}\n\nvoid renderline(vec2 a,vec2 b,vec3 color2) \/\/ anti aliased line\n{\n    if (  dot(uv,b-a)>dot(a,b-a) && dot(uv,b-a)<dot(b,b-a))\n    {\n        if (length(color)<0.2) \n        {\n            float f= clamp((0.006-abs(dot(uv-a,(b-a).yx*vec2(1.0,-1.0)))\/length(b-a))*iResolution.y,0.0,1.0);\n            color = color2*f;\n        }\n    }\n}\n\n#define pos(i,t) (balldatas[i].xy+balldatas[i].zw*t)\n\n#define ballpath(i) renderline(pos(i,simtime),pos(i,earliest),ballcolors[i]*0.5)\n\nvoid pathrender()\n{\n    ballpath(0);\n    ballpath(1);\n    ballpath(2);\n    if (ballCount>3) ballpath(3);\n    \n}\n\nconst float wallx = 8.0\/9.0-diskrad;\nconst float wally = 0.5-diskrad;\n\n#define updatevel(i,v,t){ balldatas[i].xy+=(balldatas[i].zw-(v))*t;balldatas[i].zw=(v);}\n\nvoid ballwall_func_unused() \/\/ needs to be #defined\n{\n    const int i=0;\n\n    float t;\n    \n    t = (((balldatas[i].z>0.0) ? wallx : -wallx) -   balldatas[i].x)\/balldatas[i].z;\n    if (pass==0)\n    {\n        earliest = min(earliest,t);\n    }\n    else\n    {\n        if (earliest==t)\n        {\n            updatevel(i,balldatas[i].zw*vec2(-1.,1.)*bounceRatio,t);\n        }\n    }\n    t = (((balldatas[i].w>0.0) ? wally : -wally) -   balldatas[i].y)\/balldatas[i].w;\n    if (pass==0)\n    {\n        earliest = min(earliest,t);\n    }\n    else\n    {\n        if (earliest==t)\n        {\n            updatevel(i,balldatas[i].zw*vec2(1.,-1.)*bounceRatio,t);\n        }\n    }\n}\n\n#define ballwall(i) {    float t;    t = (((balldatas[i].z>0.0) ? wallx : -wallx) -   balldatas[i].x)\/balldatas[i].z;    if (pass==0)    {        earliest = min(earliest,t);    }    else    {        if (earliest==t)        {            updatevel(i,balldatas[i].zw*vec2(-1.,1.)*bounceRatio,t);        }    }    t = (((balldatas[i].w>0.0) ? wally : -wally) -   balldatas[i].y)\/balldatas[i].w;    if (pass==0)    {        earliest = min(earliest,t);    }    else    {        if (earliest==t)        {            updatevel(i,balldatas[i].zw*vec2(1.,-1.)*bounceRatio,t);        }    }     }\n\n\nvoid docollisions()\n{\n    ballwall(0);\n    ballwall(1);\n    ballvsball(0,1);\n    if (ballCount>2)\n    {\n    \tballwall(2);\n    \tballvsball(0,2);\n    \tballvsball(1,2);\n        if (ballCount>3)\n        {\n    \t\tballwall(3);\n            ballvsball(0,3);\n            ballvsball(1,3);\n            ballvsball(2,3);\n        }\n    }\n}\n \n\nvoid rundemo(float timein) \n{\n    float startdata = floor(timein\/timewrap);\n    timein = mod(timein,timewrap);\n    timein = max(timein-1.0,0.0); \/\/ wait before shooting\n    \n    ballcolors[0] = vec3(0.9);\n    ballcolors[1] = vec3(0.9,0.0,0.0);\n    ballcolors[2] = vec3(0.8,0.5,0.0);\n    ballcolors[3] = vec3(0.1,0.6,0.0);\n    ballcolors[4] = vec3(0.0,0.6,0.9);\n    \n    float mininum=1e-20;\n    balldatas[0] = vec4(-0.7,0.0+startdata*0.01,initialVelocity,mininum);\n    balldatas[1] = vec4(-0.1,-0.08,mininum,mininum);\n    balldatas[2] = vec4(-0.0,0.1,mininum,mininum);\n    balldatas[3] = vec4(0.4,0.1,mininum,mininum);\n    \n    if (mouse.x!=0.0)\n    {\n        balldatas[0].y = mouse.y;\n        balldatas[0].zw = normalize(vec2(1.0,mouse.x*2.0))*initialVelocity;\n    }\n    \n    \n    if (timein<0.1)\n    {\n        renderline(balldatas[0].xy,balldatas[0].xy+balldatas[0].zw*0.25,ballcolors[0]);\n    }\n        \n    time = endtime*(1.0-exp(-timein\/endtime)); \/\/ apply air friction to all balls (no roll friction)\n    \n    if (futureTrail==0)\n    {\n        endtime = min(endtime,time);\n    }\n    \n    simtime = 0.0;\n    \n    for(int i=0;i<100;i++)\n    {\n        earliest = endtime;\n        pass = 0;\n        docollisions();\n        pathrender();\n        if (earliest>=endtime) break;\n        if (simtime<=time && earliest>time) render();\n        pass = 1;\n        docollisions();\n        simtime = earliest;\n    }\n    earliest=endtime;\n    pathrender();\n    if (simtime<=time) render();\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tuv = fragCoord.xy \/ iResolution.xy;\n    uv.x -= 0.5;\n    uv.y -= 0.5;\n    uv.x*=16.0\/9.0;\n    mouse = iMouse.xy \/ iResolution.xy;\n    if (length(mouse)>0.0)\n    {\n    \tmouse.xy -= vec2(0.5,0.5);\n    \tmouse.x*=16.0\/9.0;\n    }\n \n    if (showSolution!=0)\n    {\n        mouse = uv;\n    }\n  \n   \n   color = vec3(0.0);\n   rundemo(iGlobalTime);\n    \n    \n\tfragColor = vec4(color,1.0);\n    if (showSolution!=0)\n    {\n\/\/        fragColor = vec4( length(pos(3,endtime).xy-vec2(-wallx,-wally))<0.1?1.0:0.0, 0.0,0.0,0.0);\n        fragColor = vec4( pos(3,endtime).xy,0.0,0.0);        \n    }\n    \n}","name":"","description":"","type":"image"}]}}