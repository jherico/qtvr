{"Shader":{"ver":"0.1","info":{"id":"XdX3zN","date":"1363629015","viewed":1059,"name":"Flying Logo","username":"Dave_Hoskins","description":"A quick look at a LengthN function for flatter sides and rounded corners using distance fields.<br\/>And a test of the new cube-map stuff.<br\/>It floats around then smacks you in the face! <img src=\"\/img\/emoticonHappy.png\"\/>","likes":11,"published":3,"flags":0,"tags":["raytracing","cubemap","lengthn"],"hasliked":0},"renderpass":[{"inputs":[{"id":24,"src":"\/presets\/cube02_0.jpg","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"vec3 lightDir = normalize(vec3(1.0, 1.0, -1.0));\nfloat time = iGlobalTime - 6.96;\n\n\/\/--------------------------------------------------------------------------------------\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    float res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n\n    return res;\n}\n\n\/\/--------------------------------------------------------------------------------------\nvec3 rotateY(vec3 v, float x)\n{\n    return vec3(\n        cos(x)*v.x - sin(x)*v.z,\n        v.y,\n        sin(x)*v.x + cos(x)*v.z\n    );\n}\n\nvec3 rotateX(vec3 v, float x)\n{\n    return vec3(\n        v.x,\n        v.y*cos(x) - v.z*sin(x),\n        v.y*sin(x) + v.z*cos(x)\n    );\n}\n\nvec3 rotateZ(vec3 v, float x)\n{\n    return vec3(\n        v.x*cos(x) - v.y*sin(x),\n        v.x*sin(x) + v.y*cos(x),\n        v.z\n    );\n}\n\n\/\/--------------------------------------------------------------------------------------\n\/\/ LenghtN. Normal 'length' function uses N = 2.0;\nfloat lengthN(vec3 p, float N)\n{\n\tfloat l = pow(abs(p.x), N) + pow(abs(p.y), N) + pow(abs(p.y), N);\n\treturn pow(l, 1.0\/N);\n}\n\nfloat lengthN(vec2 p, float N)\n{\n\tfloat l = pow(abs(p.x), N) + pow(abs(p.y), N);\n\treturn pow(l, 1.0\/N);\n}\n\n\/\/--------------------------------------------------------------------------------------\nfloat Scene(vec3 p)\n{\n\tp = rotateY(rotateZ(p, time*.5341), time);\n \tvec2 q = vec2(lengthN(p.xy, 1.3+sin(time*1.234)*.7),p.z);\n \treturn lengthN(q-6.3, 12.95)+2.4*sin(time*1.321)-2.4;\n}\n\n\/\/--------------------------------------------------------------------------------------\nbool RayMarch(vec3 org, vec3 dir, out vec3 p)\n{\n\tp=org;\n\tbool hit = false;\n\tfloat dist = .0;\n\t\/\/ 'Break'less ray march...\n\tfor(int i = 0; i < 120; i++)\n\t{\n\t\tif (!hit && dist < 25.0)\n\t\t{\n\t\t\tp = org + dir*dist;\n\t\t\tfloat d = Scene(p);\n\t\t\tif (d < 0.05)\n\t\t\t{\n\t\t\t\thit = true;\n\t\t\t}\n\t\t\tdist += d*.5;\n\t\t}\n\t}\n\treturn hit;\n}\n\n\/\/--------------------------------------------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tvec3 eps = vec3(0.01,0.0,0.0);\n\treturn normalize(vec3(\n\t\tScene(p+eps.xyy)-Scene(p-eps.xyy),\n\t\tScene(p+eps.yxy)-Scene(p-eps.yxy),\n\t\tScene(p+eps.yyx)-Scene(p-eps.yyx)\n\t\t));\n}\n\n\/\/--------------------------------------------------------------------------------------\nvec3 Background(vec3 rd)\n{\n\treturn  mix(vec3(0.35, 0.5, .6), vec3(0.6, 0.8, 1.0), rd.y*2.0);\n}\n\n\/\/--------------------------------------------------------------------------------------\nvec3 GetColor(vec3 p, vec3 n, vec3 org, vec3 dir)\n{\n\tfloat lum = clamp(dot(n, lightDir), 0.0, 1.0);\n\tvec3 colour = vec3(1.0, .6, 0.0) * lum;\n\t\/\/n = dir -2.0*(dot(dir, n))*n;\n\tn = reflect(dir, n);\n\tcolour += textureCube(iChannel0, n).xyz;\n\treturn colour;\t\n}\n\n\/\/--------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 v = -1.0 + 2.0 * fragCoord.xy \/ iResolution.xy;\n\tv.x *= iResolution.x\/iResolution.y;\n\t\n\tvec3 org = vec3(0.0,0.0,-15.0);\n\tvec3 dir = normalize(vec3(v.x,v.y,1.0));\n\tvec3 colour;\n\tvec3 p;\n\t\n\tbool hit = RayMarch(org,dir,p);\n\tif (hit)\n\t{\n\t\tvec3 nor = GetNormal(p);\n\t\tnor += (noise(vec2(p.x*4.0, p.y*4.0))-.5) * .15;\n\t\tnor += (noise(vec2(p.x*9.0, p.y*9.0))-.5) * .08;\n\t\tnor = normalize(nor);\n\t\tcolour = GetColor(p,nor,org,dir);\n\t}else\n\t{\n\t\tcolour = Background(dir);\n\t}\n\t\t\t\n\tfragColor = vec4(colour, 1.0);\n}\n\/\/--------------------------------------------------------------------------------------\n","name":"","description":"","type":"image"}]}}