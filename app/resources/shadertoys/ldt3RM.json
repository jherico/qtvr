{"Shader":{"ver":"0.1","info":{"id":"ldt3RM","date":"1448710214","viewed":284,"name":"11_patterns","username":"yiwenl","description":"Pattern x gradients","likes":1,"published":3,"flags":0,"tags":["raymarch"],"hasliked":0},"renderpass":[{"inputs":[{"id":22,"src":"\/presets\/cube00_0.jpg","ctype":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"id":23,"src":"\/presets\/cube01_0.png","ctype":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"const int NUM_ITER = 140;\nconst float maxDist  = 4.0;\n\nfloat time = iGlobalTime * 2.0;\nconst float PI      = 3.141592657;\n\nconst vec3 grdColor0 = vec3(0.16, 0.537, 0.8);\nconst vec3 grdColor1 = vec3(1.0, 1.0, 1.0);\nconst vec3 grdColor2 = vec3(0.564, 0.415, 0.0);\nconst vec3 grdColor3 = vec3(0.851, 0.623, 0.0);\nconst vec3 grdColor4 = vec3(1.0, 1.0, 1.0);\n\n\nvec3 getGradient(float x) {\n    float p = 0.0;\n    if(x < 0.5) {\n        p = x\/0.5;\n        return mix(grdColor0, grdColor1, p);\n    } else if(x < 0.52) {\n        p = (x-0.5)\/0.02;\n        return mix(grdColor1, grdColor2, p);\n    } else if(x < 0.64) {\n        p = (x-0.52)\/0.12;\n        return mix(grdColor2, grdColor3, p);\n    } else {\n        p = (x-0.64)\/0.36;\n        return mix(grdColor3, grdColor4, p);\n    }\n    \n    return vec3(0.0);\n}\n\n\n\/\/\tTOOLS\nvec2 rotate(vec2 pos, float angle) {\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\n\treturn mat2(c, s, -s, c) * pos;\n}\n\nfloat smin( float a, float b, float k ) {\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )\/k;\n}\n\nfloat smin( float a, float b ) {\treturn smin(a, b, 7.0);\t}\n\n\/\/\tGEOMETRY\nfloat sphere(vec3 pos, float radius) {\n\treturn length(pos) - radius;\n}\n\nfloat rep(float p, float c) {\treturn mod(p, c) - 0.5*c;\t}\nvec2 rep(vec2 p, float c) {\t\treturn mod(p, c) - 0.5*c;\t}\n\nvec2 repAng(vec2 p, float n) {\n    float ang = 2.0*PI\/n;\n    float sector = floor(atan(p.x, p.y)\/ang + 0.5);\n    p = rotate(p, sector*ang);\n    return p;\n}\n\nvec3 repAngS(vec2 p, float n) {\n    float ang = 2.0*PI\/n;\n    float sector = floor(atan(p.x, p.y)\/ang + 0.5);\n    p = rotate(p, sector*ang);\n    return vec3(p.x, p.y, mod(sector, n));\n}\n\nfloat box( vec3 p, vec3 b ) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nconst float size = 3.0;\n\nvec2 map(vec3 pos) {\n\tpos.xy = rotate(pos.xy, time*.1);\n\tpos.xz = rotate(pos.xz, sin(time*.1));\n\tfloat colorIndex = 1.0;\n\tfloat volume = 0.01;\n\tfloat gap = 0.3;\n\tfloat num = 480.0;\n\n\tvec3 pBox0 = pos;\n\tpBox0.yz = repAng(pBox0.yz, num);\n\tpBox0.z = rep(pBox0.z, gap);\n\tfloat d0 = box(pBox0, vec3(size, size, volume));\n\n\tvec3 pBox1 = pos;\n\tpBox1.xy = repAng(pBox1.xy, num);\n\tpBox1.y = rep(pBox1.y, gap);\n\tfloat d1 = box(pBox1, vec3(size, volume, size));\n\n\tfloat dSphere0 = sphere(pos+vec3(sin(time*0.845613)*1.0, 0.0, 0.0), size*(.5+sin(time*.25)*.2));\n\tfloat dSphere1 = sphere(pos+vec3(0.0, cos(time*.3238)*1.0, 0.0), size*.5+cos(time*.32) * .25);\n\tfloat dSphere = smin(dSphere0, dSphere1);\n\n\tif(d0 < d1) {\n\t\tcolorIndex = 0.0;\n\t}\n\n\tfloat d = min(d0, d1);\n\td = max(dSphere, d);\n\t\n\treturn vec2(d, colorIndex);\n}\n\nvec3 computeNormal(vec3 pos) {\n\tvec2 eps = vec2(0.001, 0.0);\n\n\tvec3 normal = vec3(\n\t\tmap(pos + eps.xyy).x - map(pos - eps.xyy).x,\n\t\tmap(pos + eps.yxy).x - map(pos - eps.yxy).x,\n\t\tmap(pos + eps.yyx).x - map(pos - eps.yyx).x\n\t);\n\treturn normalize(normal);\n}\n\n\n\/\/\tLIGHTING\nconst vec3 lightPos0 = vec3(-0.6, 0.7, -0.5);\nconst vec3 lightColor0 = vec3(1.0, 1.0, .96);\nconst float lightWeight0 = 0.35;\n\nconst vec3 lightPos1 = vec3(-1.0, -0.75, -.6);\nconst vec3 lightColor1 = vec3(.96, .96, 1.0);\nconst float lightWeight1 = 0.15;\n\nfloat ao( in vec3 pos, in vec3 nor ){\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.06*float(i)\/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 envLight(vec3 normal, vec3 dir, samplerCube tex) {\n\tvec3 eye    = -dir;\n\tvec3 r      = reflect( eye, normal );\n\tvec3 color  = textureCube( tex, r ).rgb;\n\tfloat power = 10.0;\n\tcolor.r     = pow(color.r, power);\n\tcolor       = color.rrr;\n    return color;\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax ) {\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ ) {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h\/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\nfloat diffuse(vec3 normal, vec3 light) {\n\treturn max(dot(normal, light), 0.0);\n}\n\nfloat displacement(vec3 p) {\n\treturn sin(20.0*p.x+time*.232)*sin(20.0*p.y+time*.25)*sin(20.0*p.z+time*.33);\n}\n\nvec4 getColor(vec3 pos, vec3 dir, vec3 normal, float colorIndex, mat3 ca) {\n\tvec3 p = pos + vec3(sin(time*.25) * .5, cos(time*.05), .0);\n\tfloat n = displacement(pos);\n\tvec3 baseColor = vec3(0.0);\n\tvec3 env = vec3(0.0);\n\tfloat shadowOffset = 1.0;\n\tif(colorIndex < .5) {\n\t\tfloat a = atan(p.y, p.x);\n\t\tfloat r = length(p.xy);\n\t\tfloat g = sin(a*3.0+r*20.0-time + sin(time * .1) * 5.0) + cos(r*13.0-a*10.0 - time + cos(time*.25) * 2.0);\n\t\tg = r * g;\n\n\t\tg = sin(g* 5.0) * .5 + .5;\n\t\tg = mod(g - time*.1, 1.0);\n        vec3 grdColor = getGradient(g);\n\t\tbaseColor = mix(vec3(g), grdColor, .5);\n\t\tenv \t = envLight(normal, dir, iChannel1);\n\t} else {\n\t\tvec3 p = ca*pos;\n\t\tshadowOffset = 0.0;\n\t\tenv \t = envLight(normal, dir, iChannel0);\n\t\tbaseColor = vec3(1.0, 1.0, .96);\n\t}\n\n\t\n\tvec3  lig     = normalize( lightPos0 );\n\tfloat shadow  = softshadow(pos, lig, 0.02, 2.5 );\n\tshadow        = mix(shadow, 1.0, .75);\n\tfloat _ao     = ao(pos, normal);\n\treturn vec4(vec3(baseColor + env)*_ao*shadow, 1.0);\t\n\t\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    uv = -1.0 + uv * 2.0;\n    uv.x *= iResolution.x \/ iResolution.y;\n    \n    \/\/\tGRADIENT BACKGROUND\n    float g = 1.0 - clamp(length(uv)\/2.0, 0.0, 1.0);\n    g *= .25;\n    \n    \/\/\tCAMERA POSITION\/LOOK AT CENTER\n    float r = 6.0;\n    float t = 4.0+iMouse.x*.05;\n    float y = sin(time*.25) * .5 + .65;\n    vec3 pos = vec3( cos(t)*r, y, 0.5 + sin(t)*r );\n\tvec3 ta = vec3( 0.0, 0.0, 0.0 );\n    mat3 ca = setCamera( pos, ta, 0.0 );\n\tvec3 dir = ca * normalize( vec3(uv,1.5) );\n    \n\tvec4 color = vec4(vec3(g), 1.0);\n\tfloat prec = pow(.1, 7.0);\n\tfloat d;\n\tfloat colorIndex = 0.0;\n\tbool hit = false;\n\t\n\tfor(int i=0; i<NUM_ITER; i++) {\n\t\tvec2 result = map(pos);\t\t\t\t\t\t\/\/\tdistance to object\n\t\td = result.x;\n\t\tcolorIndex = result.y;\n\n\t\tif(d < prec) {\t\t\t\t\t\t\/\/ \tif get's really close, set as hit the object\n\t\t\thit = true;\n\t\t}\n\n\t\tpos += d * dir;\t\t\t\t\t\t\/\/\tmove forward by\n\t\tif(length(pos) > maxDist) break;\n\t}\n\n\n\tif(hit) {\n\t\tcolor = vec4(1.0);\n\t\tvec3 normal = computeNormal(pos);\n\t\tcolor = getColor(pos, dir, normal, colorIndex, ca);\n\t}\n    \n\tfragColor = color;\n}","name":"","description":"","type":"image"}]}}