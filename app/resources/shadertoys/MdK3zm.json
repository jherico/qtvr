{"Shader":{"ver":"0.1","info":{"id":"MdK3zm","date":"1453864727","viewed":118,"name":"Orchard Blight","username":"eiffie","description":"Buggy Trees with broken branches (3d version too). Harder than it seems. Using knighty's dragon ifs example: <a href=\"https:\/\/www.shadertoy.com\/view\/MsBXW3\" class=\"regular\" target=\"_blank\">https:\/\/www.shadertoy.com\/view\/MsBXW3<\/a>","likes":1,"published":3,"flags":0,"tags":["tree"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/#define DO_3D\n\/\/Orchard Blight by eiffie (uncomment DO_3D for more ?... fun?)\n\/\/This is based on knighty's dragon ifs branching here: https:\/\/www.shadertoy.com\/view\/MsBXW3\n\/\/I wanted to do this earlier but didn't get to it. It needs lots of corrections so if\n\/\/you see anything amiss let me know!\n\n\/\/for iterating thru the branches\n#define DEPTH 6\n#define ITER_NUM pow(2., float(DEPTH))\nfloat BR,BO; \/\/bounding radii\nfloat Findex=0.;\/\/mapping of branch indices to [0,1]\n\n\/\/for making the tree (base angles and scales which are altered per branch)\n#define angleY 0.58\n#define angleZ 0.73\n#define scale 1.5\n#define MIN_DIST 0.01\nmat2 mx=mat2(1.0,0.0,0.0,1.0);\n\nvoid ComputeBR(){\/\/a rather brutish way to calc a loose bounding radius :(\n\tBR=0.0;\/\/1.0\/(scale-1.0);\n\tfloat a=1.0;\n\tfor(int i=0;i<DEPTH;i++){\/\/the absolute worst case - a straight branch\n\t\ta\/=scale;\n\t\tBR+=a;\n\t}\n    BR=max(1.0,BR); \/\/for the trunk (parent stem that gets drawn if scale>2.0)\n\n\tBO=BR*BR;\n#ifdef DO_3D\n\tmx=mat2(cos(angleY),sin(angleY),-sin(angleY),cos(angleY));\/\/give the tree depth\n#endif\n}\nvec2 rotate(vec2 v, float angle) {return cos(angle)*v+sin(angle)*vec2(v.y,-v.x);}\nfloat rand(vec2 c){return fract(sin(dot(c,vec2(12.9898,78.233)))*43758.5453);}\nfloat rand(float c){return fract(sin(c)*43758.5453);}\nfloat Branch(vec3 p){return length(vec3(p.x,p.y-clamp(p.y,-1.0,0.0),p.z))-0.05+p.y*0.025;}\n\n\/\/the knighty bit\nfloat dragonSample(vec3 p, inout float lastDist, in float rnd1, in float rnd2){\n\tfloat q=Findex;\/\/Get the index of the current point\n\tfloat dd=1.;\/\/running scale\n\tfloat md=100.0;\/\/minimum distance to tree branchs\n\tfloat j=ITER_NUM;\n\tfloat scl=rnd1,ang=rnd2;\n\tfor(int i=0; i<DEPTH; i++){\n\t\tfloat l2=dot(p,p);\n\t\tfloat temp=BR+lastDist*dd;\/\/this is to avoid computing length (sqrt)\n\t\tif(l2>temp*temp || l2>BO || md<MIN_DIST) break;\n\t\tif(q<0.5){\n\t\t\tscl+=rnd2;\n\t\t\tang+=rnd1;\n\t\t}else{\n\t\t\t\/\/if(fract(scl*231.4563)>0.8)break;\/\/the broken branches, not working :(\n\t\t\tscl+=rnd1;\n\t\t\tang+=rnd2;\n\t\t}\n        scl=scale+scale*rand(scl)*0.5;\n        if(fract(scl*231.4563)>0.9)scl=scale*100.0;\n\t\tang=(angleZ-angleZ*rand(ang)*0.5)*(q<0.5?1.0:-1.0);\n\t\tp.xz=p.xz*mx;\n\t\tp.xy=rotate(p.xy,ang);\n\t\tp*=scl;\n\t\tdd*=scl;\n\t\tp.y-=1.0;\n\t\tmd=min(md,Branch(p)\/dd);\n\t\tq=fract(2.*q);j*=.5;\/\/move the indices\n\t}\n\tFindex += j\/ITER_NUM;\/\/update current index. it is not necessary to check the next j-1 points.\n\tlastDist=min((length(p)-BR)\/dd,lastDist);\/\/this is the distance to the bounding radius\n\treturn md; \/\/this is the distance to the fractal\n}\n\nfloat DE(in vec3 p){\n    \/\/some modding for 3d orchard\n#ifdef DO_3D\n\tvec2 c=floor(vec2(100.0)+p.xz\/(BR*2.0));\n\tp.xz=mod(p.xz,BR*2.0)-BR;\t\n#else\n\tfloat c=floor(iGlobalTime*0.5);\n#endif\n\tfloat dist=length(p)+0.5,rnd1=rand(c),rnd2=rand(1.0-rnd1);\n#ifdef DO_3D\n\tp.y+=rnd1*0.5;\n\tp.xz=rotate(p.xz,rnd2*3.14);\n#endif\n    \/\/this is the good stuff (only 13 paths are used from trunk to leaf)\n\tFindex=0.;\n\tfloat d=Branch(p);\n\tfor(int i=0; i<13; i++){\n\t\td=min(d,dragonSample(p,dist,rnd1,rnd2));\n\t\tif(Findex>=1. || d<MIN_DIST) break;\n\t}\n\n\treturn min(d,max(0.0,dist)+BR*0.15);\n}\n\n\/\/ From IQ's original 3D noise function. Ripped from Desert Canyon by Shane: https:\/\/www.shadertoy.com\/view\/Xs33Df\nfloat noise3D(in vec3 p){\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);p -= ip;p = p*p*(3. - 2.*p);\n\tvec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);return mix(h.x, h.y, p.z); \/\/ Range: [0, 1].\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tComputeBR(); \/\/compute the bounding radius of a branch and all its children\n#ifdef DO_3D\n\tvec3 ro=vec3(0.0,0.0,iGlobalTime);\n\tvec3 rd=normalize(vec3((2.0*fragCoord-iResolution.xy)\/iResolution.y-vec2(sin(iGlobalTime)*0.1,0.2+sin(iGlobalTime*0.4)*0.1),2.0));\n\tfloat t=0.0,d;\n\tfor(int i=0;i<64;i++){\n\t\tt+=d=DE(ro+rd*t);\n\t\tif(t>40.0 || d<MIN_DIST)break;\n\t}\n\tt=clamp(min(t\/40.0,(rd.y*3.0+1.0)*pow(1.0-abs(rd.y),5.0)+0.5*noise3D(40.0*rd*max(0.0,rd.y))),0.0,1.0);\n#else\n\tvec3 p=vec3(3.0*(fragCoord\/iResolution.xy-0.5),0.0);\n\tfloat t=DE(p);\n\tt=smoothstep(0.0,0.01,t);\n#endif\n\tfragColor=vec4(t);\n}\n","name":"","description":"","type":"image"}]}}