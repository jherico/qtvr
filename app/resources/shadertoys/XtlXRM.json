{"Shader":{"ver":"0.1","info":{"id":"XtlXRM","date":"1435347009","viewed":637,"name":"Standing in the Water","username":"codywatts","description":"This was my first time playing with raymarching. Somehow it turned into... this. Click and drag the mouse to move the camera.","likes":0,"published":3,"flags":0,"tags":["raymarching"],"hasliked":0},"renderpass":[{"inputs":[{"id":8,"src":"\/presets\/tex07.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define EPSILON 0.005\n#define X_AXIS vec3(1, 0, 0)\n#define Y_AXIS vec3(0, 1, 0)\n#define Z_AXIS vec3(0, 0, 1)\n\nconst int RaysPerFragment = 10;\nconst float MaxRaymarchingDistance = 400.0;\nconst float CameraHeight = 11.0;\nconst float CameraRadius = 4.0;\nconst float MinWaterHeight = 3.2;\nconst float MaxWaterHeight = 3.8;\nconst float WaveSpeed = 1.5;\nconst float WavePeriod = 0.4;\nconst float GroundTextureSize = 15.0;\nconst float WaterTransparency = 0.3;\nconst float WaterRefractionIndex = 0.3;\nconst vec3 SunColor = vec3(1.0, 1.0, 0.8);\nconst float SunSize = 0.03;\nconst vec3 SkyColor = vec3(255.0 \/ 255.0, 199.0 \/ 255.0, 99.0 \/ 255.0);\nconst vec3 HighSkyColor = vec3(0.0, 0.0, 0.8);\nconst vec3 WaterColor = vec3(0.8, 0.8, 1);\nconst float MinFadeDistance = 0.0;\nconst float MaxFadeDistance = MaxRaymarchingDistance - 50.0;\n\nstruct Material\n{\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat shininess;\n};\n\nstruct Plane\n{\n\tvec3 point;\n\tvec3 normal;\n\tMaterial material;\n};\n\nstruct Ray\n{\n\tvec3 origin;\n\tvec3 direction;\n};\n\nstruct Intersection\n{\n\tbool hit;\n\tvec3 position;\n\tvec3 normal;\n\tMaterial material;\n};\n\nstruct Camera\n{\n\tvec3 position;\n\tvec3 forward;\n\tvec3 up;\n\tvec3 right;\n};\n\nstruct Light\n{\n\tvec3 position;\n};\n\nIntersection rayPlaneIntersection(in Ray ray, in Plane plane)\n{\n\tIntersection i;\n\ti.hit = false;\n\t\n\tfloat dotProduct = dot(ray.direction, plane.normal);\n\tif (dotProduct == 0.0)\n\t{\n\t\treturn i;\n\t}\n\t\n\tfloat distanceToHit = dot(plane.point - ray.origin, plane.normal)\/dotProduct;\n\tif (distanceToHit < 0.0)\n\t{\n\t\treturn i;\n\t}\n\ti.position = ray.origin + (ray.direction * distanceToHit);\n\ti.normal = plane.normal;\n\ti.material = plane.material;\n\ti.hit = true;\n\treturn i;\n}\n\nvoid blinnPhong(in vec3 lightPosition, in vec3 cameraPosition, in vec3 objectPosition, in vec3 objectNormal, in Material material, out float diffuse, out float specular)\n{\n\tvec3 fromObjectToLight = normalize(lightPosition - objectPosition);\n\tdiffuse = clamp(dot(fromObjectToLight, objectNormal), 0.0, 1.0);\n\tvec3 fromObjectToCamera = normalize(cameraPosition - objectPosition);\n\tvec3 half_way = normalize(fromObjectToCamera + fromObjectToLight);\n\tspecular = pow(clamp(dot(half_way, objectNormal), 0.0, 1.0), material.shininess);\n}\n\nfloat waterHeight(in float x, in float z)\n{  \n    float r = distance(vec2(x, z), vec2(0, 0));\n\n    float xComponent = cos(-r * WavePeriod + iGlobalTime * WaveSpeed);\n    float zComponent = sin(-r * WavePeriod + iGlobalTime * WaveSpeed);\n    return MinWaterHeight + ((xComponent + zComponent) + 2.0) \/ 4.0 * (MaxWaterHeight - MinWaterHeight);\n}\n\nvec3 getNormal(in vec3 p)\n{\n    vec3 n = vec3(waterHeight(p.x - EPSILON, p.z) - waterHeight(p.x + EPSILON, p.z), 2.0 * EPSILON, waterHeight(p.x, p.z - EPSILON) - waterHeight(p.x, p.z + EPSILON));\n    return normalize(n);\n}\n\nIntersection castRayAgainstWater(in Ray ray)\n{\n    Intersection i;\n    i.hit = false;\n    \n    const int iterations = 20;  \n    const float minDistance = 0.001;\n\n    vec3 upperPoint = ray.origin + ray.direction * minDistance;\n    vec3 lowerPoint = ray.origin + ray.direction * MaxRaymarchingDistance;\n    if (sign(upperPoint.y - waterHeight( upperPoint.x, upperPoint.z )) == sign(lowerPoint.y - waterHeight( lowerPoint.x, lowerPoint.z )))\n    {\n        return i;\n    }\n   \n\tvec3 midPoint;\n    for (int x = 0; x < iterations; ++x)\n    {\n        float upperPointHeight = waterHeight( upperPoint.x, upperPoint.z );\n        float lowerPointHeight = waterHeight( lowerPoint.x, lowerPoint.z );\n\t\tmidPoint = (upperPoint + lowerPoint) \/ 2.0;\n\n\t\tif (distance(upperPoint, lowerPoint) <= EPSILON)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tfloat midPointHeight = waterHeight( midPoint.x, midPoint.z );\n\t\tif (abs(midPoint.y - midPointHeight) <= EPSILON)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\telse if (midPoint.y > midPointHeight)\n\t\t{\n\t\t\tupperPoint = midPoint;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlowerPoint = midPoint;\n\t\t}\n    }\n    \n    i.hit = true;\n    i.position = midPoint;\n    i.normal = getNormal(i.position);\n    i.material.shininess = 10.0;\n    i.material.diffuseColor = WaterColor;\n    i.material.specularColor = SunColor;\n    return i;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\/\/ Define our sun\n\tLight sun;\n\tsun.position = vec3(300000.0, 30000.0, 0.0);\n    \n\t\/\/ Define our ground\n    Plane ground;\n    ground.normal = Y_AXIS;\n    ground.point = vec3(0, 0, 0);\n\t\n\t\/\/ Set up our camera\n\tCamera camera;\n\tcamera.position = vec3(0.0, CameraHeight, 0.0);\n\t\n\t\/\/ This is just a little hack to make the view look nice before the user has clicked on the screen.\n\tvec2 mouseCoords = iMouse.xy \/ iResolution.xy;\n    if (mouseCoords.x <= 0.0 && mouseCoords.y <= 0.0)\n    {\n        mouseCoords = vec2(0.5, 1.0);\n    }\n\t\n\tfloat cameraRotationAmount = mouseCoords.x * (PI \/ 2.0) - (PI \/ 4.0);\n    float targetHeight = ((sin(mouseCoords.y * PI \/ 2.0) - 1.0) \/ 2.0) * CameraHeight;\n    vec3 targetPosition = camera.position + vec3(cos(cameraRotationAmount) * CameraRadius, targetHeight, sin(cameraRotationAmount) * CameraRadius);\n\tcamera.forward = normalize(targetPosition - camera.position);\n\tcamera.right = cross(Y_AXIS, camera.forward);\n\tcamera.up = cross(camera.forward, camera.right);\n\n\t\/\/ To antialias our image, we cast multiple rays per fragment and average the result.\n\tvec3 accumulatedColor = vec3(0, 0, 0);\n\tfloat accumulatedSignificance = 0.0;\n\t\n\tfor (int i = 0; i < RaysPerFragment; ++i)\n\t{\n\t\tfloat t = float(i) \/ float(RaysPerFragment);\n\t\t\n        float significance = 1.0;\n\t\t\n\t\tvec2 fragCoordOffset = vec2(cos(t * TWO_PI) * t, sin(t * TWO_PI) * t);\n\t\tvec2 uv = 2.0 * (fragCoord + fragCoordOffset) \/ iResolution.xy - 1.0;\n\t\tuv.x *= iResolution.x \/ iResolution.y;\n\t\t\n\t\tRay ray;\n\t\tray.origin = camera.position;\n\t\tray.direction = normalize(camera.forward + camera.right * uv.x + camera.up * uv.y);\n        \n\t\tIntersection waterIntersection = castRayAgainstWater(ray);\n        Intersection groundIntersection;\n        groundIntersection.hit = false;\n\n\t\tfloat angleToSun = acos(dot(normalize(sun.position - camera.position), ray.direction));\n        \n        Plane horizon;\n        horizon.point = sun.position;\n        horizon.normal = -camera.forward;\n\t\tIntersection horizonIntersection = rayPlaneIntersection(ray, horizon);      \n        \n        vec3 skyColor = mix(SkyColor, HighSkyColor, clamp(horizonIntersection.position.y \/ 500000.0 - 0.1, 0.0, 1.0));\n\t\tskyColor = mix(skyColor, SunColor, smoothstep(0.05, 0.0, angleToSun - SunSize));\n\t\t\n\t\tvec3 objectColor = skyColor;\n        \n        if (waterIntersection.hit == true)\n        {         \n            Ray refractionRay;\n            refractionRay.origin = waterIntersection.position;\n            refractionRay.direction = refract(ray.direction, waterIntersection.normal, WaterRefractionIndex);\n            groundIntersection = rayPlaneIntersection(refractionRay, ground);\n            if (groundIntersection.hit == true)\n            {\n            \tvec3 fromPointToIntersection = groundIntersection.position - ground.point;\n            \tvec2 textureCoordinates = vec2(dot(fromPointToIntersection, X_AXIS), dot(fromPointToIntersection, Z_AXIS)) * (1.0 \/ GroundTextureSize);\n                objectColor = texture2D(iChannel0, textureCoordinates).xyz;\n                objectColor *= skyColor; \/\/ This tints the ground texture to match the sun.\n            }\n\t\t\t\n\t\t\tfloat diffuse;\n\t\t\tfloat specular;\n\t\t\tblinnPhong(sun.position, camera.position, waterIntersection.position, waterIntersection.normal, waterIntersection.material, diffuse, specular);\n\n            objectColor = (waterIntersection.material.diffuseColor * diffuse) * WaterTransparency + (waterIntersection.material.specularColor * specular) + objectColor * (1.0 - WaterTransparency);\n\n\t\t\tfloat distanceFromCamera = clamp((distance(waterIntersection.position.xz, camera.position.xz) - MinFadeDistance)\/MaxFadeDistance, 0.0, 1.0);\n            objectColor = mix(objectColor, skyColor, vec3(distanceFromCamera)); \/\/ This causes the water to fade into the horizon.\n        }\n\n\t\taccumulatedColor += objectColor * significance;\n\t\taccumulatedSignificance += significance;\n\t}\n\t\n\taccumulatedColor \/= accumulatedSignificance;\n\taccumulatedColor = pow(accumulatedColor, vec3(1.0\/2.2)); \/\/ Gamma correction\n\tfragColor = vec4(accumulatedColor, 1.0);\n}","name":"","description":"","type":"image"}]}}