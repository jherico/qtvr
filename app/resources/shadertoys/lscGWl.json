{"Shader":{"ver":"0.1","info":{"id":"lscGWl","date":"1452698451","viewed":216,"name":"Verlet Drop","username":"eiffie","description":"Use the mouse to position the triangle then drop it with SPACE BAR. Keep the triangle on the screen and moving for 5 seconds and you get to keep it! WHEE! You get 3 triangles to start and then like any good game it crashes before you can finish.","likes":13,"published":3,"flags":48,"tags":["game","verlet"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Verlet Drop by eiffie (rendering pass)\n\n\/\/ Number of particles\n#define MASSES 3\n\nstruct Particle{\/\/point mass\n\tvec2 cp,pp;\/\/current and previous points\n\tfloat im; \/\/inverse mass\n} pm[MASSES];\n\n\nvec2 gameState=vec2(0.0);\/\/x=plays,y=triangles left\nvec2 timer=vec2(0.0);\/\/x=last tick,y=total\n\n\/\/----------------------------------------------------------------------------------------------\n\/\/originally from iq but messed up by me\n\nvec2 load(in int re) {\n    return texture2D(iChannel0, (0.5+vec2(re,0.0)) \/ iChannelResolution[0].xy, -100.0 ).xy;\n}\n\n\nvoid loadState(){\n\tfor(int i=0;i<MASSES;i++){\n\t\tpm[i].cp=load(i*2);\n\t\tpm[i].pp=load(i*2+1);\n\t\tpm[i].im=1.0; \/\/this isn't really used (can pin with 0.0 or set individual weights)\n\t}\n\tgameState=load(MASSES*2);\n\ttimer=load(MASSES*2+1);\n}\n\n\nfloat Pattern(in vec2 uv, in float randSeed){\/\/just a crazy pattern for clouds etc\n\tuv=vec2(uv.x+uv.y,uv.x-uv.y);\n\tfloat rnd1=sin(randSeed),rnd2=sin(randSeed+1.5);\n\treturn sin(uv.x+rnd1+sin(2.0*(uv.y+rnd2))+sin(3.0*(uv.x+uv.y*-0.7)+sin(0.5*uv.x*uv.y)));\n}\n\n\/\/from iq\nfloat Tube(vec2 pa, vec2 ba){return length(pa-ba*clamp(dot(pa,ba)\/dot(ba,ba),0.0,1.0));}\n\nfloat DE(vec2 p){\/\/terrain\n\tfloat randSeed=gameState.x;\n\tvec2 v1=abs(sin(vec2(randSeed,randSeed+1.5)));\n\tvec2 v2=abs(sin(vec2(randSeed+3.75,randSeed+2.25)));\n\tvec2 v3=vec2(v1.y,v2.x),v4=vec2(v2.y,v1.x);\n\tconst vec2 scl=vec2(1.0,0.5);\n\tv1*=scl;v2*=scl;v3*=scl;v4*=scl;\n\tfloat d1=Tube(p-v1,v2-v1);\n\tfloat d2=Tube(p-v2,v3-v2);\n\tfloat d3=Tube(p-v3,v4-v3);\n\tfloat d4=Tube(p-v4,v1.yx-v4);\n\tfloat k=-32.0+v2.y*28.0;\n\treturn log(exp(k*d1)+exp(k*d2)+exp(k*d3)+exp(k*d4))\/k-0.03;\n}\n\nfloat tri(vec2 p){return abs(max(abs(p.y)-0.05,abs(p.x)-0.025+p.y*0.5))-0.001;}\n\nfloat DE_Tri(vec2 p){\/\/triangle\n    float t=100.0;\n    for(float i=1.0;i<3.0;i+=1.0){\/\/spare triangles\n        if(gameState.y-0.5>i)t=min(t,tri(p+vec2(-0.1*i,-0.1)));\n    }\n    \n\tfloat d1=Tube(p-pm[0].cp,pm[1].cp-pm[0].cp);\n\tfloat d2=Tube(p-pm[1].cp,pm[2].cp-pm[1].cp);\n\tfloat d3=Tube(p-pm[0].cp,pm[2].cp-pm[0].cp);\n\tconst float k=-128.0;\n\treturn min(log(exp(k*d1)+exp(k*d2)+exp(k*d3))\/k,t);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tloadState();\n\tif(gameState.y<=0.0)discard;\n\tvec2 uv=fragCoord.xy\/iResolution.xy;\n\tvec3 col=mix(vec3(0.5,0.6,0.7),vec3(0.75),Pattern(4.0*uv,gameState.x)); \/\/background\n\tvec3 ter=mix(vec3(0.3,0.4,0.2),vec3(0.2),Pattern(10.0*uv.yx,gameState.x)); \/\/terrain\n\tcol=mix(ter,col,smoothstep(0.0,0.005,DE(uv))); \/\/add terrain\n\tcol=mix(vec3(1.0,0.9,0.97),col,smoothstep(0.0,1.0\/iResolution.y,DE_Tri(uv))); \/\/add triangle\n\tfragColor = vec4(col,1.0);\n}","name":"","description":"","type":"image"},{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Verlet Drop by eiffie (game logic)\n\n\/\/the verlet routines\n#define AIR_RESISTANCE 0.1\n#define SURFACE_HARDNESS 0.99\n#define STRUCTURAL_RIGIDITY 8.0\n#define GRAVITY 0.05\n\/\/ Minimum seconds before updating 0.02=50fps\n#define THROTTLE 0.02\n\/\/ A distance where stretch does not cause strain\n#define SLACK 0.0001\n\/\/ Radius of particles (the connections DO NOT interact with the surface)\n#define RADIUS 0.005\n\/\/ Number of particles\n#define MASSES 3\n\/\/ Number of Stick Constraints\n#define STICKCONSTRAINTS 3\n\nstruct Particle{\/\/point mass\n\tvec2 cp,pp;\/\/current and previous points\n\tfloat im; \/\/inverse mass\n} pm[MASSES];\n\nstruct StickConstraint{\/\/a stick constraint between two particles\n\tint v1;\t\t\t\/\/the first particle\n\tint v2;\t\t\t\/\/the second particle\n\tfloat restLength;\t\/\/the distance between the particles at rest\n}sc[STICKCONSTRAINTS];\n\nvec2 gameState=vec2(0.0);\/\/x=plays,y=triangles left\nvec2 timer=vec2(0.0);\/\/x=last tick,y=total\n\nParticle getpm(int j){\n\tfor(int i=0;i<MASSES;i++){\n\t\tif(i==j)return pm[i];\n\t}\n\treturn pm[0];\n}\nvoid putpm(int j, Particle p){\n\tfor(int i=0;i<MASSES;i++){\n\t\tif(i==j){pm[i]=p;return;}\n\t}\n}\n\nbool KeyDown(in int key){return (texture2D(iChannel1,vec2((float(key)+0.5)\/256.0, 0.25)).x>0.0);}\n\n\/\/----------------------------------------------------------------------------------------------\n\/\/originally from iq but messed up by me\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\n\nvec2 load(in int re) {\n    return texture2D(iChannel0, (0.5+vec2(re,0.0)) \/ iChannelResolution[0].xy, -100.0 ).xy;\n}\n\nvoid store( in int re, in vec2 va, inout vec4 fragColor, in vec2 fragCoord) {\n    fragColor = ( isInside(fragCoord,vec2(re,0.0)) > 0.0 ) ? vec4(va,0.,0.) : fragColor;\n}\n\nvoid loadState(){\n\tgameState=load(MASSES*2);\n\ttimer=load(MASSES*2+1);\n\tif(iFrame==0 || timer.y==0.0){\n        if(iFrame==0){gameState=vec2(iDate.w,3.0);timer=vec2(iGlobalTime,0.0);}\n\t\tpm[0].cp=iMouse.xy\/iResolution.xy;pm[0].pp=pm[0].cp;\n\t\tpm[1].cp=pm[0].cp+vec2(0.05,0.1);pm[1].pp=pm[1].cp;\n\t\tpm[2].cp=pm[0].cp+vec2(-0.05,0.1);pm[2].pp=pm[2].cp;\n\t\tpm[0].im=pm[1].im=pm[2].im=1.0;\n\t}else{\n\t\tfor(int i=0;i<MASSES;i++){\n\t\t\tpm[i].cp=load(i*2);\n\t\t\tpm[i].pp=load(i*2+1);\n\t\t\tpm[i].im=1.0; \/\/this isn't really used (can pin with 0.0 or set individual weights)\n\t\t}\n\t}\n\t\/\/setup the stick constraints which are constant\n\tsc[0].v1=0;sc[0].v2=1;sc[0].restLength=0.1;\n\tsc[1].v1=1;sc[1].v2=2;sc[1].restLength=0.1;\n\tsc[2].v1=2;sc[2].v2=0;sc[2].restLength=0.1;\n}\nvoid saveState(inout vec4 fragColor, in vec2 fragCoord){\n\tfor(int i=0;i<MASSES;i++){\n\t\tstore(i*2,pm[i].cp,fragColor,fragCoord);\n\t\tstore(i*2+1,pm[i].pp,fragColor,fragCoord);\n\t}\n\tstore(MASSES*2,gameState,fragColor,fragCoord);\n\tstore(MASSES*2+1,timer,fragColor,fragCoord);\n}\n\n\nfloat Tube(vec2 pa, vec2 ba){return length(pa-ba*clamp(dot(pa,ba)\/dot(ba,ba),0.0,1.0));}\n\nfloat DE(vec2 p){\/\/terrain\n\tfloat randSeed=gameState.x;\n\tvec2 v1=abs(sin(vec2(randSeed,randSeed+1.5)));\n\tvec2 v2=abs(sin(vec2(randSeed+3.75,randSeed+2.25)));\n\tvec2 v3=vec2(v1.y,v2.x),v4=vec2(v2.y,v1.x);\n\tconst vec2 scl=vec2(1.0,0.5);\n\tv1*=scl;v2*=scl;v3*=scl;v4*=scl;\n\tfloat d1=Tube(p-v1,v2-v1);\n\tfloat d2=Tube(p-v2,v3-v2);\n\tfloat d3=Tube(p-v3,v4-v3);\n\tfloat d4=Tube(p-v4,v1.yx-v4);\n\tfloat k=-32.0+v2.y*28.0;\n\treturn log(exp(k*d1)+exp(k*d2)+exp(k*d3)+exp(k*d4))\/k-0.03;\n}\n\nvoid Verlet(float deltaTime){\n\tfloat visc=1.0-AIR_RESISTANCE*deltaTime;\n\tfor(int i=0;i<MASSES;i++){\n\t\tpm[i].pp.y+=GRAVITY*deltaTime;\/\/add gravity to previous pos\n\t\tvec2 tmp=pm[i].cp;\n\t\tpm[i].cp+=(pm[i].cp-pm[i].pp)*visc;\n\t\tpm[i].pp=tmp;\n        \n        float d=DE(pm[i].cp);\/\/satisfy DE constraint\n\t\tif(d<RADIUS){\n\t\t\tfloat dx=DE(pm[i].cp+vec2(RADIUS,0.0));\n\t\t\tfloat dy=DE(pm[i].cp+vec2(0.0,RADIUS));\n\t\t\tvec2 N=normalize(vec2(dx-d,dy-d));\n\t\t\tvec2 vel=pm[i].cp-pm[i].pp;\/\/the velocity\n\t\t\tif(dot(N,vel)<0.0)vel=reflect(vel,N)*SURFACE_HARDNESS;\/\/if moving toward surface bounce\n\t\t\tpm[i].cp+=N*(RADIUS-d)*1.5;\n\t\t\tpm[i].pp=pm[i].cp-vel*visc;\n\t\t}\n\t}\n\tfor(int i=0;i<STICKCONSTRAINTS;i++){\/\/satisfy stick constraints\n\t\tParticle m1=getpm(sc[i].v1);\n\t\tParticle m2=getpm(sc[i].v2);\n\t\t\/\/if(m1->im+m2->im==0.0)continue;\/\/skip two pinned masses\n\t\tvec2 delta=m1.cp-m2.cp;\n\t\tfloat deltaLength=length(delta)-sc[i].restLength;\n\t\tif(abs(deltaLength)>SLACK){\n\t\t\tfloat scl=STRUCTURAL_RIGIDITY*deltaLength\/(m1.im+m2.im);\n\t\t\tm1.cp-=delta*m1.im*scl;\n\t\t\tm2.cp+=delta*m2.im*scl;\n\t\t\tputpm(sc[i].v1,m1);\n\t\t\tputpm(sc[i].v2,m2);\n\t\t}\n\t}\t\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    if(fragCoord.y>0.5 || fragCoord.x>2.0*float(MASSES)+2.0)discard;\n\tloadState();\n\tfragColor=texture2D(iChannel0, (vec2(0.25)+fragCoord) \/ iResolution.xy );\n\tfloat deltaTime=iGlobalTime-timer.x;\n\tif(deltaTime>THROTTLE){\n\t\tif(timer.y>0.0){\n\t\t\tVerlet(deltaTime);\n\t\t\ttimer.y+=deltaTime;\n\t\t\tif(timer.y>5.0){\n                gameState.x+=1.0;\/\/inc # of plays\n\t\t\t\ttimer.y=0.0; \/\/reset timer\n\t\t\t\tvec2 h=vec2(0.0);\n\t\t\t\tfor(int i=0;i<3;i++){\/\/check if off screen or not moving\n\t\t\t\t\tif(clamp(pm[i].cp,0.0,1.0)==pm[i].cp)h.x+=1.0;\n\t\t\t\t\th.y+=length(pm[i].cp-pm[i].pp);\n\t\t\t\t}\n\t\t\t\tif(h.x==0.0 || h.y<0.001){gameState.y-=1.0;}\/\/lose a triangle\n\t\t\t}\n\t\t}else{\n\t\t\tif(KeyDown(32))timer.y=deltaTime; \/\/drop\n\t\t}\n\t\ttimer.x=iGlobalTime;\n\t}\n\tsaveState(fragColor,fragCoord);\n}","name":"","description":"","type":"buffer"}]}}