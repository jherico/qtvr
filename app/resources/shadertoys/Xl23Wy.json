{"Shader":{"ver":"0.1","info":{"id":"Xl23Wy","date":"1432063291","viewed":1002,"name":"Directional Derivative","username":"iq","description":"Directional Derivatives for lighting. Much faster than gradients, see <a href=\"https:\/\/www.shadertoy.com\/view\/XslGRr\" class=\"regular\" target=\"_blank\">https:\/\/www.shadertoy.com\/view\/XslGRr<\/a> or <a href=\"https:\/\/www.shadertoy.com\/view\/Xd23zh\" class=\"regular\" target=\"_blank\">https:\/\/www.shadertoy.com\/view\/Xd23zh<\/a>. More info: <a href=\"http:\/\/iquilezles.org\/www\/articles\/derivative\/derivative.htm\" class=\"regular\" target=\"_blank\">http:\/\/iquilezles.org\/www\/articles\/derivative\/derivative.htm<\/a>","likes":6,"published":3,"flags":0,"tags":["3d","gradient","derivative"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\/\/ Usign directional derivatives for lighting is much faster than computing \n\/\/ gradients\/normals and doing lighting with it (if the number of lights is\n\/\/ less than four). Mostly useful for volumetric effects.\n\/\/\n\/\/ See \n\/\/\n\/\/  http:\/\/iquilezles.org\/www\/articles\/derivative\/derivative.htm\n\/\/\n\/\/ and also:\n\/\/\n\/\/  https:\/\/www.shadertoy.com\/view\/XslGRr\n\/\/  https:\/\/www.shadertoy.com\/view\/Xd23zh]Xd23zh\n\/\/  https:\/\/www.shadertoy.com\/view\/MsfGzM\n\/\/\n\/\/ In the left haf of the screen, directional derivatives. On the right, the\n\/\/ traditional gradient-based lighting. Move the mouse to compare.\n\n\nfloat map( vec3 p )\n{\n\tfloat d1 = p.y - 0.0;\n    float d2 = length(p-vec3(0.0,0.0,0.0)) - 1.0;\n    float d3 = length(p.xz-vec2(-3.0,0.0)) - 0.5;\n    float d4 = length(p-vec3(1.0,1.0,1.0)) - 0.3;\n    return min( min(d1,d2), min(d3,d4) );\n}\n\nfloat intersect( in vec3 ro, in vec3 rd, const float maxdist )\n{\n    float res = -1.0;\n    float t = 0.1;\n    for( int i=0; i<128; i++ )\n    {\n\t    float h = map(ro + t*rd);\n        res = t;\n        if( h<(0.0001*t) || t>maxdist ) break;\n        t += h;\n    }\n\treturn res;\n}\n\nvec3 calcNormal( in vec3 pos, in float eps )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in float doAB )\n{\n    vec3 col = vec3(0.0);\n    \n    const float maxdist = 32.0;\n    float t = intersect( ro, rd, maxdist );\n    if( t < maxdist )\n    {\n        float eps = 0.001;\n        vec3  pos = ro + t*rd;\n\n        vec3 lig = normalize( vec3(2.0,1.0,0.2) );\n        float dif = 0.0;\n\n        \/\/ directional derivative\n        if( doAB>0.0 )\n        {\n            dif = (map(pos+lig*eps) - map(pos)) \/ eps;\n        }\n        \/\/ gradient based lighting\n\t\telse\n        {\n            vec3 nor = calcNormal( pos, eps );\n            dif = dot(nor,lig);\n        }\n        dif = clamp( dif, 0.0, 1.0 );\n        \n        col = vec3(1.0,0.9,0.8)*dif + vec3(0.1,0.15,0.2);\n        \n        col *= exp( -0.1*t );\n    }\n    \n    return pow( col, vec3(0.45) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = (-iResolution.xy+2.0*fragCoord.xy)\/iResolution.y;\n    \n\tvec3  ro = vec3(0.0,1.0,7.0);\n\tvec3  ta = vec3(0.0,1.0,0.0);\n    vec3  ww = normalize( ta - ro);\n    vec3  uu = normalize( cross( vec3(0.0,1.0,0.0), ww ) );\n    vec3  vv = normalize( cross(ww,uu) );\n    vec3  rd = normalize( p.x*uu + p.y*vv + 3.0*ww );\n\n    float im = iMouse.x; if( iMouse.z<=0.001 ) im = iResolution.x\/2.0;\n    float dm = im - fragCoord.x;\n\n    vec3 col = render( ro, rd, dm );\n    \n\tcol = mix( vec3(0.0), col, smoothstep( 1.0, 2.0, abs(dm) ) );\n    \n\tfragColor = vec4( col, 1.0 );\n}\n","name":"","description":"","type":"image"}]}}