{"Shader":{"ver":"0.1","info":{"id":"4ts3zl","date":"1424365424","viewed":262,"name":"Knot Curves","username":"dr2","description":"Simple parametric knot curves.","likes":1,"published":3,"flags":0,"tags":["knots"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ \"Knot Curves\" by dr2 - 2015\n\/\/ License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n\/\/ Simple parametric knot curves.\n\n\/\/#define ALL_KNOTS  \/\/ cycle through all knots (enable this at your peril)...\n\n#ifdef ALL_KNOTS\n#define KNOT_A\n#define KNOT_B\n#define KNOT_C\n\n#else\n\n#define KNOT_A  \/\/ ...OR choose one of the knots\n\/\/#define KNOT_B\n\/\/#define KNOT_C\n#endif\n\nconst float pi = 3.14159;\n\nfloat PrFlatCylDf (vec3 p, vec3 b)\n{\n  return max (length (p.yz - vec2 (b.y *\n     clamp (p.y \/ b.y, -1., 1.), 0.)) - b.z, abs (p.x) - b.x);\n}\n\nfloat tCur, pScale, dAng, eAng, ei2Ang;\nvec3 qHit, ltDir;\nint idObj;\nconst int nAngInc = 30, nMarStep = 50;\nconst float dstFar = 40.;\nconst vec3 cSize = vec3 (0.3, 0.12, 0.05);\n\n#ifdef ALL_KNOTS\nint idKnot;\n#endif\n\n\/* separate distance function for each knot to avoid performance hit (!?) *\/\n\nmat3 EvalRMat (vec3 r, vec3 rp, vec3 rm)\n{\n  vec3 ddr, vt, vn;\n  vt = normalize (rp - rm);\n  ddr = ei2Ang * (rp + rm - 2. * r);\n  vn = normalize (ddr - vt * dot (vt, ddr));\n  return mat3 (vt, vn, cross (vt, vn));\n}\n\n#ifdef KNOT_A\n\nvec3 KtPointA (float a)  \/\/trefoil knot\n{\n  const vec3\n     gc1 = vec3 ( 41,   36,   0),\n     gs1 = vec3 (-18,   27,   45),\n     gc2 = vec3 (-83, -113,  -30),\n     gs2 = vec3 (-83,   30,  113),\n     gc3 = vec3 (-11,   11,  -11),\n     gs3 = vec3 ( 27,  -27,   27);\n  return gc1 * cos (a)      + gs1 * sin (a) +\n         gc2 * cos (2. * a) + gs2 * sin (2. * a) +\n         gc3 * cos (3. * a) + gs3 * sin (3. * a);\n}\n\nfloat ObjDfA (vec3 p)\n{\n  vec3 q, r, rp, rm;\n  float d, a;\n  d = dstFar;\n  a = 0.;\n  for (int j = 0; j < nAngInc; j ++) {\n    r = KtPointA (a);\n    rp = KtPointA (a + eAng);\n    rm = KtPointA (a - eAng);\n    q = (p - r * pScale) * EvalRMat (r, rp, rm);\n    d = min (d, PrFlatCylDf (q, cSize));\n    a += dAng;\n  }\n  if (d < dstFar) idObj = 1;\n  return d;\n}\n\nfloat ObjRayA (vec3 ro, vec3 rd)\n{\n  float d, dHit;\n  dHit = 0.;\n  for (int j = 0; j < nMarStep; j ++) {\n    d = ObjDfA (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;              \n  }\n  return dHit;\n}\n\n#endif\n\n#ifdef KNOT_B\n\nvec3 KtPointB (float a)  \/\/figure 8 knot\n{\n  const vec3\n     gc1 = vec3 (  32,   94,   16),\n     gs1 = vec3 ( -51,   41,   73),\n     gc2 = vec3 (-104,  113, -211), \n     gs2 = vec3 ( -34,    0,  -39),\n     gc3 = vec3 ( 104,  -68,  -99),\n     gs3 = vec3 ( -91, -124,  -21);\n  return gc1 * cos (a)      + gs1 * sin (a) +\n         gc2 * cos (2. * a) + gs2 * sin (2. * a) +\n         gc3 * cos (3. * a) + gs3 * sin (3. * a);\n}\n\nfloat ObjDfB (vec3 p)\n{\n  vec3 q, r, rp, rm;\n  float d, a;\n  d = dstFar;\n  a = 0.;\n  for (int j = 0; j < nAngInc; j ++) {\n    r = KtPointB (a);\n    rp = KtPointB (a + eAng);\n    rm = KtPointB (a - eAng);\n    q = (p - r * pScale) * EvalRMat (r, rp, rm);\n    d = min (d, PrFlatCylDf (q, cSize));\n    a += dAng;\n  }\n  if (d < dstFar) idObj = 2;\n  return d;\n}\n\nfloat ObjRayB (vec3 ro, vec3 rd)\n{\n  float d, dHit;\n  dHit = 0.;\n  for (int j = 0; j < nMarStep; j ++) {\n    d = ObjDfB (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;              \n  }\n  return dHit;\n}\n\n#endif\n\n#ifdef KNOT_C\n\nvec3 KtPointC (float a)  \/\/square knot\n{\n  const vec3\n     gc1 = vec3 ( -22,  11,   0),\n     gs1 = vec3 (-128,   0,   0),\n     gc3 = vec3 ( -44, -43,  70),\n     gs3 = vec3 ( -78,   0, -40),\n     gc5 = vec3 (   0,  34,   8),\n     gs5 = vec3 (   0, -39,  -9);\n  return gc1 * cos (a)      + gs1 * sin (a) +\n         gc3 * cos (3. * a) + gs3 * sin (3. * a) +\n         gc5 * cos (5. * a) + gs5 * sin (5. * a);\n}\n\nfloat ObjDfC (vec3 p)\n{\n  vec3 q, r, rp, rm;\n  float d, a;\n  d = dstFar;\n  a = 0.;\n  for (int j = 0; j < nAngInc; j ++) {\n    r = KtPointC (a);\n    rp = KtPointC (a + eAng);\n    rm = KtPointC (a - eAng);\n    q = (p - r * pScale) * EvalRMat (r, rp, rm);\n    d = min (d, PrFlatCylDf (q, cSize));\n    a += dAng;\n  }\n  if (d < dstFar) idObj = 3;\n  return d;\n}\n\nfloat ObjRayC (vec3 ro, vec3 rd)\n{\n  float d, dHit;\n  dHit = 0.;\n  for (int j = 0; j < nMarStep; j ++) {\n    d = ObjDfC (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;              \n  }\n  return dHit;\n}\n\n#endif\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n#ifdef ALL_KNOTS\n  if (idKnot == 1)\n#endif\n#ifdef KNOT_A\n     v = vec4 (ObjDfA (p + e.xxx), ObjDfA (p + e.xyy),\n\tObjDfA (p + e.yxy), ObjDfA (p + e.yyx));\n#endif\n#ifdef ALL_KNOTS\n  else if (idKnot == 2)\n#endif\n#ifdef KNOT_B\n     v = vec4 (ObjDfB (p + e.xxx), ObjDfB (p + e.xyy),\n\tObjDfB (p + e.yxy), ObjDfB (p + e.yyx));\n#endif\n#ifdef ALL_KNOTS\n  else if (idKnot == 3)\n#endif\n#ifdef KNOT_C\n     v = vec4 (ObjDfC (p + e.xxx), ObjDfC (p + e.xyy),\n\tObjDfC (p + e.yxy), ObjDfC (p + e.yyx));\n#endif\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstHit;\n  int idObjT;\n  idObj = -1;\n#ifdef ALL_KNOTS\n  if (idKnot == 1) {\n#endif\n#ifdef KNOT_A\n    pScale = 0.015;\n    dstHit = ObjRayA (ro, rd);\n#endif\n#ifdef ALL_KNOTS\n  } else if (idKnot == 2) {\n#endif\n#ifdef KNOT_B\n    pScale = 0.008;\n    dstHit = ObjRayB (ro, rd);\n#endif\n#ifdef ALL_KNOTS\n  } else if (idKnot == 3) {\n#endif\n#ifdef KNOT_C\n    pScale = 0.016;\n    dstHit = ObjRayC (ro, rd);\n#endif\n#ifdef ALL_KNOTS\n  }\n#endif\n  if (idObj < 0) dstHit = dstFar;\n  if (dstHit >= dstFar) col = vec3 (0.2, 0.25, 0.3);\n  else {\n    ro += dstHit * rd;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n#ifdef ALL_KNOTS\n    if (idKnot == 1)\n#endif\n#ifdef KNOT_A\n       col = vec3 (0.9, 0.3, 0.6);\n#endif\n#ifdef ALL_KNOTS\n    else if (idKnot == 2)\n#endif\n#ifdef KNOT_B\n       col = vec3 (0.3, 0.9, 0.6);\n#endif\n#ifdef ALL_KNOTS\n    else if (idKnot == 3)\n#endif\n#ifdef KNOT_C\n       col = vec3 (0.9, 0.6, 0.3);\n#endif\n    col = col * (0.1 + 0.7 * max (dot (vn, ltDir), 0.)) +\n       0.5 * pow (max (0., dot (ltDir, reflect (rd, vn))), 128.);\n  }\n  return sqrt (clamp (col, 0., 1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy \/ iResolution.xy - 1.;\n  uv.x *= iResolution.x \/ iResolution.y;\n  tCur = iGlobalTime;\n  mat3 vuMat;\n  float az, el, rl;\n  vec3 rd, ro, ca, sa;\n#ifdef ALL_KNOTS\n  idKnot = 1 + int (mod (floor (tCur \/ 10.), 3.));\n#endif\n  dAng = 2. * pi \/ float (nAngInc);\n  eAng = 0.1 * dAng;\n  ei2Ang = 1. \/ (eAng * eAng);\n  rl = 0.26 * tCur;\n  az = 0.15 * tCur;\n  el = 0.19 * tCur;\n  ca = cos (vec3 (el, az, rl));\n  sa = sin (vec3 (el, az, rl));\n  vuMat = mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n     mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n  ro = - vec3 (0., 0., 25.) * vuMat;\n  rd = normalize (vec3 (uv, 7.5)) * vuMat;\n  ltDir = normalize (vec3 (1., 1., -1.)) * vuMat;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n","name":"","description":"","type":"image"}]}}