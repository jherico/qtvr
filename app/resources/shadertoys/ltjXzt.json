{"Shader":{"ver":"0.1","info":{"id":"ltjXzt","date":"1446331115","viewed":688,"name":"Verlet Spider!","username":"Dave_Hoskins","description":"It uses Verlet Integration to place the 'knees' correctly.","likes":28,"published":3,"flags":0,"tags":["3d","raymarching","spider","verlet"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Verlet Spider. By David Hoskins - 2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ It uses Verlet Integration to place the 'knees' correctly.\n\n\/\/ https:\/\/www.shadertoy.com\/view\/ltjXzt\n\n#define MOD3 vec3(.1031,.11369,.13787)\n\nstruct SPID_LEGS\n{\n    vec3 point;\n    vec3 knee;\n    vec3 ankle;\n    vec3 fix;\n};\n    \nSPID_LEGS spiderLegs[8];\nfloat gTime = iGlobalTime*.7-9.;\nvec3 body = vec3(0.0);\nvec2 add = vec2(1.0, 0.0);\n\n\n\/\/----------------------------------------------------------------------------------------\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat noise11(float n)\n{\n    float f = fract(n);\n     f = f*f*(3.0-2.0*f);\n    n = floor(n);\n    return mix(hash11(n),  hash11(n+1.0), f);\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat  sphere(vec3 p, vec3 x, float s )\n{\n    return length(p-x)-s;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat  ass(vec3 p, vec3 x, float s )\n{\n    return length((p-x)* vec3(1., 1.0, .8)) - s;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat upperLeg( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r*(sin(h*2.14+.4));\n}\n\nfloat upperLegCE( vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\tfloat d =  length( pa - ba*h ) - r*(sin(h*2.14+.4));\n\tif (d< .05)\n     \treturn h;\n        else return -1.0;\n}\n\n\n\/\/----------------------------------------------------------------------------------------\nfloat lowerLeg(vec3 p,  vec3 a, vec3 b, float r1, float r2)\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r1 + r2*h;\n}\n\/\/----------------------------------------------------------------------------------------\nfloat lowerLegCE(vec3 p,  vec3 a, vec3 b, float r1, float r2)\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h ) - r1 + r2*h;\n\tif (d< .05)\n     \treturn h;\n        else return -1.0;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat smoothMin( float a, float b, float k )\n{\n    \n\tfloat h = clamp(0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.-h);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ Map the distance estimation...\nfloat mapDE(vec3 p)\n{\n    float d;\n\n    \/\/ Body...\n    d = ass(p, body+vec3(0.0, 0.1, -1.7), .9);\n    d = smoothMin(d, sphere(p, body+vec3(0.0, 0., .5 ), .65), .8);\n    \/\/ Eight legs....\n    for (int i = 0; i < 8; i++)\n    {\n        d = min(d, upperLeg(p, spiderLegs[i].fix, spiderLegs[i].knee, .18)); \n        d = min(d, upperLeg(p, spiderLegs[i].knee, spiderLegs[i].ankle, .16)); \n        d = min(d, lowerLeg(p, spiderLegs[i].ankle, spiderLegs[i].point, .09, .05)); \n    }\n    \n    \/\/ Mirror down body...\n    p.x = abs(p.x);\n    \/\/ Eyeballs...\n    d = min(d, sphere(p, body+vec3(0.2, 0.4, .93 ), .14));\n    d = min(d, sphere(p, body+vec3(0.11, 0.18, 1.1), .08));\n    \/\/ Mandible parts..\n    d = min(d, lowerLeg(p, body+vec3(0.2, 0., 1. ), body+vec3(0.07, -.4, 1.24), .12,.12));\n    return d;\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ Map the colour material...\nvec3 mapCE(vec3 p)\n{\n    \/\/ Default red...\n    vec3 mat  = vec3(.1, 0.0, 0.0);\n\n    \n    float d = ass(p, body+vec3(0.0, 0.1, -1.7), 1.);\n    if (d< .05)\n        mat  = mix(vec3(.05, 0.02, .0),mat, clamp((p.z-body.z+.7)*4.0, 0.0, 1.0));\n        \n    d = smoothMin(d, sphere(p, body+vec3(0.0, 0., .5 ), .65), .8);\n    \n        \/\/ Eight legs....\n    for (int i = 0; i < 8; i++)\n    {\n        float h = -1.0, h2 = h;\n        h = max(upperLegCE(p, spiderLegs[i].fix, spiderLegs[i].knee, .18), h); \n        \n        h = max(upperLegCE(p, spiderLegs[i].knee, spiderLegs[i].ankle, .16), h); \n        \n        h = max(lowerLegCE(p, spiderLegs[i].ankle, spiderLegs[i].point, .09, .05), h); \n        if (h  > .0)\n            mat = mix(vec3(.1, 0.0, 0.0), vec3(.008, .008, .0), fract(abs(h-.5))*2.);\n            \n    }\n    \n\n    p.x = abs(p.x);\n    \/\/ Eye balls...  \n    if (sphere(p, body+vec3(0.2, 0.40, .93 ), .14) < 0.05 || sphere(p, body+vec3(0.1, 0.18, 1.1), .09) <0.05)\n   \t\t mat  = vec3(.0, 0.00, 0.00);\n    \n    return mat;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat translucency(vec3 p, vec3 nor)\n{\n    float d = max(mapDE(p-nor*2.), 0.0);\n    return min(d*d*d, 2.);\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat binarySubdivision(in vec3 rO, in vec3 rD, vec2 t)\n{\n\t\/\/ Home in on the surface by dividing by two and split...\n    float halfwayT;\n\tfor (int n = 0; n < 2; n++)\n\t{\n\t\thalfwayT = (t.x + t.y) * .5;\n        (mapDE(rO + halfwayT*rD) < 0.05) ? t.x = halfwayT:t.y = halfwayT;\n\t}\n\treturn t.x;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat rayMarch(vec3 pos, vec3 dir)\n{\n    float d =  8., de, oldD = 0.0;\n    float res = 35.0;\n    for (int i = 0; i < 30 ; i++)\n    {\n        if (d > 35.0) break;\n        vec3 p = pos + dir * d;\n        de = mapDE(p);\n        if(de < 0.05)\n        {\n            res = d;\n            break;\n        }\n        \n        oldD = d;\n        d += de;\n    }\n    \/\/ Divide down onto the distance field..\n\tif (res < 35.0)\n        res = binarySubdivision(pos, dir, vec2(d, oldD));\n        \n    return res;\n}\n\/\/----------------------------------------------------------------------------------------\nfloat shadow( in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 0.1;\n\tfloat h;\n\t\n    for (int i = 0; i <8; i++)\n\t{\n\t\th = max(mapDE( ro + rd*t )+.03, 0.0);\n\t\tres = min(3.*h \/ t, res);\n\t\tt += h+.1;\n\t}\n    return max(res, .12);\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 normal( in vec3 pos)\n{\n\tvec2 eps = vec2(.003, 0.0);\n\tvec3 nor = vec3(\n\t    mapDE(pos+eps.xyy) - mapDE(pos-eps.xyy),\n\t    mapDE(pos+eps.yxy) - mapDE(pos-eps.yxy),\n\t    mapDE(pos+eps.yyx) - mapDE(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 cameraLookAt(in vec2 uv, in vec3 cam, in vec3 tar)\n{\n\tvec3 cw = normalize(tar-cam);\n\tvec3 cp = vec3(0.0,1.0,0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = (cross(cu,cw));\n\treturn normalize(-uv.x*cu + uv.y*cv +2.*cw );\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ Verlet integration. Only effects the second vector because there is always an anchor point.\n\/\/ ie. the foot and the hip...\nvoid verlet (in vec3 anchor, inout vec3 knee, float len)\n{\n\n\t\tvec3 delta = anchor-knee;\n\t\tfloat deltalength = length(delta);\n\t\tfloat diff = (-len \/ (deltalength + len)) + 0.5;\n\t\tdelta = delta * diff;\n    \/\/\tMove it double becuase it's there's an anchor, so I only move one.\n    \tknee += delta*2.0;\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ Started off looking at iq's 'insect', then realised it's feet weren't passing each other.\n\/\/ So this is also a larger stride, an more legs of course.\nvoid moveSpider()\n{\n    float t  = gTime+sin(noise11(gTime*.7)+gTime+4.0);\n\tbody.z = 3.*mod(t*1.2, 12.0)-2.0;\n    body.y = 1.2 + sin(noise11(gTime*.9)*6.28) *.8;\n\n    for (int i = 0; i < 8 ; i++)\n    {\n\t    float s = sign( float(i)-3.5 );\n\t\tfloat h = mod( float(7-i),4. )\/4.0;\n        \n\t\tfloat z = (body.z + h*4.+s*.66 )\/3.0;\n\t\tfloat iz = floor(z);\n\t\tfloat fz = fract(z);\n\t    float az = smoothstep(.65,  1., fz);\n        \n        spiderLegs[i].point = spiderLegs[i].fix;\n        spiderLegs[i].point.y += sin(az*3.141); \/\/ az*(1.0-az)*4.0;\/\/\n        spiderLegs[i].point.z +=  (iz*3.0 + az*3.0 -h * 4.) + (s<.0?1.5:0.);\n        spiderLegs[i].fix = spiderLegs[i].fix*vec3(.12, .4, .1) + body - vec3(.0, .34, 0.);\n        spiderLegs[i].knee  = (spiderLegs[i].point+spiderLegs[i].fix)*.5;\n\n        spiderLegs[i].knee.y+=1.3;\n      \n\n\t\t\/\/ Iterate twice for stronger constraints..\n\t    \/\/ Over exagerate the limbs size to increase the contraint effect,\n        \/\/ without the need for many iterations...\n\t\tverlet(spiderLegs[i].fix, spiderLegs[i].knee,2.);\n\t\tverlet(spiderLegs[i].point, spiderLegs[i].knee, 2.2);\n        \n\t\tspiderLegs[i].ankle = (spiderLegs[i].point + spiderLegs[i].knee)*.5;\n        spiderLegs[i].ankle.x *= 1.14;\n        \n    }\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ I moved this away from random numbers to Kali's chaotic formula...\nvec3 getFloorBoards(vec2 p)\n{\n    p *= vec2(1.5, 20.0) * .01;\/\/ ...Fiddly adjustments!\n    p.y -=.4;\n\t\/\/p = abs(.85-mod(p,vec2(.85*2.))); \/\/ tiling fold\n\t\n    for (int i=0; i < 6; i++)\n        p = abs(p * 2.27) \/ dot(p, p) - .94 ;\n    \n    float f = max(sin(dot(p,p)), 0.0);\n    return (0.6 + .4*sin( f + vec3(1.,1.8,2.) ) )* vec3(.3, .23, .15) ;\n\n}\n\n\/\/----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 outColour, in vec2 coords )\n{\n    vec2 xy = (coords.xy \/ iResolution.xy);\n\tvec2 uv = (xy-.5)*vec2( iResolution.x \/ iResolution.y, 1);\n    \n    \/\/ Set initial feet positions...\n    spiderLegs[0].fix = vec3(-1.9,0.0, 3.5);\n    spiderLegs[1].fix = vec3(-2.9,0.0, 1.4);\n    spiderLegs[2].fix = vec3(-3.0, 0.0, -.4);\n    spiderLegs[3].fix = vec3(-2.25, 0.0, -2.4);\n    \n    spiderLegs[4].fix = vec3(1.9,0.0, 3.5);\n    spiderLegs[5].fix = vec3(2.9, 0.0, 1.4);\n    spiderLegs[6].fix = vec3(3.0, 0.0, -.4);\n    spiderLegs[7].fix = vec3(2.25, 0.0, -2.4);\n    \n        \/\/ Do the animation..\n    moveSpider();\n\n\tfloat height = 10.0;\n    if (iMouse.z > 0.)  height = (iMouse.y\/ iResolution.y * 17.0)+2.0;\n  \n    vec3 pos = vec3(-10.0, height,25.0)+0.04*cos(gTime*vec3(2.4,2.5,2.1) );\n    pos = mix(vec3(0.0, 1., 20.0), pos, smoothstep(0.5, 4.0, iGlobalTime));\n    vec3 dir = cameraLookAt(uv, pos, vec3(1.0, body.y*.4, 1.0+body.z)+0.04*sin(gTime*vec3(2.7,2.4,2.4) ));\n    vec3 col = vec3(0.5), mat;\n    \n    \n    float d = rayMarch(pos, dir);\n    vec3 nor, loc;\n    float tra = 0.0;\n    if (d < 35.0)\n    {\n        \/\/ Spider...\n        loc = pos+dir*d;\n        nor = normal(loc);\n        mat = mapCE(loc);\n        tra = translucency(loc, nor);  \n    }else    \n    {\n        \/\/ Floor...\n        if (dir.y < 0.0)\n        {\n            d = (.0-pos.y) \/ dir.y;\n            nor = vec3(0.0, 1.0, 0.0);\n            loc = pos+dir*d;\n\t\t\tmat = getFloorBoards(loc.zx);\n            float f =  fract(loc.x*.14);\n            mat = mix(mat, vec3(0.0), smoothstep(0., .025,f)*smoothstep(.05, .025, f)*.75);\n        }else\n        {\n            outColour = vec4(.3, .3, .3, 1.0);\n            return;\n        }\n    }\n    vec3 sun = normalize(vec3(-18.5, 10.4, 10.)- loc);\n    float sha = shadow(loc, sun);\n\n    \n    vec3 ref = reflect(sun, nor);\n    col = (mat * (tra+max(dot(sun, nor), 0.0))+pow(max(dot(dir, ref), 0.0), 24.0)*.2) *sha;\n    col+= vec3(0.01, 0.01, .02) * max(dot(normalize(vec3(18.5, 10.4, -30.)), nor),0.0);\n    col += min(mat * abs(nor.y*.2), 1.0);\n    \n     col *= .5+.55*180.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y);\n    \/\/ Gamma and end...\n\toutColour = vec4(sqrt(col),1.0);\n}","name":"","description":"","type":"image"}]}}