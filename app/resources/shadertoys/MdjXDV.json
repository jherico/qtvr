{"Shader":{"ver":"0.1","info":{"id":"MdjXDV","date":"1416338272","viewed":831,"name":"Folding","username":"reinder","description":"I was hoping that 'folding' the input domain of the distance function would lead to some elegant math. Unfortunately, the math isn't that elegant at all, and also it isn't stable for large folding-angles (hence the 'clipping hack' at lines 90 to 99).","likes":8,"published":3,"flags":0,"tags":["distancefields","folding","paper","inputdomain"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Folding. Created by Reinder Nijhoff 2014\n\/\/ @reindernijhoff\n\/\/\n\/\/ https:\/\/www.shadertoy.com\/view\/MdjXDV\n\/\/\n\n#define MARCHSTEPS 250\n#define PAPERHEIGHT 0.002\n#define PI 3.1415926\n\nfloat time = mod( iGlobalTime + 8., 32. );\n\n\/\/----------------------------------------------------------------------\n\nvec3 RotateY( const in vec3 vPos, const in float fAngle ) {\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n   \n    vec3 vResult = vec3( c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);\n   \n    return vResult;\n}\n   \nvec3 RotateZ( const in vec3 vPos, const in float fAngle ) {\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n   \n    vec3 vResult = vec3( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y, vPos.z);\n   \n    return vResult;\n}\n\n\/\/----------------------------------------------------------------------\n\/\/ distance primitives\n\nfloat opS( float d2, float d1 ) { return max(-d1,d2); }\n\nfloat sdBox( in vec3 p, in vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\/\/----------------------------------------------------------------------\n\/\/ Map functions\n\nvec3 fold( const in vec3 p, in float offset, const in float rot, in float a, const bool left ) {    \n    a = clamp( a, -PI, PI );\n    float b = PI-a;   \n    vec3 rp = p;\n\n    if( !left ) offset = -offset;\n    \n\trp.x -= offset;\n    rp = RotateY( rp, rot );\n    \n\tfloat angle = atan( rp.y, rp.x * (left?-1.:1.) );\n     \n    if( angle < 0. ) {\n        if(  angle >  - b * 0.5 ) {\n            rp = RotateZ( rp, a * (left?-1.:1.) );\n        }\n    } else {\n        if( angle - a < b * 0.5 ) {\n\t        rp = RotateZ( rp, a * (left?-1.:1.) );\n        }\n    }\n    \n    rp = RotateY( rp, -rot );      \n    rp += vec3(offset,0.,0.);\n    \n   \n    return rp;\n}\n\nfloat timedAngle( const in float starttime, const in float totaltime, const in float angle ) {\n\tfloat i = clamp( time - starttime, 0., totaltime );\n    return 3.1415926 * angle * i \/ totaltime;\n}\n\nfloat map( in vec3 p ) {\n    \n\t\/\/ folding input domain\n    p = fold( p, 0.,    0.,  \t\t   timedAngle( 6., 2., 0.25), false );\n    p = fold( p, 0.,    0.,  \t\t   timedAngle(10., 2., 0.25), true );\n    p = fold( p, -0.25,  0., \t\t   timedAngle( 8., 2.,-0.25), false  );\n    p = fold( p, -0.25,  0., \t\t   timedAngle(12., 2.,-0.25), true  );\n    \n    if( time < 6.  ) \n    \tp = fold( p, -1.4, PI*0.25,  timedAngle( 4., 2., -0.8 ) , true );\n    if( time < 4.  ) \n\t\tp = fold( p, -1.4, -PI*0.25, timedAngle( 2., 2., -0.8 ) , false );\n    \n    \/\/ just one paper plane\n    float d = sdBox( p, vec3( 1., PAPERHEIGHT, 1.4) );\n    \n    if( time >= 6.  ) { \/\/ clip the plane hack :(\n        vec3 po = p + vec3( 1.53, 0., 2.707 ); po = RotateY( po, PI*0.25 );\n        d = opS( d, sdBox( po, vec3( 2., 1., 2. ) ) );\n    } \n    \n    if( time >= 4.  ) { \/\/ clip the plane hack :(\n        vec3 po = p + vec3( -1.53, 0., 2.707 ); po = RotateY( po, PI*0.25 );\n        d = opS( d, sdBox( po, vec3( 2., 1., 2. ) ) );\n    } \n    \n\treturn d;\n}\n\n\/\/----------------------------------------------------------------------\n\nvec3 calcNormal( in vec3 pos ) {\n    const vec2 e = vec2(1.0,-1.0)*0.0025;\n\n    vec3 n = normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t    e.yyx*map( pos + e.yyx )   + \n\t\t\t\t\t    e.yxy*map( pos + e.yxy )   + \n\t\t\t\t\t    e.xxx*map( pos + e.xxx )   );  \n    return n;\n}\n\nvec2 intersect( in vec3 ro, in vec3 rd ) {\n\tconst float maxd = 60.0;\n\tconst float precis = 0.001;\n    float d = precis*2.0;\n    float t = 0.;\n    float m = 1.;\n    \n    for( int i=0; i<MARCHSTEPS; i++ ) {\n\t    d = 0.2 * map( ro+rd*t );\n\t\tt+=d;\n        if( d<precis||t>maxd ) break;\n    \n    }\n\n    if( t>maxd ) m=-1.0;\n    return vec2( t, m );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \n    vec2 q = fragCoord.xy \/ iResolution.xy;\n\tvec2 p = -1.0 + 2.0*q;\n\tp.x *= iResolution.x \/ iResolution.y;\n        \n    if (q.y < .12 || q.y >= .88) {\n\t\tfragColor=vec4(vec4(0.0));\n\t\treturn;\n\t}\n    \n    if ( time > 16. ) { time = 32.-time; }\n    \n    \/\/-----------------------------------------------------\n    \/\/ camera\n    \/\/-----------------------------------------------------\n\n\tvec3 ro = vec3(0.,1.75 + 0.25*sin( iGlobalTime * 0.42 ), 3.);\n    ro = RotateY( ro, iGlobalTime*0.05 );\n    vec3 ta = vec3( 0. ,0., 0. );\n\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\tvec3 rd = normalize( -p.x*uu + p.y*vv + 2.2*ww );\n    \n    \n     vec3 col = vec3(0.01);\n\n    \/\/ raymarch\n    vec2 ints = intersect(ro ,rd );\n    if(  ints.y > -0.5 ) {\n        vec3 i = ro + ints.x * rd;\n        vec3 nor =  calcNormal( i );\n    \tcol = vec3(1.) * (0.1+0.9 * clamp(dot( nor, normalize(vec3(0.5, 0.8, 0.2))),0.,1.));\n\t}\n    \n    \/\/ gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\n\n    fragColor = vec4( col, 1.0 );\n}\n","name":"","description":"","type":"image"}]}}