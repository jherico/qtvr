{"Shader":{"ver":"0.1","info":{"id":"MlBGWK","date":"1432379559","viewed":676,"name":"Beware your eyes ","username":"ManuManu","description":"Just to show off to some friends what could be done with 2D shaders, with some simple code to start having things on your screen...<br\/>I'm aware that it's ugly <img src=\"\/img\/emoticonHappy.png\"\/><br\/>Made on GlSlSandbox here :<br\/>http:\/\/glslsandbox.com\/e#24464.1","likes":2,"published":3,"flags":0,"tags":["2d","ugly","spiral"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\nfloat rand( vec2 p )\n{\n\treturn fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat noise(vec2 _v, vec2 _freq)\n{\n\tfloat fl1 = rand(floor(_v * _freq));\n\tfloat fl2 = rand(floor(_v * _freq) + vec2(1.0, 0.0));\n\tfloat fl3 = rand(floor(_v * _freq) + vec2(0.0, 1.0));\n\tfloat fl4 = rand(floor(_v * _freq) + vec2(1.0, 1.0));\n\tvec2 fr = fract(_v * _freq);\n\n\t\/\/ linear interpolate\n\tfloat r1 = mix(fl1, fl2, fr.x);\n\tfloat r2 = mix(fl3, fl4, fr.x);\n\treturn mix(r1, r2, fr.y);\n}\n\nfloat perlin_noise(vec2 _pos, float _freq_start, float _amp_start, float _amp_ratio)\n{\n\tfloat freq = _freq_start;\n\tfloat amp = _amp_start;\n\tfloat pn = noise(_pos, vec2(freq, freq)) * amp;\n\tfor(int i=0; i<4; i++)\n\t{\n\t\tfreq *= 2.0;\n\t\tamp *= _amp_ratio;\n\t\tpn += (noise(_pos, vec2(freq, freq)) * 2.0 - 1.0) * amp;\n\t}\n\treturn pn;\n}\n\n\n\/*\n\/\/ disk :\nvoid main( void ) \n{\n\tvec2 uv = ( gl_FragCoord.xy \/ resolution.xy );\n\tuv -=.5;\n\tuv.x *= resolution.x\/ resolution.y;\n\n\tvec3 col = vec3( .1, .9, .1 );\n\tif ( length( uv ) < .5 ) col = vec3( .9, .1, .1 );\n\tgl_FragColor = vec4(col, 1.);\n}*\/\n\/*\n\/\/ diamonds\nvoid main( void ) \n{\n\tvec2 uv = ( gl_FragCoord.xy \/ resolution.xy );\n\tuv -=.5;\n\tuv.x *= resolution.x\/ resolution.y;\n\n\tgl_FragColor = vec4(vec3( length(sin(20.*uv + sin(time)))), 1.);\n}*\/\n\/*\nvoid main( void ) \n{\n\tvec2 uv = ( gl_FragCoord.xy \/ resolution.xy );\n\tuv -=.5;\n\tuv.x *= resolution.x\/ resolution.y;\n\n\tgl_FragColor = vec4(vec3( sin(length(40.*uv))), 1.);\n}*\/\n\/*\nvoid main( void ) \n{\n\tvec2 uv = ( gl_FragCoord.xy \/ resolution.xy );\n\tuv -=.5;\n\tuv.x *= resolution.x\/ resolution.y;\n\n\tgl_FragColor = vec4(vec3( sin(time + length(40.*uv))), 1.);\n}*\/\n\/*\nvoid main( void ) \n{\n\tvec2 uv = ( gl_FragCoord.xy \/ resolution.xy );\n\tuv -=.5;\n\tuv.x *= resolution.x\/ resolution.y;\n\n\tgl_FragColor = vec4(vec3( sin(cos(time) + length(40.*uv))), 1.);\n}\n*\/\n\/*\n\/\/ repeating quarter of circles :\nvoid main( void ) \n{\n\tvec2 uv = ( gl_FragCoord.xy \/ resolution.xy );\n\tuv -=.5;\n\tuv.x *= resolution.x\/ resolution.y;\n\n\tgl_FragColor = vec4(vec3( sin(cos(time) + length(40.*mod(3.*uv, 1.)))), 1.);\n}*\/\n\/*\n\/\/ cool error :\nvoid main( void ) \n{\n\tvec2 uv = ( gl_FragCoord.xy \/ resolution.xy );\n\tuv -=.5;\n\tuv.x *= resolution.x\/ resolution.y;\n\n\tgl_FragColor = vec4(vec3( sin(cos(time) + length(40.*mod(3.*abs(uv), 1.)))), 1.);\n}*\/\n\/\/repeating circles :\n\/*\nvoid main( void ) \n{\n\tvec2 uv = ( gl_FragCoord.xy \/ resolution.xy );\n\tuv -=.5;\n\tuv.x *= resolution.x\/ resolution.y;\n\n\tgl_FragColor = vec4(vec3( sin(cos(time) +  length(40.*(mod(3.*uv, 1.)-.5)))), 1.);\n}*\/\n\/\/ combining everything : \nfloat Mylength(vec2 pos)\n{\n\treturn max(abs(pos.x), abs(pos.y));\n}\n\/*\n\/\/ Spiral\n\/\/#define F(x) (log(x))\n\/\/#define F(x) (x <= 0.1 ? 10.*x : log(x))\n#define F(x) 0.5*x\n\/\/#define F(x) (x)\n\/\/#define F(x) pow(x,1.414213562373095)\n\/\/#define F(x) pow(x,2.0)\n\/\/#define F(x) pow(x,10.0)\n\/\/#define F(x) pow(x,42.0)\nvoid main( void ) \n{\n\tvec2 uv = ( gl_FragCoord.xy \/ resolution.xy );\n\tuv -=.5;\n\tuv.x *= resolution.x\/ resolution.y;\n\n\tconst float PI = 3.14159265358979323846264;\n\tfloat a = atan(uv.x, uv.y ) * 6.\/PI;\n\tfloat r = length(uv);\n\tfloat twist = fract(-4.*F(r)+time+a);\n\t\n\tfloat val = float(twist > .5);\n\tgl_FragColor = vec4(vec3( val ), 1.);\n}\n*\/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord.xy \/ iResolution.xy );\n\tuv -=.5;\n\t\/\/uv.x += sin(time)*.005*cos( 80.*uv.y + 10.*time);\n\t\/\/uv.x += cos(uv.x * .5*sin(2.*time));\n\t\/\/uv.y += cos(uv.y * cos(time));\n\tuv.x *= iResolution.x\/ iResolution.y;\n\n\tfloat val1 = sin(cos(3.*iGlobalTime) +  length(40.*(mod(3.*uv, 1.)-.5)));\n\tfloat val2 = sin(cos(5.*iGlobalTime) +  Mylength(40.*(mod(4.*uv, 1.)-.5)));\n\tfloat val3 = length(sin(20.*uv)+sin(10.*iGlobalTime));\n\n\t\tconst float PI = 3.14159265358979323846264;\n\tfloat a = atan(uv.x, uv.y ) * 6.\/PI;\n\tfloat r = length(uv);\n\tfloat twist = fract(-4.*r+iGlobalTime+a);\n\tfloat val = float(twist > .5);\n\t\n\tvec3 finalColor1 = vec3( val1 * val2+val3, val1+val2, val2-val1 );\n\t\/\/vec3 finalColor2 = vec3( (val1 + val2+val3)\/3., (val1-val2)\/2., val2*val1\/2. );\n\tvec3 finalColor2 = vec3(sin(50.*uv.y - 10.*iGlobalTime));\n\t\n\tvec3 FinalColor= mix( finalColor1, finalColor2, val) ;\n    FinalColor -= perlin_noise( uv, 10., 2., .5 );\n\tfragColor = vec4(FinalColor, 1.);\n}","name":"","description":"","type":"image"}]}}