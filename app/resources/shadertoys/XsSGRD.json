{"Shader":{"ver":"0.1","info":{"id":"XsSGRD","date":"1384180513","viewed":7125,"name":"fluffy's breakfast","username":"eiffie","description":"Now I like the name \"Confusion Marching\".","likes":24,"published":3,"flags":0,"tags":["dof","confusionmarching"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ fluffy's breakfast by eiffie\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ using massive DoF to march around this little guy's furry butt\n\nconst float focalDistance=1.0,aperature=0.07,fudgeFactor=0.9;\n\n#define size iResolution\n#define time iGlobalTime\n\n\/\/handy routines from iq\nfloat smin(float a,float b,float k){return -log(exp(-k*a)+exp(-k*b))\/k;}\/\/negative k gives int and dif\nfloat Ellipsoid(vec3 z, vec4 r){float f=length(z*r.xyz);return f*(f-r.w)\/length(z*r.xyz*r.xyz);}\nfloat Segment(vec3 p, vec3 p0, vec3 p1, float r){vec3 v=p1-p0;v*=clamp(dot(p-p0,v)\/dot(v,v),0.0,1.0);return distance(p-p0,v)-r;}\nfloat Cone(in vec3 z, vec2 r){return max(abs(z.y)-r.y,(length(z.xz)-r.x*clamp(r.y-abs(z.y),0.0,r.y))\/(1.0+r.x\/r.y));}\nvec4 seg4( vec3 pa, vec3 ba )\/\/iq's tube returning nearest point and distance along segment\n{\/\/same as tube except it lets you shape the result with dot(j.xyz,rt) and j.w\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\treturn vec4(pa - ba*h,h);\n}\n\/\/ See http:\/\/www.iquilezles.org\/www\/articles\/morenoise\/morenoise.htm for a proper version :)\nfloat hash(float n) {return fract(sin(n) * 43758.5453123);}\nfloat noyz(vec2 x) {\/\/simple version\n\tvec2 p=floor(x),f=fract(x),u=f*f*(3.0-2.0*f);\n\tconst float tw=117.0;\n\tfloat n=p.x+p.y*tw,a=hash(n),b=hash(n+1.0),c=hash(n+tw),d=hash(n+tw+1.0);\n\treturn a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y;\n}\nfloat fbm(vec2 p) {return 0.5*noyz(p)+0.3*noyz(p*2.3)+0.2*noyz(p*3.7);}\n\nfloat RCyl(in vec3 z, vec3 r){return length(max(vec2(abs(z.z)-r.y,length(z.xy)-r.x),0.0))-r.z;}\n\nfloat linstep(float a, float b, float t){return clamp((t-a)\/(b-a),0.,1.);}\/\/ i got this from knighty and\/or darkbeam\nfloat rand(vec2 co){\/\/ implementation found at: lumina.sourceforge.net\/Tutorials\/Noise.html\n\treturn fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat headbob,tailwag;\nfloat DE(in vec3 p)\n{\n\tvec3 z=p+vec3(0.0,1.2,2.5);\n\tfloat dB=Cone(z,vec2(0.75,1.5));\/\/dog bowl\n\tdB=smin(dB,-length(z+vec3(0.0,-1.215,0.0))+1.08,-64.0);\/\/smooth difference to scoop out bowl\n\tfloat dF=z.y;  \/\/floor\n\tfloat d=Ellipsoid(p,vec4(1.4,1.4,1.0,1.0)); \/\/body\n\tvec4 j=seg4(p+vec3(0.0,-0.58,-1.0),vec3(tailwag,0.68,0.0));\/\/create tail segment\n\tj.z-=sin(j.w*3.1416)*0.1;\/\/add a curve to the tail\n\tfloat d2=length(j.xyz); \/\/tail distance\n\tvec2 uv=vec2(atan(p.z,p.x),p.y); \/\/basic fur pattern\n\tp.x=abs(p.x);\n\tuv.xy=mix(vec2(uv.x+(p.y-0.32)*1.3,p.y+d2*3.3),uv.xy,smoothstep(0.0,0.25,d2));\/\/changing fur direction for tail\n\tfloat d3=min(d2,RCyl(p+vec3(-0.4,headbob,1.35),vec3(0.15,0.0,0.02))); \/\/ears\n\tuv.y=mix(p.y+d3*3.3,uv.y,smoothstep(0.0,0.51,d3));\/\/changing fur direction for ears\n\td2=min(d2,d3);\n\tfloat h=fbm(uv*25.0); \n\tp.z=abs(p.z);\n\td2=min(d2,Ellipsoid(p+vec3(-0.45,0.78,-0.63),vec4(2.0,1.0,2.0,0.07))); \/\/feet\n\td=(smin(d2,d,8.0)-h*0.2)*0.5; \/\/smooth together and add fur\n\treturn min(d,min(dB,dF)); \/\/return closest object\n}\nvec3 mcol;\nfloat CE(vec3 p){\/\/same for coloring\n\tvec3 z=p+vec3(0.0,1.2,2.5);\n\tfloat dB=Cone(z,vec2(0.75,1.5));\n\tdB=smin(dB,-length(z+vec3(0.0,-1.215,0.0))+1.08,-64.0);\n\tfloat dF=z.y;\n\tfloat d=Ellipsoid(p,vec4(1.4,1.4,1.0,1.0));\n\tvec4 j=seg4(p+vec3(0.0,-0.58,-1.0),vec3(tailwag,0.68,0.0));\n\tj.z-=sin(j.w*3.1416)*0.1;\n\tfloat d2=length(j.xyz);\n\tvec2 uv=vec2(atan(p.z,p.x),p.y);\n\tp.x=abs(p.x);\n\tuv.xy=mix(vec2(uv.x+(p.y-0.32)*tailwag*1.3,p.y+d2*3.3),uv.xy,smoothstep(0.0,0.25,d2));\/\/changing the direction for ears\n\tfloat d3=min(d2,RCyl(p+vec3(-0.4,headbob,1.35),vec3(0.15,0.0,0.02)));\n\tuv.y=mix(p.y+d3*3.3,uv.y,smoothstep(0.0,0.51,d3));\n\td2=min(d2,d3);\n\tfloat h=fbm(uv*25.0);\n\tp.z=abs(p.z);\n\td2=min(d2,Ellipsoid(p+vec3(-0.45,0.78,-0.63),vec4(2.0,1.0,2.0,0.07)));\n\tfloat d1=(smin(d2,d,8.0)-h*0.2)*0.5;\n\td=min(d1,min(dB,dF));\n\tif(abs(d-dB)<0.001)mcol+=vec3(0.9,0.9,0.2);\n\telse if(abs(d-dF)<0.001){mcol+=vec3(1.0,0.4+noyz(z.xz*vec2(50.0,1.0))*0.4,0.4)*(0.4+0.6*clamp(d1*3.0,0.0,1.0));}\n\telse mcol+=vec3(0.7,0.5,0.3)*h+vec3(-p.y*0.5);\n\treturn d;\n}\n\nfloat pixelSize;\nfloat CircleOfConfusion(float t){\/\/calculates the radius of the circle of confusion at length t\n\treturn max(abs(focalDistance-t)*aperature,pixelSize*t);\n}\nmat3 lookat(vec3 fw,vec3 up){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,normalize(up)));return mat3(rt,cross(rt,fw),fw);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tpixelSize=1.0\/size.y;\n\theadbob=-0.6+abs(sin(time*9.0)*sin(time*3.5))*0.1;\n\ttailwag=sin(time*14.0)*0.1;\n\tvec3 ro=vec3(-1.5,0.15,2.75)+vec3(cos(time),sin(time*0.7)*0.5,sin(time))*0.25;\n\tvec3 rd=lookat(-ro,vec3(0.0,1.0,0.0))*normalize(vec3((2.0*fragCoord.xy-size.xy)\/size.y,2.0));\n\tvec3 L=normalize(ro+vec3(0.5,2.5,0.5));\n\tvec4 col=vec4(0.0);\/\/color accumulator\n\tfloat t=0.0;\/\/distance traveled\n\tfor(int i=1;i<48;i++){\/\/march loop\n\t\tif(col.w>0.9 || t>7.0)continue;\/\/bail if we hit a surface or go out of bounds\n\t\tfloat rCoC=CircleOfConfusion(t);\/\/calc the radius of CoC\n\t\tfloat d=DE(ro)+0.25*rCoC;\n\t\tif(d<rCoC){\/\/if we are inside add its contribution\n\t\t\tvec3 p=ro;\/\/-rd*abs(d-rCoC);\/\/back up to border of CoC\n\t\t\tmcol=vec3(0.0);\/\/clear the color trap, collecting color samples with normal deltas\n\t\t\tvec2 v=vec2(rCoC*0.5,0.0);\/\/use normal deltas based on CoC radius\n\t\t\tvec3 N=normalize(vec3(-CE(p-v.xyy)+CE(p+v.xyy),-CE(p-v.yxy)+CE(p+v.yxy),-CE(p-v.yyx)+CE(p+v.yyx)));\n\t\t\t\/\/if(dot(N,rd)<0.0){\/\/doesn't seem to matter??\n\t\t\t\tvec3 scol=mcol*0.1666*(0.7+0.3*dot(N,L));\/\/do some fast light calcs (you can forget about shadow casting, too expensive)\n\t\t\t\tscol+=pow(max(0.0,dot(reflect(rd,N),L)),8.0)*vec3(1.0,0.5,0.0);\n\t\t\t\tfloat alpha=fudgeFactor*(1.0-col.w)*linstep(-rCoC,rCoC,-d);\/\/calculate the mix like cloud density\n\t\t\t\tcol+=vec4(scol*alpha,alpha);\/\/blend in the new color\n\t\t\t\/\/}\n\t\t}\n\t\td=abs(fudgeFactor*d*(0.7+0.2*rand(fragCoord.xy*vec2(i))));\/\/add in noise to reduce banding and create fuzz\n\t\tro+=d*rd;\/\/march\n\t\tt+=d;\n\t}\/\/mix in background color\n\tvec3 scol=mix(vec3(0.025,0.1,0.05)+rd*0.025,vec3(0.1,0.2,0.3)+rd*0.1,smoothstep(-0.1,0.1,rd.y));\n\tcol.rgb+=scol*(1.0-clamp(col.w,0.0,1.0));\n\n\tfragColor = vec4(clamp(col.rgb,0.0,1.0),1.0);\n}\n\n","name":"","description":"","type":"image"},{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/i thought this needed some suspense, maybe that is not fluffy\n\nfloat sawtooth(float time){return fract(time)-0.5;}\n\/\/ note number to frequency  from https:\/\/www.shadertoy.com\/view\/ldfSW2\nfloat ntof(float n){return 440.0 * pow(2.0, (n - 67.0) \/ 12.0);}\n\nvec2 mainSound(float time)\n{\n    float bps=1.8+time*0.01;\n    float tim=time*bps;\n    float b=floor(tim);\n    float t=fract(tim);\n    float n=37.0+mod(b,2.0);\n    float f=ntof(n);\n    float a=0.5,r=0.0,a2=time*0.018;\n    for(int i=0;i<6;i++){\n        r+=(sawtooth(f*time)+sawtooth(f*time*1.01))*a;\n        f*=1.666;a*=a2;\n    }\n    return vec2( r*exp(-2.0*t) )*time*0.01;\n}","name":"","description":"","type":"sound"}]}}