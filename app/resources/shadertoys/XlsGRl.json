{"Shader":{"ver":"0.1","info":{"id":"XlsGRl","date":"1424328467","viewed":1077,"name":"Plane From Point Cloud","username":"paniq","description":"fit a plane to a point cloud using least squares via singular value decomposition (SVD); toggle INVERSE_ITER_EIGEN for a cheaper computation of the tangent space only","likes":8,"published":3,"flags":0,"tags":["pca"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ fit a plane to a point cloud using least squares via singular value decomposition (SVD)\n\/\/ the technique is called PCA (Principle Component Analysis)\n\n\/\/ number of random points to track\n\/\/ you need at least 3 or ... well.\n\/\/ less points need more sweeps.\n#define POINT_COUNT 13\n\n\/\/ set to 1 to see some mightly fine plane fittin'\n#define SHAPE_CLOUD 0\n\n\/\/ plane needs to orient towards smallest eigenvalue, so leave this on\n#define SORT_EIGENVALUES 1\n\n\/\/ SVD parts are public domain\n\n\/\/ for some reason, too many sweeps ruin the anisotropic distribution\n\/\/ of the eigenvalues; so higher is not always better.\n#define SVD_NUM_SWEEPS 6\n\n\/\/ use approximate eigensolver instead\n#define INVERSE_ITER_EIGEN 0\n\n\/\/ GLSL prerequisites\n\n#define IN(t,x) in t x\n#define OUT(t, x) out t x\n#define INOUT(t, x) inout t x\n#define rsqrt inversesqrt\n\n#define SWIZZLE_XYZ(v) v.xyz\n            \n\/\/ SVD\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst float Small_Number = 1.e-3;\nconst float Tiny_Number = 1.e-20;\n\nvoid givens_coeffs_sym(float a_pp, float a_pq, float a_qq, OUT(float,c), OUT(float,s)) {\n    if (a_pq == 0.0) {\n        c = 1.0;\n        s = 0.0;\n        return;\n    }\n    float tau = (a_qq - a_pp) \/ (2.0 * a_pq);\n    float stt = sqrt(1.0 + tau * tau);\n    float tan = 1.0 \/ ((tau >= 0.0) ? (tau + stt) : (tau - stt));\n    c = rsqrt(1.0 + tan * tan);\n    s = tan * c;\n}\n\nvoid svd_rotate_xy(INOUT(float,x), INOUT(float,y), IN(float,c), IN(float,s)) {\n    float u = x; float v = y;\n    x = c * u - s * v;\n    y = s * u + c * v;\n}\n\nvoid svd_rotateq_xy(INOUT(float,x), INOUT(float,y), INOUT(float,a), IN(float,c), IN(float,s)) {\n    float cc = c * c; float ss = s * s;\n    float mx = 2.0 * c * s * a;\n    float u = x; float v = y;\n    x = cc * u - mx + ss * v;\n    y = ss * u + mx + cc * v;\n}\n\nvoid svd_rotate01(INOUT(mat3,vtav), INOUT(mat3,v)) {\n    if (vtav[0][1] == 0.0) return;\n    \n    float c, s;\n    givens_coeffs_sym(vtav[0][0], vtav[0][1], vtav[1][1], c, s);\n    svd_rotateq_xy(vtav[0][0],vtav[1][1],vtav[0][1],c,s);\n    svd_rotate_xy(vtav[0][2], vtav[1][2], c, s);\n    vtav[0][1] = 0.0;\n    \n    svd_rotate_xy(v[0][0], v[0][1], c, s);\n    svd_rotate_xy(v[1][0], v[1][1], c, s);\n    svd_rotate_xy(v[2][0], v[2][1], c, s);\n}\n\nvoid svd_rotate02(INOUT(mat3,vtav), INOUT(mat3,v)) {\n    if (vtav[0][2] == 0.0) return;\n    \n    float c, s;\n    givens_coeffs_sym(vtav[0][0], vtav[0][2], vtav[2][2], c, s);\n    svd_rotateq_xy(vtav[0][0],vtav[2][2],vtav[0][2],c,s);\n    svd_rotate_xy(vtav[0][1], vtav[1][2], c, s);\n    vtav[0][2] = 0.0;\n    \n    svd_rotate_xy(v[0][0], v[0][2], c, s);\n    svd_rotate_xy(v[1][0], v[1][2], c, s);\n    svd_rotate_xy(v[2][0], v[2][2], c, s);\n}\n\nvoid svd_rotate12(INOUT(mat3,vtav), INOUT(mat3,v)) {\n    if (vtav[1][2] == 0.0) return;\n    \n    float c, s;\n    givens_coeffs_sym(vtav[1][1], vtav[1][2], vtav[2][2], c, s);\n    svd_rotateq_xy(vtav[1][1],vtav[2][2],vtav[1][2],c,s);\n    svd_rotate_xy(vtav[0][1], vtav[0][2], c, s);\n    vtav[1][2] = 0.0;\n    \n    svd_rotate_xy(v[0][1], v[0][2], c, s);\n    svd_rotate_xy(v[1][1], v[1][2], c, s);\n    svd_rotate_xy(v[2][1], v[2][2], c, s);\n}\n\nfloat svd_off(IN(mat3,a)) {\n    return sqrt(2.0 * ((a[0][1] * a[0][1]) + (a[0][2] * a[0][2]) + (a[1][2] * a[1][2])));\n}\n\n\nvoid svd_solve_sym(IN(mat3,a), OUT(vec3,sigma), INOUT(mat3,v)) {\n    \/\/ assuming that A is symmetric: can optimize all operations for \n    \/\/ the lower left triagonal\n    mat3 vtav = a;\n    \/\/ assuming V is identity: you can also pass a matrix the rotations\n    \/\/ should be applied to\n    \/\/ U is not computed\n    for (int i = 0; i < SVD_NUM_SWEEPS; ++i) {\n        if (svd_off(vtav) < Small_Number)\n            continue;\n        svd_rotate01(vtav, v);\n        svd_rotate02(vtav, v);\n        svd_rotate12(vtav, v);        \n    }\n    sigma = vec3(vtav[0][0],vtav[1][1],vtav[2][2]);    \n}\n\n\/\/ QEF\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvoid qef_add(\n    IN(vec3,p),\n    IN(vec3,masspoint),\n    INOUT(mat3,ATA)) {\n    p -= masspoint;\n    ATA[0][0] += p.x * p.x;\n    ATA[0][1] += p.x * p.y;\n    ATA[0][2] += p.x * p.z;\n    ATA[1][1] += p.y * p.y;\n    ATA[1][2] += p.y * p.z;\n    ATA[2][2] += p.z * p.z;\n}\n\nvoid swap(inout float a, inout float b) {\n    float x = a;\n    a = b;\n    b = x;\n}\n\nvoid swap_vec3(inout vec3 a, inout vec3 b) {\n    vec3 x = a;\n    a = b;\n    b = -x;\n}\n\nmat3 transp(mat3 m) {\n    return mat3(\n        \tm[0][0], m[1][0], m[2][0],\n        \tm[0][1], m[1][1], m[2][1],\n        \tm[0][2], m[1][2], m[2][2]\n        );\n}\n\n\/\/ approximate eigensolver for smallest eigenvalue\n\/\/ tuned by ryg\n\nconst float singularEps = 2.0 * 1.192092896e-7; \/\/ float32 epsilon, *2 to have a bit of margin\n\n\/\/ QR factorization using MGS\n\/\/ store 1 \/ diag elements in diag of R since that's what we need\nbool QR(IN(mat3,m),OUT(mat3,q),OUT(mat3,r)) {\n    q[0] = normalize(m[0]);\n    q[1] = normalize(m[1] - dot(m[1], q[0])*q[0]);\n    q[2] = cross(q[0], q[1]);\n\n    float d0 = dot(m[0], q[0]);\n    float d1 = dot(m[1], q[1]);\n    float d2 = dot(m[2], q[2]);\n    float maxd = max(max(abs(d0), abs(d1)), abs(d2));\n    float mind = min(min(abs(d0), abs(d1)), abs(d2));\n\n    \/\/ Are we numerically singular? (This test is written to work\n    \/\/ in the presence of NaN\/Inf; using >= won't work right.)\n    if (!(maxd * singularEps < mind))\n        return false;\n    \n    r[0] = vec3(1.0 \/ d0, 0.0, 0.0);\n    r[1] = vec3(dot(m[1],q[0]), 1.0 \/ d1, 0.0);\n    r[2] = vec3(dot(m[2],q[0]), dot(m[2],q[1]), 1.0 \/ d2);\n    return true;\n}\n\n\/\/ matrix a must be upper triangular\n\/\/ with main diagonal storing reciprocal of actual vals\nvec3 solve_Ux_b(IN(mat3,a), IN(vec3,b)) {\n    float x2 = b[2] * a[2][2];\n    float x1 = (b[1] - a[2][1]*x2) * a[1][1];\n    float x0 = (b[0] - a[1][0]*x1 - a[2][0]*x2) * a[0][0];\n    return vec3(x0,x1,x2);\n}    \n\n\/\/ rayleigh quotient iteration from Q R matrices\nvoid rayleigh_quot(IN(mat3,a), INOUT(float,mu), INOUT(vec3, x)) {\n    mat3 q, r;\n    vec3 y = x;\n    for (int i = 0; i < 5; ++i) {\n        x = y \/ length(y);\n        if (!QR(a - mat3(mu), q, r))\n            break;\n        y = solve_Ux_b(r, x * q);\n        mu = mu + 1.0 \/ dot(y,x);\n    }\n}\n\n\/\/ inverse iter to find EV closest to mu\nvoid inverse_iter(IN(mat3,a), INOUT(float,mu), INOUT(vec3, x)) {\n    mat3 q, r;\n\n    \/\/ If a - mat3(mu) is singular, we already have an eigenvector!\n    if (!QR(a - mat3(mu), q, r))\n        return;\n\n    \/\/ If you know eigenvalues aren't too large\/small, can skip\n    \/\/ normalize here. (It's only there to present over-\/underflow.)\n    \/\/ Normalizing once at the end (before calc of mu) works fine.\n    for (int i = 0; i < 4; ++i)\n        x = normalize(solve_Ux_b(r, x * q));\n\n    mu = dot(x, a*x);\n}\n\nvec3 orthogonal(vec3 v)\n{\n    return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)\n                               : vec3(0.0, -v.z, v.y);\n}\n\n\/\/ missing GLSL function\nfloat determinant(mat3 m) {\n  return   m[0][0]*( m[1][1]*m[2][2] - m[2][1]*m[1][2])\n         - m[1][0]*( m[0][1]*m[2][2] - m[2][1]*m[0][2])\n         + m[2][0]*( m[0][1]*m[1][2] - m[1][1]*m[0][2]) ;\n  }\n\n\/\/ missing GLSL function\nmat3 inverse(mat3 m) {\n  float d = 1.0 \/ determinant(m) ;\n  return d * mat3( m[2][2]*m[1][1] - m[1][2]*m[2][1],\n                    m[1][2]*m[2][0] - m[2][2]*m[1][0],\n                     m[2][1]*m[1][0] - m[1][1]*m[2][0] ,\n\n                   m[0][2]*m[2][1] - m[2][2]*m[0][1],\n                    m[2][2]*m[0][0] - m[0][2]*m[2][0],\n                     m[0][1]*m[2][0] - m[2][1]*m[0][0],\n   \n                   m[1][2]*m[0][1] - m[0][2]*m[1][1],\n                    m[0][2]*m[1][0] - m[1][2]*m[0][0],\n                     m[1][1]*m[0][0] - m[0][1]*m[1][0]\n                 );\n  }\n\nmat3 qef_solve(IN(mat3,ATA), OUT(vec3,sigma)) {\n#if INVERSE_ITER_EIGEN    \n    ATA[1][0] = ATA[0][1];\n    ATA[2][0] = ATA[0][2];\n    ATA[2][1] = ATA[1][2];\n    \n    vec3 e0 = vec3(1.0);    \n    float mu = 0.0; \n    \/\/ so the problem with rayleigh is that it really likes to latch on to\n    \/\/ the eigenvalue with largest absolute value.\n    \/\/ better to use normal inverse iteration if we want the EV closest to 0!\n    \/\/rayleigh_quot(a, mu, x);\n \n    \/\/ once to get close to smallest EV, second pass to polish\n    inverse_iter(ATA, mu, e0);\n    inverse_iter(ATA, mu, e0);\n\n    mat3 iATA = inverse(ATA);\n    vec3 e1 = vec3(1.0);\n    float mu2 = 0.0;\n    inverse_iter(iATA, mu2, e1);\n    inverse_iter(iATA, mu2, e1);\n    \n\n    \/\/vec3 e1 = orthogonal(e0);\n    vec3 e2 = cross(e0,e1);\n    sigma = vec3(1.0,1.0,max(0.01,sqrt(mu)*0.5));\n    return mat3(e2,e1,e0);\n#else \/\/ SVD\n    mat3 V = mat3(1.0);\n    \n    svd_solve_sym(ATA, sigma, V);\n    V = transp(V);\n    \n#if SORT_EIGENVALUES    \n    if (sigma[0] < sigma[1]) {\n        swap(sigma[0],sigma[1]);\n        swap_vec3(V[0],V[1]);\n    }\n    if (sigma[0] < sigma[2]) {\n        swap(sigma[0],sigma[2]);\n        swap_vec3(V[0],V[2]);\n    }\n    if (sigma[1] < sigma[2]) {\n        swap(sigma[1],sigma[2]);\n        swap_vec3(V[1],V[2]);\n    }\n#endif    \n    sigma = vec3(sqrt(sigma[0]),sqrt(sigma[1]),sqrt(sigma[2]))*0.5;\n    \n    return V;\n#endif\n}\n\n\/\/ uncomment for a cross section view\n\/\/#define CROSS_SECTION\n\n\/\/------------------------------------------------------------------------\n\/\/ Camera\n\/\/\n\/\/ Move the camera. In this case it's using time and the mouse position\n\/\/ to orbitate the camera around the origin of the world (0,0,0), where\n\/\/ the yellow sphere is.\n\/\/------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 10.0*mouseX;\n\tcamPos = vec3(4.5*sin(an),2.0,4.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n\/\/------------------------------------------------------------------------\n\/\/ Background \n\/\/\n\/\/ The background color. In this case it's just a black color.\n\/\/------------------------------------------------------------------------\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n\nvec3 min3(vec3 a, vec3 b) {\n    return (a.x <= b.x)?a:b;\n}\n\nvec3 max3(vec3 a, vec3 b) {\n    return (a.x > b.x)?a:b;\n}\n\nvoid rotate_xy(inout float x, inout float y, in float a) {\n    float c = cos(a);\n    float s = sin(a);\n    float u = x; float v = y;\n    x = c * u - s * v;\n    y = s * u + c * v;\n}\n\n\/\/ Fractional Brownian Motion code by IQ.\n\nfloat noise( float x, float y )\n{\n\treturn sin(1.5*x)*sin(1.5*y);\n}\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\nfloat fbm4( float x, float y )\n{\n    vec2 p = vec2( x, y );\n    float f = 0.0;\n    f += 0.5000*noise( p.x, p.y ); p = m*p*2.02;\n    f += 0.2500*noise( p.x, p.y ); p = m*p*2.03;\n    f += 0.1250*noise( p.x, p.y ); p = m*p*2.01;\n    f += 0.0625*noise( p.x, p.y );\n    return f\/0.9375;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nvec3 hue2rgb(float hue) {\n    return clamp( \n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, \n        0.0, 1.0);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec3 rgb = hue2rgb(c.x);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n\n\/\/------------------------------------------------------------------------\n\/\/ Modelling \n\/\/\n\/\/ Defines the shapes (a sphere in this case) through a distance field\n\/\/------------------------------------------------------------------------\n\n#define POINT_PT_R 0.05\n#define AXIS_PT_R 0.01\n#define CENTER_PT_R 0.15\n\nvec3 points[POINT_COUNT];\nvec3 center;\nmat3 orientation;\nvec3 sigma;\n\nvoid update_points() {\n\tmat3 ATA = mat3(0.0);\n\tvec4 pointaccum = vec4(0.0);\n    \n    float t = iGlobalTime*0.05;\n    for (int i = 0; i < POINT_COUNT; ++i) {\n        vec3 f = float(i) * vec3(1.0,3.0,5.0);\n        points[i] = vec3(fbm4(f.y+t,f.z+t),fbm4(f.x+t,f.z+t),fbm4(f.x+t,f.y+t))*3.0;\n#if SHAPE_CLOUD        \n        points[i].x *= 0.21;\n        float d = points[i].z + points[i].y;        \n        points[i].z = mix(points[i].z, d, 0.9);\n        points[i].y = mix(points[i].y, d, 0.5);\n#endif\n        pointaccum += vec4(points[i],1.0);\n    }\n    \n    center = pointaccum.xyz \/ pointaccum.w;    \n\n    for (int i = 0; i < POINT_COUNT; ++i) {\n\t    qef_add(points[i], center, ATA);\n    }\n    \n    orientation = qef_solve(ATA, sigma);\n}\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nvec3 doModel2( vec3 p ) {\n    vec3 s = vec3(sphere(p - points[0], POINT_PT_R),0.9,1.0);\n    for (int i = 1; i < POINT_COUNT; ++i) {\n        s = min3(s, vec3(sphere(p - points[i], POINT_PT_R),0.9,1.0));\n    }\n    \n    s = min3(s, vec3(sdCapsule(p, center, center + orientation[0]*sigma.x, AXIS_PT_R),0.0,1.0));\n    s = min3(s, vec3(sdCapsule(p, center, center + orientation[1]*sigma.y, AXIS_PT_R),0.33,1.0));\n    s = min3(s, vec3(sdCapsule(p, center, center + orientation[2]*sigma.z, AXIS_PT_R),0.66,1.0));\n    \n    s = min3(s, vec3(udRoundBox((p - center) * orientation, vec3(sigma.x,sigma.y,0.005), 0.0),0.0,0.0));\n    \n  \treturn s;\n}\n\nfloat doModel( vec3 p ) {\n    return doModel2(p).x;\n}\n    \n\/\/------------------------------------------------------------------------\n\/\/ Material \n\/\/\n\/\/ Defines the material (colors, shading, pattern, texturing) of the model\n\/\/ at every point based on its position and normal. In this case, it simply\n\/\/ returns a constant yellow color.\n\/\/------------------------------------------------------------------------\nvec3 doMaterial( in vec3 pos, in vec3 nor )\n{\n    vec3 m = doModel2(pos);\n    \n    return hsv2rgb(vec3(m.yz,0.5))*0.5;\n}\n\n\/\/------------------------------------------------------------------------\n\/\/ Lighting\n\/\/------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal )\n{\n    vec3 lin = vec3(0.0);\n\n    \/\/ key light\n    \/\/-----------------------------\n    vec3  lig = normalize(vec3(1.0,0.7,0.9));\n    float dif = max(dot(nor,lig),0.0);\n    float sha = 0.0; if( dif>0.01 ) sha=calcSoftshadow( pos+0.01*nor, lig );\n    lin += dif*vec3(4.00,4.00,4.00)*sha;\n\n    \/\/ ambient light\n    \/\/-----------------------------\n    lin += vec3(0.50,0.50,0.50);\n\n    \n    \/\/ surface-light interacion\n    \/\/-----------------------------\n    vec3 col = mal*lin;\n\n    \n    \/\/ fog    \n    \/\/-----------------------------\n\tcol *= exp(-0.01*dis*dis);\n\n    return col;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 20.0;           \/\/ max trace distance\n\tconst float precis = 0.001;        \/\/ precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<90; i++ )          \/\/ max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = doModel( ro+rd*t );\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             \/\/ precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ) + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ) + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ) + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ) );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 \/\/ selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<40; i++ )         \/\/ 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t);\n        res = min( res, 64.0*h\/t );   \/\/ 64 is the hardness of the shadows\n\t\tt += clamp( h, 0.02, 2.0 );   \/\/ limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)\/iResolution.y;\n    vec2 m = iMouse.xy\/iResolution.xy;\n\n    update_points();\n\n    \/\/-----------------------------------------------------\n    \/\/ camera\n    \/\/-----------------------------------------------------\n    \n    \/\/ camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iGlobalTime, m.x );\n\n    \/\/ camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  \/\/ 0.0 is the camera roll\n    \n\t\/\/ create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); \/\/ 2.0 is the lens length\n\n    \/\/-----------------------------------------------------\n\t\/\/ render\n    \/\/-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t\/\/ raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        \/\/ geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        \/\/ materials\n        vec3 mal = doMaterial( pos, nor );\n\n        col = doLighting( pos, nor, rd, t, mal );\n\t}\n\n\t\/\/-----------------------------------------------------\n\t\/\/ postprocessing\n    \/\/-----------------------------------------------------\n    \/\/ gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\t   \n    fragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}