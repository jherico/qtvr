{"Shader":{"ver":"0.1","info":{"id":"Xtf3RS","date":"1422732953","viewed":755,"name":"Ray Tracer Example","username":"akaitora","description":"Here is my first ray tracer.  The specular lighting is wrong.  A work in progress...","likes":0,"published":3,"flags":0,"tags":["raytracing","raytracer","ray","tracer","tracying"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/--------------------------------------------------------------------------------------------\n\/\/ Simple Ray Tracer\n\/\/ By: Brandon Fogerty\n\/\/ bfogerty at gmail dot com\n\/\/--------------------------------------------------------------------------------------------\n\n\n\/\/--------------------------------------------------------------------------------------------\n\/\/ Begin Region: Defines\n\/\/--------------------------------------------------------------------------------------------\n#define PrimitiveType_None          0.0\n#define PrimitiveType_Sphere        1.0\n#define PrimitiveType_Plane         2.0\n\n#define MAX_SPHERES                 4\n#define MAX_PLANES                  6\n\n#define TimeValue                   iGlobalTime\n#define ResolutionValue             iResolution\n#define MouseValue\t\t\t\t\tiMouse\n#define Epsilon                     0.00001\n\/\/--------------------------------------------------------------------------------------------\n\/\/ End Region\n\/\/--------------------------------------------------------------------------------------------\n\n\/\/--------------------------------------------------------------------------------------------\n\/\/ Begin Region: Data Structures\n\/\/--------------------------------------------------------------------------------------------\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct SphereParms\n{\n    vec3 position;\n    float radius;\n    vec3 diffuseColor;\n    int lightVisualizer;\n   \n    float receiveShadow;\n    float shadowCasterIntensity;\n    float reflectionIntensity;\n   \n};\n \nstruct PlaneParams\n{\n    vec3 pointOnPlane;\n    vec3 normal;\n    vec3 diffuseColor;\n    \n    float receiveShadow;\n    float shadowCasterIntensity;\n    float reflectionIntensity;\n};\n\nstruct HitInfo\n{\n    vec3 position;\n    vec3 normal;\n    vec3 rayDir;\n    float t;\n    float dist;\n    vec3 diffuseColor;\n    \n    float receiveShadow;\n    float shadowCasterIntensity;\n    float reflectionIntensity;\n \n    int lightVisualizer;\n   \n    float primitiveType;\n    float hit;\n};\n \n\/\/--------------------------------------------------------------------------------------------\n\/\/ End Region\n\/\/--------------------------------------------------------------------------------------------\n \n\/\/--------------------------------------------------------------------------------------------\n\/\/ Begin Region: Global Variables\n\/\/--------------------------------------------------------------------------------------------\nSphereParms spheres[MAX_SPHERES];\nHitInfo sphereHitInfos[MAX_SPHERES];\nPlaneParams planes[MAX_PLANES];\nHitInfo planeHitInfos[MAX_PLANES];\nvec3 lightPos;\n\/\/--------------------------------------------------------------------------------------------\n\/\/ End Region\n\/\/--------------------------------------------------------------------------------------------\n\n\/\/--------------------------------------------------------------------------------------------\nvec3 checkerBoardTexture( vec3 hitPos )\n{\n     vec2 p = floor( hitPos.xz * 1.0 );\n     float s = mod( p.x + p.y, 2.0 );\n     vec3 c = vec3( 0.4 ) * s;\n     c = mix( c, vec3( 0.9 ), hitPos.z \/ 30.0 );\n   \n     return c;\n}\n\n\/\/--------------------------------------------------------------------------------------------\nvoid sphere( Ray ray, SphereParms sphereParams, inout HitInfo hitInfo )\n{\n    hitInfo.primitiveType = PrimitiveType_None;\n    hitInfo.t = -1.0;\n    hitInfo.hit = 0.0;\n \n    vec3 newO = ray.origin - sphereParams.position;\n    float b = 2.0 * dot( newO, ray.direction );\n    float c = dot( newO, newO ) - (sphereParams.radius*sphereParams.radius);\n \n    float h = b*b - (4.0*c);\n    if( h < 0.0 ) return;\n    float t = (-b - sqrt( h ) ) \/ 2.0;\n \n    if ( t < Epsilon ) return;\n    \n    hitInfo.position = ray.origin + ray.direction * t;\n    hitInfo.normal = normalize( ( hitInfo.position - sphereParams.position ) \/ sphereParams.radius );\n    hitInfo.t = t;\n    hitInfo.dist = length( hitInfo.position - ray.origin );\n    hitInfo.rayDir = ray.direction;\n    hitInfo.diffuseColor = sphereParams.diffuseColor;\n    hitInfo.receiveShadow = sphereParams.receiveShadow;\n    hitInfo.shadowCasterIntensity = sphereParams.shadowCasterIntensity;\n    hitInfo.reflectionIntensity = sphereParams.reflectionIntensity;\n    hitInfo.lightVisualizer = sphereParams.lightVisualizer;\n    hitInfo.primitiveType = PrimitiveType_Sphere;\n    hitInfo.hit = 1.0;\n}\n\n\/\/--------------------------------------------------------------------------------------------\nvoid plane( Ray ray, PlaneParams planeParams, inout HitInfo hitInfo )\n{\n    hitInfo.primitiveType = PrimitiveType_None;\n    hitInfo.t = -1.0;\n    hitInfo.hit = 0.0;\n \n    float d = dot( planeParams.pointOnPlane, planeParams.normal );\n    float t = ( d - dot( ray.origin, planeParams.normal ) ) \/ dot( ray.direction, planeParams.normal );\n \n    if( t < 0.00 )\n    {\n        return;\n    }\n \n    hitInfo.position = ray.origin + ray.direction * t;\n    hitInfo.normal = normalize( planeParams.normal );\n    hitInfo.t = t;\n    hitInfo.dist = length( hitInfo.position - ray.origin );\n    hitInfo.rayDir = ray.direction;\n    hitInfo.diffuseColor = planeParams.diffuseColor;\n    hitInfo.receiveShadow = planeParams.receiveShadow;\n    hitInfo.shadowCasterIntensity = planeParams.shadowCasterIntensity;\n    hitInfo.reflectionIntensity = planeParams.reflectionIntensity;\n    hitInfo.lightVisualizer = 0;\n    hitInfo.primitiveType = PrimitiveType_Plane;\n    hitInfo.hit = 1.0;\n}\n\n\/\/--------------------------------------------------------------------------------------------\nHitInfo intersect( Ray ray )\n{\n    HitInfo hitInfo;\n    hitInfo.primitiveType = PrimitiveType_None;\n    \n    for( int i = 0; i < MAX_SPHERES; ++i )\n    {\n        \n        sphere( ray, spheres[i], sphereHitInfos[i] );\n       \n        if( sphereHitInfos[i].primitiveType > PrimitiveType_None )\n        {\n            if(  sphereHitInfos[i].dist <  hitInfo.dist || hitInfo.primitiveType <= PrimitiveType_None )\n            {\n                hitInfo = sphereHitInfos[i];\n            }\n        }\n    }\n   \n    for( int i = 0; i < MAX_PLANES; ++i )\n    {\n        \n        plane( ray, planes[i], planeHitInfos[i] );\n       \n        if( planeHitInfos[i].primitiveType > PrimitiveType_None )\n        {\n            if(  planeHitInfos[i].dist <  hitInfo.dist || hitInfo.primitiveType <= PrimitiveType_None )\n            {\n                hitInfo.diffuseColor = planeHitInfos[i].diffuseColor;\n                if( i == 0 || i == 4 )\n                {\n                    planeHitInfos[i].diffuseColor = checkerBoardTexture( planeHitInfos[i].position ) * planeHitInfos[i].diffuseColor;\n                }\n\n                hitInfo = planeHitInfos[i];\n            }\n        }\n    }\n    \n    return hitInfo;\n}\n\n\/\/--------------------------------------------------------------------------------------------\nvoid onSetupScene()\n{\n    lightPos = vec3( 0.0, 8.0, 2.0 );\n   \n    \/\/ Light Visualizer\n    spheres[0].position = lightPos;\n    spheres[0].radius = 0.5;\n    spheres[0].diffuseColor = vec3( 1.0, 1.0, 0.0 );\n    spheres[0].shadowCasterIntensity = 1.0;\n    spheres[0].lightVisualizer = 1;\n    spheres[0].reflectionIntensity = 0.0;\n   \n    spheres[1].position = vec3( -5.0, 1.0, -3.0 );\n    spheres[1].radius = 1.0;\n    spheres[1].diffuseColor = vec3( 1.0, 1.4, 1.0 );\n    spheres[1].shadowCasterIntensity = 0.5;\n    spheres[1].reflectionIntensity = 0.0;\n    \n    spheres[2].position = vec3( 0.0, 1.0, 1.0 );\n    spheres[2].radius = 1.0;\n    spheres[2].diffuseColor = vec3( 1.0, 0.4, 1.0 );\n    spheres[2].shadowCasterIntensity = 0.5;\n    spheres[2].reflectionIntensity = 0.7;\n    \n    spheres[3].position = vec3( 5.0, 1.0, -3.0 );\n    spheres[3].radius = 1.0;\n    spheres[3].diffuseColor = vec3( 0.0, 1.0, 1.4 );\n    spheres[3].shadowCasterIntensity = 0.5;\n    spheres[3].reflectionIntensity = 0.0;\n    \n    planes[0].pointOnPlane = vec3( 0.0, 0.0, 0.0 );\n    planes[0].normal = vec3( 0.0, 1.0, 0.0 );\n    planes[0].diffuseColor = vec3( 0.8 );\n    planes[0].shadowCasterIntensity = 1.0;\n    planes[0].reflectionIntensity = 0.0;\n    \n    planes[1].pointOnPlane = vec3( -10.0, 0.0, 0.0 );\n    planes[1].normal = vec3( 1.0, 0.0, 0.0 );\n    planes[1].diffuseColor = vec3( 1.0, 0.0, 0.0 );\n    planes[1].shadowCasterIntensity = 1.0;\n    planes[1].reflectionIntensity = 0.0;\n    \n    planes[2].pointOnPlane = vec3( 10.0, 0.0, 0.0 );\n    planes[2].normal = vec3( -1.0, 0.0, 0.0 );\n    planes[2].diffuseColor = vec3( 0.0, 0.0, 1.0 );\n    planes[2].shadowCasterIntensity = 1.0;\n    planes[2].reflectionIntensity = 0.0;\n    \n    planes[3].pointOnPlane = vec3( 0.0, 0.0, -10.0 );\n    planes[3].normal = vec3( 0.0, 0.0, 1.0 );\n    planes[3].diffuseColor = vec3( 0.0, 1.0, 0.0 );\n    planes[3].shadowCasterIntensity = 1.0;\n    planes[3].reflectionIntensity = 0.0;\n    \n    planes[4].pointOnPlane = vec3( 0.0, 15.0, 0.0 );\n    planes[4].normal = vec3( 0.0, -1.0, 0.0 );\n    planes[4].diffuseColor = vec3( 0.0, 1.0, 1.0 );\n    planes[4].shadowCasterIntensity = 1.0;\n    planes[4].reflectionIntensity = 0.0;\n    \n    planes[5].pointOnPlane = vec3( 0.0, 0.0, 15.0 );\n    planes[5].normal = vec3( 0.0, 0.0, -1.0 );\n    planes[5].diffuseColor = vec3( 1.0, 1.0, 0.0 );\n    planes[5].shadowCasterIntensity = 1.0;\n    planes[5].reflectionIntensity = 0.0;\n}\n\n\/\/--------------------------------------------------------------------------------------------\nvoid onAnimateScene()\n{\n    float animationTime = TimeValue * 0.5;\n \n    float radius = 5.0;\n    \/\/lightPos = vec3( 0.0, 8.0, 2.0 ) + vec3(cos(animationTime)*radius, cos(animationTime)*6.0, sin(animationTime)*radius);\n    \n\tlightPos = vec3( 0.0, 10.0, 9.0 );\n\t\n    spheres[0].position = lightPos;\n    \n    spheres[2].position.x += sin( animationTime * 1.0 ) * 3.0;\n    spheres[2].position.y += abs( sin( animationTime * 4.0 ) * 4.0 );\n    spheres[2].position.z += sin( cos( animationTime)  *    3.0 ) * 2.0;\n}\n\n\/\/--------------------------------------------------------------------------------------------\nvec3 calculateReflection( vec3 currentPixelColor, vec3 viewDir, HitInfo hitInfo )\n{    \n     Ray reflectionRay;\n     reflectionRay.direction = normalize( reflect( hitInfo.rayDir, hitInfo.normal ) );\n     reflectionRay.origin = hitInfo.position + hitInfo.normal * Epsilon;\n    \n     HitInfo rHitInfo = intersect( reflectionRay );\n     currentPixelColor += ( rHitInfo.diffuseColor * hitInfo.reflectionIntensity );\n    \n    \n     return currentPixelColor;\n}\n\/\/--------------------------------------------------------------------------------------------\nvec3 calculateShadow( vec3 currentPixelColor, vec3 lightDir, HitInfo hitInfo )\n{\n    Ray shadowRay;\n    shadowRay.direction = normalize( lightDir );\n    shadowRay.origin = hitInfo.position + (shadowRay.direction * Epsilon);\n    HitInfo shadowHitInfo = intersect( shadowRay );\n    currentPixelColor *= clamp( shadowHitInfo.shadowCasterIntensity, 0.00, 1.0 );\n    \n    return currentPixelColor;\n}\n\n\/\/--------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse=(MouseValue.xy \/ ResolutionValue.xy - 0.5) * 3.0;\n  \n    vec2 uv = fragCoord.xy \/ ResolutionValue.x;\n    vec2 uvp = (uv * 2.0 - 1.0) + mouse;\n \n    Ray ray;\n    ray.origin = vec3( 0.0, 5.0, 10.0 );\n    ray.direction = normalize( vec3( uvp, -1.0 ) );\n \n    onSetupScene();\n    onAnimateScene();\n \n    HitInfo hitInfo = intersect( ray );\n \n    vec3 c = vec3( 0.9 );\n    if( hitInfo.primitiveType <= PrimitiveType_None )\n    {\n        fragColor = vec4( c, 1.0 );\n        return;\n    }\n\n    vec3 lightDir = normalize( lightPos - hitInfo.position );\n    \/\/ Calculate Lighting\n    float dif = clamp( dot( hitInfo.normal, lightDir ), 0.00, 1.00 );\n    vec3 reflectionVector = normalize( reflect( lightDir, hitInfo.normal ) );\n    vec3 cameraToSurface = ray.direction;\n    float spec = pow( clamp( dot( reflectionVector, cameraToSurface ), 0.00, 1.0 ), 10.0 );\n    c = calculateReflection( hitInfo.diffuseColor, ray.direction, hitInfo ) * dif + vec3( 0.5 ) * spec;\n   \n    c = calculateShadow( c, lightDir, hitInfo );\n   \n    fragColor = vec4( c, 1.0 );\n}\n","name":"","description":"","type":"image"}]}}