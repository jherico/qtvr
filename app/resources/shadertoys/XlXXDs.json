{"Shader":{"ver":"0.1","info":{"id":"XlXXDs","date":"1440460445","viewed":888,"name":"Superformula (3D)","username":"mech4rhork","description":"testing Johan Gielis's superformula\u2122 in 3D","likes":12,"published":3,"flags":0,"tags":["3d","raymarching","fractal","superformula","supershape"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define PI 3.14159265359\n#define time iGlobalTime\n\n#define ANIM\n#define speed 5.\n\/\/#define MSAA\n#define MSAA_SAMPLES 4\n#define SHADOWS\n\n\nconst vec2 renderRange = vec2(0.001, 300.0);\n\/\/ parameters ( shape1, shape2 ) \/\/ another cool shape \/\/ another\nvec2 m  = vec2( 12, 3 ),   \/\/ 10, 4   \/\/ 12, 6      \/\/ 1, 10\n     a  = vec2( 1, -4 ),   \/\/ .9, .6  \/\/ 1, .9      \/\/ 1, 1\n     b  = vec2( .2, .2 ),  \/\/ -1, -.5 \/\/ .25, 10    \/\/ 1, 1\n     n1 = vec2( -.4, .3 ), \/\/ 1, 1    \/\/ .05, -.05  \/\/ 1, 1\n     n2 = vec2( 2, 1 ),    \/\/ 3, .2   \/\/ 25, 20     \/\/ 1, 1\n     n3 = vec2( 1, 1 );    \/\/ 4, -1   \/\/ 9.79225, 8 \/\/ 1, 1\nvec3 rd; \/\/ ray direction - used in map()\nvec4 S1, S2; \/\/ m, n1, n2, n3\nvec2 S1_ab, S2_ab; \/\/ a, b\n\nvec2 rotate( vec2 p, vec2 c, float theta ) {\n    float co=cos(theta), si=sin(theta);\n    return (p-c)*mat2(co,-si,si,co);\n}\nvec3 rotate( vec3 p, vec3 theta ) {\n    float cx=cos(theta.x), sx=sin(theta.x), cy=cos(theta.y),\n          sy=sin(theta.y), cz=cos(theta.z), sz=sin(theta.z);\n    p.yz*=mat2(cx, -sx, sx, cx); p.xz*=mat2(cy, -sy, sy, cy); p.xy*=mat2(cz, -sz, sz, cz);\n    return p;\n}\nfloat superformula( float m, float a, float b, float n1, float n2, float n3, float phi ) {\n    return pow(pow(abs(cos(m*phi\/4.)\/a), n2) + pow(abs(sin(m*phi\/4.)\/b), n3), -n1);\n}\nvec4 shape2d( float m, float a, float b, float n1, float n2, float n3, vec2 p ) {\n    p *= 1.+(abs(a-b)+abs(n1-n2)+abs(n1-n3)+abs(n2-n3));\n    float rd = length(p) - superformula(m, a, b, n1, n2, n3, atan(p.y\/p.x));\n    float alpha = step(0., rd*10.); \/\/ alpha = step(2.0, abs(rd*10.0)); \/\/ for outline\n    return vec4(vec3(.37), 1.-alpha);\n}\nfloat shape3d( vec3 p ) {\n    float d = length(p); \n    float theta = atan(p.z\/p.x); \/\/ longitude\n    float phi = asin(p.y\/d); \/\/ latitude\n    float r1 = superformula(m.x, a.x, b.x, n1.x, n2.x, n3.x, theta);\n    float r2 = superformula(m.y, a.y, b.y, n1.y, n2.y, n3.y, phi);\n    vec3 q = r2 * vec3(r1*cos(theta)*cos(phi), r1*sin(theta)*cos(phi), sin(phi));\n\treturn d - length(q);\n}\nfloat map( vec3 p ) {\n    float d = shape3d(p);\n\tfloat s = d*.5, dr = (d-shape3d(p + rd*s))\/s; \/\/ from eiffie\n\treturn d \/ (1.+max(dr, 0.)); \/\/ this one too\n}\nfloat castRay( vec3 ro, vec3 rd ) {\n    float startDelta=renderRange.x, delta=startDelta, stopDelta=renderRange.y;\n    float maxDist = 0.002;\n    for(int i = 0; i < 64; i++) {\n        float dist = map(ro + rd * delta);\n        if(dist <= maxDist || dist > stopDelta) break;\n        delta += dist;\n    }\n    return delta;\n}\nvec3 calcNormal( vec3 pos ) {\n    float delta = 0.01;\n    vec2 unit = vec2(1.0, 0.0);\n    return normalize( vec3(\n            map(pos + unit.xyy*delta) - map(pos - unit.xyy*delta),\n            map(pos + unit.yxy*delta) - map(pos - unit.yxy*delta),\n            map(pos + unit.yyx*delta) - map(pos - unit.yyx*delta)));\n}\nfloat calcSSS( vec3 pos, vec3 lig ) {\n    float sss = 0.0, sca = 1.0;\n    for(int i = 0; i < 5; i++) {\n        float delta = 0.01 + 0.03*float(i);\n        vec3 sspos = pos + lig*delta;\n        float dist = map(sspos);\n        sss += -(dist - delta)*sca;\n        sca *= 0.95;\n    }\n    return clamp(1. - 3.0*sss, 0., 1.);\n}\n\/\/ by iq\nfloat calcAO( in vec3 pos, in vec3 nor ) {\n\tfloat occ = 0.0, sca = 1.0;\n    for(int i = 0; i < 4; i++) {\n        float hr = 0.01 + 0.03*float(i);\n        vec3 aopos = nor*hr + pos;\n        float dd = map(aopos);\n        occ += -(dd - hr)*sca;\n        sca *= 0.97;\n    }\n    return clamp(1. - 3.*occ, 0., 1.);    \n}\n\/\/ based on softshadow() by iq\nfloat calcSoftShadow( vec3 ro, vec3 rd, float mint, float tmax, int samples ) {\n\tfloat res=1.0, t=mint, stepDist=(tmax - mint)\/float(samples);\n    for(int i = 0; i < 64; i++) {\n\t\tfloat h = map(ro + rd*t);\n        res = min(res, 8.0*h \/ t);\n        t += clamp(h, stepDist, 1e10);\n        if(h < 0.001 || t > tmax) break;\n    }\n    return clamp(res, 0., 1.);\n}\nvec4 render( vec3 ro, vec3 rd ) {\n    \/\/ color\n    vec3 col = vec3(0);\n    #ifndef ANIM\n    float t = 2. + m.x+m.y + n1.x+n1.y,\n          ps = m.x+m.y+a.x+a.y+b.x+b.y+n1.x+n1.y+n2.x+n2.y+n3.x+n3.y;\n    vec3 com = 0.3 + 0.3*(0.5+vec3( .5*sin(ps + 2.*t), .5*sin(ps + 3.*t), .5*sin(ps + 4.*t) ));\n    float maxCom = max(com.r, max(com.g, com.b));\n    vec3 f = 0.8*(1.0 + vec3(step(1., com.r\/maxCom), step(1., com.g\/maxCom), step(1., com.b\/maxCom)));\n    col += com * f;\n    #else\n    col = vec3(.33,.49,.81)*(1.15 + .2*vec3(sin(m.x+a.y-n1.x+n3.y), cos(m.x+a.y-n1.y+n3.x), sin(m.y+a.y-n1.x+n2.y)));\n    #endif\n    \n    float dist = castRay(ro, rd);\n    vec3 pos = ro + rd * dist;\n    \n    if(dist > renderRange.y) return vec4(0); \/\/ background\n    else {\n        vec3 lig = normalize(vec3(1,3,-2)),\n             nor = calcNormal(pos),\n             ref = reflect(rd, nor);\n        float dif = clamp(dot(nor, lig), 0., 1.),\n              spe = pow(clamp(dot(reflect(-lig, nor), -rd), 0., 1.), 25.),\n              fre = pow(clamp(1.0 + dot(nor, rd), 0., 1.), 5.),\n              dom = smoothstep(-0.15, 0.15, ref.y),\n              amb = 1.0,\n              occ = calcAO(pos, nor),\n              sss = calcSSS(pos, lig);\n        #ifdef SHADOWS\n        dif *= calcSoftShadow(pos, lig, .001, 3.1, 40);\n        #endif\n        vec3 brdf = vec3(0);\n        brdf += 0.8 * dif;\n        brdf += 1.0 * spe * dif;\n    \tbrdf += 0.3 * amb * occ;\n        brdf += 0.1 * fre * occ;\n        brdf += 0.1 * dom * occ;\n        brdf += 0.2 * sss * occ;\n        col *= brdf;\n    }\n    return vec4(col, 1);\n}\nvec4 renderAA( vec3 ro, vec3 rd ) {\n    const int k = (MSAA_SAMPLES < 0) ? 1 : MSAA_SAMPLES;\n    vec4 c = vec4(0); \/\/ color\n\tvec2 o = vec2(10, 0); \/\/ offset\n    o = rotate(o, vec2(0), PI\/8.0);\n    for(int i = 0; i < k; i++) {\n        c += render(ro + o.x\/iResolution.x, rd) \/ float(k);\n        o = rotate(o, vec2(0), 2.*PI\/float(k));\n    }\n    return c;\n}\nvec4 params( float t ){\n\tt=mod(t,10.0);\n\tif(t<1.0)return vec4(2., .9, 1.6, 2.5);\n\tif(t<2.0)return vec4(8, .2, -1.9, 1);\n    if(t<3.0)return vec4(7, .8, 1, -1.39);\n    if(t<4.0)return vec4(9, 1, 1, 1);\n    if(t<5.0)return vec4(12, .1, 1.05, 4);\n    if(t<6.0)return vec4(5, 1, 2, 2);\n    if(t<7.0)return vec4(-4, 2, .4, 1.04);\n    if(t<8.0)return vec4(-2, 1, 2, 6);\n    if(t<9.0)return vec4(7, 1, 1, 1);\n    if(t<10.)return vec4(8, 1, -1, 1);\n    return vec4(7, 1, 4, -1);\n}\nvec2 params_ab( float t ){\n\tt=mod(t,10.0);\n\tif(t<1.0)return vec2(.8, 1.);\n\tif(t<2.0)return vec2(-1, 1);\n    if(t<3.0)return vec2(-1, .95);\n    if(t<4.0)return vec2(1.3, 1.);\n    if(t<5.0)return vec2(-1, 1.3);\n    if(t<6.0)return vec2(1.3, 1);\n    if(t<7.0)return vec2(-1, 1.5);\n    if(t<8.0)return vec2(1.3, 1.3);\n    if(t<9.0)return vec2(1.15, 1);\n    if(t<10.)return vec2(1, .9);\n    return vec2(1.4, 1);\n}\n\nvoid mainImage( out vec4 o, in vec2 uv ) {\n\tvec2 R = iResolution.xy,\n         p = (2.*uv - R)\/R.y, q = p,\n         mo = -(iMouse.xy \/ R - 0.5)*2.;\n    p *= 3.0;\n    \n    \/\/ background\n    o = vec4(vec3(.099), 1);\n    \n    \/\/ animation - from effie\n    #ifdef ANIM\n    float t = time*0.25*speed;\n    S1 =    mix(params(t-1.),    params(t),    smoothstep(0.,1.\/speed*10.,fract(t)*2.));\n    S1_ab = mix(params_ab(t-1.), params_ab(t), smoothstep(0.,1.\/speed*10.,fract(t)*2.)); t \/= 10.;\n    S2 =    mix(params(t-1.),    params(t),    smoothstep(0.,1.\/speed,fract(t)*2.));\n    S2_ab = mix(params_ab(t-1.), params_ab(t), smoothstep(0.,1.\/speed,fract(t)*2.));\n    m=vec2(S1.x, S2.x); n1=vec2(S1.y, S2.y); n2=vec2(S1.z, S2.z); n3=vec2(S1.w, S2.w);\n    a=vec2(S1_ab.x, S2_ab.x); b=vec2(S1_ab.y, S2_ab.y); \n    #endif\n    \n    \/\/ 2d shape 1\n    vec4 col = shape2d(m.x, a.x, b.x, n1.x, n2.x, n3.x, p - vec2(-3.0, 1.5));\n    o = mix(o, vec4(col.rgb, 1.), col.a);\n    \/\/ 2d shape 2\n    col = shape2d(m.y, a.y, b.y, n1.y, n2.y, n3.y, p - vec2(-3.0, -1.5));\n    o = mix(o, vec4(col.rgb, 1.), col.a);\n    \n    \/\/ 3d shape (raymarching)\n    float camDist = 20.;\n    vec2 drot = vec2(mo.x*PI*1.1, mo.y*PI\/3.*1.1);\n    vec3 camPos = rotate(vec3(-camDist, 0, -camDist), vec3(drot.y, drot.x, 0));\n    vec3 forward=normalize(vec3(vec3(0)-camPos)), right=normalize(cross(vec3(0,1,0), forward)), up=cross(forward, right);\n    vec3 rayDir = mat3(right, up, forward) * normalize(vec3(q-vec2(0.48, -.125), R.y \/ R.x * 12.5)); rd = rayDir;\n    #ifdef MSAA\n    col = renderAA(camPos, rayDir);\n    #else\n    col = render(camPos, rayDir);\n    #endif\n    o = mix(o, vec4(col.rgb, 1.), col.a);\n}","name":"","description":"","type":"image"}]}}