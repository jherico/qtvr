{"Shader":{"ver":"0.1","info":{"id":"4sf3DB","date":"1378157024","viewed":875,"name":"Audio Clay","username":"TekF","description":"I was messing with applying the spectograph to an isosurface and I thought it looked like clay, so I went with that and this is the result.","likes":12,"published":3,"flags":0,"tags":["music","isosurface"],"hasliked":0},"renderpass":[{"inputs":[{"id":7,"src":"\/presets\/tex06.jpg","ctype":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":21,"src":"\/presets\/mzk04.mp3","ctype":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"id":27,"src":"\/presets\/cube05_0.png","ctype":"cubemap","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Ben Weston - 16\/08\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ constants, don't edit\nconst float tau = 6.28318530717958647692;\nfloat Noise( in vec3 x );\n\n\n\n\/\/ ------- EDIT THESE THINGS! -------\n\n\/\/ Camera (also rotated by mouse)\nconst vec3 CamPos = vec3(0,2.0,-5.0);\nconst vec3 CamLook = vec3(0,0,0);\nconst float CamZoom = 2.0;\n\n\/\/ Lights\nconst vec3 LightDir = vec3(-3,2,-1); \/\/ used for shadow rays\nconst vec3 FillLightDir = vec3(1,1,-1);\nconst vec3 lightColour = vec3(1.3);\nconst vec3 fillLightColour = vec3(.2,.3,.4)*1.3;\n\n\/\/ Shape\n\/\/ This should return continuous positive values when outside and negative values inside,\n\/\/ which roughly indicate the distance of the nearest surface.\nfloat Isosurface( vec3 pos )\n{\n\/*\tfloat f = pos.y*.2-1.5;\n\n\tpos.z += iGlobalTime*.5;\n\tpos \/= 2.0;\n\tf += Noise(pos\/3.0)*3.0; \/\/ I tried putting this in a for loop but it vanished. Faster like this anyway\n\tf += Noise(pos\/1.0)*1.0;\n\tf += Noise(pos*3.0)\/3.0;\n\t\/\/f += Noise(pos*9.0)\/9.0;\n\t\/\/f += Noise(pos*27.0)\/27.0;*\/\n\t\n\/*\tfloat a = atan(length(pos.xz),pos.y)\/(.5*tau);\n\n\t\/\/ adjust range to look pretty\t\n\ta *= 1.0\/8.0;\n\ta += 1.5\/256.0; \/\/ remove spike at freq 0.0\n\t\n\tfloat seperation = 0.06*(1.0-iMouse.x\/iResolution.x);\n\t\n\tfloat sound = texture2D( iChannel1, vec2(a,.25) ).x;\n\n\tfloat f = length(pos)-1.0+(.5-sound)*.3;\/\/smoothstep(4.0\/640.0, 0.0, abs(uv.y - sound*.3));\n\t\n\treturn f*.3;*\/\n\n\tfloat u = max(0.0,(.7-pos.y))*.15;\n\t\n\t\/\/ cubic interpolation of the values\n\tu *= 256.0;\n\tu += .5;\n\tfloat ui = floor(u);\n\tfloat uf = fract(u);\n\tuf = uf*uf*(3.0-2.0*uf);\n\t\n\tfloat sound = mix( texture2D( iChannel1, vec2(ui\/256.0,.25) ).x,  texture2D( iChannel1, vec2((ui+1.0)\/256.0,.25) ).x, uf );\n\t\n\tfloat r = 1.0-.2*pow(1.0-pos.y,2.0);\n\tr -= sound*.4;\n\t\n\tfloat f = abs( length(pos.xz)-r )-.1;\n\tf = f + .2*smoothstep( .7,.9, pos.y );\n\t\n\treturn max( f*.3, -.5-pos.y );\n}\n\n\/\/ Colour\nvec3 Shading( vec3 pos, vec3 norm, float shadow, vec3 rayDir )\n{\n\tvec3 albedo = vec3(.6,.4,.3);\/\/mix( vec3(1,.8,.7), vec3(.5,.3,.2), Noise(pos*vec3(1,10,1)) );\n\talbedo += .03*texture2D( iChannel3, vec2(atan(pos.x,pos.z)\/tau+iGlobalTime*3.0,pos.y) ).rgb;\n\n\tvec3 lightDir = normalize(LightDir);\n\tvec3 fillLightDir = normalize(FillLightDir);\n\t\n\tvec3 l = shadow*lightColour*(dot(norm,lightDir)*.5+.5);\n\tvec3 fl = fillLightColour*(dot(norm,fillLightDir)*.5+.5);\n\t\n\t\/\/ ambient occlusion\n\tfloat ao = smoothstep( -.5,-.0, pos.y );\n\t\n\tao = mix( .7, 1.0, ao );\n\t\n\tl += fl;\n\tl *= ao;\n\n\t\/\/ I did this wrong, will fix it in the morning...\n\t\/\/vec3 h = normalize(lightDir-normalize(rayDir));\n\t\/\/vec3 s = pow(max(0.0,dot(h,norm)),1000.0) * vec3(1) * 32.0;\n\t\n\tfloat f = mix(.01,.2,pow(clamp(1.0+dot(rayDir,norm), 0.0, 0.8),5.0));\n\t\n\tvec3 r = textureCube( iChannel2, reflect(rayDir,norm) ).rgb;\n\tr *= (1.0\/(1.2-r.y) - 1.0\/1.2)\/r.y; \/\/ fake HDR\n\t\n\treturn mix( albedo*l, r, f );\n}\n\n\n\/\/ Precision controls\nconst float epsilon = .003;\nconst float normalPrecision = .1;\nconst float shadowOffset = .1;\nconst int traceDepth = 100; \/\/ takes time\nconst float drawDistance = 10.0;\n\n\n\n\/\/ ------- BACK-END CODE -------\n\nfloat Noise( in vec3 x )\n{\n    vec3 p = floor(x.xzy);\n    vec3 f = fract(x.xzy);\n\tf = f*f*(3.0-2.0*f);\n\/\/\tvec3 f2 = f*f; f = f*f2*(10.0-15.0*f+6.0*f2);\n\n\/\/cracks cause a an artefact in normal, of course\n\t\n\t\/\/ there's an artefact because the y channel almost, but not exactly, matches the r channel shifted (37,17)\n\t\/\/ this artefact doesn't seem to show up in chrome, so I suspect firefox uses different texture compression.\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D( iChannel0, (uv+0.5)\/256.0, -100.0 ).ba;\n\treturn mix( rg.y, rg.x, f.z );\n}\n\nfloat Trace( vec3 ro, vec3 rd )\n{\n\tfloat t = 0.0;\n\tfloat dist = 1.0;\n\tfor ( int i=0; i < traceDepth; i++ )\n\t{\n\t\tif ( abs(dist) < epsilon || t > drawDistance || t < 0.0 )\n\t\t\tcontinue;\n\t\tdist = Isosurface( ro+rd*t );\n\t\tt = t+dist;\n\t}\n\t\n\treturn t;\/\/vec4(ro+rd*t,dist);\n}\n\n\/\/ get normal\nvec3 GetNormal( vec3 pos )\n{\n\tconst vec2 delta = vec2(normalPrecision, 0);\n\t\n\tvec3 n;\n\n\/\/ it's important this is centred on the pos, it fixes a lot of errors\n\tn.x = Isosurface( pos + delta.xyy ) - Isosurface( pos - delta.xyy );\n\tn.y = Isosurface( pos + delta.yxy ) - Isosurface( pos - delta.yxy );\n\tn.z = Isosurface( pos + delta.yyx ) - Isosurface( pos - delta.yyx );\n\treturn normalize(n);\n}\t\t\t\t\n\n\/\/ camera function by TekF\n\/\/ compute ray from camera parameters\nvec3 GetRay( vec3 dir, float zoom, vec2 uv )\n{\n\tuv = uv - .5;\n\tuv.x *= iResolution.x\/iResolution.y;\n\t\n\tdir = zoom*normalize(dir);\n\tvec3 right = normalize(cross(vec3(0,1,0),dir));\n\tvec3 up = normalize(cross(dir,right));\n\t\n\treturn normalize(dir + right*uv.x + up*uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\n\tvec3 camPos = CamPos;\n\tvec3 camLook = CamLook;\n\n\tvec2 camRot = tau*(vec2(.2,.04)+vec2(-.5,.2)*(iMouse.xy-iResolution.xy*.5)\/iResolution.x);\n\tcamPos.yz = cos(camRot.y)*camPos.yz + sin(camRot.y)*camPos.zy*vec2(-1,1);\n\tcamPos.xz = cos(camRot.x)*camPos.xz + sin(camRot.x)*camPos.zx*vec2(1,-1);\n\t\n\tif ( Isosurface(camPos) <= 0.0 )\n\t{\n\t\t\/\/ camera inside ground\n\t\tfragColor = vec4(0,0,0,0);\n\t\treturn;\n\t}\n\n\tvec3 ro = camPos;\n\tvec3 rd;\n\trd = GetRay( camLook-camPos, CamZoom, uv );\n\t\n\tfloat t = Trace(ro,rd);\n\n\tvec3 lightDir = normalize(LightDir); \/\/stupid compiler won't let me do this in a const.\n\t\n\tvec3 pos = ro+t*rd;\n\tvec3 result;\n\tif ( t > 0.0 && t < drawDistance && pos.y >-.5 )\n\t{\n\t\tvec3 norm = GetNormal(pos);\n\t\t\n\t\t\/\/ shadow test\n\t\tfloat shadow = 1.0;\n\/*\t\tif ( Trace( pos+lightDir*shadowOffset, lightDir ) < drawDistance )\n\t\t\tshadow = 0.0;*\/\n\t\t\n\t\tresult = Shading( pos, norm, shadow, rd );\n\t\t\n\t\t\/\/ fog\n\/\/\t\tresult = mix ( vec3(.7,.9,1.2), result, exp(-t*t*.0002) );\n\t}\n\telse\n\t{\n\t\tresult = textureCube( iChannel2, rd ).rgb;\/\/vec3(.7,.9,1.2);\n\t\t\n\t\t\/\/ wheel\n\t\t\/\/ intersect capped cylinder\n\t\t\n\t\tt = (-.5-ro.y)\/rd.y;\n\t\tif ( t > 0.0 )\n\t\t{\n\t\t\tvec3 pos = ro + rd*t;\n\t\t\t\n\t\t\tif ( length(pos.xz) < 1.5 )\n\t\t\t{\n\t\t\t\tfloat a = iGlobalTime*3.0*tau;\n\t\t\t\tvec2 uv = vec2( (atan(pos.x,pos.z)+a)\/tau, length(pos.xz)*.3 );\n\t\t\t\tvec3 col = texture2D( iChannel3, uv ).rgb;\n\t\t\t\tcol = .8+.1*col;\n\t\t\t\t\n\t\t\t\t\/\/ ambient occlusion from the clay\n\t\t\t\tcol *= smoothstep(-.1,.15, Isosurface( pos + lightDir*vec3(1,0,1)*.2 ) );\n\t\t\t\t\n\t\t\t\tresult = mix(col,result,smoothstep(1.47,1.5,length(pos.xz)));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfragColor = vec4( result, 1.0 );\n}","name":"","description":"","type":"image"}]}}