{"Shader":{"ver":"0.1","info":{"id":"XtXGWX","date":"1425686594","viewed":788,"name":"Burning Mandelbrot","username":"mpcomplete","description":"Testing fractals with orbit traps.","likes":6,"published":3,"flags":0,"tags":["noise","mandelbrot","fbm","fractals"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define USE_NOISE 1\n\n#if USE_NOISE\nconst float kTrapScale = 1.;\n#else\nconst float kTrapScale = 2.;\n#endif\n\nfloat time = iGlobalTime * 0.3;\n\nvec3 noise3(in vec2 uv)\n{\n    vec3 f = texture2D(iChannel0, uv\/256.0).xyz;\n\tf = f*f*(3.0-2.0*f);\n    return f;\n}\n\n\/\/ https:\/\/code.google.com\/p\/fractalt}erraingeneration\/wiki\/Fractional_Brownian_Motion\nvec3 fbm(in vec2 p)\n{\n    const float gain = 0.5;\n    const float lacunarity = 2.;\n\n    vec3 total;\n\tfloat amplitude = gain;\n\n\tfor (int i = 0; i < 7; i++) {\n\t\ttotal += noise3(p) * amplitude;\n\t\tamplitude *= gain;\n\t\tp *= lacunarity;\n\t}\n\treturn total;\n}\n\nvec2 cxMult(in vec2 c1, in vec2 c2) {\n\treturn vec2(c1.x*c2.x - c1.y*c2.y, c1.x*c2.y + c1.y*c2.x);\n}\n\nfloat cxModuloSquared(in vec2 c) {\n    return dot(c, c);\n}\n\nfloat distanceSquared(in vec2 x, in vec2 y) {\n    return dot(x-y, x-y);\n}\n\nfloat calcDistance(in vec2 c, out float trapDist)\n{\n    vec2 z, dz;\n    float m2;\n\n    vec2 trap = vec2(.5, 2.)*(sin(1.5*time));\n\t#if USE_NOISE\n    trap += 2.5*(2.*fbm(c*1000. + 3.*(1. + sin(.6*time))).xy - 1.);\n\t#endif\n    trapDist = 1e20;\n    for( int i=0; i<150; i++ ) {\n\t\t\/\/ Z' -> 2*Z*Z' + 1\n        dz = 2.0*cxMult(z, dz) + vec2(1.0,0.0);\n\n        \/\/ Z -> Z^2 + c\n        z = c + cxMult(z, z);\n\n        m2 = cxModuloSquared(z);\n        trapDist = min(trapDist, distanceSquared(z, trap));\n        if( m2>1024. )\n            break;\n    }\n\n    trapDist = sqrt(trapDist)*2.;\n\n    \/\/ distance estimation: G\/|G'|\n    return sqrt(m2\/cxModuloSquared(dz)) * log(m2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy \/ iResolution.xy;\n    p.x *= iResolution.x\/iResolution.y;\n\n    float zoom = 1.\/(250. + 100.*(1. + sin(time)));\n    if (iMouse.w > .001) zoom = 1.\/(exp(10.*iMouse.x\/iResolution.x)*100.);\n\tp = vec2(-0.53453,0.5263) + p*zoom;\n\n    float trapDist;\n    float d = calcDistance(p, trapDist)*1000.;\n\n    float c1 = d*5.;\n\tfloat c2 = pow( clamp( .3*trapDist, 0.0, 1.0 ), 2.0 );\n\tfloat c3 = pow( clamp( 1.7*trapDist, 0.0, 1.0 ), 2.0 );\n\/\/    float c3 = trapDist*5.;\n\n\tvec3 col1 = 0.5 + 0.5*sin( 3.0 + 4.0*c2 + vec3(0.0,0.5,1.0) );\n\tvec3 col2 = 0.5 + 0.5*sin( 4.1 + 2.0*c3 + vec3(1.0,0.5,0.0) );\n\tvec3 col = 2.0*sqrt(c1*col1*col2);\n\n\tfragColor = vec4( col, 1.0 );\n\n}","name":"","description":"","type":"image"}]}}