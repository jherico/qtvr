{"Shader":{"ver":"0.1","info":{"id":"MtjGDD","date":"1429238311","viewed":753,"name":"ngTile0","username":"netgrind","description":"kisrhombille tiling","likes":5,"published":3,"flags":0,"tags":["colorful","hue","tile","netgrind","kisrhombille"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/uncomment the line below to kill the color\n\/\/#define bw\n\n#define PI 3.1415\n\nvec4 hue(vec4 color, float shift) {\n\n    const vec4  kRGBToYPrime = vec4 (0.299, 0.587, 0.114, 0.0);\n    const vec4  kRGBToI     = vec4 (0.596, -0.275, -0.321, 0.0);\n    const vec4  kRGBToQ     = vec4 (0.212, -0.523, 0.311, 0.0);\n\n    const vec4  kYIQToR   = vec4 (1.0, 0.956, 0.621, 0.0);\n    const vec4  kYIQToG   = vec4 (1.0, -0.272, -0.647, 0.0);\n    const vec4  kYIQToB   = vec4 (1.0, -1.107, 1.704, 0.0);\n\n    \/\/ Convert to YIQ\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I      = dot (color, kRGBToI);\n    float   Q      = dot (color, kRGBToQ);\n\n    \/\/ Calculate the hue and chroma\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    \/\/ Make the user's adjustments\n    hue += shift;\n\n    \/\/ Convert back to YIQ\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    \/\/ Convert back to RGB\n    vec4    yIQ   = vec4 (YPrime, I, Q, 0.0);\n    color.r = dot (yIQ, kYIQToR);\n    color.g = dot (yIQ, kYIQToG);\n    color.b = dot (yIQ, kYIQToB);\n\n    return color;\n}\n\nfloat ease(float t) {\n  \/\/return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n   \/\/ return -0.5 * (cos(PI * t) - 1.0);\n    float p = 2.0 * t * t;\n  return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float i = iGlobalTime;\n    vec2 uv = fragCoord.xy-iResolution.xy*.5;\n\tuv = uv \/ iResolution.xx*(4.+iMouse.x*.03);\n    float d = length(uv);\n    float a = atan(uv.y,uv.x)+(sin(d*.3+i*.3)*(iMouse.y\/iResolution.y*2.)+i*.2);\n    d = pow(d,1.5);    \n    uv.y = sin(a)*d;\n    uv.x = cos(a)*d;\n    float j = mod(i,3.5);\n    \n    uv.y+= ease(j) * ceil(clamp(1.0-j,0.0,1.0));\n    uv.x+=ease((clamp(j,1.5,3.0)-1.5)\/1.5)*2.0; \n    \n    float f = (abs(mod(uv.x,1.0)-.5)-.45)*20.;\n    f = max(f, (abs(mod(uv.y,0.5)-.25)-.2)*20.);\n    \n    f = max(f, (abs(mod(uv.y+uv.x*1.5,1.0)-.5)-.4)*10.);\n    f = max(f, (abs(mod(uv.y+uv.x*-1.5,1.0)-.5)-.4)*10.);\n    \n    f = max(f, (abs(mod(uv.y+uv.x*0.5,1.0)-.5)-.45)*20.);\n    f = max(f, (abs(mod(uv.y+uv.x*-0.5,1.0)-.5)-.45)*20.);\n    \n    vec4 c = vec4(0.0,0.0,0.0,1.0);\n    \/\/c.r = f;\n    c.b = cos(f+sin(i))*.5+.5;\n    c.g = abs(f);\n    #ifdef bw\n    \tc.rgb = vec3(f);\n    #endif\n    c = hue(c,i+d*.3);\n   \tfragColor = c;\n}","name":"","description":"","type":"image"}]}}