{"Shader":{"ver":"0.1","info":{"id":"ltlGzj","date":"1423468682","viewed":756,"name":"cubeOcube","username":"Fred1024","description":"First try with ray casting and with GLSL,<br\/>Advice is more than welcome <img src=\"\/img\/emoticonHappy.png\"\/><br\/><br\/>","likes":0,"published":3,"flags":0,"tags":["3d","raycast","shadows"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ ~ cubeOcube ~\n\/\/ Frederic Heintz\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define FOV_DEGRE 62.0\n#define LIGHT_RANGE 5.0\n\nivec3 ptr;\nvec3 fraction;\nvec3 lightPos;\nvec3 mask;\n\nvec3 colorFromPtr( in ivec3 ptr )\n{\n    float r = (sin( (float(ptr.x) + 0.1) * 2.0) * sin( (float(ptr.y) + 0.5) * 1.1) * sin( (float(ptr.z) + 0.8) * 1.0));\n    float b = (sin( (float(ptr.x) + 0.6) * 1.2) * sin( (float(ptr.y) + 0.2) * 1.0) * sin( (float(ptr.z) + 0.5) * 1.2));\n    float g = (1.0 - r - b);\n    return clamp(vec3(r, g, b), vec3(1.0, 0.5, 0.0), vec3(1.0, 1.0, 1.0));\n}\n\nbool mapCube( ivec3 coord )\n{\n    if( coord.y < 0)\treturn true;\n\/\/    if( coord.y > 1)\treturn true;\n    return false;\n}\n\nbool computeRayHit( in vec3 ray, in float dist )\n{\n    vec3 normalsSign = -sign(ray);\n    vec3 dots = vec3(ray.x * normalsSign.x, ray.y * normalsSign.y, ray.z * normalsSign.z);\n\n    ivec3 ptrSteps = ivec3(1, 1, 1); \/\/-normalsSign);\n    if(ray.x < 0.0)\tptrSteps.x = -1;\n    if(ray.y < 0.0)\tptrSteps.y = -1;\n    if(ray.z < 0.0)\tptrSteps.z = -1;\n    \n    vec3 crossValues = max(vec3(0.0, 0.0, 0.0), normalsSign);\t\/\/ 0.0 or 1.0\n\n    for(int i = 0; i < 64; i++)\n    {\n        vec3 vDist = ((1.0 - crossValues - fraction) * normalsSign) \/ dots;\n\n        float shortestDist = min(min( vDist.x, vDist.y), vDist.z);\n        dist -= shortestDist;\n        if(dist <= 0.0)\n        {\n            \/\/ far dist or light dist reached\n\t\t    break;\n        }\n\n        \/\/ to current cube exit coord\n        fraction = fraction + (ray * shortestDist);\n        \n        \/\/ which side\n        if(all(lessThanEqual( vDist.xx, vDist.yz)))  \tmask = vec3(1.0, 0.0, 0.0);\t  \/\/ cut X ?\n        else if(vDist.y <= vDist.z)         \t\t\tmask = vec3(0.0, 1.0, 0.0);   \/\/ cut Y ?\n        else            \t\t\t\t\t\t\t\tmask = vec3(0.0, 0.0, 1.0);\t  \/\/ then must be cuting Z\n        \n        \/\/ next cube ( the cube we should be entering )\n\t\tivec3 nextPtr = ptr + ptrSteps * ivec3(mask);\n        if( mapCube( nextPtr ) )\n        {\n            return true;\n        }\n        \n        \/\/ bumping on a cube edge ?\n        vec3 temp = (1.0 - mask) * abs( fraction - 0.5 );\n        float distToClosestSide = max( max( temp.x, temp.y ), temp.z);\n        if(distToClosestSide > 0.4)\n        {\n            return true;\n        }\n\n        \/\/ next cube is now current\n        ptr = nextPtr;\n        fraction = mix(fraction, crossValues, mask);\t\/\/ got to reset the crossing coord component (float imprecision)\n\t}\n    return false;\n}\n\nvec3 shadeHit( in vec3 ray, in vec3 hitNormal, in vec3 surfaceColor, in float ao )\n{\n    vec3 lightDir = (lightPos - (vec3(ptr) + fraction));\n    float lightDist = length(lightDir);\n    lightDir = normalize(lightDir);\n    float lightDot = clamp(dot(lightDir, hitNormal), 0.0, 1.0);\n\n    float spec = 0.0;\n\tfloat lightI = 0.0;\n    if(lightDot >= 0.0 && lightDist < LIGHT_RANGE)\n    {\n\t    if( computeRayHit(lightDir, lightDist) == false)\n        {\n\t        lightI = lightDot * pow(1.0 - (lightDist \/ LIGHT_RANGE), 2.0) * 1.6;\n\t\t    spec = clamp(dot(ray, normalize(lightDir - hitNormal)), 0.0, 1.0);\n\t\t    spec = pow(spec, 40.0) * 0.8;\n        }\n    }\n\n    return( (surfaceColor * 0.05 * ao) + (surfaceColor * lightI) + spec );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    lightPos = vec3(0.8 - sin(iGlobalTime * 0.15) * 1.8, 0.9 - sin(iGlobalTime * 0.25) * 0.7, cos(iGlobalTime * 0.17) * 0.7);\n\n    \/\/ Camera setup\n    float height = (iMouse.y \/ iResolution.y) * 6.0;\n    vec3 camPos = vec3(0.5, 0.1 + height, 0.5);\n    camPos = mix(camPos, lightPos, 0.2);\n\tvec3 camTgt = vec3(lightPos.x, 0.5 + (height * 0.5), lightPos.z);\n\n    \/\/ A view matrix\n    vec3 dir = normalize(camTgt - camPos);\t\t\t\t\t\/\/ z\n    vec3 side = normalize(cross(dir, vec3(0.0, 1.0, 0.0)));\t\/\/ side = z X up (with dir and up not || )\n    vec3 up = normalize(cross(side, dir));\t\t\t\t\t\/\/ up = sideXdir\n    mat3 viewMatrix = mat3(side.x, up.x, dir.x, side.y, up.y, dir.y, side.z, up.z, dir.z);\n    \n    \/\/ Ray setup\n    float tangF = tan(radians(FOV_DEGRE));\n    float ratio = iResolution.y \/ iResolution.x;\n    float rX = (((gl_FragCoord.x \/ iResolution.x) * 2.0) - 1.0) * tangF;\n    float rY = (((gl_FragCoord.y \/ iResolution.y) * 2.0) - 1.0) * tangF * ratio;\n    vec3 ray = normalize(vec3(rX, rY, 1.0));\n    \n    \/\/ apply camera transform to ray\n    ray = ray * viewMatrix;\n\n\t\/\/ search hit\n    ptr = ivec3(floor(camPos));\n    fraction = fract(camPos);\n\n    \/\/ pick color\n    vec3 color = vec3(1.0, 0.5, 0.0) * 0.07;\n    if( computeRayHit( ray, 16.0 ) == true)\n    {\n\t\tvec2 testCoord;\n        vec3 normalsSign = -sign(ray);\n\t    vec3 normal = normalsSign * mask;\n        testCoord.x = (fraction.y * mask.x) + (fraction.x * mask.y) + (fraction.x * mask.z);\n        testCoord.y = (fraction.z * mask.x) + (fraction.z * mask.y) + (fraction.y * mask.z);\n\n        float ao = 1.0;\n        vec3 surfaceColor = vec3(211.0 \/ 255.0, 74.0 \/ 255.0, 47.0 \/ 255.0);\n        if(any(lessThanEqual( vec4(testCoord, 0.9, 0.9), vec4(0.1, 0.1, testCoord))))\n        {\n            \/\/ cube edge\n        \tsurfaceColor = colorFromPtr( ptr );\n            float g0 = 5.0 - abs(testCoord.x - 0.5) * 8.0;\n            float g1 = 5.0 - abs(testCoord.y - 0.5) * 8.0;\n            ao = min(min(g0, g1), g0 * g1 * 0.25);\n        }\n\n        color = shadeHit( ray, normal, surfaceColor, ao );\n    }\n\n    \/\/ show light\n    vec3 hitPos = vec3(ptr) + fraction;\n\tvec3 lightDir = (lightPos - camPos);\n    float lightDist = length(lightDir);\n    if(lightDist < length(hitPos - camPos))\n    {\n        lightDir = normalize(lightDir);\n        float lightQ = max( 0.0, dot(ray, lightDir));\n        color.xyz += clamp(vec3(pow(lightQ, 1000.0)), 0.0, 1.0);\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n\n","name":"","description":"","type":"image"}]}}