{"Shader":{"ver":"0.1","info":{"id":"Xlf3zf","date":"1423670655","viewed":758,"name":"DDE","username":"eiffie","description":"Marching thru an iso-mess using an extra DE calc to slow the march down only where needed. Left side is just a fudge factor slowing errrything down. It both penetrates and fails to march to the surface. Right side is perfection! <img src=\"\/img\/emoticonHappy.png\"\/>","likes":6,"published":3,"flags":0,"tags":["isosurface","gradientmarch","dde"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/DDE by eiffie (directional distance estimate using a gradient)\n\/\/The idea is to find a method of optimal marching when analytic gradients fail (or are unknown).\n\/\/This isn't it! But it is a first step. :)\n\n\/\/We need to know how the surface changes in the direction we are marching so the first term is\n\/\/how far ahead we should look based on an initial DE check. It is critical and highly dependant.\n\/\/Second term is still a neccessary fudge factor :( \n\/\/Third term is for comparison (left side). \n#define GRADIENT_DELTA 0.4\n#define FUDGE_FACTOR 0.5\n#define COMPARE_FUDGE_FACTOR 0.2\n\n\n#define time iGlobalTime\n#define size iResolution\n\n\nfloat DE(vec3 p0)\n{\n\tvec3 p=p0+sin(p0.yzx*4.0+2.4*sin(p0.zxy*5.0+time)+time*0.7)*0.5;\n\tfloat d=length(p)-1.0;\n\treturn d;\n}\nvec2 fragCoord;\nvec2 DDE(vec3 p, vec3 rd){\n\tfloat d1=DE(p);\n    if(fragCoord.x<size.x*0.5)return vec2(d1,d1*COMPARE_FUDGE_FACTOR);\n\tfloat dt=GRADIENT_DELTA*log(d1+1.0);\n\tfloat d2=DE(p+rd*dt);\n\tdt\/=max(dt,d1-d2);\n\treturn vec2(d1,FUDGE_FACTOR*log(d1*dt+1.0));\n}\n\nfloat rndStart(vec2 co){return fract(sin(dot(co,vec2(123.42,117.853)))*412.453);}\n\nmat3 lookat(vec3 fw,vec3 up){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,up));return mat3(rt,cross(rt,fw),fw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 iFragCoord ){\n\tfloat pxl=4.0\/size.y;\/\/find the pixel size\n\tfloat tim=time*0.3;\n\tfragCoord = iFragCoord;\n\t\/\/position camera\n\tvec3 ro=vec3(cos(tim),0.5,sin(tim))*3.0;\n\tvec3 rd=normalize(vec3((2.0*fragCoord.xy-size.xy)\/size.y,2.0));\n\trd=lookat(-ro,vec3(0.0,1.0,0.0))*rd;\n\t\/\/ro=eye;rd=normalize(dir);\n\tvec3 bcol=vec3(1.0);\n\t\/\/march\n\t\n\tfloat t=DDE(ro,rd).y*rndStart(fragCoord.xy),d,od=1.0;\n\tvec4 col=vec4(0.0);\/\/color accumulator\n\tfor(int i=0;i<64;i++){\n\t\tvec2 v=DDE(ro+rd*t,rd);\n\t\td=v.x;\/\/DE(ro+rd*t);\n\t\tfloat px=pxl*(1.0+t);\n\t\tif(d<px){\n            vec3 mcol=0.5*abs(sin((ro+rd*t)*30.0));\n\t\t\tmcol+=mcol.gbr;\n\t\t\tmcol*=max(0.0,1.0-d\/od)*10.0*exp(-t);\n\t\t\tif(d<0.0){\n\t\t\t\tfragColor=vec4(1.0,0.0,0.0,1.0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfloat alpha=(1.0-col.w)*clamp(1.0-d\/(px),0.0,1.0);\n\t\t\tcol+=vec4(clamp(mcol,0.0,1.0),1.0)*alpha;\n\t\t\tif(col.w>0.9)break;\n\t\t}\n\t\tod=d;\n\t\tt+=v.y;\/\/d;\n\t\tif(t>10.0)break;\n\t}\n\tcol.rgb+=bcol*(1.0-clamp(col.w,0.0,1.0));\n\n\tfragColor=vec4(col.rgb,1.0);\n} ","name":"","description":"","type":"image"}]}}