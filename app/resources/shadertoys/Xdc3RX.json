{"Shader":{"ver":"0.1","info":{"id":"Xdc3RX","date":"1451151548","viewed":195,"name":"oldskool plasma","username":"Harha","description":"Some plasma functions combined with 4x4 dithering.","likes":7,"published":3,"flags":0,"tags":["oldschool","plasma","dithering"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define time iGlobalTime * 1.0\n#define scale 8.0\n#define resolution 1.0 \/ 2.0\n#define background 0.25\n#define PI 3.14159265359\n\n\/*\n\tBrightness function adapted from: https:\/\/github.com\/hughsk\/glsl-luma\n\tDithering functions adapted from: https:\/\/github.com\/hughsk\/glsl-dither\n\tEdit: Eh, I just realized that the 8x8 R texture is made for this.\n*\/\nfloat luma(in vec4 color) {\n    return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\n\nfloat dither4x4(in vec2 position, in float brightness) {\n    int x = int(mod(position.x, 4.0));\n\tint y = int(mod(position.y, 4.0));\n\tint index = x + y * 4;\n\tfloat limit = 0.0;\n\n\tif (x < 8) {\n\t\tif (index == 0) limit = 0.0625;\n\t\tif (index == 1) limit = 0.5625;\n    \tif (index == 2) limit = 0.1875;\n    \tif (index == 3) limit = 0.6875;\n    \tif (index == 4) limit = 0.8125;\n    \tif (index == 5) limit = 0.3125;\n    \tif (index == 6) limit = 0.9375;\n    \tif (index == 7) limit = 0.4375;\n    \tif (index == 8) limit = 0.25;\n    \tif (index == 9) limit = 0.75;\n    \tif (index == 10) limit = 0.125;\n    \tif (index == 11) limit = 0.625;\n    \tif (index == 12) limit = 1.0;\n    \tif (index == 13) limit = 0.5;\n    \tif (index == 14) limit = 0.875;\n    \tif (index == 15) limit = 0.375;\n        limit *= 0.75;\n  }\n\n  return brightness < limit ? 0.0 : 1.0;\n}\n\nvec4 dither4x4(in vec2 position, in vec4 color) {\n\treturn vec4(color.rgb * dither4x4(position, luma(color)), 1.0);\n}\n\n\/*\n\tPlasma functions adapted from: http:\/\/www.bidouille.org\/prog\/plasma\n\tAt first I tried to make up my own, but as I didn't like the outcome I decided to use the ones in above link.\n\tIt's surprisingly difficult to come up with good looking color combinations.\n*\/\nfloat v1(in vec2 uv)\n{\n    return sin(uv.x * scale + time);\n}\n\nfloat v2(in vec2 uv)\n{\n    return sin(scale * (uv.x * sin(time \/ 2.0) + uv.y * cos(time \/ 3.0)) + time);\n}\n\nfloat v3(in vec2 uv)\n{\n    float cx = uv.x + 0.5 * sin(time \/ 5.0);\n    float cy = uv.y + 0.5 * cos(time \/ 3.0);\n    return sin(sqrt(128.0 * (cx * cx + cy * cy) + 1.0) + time);\n}\n\nfloat v(in vec2 uv)\n{\n    return v1(uv) + v2(uv) + v3(uv);\n}\n\nvoid mainImage(out vec4 c, in vec2 f)\n{\n    \/\/ Center & scale the uv coordinates\n\tvec2 uv = (f.xy \/ iResolution.xy) - vec2(0.5);\n    uv.x *= iResolution.x \/ iResolution.y;\n   \tc = vec4(0.0);\n    \n    \/\/ Plasma\n    c.r += sin(v(uv) * PI * 0.16);\n    c.g += sin(v(uv) * PI * 0.33);\n    c.b += sin(v(uv) * PI * 0.66);\n    \n    \/\/ Dither + mix with background color\n    c = max(dither4x4(f * resolution, c), background);\n}","name":"","description":"","type":"image"}]}}