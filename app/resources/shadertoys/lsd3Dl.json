{"Shader":{"ver":"0.1","info":{"id":"lsd3Dl","date":"1452854646","viewed":401,"name":"Rocket City","username":"eiffie","description":"Mouse to aim (pitch yaw), UP ARROW to thrust, DOWN ARROW to break, RIGHT\/LEFT ARROWS to roll.","likes":25,"published":3,"flags":48,"tags":["flying","flightcontrols"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/Rocket City by eiffie (although there are no rockets and there is little if any\n\/\/resemblance to a city this is what I called it)\n\n\/\/I just wanted to make a reusable flight control but then messed that up with\n\/\/collision detection.\n\nvec3 Tile(vec3 p){vec3 a=vec3(8.0);return abs(mod(p,a)-a*0.5)-a*0.25;}\nfloat DERect(vec4 z,vec3 r){return length(max(abs(z.xyz)-r,0.0))\/z.w;}\nconst float mr=0.5, mxr=0.975, scale = 2.52;\nconst vec3 rc=vec3(3.31,2.79,4.11),rcL=vec3(2.24,1.88,2.84);\nconst vec4 p0=vec4(4.0,0.0,-4.0,1.0);\n\nfloat DE(in vec3 p)\n{\n\tp=Tile(p);\n\tvec4 z = vec4(p,1.0);\n\tfloat dG=1000.0;\n\tfor (int n = 0; n<5; n++) {\n\t\tz.xyz=clamp(z.xyz, -1.0, 1.0) *2.0-z.xyz;\n\t\tz*=scale\/clamp(max(dot(z.xy,z.xy),max(dot(z.xz,z.xz),dot(z.yz,z.yz))),mr,mxr);\n\t\tz+=p0;\n\t\tif(n==2){dG=DERect(z,rcL);}\n\t}\n\tfloat ds=DERect(z,rc);\n\treturn min(dG,ds);\n}\nvec4 mcol;\nfloat CE(in vec3 p){\n\tp=Tile(p);\n\tvec4 z = vec4(p,1.0);\n\tfloat dG=1000.0;\n\tvec4 mc=vec4(0.0);\n\tfor (int n = 0; n<5; n++) {\n\t\tz.xyz=clamp(z.xyz, -1.0, 1.0) *2.0-z.xyz;\n\t\tz*=scale\/clamp(max(dot(z.xy,z.xy),max(dot(z.xz,z.xz),dot(z.yz,z.yz))),mr,mxr);\n\t\tz+=p0;\n\t\tif(n==4)mc=vec4(vec3(0.5,0.3,0.2)+z.xyz*0.05,0.25);\n\t\telse if(n==2){dG=DERect(z,rcL);}\n\t}\n\tfloat ds=DERect(z,rc);\n\tif(dG<ds)mcol+=vec4(0.5,0.6,0.9,0.9)+vec4(z.xyz*0.025,0.0);\n\telse mcol+=mc;\n\treturn min(dG,ds);\n}\n\nvec3 sunDir=normalize(vec3(0.7,1.0,-0.7)),sunColor=vec3(1.0,0.99,0.9),skyColor=vec3(0.25,0.26,0.27);\n\nvec3 Backdrop( in vec3 rd ){\n\treturn skyColor+rd*0.05+sin(rd.yzx*5.0+2.4*sin(rd.zxy*3.0))*0.05+sunColor*(max(0.0,dot(rd,sunDir))*0.2+pow(max(0.0,dot(rd,sunDir)),256.0));\n}\n\n\nfloat rnd;\nvoid randomize(in vec2 p){rnd=fract(float(iFrame)+sin(dot(p,vec2(13.3145,17.7391)))*317.7654321);}\n\nfloat ShadAO(in vec3 ro, in vec3 rd){\n\tfloat t=0.0,s=1.0,d,mn=0.01+0.04*rnd;\n\tfor(int i=0;i<12;i++){\n\t\td=max(DE(ro+rd*t)*1.5,mn);\n\t\ts=min(s,d\/t+t*0.5);\n\t\tt+=d;\n\t}\n\treturn s;\n}\n\nvec3 scene(in vec3 ro, in vec3 rd){\n\tfloat d=DE(ro)*rnd*0.5,t=d,od=1.0,pxl=2.0\/iResolution.y;\n\tvec4 dm=vec4(1000.0),tm=vec4(-1.0);\n\tfor(int i=0;i<78;i++){\n\t\td=DE(ro+rd*t);\n\t\tif(d<pxl*t && d<od && tm.w<0.0){dm=vec4(abs(d),dm.xyz);tm=vec4(t,tm.xyz);}\/\/push\n\t\tt+=d;\n\t\tod=d;\n\t\tif(t>20.0 || d<0.00001)break;\n\t}\n\tif(d<pxl*t && d<dm.x){dm.x=d;tm.x=t;}\n\tvec3 col=Backdrop(rd),fcol=col;\n\tfor(int i=0;i<4;i++){\/\/unrolled back to front\n\t\tif(tm.x<0.0)break;\n\t\tfloat px=pxl*tm.x;\n\t\tvec3 so=ro+rd*tm.x;\n\t\tmcol=vec4(0.0);\n\t\tvec3 ve=vec3(px,0.0,0.0);\n\t\tfloat d1=CE(so);\n\t\tvec3 dn=vec3(CE(so-ve.xyy),CE(so-ve.yxy),CE(so-ve.yyx));\n\t\tvec3 dp=vec3(CE(so+ve.xyy),CE(so+ve.yxy),CE(so+ve.yyx));\n\t\tvec3 N=(dp-dn)\/(length(dp-vec3(d1))+length(vec3(d1)-dn));\n\t\tvec3 L=sunDir;\n\t\tvec3 scol=mcol.rgb*0.14;\n\t\tvec3 R=reflect(rd,N);\n\t\tfloat v=dot(-rd,N),l=dot(N,L);\n\t\tfloat shad=ShadAO(so+N*0.001,L);\n\t\tvec3 cc=vec3(0.6,0.8,1.0),lc=vec3(1.0,0.8,0.6);\n\t\tfloat cd=exp(-distance(ro,so));\n\t\tfloat spcl=pow(clamp(dot(R,L),0.0,1.0),10.0),spcc=pow(max(0.0,dot(R,-rd)),1.0+cd)*0.25;\n\t\tscol=scol*(cd*v*cc+shad*l*lc)+(cd*spcc*cc+shad*spcl*lc)*mcol.a;\n\t\tscol=clamp(scol,0.0,1.0);\n\t\tfloat fog=min(pow(tm.x*0.2,1.33)*0.54,1.0);\n\t\tscol=mix(scol,fcol,fog);\n\t\tcol=mix(scol,col,clamp(dm.x\/px,0.0,1.0));\n\t\tdm=dm.yzwx;tm=tm.yzwx;\n\t}\n\tif(col!=col)col=vec3(1.0,0.0,0.0);\n\treturn clamp(col*2.0,0.0,1.0);\n}\n\n\/\/some quaterion math just to be different\n#define quat vec4\nquat qid(){return quat(0.0,0.0,0.0,1.0);}\nquat qmulq(quat q1, quat q2){\/\/multiply two quats\n\treturn quat(q1.xyz*q2.w+q2.xyz*q1.w+cross(q1.xyz,q2.xyz),(q1.w*q2.w)-dot(q1.xyz,q2.xyz));\n}\nquat qinv(quat q){return quat(-q.xyz,q.w)\/dot(q,q);}\/\/inverse quaternion\nvec3 qmulv(quat q, vec3 p){return qmulq(q,qmulq(quat(p,0.0),qinv(q))).xyz;}\/\/rotate a vector\n\/* \/\/extra quaternion functions\nquat aa2q(vec3 axis, float angle){return quat(normalize(axis)*sin(angle*0.5),cos(angle*0.5));}\nquat q2aa(quat q){return quat(q.xyz\/sqrt(1.0-q.w*q.w),acos(q.w)*2.0);}\/\/assumed q is normalized coverts to axis&angle\nquat qlookat(vec3 v){return aa2q(vec3(-v.y,v.x,0.0),acos(v.z\/length(v)));}\/\/point in direction v\nvec3 vmulq(vec3 p, quat q){return qmulq(qinv(q),qmulq(quat(p,0.0),q)).xyz;}\/\/inverse rotation\nquat qslerp(quat q1, quat q2, float f){\n\tfloat d=dot(q1,q2),theta=acos(abs(d)),ost=(1.0\/sin(theta)); \n\treturn normalize(q1*sin(theta*(1.0-f))*ost*sign(d)+q2*sin(theta*f)*ost); \n}\n*\/\nvec4 load(in int re) {\n    return texture2D(iChannel0, (0.5+vec2(re,0.0)) \/ iChannelResolution[0].xy, -100.0 );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\trandomize(fragCoord);\n\tvec3 rd=normalize(vec3((2.0*fragCoord-iResolution.xy)\/iResolution.y,1.0));\n\tvec3 ro=load(0).xyz;\n\tquat fw=load(1);\n\trd=qmulv(fw,rd);\n\t\/\/ro=eye;rd=normalize(dir);\n\tfragColor=vec4(scene(ro,rd),1.0);\n}","name":"","description":"","type":"image"},{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/now with autopilot, thanks Fabrice!\n\/\/#define USE_AUTO_PILOT\n\n#define THRUST 0.04*iTimeDelta\n#define ROLL 1.0*iTimeDelta\n#define ROTATE 4.0*iTimeDelta\n#define TOO_CLOSE 0.01\n\n#define LEFT_ARROW 37\n#define UP_ARROW 38\n#define RIGHT_ARROW 39\n#define DOWN_ARROW 40\n\n\/\/originally from iq but messed up by me\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\n\nvec4 load(in int re) {\n    return texture2D(iChannel0, (0.5+vec2(re,0.0)) \/ iChannelResolution[0].xy, -100.0 );\n}\n\nvoid store( in int re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord) {\n    fragColor = ( isInside(fragCoord,vec2(re,0.0)) > 0.0 ) ? va : fragColor;\n}\n\nbool KeyDown(in int key){return (texture2D(iChannel1,vec2((float(key)+0.5)\/256.0, 0.25)).x>0.0);}\n\n\/\/some quaterion math just to be different\n#define quat vec4\nquat qid(){return quat(0.0,0.0,0.0,1.0);}\nquat qmulq(quat q1, quat q2){\/\/multiply two quats\n\treturn quat(q1.xyz*q2.w+q2.xyz*q1.w+cross(q1.xyz,q2.xyz),(q1.w*q2.w)-dot(q1.xyz,q2.xyz));\n}\nquat aa2q(vec3 axis, float angle){return quat(normalize(axis)*sin(angle*0.5),cos(angle*0.5));}\nquat qinv(quat q){return quat(-q.xyz,q.w)\/dot(q,q);}\/\/inverse quaternion\nvec3 qmulv(quat q, vec3 p){return qmulq(q,qmulq(quat(p,0.0),qinv(q))).xyz;}\/\/rotate a vector\nquat qpyr(vec3 o){ o*=0.5; vec3 s=sin(o),c=cos(o); \/\/rotate pitch,yaw,roll in that order\n\treturn quat(s.x*c.y*c.z+s.y*c.x*s.z, s.y*c.x*c.z-s.x*c.y*s.z, s.x*s.y*c.z+s.z*c.x*c.y, c.x*c.y*c.z-s.x*s.y*s.z);\n}\n\n\/*\/\/extras\nquat q2aa(quat q){return quat(q.xyz\/sqrt(1.0-q.w*q.w),acos(q.w)*2.0);}\/\/assumed q is normalized coverts to axis&angle\nquat qlookat(vec3 v){return aa2q(vec3(-v.y,v.x,0.0),acos(v.z\/length(v)));}\/\/point in direction v\nvec3 vmulq(vec3 p, quat q){return qmulq(qinv(q),qmulq(quat(p,0.0),q)).xyz;}\/\/inverse rotation\nquat qslerp(quat q1, quat q2, float f){\n\tfloat d=dot(q1,q2),theta=acos(abs(d)),ost=(1.0\/sin(theta)); \n\treturn normalize(q1*sin(theta*(1.0-f))*ost*sign(d)+q2*sin(theta*f)*ost); \n}\n*\/\n\n\/\/repeated code...\nvec3 Tile(vec3 p){vec3 a=vec3(8.0);return abs(mod(p,a)-a*0.5)-a*0.25;}\nfloat DERect(vec4 z,vec3 r){return length(max(abs(z.xyz)-r,0.0))\/z.w;}\nconst float mr=0.5, mxr=0.975, scale = 2.52;\nconst vec3 rc=vec3(3.31,2.79,4.11),rcL=vec3(2.24,1.88,2.84);\nconst vec4 p0=vec4(4.0,0.0,-4.0,1.0);\n\nfloat DE(in vec3 p){\/\/for collision detection\n\tp=Tile(p);\n\tvec4 z = vec4(p,1.0);\n\tfloat dG=1000.0;\n\tfor (int n = 0; n<5; n++) {\n\t\tz.xyz=clamp(z.xyz, -1.0, 1.0) *2.0-z.xyz;\n\t\tz*=scale\/clamp(max(dot(z.xy,z.xy),max(dot(z.xz,z.xz),dot(z.yz,z.yz))),mr,mxr);\n\t\tz+=p0;\n\t\tif(n==2){dG=DERect(z,rcL);}\n\t}\n\tfloat ds=DERect(z,rc);\n\treturn min(dG,ds)-0.005;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.y>0.5 || fragCoord.x>1.5)discard;\n\tvec4 pos;\n\tquat qrot;\n\tif(iFrame<2){\n\t\tpos=vec4(0.1,0.0,0.0,2.0*iTimeDelta);\n\t\tqrot=normalize(vec4(0.1,0.2,0.3,0.8));\n\t}else{\n\t\tpos=load(0);\n\t\tqrot=load(1);\n\t\tvec3 fw=vec3(0.0,0.0,1.0);\n\t\tfw=qmulv(qrot,fw);\n\t\tvec3 newp=pos.xyz+fw*pos.w;\n\t\tif(DE(newp)>TOO_CLOSE)pos.xyz=newp;\n\t\telse{\/\/per Dave kinda\n\t\t\tif(DE(vec3(pos.xy,newp.z))>TOO_CLOSE){pos.z=newp.z;}\n\t\t\tif(DE(vec3(pos.x,newp.y,pos.z))>TOO_CLOSE){pos.y=newp.y;} \n\t\t\tif(DE(vec3(newp.x,pos.yz))>TOO_CLOSE){pos.x=newp.x;}\n\t\t}\n\t\tif(KeyDown(UP_ARROW))pos.w+=THRUST;\n\t\tif(KeyDown(DOWN_ARROW))pos.w-=THRUST;\n\t\tfloat roll=0.0;\n\t\tif(KeyDown(LEFT_ARROW))roll-=ROLL;\n\t\tif(KeyDown(RIGHT_ARROW))roll+=ROLL;\n\t\tvec2 mous=vec2(0.0);\n\t\tif(iMouse.z>0.0){\n\t\t\tmous.xy=(iMouse.xy-iMouse.zw)\/iResolution.xy;\n\t\t}\n#ifdef USE_AUTO_PILOT\n        else{\/\/I'm pretty sure this is how google cars steer\n\t\t\tfloat d=DE(pos.xyz);\n\t\t\tnewp=qmulv(qrot,vec3(d,0.0,0.0));\n\t\t\tfloat d2=DE(pos.xyz+newp);\n\t\t\tmous.x=sign(d2-d)*ROTATE\/(0.1+2.0*d*d);\n\t\t}\n#endif\n        quat qp=qpyr(vec3(-mous.y*ROTATE,mous.x*ROTATE,roll));\/\/finally did the math!!\n\t\t\/\/quat qp=aa2q(vec3(1.0,0.0,0.0),-mous.y*ROTATE);\/\/pitch,yaw,roll rotations\n\t\t\/\/quat qy=aa2q(vec3(0.0,1.0,0.0),mous.x*ROTATE);\/\/there must be a way to\n\t\t\/\/quat qr=aa2q(vec3(0.0,0.0,1.0),roll);\t\t\/\/cram these into a quat at once?\n\t\t\/\/qrot=qmulq(qrot,qp);\n\t\t\/\/qrot=qmulq(qrot,qy);\n\t\tqrot=normalize(qmulq(qrot,qp));\/\/normalize before saving\n\t}\n\tstore(0,pos,fragColor,fragCoord);\/\/position,velocity\n\tstore(1,qrot,fragColor,fragCoord);\/\/rotation\n}","name":"","description":"","type":"buffer"}]}}