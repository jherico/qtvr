{"Shader":{"ver":"0.1","info":{"id":"4tsGRl","date":"1424317610","viewed":799,"name":"Plane Feature Points","username":"paniq","description":"finding feature points of planes with a simplified SVD","likes":4,"published":3,"flags":0,"tags":["mattdamon"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\n\/\/ minimal SVD implementation for calculating feature points from hermite data\n\/\/ works in C++ and GLSL\n\n#define PLANE_COUNT 3\n\n\n\/\/ SVD\/QEF parts are public domain\n\n#define SVD_NUM_SWEEPS 10\n\n\/\/ GLSL prerequisites\n\n#define IN(t,x) in t x\n#define OUT(t, x) out t x\n#define INOUT(t, x) inout t x\n#define rsqrt inversesqrt\n\n#define SWIZZLE_XYZ(v) v.xyz\n\n\/\/ SVD\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst float Tiny_Number = 0.1;\n\nvoid givens_coeffs_sym(float a_pp, float a_pq, float a_qq, OUT(float,c), OUT(float,s)) {\n    if (a_pq == 0.0) {\n        c = 1.0;\n        s = 0.0;\n        return;\n    }\n    float tau = (a_qq - a_pp) \/ (2.0 * a_pq);\n    float stt = sqrt(1.0 + tau * tau);\n    float tan = 1.0 \/ ((tau >= 0.0) ? (tau + stt) : (tau - stt));\n    c = rsqrt(1.0 + tan * tan);\n    s = tan * c;\n}\n\nvoid svd_rotate_xy(INOUT(float,x), INOUT(float,y), IN(float,c), IN(float,s)) {\n    float u = x; float v = y;\n    x = c * u - s * v;\n    y = s * u + c * v;\n}\n\nvoid svd_rotateq_xy(INOUT(float,x), INOUT(float,y), INOUT(float,a), IN(float,c), IN(float,s)) {\n    float cc = c * c; float ss = s * s;\n    float mx = 2.0 * c * s * a;\n    float u = x; float v = y;\n    x = cc * u - mx + ss * v;\n    y = ss * u + mx + cc * v;\n}\n\nvoid svd_rotate01(INOUT(mat3,vtav), INOUT(mat3,v)) {\n    if (vtav[0][1] == 0.0) return;\n    \n    float c, s;\n    givens_coeffs_sym(vtav[0][0], vtav[0][1], vtav[1][1], c, s);\n    svd_rotateq_xy(vtav[0][0],vtav[1][1],vtav[0][1],c,s);\n    svd_rotate_xy(vtav[0][2], vtav[1][2], c, s);\n    vtav[0][1] = 0.0;\n    \n    svd_rotate_xy(v[0][0], v[0][1], c, s);\n    svd_rotate_xy(v[1][0], v[1][1], c, s);\n    svd_rotate_xy(v[2][0], v[2][1], c, s);\n}\n\nvoid svd_rotate02(INOUT(mat3,vtav), INOUT(mat3,v)) {\n    if (vtav[0][2] == 0.0) return;\n    \n    float c, s;\n    givens_coeffs_sym(vtav[0][0], vtav[0][2], vtav[2][2], c, s);\n    svd_rotateq_xy(vtav[0][0],vtav[2][2],vtav[0][2],c,s);\n    svd_rotate_xy(vtav[0][1], vtav[1][2], c, s);\n    vtav[0][2] = 0.0;\n    \n    svd_rotate_xy(v[0][0], v[0][2], c, s);\n    svd_rotate_xy(v[1][0], v[1][2], c, s);\n    svd_rotate_xy(v[2][0], v[2][2], c, s);\n}\n\nvoid svd_rotate12(INOUT(mat3,vtav), INOUT(mat3,v)) {\n    if (vtav[1][2] == 0.0) return;\n    \n    float c, s;\n    givens_coeffs_sym(vtav[1][1], vtav[1][2], vtav[2][2], c, s);\n    svd_rotateq_xy(vtav[1][1],vtav[2][2],vtav[1][2],c,s);\n    svd_rotate_xy(vtav[0][1], vtav[0][2], c, s);\n    vtav[1][2] = 0.0;\n    \n    svd_rotate_xy(v[0][1], v[0][2], c, s);\n    svd_rotate_xy(v[1][1], v[1][2], c, s);\n    svd_rotate_xy(v[2][1], v[2][2], c, s);\n}\n\nvoid svd_solve_sym(IN(mat3,a), OUT(vec3,sigma), INOUT(mat3,v)) {\n    \/\/ assuming that A is symmetric: can optimize all operations for \n    \/\/ the lower left triagonal\n    mat3 vtav = a;\n    \/\/ assuming V is identity: you can also pass a matrix the rotations\n    \/\/ should be applied to\n    \/\/ U is not computed\n    for (int i = 0; i < SVD_NUM_SWEEPS; ++i) {\n        svd_rotate01(vtav, v);\n        svd_rotate02(vtav, v);\n        svd_rotate12(vtav, v);\n    }\n    sigma = vec3(vtav[0][0],vtav[1][1],vtav[2][2]);    \n}\n\nfloat svd_invdet(float x, float tol) {\n    return (abs(x) < tol || abs(1.0 \/ x) < tol) ? 0.0 : (1.0 \/ x);\n}\n\nvoid svd_pseudoinverse(OUT(mat3,o), IN(vec3,sigma), IN(mat3,v)) {\n    float d0 = svd_invdet(sigma[0], Tiny_Number);\n    float d1 = svd_invdet(sigma[1], Tiny_Number);\n    float d2 = svd_invdet(sigma[2], Tiny_Number);\n    o = mat3(v[0][0] * d0 * v[0][0] + v[0][1] * d1 * v[0][1] + v[0][2] * d2 * v[0][2],\n             v[0][0] * d0 * v[1][0] + v[0][1] * d1 * v[1][1] + v[0][2] * d2 * v[1][2],\n             v[0][0] * d0 * v[2][0] + v[0][1] * d1 * v[2][1] + v[0][2] * d2 * v[2][2],\n             v[1][0] * d0 * v[0][0] + v[1][1] * d1 * v[0][1] + v[1][2] * d2 * v[0][2],\n             v[1][0] * d0 * v[1][0] + v[1][1] * d1 * v[1][1] + v[1][2] * d2 * v[1][2],\n             v[1][0] * d0 * v[2][0] + v[1][1] * d1 * v[2][1] + v[1][2] * d2 * v[2][2],\n             v[2][0] * d0 * v[0][0] + v[2][1] * d1 * v[0][1] + v[2][2] * d2 * v[0][2],\n             v[2][0] * d0 * v[1][0] + v[2][1] * d1 * v[1][1] + v[2][2] * d2 * v[1][2],\n             v[2][0] * d0 * v[2][0] + v[2][1] * d1 * v[2][1] + v[2][2] * d2 * v[2][2]);\n}\n\nvoid svd_solve_ATA_ATb(\n    IN(mat3,ATA), IN(vec3,ATb), OUT(vec3,x)\n) {\n    mat3 V = mat3(1.0);\n    vec3 sigma;\n    \n    svd_solve_sym(ATA, sigma, V);\n    \n    mat3 Vinv;\n    svd_pseudoinverse(Vinv, sigma, V);\n    x = Vinv * ATb;\n}\n\nvec3 svd_vmul_sym(IN(mat3,a), IN(vec3,v)) {\n    return vec3(\n        dot(a[0],v),\n        (a[0][1] * v.x) + (a[1][1] * v.y) + (a[1][2] * v.z),\n        (a[0][2] * v.x) + (a[1][2] * v.y) + (a[2][2] * v.z)\n    );\n}\n\n\/\/ QEF\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvoid qef_add(\n    IN(vec3,n), IN(vec3,p),\n    INOUT(mat3,ATA), \n    INOUT(vec3,ATb),\n    INOUT(vec4,pointaccum))\n{\n    ATA[0][0] += n.x * n.x;\n    ATA[0][1] += n.x * n.y;\n    ATA[0][2] += n.x * n.z;\n    ATA[1][1] += n.y * n.y;\n    ATA[1][2] += n.y * n.z;\n    ATA[2][2] += n.z * n.z;\n\n    float b = dot(p, n);\n    ATb += n * b;\n    pointaccum += vec4(p,1.0);\n}\n\nfloat qef_calc_error(IN(mat3,A), IN(vec3, x), IN(vec3, b)) {\n    vec3 vtmp = b - svd_vmul_sym(A, x);\n    return dot(vtmp,vtmp);\n}\n\nfloat qef_solve(\n    IN(mat3,ATA), \n    IN(vec3,ATb),\n    IN(vec4,pointaccum),\n    OUT(vec3,x)\n) {\n    vec3 masspoint = SWIZZLE_XYZ(pointaccum) \/ pointaccum.w;\n    ATb -= svd_vmul_sym(ATA, masspoint);\n    svd_solve_ATA_ATb(ATA, ATb, x);\n    float result = qef_calc_error(ATA, x, ATb);\n    \n    x += masspoint;\n        \n    return result;\n}\n\n\/\/ uncomment for a cross section view\n\/\/#define CROSS_SECTION\n\n\/\/------------------------------------------------------------------------\n\/\/ Camera\n\/\/\n\/\/ Move the camera. In this case it's using time and the mouse position\n\/\/ to orbitate the camera around the origin of the world (0,0,0), where\n\/\/ the yellow sphere is.\n\/\/------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n#ifdef CROSS_SECTION\n    float an = 1.5+sin(0.3*iGlobalTime);\n#else\n    float an = 0.3*iGlobalTime + 10.0*mouseX;\n#endif\n\tcamPos = vec3(4.5*sin(an),2.0,4.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n\/\/------------------------------------------------------------------------\n\/\/ Background \n\/\/\n\/\/ The background color. In this case it's just a black color.\n\/\/------------------------------------------------------------------------\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n    return (a.x <= b.x)?a:b;\n}\n\nvec2 max2(vec2 a, vec2 b) {\n    return (a.x > b.x)?a:b;\n}\n\nvoid rotate_xy(inout float x, inout float y, in float a) {\n    float c = cos(a);\n    float s = sin(a);\n    float u = x; float v = y;\n    x = c * u - s * v;\n    y = s * u + c * v;\n}\n\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n\n\/\/------------------------------------------------------------------------\n\/\/ Modelling \n\/\/\n\/\/ Defines the shapes (a sphere in this case) through a distance field\n\/\/------------------------------------------------------------------------\n\n#define PLANE_RADIUS 1.0\n#define PLANE_PT_R 0.05\n#define FEATURE_PT_R 0.1\n\nvec4 planef[PLANE_COUNT];\nvec3 normals[PLANE_COUNT];\nvec3 origins[PLANE_COUNT];\nvec3 points[PLANE_COUNT];\n\nmat3 ATA = mat3(0.0);\nvec3 ATb = vec3(0.0);\nvec4 pointaccum = vec4(0.0);\nvec3 corner;\nfloat error;\n\n\/\/ pluecker line stored in a matrix\nmat3 line(vec3 p, vec3 q) {\n    return mat3(q-p, cross(p,q), vec3(0.0));\n}\n\nvec4 intersect_line_plane(mat3 l, vec4 e) {\n    vec3 t = l[0];\n    vec3 m = l[1];\n    return vec4(\n        m.z*e.y - m.y*e.z - t.x*e.w,\n        m.x*e.z - m.z*e.x - t.y*e.w,\n        m.y*e.x - m.x*e.y - t.z*e.w,\n        e.x*t.x + e.y*t.y + e.z*t.z\n    );\n}\n\nvoid update_planes() {\n    for (int i = 0; i < PLANE_COUNT; ++i) {\n        float a = float(i)*PI2 \/ float(PLANE_COUNT);\n        float f = mod(float(i),2.0)*2.0-1.0;\n        normals[i] = normalize(vec3(sin(iGlobalTime*0.1+a)*cos(iGlobalTime*0.22+a*7.41)*0.8,1.0,0.0));\n        rotate_xy(normals[i].x, normals[i].z, -a*11.2*f);\n        origins[i] = vec3(cos(a)*PLANE_RADIUS,0.0,sin(a)*PLANE_RADIUS);\n        planef[i] = vec4(normals[i], dot(-origins[i],normals[i]));\n    }\n    \/\/ push origins onto deepest plane\n    for (int i = 0; i < PLANE_COUNT; ++i) {\n        points[i] = origins[i] * 2.0;\n        points[i].y = 5.0;\n        vec3 n = normals[i];\n        for (int j=0; j < PLANE_COUNT; ++j) {\n            mat3 l = line(points[i], points[i] + vec3(0.0,-1.0,0.0));\n            vec4 np = intersect_line_plane(l, planef[j]);\n            float h = np.y \/ np.w;\n            if (h < points[i].y) {\n                points[i].y = h;\n                n = normals[j];\n            }                \n        }\n\t    qef_add(n, points[i], ATA, ATb, pointaccum);\n    }\n    \n    error = qef_solve(ATA, ATb, pointaccum, corner);\n}\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat plane(vec3 p, vec3 n, vec3 o) {\n    return dot(p,n) + dot(-o,n);\n}\n\nfloat doModel( vec3 p ) {\n    float d = plane(p, normals[0], origins[0]);\n    float s = sphere(p - corner, FEATURE_PT_R + error);\n    s = min(s, sphere(p - points[0], PLANE_PT_R));\n    for (int i = 1; i < PLANE_COUNT; ++i) {\n        d = max(d, plane(p, normals[i], origins[i]));\n        s = min(s, sphere(p - points[i], PLANE_PT_R));\n    }\n    \n  \treturn min(s, d);\n}\n\n\/\/------------------------------------------------------------------------\n\/\/ Material \n\/\/\n\/\/ Defines the material (colors, shading, pattern, texturing) of the model\n\/\/ at every point based on its position and normal. In this case, it simply\n\/\/ returns a constant yellow color.\n\/\/------------------------------------------------------------------------\nvec3 doMaterial( in vec3 pos, in vec3 nor )\n{\n    return vec3(0.3);\n}\n\n\/\/------------------------------------------------------------------------\n\/\/ Lighting\n\/\/------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal )\n{\n    vec3 lin = vec3(0.0);\n\n    \/\/ key light\n    \/\/-----------------------------\n    vec3  lig = normalize(vec3(1.0,0.7,0.9));\n    float dif = max(dot(nor,lig),0.0);\n    float sha = 0.0; if( dif>0.01 ) sha=calcSoftshadow( pos+0.01*nor, lig );\n    lin += dif*vec3(4.00,4.00,4.00)*sha;\n\n    \/\/ ambient light\n    \/\/-----------------------------\n    lin += vec3(0.50,0.50,0.50);\n\n    \n    \/\/ surface-light interacion\n    \/\/-----------------------------\n    vec3 col = mal*lin;\n\n    \n    \/\/ fog    \n    \/\/-----------------------------\n\tcol *= exp(-0.01*dis*dis);\n\n    return col;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 20.0;           \/\/ max trace distance\n\tconst float precis = 0.001;        \/\/ precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<90; i++ )          \/\/ max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = doModel( ro+rd*t );\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             \/\/ precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ) + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ) + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ) + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ) );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 \/\/ selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<40; i++ )         \/\/ 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t);\n        res = min( res, 64.0*h\/t );   \/\/ 64 is the hardness of the shadows\n\t\tt += clamp( h, 0.02, 2.0 );   \/\/ limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)\/iResolution.y;\n    vec2 m = iMouse.xy\/iResolution.xy;\n\n    update_planes();\n\n    \/\/-----------------------------------------------------\n    \/\/ camera\n    \/\/-----------------------------------------------------\n    \n    \/\/ camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iGlobalTime, m.x );\n\n    \/\/ camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  \/\/ 0.0 is the camera roll\n    \n\t\/\/ create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); \/\/ 2.0 is the lens length\n\n    \/\/-----------------------------------------------------\n\t\/\/ render\n    \/\/-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t\/\/ raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        \/\/ geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        \/\/ materials\n        vec3 mal = doMaterial( pos, nor );\n\n        col = doLighting( pos, nor, rd, t, mal );\n\t}\n\n\t\/\/-----------------------------------------------------\n\t\/\/ postprocessing\n    \/\/-----------------------------------------------------\n    \/\/ gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\t   \n    fragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}