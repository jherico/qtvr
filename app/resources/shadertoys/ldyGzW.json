{"Shader":{"ver":"0.1","info":{"id":"ldyGzW","date":"1453468139","viewed":293,"name":"WASD movement","username":"TekF","description":"Basic FPS style WASD controls. I figure I'm going to want this for a lot of my shaders, and I thought other folks would too. Apologies for the ugly scene, that wasn't really the focus. <img src=\"\/img\/emoticonHappy.png\"\/><br\/>Press F to fly, Space to jump (when not flying).","likes":13,"published":3,"flags":48,"tags":["cameracontrol"],"hasliked":0},"renderpass":[{"inputs":[{"id":47,"src":"\/presets\/tex19.png","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":48,"src":"\/presets\/tex20.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Ben Quantock 2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec4 pattern( in vec3 p )\n{\n    vec4 o;\n    o.a = 1.0;\n    o.rgb = texture2D( iChannel2, (p.xz + p.xy)\/11.0 ).rgb;\n    o *= texture2D( iChannel1, (p.xz + p.xy)\/7.0 ).r;\n\treturn o;\n}\n\nfloat scene( in vec3 p )\n{\n    \/\/ simple scene\n    \n    float f = p.y - (-2.0);\n    \n    f = min( f, length(fract(p.xz\/20.0+.4)-.5)*20.0-.8 );\n    f = min( f, length(fract(p.xz\/31.0)-.5)*30.0-1.8 );\n    f = max( f, p.y - 2.0 );\n    \n    f -= .2*pattern(p).a;\n    \n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ read camera position & orientation\n    \n    vec4 camPos = texture2D( iChannel0, vec2(.5,.5)\/iResolution.xy, -100.0 );\n    vec4 camRot = texture2D( iChannel0, vec2(1.5,.5)\/iResolution.xy, -100.0 )*6.28318530718;\n\n    \/\/ cast a ray from the camera\n    \n    vec3 ray = normalize( vec3( (fragCoord.xy-iResolution.xy*.5)\/iResolution.x, 1.0 ) );\n    \n    ray.zy = ray.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*ray.yz;\n    ray.xz = ray.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*ray.zx;\n\n    vec3 p = camPos.xyz;\n    \n    float h = 1.0;\n    for ( int i=0; i < 100; i++ )\n    {\n        if ( h < .001 )\n            break;\n        h = scene(p);\n        p += ray*h;\n    }\n    \n    \n    \/\/ sample scene colour\n\n    vec3 col;\n\tif ( h < .001 )\n    {\n        col = pattern(p).rgb;\n        \n        \/\/ vague lighting trick\n        float light = max( .0, scene(p + normalize(vec3(3,2,1))*.1) )\/.1;\n        light = min( light, max (.0, scene(p + normalize(vec3(3,2,1))*2.) )\/2. ); \/\/ vague shadows\n\t\tcol *= light*.9+.1;\n    }\n    else\n    {\n       \tcol =( ray.y < .0 ) ?  vec3(.1) : vec3(.3,.5,.9);\n        \n        p += ray*(p.y+2.0)\/max(-ray.y,.01);\n    }\n    \n    col = mix( vec3(.3,.5,.9), col, exp2(-length(p-camPos.xyz)\/1000.0) );\n\n    fragColor = vec4(pow(col,vec3(1.0\/2.2)),1.0);\n}","name":"","description":"","type":"image"},{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Ben Quantock 2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define INVERT_Y 1\n\nconst float accel = .01;\nconst float decay = .95; \/\/ how much velocity is preserved per frame (proportionally)\n\n#if INVERT_Y\nconst float yMul = 1.0;\n#else\nconst float yMul = -1.0;\n#endif\n\n\n\/\/ keys are javascript keycode\nconst int Key_A = 65; const int Key_B = 66; const int Key_C = 67; const int Key_D = 68; const int Key_E = 69;\nconst int Key_F = 70; const int Key_G = 71; const int Key_H = 72; const int Key_I = 73; const int Key_J = 74;\nconst int Key_K = 75; const int Key_L = 76; const int Key_M = 77; const int Key_N = 78; const int Key_O = 79;\nconst int Key_P = 80; const int Key_Q = 81; const int Key_R = 82; const int Key_S = 83; const int Key_T = 84;\nconst int Key_U = 85; const int Key_V = 86; const int Key_W = 87; const int Key_X = 88; const int Key_Y = 89;\nconst int Key_Z = 90;\nconst int Key_0 = 48; const int Key_1 = 49; const int Key_2 = 50; const int Key_3 = 51; const int Key_4 = 52;\nconst int Key_5 = 53; const int Key_6 = 54; const int Key_7 = 55; const int Key_8 = 56; const int Key_9 = 57;\nconst int Key_Space = 32;\n\nfloat ReadKeyInternal( int key, bool toggle )\n{\n\treturn texture2D( iChannel3, vec2( (float(key)+.5)\/256.0, toggle?.75:.25 ) ).x;\n}\n\nfloat ReadKey( int key )\n{\n\treturn ReadKeyInternal(key,false);\n}\n\nfloat ReadKeyToggle( int key )\n{\n\treturn ReadKeyInternal(key,true);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n\n    if ( int(fragCoord.y) == 0 )\n    {\n        if ( int(fragCoord.x) == 0 )\n        {\n            vec4 camPos = texture2D( iChannel0, vec2(.5,.5)\/iResolution.xy, -100.0 );\n            vec4 camVel = texture2D( iChannel0, vec2(3.5,.5)\/iResolution.xy, -100.0 );\n            \n            fragColor = camPos + camVel;\n\n            if ( camPos.y < .0 ) { fragColor.y = .0; }\n\n            \/\/ fly\n            fragColor.w = ReadKeyToggle(Key_F);\n        }\n        else if ( int(fragCoord.x) <= 2 )\n        {\n            vec4 baseCamRot = texture2D( iChannel0, vec2(2.5,.5)\/iResolution.xy, -100.0 );\n            vec4 camRot = texture2D( iChannel0, vec2(1.5,.5)\/iResolution.xy, -100.0 );\n\n            vec2 mouseRot = (iMouse.yx\/iResolution.yx-.5)*vec2(.5*yMul,1.);\n            \n            camRot.w = iMouse.z;\n            \n            bool press = (camRot.w > .0);\n            bool lastPress = (baseCamRot.w > .0);\n            bool click = press && !lastPress;\n            if ( click )\n            {\n                baseCamRot.xy -= mouseRot;\n            }\n            \n            if ( press )\n            {\n                camRot.xy = baseCamRot.xy + mouseRot;\n            }\n            else\n            {\n                \/\/update the base pos\n                baseCamRot = camRot;\n            }\n\n            baseCamRot.w = camRot.w;\n            \n            \/\/ store\n            if ( int(fragCoord.x) == 1 )\n            {\n            \tfragColor = camRot;\n            }\n            else\n            {\n            \tfragColor = baseCamRot;\n            }\n        }\n        else if ( int(fragCoord.x) == 3 )\n        {\n            vec4 camPos = texture2D( iChannel0, vec2(.5,.5)\/iResolution.xy, -100.0 );\n            vec4 camVel = texture2D( iChannel0, vec2(3.5,.5)\/iResolution.xy, -100.0 );\n            vec4 camRot = texture2D( iChannel0, vec2(1.5,.5)\/iResolution.xy, -100.0 )*6.28318530718;\n            \n            bool fly = (camPos.w > .0);\n            \n            vec3 forward = vec3(0,0,1)*accel;\n            vec3 right = vec3(1,0,0)*accel;\n\n            if ( fly ) \/\/ allow flying\n            {\n                forward.zy = forward.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*forward.yz;\n                right.zy = right.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*right.yz;\n            }\n                \n            forward.xz = forward.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*forward.zx;\n\t\t    right.xz = right.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*right.zx;\n            \n            camVel.xyz += (ReadKey(Key_W)-ReadKey(Key_S)) * forward;\n            camVel.xyz += (ReadKey(Key_D)-ReadKey(Key_A)) * right;\n\n            camVel *= decay; \/\/ exponential decay\n            \n            if ( !fly )\n            {\n            \tcamVel.y -= .01;\n            \n            \tif ( camPos.y <= .0 )\n            \t{\n                \tcamVel.y = (ReadKey(Key_Space) != .0) ? .3 : 0.0;\n            \t}\n            }\n            \n            fragColor = camVel;\n        }\n    }\n}","name":"","description":"","type":"buffer"}]}}