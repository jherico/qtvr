{"Shader":{"ver":"0.1","info":{"id":"4ds3D7","date":"1372250420","viewed":1005,"name":"Fire Counter","username":"FabriceNeyret2","description":"combine counter[1] and noise[2]<br\/>[1]: https:\/\/www.shadertoy.com\/view\/XslGD7<br\/>[2]: https:\/\/www.shadertoy.com\/view\/XslGRr","likes":7,"published":3,"flags":0,"tags":["procedural","text"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ ------------- Counter. (c) Fabrice NEYRET June 2013 -----------------------\\\\\n\n#define STYLE 2     \/\/ 1\/2\n#define EFFECT 2    \/\/ 0\/1\/2\n#define E (1.\/6.)   \/\/ segment thickness\n#define DELAY 4.    \/\/ effect periodicity\nfloat rad = 4.;     \/\/ segment shape ratio\n#define ANIM true\n\n#define PI 3.1415927\nvec2 FragCoord;\n\nvec2 pos   = vec2(.94*float(iResolution.x), .6*float(iResolution.y));\nvec2 scale = 1.5*vec2(.25*float(iResolution.y),.375*float(iResolution.y));\n#define offset .0\n\n\/\/ --- noise functions from https:\/\/www.shadertoy.com\/view\/XslGRr\n\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\/\/ --- End of Created by inigo quilez\n\nvec2 noise2( vec2 p )\n{\n\tif (ANIM) p += iGlobalTime;\n    float fx = noise(vec3(p,.5));\n    float fy = noise(vec3(p,.5)+vec3(1345.67,0,45.67));\n    return vec2(fx,fy);\n}\nvec2 fbm2( vec2 p )\n{\n\tif (ANIM) p += iGlobalTime;\n    float fx = fbm(vec3(p,.5));\n    float fy = fbm(vec3(p,.5)+vec3(1345.67,0,45.67));\n    return vec2(fx,fy);\n}\nvec2 perturb2(vec2 p, float scaleX, float scaleI)\n{\n    scaleX *= 2.;\n\treturn scaleI*scaleX*fbm2(p\/scaleX); \/\/ usually, to be added to p\n}\n\n\/\/ --- Displays digit b at pos with size=scale ------------------------------\n\/\/     return code =  1:pixel on , 0: pixel off , -1: pixel out of digit bbox\nint _i;\nfloat aff(int b)\n{\n\tvec2 uv = (FragCoord.xy-pos)\/scale;       \/\/ normalized coordinates in digit bbox\n#if 1\n\tuv += perturb2((uv+pos\/scale)-vec2(0.,2.*iGlobalTime),.1,1.5);  \/\/ distort digits\n#endif\n\tpos.x -= (1.+offset)*scale.x;\n\tif((abs(uv.x)<.5)&&(abs(uv.y)<.5))    \/\/ pixel is in bbox\n\t{\n\t\tconst float dy = 2.*(1.-E);\n\t\tfloat ds = 1.\/sqrt(1.+dy*dy)*3.\/1.414\/(1.-2.*E);\n\t\tvec2 st = ds*vec2(uv.x-dy*uv.y,-uv.x-dy*uv.y);  \/\/ in diamond frame coords\n\t\tif((abs(st.x)>1.5)||(abs(st.y)>1.5)) return 0.; \/\/ pixel is not in 3x3 diamond grid\n\t\tst += 1.5;\n\t\tint seg = int(st.x)+3*int(st.y);           \/\/ diamond cell number\n\t\tif ((seg==2)||(seg==6)) return 0.;         \/\/ pixel is in a non-segment cells\n\t\tuv = 2.*(st-floor(st))-1.;                 \/\/ pixel in diamond cell coords\n\t\tfloat t=PI\/4.; \n#if EFFECT>0\n\t\tfloat T = iGlobalTime;\n\t\tT = 2.*T-4.*(FragCoord.x\/iResolution.x);   \/\/ phase varies with x\n\t\tfloat dt = DELAY*floor(T\/DELAY); \/\/ effect every DELAY seconds\n  #if EFFECT==1                       \/\/ rotation effect\n\t\tif (T-dt<PI\/2.) {\n\t\t\tt=4.*(T-dt); \n\t\t\tt = PI\/4.+.5*(t-sin(t));\n\t\t}\n  #elif EFFECT==2                     \/\/ zoom effect\n\t\tif (T-dt<PI) {\n\t\t\tfloat tt = 2.*(T-dt); \n\t\t\ttt = sin(tt)*(1.-cos(tt))\/1.3; \/\/ -1..1\n\t\t\trad \/= 1.-.9*tt;\n\t\t}\t\t\n  #endif\n#endif\n\t\tfloat C = cos(t), S=sin(t);\n\t\tuv = vec2(C*uv.x-S*uv.y,S*uv.x+C*uv.y); \/\/ pixel in screen-parallel cell coords\n\t    bool c;                                 \/\/ true if pixel is in a set segment of digit b.\n#if 1\n\t\tif     (b==0) c = (seg!=4);             \/\/ is pix in a segment of digit b ?\n\t\telse if(b==1) c = (seg==1)||(seg==5);\n\t\telse if(b==2) c = (seg!=3)&&(seg!=5);\n\t\telse if(b==3) c = (seg!=3)&&(seg!=7);\n\t\telse if(b==4) c = (seg!=0)&&(seg!=7)&&(seg!=8);\n\t\telse if(b==5) c = (seg!=1)&&(seg!=7);\n\t\telse if(b==6) c = (seg!=1);\n\t\telse if(b==7) c = (seg==0)||(seg==1)||(seg==5);\n\t\telse if(b==8) c =   true;\n\t\telse if(b==9) c = (seg!=7);\n#else\n\t\tc = (seg==b);                        \/\/ drawn cell b\n#endif\n\t    \/\/ return 1 if pixel should be drawn.\n#if STYLE==1\n\t    if (c)\treturn max(1.-length(uv),0.); \/\/ pixel in positive shape for segment on\n\t\telse    return    length(uv); \/\/ pixel in positive shape for segment off\t\t\t\n#elif STYLE==2\n\t\tif (4*(seg\/4)==seg) uv.y *=rad;       \/\/ segment = vertical or horizontal ellips\n\t\telse                uv.x *=rad;\n\t    if (c)\treturn 1.-length(uv)\/1.3; \/\/ pixel in a set segment\tshape\n#endif\n        return 0.; \/\/ pixel is in digit bbox but out of a set segment\n\t}\n\treturn -1.;    \/\/ pixel is out of digit bbox\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat c;\n\tFragCoord=fragCoord;\n    \n\tint t = int(iGlobalTime*100.);   \/\/ decompose 100*timer in digits \n\tfor (int i=0; i<5; i++) {\n\t\t_i = i;\n\t\tint n = t-10*(t\/10); t=t\/10; \/\/ n = digit from right to left\n\t\tc = aff(n);                  \/\/ 1 if pixel is in the digit bbox AND in a set segment \n\t\tif (c>=0.) break;             \/\/ the digit under pixel as been found\n\t}\n\t\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\tif (c>0.) {\n\t\tc = .5*(1.+cos(PI*(1.-c))); c=pow(c,.5);\n\t\tfloat I = 1.-.2*noise(vec3(30.*uv.x+80.643,3.*uv.y-67.123,20.*iGlobalTime));\n\t\tfloat r = 1.;\n\t\tfloat g = r*noise(vec3(30.*uv.x,10.*uv.y,.5));\n\t\tfragColor = vec4(c*r*I,c*g*I,0.,1.0);     \/\/ draw set pixels\n\t}\n\t\/\/else if (c==0)\n\t\/\/\tfragColor = vec4(0.*uv,0.5-0.5*sin(iGlobalTime),1.0);  \/\/ draw digit background\n\telse\n\t\tfragColor = vec4(0.);     \/\/ draw background\n}","name":"","description":"","type":"image"}]}}