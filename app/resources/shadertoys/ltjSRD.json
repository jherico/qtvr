{"Shader":{"ver":"0.1","info":{"id":"ltjSRD","date":"1442177752","viewed":1258,"name":"Ray Marched Mesh Terrain","username":"Flyguy","description":"An edit of a shader I posted here a few months ago with some fixes and better shading.","likes":22,"published":3,"flags":0,"tags":["raymarching","distancefield","triangle","heightmap","mesh"],"hasliked":0},"renderpass":[{"inputs":[{"id":8,"src":"\/presets\/tex07.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/Raymarch settings\n\n#define MIN_DIST 0.001\n#define MAX_DIST 12.0\n#define MAX_STEPS 96\n#define STEP_MULT 0.5\n#define NORMAL_OFFS 0.002\n\n\/\/Scene settings\n\n#define QUADS_PER_UNIT 8.0\n#define HAZE_COLOR vec3(0.15, 0.00, 0.10)\n#define GRID_LINE_RADIUS 2.0\n\/\/#define SHOW_RAY_COST\n\n\/\/Derived settings\n#define QUAD_SIZE (1.0\/QUADS_PER_UNIT)\n\nfloat pi = atan(1.0) * 4.0;\nfloat tau = atan(1.0) * 8.0;\n\nstruct MarchResult\n{\n    vec3 position;\n    vec3 normal;\n    float dist;\n    float steps;\n};\n\n\/\/Returns the height at a given position.\nfloat Height(vec2 p)\n{\n    p *= QUAD_SIZE;\n    \n    float h = texture2D(iChannel0, p * 0.1 + iGlobalTime * 0.01, -99.0).x * 0.5;\n    \n    h += sin(length(p) * 2.0 + iGlobalTime) * 0.25;\n    \n\treturn h;\n}\n\n\/\/Returns a rotation matrix for the given angles around the X,Y,Z axes.\nmat3 Rotate(vec3 angles)\n{\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\n    return rotX * rotY * rotZ;\n}\n\n\/\/==== Distance field operators\/functions by iq. ====\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1, d2);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p) - s;\n}\n\n\/\/Modified to create a plane from 3 points.\nfloat sdPlane( vec3 p, vec3 p0, vec3 p1, vec3 p2 )\n{\n  return dot(p - p0, normalize(cross(p0 - p1, p0 - p2)));\n}\n\/\/===================================================\n\n\/*\nDistance to a vertical quad comprised of two triangles.\n\n1-----2\n| 0  \/|\n|  \/  |\n|\/  1 |\n0-----3\n*\/\nfloat sdVQuad( vec3 p, float h0, float h1, float h2, float h3)\n{\n    float s = QUAD_SIZE;\n       \n    float diag = sdPlane(p, vec3(0, 0, 0),vec3(s, s, 0),vec3(0, 0, s));\n    \n    float tri0 = sdPlane(p, vec3(0, 0,-h0),vec3(0, s,-h1),vec3(s, s,-h2)); \/\/Triangle 0 (0,1,2)\n    tri0 = opS(-diag, tri0);\n    \n    float tri1 = sdPlane(p, vec3(0, 0,-h0),vec3(s, s,-h2),vec3(s, 0,-h3)); \/\/Triangle 1 (0,2,3)\n    tri1 = opS(diag, tri1);\n    \n    float d = min(tri0,tri1);\n    \n    return d;\n}\n\n\/\/Distance to the scene\nfloat Scene(vec3 p)\n{\n    float d = MAX_DIST;\n    \n    vec3 pm = vec3(mod(p.xy, vec2(QUAD_SIZE)), p.z);\n    \n    vec2 uv = floor(p.xy \/ QUAD_SIZE);\n    \n    float v0 = Height(uv + vec2(0, 0));\n    float v1 = Height(uv + vec2(0, 1));\n    float v2 = Height(uv + vec2(1, 1));\n    float v3 = Height(uv + vec2(1, 0));\n    \n    d = sdVQuad(pm - vec3(0.0 ,0.0, 0.0), v0, v1, v2, v3);\n    \n    d = opU(d, -sdSphere(p, MAX_DIST - 1.0));\n    \n\treturn d;\n}\n\n\/\/Surface normal at the current position\nvec3 Normal(vec3 p)\n{\n    vec3 off = vec3(NORMAL_OFFS, 0, 0);\n    return normalize\n    ( \n        vec3\n        (\n            Scene(p + off.xyz) - Scene(p - off.xyz),\n            Scene(p + off.zxy) - Scene(p - off.zxy),\n            Scene(p + off.yzx) - Scene(p - off.yzx)\n        )\n    );\n}\n\n\/\/Raymarch the scene with the given ray\nMarchResult MarchRay(vec3 orig,vec3 dir)\n{\n    float steps = 0.0;\n    float dist = 0.0;\n    \n    for(int i = 0;i < MAX_STEPS;i++)\n    {\n        float sceneDist = Scene(orig + dir * dist);\n        \n        dist += sceneDist * STEP_MULT;\n        \n        steps++;\n        \n        if(abs(sceneDist) < MIN_DIST)\n        {\n            break;\n        }\n    }\n    \n    MarchResult result;\n    \n    result.position = orig + dir * dist;\n    result.normal = Normal(result.position);\n    result.dist = dist;\n    result.steps = steps;\n    \n    return result;\n}\n\n\/\/Scene texturing\/shading\nvec3 Shade(MarchResult hit, vec3 direction, vec3 camera)\n{\n    vec3 color = vec3(1.0);\n    \n    \/\/Triangle grid pattern\n    vec2 gridRep = mod(hit.position.xy, vec2(QUAD_SIZE)) \/ float(QUAD_SIZE) - 0.5;\n    \n    float grid = 0.5 - max(abs(gridRep.x), abs(gridRep.y));\n    grid = min(grid, abs(dot(gridRep.xy, normalize(vec2(-1, 1)))));\n    \n    float lineSize = GRID_LINE_RADIUS * hit.dist \/ iResolution.y \/ float(QUAD_SIZE);\n    \n    color *= 1.0-smoothstep(lineSize, lineSize * 0.25, grid);\n    color = color * 0.75 + 0.25;\n    \n    \/\/Lighting\n    float ambient = 0.1;\n    float diffuse = 0.5 * -dot(hit.normal, direction);\n    float specular = 1.1 * max(0.0, -dot(direction, reflect(direction, hit.normal)));\n    \n    color *= vec3(ambient + diffuse + pow(specular, 5.0));\n\t\n    \/\/Fog \/ haze\n    float sky = smoothstep(MAX_DIST - 1.0, 0.0, length(hit.position));\n    float haze = 1.0 - (hit.steps \/ float(MAX_STEPS));\n    \n    vec3 skycol = mix(HAZE_COLOR, vec3(0), clamp(-hit.position.z * 0.2, 0.0, 1.0));\n    \n    color = mix(skycol, color, sky * haze);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy \/ iResolution.y;\n\tvec2 uv = fragCoord.xy \/ iResolution.y;\n    \n    \/\/Camera stuff   \n    vec3 angles = vec3(0);\n    \n    if(iMouse.xy == vec2(0,0))\n    {\n        angles.y = tau * (1.5 \/ 8.0);\n        angles.x = iGlobalTime * 0.1;\n    }\n    else\n    {    \n    \tangles = vec3((iMouse.xy \/ iResolution.xy) * pi, 0);\n        angles.xy *= vec2(2.0, 1.0);\n    }\n    \n    angles.y = clamp(angles.y, 0.0, tau \/ 4.0);\n    \n    mat3 rotate = Rotate(angles.yzx);\n    \n    vec3 orig = vec3(0, 0,-2) * rotate;\n    orig -= vec3(0, 0, 1);\n    \n    vec3 dir = normalize(vec3(uv - res \/ 2.0, 0.5)) * rotate;\n    \n    \/\/Ray marching\n    MarchResult hit = MarchRay(orig, dir);\n    \n    \/\/Shading\n    vec3 color = Shade(hit, dir, orig);\n    \n    #ifdef SHOW_RAY_COST\n    color = mix(vec3(0,1,0), vec3(1,0,0), hit.steps \/ float(MAX_STEPS));\n    #endif\n    \n\tfragColor = vec4(color, 1.0);\n}","name":"","description":"","type":"image"}]}}