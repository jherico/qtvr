{"Shader":{"ver":"0.1","info":{"id":"lsc3Ds","date":"1452747266","viewed":168,"name":"volumetric fog - above and below","username":"trapzz","description":"Shadertoy has been inspiring so I wanted to add something fun.  Here's some simple but cool looking (I think) volumetric fog - you can find references and descriptions at the top of the file.  Thanks for looking!","likes":7,"published":3,"flags":0,"tags":["volumetricfog","pbr"],"hasliked":0},"renderpass":[{"inputs":[{"id":17,"src":"\/presets\/tex12.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/No license, if you like anything here feel free to use it - credit would be nice but not necessary\n\/\/Shoutout to IQ, his work is simply incredible \n\n\/\/There are a lot of things this volumetric fog doesn't do; but I think it still gives a pretty nice result\n\/\/and it runs well on my Intel Sandy Bridge integrated graphics, so that's a plus :)\n\/\/What it does:\n\/\/  Marches two 'fog volumes' (separated by a plane) and accumulates lighting according to the density of the fog\n\/\/  It stops the march once the volume is complete or if it intersects an object\n\/\/  It uses a random noise texture to vary the density of the fog which I think gives a nice \"northern lights\" effect.\n\/\/A more complex solution would:\n\/\/  integrate scattering and occlusion from neighbouring fog and other objects\n\/\/  S\u00e9bastien Hillaire's paper is an excellent reference:\n\/\/      http:\/\/advances.realtimerendering.com\/s2015\/Frostbite%20PB%20and%20unified%20volumetrics.pptx    \n\n\/\/References:\n\/\/\n\/\/SIGNED DISTANCE FIELD\n\/\/  http:\/\/iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\n\/\/GENERATING NORMALS\n\/\/ TEKF https:\/\/www.shadertoy.com\/view\/lslXRj\n\/\/PBR\n\/\/  http:\/\/renderwonk.com\/publications\/s2010-shading-course\/gotanda\/course_note_practical_implementation_at_triace.pdf\n\/\/  http:\/\/simonstechblog.blogspot.com\/2011\/12\/microfacet-brdf.html\n\/\/  http:\/\/www.cs.virginia.edu\/~jdl\/bib\/appearance\/analytic%20models\/schlick94b.pdf\n\/\/  http:\/\/graphicrants.blogspot.com\/2013\/08\/specular-brdf-reference.html\n\/\/FOG\n\/\/  http:\/\/advances.realtimerendering.com\/s2015\/Frostbite%20PB%20and%20unified%20volumetrics.pptx\n\n#define CAMERA_STATIC\t0\n#define CAMERA_ROTATE\t1\n#define CAMERA_MANUAL\t2\n#define CAMERA_SCRIPTED\t3\n\n#define RAYMARCH_STEPS\t100\n#define ROTATE_LIGHT\n#define CAMERA\tCAMERA_SCRIPTED\n\n\/\/fog\n#define FOG\n#define FOG_VOLUME                  20\n#define FOG_DENSITY                 1.80 \/\/1 == looking through the fog volume an \n                                         \/\/unoccluded pixel will be fully fogged by the end of the volume\n#define RAYMARCH_FOG_RESOLUTION     .2\n#define RAYMARCH_FOG_STEPS          int(float(FOG_VOLUME) \/ RAYMARCH_FOG_RESOLUTION)\n#define FOG_VOXEL_DENSITY           float(FOG_DENSITY) \/ float(RAYMARCH_FOG_STEPS)\n#define RAYMARCH_FOG_LIGHTING_STEPS 15\n#define FOG_LIGHTING_MAX_DISTANCE  20.0\n\nconst float SIGNED_DISTANCE_EPSILON = 0.0001;\nconst float PI = 3.1415926535897932384626433832795;\n\nconst int g_num_materials = 2;\nconst int g_num_spheres = 4;\nconst int g_num_point_lights = 2;\nconst int g_num_light_descs = g_num_point_lights;\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Material\n{\n    vec4 color;\n    float emissive;\n    float roughness;\n    float metallic;\n};\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n    Material material;\n};  \n\nstruct RayHit\n{\n    Material material;\n    vec3 position;\n    vec3 normal;\n    float n_dot_v;\n    float dist;\n    bool valid;\n};\n\nstruct TraceResult\n{\n    vec4 color;\n    RayHit ray_hit;\n};\n\nstruct SignedDistanceResult\n{\n    float d;\n    Material m;\n};\n\nstruct PointLight\n{\n    vec3 position;\n    vec3 color;\n    \n    float radius;\n    float n_dot_l;\n    float n_dot_h;\n    float v_dot_h;\n};\n\nstruct LightDesc\n{\n    vec3 color;\n    \n    float n_dot_l;\n    float n_dot_h;\n    float v_dot_h;   \n};\n\nMaterial g_materials[g_num_materials];\nSphere g_spheres[g_num_spheres];\n\nPointLight g_point_lights[g_num_point_lights];\nLightDesc g_light_desc[g_num_light_descs];\n\nvec3 g_ambient_light;\n\nvec3 RotateYaw( vec3 position, float yaw )\n{\n    vec3 center = position;\n    center.x = cos(yaw) * position.x + - sin(yaw) * position.z;\n    center.z = sin(yaw) * position.x +   cos(yaw) * position.z;   \n\n    return center;\n}\n\nvec3 RotatePitch( vec3 position, float pitch )\n{\n    vec3 center = position;\n    center.y = cos(pitch) * position.y + - sin(pitch) * position.z;\n    center.z = sin(pitch) * position.y +   cos(pitch) * position.z;   \n\n    return center;\n}\n\nvec3 TransformPosition( vec3 position, vec3 center, float yaw )\n{\n    return RotateYaw( position - center, yaw ) + center;\n}\n\nvec4 saturate(vec4 v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\nvec3 saturate(vec3 v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\nfloat saturate(float f)\n{\n    return clamp(f, 0.0, 1.0);\n}\n\nvoid Init()\n{\n    float time_cos_0_point_5 = cos(iGlobalTime * 0.5);\n    float time_cos_1_point_0 = cos(iGlobalTime * 1.0);\n    float time_sin_0_point_5 = sin(iGlobalTime * 0.5);\n    \n    \/\/ material for two spheres\n    g_materials[0].color = vec4(1.0, 1.0, 1.0, 1.0);\n    g_materials[0].emissive = 0.0;\n    g_materials[0].metallic = 0.0;   \n    g_materials[0].roughness = 0.5;\n    \n    \/\/ materials - emissive (for lights)\n    g_materials[1].color = vec4(1.0, 1.0, 0.30, 1.0);\n    g_materials[1].emissive = 1.0;\n    g_materials[1].roughness = 1.0;\n    g_materials[1].metallic = 1.00;   \n\n    \/\/ rotating sphere\n    g_spheres[0].center = vec3(time_sin_0_point_5 * 12.0, -6.0, time_cos_0_point_5 * 12.0);\n    g_spheres[0].radius = 1.0;\n    g_spheres[0].material = g_materials[0];\n    \n    \/\/ up \/ down sphere sphere\n    g_spheres[1].center = vec3(0.0, time_cos_1_point_0 * 10.0, 0.0);\n    g_spheres[1].radius = 2.0;\n    g_spheres[1].material = g_materials[0];\n\n    \/\/ lights\n    g_point_lights[0].position = vec3(0.0, 0.0, -15.0);\n    g_point_lights[0].color = vec3(174.0 \/ 255.0 * 2.0, 174.0 \/ 255.0 * 2.0, 255.0 \/ 255.0 * 2.0);\n    g_point_lights[0].radius = .2;\n\n    g_point_lights[1].position = vec3(0.0, 0.0, 15.0);\n    g_point_lights[1].color = vec3(175.0 \/ 255.0 * 2.0, 151.0 \/ 255.0 * 2.0, 175.0 \/ 255.0 * 2.0);\n    g_point_lights[1].radius = .2;\n    \n#ifdef ROTATE_LIGHT\n    g_point_lights[0].position = RotateYaw(g_point_lights[0].position, -time_cos_1_point_0);\n    g_point_lights[0].position = RotatePitch(g_point_lights[0].position, time_cos_0_point_5);\n    g_point_lights[1].position = RotateYaw(g_point_lights[1].position, -time_cos_0_point_5);\n    g_point_lights[1].position = RotatePitch(g_point_lights[1].position, -time_cos_1_point_0);\n#endif\n    \n    g_spheres[2].center = g_point_lights[0].position;\n    g_spheres[2].radius = g_point_lights[0].radius;\n    g_spheres[2].material = g_materials[1];\n    g_spheres[2].material.color.rgb = g_point_lights[0].color;\n    \n    g_spheres[3].center = g_point_lights[1].position;\n    g_spheres[3].radius = g_point_lights[1].radius;\n    g_spheres[3].material = g_materials[1];\n    g_spheres[3].material.color.rgb = g_point_lights[1].color;\n\n    g_ambient_light = vec3(.075, .09, .075);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    \n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length( p ) - s;\n}\n\nSignedDistanceResult sdUnion( SignedDistanceResult r1, SignedDistanceResult r2 )\n{\n    if (r1.d < r2.d)\n        return r1;\n    else    \n        return r2;\n}\n\nSignedDistanceResult SignedDistance( vec3 position )\n{\n    SignedDistanceResult result;\n    \n    float d = sdSphere( position - g_spheres[0].center, g_spheres[0].radius );\n    result = SignedDistanceResult( d, g_spheres[0].material );\n\n    for ( int i = 1; i < g_num_spheres; i++ )\n    {\n        d = sdSphere( position - g_spheres[i].center, g_spheres[i].radius );    \n        result = sdUnion( result, SignedDistanceResult(d, g_spheres[i].material) );\n    }\n            \n    return result;\n}\n\nvec3 CalculateNormal( vec3 ray_direction, vec3 position )\n{   \n    \/\/ from TEKF: https:\/\/www.shadertoy.com\/view\/lslXRj\n    \/\/ I really liked the results\n    float pitch = 0.2 \/ iResolution.x;\n    \n    vec2 d = vec2(-1, 1) * pitch;\n\n    vec3 p0 = position + d.xxx; \/\/ tetrahedral offsets\n    vec3 p1 = position + d.xyy;\n    vec3 p2 = position + d.yxy;\n    vec3 p3 = position + d.yyx;\n\n    float f0 = SignedDistance(p0).d;\n    float f1 = SignedDistance(p1).d;\n    float f2 = SignedDistance(p2).d;\n    float f3 = SignedDistance(p3).d;\n            \n    vec3 grad = p0 * f0 + p1 * f1 + p2 * f2 + p3 * f3 - position * (f0 + f1 + f2 + f3);\n    \n    \/\/ prevent normals pointing away from camera (caused by precision errors)\n    float gdr = dot (grad, ray_direction);\n    grad -= max(0.0, gdr) * ray_direction;\n\n    return normalize(grad);\n}\n\nRay CreateRay(vec3 cam_pos, vec3 cam_euler, vec2 frag_coord)\n{\n    const float fov_degrees = 45.0;\n    \n    vec3 eye;\n    eye.x = 0.0; eye.y = 0.0; eye.z = - 1.0 \/ tan(fov_degrees \/ 2.0 * 0.0174532925);\n    \n    vec3 pixel;\n    pixel.xy = (frag_coord.xy - .5) \/ iResolution.xy * 2.0 - 1.0;\n    pixel.x *= iResolution.x \/ iResolution.y;\n    pixel.z = 0.0;\n\n    vec3 dir = normalize(pixel - eye);\n\n    Ray ray;\n    \n    ray.direction = dir;\n    ray.direction.x = cos(cam_euler.y) * dir.x + - sin(cam_euler.y) * dir.z;\n    ray.direction.z = sin(cam_euler.y) * dir.x +   cos(cam_euler.y) * dir.z;\n    \n    dir = ray.direction;\n\n    ray.direction.y = cos(cam_euler.x) * dir.y + - sin(cam_euler.x) * dir.z;\n    ray.direction.z = sin(cam_euler.x) * dir.y +   cos(cam_euler.x) * dir.z;\n    \n    vec3 origin = cam_pos;\n\n    ray.origin = origin;\n    ray.origin.x = cos(cam_euler.y) * cam_pos.x + - sin(cam_euler.y) * cam_pos.z;\n    ray.origin.z = sin(cam_euler.y) * cam_pos.x +   cos(cam_euler.y) * cam_pos.z;   \n\n    origin = ray.origin;\n\n    ray.origin.y = cos(cam_euler.x) * origin.y + - sin(cam_euler.x) * origin.z;\n    ray.origin.z = sin(cam_euler.x) * origin.y +   cos(cam_euler.x) * origin.z;\n    \n    ray.origin += ray.direction * - eye.z;\n    \n    return ray;\n}\n\nRayHit CheckHit( vec3 ray_direction, vec3 position )\n{\n    RayHit ray_hit;\n    \n    SignedDistanceResult result = SignedDistance( position );\n    ray_hit.dist = result.d;\n    \n    if ( ray_hit.dist < SIGNED_DISTANCE_EPSILON )\n    {\n        ray_hit.valid = true;\n        ray_hit.material = result.m;\n        ray_hit.position = position;\n        ray_hit.normal = CalculateNormal( ray_direction, position );\n    }\n    else\n    {\n        ray_hit.valid = false;\n    }\n\n    return ray_hit;\n}\n\nRayHit RayMarch( Ray ray )\n{\n    float dist = 0.0;\n    vec3 pos = ray.origin;\n\n    RayHit ray_hit;\n    \n    for (int i = 0; i < RAYMARCH_STEPS; i++)\n    {\n        ray_hit = CheckHit( ray.direction, pos );\n\n        if (true == ray_hit.valid)\n            break;\n        \n        dist += ray_hit.dist;\n        pos = ray.origin + ray.direction * dist;\n    }\n        \n    return ray_hit;\n}\n\nfloat CalculateSpecDistribution_GGX( float n_dot_h, float roughness )\n{\n    float a = roughness * roughness;\n    float a2 = a * a;\n    float d = (n_dot_h * n_dot_h) * (a2 - 1.0) + 1.0;\n\n    d = PI * (d * d);\n    \n    return a2 \/ d;\n}\n\nfloat CalculateSpecGeometricAttenuation_Schlick_G1( float d, float k )\n{\n    float g = d \/ (d * (1.0 - k) + k);\n\n    return (g);\n}\n\nfloat CalculateSpecGeometricAttenuation_Schlick_G( float n_dot_l, float n_dot_v, float roughness )\n{\n    float a = (roughness + 1.0) \/ 2.0;\n    float a2 = a * a;\n    float k = a2 \/ 2.0;\n    \n    k = a2 * sqrt(2.0 \/ PI);\n    \n    float g = CalculateSpecGeometricAttenuation_Schlick_G1(n_dot_l, k) * \n              CalculateSpecGeometricAttenuation_Schlick_G1(n_dot_v, k);\n              \n    return max(0.0, g);\/\/saturate(g);\n}\n\nfloat CalculateFresnel_Schlick(float f0, float c)\n{\n    return (f0 + (1.0 - f0) * pow(1.0 - c, 5.0));\n}\n\nvec3 CalculateLighting( RayHit ray_hit, Material material )\n{\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    for (int c = 0; c < g_num_light_descs; c++)\n    {\n        float d = CalculateSpecDistribution_GGX( g_light_desc[c].n_dot_h, material.roughness );\n        float g = CalculateSpecGeometricAttenuation_Schlick_G( g_light_desc[c].n_dot_l, ray_hit.n_dot_v, material.roughness );\n        float fd = CalculateFresnel_Schlick( material.metallic, saturate(g_light_desc[c].n_dot_l) );\n        float fs = CalculateFresnel_Schlick( material.metallic, saturate(g_light_desc[c].v_dot_h) );\n    \n        float n_dot_l_sat = saturate(g_light_desc[c].n_dot_l);\n\n        vec3 diffuse = g_light_desc[c].color * n_dot_l_sat \/ PI * (1.0 - fd);\n    \n        vec3 brdf = g_light_desc[c].color * (g * d * fs) * n_dot_l_sat \/ (4.0 * (g_light_desc[c].n_dot_l * ray_hit.n_dot_v));\n        \n        color += diffuse + brdf;\n    }   \n    \n    return color;\n}\n\nTraceResult ProcessRayHit( RayHit ray_hit, Ray ray )\n{\n    TraceResult result;\n    result.ray_hit = ray_hit;\n    \n    if (false == result.ray_hit.valid)\n        return result;\n    \n    result.ray_hit.n_dot_v = dot(result.ray_hit.normal, -ray.direction);\n\n    for (int c = 0; c < g_num_point_lights; c++)\n    {\n        vec3 direction = normalize(result.ray_hit.position - g_point_lights[c].position);\n\n        vec3 h = normalize(direction + ray.direction);\n    \n        g_light_desc[c].n_dot_l = dot(result.ray_hit.normal, -direction);\n        g_light_desc[c].n_dot_h = dot(result.ray_hit.normal, h);\n        g_light_desc[c].v_dot_h = dot(ray.direction, -h);\n        g_light_desc[c].color = g_point_lights[c].color;\n    }\n    \n    vec3 color = CalculateLighting( result.ray_hit, result.ray_hit.material );\n    \n    result.color.rgb =  color + \n                        result.ray_hit.material.color.rgb * result.ray_hit.material.emissive +  \n                        result.ray_hit.material.color.rgb * g_ambient_light;\n\n    result.color.w = result.ray_hit.material.color.w;\n    \n    return result;\n}\n\nvec2 DistanceFromLight(vec3 position, vec3 light_position, float light_radius)\n{\n    vec3 delta = light_position - position;\n    vec3 to_light = normalize(delta);\n    \n    float distance = dot(to_light, delta) - light_radius;\n    \n    if (distance > FOG_LIGHTING_MAX_DISTANCE)\n        return vec2(FOG_LIGHTING_MAX_DISTANCE, 0.0);\n    \n    return vec2(distance, 1.0);\n}    \n\nvec3 PointOnPlane( vec3 direction, vec3 position, vec4 plane )\n{\n    float c = dot(-direction, plane.xyz);\n    float adj = dot(plane.xyz, position) + plane.w;\n    float hyp = adj \/ c;\n\n    return position + direction * hyp;\n}\n\nvec4 TraceFog( Ray ray, float depth )\n{\n    \/\/A plane at 0,1,0,0 separates two levels of fog\n    \/\/the overlap each other between 1 and -1 for blending\n    \/\/below the plane being very dense\n    \/\/above the plane being just dense enough to scatter some light\n    \n    vec4 fog_color = vec4( 0, 0, 0, 0 );\n    \n    vec3 ray_march_start = ray.origin;\n    float length = 0.0;\n\n    float plane_w = 1.0;\n\n    \/\/if we're starting below the plane or we will end up below the plane\n    if (ray_march_start.y < plane_w || ray.direction.y < 0.0)\n    {\n        \/\/if we are above the plane move our ray march start down the ray to the plane\n        \/\/this way we get as many ray march samples as possible in the plane\n        if (ray_march_start.y > plane_w && ray.direction.y < 0.0)\n            ray_march_start = PointOnPlane(ray.direction, ray_march_start, vec4(0, 1, 0, -plane_w));\n        \n        vec3 position = ray_march_start;\n        \n        \/\/ray march the bottom plane\n        for (int i = 0; i < RAYMARCH_FOG_STEPS; i++)\n        {\n            \/\/if we've gone deep enough that we hit whatever object is at this pixel\n            \/\/we have to stop fogging\n            if (dot(position - ray.origin, ray.direction) >= depth)\n                break;\n            \n            float density;\n            \n            \/\/if we're below the plane, calculate the fog\n            if (position.y <= plane_w)\n            {\n                float scale = .001;\n                float coeff = iGlobalTime * .005;\n\n                \/\/use t for a slight fade in to our fog\n                float t = saturate((plane_w - position.y) \/ 2.0);\n                \n                \/\/random noise sampling so the fog isn't so bland\n                float d1 = texture2D(iChannel0, position.xz * scale + coeff).g;\n                float d2 = texture2D(iChannel0, position.xz * scale + cos(iGlobalTime) * .002).g;\n                density = max(FOG_VOXEL_DENSITY * max(d1,d2), FOG_VOXEL_DENSITY * .25) * t;\n            }\n            else\n                density = 0.0;\n            \n            if (density > 0.0)\n            {                \n                vec3 light_contribution = vec3(0, 0, 0);\n                vec4 voxel_color;\n                \n                \/\/get the distance to each light and accumulate that in our fog\n                for (int k = 0; k < g_num_point_lights; k++)\n                {\n                    vec2 distance_and_occlusion = DistanceFromLight(position, g_point_lights[k].position, g_point_lights[k].radius);\n                    float distance = distance_and_occlusion.x;\n                    float occlusion = distance_and_occlusion.y;\n                    \n                    float dist = distance \/ FOG_LIGHTING_MAX_DISTANCE;\n                    dist = saturate(dist);\n\n                    float d = 1.0 - dist;\n                    light_contribution += g_point_lights[k].color * d * d * occlusion;\n                }\n\n                voxel_color.rgb = (light_contribution + g_ambient_light) * density;\n                voxel_color.w = density;\n                \n                \/\/ accumulate all the voxels into our end fog result\n                fog_color += voxel_color;\n            }\n            \n            length += float(RAYMARCH_FOG_RESOLUTION);\n            position = ray_march_start + ray.direction * length;\n        }\n    }\n    \n    ray_march_start = ray.origin;\n    length = 0.0;\n\n    \/\/now we trace into the top plane\n    plane_w = -1.0;\n    \n    \/\/if we're starting above the plane or will end up above it\n    if (ray_march_start.y > plane_w || ray.direction.y > 0.0)\n    {\n        \/\/if we are above the plane move our ray march start up the ray to the plane\n        \/\/this way we get as many ray march samples as possible in the plane\n        if (ray_march_start.y < plane_w && ray.direction.y > 0.0)\n            ray_march_start = PointOnPlane(ray.direction, ray_march_start, vec4(0, -1, 0, plane_w));\n        \n        vec3 position = ray_march_start;\n\n        for (int i = 0; i < RAYMARCH_FOG_STEPS; i++)\n        {\n            \/\/if we've gone deep enough that we hit whatever object is at this pixel\n            \/\/we have to stop fogging\n            if (dot(position - ray.origin, ray.direction) >= depth)\n                break;\n            \n            float density;\n            \n            if (position.y > plane_w)\n            {\n                \/\/use t for a slight fade in to our fog\n                float t = saturate((position.y - plane_w) \/ 2.0);\n                density = FOG_VOXEL_DENSITY * .25 * t;\n            }\n            else\n                density = 0.0;\n            \n            if (density > 0.0)\n            {                \n                vec3 light_contribution = vec3(0, 0, 0);\n                vec4 voxel_color;\n                \n                \/\/get the distance to each light and accumulate that in our fog\n                for (int k = 0; k < g_num_point_lights; k++)\n                {\n                    vec2 distance_and_occlusion = DistanceFromLight(position, g_point_lights[k].position, g_point_lights[k].radius);\n                    float distance = distance_and_occlusion.x;\n                    float occlusion = distance_and_occlusion.y;\n                    \n                    float dist = distance \/ FOG_LIGHTING_MAX_DISTANCE;\n                    dist = saturate(dist);\n\n                    float d = 1.0 - dist;\n                    light_contribution += g_point_lights[k].color * d * d * occlusion;\n                }\n\n                voxel_color.rgb = (light_contribution + g_ambient_light) * density;\n                voxel_color.w = density;\n                \n                \/\/ accumulate all the voxels into our end fog result\n                fog_color += voxel_color;\n            }\n            \n            length += float(RAYMARCH_FOG_RESOLUTION);\n            position = ray_march_start + ray.direction * length;\n        }\n    }\n    \n    fog_color.w = saturate(fog_color.w);\n    return fog_color;\n}\n\nvec4 TraceScene( Ray ray )\n{\n    TraceResult result = ProcessRayHit( RayMarch(ray), ray );\n\n    if (false == result.ray_hit.valid)\n        return vec4(0, 0, 0, 10000.0);\n\n    vec4 color;\n    \n    color.rgb = result.color.rgb;\n    color.w = dot(result.ray_hit.position - ray.origin, ray.direction);\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Init();\n    \n    vec3 cam_rot = vec3(.25, 0, 0);\n    vec3 cam_pos = vec3(0, 0, -35.0);\n    \n    #if CAMERA == CAMERA_ROTATE\n        cam_rot = vec3(0, iGlobalTime * .025, 0);\n    #elif CAMERA == CAMERA_MANUAL\n        cam_rot = vec3(iMouse.y * .02, iMouse.x * .02, 0);\n    #elif CAMERA == CAMERA_SCRIPTED\n        vec3 rot_up = vec3(0.25, 0.0, 0.0);\n        vec3 rot_down = vec3(-0.25, 0.0, 0.0);\n        vec3 pos_up = vec3(0.0, 5.0, -35.0);\n        vec3 pos_down = vec3(0.0,-10.0, -35.0);\n        \n        float t = abs(cos(iGlobalTime * .15));\n        cam_pos = mix(pos_up, pos_down, 1.0 - t);\n        cam_rot = mix(rot_up, rot_down, 1.0 - t);\n    #endif\n    \n    \n    Ray ray = CreateRay(cam_pos, cam_rot, fragCoord);\n\n    vec4 pixel_color_and_depth = TraceScene( ray );\n    \n    #ifdef FOG\n        vec4 fog_color = TraceFog( ray, pixel_color_and_depth.w );\n    #else\n        vec4 fog_color = vec4(0.0, 0.0, 0.0, 0.0);\n    #endif\n    \n    fragColor.rgb = saturate(pixel_color_and_depth.rgb * (1.0 - fog_color.w) + fog_color.rgb);\n    fragColor.a = 1.0;\n    \n    fragColor = sqrt(fragColor);\n}\n\n","name":"","description":"","type":"image"}]}}