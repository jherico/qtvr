{"Shader":{"ver":"0.1","info":{"id":"Xt2SRG","date":"1444618549","viewed":571,"name":"dream cavern","username":"gtoledo3","description":"Dream cavern derived from julia fractal.","likes":3,"published":3,"flags":0,"tags":["fractal","julia","cavern","hills"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"const float depthCull=.1;\nconst float zoom=3.5;\nconst float bailout=10.;\nconst vec2 offset=vec2(.3,.45);\nconst int iterations=9;\nfloat time=iGlobalTime;\n\n\/\/\"dream cavern\", by George Toledo. 2015.\n\nvec3 hsv(const in float h, const in float s, const in float v) {\n\treturn mix(vec3(1.0),clamp((abs(fract(h+vec3(3.,2.,1.)\/3.0)*6.-3.)-1.),0.,1.0),s)*v;\n}\n\n\n\/\/ Cellular noise (\"Worley noise\") in 2D in GLSL.\n\/\/ Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n\/\/ This code is released under the conditions of the MIT license.\n\/\/ See LICENSE file for details, located in ZIP file here:\n\/\/ http:\/\/webstaff.itn.liu.se\/~stegu\/GLSL-cellular\/\n\n\/\/ Permutation polynomial: (34x^2 + x) mod 289\nvec3 permute(vec3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\n\/\/ Cellular noise, returning F1 and F2 in a vec2.\n\/\/ Standard 3x3 search window for good F1 and F2 values\nvec2 cellular(vec2 P) {\n#define K 0.142857142857 \/\/ 1\/7\n#define Ko 0.428571428571 \/\/ 3\/7\n#define jitter 1.0 \/\/ Less gives more regular pattern\n\tvec2 Pi = mod(floor(P), 289.0);\n \tvec2 Pf = fract(P);\n\tvec3 oi = vec3(-1.0, 0.0, 1.0);\n\tvec3 of = vec3(-0.5, 0.5, 1.5);\n\tvec3 px = permute(Pi.x + oi);\n\tvec3 p = permute(px.x + Pi.y + oi); \/\/ p11, p12, p13\n\tvec3 ox = fract(p*K) - Ko;\n\tvec3 oy = mod(floor(p*K),7.0)*K - Ko;\n\tvec3 dx = Pf.x + 0.5 + jitter*ox;\n\tvec3 dy = Pf.y - of + jitter*oy;\n\tvec3 d1 = dx * dx + dy * dy; \/\/ d11, d12 and d13, squared\n\tp = permute(px.y + Pi.y + oi); \/\/ p21, p22, p23\n\tox = fract(p*K) - Ko;\n\toy = mod(floor(p*K),7.0)*K - Ko;\n\tdx = Pf.x - 0.5 + jitter*ox;\n\tdy = Pf.y - of + jitter*oy;\n\tvec3 d2 = dx * dx + dy * dy; \/\/ d21, d22 and d23, squared\n\tp = permute(px.z + Pi.y + oi); \/\/ p31, p32, p33\n\tox = fract(p*K) - Ko;\n\toy = mod(floor(p*K),7.0)*K - Ko;\n\tdx = Pf.x - 1.5 + jitter*ox;\n\tdy = Pf.y - of + jitter*oy;\n\tvec3 d3 = dx * dx + dy * dy; \/\/ d31, d32 and d33, squared\n\t\/\/ Sort out the two smallest distances (F1, F2)\n\tvec3 d1a = min(d1, d2);\n\td2 = max(d1, d2); \/\/ Swap to keep candidates for F2\n\td2 = min(d2, d3); \/\/ neither F1 nor F2 are now in d3\n\td1 = min(d1a, d2); \/\/ F1 is now in d1\n\td2 = max(d1a, d2); \/\/ Swap to keep candidates for F2\n\td1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; \/\/ Swap if smaller\n\td1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; \/\/ F1 is in d1.x\n\td1.yz = min(d1.yz, d2.yz); \/\/ F2 is now not in d2.yz\n\td1.y = min(d1.y, d1.z); \/\/ nor in  d1.z\n\td1.y = min(d1.y, d2.x); \/\/ F2 is in d1.y, we're done.\n\treturn sqrt(d1.xy);\n}\n\nvec2 cmult(vec2 a, vec2 b)\n{\n\tvec2 p;\n\tp[0]=a[0]*b[0]-a[1]*b[1];\n\tp[1]=a[0]*b[1]+a[1]*b[0];\n\treturn p;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 offset=vec2(offset.x+sin(time*.1)*.05,offset.y+cos(time*.1)*.05);\n\tvec2 position = gl_FragCoord.xy\/iResolution.xy - offset;\n\t\n\tposition = position * (zoom-.7);\n\n\tvec2 perturb=vec2(-.7+(sin(time*.11)*.1)+(sin(time*.2)*.4),0.45+cos(time*.03)*.05)+(sin(time*.12)*.3);\n\tvec2 c, c0, d;\n\tfloat v;\n\t\n\tc = vec2(position);\n\tc0 = perturb;\n\tc +=(cellular( c*4.))*.025;\n\tvec2 f = position.xy;\n\tfor(int i=0; i<iterations; i++) {\n\t\td = cmult(c, c);\n\t\tc = d + c0;\n\t\tv = abs((c.x*c.x) + sin(.1*time+c.y*c.y)) \/ sqrt(.1*time+c.x*c.x );\n\t\t\t\n\t\t\t\n\n\t\tif (v > bailout) break;\n\t}\n\tvec2 c1 =c+cellular( .1*time+c*3.);\n\tvec2 c2=cellular(-.1*vec2(sin(.4*time + c.y*.2),sin(.02*time + c.x*.5)));\n\tvec2 c3=cellular( c*.01);\n\n\t\n\tfloat rand = mod(fract(sin(dot(2.5*gl_FragCoord.xy\/iResolution.xy, vec2(12.9898,100.233))) * 43758.5453), .4);\n\t\n\tfloat col=(pow(v,-.23)*pow(sin(c2.x),.99));\n\tfloat col2=(pow(sin(c1.y)+1.75,.99));\n\t\n    if(v>10.){\n\n\tfragColor = vec4(hsv(.8+sin(c3.r+col)*.3,.5-c3.r,.1+col*.75),1.);\n\t}\n\n\telse \n    \n    fragColor=vec4(hsv(.8+sin(col2)*.3,.5-col+sin(time*.4)*.3,col2*.3),1.);\n}\n\n\n","name":"","description":"","type":"image"}]}}