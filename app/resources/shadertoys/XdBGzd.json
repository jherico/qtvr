{"Shader":{"ver":"0.1","info":{"id":"XdBGzd","date":"1392082162","viewed":25703,"name":"Sphere - projection","username":"iq","description":"Analytic projection of a sphere to screen pixels. Spheres in world space become ellipses in clip space. The ellipses can be analytically determined from the camera and sphere geometry. This shaders computers their center, axis and area in raster pixels.","likes":50,"published":3,"flags":0,"tags":["3d","sphere","projection","analytic"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\/\/ Analytic projection of a sphere to screen pixels. \n\n\/\/ Spheres in world space become ellipses when projected to the camera view plane. In fact, these\n\/\/ ellipses can be analytically determined from the camera parameters and the sphere geometry,\n\/\/ such that their exact position, orientation and surface area can be compunted. This means that,\n\/\/ given a sphere and a camera and buffer resolution, there is an analytical formula that \n\/\/ provides the amount of pixels covered by a sphere in the image. This can be very useful for\n\/\/ implementing LOD for objects based on their size in screen (think of trees, vegetation, characters\n\/\/ or any other such complex object).\n\n\/\/ This shaders implements this formula, and provides too the center and axes of the ellipse\n\n\/\/ More info, here: http:\/\/www.iquilezles.org\/www\/articles\/sphereproj\/sphereproj.htm\n\n\/\/ ---------------------------------------------------------------------------------------------\n\nstruct ProjectionResult\n{\n    float area;      \/\/ probably all we care about in practical applications is the area, \n    vec2  center;    \/\/ but i'm outputing all the information for debugging and ilustration\n    vec2  axisA;     \/\/ purposes\n    vec2  axisB;\t\n\tfloat a, b, c, d, e, f;\n};\n\nProjectionResult projectSphere( \/* sphere        *\/ in vec4 sph, \n\t\t\t\t                \/* camera matrix *\/ in mat4 cam,\n\t\t\t\t\t\t\t    \/* projection    *\/ in float fle )\n{\n    \/\/ transform to camera space\t\n\tvec3  o = (cam*vec4(sph.xyz,1.0)).xyz;\n\t\n    float r2 = sph.w*sph.w;\n\tfloat z2 = o.z*o.z;\t\n\tfloat l2 = dot(o,o);\n\t\n\tfloat area = -3.141593*fle*fle*r2*sqrt(abs((l2-r2)\/(r2-z2)))\/(r2-z2);\n\t\n\t\/\/return area;\n\t\n\t\n    \/\/-- debug stuff ---\n\n\t\n\t\/\/ axis\n\tvec2 axa = fle*sqrt(-r2*(r2-l2)\/((l2-z2)*(r2-z2)*(r2-z2)))*vec2( o.x,o.y);\n\tvec2 axb = fle*sqrt(-r2*(r2-l2)\/((l2-z2)*(r2-z2)*(r2-l2)))*vec2(-o.y,o.x);\n\n    \/\/area = length(axa)*length(axb)*3.141593;\t\n\t\n\t\/\/ center\n\tvec2  cen = fle*o.z*o.xy\/(z2-r2);\n\n\treturn ProjectionResult( area, \n\t\t\t\t\t\t\t cen, axa, axb, \n                     \/* implicit ellipse f(x,y) = a\u00b7x\u00b2 + b\u00b7y\u00b2 + c\u00b7x\u00b7y + d\u00b7x + e\u00b7y + f = 0 *\/\n                     \/* a *\/ r2 - o.y*o.y - z2,\n                     \/* b *\/ r2 - o.x*o.x - z2,\n                     \/* c *\/ 2.0*o.x*o.y,\n                     \/* d *\/ 2.0*o.x*o.z*fle,\n                     \/* e *\/ 2.0*o.y*o.z*fle,\n                     \/* f *\/ (r2-l2+z2)*fle*fle );\n\t\n}\n\n\/\/-----------------------------------------------------------------\n\/\/ Digit drawing function by P_Malin (https:\/\/www.shadertoy.com\/view\/4sf3RN)\n\nfloat SampleDigit(const in float n, const in vec2 vUV)\n{\t\t\n\tif(vUV.x  < 0.0) return 0.0;\n\tif(vUV.y  < 0.0) return 0.0;\n\tif(vUV.x >= 1.0) return 0.0;\n\tif(vUV.y >= 1.0) return 0.0;\n\t\n\tfloat data = 0.0;\n\t\n\t     if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n\telse if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n\telse if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\t\n\tvec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n\tfloat fIndex = vPixel.x + (vPixel.y * 4.0);\n\t\n\treturn mod(floor(data \/ pow(2.0, fIndex)), 2.0);\n}\n\nfloat PrintInt(const in vec2 uv, const in float value )\n{\n\tfloat res = 0.0;\n\tfloat maxDigits = 1.0+ceil(log2(value)\/log2(10.0));\n\tfloat digitID = floor(uv.x);\n\tif( digitID>0.0 && digitID<maxDigits )\n\t{\n        float digitVa = mod( floor( value\/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n        res = SampleDigit( digitVa, vec2(fract(uv.x), uv.y) );\n\t}\n\n\treturn res;\t\n}\n\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\nfloat oSphere( in vec3 pos, in vec3 nor, in vec4 sph )\n{\n    vec3 di = sph.xyz - pos;\n    float l = length(di);\n    return 1.0 - max(0.0,dot(nor,di\/l))*sph.w*sph.w\/(l*l); \n}\n\nfloat ssSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = sph.xyz - ro;\n    float b = dot( oc, rd );\n\t\n    float res = 1.0;\n    if( b>0.0 )\n    {\n        float h = dot(oc,oc) - b*b - sph.w*sph.w;\n        res = smoothstep( 0.0, 1.0, 12.0*h\/b );\n    }\n    return res;\n}\n\nfloat sdSegment( vec2 a, vec2 b, vec2 p )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn length( pa - ba*h );\n}\n\nvec3 drawMaths( vec3 col, in ProjectionResult res, in vec2 p )\n{\n\tfloat showMaths = 1.0;\/\/smoothstep( -0.5, 0.5, cos(0.5*6.2831*iGlobalTime) );\n\n\tfloat impl = res.a*p.x*p.x + res.b*p.y*p.y + res.c*p.x*p.y + res.d*p.x + res.e*p.y + res.f;\n\t\n\tcol = mix( col, vec3(1.0,0.0,0.0), showMaths*(1.0-smoothstep(0.00,0.10, abs(impl))));\n\tcol = mix( col, vec3(1.0,1.0,0.0), showMaths*(1.0-smoothstep(0.00,0.01, sdSegment( res.center-res.axisA, res.center+res.axisA, p  )) ));\n\tcol = mix( col, vec3(1.0,1.0,0.0), showMaths*(1.0-smoothstep(0.00,0.01, sdSegment( res.center-res.axisB, res.center+res.axisB, p  )) ));\n\tcol = mix( col, vec3(1.0,0.0,0.0), showMaths*(1.0-smoothstep(0.03,0.04, length(p-res.center))));\n    vec2 pp  = res.center + 0.5*max( max( res.axisA, -res.axisA ), max( res.axisB, -res.axisB ) );\n\tcol = mix( col, vec3(1.0), PrintInt( ((p-pp)-vec2(0.0,0.0))\/0.07, floor(res.area) ) );\n\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) \/ iResolution.y;\n\t\n\tfloat fov = 1.0;\n\t\n\tfloat an = 12.0 + 0.5*iGlobalTime + 10.0*iMouse.x\/iResolution.x;\n\tvec3 ro = vec3( 3.0*cos(an), 0.0, 3.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n\tvec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\tvec3 rd = normalize( p.x*uu + p.y*vv + fov*ww );\n\tmat4 cam = mat4( uu.x, uu.y, uu.z, 0.0,\n\t\t\t\t\t vv.x, vv.y, vv.z, 0.0,\n\t\t\t\t\t ww.x, ww.y, ww.z, 0.0,\n\t\t\t\t\t -dot(uu,ro), -dot(vv,ro), -dot(ww,ro), 1.0 );\n\t\n\tvec4 sph1 = vec4(-2.0, 1.0,0.0,1.1);\n\tvec4 sph2 = vec4( 3.0, 1.5,1.0,1.2);\n\tvec4 sph3 = vec4( 1.0,-1.0,1.0,1.3);\n\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tfloat occ = 1.0;\n\tvec3  pos = vec3(0.0);\n\t\n\tvec3 sur = vec3(1.0);\n\tfloat h = iSphere( ro, rd, sph1 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n\t\tpos = ro + h*rd;\n\t\tnor = normalize(pos-sph1.xyz); \n\t\tocc = oSphere( pos, nor, sph2 ) * oSphere( pos, nor, sph3 );\n\t\tsur = vec3(1.0,0.7,0.2)*smoothstep(-0.6,-0.2,sin(20.0*(pos.x-sph1.x)));\n\t}\n\th = iSphere( ro, rd, sph2 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n\t\tpos = ro + h*rd;\n\t\tnor = normalize(pos-sph2.xyz); \n\t\tocc = oSphere( pos, nor, sph1 ) * oSphere( pos, nor, sph3 );\n\t\tsur = vec3(0.7,1.0,0.2)*smoothstep(-0.6,-0.2,sin(20.0*(pos.z-sph2.z)));\n\t}\n\th = iSphere( ro, rd, sph3 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n\t\tpos = ro + h*rd;\n\t\tnor = normalize(pos-sph3.xyz); \n\t\tocc = oSphere( pos, nor, sph1 ) * oSphere( pos, nor, sph2 );\n\t\tsur = vec3(1.0,0.2,0.2)*smoothstep(-0.6,-0.2,sin(20.0*(pos.y-sph3.y)));\n\t}\n\th = (-2.0-ro.y)\/rd.y;\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n\t\tpos = ro + h*rd;\n\t\tnor = vec3(0.0,1.0,0.0); \n\t\tocc = oSphere( pos, nor, sph1 ) * oSphere( pos, nor, sph2 ) * oSphere( pos, nor, sph3 );\n\t\tsur = vec3(1.0,1.0,1.0)*smoothstep(-1.0,-0.95,sin(8.0*pos.x))*smoothstep(-1.0,-0.95,sin(8.0*pos.z));\n\t}\n\n\tvec3 col = vec3(0.0);\n\n\tif( tmin<100.0 )\n\t{\n\t    pos = ro + tmin*rd;\n        col = vec3(1.0);\n\t\t\n\t\tvec3 lig = normalize( vec3(2.0,1.4,-1.0) );\n\t\tfloat sha = 1.0;\n\t\tsha *= ssSphere( pos, lig, sph1 );\n\t\tsha *= ssSphere( pos, lig, sph2 );\n\t\tsha *= ssSphere( pos, lig, sph3 );\n\n\t\tfloat ndl = clamp( dot(nor,lig), 0.0, 1.0 );\n\t\tcol = occ*(0.5+0.5*nor.y)*vec3(0.2,0.3,0.4) + sha*vec3(1.0,0.9,0.8)*ndl + sha*vec3(1.5)*ndl*pow( clamp(dot(normalize(-rd+lig),nor),0.0,1.0), 16.0 );\n\t\tcol *= sur;\n\t\t\n        col *= exp( -0.25*(max(0.0,tmin-3.0)) );\n\n\t}\n\n\tcol = pow( col, vec3(0.45) );\n\t\n\t\/\/-------------------------------------------------------\n\t\n\tProjectionResult res = projectSphere( sph1, cam, fov );\n\tres.area *= iResolution.y*iResolution.y*0.25;\n    if( res.area>0.0 ) col = drawMaths( col, res, p );\n\t\n\tres = projectSphere( sph2, cam, fov );\n\tres.area *= iResolution.y*iResolution.y*0.25;\n    if( res.area>0.0 ) col = drawMaths( col, res, p );\n\t\n\tres = projectSphere( sph3, cam, fov );\n\tres.area *= iResolution.y*iResolution.y*0.25;\n    if( res.area>0.0 ) col = drawMaths( col, res, p );\n\n\t\/\/-------------------------------------------------------\n\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}