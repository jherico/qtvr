{"Shader":{"ver":"0.1","info":{"id":"4tsGDS","date":"1425092994","viewed":780,"name":"Pedestal","username":"Impossible","description":"Reference:<br\/>iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm<br\/>paulbourke.net\/geometry\/sphericalh\/<br\/>www.filmicworlds.com\/2014\/04\/21\/optimizing-ggx-shaders-with-dotlh\/<br\/>Updated for VR!","likes":5,"published":3,"flags":1,"tags":["raymarching","distancefields","sphericalharmonics","ggx"],"hasliked":0},"renderpass":[{"inputs":[{"id":21,"src":"\/presets\/mzk04.mp3","ctype":"music","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"id":22,"src":"\/presets\/cube00_0.jpg","ctype":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"id":23,"src":"\/presets\/cube01_0.png","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define EPS 0.02\n#define PI 3.14159265359\n\nvec2 toPolar( vec3 p, float r )\n{\n    vec2 polar;\n    \n    polar.x = acos(p.z\/r);\n    polar.y = atan(p.y,p.x);\n    \n    return polar;\n}\n\nfloat myPow(float v, float n)\n{\n    float result = 1.0;\n    for(int i=0;i<16;i++)\n    {\n        if(i<int(n))\n\t        result*=v;\n    }\n    \n    return result;\n}\n\nfloat EvalSH(float theta,float phi)\n{\n\tfloat m[8];\n\n\tm[0] = mod(texture2D(iChannel2,vec2(0.0,0.0)).x * 8.,8.);\n\tm[1] = 5.;\n\tm[2] = 3.;\n\tm[3] = 2.;\n\tm[4] = 0.;\n\tm[5] = 1.;\n\tm[6] = 0.;\n\tm[7] = 0.;\n\n   float r = 0.;\n\n   r += myPow(sin(m[0]*phi),m[1]);\n   r += myPow(cos(m[2]*phi),m[3]);\n   r += myPow(sin(m[4]*theta),m[5]);\n   r += myPow(cos(m[6]*theta),m[7]);\n\n   return r;\n}\n\nfloat sdSH( vec3 p, float s )\n{\n  float r = length(p);\n  vec2 angles = toPolar(p,r);\n  return r - EvalSH(angles.y,angles.x);\n}\n\n\nvec3 shColor( vec3 p )\n{\n   vec3 col;\n   float r = length(p);\n   vec2 angles = toPolar(p,r);\n   r = EvalSH(angles.y,angles.x);\n   col.x = r * sin(angles.x) * cos(angles.y);\n   col.y = r * cos(angles.x);\n   col.z = r * sin(angles.x) * sin(angles.y); \n    \n    return col;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nmat3 rotateY(float angle)\n{\n    float cs = cos(angle);\n    float sn = sin(angle);\n    \n    mat3 m;\n    \n    m[0] = vec3(cs,0.,-sn);\n    m[1] = vec3(0.,1.,0.);\n    m[2] = vec3(sn,0.,cs);\n\n    \n    return m;\n}\n\nmat3 rotateZ(float angle)\n{\n    float cs = cos(angle);\n    float sn = sin(angle);\n    \n    mat3 m;\n    \n    m[0] = vec3(cs,-sn,0.);\n    m[1] = vec3(sn,cs,0.);\n    m[2] = vec3(0.,0.,1);\n\n    \n    return m;\n}\n\nmat3 rotateX(float angle)\n{\n    float cs = cos(angle);\n    float sn = sin(angle);\n    \n    mat3 m;\n    \n    m[0] = vec3(1.,0.,0.);\n    m[1] = vec3(0.,cs,-sn);\n    m[2] = vec3(0.,sn,cs);\n\n    \n    return m;\n}\n\n\nfloat G1V(float dotNV, float k)\n{\n    return 1.0\/(dotNV*(1.0-k)+k);\n}\n\n\nfloat GGXSpec( vec3 n, vec3 v, vec3 l, float roughness, float F0 )\n{\n\tfloat alpha = roughness*roughness;\n\n    vec3 h = normalize( n + l );\n    \n    float dotNL = max(0.,dot(n,l));\n    float dotNV = max(0.,dot(n,v));\n    float dotNH = max(0.,dot(n,h));\n    float dotLH = max(0.,dot(l,h));\n    \n    float F, D, vis;\n    \n    float alphaSqr = alpha * alpha;\n    float denom = dotNH * dotNH * (alphaSqr-1.0) + 1.0;\n    D = alphaSqr\/(PI * denom*denom);\n    \n    float dotLH5 = pow(1.0-dotLH,5.);\n    F = F0 + (1.0-F0)*(dotLH5);\n    \n    float k = alpha\/2.;\n    vis = G1V(dotNL,k)*G1V(dotNV,k);\n    \n    float specular = dotNL * D *F *vis;\n    \n    return specular;\n    \n}\n\nfloat map(vec3 p)\n{        \n    float rad = .1*sin(p.y*1.75) + ((p.y>-3.6)?smoothstep(-3.,-3.6,p.y)*0.35+2.95:2.4);\n    float res = min(sdCappedCylinder(p+vec3(0.,6.,0.),vec2(rad,3.)),sdSH(p,1.));\n     \n    \n    if(p.y<-3.4)\n    {\n  \t  \tfor(int i=0;i<25;i++)\n   \t\t{\n\t    \tfloat cs = cos(float(i)\/12.0*PI);\n   \t    \tfloat sn = sin(float(i)\/12.0*PI); \n\n    \t\tres = max(res,-sdCylinder(p+vec3(cs*(rad),0.,sn*(rad)),vec3(0.,.0,.2)));    \n    \t}\n    }    \n    return res;\n}\n\nvec3 normal(vec3 p)\n{\n    vec3 n;\n    \n    n.x = map(p + vec3(EPS,0.,0.)) - map(p-vec3(EPS,0.,0.));\n    n.y = map(p + vec3(0.,EPS,0.)) - map(p-vec3(0.,EPS,0.));\n    n.z = map(p + vec3(0.,0.,EPS)) - map(p-vec3(0.,0.,EPS));   \n    \n    return normalize(n);\n}\n\nfloat shadow( vec3 ro, vec3 rd )\n{\n    bool hit = false;\n    vec3 p = ro + rd;\n    float t = 0.;\n    float k = 16.;\n    float res = 1.;\n    \n    for( int i=0;i<32;i++)\n    {\n       float d = map(p);\n        \n        t+=d;\n        res = min( res, k*d\/t );\n        \n        if(d<EPS)\n        {\n            hit = true;\n            res = 0.;\n            break;\n        }\n        else if(t>15.)\n        {\n            hit = false;\n            break;\n        }\n      \n        p = ro + rd * t * 0.45;\n    }\n    \n    return res;\n}\n\n\nvoid rayMarch()\n{\n    \n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{    \n    \n    float cs = cos(mod(0.3*iGlobalTime,2.*PI));\n    float sn = sin(mod(0.3*iGlobalTime,2.*PI));\n    \n    ro += vec3(cs*7.,2.,7.*sn);\n    \n    mat3 m = rotateX(15.\/180.*PI);\n    mat3 m2 = rotateY(-mod(0.3*iGlobalTime,2.*PI)+PI*0.5);\n    rd = m2*m*rd; \n    \n    bool hit = false;\n    \n    vec3 p = ro + rd;\n    \n    float t = 0.;\n    \n    for( int i=0;i<256;i++)\n    {\n       float d = map(p);\n        \n        t+=d;\n        if(d<EPS)\n        {\n            hit = true;\n            break;\n        }\n        else if(t>200.)\n        {\n            hit = false;\n            break;\n        }\n        p = ro + rd * t * 0.1;\n    }\n    \n    float vignette = pow(1.-dot( fragCoord.xy \/ iResolution.xy - vec2(0.5,0.5), fragCoord.xy \/ iResolution.xy - vec2(0.5,0.5) ),3.);\n    \n    if (hit )\n    {\n        vec3 n = normal(p);\n        float ndv = dot(n,-rd);\n        float f0 = 0.15;\n        float fresnel = f0 + (1.-f0)*pow(1.-ndv,5.); \n        vec3 l = m2*m*normalize(vec3(iMouse.x - iResolution.x\/2.,iMouse.y - iResolution.y\/2.,200.));\n        float ndl = max(0.,dot(n,l));\n        \n        vec3 col = vec3(181.\/255.);\n        \n        vec4 spec = vec4(GGXSpec(n,rd,l,0.01,0.75));\n        \n\t\tfragColor = pow(((spec+vec4( ndl * col.r, ndl * col.g, ndl * col.b,1.0))*shadow(p,l) + fresnel*textureCube(iChannel0,n))*vignette,vec4(1.\/2.2));\n    }\n    else\n        fragColor = textureCube(iChannel1,rd)*vignette;    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 rd = vec3( ( fragCoord.xy \/ iResolution.xy  * 2.0) - 1.0, -1.0);\n    rd.x *= iResolution.x\/iResolution.y;\n    \n    rd = normalize(rd); \n    \n\tmainVR( fragColor, fragCoord, vec3(0,0,0), rd);\n}","name":"","description":"","type":"image"}]}}