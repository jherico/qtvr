{"Shader":{"ver":"0.1","info":{"id":"lssSRn","date":"1396028001","viewed":809,"name":"clipped disc hypertexture 1","username":"FabriceNeyret2","description":"hypertexture (here, sphere clipped by plane) with well controlled thickness, i.e., noise saturating the \"skin\" range.<br\/>mouse.x tune noise layer thickness<br\/>mouse.y tune noise bluriness<br\/>See #define for more tunings","likes":6,"published":3,"flags":0,"tags":["procedural"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define GAIN 1.6 \/\/ >1 is unsafe, but up to 2 still looks ok (noise don t sature dynamics)\n#define NOISE 1 \/\/ 1: linear  2: blobby (abs)  3:  hairy (1-abs)\n\n\/\/ --- scene    ( screen = [-1.8, 1.8] x [-1, 1] )\n\nvec2 sphere1Pos = vec2(0.,0.);\nfloat sphere1Rad = .7;         \/\/ sphere radius\n\nfloat planePos = .1;\n\nvec2 sphere2Pos = vec2(1.,0.);\nfloat sphere2Rad = .2;         \n\n\/\/ cloud appearance (superseeded by mouse tuning)\n\nfloat H = .2;                 \/\/ skin layer thickness ( % of normalized sphere)\nfloat sharp = 0.3;            \/\/ cloud sharness (0= ultra sharp ).\n\n\n\n#define ANIM 1         \/\/ 1\/0\n#if ANIM\n   float t = iGlobalTime;\n#else\n  float t = 0.; \n#endif\n\n#define PI 3.14159\n\n\/\/ --- noise functions from https:\/\/www.shadertoy.com\/view\/XslGRr\n\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )  \/\/ base rand in [0,1]; \n{\n    return fract(sin(n-765.36334)*43758.5453);\n    \/\/return -1.+2.*fract(sin(n-765.36334)*43758.5453);\n}\n\nfloat noise( in vec3 x ) \/\/ base noise in [0,1]; \n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n#if NOISE==1\n\treturn res;\n#elif NOISE==2\n\treturn abs(2.*res-1.);\n#elif NOISE==3\n\treturn 1.-abs(2.*res-1.);\n#endif\n}\n\nfloat fbm( vec3 p ) \/\/ turbulent (=fractal) noise in [0,1]; \n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\/\/ --- End of: Created by inigo quilez --------------------\n\n\n\n\/\/ smooth distance to sphere = [-1,1] around radius +- thickness H\n\nfloat sphere(vec2 uv, vec2 spherePos, float sphereRad)\n{\n\tvec2 p = (uv-spherePos)\/sphereRad; \/\/ pos in sphere normalized coordinates\n\tfloat d = (1.-length(p))\/H;  \n\treturn clamp(d,-1.,1.);\n}\n\t\t\n\/\/ smooth distance to plane = [-1,1] around plane +- thickness H\n\nfloat plane(vec2 uv, float planePos, float planeRad) \/\/ planeRad to share normalization with spheres\n{\n\tvec2 p = uv-vec2(planePos,0.); \/\/ pos in sphere normalized coordinates\n\tfloat d = -p.x\/(H*planeRad);  \n\treturn clamp(d,-1.,1.);\n}\n\t\n\/\/ smooth intersect operator\n\nfloat inter(float d0, float d1) {\n\td0 = (1.+d0)\/2.;    \t \/\/   [-1,1] -> [0,1], mul,  [0,1] -> [-1,1]\n\td1 = (1.+d1)\/2.;\n\treturn 2.*d0*d1 -1.;\n}\n\n\/\/ smooth union operator\n\nfloat add(float d0, float d1) {\n\td0 = (1.+d0)\/2.;     \t\/\/   [-1,1] -> [0,1], add,  [0,1] -> [-1,1]\n\td1 = (1.+d1)\/2.;\n\treturn 2.*(d0+d1-d0*d1) -1.;\n}\n\n\/\/ jitter the distance around 0  and smoothclamp\n\nfloat perturb(vec2 p, float d, float H) {\n    \/\/float fillfactor=0.; d = (d+1.)*fillfactor-1.;\n\tif (d<=-1.) return -1.;  \t\t\t\/\/ exterior\n\tif (d>= 1.) return 1.;   \t\t\t\/\/ interior (1 when H% inside radius )\n\t\n\tfloat n = 2.*fbm(vec3(p\/H,t)) -1.;  \/\/ perturbation in [-1,1]\n\treturn  2.*(d + GAIN*n);   \t\t\t\/\/ still in [-1,1] :-)\n}\n\n\/\/ convert [-1,1] distances into densities\n\nfloat dist2dens(float d) {  \t\/\/ transition around zero. Tunable sharpness\n\treturn smoothstep(-sharp,sharp,d);\n}\n\n\n\/\/ user-define shape\n\t\nfloat shape(vec2 uv,float n) {\n\t\n\tfloat v1 = sphere(uv, sphere1Pos, sphere1Rad),\n\t\t  v2 = plane (uv, planePos,   sphere1Rad), \/\/ share normalization radius\n\t\t  v3 = sphere(uv, sphere2Pos, sphere2Rad);\n\tfloat v;\n\n#define globalNoise false\n\t\n\tif (globalNoise || (n==0.)) {\n\t\tv = add( inter(v1,v2), v3 );               \/\/ we combine smooth distances *then* perturbate\n\t\tif (n>0.) v = perturb(uv, v,H*sphere1Rad);\n\t}\n\telse {\n\t\tv = perturb(uv, inter(v1,v2), H*sphere1Rad); \/\/ we perturbate (with different coefs) *then* combine\n\t\tv = add( v, perturb(uv, v3 , H*sphere2Rad));\n\t}\n\t\n\treturn v;\n}\n\n\/\/ main loop\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.* (fragCoord.xy \/ iResolution.y - vec2(.8,.5) );\n\tif (iMouse.z>0.) {       \t\t\t\t   \/\/ mouse tuning\n\t\tvec2 m = iMouse.xy \/ iResolution.xy;\n\t\tH = m.x+1e-5 ; sharp = m.y+1e-5; \n\t}\n\n\tfloat v = dist2dens( shape(uv,1.) ); \n\tvec3 col = vec3(v);\n\t\n\tif (uv.y<0.) {                   \t \/\/ bottom half scren: display bounds\n\t\t\n\t\tsharp = 1e-5; \/\/ no noise for bounds\n\t\tfloat d = shape(uv,0.), dv = fwidth(d);\n\t\t\n\t\tv = dist2dens(d-0.99+dv)-dist2dens(d-0.99); \/\/ inner bound : draw on top\n\t\tcol = mix(col, vec3(v,0.,0.),v);\t\n\t\t\n\t\tv = dist2dens(d+.5*dv)-dist2dens(d-.5*dv);  \/\/ mid-bound: draw on top\n\t\tcol = mix(col, vec3(0.,v,0.),v);\n\t\t\n\t\tv = dist2dens(d+.99)-dist2dens(d+0.99-dv);  \/\/ exterior bound : draw below\n\t\tfloat alpha = max(col.r,col.g);\n\t\tcol = mix(vec3(0.,0.,v),col, alpha);\t\n\t\talpha = max(col.b,alpha);\n\t\t\n\t\tv = dist2dens(sphere(uv, sphere1Pos, sphere1Rad)+.99); \/\/ sphere without plane clipping\n\t\tcol = mix(v*vec3(0.,0.,.3),col, alpha);\t\n\t}\n\t\n    fragColor = vec4(col,0.); \n}\n","name":"","description":"","type":"image"}]}}