{"Shader":{"ver":"0.1","info":{"id":"lslXRj","date":"1404836685","viewed":2560,"name":"Wax (fake subsurface)","username":"TekF","description":"Another fake lighting trick with distance fields.><br\/>Press: D - dark scene, S - toggle sub-surface, A,R - toggle occlusion, L - lens effects><br\/>Mouse drag: move camera","likes":42,"published":3,"flags":0,"tags":["distancefields","subsurfacescattering"],"hasliked":0},"renderpass":[{"inputs":[{"id":10,"src":"\/presets\/tex09.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Ben Quantock 2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ artefacts from noise texture interpolation\n\/\/#define FAST\n\n\/\/ keys\nint kA=65,kB=66,kC=67,kD=68,kE=69,kF=70,kG=71,kH=72,kI=73,kJ=74,kK=75,kL=76,kM=77,kN=78,kO=79,kP=80,kQ=81,kR=82,kS=83,kT=84,kU=85,kV=86,kW=87,kX=88,kY=89,kZ=90;\nint k0=48,k1=49,k2=50,k3=51,k4=52,k5=53,k6=54,k7=55,k8=56,k9=57;\nint kSpace=32,kLeft=37,kUp=38,kRight=39,kDown=40;\n\n\n\/\/ TOGGLES:\n\nint kAmbientOcclusion = kA;\nint kReflectionOcclusion = kR;\nint kSubsurface = kS;\nint kLensFX = kL;\nint kDarkScene = kD;\n\n\n\/\/ consts\nconst float tau = 6.2831853;\nconst float phi = 1.61803398875;\n\n\/\/ globals\nvec3 envBrightness = vec3(1);\nconst vec3 darkEnvBrightness = vec3(.02,.03,.05);\n\n\n\/\/ key is javascript keycode: http:\/\/www.webonweboff.com\/tips\/js\/event_key_codes.aspx\nbool ReadKey( int key, bool toggle )\n{\n\tfloat keyVal = texture2D( iChannel3, vec2( (float(key)+.5)\/256.0, toggle?.75:.25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\n\nbool Toggle( int val )\n{\n\treturn !ReadKey( val, true );\n}\n\n\nvec2 Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\n#ifdef FAST\n\tvec4 rg = texture2D( iChannel0, (uv+0.5)\/256.0, -100.0 );\n#else\n\t\/\/ high precision interpolation, if needed\n\tvec4 rg = mix( mix(\n\t\t\t\ttexture2D( iChannel0, (floor(uv)+0.5)\/256.0, -100.0 ),\n\t\t\t\ttexture2D( iChannel0, (floor(uv)+vec2(1,0)+0.5)\/256.0, -100.0 ),\n\t\t\t\tfract(uv.x) ),\n\t\t\t\t  mix(\n\t\t\t\ttexture2D( iChannel0, (floor(uv)+vec2(0,1)+0.5)\/256.0, -100.0 ),\n\t\t\t\ttexture2D( iChannel0, (floor(uv)+1.5)\/256.0, -100.0 ),\n\t\t\t\tfract(uv.x) ),\n\t\t\t\tfract(uv.y) );\n#endif\t\t\t  \n\n\treturn mix( rg.yw, rg.xz, f.z );\n}\n\n\nfloat Sphere( vec3 p, vec3 c, float r )\n{\n\treturn length(p-c)-r;\n}\n\nfloat Tet( vec3 p, vec3 c, float r )\n{\n\tp -= c;\n\tvec2 s = -vec2(1,-1)\/sqrt(3.0);\n\treturn max(max(max(\n\t\t\tdot(p,s.xxx),dot(p,s.yyx)),\n\t\t\tdot(p,s.yxy)),dot(p,s.xyy)) - r*mix(1.0,1.0\/sqrt(3.0),1.0);\n}\n\nfloat Oct( vec3 p, vec3 c, float r )\n{\n\tp -= c;\n\tvec2 s = vec2(1,-1)\/sqrt(3.0);\n\treturn max(max(max(\n\t\t\tabs(dot(p,s.xxx)),abs(dot(p,s.yyx))),\n\t\t\tabs(dot(p,s.yxy))),abs(dot(p,s.xyy))) - r*mix(1.0,1.0\/sqrt(3.0),.5);\n}\n\nfloat Cube( vec3 p, vec3 c, float r )\n{\n\tp -= c;\n\treturn max(max(abs(p.x),abs(p.y)),abs(p.z))-r*mix(1.0,1.0\/sqrt(3.0),.5);\n}\n\nfloat CubeFrame( vec3 p, vec3 c, float r )\n{\n\tr = r*mix(1.0,1.0\/sqrt(3.0),.5);\n\tp -= c;\n\tp = abs(p);\n\tfloat rr = r*.1;\n\tp -= vec3(r-rr);\n\t\/\/ whichever axis is most negative should be clamped to 0\n\tif ( p.x < p.z ) p = p.zyx;\n\tif ( p.y < p.z ) p = p.xzy;\n\tp.z = max(0.0,p.z);\n\treturn length(p)-rr;\n}\n\nfloat DistanceField( vec3 p, float t )\n{\n\treturn\n\t\t\tmin(min(min(\n\t\t\t\tSphere(p,vec3(0,.48,0),.1),\n\t\t\t\tOct(p,vec3(0,.2,0),.2)),\n\t\t\t\tCubeFrame(p,vec3(0,-.05,0),.3)),\n\t\t\t\tSphere(p,vec3(0,-.6,0),.4));\n\n\t\/\/ spiral candle\n\/*\tp.xz = p.xz*cos(p.y*4.0)+vec2(1,-1)*p.zx*sin(p.y*4.0);\n\treturn max(\n\t\t\t\tmax( p.y-.5, -p.y-1.),\n\t\t\t\t(min(\n\t\t\t\t\tmax(abs(p.x),abs(p.z)),\n\t\t\t\t\tmax(abs(p.x+p.z),abs(p.z-p.x))\/sqrt(2.0)\n\t\t\t\t)-.15)*.8);*\/\n}\n\nfloat DistanceField( vec3 p )\n{\n\treturn DistanceField( p, 0.0 );\n}\n\n\nvec3 Sky( vec3 ray )\n{\n\treturn envBrightness*mix( vec3(.8), vec3(0), exp2(-(1.0\/max(ray.y,.01))*vec3(.4,.6,1.0)) );\n}\n\n\nvec3 Shade( vec3 pos, vec3 ray, vec3 normal, vec3 lightDir1, vec3 lightDir2, vec3 lightCol1, vec3 lightCol2, float shadowMask1, float shadowMask2, float distance )\n{\n\tvec3 ambient = envBrightness*mix( vec3(.2,.27,.4), vec3(.4), (-normal.y*.5+.5) ); \/\/ ambient\n\/\/\t\tambient = mix( vec3(.03,.05,.08), vec3(.1), (-normal.y+1.0) ); \/\/ ambient\n\t\/\/ ambient occlusion, based on my DF Lighting: https:\/\/www.shadertoy.com\/view\/XdBGW3\n\tfloat aoRange = distance\/20.0;\n\t\n\tfloat occlusion = max( 0.0, 1.0 - DistanceField( pos + normal*aoRange )\/aoRange ); \/\/ can be > 1.0\n\tocclusion = exp2( -2.0*pow(occlusion,2.0) ); \/\/ tweak the curve\n\tif ( Toggle(kAmbientOcclusion) )\n\t\tambient *= occlusion*.8+.2; \/\/ reduce occlusion to imply indirect sub surface scattering\n\n\tfloat ndotl1 = max(.0,dot(normal,lightDir1));\n\tfloat ndotl2 = max(.0,dot(normal,lightDir2));\n\tfloat lightCut1 = smoothstep(.0,.1,ndotl1);\/\/pow(ndotl,2.0);\n\tfloat lightCut2 = smoothstep(.0,.1,ndotl2);\/\/pow(ndotl,2.0);\n\n\tvec3 light = vec3(0);\n\/\/\tif ( Toggle(kDirectLight,3) )\n\tlight += lightCol1*shadowMask1*ndotl1;\n\tlight += lightCol2*shadowMask2*ndotl2;\n\n\n\t\/\/ And sub surface scattering too! Because, why not?\n\tfloat transmissionRange = distance\/10.0; \/\/ this really should be constant... right?\n\tfloat transmission1 = DistanceField( pos + lightDir1*transmissionRange )\/transmissionRange;\n\tfloat transmission2 = DistanceField( pos + lightDir2*transmissionRange )\/transmissionRange;\n\tvec3 sslight = lightCol1 * smoothstep(0.0,1.0,transmission1) + lightCol2 * smoothstep(0.0,1.0,transmission2);\n\tvec3 subsurface = vec3(1,.8,.5) * sslight;\n\n\n\tfloat specularity = Noise(pos\/vec3(.05,.2,.05)).x;\n\t\n\tvec3 h1 = normalize(lightDir1-ray);\n\tvec3 h2 = normalize(lightDir2-ray);\n\tfloat specPower = exp2(3.0+5.0*specularity);\n\tvec3 specular1 = lightCol1*shadowMask1*pow(max(.0,dot(normal,h1))*lightCut1, specPower)*specPower\/32.0;\n\tvec3 specular2 = lightCol2*shadowMask2*pow(max(.0,dot(normal,h2))*lightCut2, specPower)*specPower\/32.0;\n\t\n\tvec3 rray = reflect(ray,normal);\n\tvec3 reflection = Sky( rray );\n\t\n\t\n\t\/\/ specular occlusion, adjust the divisor for the gradient we expect\n\tfloat specOcclusion = max( 0.0, 1.0 - DistanceField( pos + rray*aoRange )\/(aoRange*max(.01,dot(rray,normal))) ); \/\/ can be > 1.0\n\tspecOcclusion = exp2( -2.0*pow(specOcclusion,2.0) ); \/\/ tweak the curve\n\t\n\t\/\/ prevent sparkles in heavily occluded areas\n\tspecOcclusion *= occlusion;\n\n\tif ( Toggle(kReflectionOcclusion) )\n\t\treflection *= specOcclusion; \/\/ could fire an additional ray for more accurate results\n\t\n\tfloat fresnel = pow( 1.0+dot(normal,ray), 5.0 );\n\tfresnel = mix( mix( .0, .01, specularity ), mix( .4, 1.0, specularity ), fresnel );\n\t\n\n\/\/\tvec3 albedo = vec3(1,.95,.9);\n\tvec3 albedo = vec3(.7,.5,1);\n\/\/\tvec3 albedo = vec3(.5,.3,.13);\n\t\n\tvec3 result = vec3(0);\n\n\t\/\/ comment these out to toggle various parts of the effect\n\tlight += ambient;\n\n\tif ( Toggle(kSubsurface) )\n\t\tlight += subsurface;\n\t\n\tresult = light*albedo;\n\n\tresult = mix( result, reflection, fresnel );\n\t\n\tresult += specular1 + specular2;\n\n\treturn result;\n}\n\n\n\n\n\/\/ Isosurface Renderer\n#ifdef FAST\nconst int traceLimit=40;\nconst float traceSize=.005;\n#else\nconst int traceLimit=60;\nconst float traceSize=.002;\n#endif\t\n\nfloat Trace( vec3 pos, vec3 ray, float traceStart, float traceEnd )\n{\n\tfloat t = traceStart;\n\tfloat h;\n\tfor( int i=0; i < traceLimit; i++ )\n\t{\n\t\th = DistanceField( pos+t*ray, t );\n\t\tif ( h < traceSize || t > traceEnd )\n\t\t\tbreak;\n\t\tt = t+h;\n\t}\n\t\n\tif ( t > traceEnd )\/\/|| h > .001 )\n\t\treturn 0.0;\n\t\n\treturn t;\n}\n\nfloat TraceMin( vec3 pos, vec3 ray, float traceStart, float traceEnd )\n{\n\tfloat Min = traceEnd;\n\tfloat t = traceStart;\n\tfloat h;\n\tfor( int i=0; i < traceLimit; i++ )\n\t{\n\t\th = DistanceField( pos+t*ray, t );\n\t\tMin = min(h,Min);\n\t\tif ( \/*h < .001 ||*\/ t > traceEnd )\n\t\t\tbreak;\n\t\tt = t+max(h,.1);\n\t}\n\t\n\treturn Min;\n}\n\nvec3 Normal( vec3 pos, vec3 ray, float t )\n{\n\t\/\/ in theory we should be able to get a good gradient using just 4 points\n\n\tfloat pitch = .2 * t \/ iResolution.x;\n#ifdef FAST\n\t\/\/ don't sample smaller than the interpolation errors in Noise()\n\tpitch = max( pitch, .005 );\n#endif\n\t\n\tvec2 d = vec2(-1,1) * pitch;\n\n\tvec3 p0 = pos+d.xxx; \/\/ tetrahedral offsets\n\tvec3 p1 = pos+d.xyy;\n\tvec3 p2 = pos+d.yxy;\n\tvec3 p3 = pos+d.yyx;\n\t\n\tfloat f0 = DistanceField(p0,t);\n\tfloat f1 = DistanceField(p1,t);\n\tfloat f2 = DistanceField(p2,t);\n\tfloat f3 = DistanceField(p3,t);\n\t\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3);\n\t\n\t\/\/ prevent normals pointing away from camera (caused by precision errors)\n\tfloat gdr = dot ( grad, ray );\n\tgrad -= max(.0,gdr)*ray;\n\t\n\treturn normalize(grad);\n}\n\n\n\/\/ Camera\n\nvec3 Ray( float zoom, in vec2 fragCoord )\n{\n\treturn vec3( fragCoord.xy-iResolution.xy*.5, iResolution.x*zoom );\n}\n\nvec3 Rotate( inout vec3 v, vec2 a )\n{\n\tvec4 cs = vec4( cos(a.x), sin(a.x), cos(a.y), sin(a.y) );\n\t\n\tv.yz = v.yz*cs.x+v.zy*cs.y*vec2(-1,1);\n\tv.xz = v.xz*cs.z+v.zx*cs.w*vec2(1,-1);\n\t\n\tvec3 p;\n\tp.xz = vec2( -cs.w, -cs.z )*cs.x;\n\tp.y = cs.y;\n\t\n\treturn p;\n}\n\n\n\/\/ Camera Effects\n\nvoid BarrelDistortion( inout vec3 ray, float degree )\n{\n\t\/\/ would love to get some disperson on this, but that means more rays\n\tray.z \/= degree;\n\tray.z = ( ray.z*ray.z - dot(ray.xy,ray.xy) ); \/\/ fisheye\n\tray.z = degree*sqrt(ray.z);\n}\n\nvec3 LensFlare( vec3 ray, vec3 lightCol, vec3 light, float lightVisible, float sky, vec2 fragCoord )\n{\n\tvec2 dirtuv = fragCoord.xy\/iResolution.x;\n\t\n\tfloat dirt = 1.0-texture2D( iChannel1, dirtuv ).r;\n\t\n\tfloat l = (dot(light,ray)*.5+.5);\n\t\n\treturn (\n\t\t\t((pow(l,30.0)+.05)*dirt*.1\n\t\t\t+ 1.0*pow(l,200.0))*lightVisible + sky*1.0*pow(l,5000.0)\n\t\t   )*lightCol\n\t\t   + 5.0*pow(smoothstep(.9999,1.0,l),20.0) * smoothstep(.5,1.0,lightVisible) * normalize(lightCol);\n}\n\n\nfloat SmoothMax( float a, float b, float smoothing )\n{\n\treturn a-sqrt(smoothing*smoothing+pow(max(.0,a-b),2.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tif ( !Toggle(kDarkScene) )\n\t\tenvBrightness = darkEnvBrightness;\n\t\n\tvec3 ray = Ray(1.0,fragCoord);\n\t\n\tif ( Toggle(kLensFX) )\n\t\tBarrelDistortion( ray, .5 );\n\t\n\tray = normalize(ray);\n\tvec3 localRay = ray;\n\n\tvec2 mouse = vec2(0);\n\t\/\/if ( iMouse.z > 0.0 )\n\t\tmouse = .5-iMouse.yx\/iResolution.yx;\n\t\t\n\tfloat T = iGlobalTime*.1;\n\tvec3 pos = 3.0*Rotate( ray, vec2(.2,1.0-T)+vec2(-1.0,-6.3)*mouse );\n\t\/\/pos += vec3(0,.3,0) + T*vec3(0,0,-1);\n\t\n\tvec3 col;\n\n\tvec3 lightDir1 = normalize(vec3(3,1,-2));\n\tfloat lt = iGlobalTime;\n\tvec3 lightPos = vec3(cos(lt*.9),sin(lt\/phi),sin(lt))*vec3(.6,1.2,.6);\n\t\n\tvec3 lightCol1 = vec3(1.1,1,.9)*.7*envBrightness;\n\tvec3 lightCol2 = vec3(.8,.4,.2)*1.0;\n\t\n\tfloat lightRange2 = .4; \/\/ distance of intensity = 1.0\n\t\n\tfloat traceStart = .5;\n\tfloat traceEnd = 40.0;\n\t\n\tfloat t = Trace( pos, ray, traceStart, traceEnd );\n\tif ( t > .0 )\n\t{\n\t\tvec3 p = pos + ray*t;\n\t\t\n\t\t\/\/ shadow test\n\t\tvec3 lightDir2 = lightPos-p;\n\t\tfloat lightIntensity2 = length(lightDir2);\n\t\tlightDir2 \/= lightIntensity2;\n\t\tlightIntensity2 = lightRange2\/(.1+lightIntensity2*lightIntensity2);\n\t\t\n\t\tfloat s1 = 0.0;\n\t\ts1 = Trace( p, lightDir1, .05, 2.0 );\n\t\tfloat s2 = 0.0;\n\t\ts2 = Trace( p, lightDir2, .05, 2.0 );\n\t\t\n\t\tvec3 n = Normal(p, ray, t);\n\t\tcol = Shade( p, ray, n, lightDir1, lightDir2,\n\t\t\t\t\tlightCol1, lightCol2*lightIntensity2,\n\t\t\t\t\t(s1>.0)?0.0:1.0, (s2>.0)?0.0:1.0, t );\n\t\t\n\t\t\/\/ fog\n\t\tfloat f = 200.0;\n\t\tcol = mix( vec3(.8), col, exp2(-t*vec3(.4,.6,1.0)\/f) );\n\t}\n\telse\n\t{\n\t\tcol = Sky( ray );\n\t}\n\t\n\tif ( Toggle(kLensFX) )\n\t{\n\t\tvec3 lightDir2 = lightPos-pos;\n\t\tfloat lightIntensity2 = length(lightDir2);\n\t\tlightDir2 \/= lightIntensity2;\n\t\tlightIntensity2 = lightRange2\/(.1+lightIntensity2*lightIntensity2);\n\n\t\t\/\/ lens flare\n\t\tfloat s1 = TraceMin( pos, lightDir1, .5, 40.0 );\n\t\tfloat s2 = TraceMin( pos, lightDir2, .5, 40.0 );\n\t\tcol += LensFlare( ray, lightCol1, lightDir1, smoothstep(-.04,.1,s1), step(t,.0), fragCoord );\n\t\tcol += LensFlare( ray, lightCol2*lightIntensity2, lightDir2, smoothstep(-.04,.1,s2), step(t,.0), fragCoord );\n\t\n\t\t\/\/ vignetting:\n\t\tcol *= smoothstep( .5, .0, dot(localRay.xy,localRay.xy) );\n\t\n\t\t\/\/ compress bright colours, ( because bloom vanishes in vignette )\n\t\tvec3 c = (col-1.0);\n\t\tc = sqrt(c*c+.05); \/\/ soft abs\n\t\tcol = mix(col,1.0-c,.48); \/\/ .5 = never saturate, .0 = linear\n\t\t\n\t\t\/\/ grain\n\t\tvec2 grainuv = fragCoord.xy + floor(iGlobalTime*60.0)*vec2(37,41);\n\t\tvec2 filmNoise = texture2D( iChannel0, .5*grainuv\/iChannelResolution[0].xy ).rb;\n\t\tcol *= mix( vec3(1), mix(vec3(1,.5,0),vec3(0,.5,1),filmNoise.x), .1*filmNoise.y );\n\t}\n\t\n\t\/\/ compress bright colours\n\tfloat l = max(col.x,max(col.y,col.z));\/\/dot(col,normalize(vec3(2,4,1)));\n\tl = max(l,.01); \/\/ prevent div by zero, darker colours will have no curve\n\tfloat l2 = SmoothMax(l,1.0,.01);\n\tcol *= l2\/l;\n\t\n\tfragColor = vec4(pow(col,vec3(1.0\/2.2)),1);\n}\n","name":"","description":"","type":"image"}]}}