{"Shader":{"ver":"0.1","info":{"id":"XdlXDr","date":"1399404228","viewed":1028,"name":"dist 2 spline #3","username":"FabriceNeyret2","description":"M: toggles construction mesh     L: toggles distance field \/ thin line<br\/>G: show gradient                        I: show isolines<br\/>C: shows parts drawn with the costly algo","likes":7,"published":3,"flags":0,"tags":["spline"],"hasliked":0},"renderpass":[{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ efficient distance to spline relying on the iterative construction of splines.\n\n#define POINTS 8  \t\t \/\/ number of control points\n\nconst int   SUBDIV=5;    \/\/ subdivision depth for the analytic method\nconst float sample=120.; \/\/ number of samples per spline for the costly method\n\nbool SHOW_MESH, SHOW_LINE, SHOW_GRAD, SHOW_ISO, SHOW_COSTLY;\n\n\/\/ --- GUI utils\n\nfloat t = iGlobalTime;\n\nbool keyToggle(int ascii) {\n\treturn (texture2D(iChannel2,vec2((.5+float(ascii))\/256.,0.75)).x > 0.);\n}\nfloat showFlag(vec2 p, vec2 uv, float v) {\n\tfloat d = length(2.*(uv-p));\n\treturn \t1.-step(.06*v,d) + smoothstep(0.005,0.,abs(d-.06));\n}\nfloat showFlag(vec2 p, vec2 uv, bool flag) {\n\treturn showFlag(p, uv, (flag) ? 1.: 0.);\n}\n\n\n\/\/ --- math utils\n\nfloat cross(vec2 v0, vec2 v1) {\treturn v0.x*v1.y - v0.y*v1.x; }\nfloat amin(float a, float b) { return (abs(a)<abs(b)) ? a : b ; }\nfloat amax(float a, float b) { return (abs(a)>abs(b)) ? a : b ; }\nfloat dist2(vec2 P0, vec2 P1) { vec2 D=P1-P0; return dot(D,D); }\n\nfloat hash (float i) { return 2.*fract(sin(i*7467.25)*1e5) - 1.; }\nvec2  hash2(float i) { return vec2(hash(i),hash(i-.1)); }\nvec4  hash4(float i) { return vec4(hash(i),hash(i-.1),hash(i-.3),hash(i+.1)); }\n\t\n\/\/ --- dist pos to seg P0P1\n\nbool SIGNED_DIST = true; \/\/ if signed, positive distance is at left of oriented segment\nbool FLIP=false;         \/\/ for normalized turn direction (we want dist negative inside shape)\n\nfloat dist2seg(vec2 pos, vec2 P0, vec2 P1) {\n\tif (FLIP) { vec2 tmp=P0; P0=P1; P1=tmp; }\n\tvec2 P0P1 = P1-P0, P0Pos = pos-P0;\n\tfloat d, l2_01=dist2(P0,P1);\n\n\t\/\/ --- if projection out of segment bounds, dist to extremity\n\t\/\/ Note that sign is set to '+' at extremity (should'nt be reached from inside cvx shape)\n\tfloat l = dot(P0Pos, P0P1)\/l2_01;\n\tif      (l <= 0.) return distance(pos,P0);\n\telse if (l >= 1.) return distance(pos,P1);\n\n\t\/\/ --- dist to seg = dist to line\n\telse if (SIGNED_DIST) \n\t    { float D = cross(P0P1,P0Pos); return D\/sqrt(l2_01); }\n\telse return distance(pos, P0+l*P0P1);\n}\n\n\/\/ --- min\/max dist to quadrilateral P0P1P2P3 (possibly non-convex)\n\nvec2 dist2quadri(vec2 pos, vec2 P0, vec2 P1, vec2 P2, vec2 P3) {\n\n\tvec2 P01 = P1-P0, P12 = P2-P1, P23 = P3-P2, P30 = P0-P3;\n\n\t\/\/ makes the quadri convex if not: the 4 turns must have same sign.\n\t\/\/    Note that alternate signs cannot happen (wouldn't loop), so possibility are:\n\t\/\/ all same, 1 different ('>'), 2 + then 2 - ('X').\n\t\/\/ for '>' shape, indeed it's no problem if it's in 0 or 3. otherwise bounding triangle.\n\n\t\/\/ measure turns direction\n#define ssign(v) (((v)>=0.) ? 1 : -1)\n\tint t0 = ssign(cross(P30,P01)), t1 = ssign(cross(P01,P12)),\t\n\t\tt2 = ssign(cross(P12,P23)), t3 = ssign(cross(P23,P30));\n\tif (SIGNED_DIST &&(t0>0)) \/\/ if direct, makes it indirect: we want negative inside\n\t\t{ FLIP = true; t0=-t0; t1=-t1; t2=-t2; t3=-t3; } \n\telse  FLIP = false;\n\tint t = t0+t1+t2+t3; \/\/ sum of turn sign = +- 4, +-2 or 0.\n\t\n\tfloat d01 = dist2seg(pos,P0,P1), d12 = dist2seg(pos,P1,P2), \n\t\t  d23 = dist2seg(pos,P2,P3), d30 = dist2seg(pos,P3,P0);\n\t\/\/ take care: dji != -dij at extremities since must be always positive outside\n\tfloat d0, d1;\n\t\n\tif ((t==4)||(t==-4)) \/\/ --- all same sign: P0P1P2P3 convex-> paths 0123, 30\n\t\t\t{ d0 = amin( amin( d01, d12 ), d23);\td1 = d30; } \n\n\telse {\n\t  float d13 = dist2seg(pos,P1,P3), d02 = dist2seg(pos,P0,P2);\n\t  float d21 = (SIGNED_DIST) ?  dist2seg(pos,P2,P1) : d12;\n\n\t  if (t==0)         \/\/ --- 'X' shape\n\t\tif(t0==t1)  \/\/ swap 2 & 3 : P0P1P3P2 -> paths 013, 320\n\t\t    { if (SIGNED_DIST) { d02 = dist2seg(pos,P2,P0); d23 = dist2seg(pos,P3,P2); }\n\t\t\t  d0 = amin(d01,d13);\t\t\t\t\td1 = amin(d02,d23); }\n\t    else \t    \/\/ swap 1 & 2 : P0P2P1P3-> paths 0213, 30\n\t\t\t{ d0 = amin( amin( d02, d21 ), d13);\td1 = d30; }\t\t\n\n\t  else  \/\/ t == +-2   \/\/  --- '>' shape : one sign different -> bounding triangle\n\t\tif (t1*t<0)       \/\/ it's P1 : del it.  -> P0P2P2P3 -> paths 023, 30\n\t\t\t{ d0 = amin( d02, d23);\t\t\t\t\td1 = d30; }\n\t\telse if (t2*t<0)  \/\/ it's P2 : del it.  -> P0P1P1P3 -> paths 013, 30\n\t\t\t{ d0 = amin( d01, d13);\t\t\t\t\td1 = d30; }\n\t\telse              \/\/ it's P0 or P3: in facts, that's fine.\n\t\t\t{ d0 = amin( amin( d01, d12 ), d23);\td1 = d30; }\n\t  }\n\n\treturn vec2( amin(d0,d1), amax(d0,d1) );\n}\n\n\n\/\/ --- dist to spline - costly (for pixels where smart method failed )\n\n\/\/ TODO: - recursive subdivision\n\/\/       - Newton iterations to  min dist\n\/\/       - adaptive stepping (especially when used on small spline section)\n\/\/       - sampling = diameter*pi*resolution\n\/\/ (anyway this function has negligible cost since rarely used).\nvec2 dist2spline2(vec2 pos, vec2 P0, vec2 P1, vec2 P2, vec2 P3, int n) {\n\tif (SHOW_COSTLY) return vec2(8.);\n\tfloat d = 1e5;\n\tfor (float x=0.; x<1.; x+= 1.\/sample) { \/\/ iterative subdivision\n\t\t\n\t\t\/\/ construct the 2 sub- control polygons\n\t\tvec2 P01   = mix(P0,P1,x),     P12 = mix(P1,P2,x),    P23 = mix(P2,P3,x),\n\t\t\t P012  = mix(P01,P12,x),  P123 = mix(P12,P23,x),\n\t\t\t P0123 = mix(P012,P123,x); \/\/ is on the spline\n\t\tvec2 D = P0123-pos;\n\t\td = min(d, dot(D,D));\n\t}\n\td = sqrt(d);\n\treturn vec2(d);\n}\n\n\/\/ --- dist to spline - iterative\n\nvec2 dist2spline(vec2 pos, vec2 P0, vec2 P1, vec2 P2, vec2 P3, int n) {\n\tvec2 d0mM, d3mM;\n\tfor (int i=0; i<SUBDIV; i++) { \/\/ iterative subdivision\n\t\tif (i >= n) continue;\n\t\t\n\t\t\/\/ construct the 2 sub- control polygons\n\t\tvec2 P01   = .5*(P0+P1),     P12 = .5*(P1+P2),    P23 = .5*(P2+P3),\n\t\t\t P012  = .5*(P01+P12),  P123 = .5*(P12+P23),\n\t\t\t P0123 = .5*(P012+P123); \/\/ is on the spline\n\n\t\t\n\t\td0mM = dist2quadri(pos, P0,P01,P012,P0123), \/\/ sub quadri 1\n\t\td3mM = dist2quadri(pos, P0123,P123,P23,P3); \/\/ sub quadri 2\n\t\t\n\t\tbool in0 = (d0mM.x<0.) && (d0mM.y<0.), in3 = (d3mM.x<0.) && (d3mM.y<0.);\n\t\td0mM = abs(d0mM); d3mM=  abs(d3mM);\n\t\t\t\n\t\tif (SHOW_MESH && ( (d0mM.x<3e-3)||(d3mM.x<3e-3) ) )\n\t\t\treturn vec2(0.,float(i));    \/\/ draw skeleton\n\t\tfloat s;\n\n\n\t\t\/\/ inside one of the sub quadri\n\t\tif      (in0 && ! in3) s = -1.; else if (in3 && ! in0) s = 1.;\n\t\telse \n#if 1\n\t\tif (d0mM.y <= d3mM.x) s = -1.;       \/\/ sub-quadri 1 totally closer\n\t\telse if (d3mM.y <= d0mM.x) s = 1.;   \/\/ sub-quadri 2 totally closer\n\t\t\telse \/\/ ambiguous\n\t\t\t  { n =-n; d0mM.x = float(n-i); continue; } \/\/ switch to costly method\n#else\n\t\t\tif (d0mM.x <= d3mM.x) s = -1.; else s = 1.; \/\/ closest box (very approx)\n#endif\n\t\t\n\t\tif (s<0.) { P1 = P01;   P2 = P012; P3 = P0123; } \/\/ continue on sub quadri 1\n\t\telse      { P0 = P0123; P1 = P123; P2 = P23;   } \/\/ continue on sub quadri 2\n   \t}\n\t\n\tif (n<0) \/\/ ambiguity found: switch to costly method\n\t\treturn dist2spline2(pos, P0,P1,P2,P3, int(d0mM.x+.5)); \n\t\n  \treturn dist2quadri(pos, P0,P1,P2,P3);\n}\n\n\n\n\n\/\/ === main ===================\n\n\/\/ motion of control points and tangents.\nvec2 P(float i) {\n\tvec4 c = hash4(i);\n\treturn vec2(   cos(t*c.x-c.z)+.5*cos(2.765*t*c.y+c.w),\n\t\t\t\t ( sin(t*c.y-c.w)+.5*sin(1.893*t*c.x+c.z) )\/1.5\t );\n}\n\n\/\/ ---\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(0.);\n\tvec2 uv    = 2.*(fragCoord.xy \/ iResolution.y - vec2(.8,.5));\n\tvec2 Pc, Tc;\n\t\n\t\/\/ --- tuning \n\t\n\tvec2 mouse = 2.*(iMouse.xy  \/ iResolution.y - vec2(.8,.5));\n\tSIGNED_DIST = !keyToggle(64+19); \n\tfragColor.b += showFlag(vec2(-1.5,.9),uv,(mod(10.*t,2.)<1.))\n\t\t\t\t\t+ showFlag(vec2(-1.4,.9),uv,SIGNED_DIST);\n\t\n\tif (iMouse.z<=0.) {\n\t\tfloat fm = mod(.2*t,8.); int m=int(fm);\n\t\tSHOW_MESH   =  (mod(fm,2.)>=1.);\n\t\tSHOW_LINE   =  (m==2)||(m==3);\n\t\tSHOW_GRAD   =  (m==4)||(m==5);\n\t\tSHOW_ISO    =  (m==6)||(m==7);\n\t\tSHOW_COSTLY =  false;\n\t\tPc = P(0.); Tc = P(0.5);\n\t} else {\n\t\tSHOW_MESH   = keyToggle(64+13); \/\/ 'M'\n\t\tSHOW_LINE   = keyToggle(64+12); \/\/ 'L'\n\t\tSHOW_GRAD   = !keyToggle(64+7); \/\/ 'G'\n\t\tSHOW_ISO    = keyToggle(64+9);  \/\/ 'I'\t\n\t\tSHOW_COSTLY = keyToggle(64+3);  \/\/ 'C'\t\n\t\tPc = mouse; Tc = vec2(1.);\n\t}\n\t\n\t\n\t\/\/ --- dist to spline \n\t\/\/ TODO:\n\t\/\/    - first select possible splines\n\t\/\/    - parallel descent in the vector of splines\n\t\n\tvec2 dmMi[POINTS];\n\tvec2 dmM = vec2(1e5);\n\tvec2 P0, T0, P3=Pc, T3=Tc;\n#if 0\n\tfor (float i=1.; i<float(POINTS); i++) \n\t{\n\t\tP0 = P3; T0 = T3; P3 = P(i); T3 = P(i+.5);\n\t\tfloat d0=dist2(uv,P0), d1=dist2(uv,P0+T0), d2=dist2(uv,P3-T3), d3=dist2(uv,P3);\n\t\tfloat dmi = min(min(d0,d1),min(d2,d3)), dMi = max(max(d0,d1),max(d2,d3));\n\t\tdmMi[int(i)] = vec2(dmi, dMi);\n\t}\n#endif\n\t\n\tdmM = vec2(1e5);\n\tP3=Pc, T3=Tc;\n\tfor (float i=1.; i<float(POINTS); i++) \n\t{\n\t\tP0 = P3; T0 = T3; P3 = P(i); T3 = P(i+.5);\n\n\t\tvec2 dmMi = abs(dist2spline(uv, P0,P0+T0,P3-T3,P3, SUBDIV)); \/\/ draw spline i\n\n\t\tif (dmMi.x==0.) \/\/ display mesh\n\t\t\t{ fragColor=mix(vec4(1),vec4(0.,0.,1.,0.),dmMi.y\/3.); return; } \n\t\tif (dmMi.x==8.) \/\/ display ambiguous parts\n\t\t\t{ fragColor=vec4(.15,0.,0.,0.); return; } \n\t\tdmM = min (dmM, dmMi);\n\t}\n\t\n\t\n\t\/\/ --- display\n\t\n\tvec3 col = 1.-abs(vec3(dmM,.5*(dmM.x+dmM.y))); \n\tif (SHOW_LINE) col = pow(col, vec3(16.));\n\tif (SHOW_ISO ) col = sin(100.*col);\n\tif (SHOW_GRAD) col.xy = .5+.5*normalize(vec2(dFdx(col.z),dFdy(col.z)));\n\t\n\tfragColor += vec4(col.xy, 0.,1.);\n}","name":"","description":"","type":"image"}]}}