{"Shader":{"ver":"0.1","info":{"id":"4ljXzV","date":"1445211665","viewed":529,"name":"Project5-GLSL-Ray-Marcher","username":"ziyezhou","description":"add sphere tracing with over relaxation","likes":0,"published":3,"flags":0,"tags":["startercodeforcis565"],"hasliked":0},"renderpass":[{"inputs":[{"id":17,"src":"\/presets\/tex12.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ ======================= Global Definition =======================\n#define DEPTH_VIEW 0\n#define ITERATION_VIEW 0\n#define Point3 vec3\n#define Vector3 vec3\n#define Vector2 vec2\n#define lerp mix\n#define mat4x4 mat4\n#define MAX_T 20.0\n#define MIN_T 1.0\n#define MAX_ITER 50\n#define Over_relaxation_factor 1.0 \nfloat maxComponent(vec3 v) { return max(v.x, max(v.y, v.z)); }\nfloat maxComponent(vec2 v) { return max(v.x, v.y); }\n\nfloat saturate(float x) { return clamp(x, 0.0, 1.0); }\n\n\n\/\/ ======================= Matrix Basic =======================\n\n\/\/part from G3D Innovation Engine\u2019s g3dmath.glsl\n\nmat4x4 identity4x4() {\n    return mat4x4(1,0,0,0,\n                  0,1,0,0,\n                  0,0,1,0,\n                  0,0,0,1);\n}\n\n\/** Constructs a 4x4 translation matrix, assuming T * v multiplication. *\/\nmat4x4 translate4x4(Vector3 t) {\n    return mat4x4(1,0,0,0,\n                  0,1,0,0,\n                  0,0,1,0,\n                  t,1);\n}\n\n\/** Constructs a 4x4 Y->Z rotation matrix, assuming R * v multiplication. a is in radians.*\/\nmat4x4 pitch4x4(float a) {\n    return mat4x4(1, 0, 0, 0,\n                  0,cos(a),-sin(a), 0,\n                  0,sin(a), cos(a), 0,\n                  0, 0, 0, 1);\n}\n\n\/** Constructs a 4x4 X->Y rotation matrix, assuming R * v multiplication. a is in radians.*\/\nmat4x4 roll4x4(float a) {\n    return mat4x4(cos(a),-sin(a),0,0,\n                  sin(a), cos(a),0,0,\n                  0,0,1,0,\n                  0,0,0,1);\n}\n\n\/** Constructs a 4x4 Z->X rotation matrix, assuming R * v multiplication. a is in radians.*\/\nmat4x4 yaw4x4(float a) {\n    return mat4x4(cos(a),0,sin(a),0,\n                  0,1,0,0,\n                  -sin(a),0,cos(a),0,\n                  0,0,0,1);\n}\n\nmat4x4 scale4x4(vec3 m_scale)\n{\n\treturn mat4x4(m_scale.x,0,0,0,\n                  0,m_scale.y,0,0,\n                  0,0,m_scale.z,0,\n                  0,0,0,1);\n}\n\n\/\/ ======================= Operations on Distance Estimators =======================\n\nfloat unionDistance(float d1, float d2) {\n\treturn min(d1, d2);\n}\n\nfloat intersectionDistance(float d1, float d2) {\n\treturn max(d1, d2);\n}\n\nfloat subtractionDistance(float d1, float d2) {\n\treturn max(d1, -d2);\n}\n\nfloat smin(float a, float b, float blendRadius) {\n    float c = saturate(0.5 + (b - a) * (0.5 \/ blendRadius));\n    return lerp(b, a, c) - blendRadius * c * (1.0 - c);\n}\n\nfloat blendDistance(float d1, float d2, float blendRadius)\n{\n    return smin(d1, d2, blendRadius);\n}\n\n\/\/ ======================= Primitive Sign Distance Function =======================\n\n\/\/ simple primitive\nfloat sdPlane( Point3 pos )\n{\n    return pos.y;\n}\n\nfloat sdTerrain(Point3 pos )\n{\n\treturn  pos.y - 0.3*sin(2.0*pos.x)*cos(pos.z);\n}\n\nfloat sdSphere( Point3 pos, Point3 center , float r )\n{\n    return length(pos - center)-r;\n}\n\nfloat sdBox(Point3 X, Point3 C, vec3 b) \n{\n\t\n\tvec3 d = abs(X - C) - b;\n\treturn min(maxComponent(d), 0.0) + length(max(d, vec3(0, 0, 0)));\n}\n\nfloat sdRoundedBox(Point3 X, Point3 C,Vector3 b, float r) \n{\n\treturn length(max(abs(X - C) - b, Vector3(0, 0, 0))) - r;\n}\n\nfloat sdTorus(Point3 X, Point3 C, float R, float r)  \/\/ R for outer radius  r for inner radius\n{\n\treturn length(vec2(length(X.xz - C.xz) - r, X.y - C.y)) - R;\n}\n\nfloat pow8(float x) \n{\n    x *= x; \/\/ x\u02c62\n    x *= x; \/\/ x\u02c64\n    return x * x;\n}\nfloat length8(Vector2 v) \n{\n\treturn pow(pow8(v.x) + pow8(v.y), 1.0 \/ 8.0);\n}\n\nfloat sdWheel(Point3 X, Point3 C, float r, float R) \/\/ R for outer radius  r for inner radius\n{\n\treturn length8(Vector2(length(X.xz - C.xz) - r, X.y - C.y)) - R;\n}\n\nfloat sdCylinder(Point3 X, Point3 C, float r, float e) \n{\n    Vector2 d = abs(Vector2(length(X.xz - C.xz), X.y - C.y)) - Vector2(r, e);\n    return min(maxComponent(d), 0.0) + length(max(d, Vector2(0, 0)));\n}\n\n\n\/\/primitive with Operations\n\nfloat sdDoubleSphere(Point3 X) {\n\treturn subtractionDistance(sdSphere(X, Point3(-0.5, 1, 0), 1.0),\n\tsdSphere(X, Point3(0.5, 1, 0), 1.0));\n}\n\n\nfloat sdRepeatSphere(Point3 X , vec3 v) \/\/v as period\n{\n    return sdSphere((mod(X,v)) - v*0.5, vec3(0.0,0.5,0),0.5);\n}\n\nfloat sdDoubleRepeatSphere(Point3 X , vec3 v1, vec3 v2) \/\/v as period\n{\n    return sdSphere(mod( (mod(X,v1)) - v1*0.5,v2) - v2*0.5, vec3(0.0,0.25,0),0.25);\n}\n    \n\n\/\/ primitive with transformation\n\nfloat sdSpere_trans(vec3 pos, mat4 trans, mat4 inv_trans, float det_trans)\n{\n  \n    vec3 new_pos = (inv_trans * vec4(pos,1.0)).xyz;\n    \n    return sdSphere(new_pos,vec3(0.0,0.5,0.0),0.5)*det_trans;\n    \n    \n}\n\n\nfloat sdBox_trans(vec3 pos, mat4 trans, mat4 inv_trans, float det_trans)\n{\n  \n    vec3 new_pos = (inv_trans * vec4(pos,1.0)).xyz;\n    \n    return sdBox(new_pos,vec3(0.0,1.0,0.0),vec3(0.5,0.5,0.5))*det_trans;\n    \n    \n}\n\n\n\n\n\n\/\/ ======================= Util =======================\n\n\nvec2 CompareDis( vec2 d1, vec2 d2 )\n{\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\n\n\n\nvec2 GetMinDis( in vec3 pos ) \/\/ compute the min dis to the primitive in the scene\n{\n    vec2 res =CompareDis( vec2( sdPlane(pos), 1.0 ),\n\t            \t\t\t\/\/vec2(sdBox(pos, vec3(0.0,0.6,0.0),vec3(0.5)) , 46.9));\n                         \/\/vec2 (sdBox_trans( pos , yaw4x4(iGlobalTime),yaw4x4(-iGlobalTime),1.0 ), 46.9));\n                         \n                         vec2( sdDoubleRepeatSphere( pos , vec3(1.0,0.0,0.0) , vec3(0.0,0.0,1.0)), 46.9 ) );  \n        \n        \/\/vec2(sdTerrain(pos),2.0);\n        \n        \n    return res;\n}\n\n\nvec3 castRay_naive( in vec3 ro, in vec3 rd )\n{\n    float tmin = MIN_T;\n    float tmax = MAX_T;\n    \n    float precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    \n    int i_ret = 0;\n    for( int i = 0 ; i<20000 ;i++)\n    {\n        vec2 res = GetMinDis( ro+rd*t );\n        m = res.y;\n        i_ret = i;\n        if( res.x<precis || t>tmax ) break;\n        t += 0.001;\n      \n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec3( t, m, i_ret );\n}\n\n\nvec3 castRay( in vec3 ro, in vec3 rd )  \/\/using the distance aided method\n{\n    float tmin = MIN_T;\n    float tmax = MAX_T;\n\tfloat minStep = 0.0001;\n    \n    float precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    \n   \tint i_ret = 0;\n    for( int i = 0 ; i<MAX_ITER; i++ )\n    {\n        vec2 res = GetMinDis( ro+rd*t );\n        m = res.y;\n        i_ret = i;\n        if( res.x<precis || t>tmax ) break;\n        t += max(res.x,minStep);\n       \n        \n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec3( t, m, i_ret);\n}\n\n\nvec3 castRay_over_relax( in vec3 ro, in vec3 rd )  \/\/using the distance aided method\n{\n\tfloat tmin = MIN_T;\n    float tmax = MAX_T;\n\tfloat minStep = 0.0001;\n    \n    float precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    \n   \tint i_ret = 0;\n    \n\tfloat old_dis = 0.0;\n\tfloat dt  = 0.0;\n\t\n\tbool is_over_relax = true;\n\n\tfor( int i = 0 ; i<MAX_ITER+1; i++ )\n    {\n        \n\t\tvec2 res = GetMinDis( ro+rd*t );\n        \n\t\tif(is_over_relax)\n\t\t{\n\t\t\tif(abs(res.x) + abs(old_dis) < dt ) \/\/ check over relax condition & over relax fail \n\t\t\t{\n\t\t\t\t\tis_over_relax = false;\n\t\t\t\t\tt = t - dt + dt\/Over_relaxation_factor; \/\/ start from the new pos\n                continue;\n\t\t\t\t\t\n\t\t\t}\n\t\t}\n\t\n\t\tm = res.y;\n        i_ret = i;\n\n        if( res.x<precis || t>tmax ) break;\n        \n\t\tif(is_over_relax)\n\t\t{\n\t\t\tdt  =max(res.x*Over_relaxation_factor,minStep);\n\t\t\told_dis = abs(res.x);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdt  =max(res.x,minStep);\n\t\t}\n\t\t\n        t += dt;\n        \n    }\n\n    if( t>tmax) m=-1.0;\n    return vec3( t, m, i_ret);\n}\n\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        GetMinDis(pos+eps.xyy).x - GetMinDis(pos-eps.xyy).x,\n        GetMinDis(pos+eps.yxy).x - GetMinDis(pos-eps.yxy).x,\n        GetMinDis(pos+eps.yyx).x - GetMinDis(pos-eps.yyx).x );\n    return normalize(nor);\n}\n\n\n\/\/ ======================= Lightning =======================\n\nfloat computeAO( in vec3 pos, in vec3 nor ) \/\/compute the ambient occlusion\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ ) \/\/sample over normal direction\n    {\n        float hr = 0.01 + 0.12*float(i)\/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = GetMinDis( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax ) \/\/compute the softshadow\n{\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<10; i++ ) \/\/sample over the rd direction\n    {\n        float h = GetMinDis( ro + rd*t ).x;\n        res = min( res, 5.0*h\/t );\n        t += clamp( h, 0.02, 0.10 );\n        \n\t\t\n\t\tif( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n\n\n\n\/\/ ======================= Starter Code  =======================\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.8, 0.9, 1.0); \/\/ Sky color\n    \/\/vec3 res = castRay_over_relax(ro,rd);\n    vec3 res = castRay(ro,rd);\n    \/\/vec3 res = castRay_naive(ro,rd);\n    float t = res.x;\n    float m = res.y;\n    float num_iter = res.z;\n    \n    \n     #if(DEPTH_VIEW)\n    \n    \tif( m>-0.5 )  \/\/ Ray intersects a surface\n        {\n            return vec3(1.0 - (t - MIN_T) \/(MAX_T - MIN_T));\n        }\n    \telse\n        {\n            return vec3(0.0);\n        }\n    \n    #endif\n    \n    #if(ITERATION_VIEW)\n        \n    \tif( m>-0.5 )  \/\/ Ray intersects a surface\n            {\n                float max_iter_f = float (MAX_ITER);\n                return vec3(num_iter\/max_iter_f);\n            }\n            else\n            {\n                return vec3(0.0);\n            }\n    \n    #endif\n    \n    \n    \n    \n    if( m>-0.5 )  \/\/ Ray intersects a surface\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        \/\/ material        \n        col = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        \n        if( m<1.5 )\n        {\n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n        \n        if( m == 2.0)\n        {\n            col = vec3(182.0\/255.0,87.0\/255.0, 29.0\/255.0) + 0.2*vec3(0.6)*sin(2.0*pos.x)*cos(pos.z) ;\n            float r = texture2D( iChannel0, mod(pos.xz,256.0) ).x;\n            \n            \n            col+= r*vec3(0.3);\n            \n        }\n\n        \/\/ lighitng        \n       \t\/\/float occ  =1.0;\/\/= computeAO( pos, nor );\n        float occ  = computeAO( pos, nor );\n        vec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n        vec3 m_brdf = vec3(0.0);\n        m_brdf += 1.20*dif*vec3(0.90,0.90,0.90);\n        m_brdf += 1.20*spe*vec3(0.90,0.90,0.90)*dif;\n        m_brdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n        m_brdf += 0.40*dom*vec3(0.50,0.70,1.00)*occ;\n        m_brdf += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n        m_brdf += 0.02;\n        col = col*m_brdf;\n\n        col = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.005*t*t ) ); \/\/ add fog\n    }\n      \n     \treturn vec3( clamp(col,0.0,1.0) );\n    \n    \n\n   \n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n    \/\/ Starter code from iq's Raymarching Primitives\n    \/\/ https:\/\/www.shadertoy.com\/view\/Xds3zN\n\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ Starter code from iq's Raymarching Primitives\n    \/\/ https:\/\/www.shadertoy.com\/view\/Xds3zN\n\n    vec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x \/ iResolution.y;\n    vec2 mo = iMouse.xy \/ iResolution.xy;\n\n    float time = 15.0 + iGlobalTime;\n\n    \/\/ camera\n    vec3 ro = vec3(\n            -0.5 + 3.5 * cos(0.1 * time + 6.0 * mo.x),\n            1.0 + 2.0 * mo.y,\n            0.5 + 3.5 * sin(0.1 * time + 6.0 * mo.x));\n    vec3 ta = vec3(-0.5, -0.4, 0.5);\n\n    \/\/ camera-to-world transformation\n    mat3 ca = setCamera(ro, ta, 0.0);\n\n    \/\/ ray direction\n    vec3 rd = ca * normalize(vec3(p.xy, 2.0));\n\n    \/\/ render\n    vec3 col = render(ro, rd);\n\n    col = pow(col, vec3(0.4545));\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"","description":"","type":"image"}]}}