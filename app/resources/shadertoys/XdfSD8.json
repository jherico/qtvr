{"Shader":{"ver":"0.1","info":{"id":"XdfSD8","date":"1409967832","viewed":416,"name":"Nucleus Rave","username":"4rknova","description":"It is what it is.","likes":3,"published":3,"flags":0,"tags":["metaballs","motionblur"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ by Nikos Papadopoulos, 4rknova \/ 2014\n\/\/ Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n#define EPS .001\n\n\n#define TM iGlobalTime * 3.5\n#define FT 2.5 * EPS * hash(TM)\n#define SM 50\n#define CI vec3(1) \n#define CO vec3(r, 0, 0)\n\nfloat hash(in float n) { return fract(sin(n)*43758.5453123); }\n\nfloat hash(vec2 p)\n{\n    return fract(sin(dot(p,vec2(127.1,311.7))) * 43758.5453123);\n}\n\nfloat noise(vec2 p)\n{\n    vec2 i = floor(p), f = fract(p); \n\tf *= f*f*(3.-2.*f);\n    \n    vec2 c = vec2(0,1);\n    \n    return mix(mix(hash(i + c.xx), \n                   hash(i + c.yx), f.x),\n               mix(hash(i + c.xy), \n                   hash(i + c.yy), f.x), f.y);\n}\n\nfloat fbm(in vec2 p)\n{\n\treturn\t.5000 * noise(p)\n\t\t   +.2500 * noise(p * 2.)\n\t\t   +.1250 * noise(p * 4.)\n\t\t   +.0625 * noise(p * 8.);\n}\n\nfloat metaball(vec2 p, float r)\n{\n\treturn vec2(noise(vec2(FT,1)\/r)).x \/ dot(p, p);\n}\n\nvec3 blob(vec2 p, float t)\n{\n\tfloat t0 = sin(t * 0.9) * .46;\n\tfloat t1 = sin(t * 2.4) * .39;\n\tfloat t2 = cos(t * 1.4) * .57;\n\n\tfloat r = metaball(p - vec2(t1 * .98, t2 * .36), noise(vec2(TM) *.8))\n\t\t\t+ metaball(p + vec2(t2 * .55, t0 * .27), noise(vec2(TM) *.7))\n\t\t\t+ metaball(p - vec2(t0 * .33, t1 * .52), noise(vec2(TM) *.9))\n\t\t\t+ metaball(p + vec2(t2 * .22, t1 * .23), noise(vec2(TM) *.6))\n\t\t\t+ metaball(p - vec2(t1 * .85, t1 * .55), noise(vec2(TM) *.2));\n\t\n\tr = max(r, .2);\n\t\n\tr *= FT;\n\n\treturn (r > .5)\n\t\t? (vec3(step(.1, r*r*r)) * CI)\n\t\t: (r < 1000.9 ? CO : CI);\n}\n\nvec3 bg(vec2 p, vec3 c)\n{\n\treturn vec3(0.01);\n}\n\nvec3 sample(vec2 uv, in vec2 fragCoord)\n{\n\tif (abs(EPS + uv.y) >= .4 || mod(floor(fragCoord.y),2.) > 0.) { \n\t\treturn vec3(0);\n\t}\n\t\t\n\tvec3  c = vec3(0);\n\t\n\tfor (int i = 0; i < SM; ++i) {\n\t\tfloat dt = TM + 30. * fbm(vec2(uv + 90.)) \/ float(i);\n\t\tc += blob(uv - noise(vec2(uv) * 0.4), dt) \/ float(SM);\n\t}\n\t\n\tvec3 fx = vec3(smoothstep(0., .3, iGlobalTime) * c);\n\t\n\tfx += bg(uv, fx);\n\n\t\/\/ PostFX\n\tfloat snow = hash((hash(uv.x) + uv.y) * iGlobalTime) * 0.025;\n\tfloat fade = smoothstep(EPS, 2.5, iGlobalTime);\n\t\n\treturn fade * (snow + fx);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy \/ iResolution.xy * 2. - 1.)\n\t\t\t* vec2(iResolution.x \/ iResolution.y, 1);\n\n\tfragColor = vec4(sample(uv, fragCoord), 1);\n}","name":"","description":"","type":"image"}]}}