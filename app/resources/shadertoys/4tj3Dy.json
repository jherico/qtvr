{"Shader":{"ver":"0.1","info":{"id":"4tj3Dy","date":"1432089451","viewed":893,"name":"2D Quadratic Bezier II","username":"demofox","description":"Use mouse to control the green control point.<br\/>This creates a triangle between the three control points, and then uses the Blinn & Loop method.  This is nice for knowing inside vs outside. Shows curve outside of the triangle as well.","likes":6,"published":3,"flags":0,"tags":["2d","bezier"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/*\nInfo on curves:\nhttp:\/\/research.microsoft.com\/en-us\/um\/people\/cloop\/LoopBlinn05.pdf\nhttp:\/\/research.microsoft.com\/en-us\/um\/people\/hoppe\/ravg.pdf\nhttp:\/\/www.pouet.net\/topic.php?which=9119&page=1\nhttp:\/\/blog.gludion.com\/2009\/08\/distance-to-quadratic-bezier-curve.html\n\nThe top link is where this technique comes from.\n\nThanks also to other bezier curve shadertoys:\nhttps:\/\/www.shadertoy.com\/view\/XsX3zf\nhttps:\/\/www.shadertoy.com\/view\/lts3Df\n*\/\n\n#define EDGE   0.005\n#define SMOOTH 0.0025\n\n\/\/ signed distance function for Circle, for control points\nfloat SDFCircle( in vec2 coords, in vec2 offset )\n{\n    coords -= offset;\n    float v = coords.x * coords.x + coords.y * coords.y - EDGE*EDGE;\n    vec2  g = vec2(2.0 * coords.x, 2.0 * coords.y);\n    return v\/length(g); \n}\n\n\/\/-----------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec3 color = vec3(1.0,1.0,1.0);\n    \n    float aspectRatio = iResolution.x \/ iResolution.y;\n    vec2 percent = ((fragCoord.xy \/ iResolution.xy) - vec2(0.25,0.5));\n    percent.x *= aspectRatio;\n    \n    vec2 mouse = (iMouse.xy \/ iResolution.xy) - vec2(0.25,0.5);\n    mouse.x *= aspectRatio;\n    vec2 A = vec2(0.0,0.0);\n    vec2 B = length(iMouse.xy) > 0.0 ? mouse : vec2(-0.3,0.2);\n    vec2 C = vec2(1.0,0.0);  \n \n    \/\/ Compute vectors        \n    vec2 v0 = C - A;\n    vec2 v1 = B - A;\n    vec2 v2 = percent - A;\n\n    \/\/ Compute dot products\n    float dot00 = dot(v0, v0);\n    float dot01 = dot(v0, v1);\n    float dot02 = dot(v0, v2);\n    float dot11 = dot(v1, v1);\n    float dot12 = dot(v1, v2);\n\n\t\/\/ Compute barycentric coordinates\n\tfloat invDenom = 1.0 \/ (dot00 * dot11 - dot01 * dot01);\n\tfloat u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n\tfloat v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n\n    \/\/ use the blinn and loop method\n    float w = (1.0 - u - v);\n    vec2 textureCoord = u * vec2(0.0,0.0) + v * vec2(0.5,0.0) + w * vec2(1.0,1.0);\n        \n\t\/\/ use the sign of the result to decide between grey or black\n    float insideOutside = sign(textureCoord.x * textureCoord.x - textureCoord.y) < 0.0 ? 0.5 : 1.0;\n    color = vec3(insideOutside * 0.5);\n    \n    \/\/ if it's outside the triangle, lighten it a bit\n    color += ((u >= 0.0) && (v >= 0.0) && (u + v < 1.0)) ? 0.0 : 0.7;\n    \n    \/\/ render control points\n    float dist = SDFCircle(percent, A);\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(1.0,0.0,0.0),vec3(1.0,1.0,1.0),dist);\n    }\n    \n    dist = SDFCircle(percent, B);\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(0.0,1.0,0.0),vec3(1.0,1.0,1.0),dist);\n    }    \n    \n    dist = SDFCircle(percent, C);\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(0.0,0.0,1.0),vec3(1.0,1.0,1.0),dist);\n    }      \n       \n\tfragColor = vec4(clamp(color,0.0,1.0),1.0);\n}\n\n","name":"","description":"","type":"image"}]}}