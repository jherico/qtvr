{"Shader":{"ver":"0.1","info":{"id":"MdsSRM","date":"1398602818","viewed":748,"name":"Moir\u00e9","username":"FabriceNeyret2","description":"A: anti aliasing       C: toggles colors                  M: draw mode = max vs sum<br\/>mouse: translate.   Z: mouse.y zoom instead.     S: mouse.x tunes wires step instead.","likes":3,"published":3,"flags":0,"tags":["moire"],"hasliked":0},"renderpass":[{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\n#define PI 3.14159265359\nfloat t = 10.*iGlobalTime;\n\nbool COMB;\nbool ANTI_A;\nfloat STEP;\n\nfloat zoom;\n\nbool keyToggle(int ascii) {\n\treturn (texture2D(iChannel2,vec2((.5+float(ascii))\/256.,0.75)).x > 0.);\n}\n\nfloat fwidth2(float k) { vec2 dk = vec2(dFdx(k),dFdy(k)); return length(dk); }\n\nfloat Icos(float k, float S) { \/\/ cos with or without antialiasing\n\tfloat dk = 1.;\n\tif (ANTI_A) { \/\/ antialiasing: return 1\/dk . int( cos(k), k= -dk\/2..dk\/2 )\n\t\tdk = fwidth(k);\n\t\tif (dk>0.) dk = 2.*sin(dk\/2.)\/dk ;\n\t\tdk *= 1.\/S; \/\/ *zoom; \/\/ scaling should not change intensity\n\t}\n\treturn cos(k)*dk;\n\t\n}\nfloat rosace(float s, float z, float L, float S, float T, bool clip) { \n\ts = S*(s-T); z = S*(z-T); \/\/ translation and scaling\n\tif (clip && ( (z<=0.) || (z>L) || (s-z<0.) || (s-z>L) )) return 0.;\n\t\/\/ canonical:  s = x+y,  z = x\n\t\/\/ <x,y> - <0,k> = <k,L> - <0,k> \n\t\/\/ => x.(L-k)=k.(y-k) => k2 -k.s + zL = 0 => D = s2-4zL\n\tfloat d = 1.-4.*z*L\/(s*s); if (d<0.) return 0.;\n\n\td = sqrt(d);\n\tfloat k1 = s*(1.+d)\/2., k2 = s*(1.-d)\/2.;\n\t\n#if 1\n\tfloat s1 = Icos(PI*k1\/STEP,S) , s2 = Icos(PI*k2\/STEP,S);\n#else\n\tfloat s1 = (clip && ( (k1<0.)||(k1>L) )) ? 0. : Icos(PI*k1\/STEP,S),\n\t\t  s2 = (clip && ( (k2<0.)||(k2>L) )) ? 0. : Icos(PI*k2\/STEP,S);\t\n#endif\n\n\treturn .5+.5* ( (COMB) ? max(s1,s2) : (s1+s2) );\n}\n\nvec2 tile1(vec2 uv, float L, float S) {\n\tS=1.;\n\tfloat r,g, s = uv.x+uv.y, S2=S*2.,T=L\/2.;\n\tr   = rosace(s, uv.x,  L,S,0., true)   + rosace(s, uv.y,  L,S,0., true);\n\tr  += rosace(s, uv.x,  L,S2,T, true) + rosace(s, uv.y,  L,S2,T, true);\n\t\n\tuv.x = L-uv.x; s = uv.x+uv.y;\n\tg  = rosace(s, uv.x,  L,S,0., true)   + rosace(s, uv.y,  L,S,0., true);\n\tg += rosace(s, uv.x,  L,S2,T, true) + rosace(s, uv.y,  L,S2,T, true);\n\n\treturn vec2(r,g);\n}\n\nvec2 tile2(vec2 uv, float L, float S) {\n\tS=1.;\n\tfloat r,g, s = uv.x+uv.y, S2=S*2.,T=L\/2.;\n\tr  = rosace(s, uv.x,  L,S2,T, true) + rosace(s, uv.y,  L,S2,T, true);\n\tr += rosace(s, mod(uv.x+L\/2.,L),  L,S2,T, true) + rosace(s, mod(uv.y+L\/2.,L),  L,S2,T, true);\n\n\tuv.x = L-uv.x; s = uv.x+uv.y;\n\tg  = rosace(s, uv.x,  L,S2,T, true) + rosace(s, uv.y,  L,S2,T, true);\n\tg += rosace(s, mod(uv.x+L\/2.,L),  L,S2,T, true) + rosace(s, mod(uv.y+L\/2.,L),  L,S2,T, true);\n\n\treturn vec2(r,g);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat L = iResolution.y;\n\tvec2 uv = fragCoord.xy-.5-iResolution.xy\/2.;\n\tvec2 trans = vec2(0.);\n\t\n\t\/\/ --- tuning\n\t\n\tvec4 mouse = abs((iMouse-.5)\/iResolution.y);\n\tif (iMouse.z<=0.) {\n\t\tzoom = 1.+10.*(1.-cos(.02*t))\/2.;\n\t\tSTEP = 1.+50.*(1.-cos(.1*t))\/2.;\n\t\tANTI_A = true;\n\t\tCOMB = ( mod(.02*t\/(2.*PI),1.) > .5 );  \n\t\ttrans = .5+iResolution.xy\/2.*(1.+vec2(cos(.02*t),sin(.03*t))\/(1.+zoom));\n\t}\n\telse\n\t{\n\t\tANTI_A = !keyToggle(65);\n\t\tCOMB   = (! keyToggle(64+13)); \/\/ 'M'\n\t\n\t\ttrans = iMouse.xy;\n\t\tif (!keyToggle(64+26)) { zoom=mouse.y*10.; trans.y=iMouse.w; } \n\t\telse \t\t\t\t\t zoom = mouse.w*10.;\n\t\tif (keyToggle(64+19)) { STEP = mouse.x*100.; trans.x=abs(iMouse.z); }\n\t\telse\t\t\t\t    STEP = 4.; \/\/ mouse.z*100.;\n\t}\n\t\n\tuv -= 10.*(trans-.5-iResolution.xy\/2.);\n\tuv *= zoom;\n\t\n\t\/\/ --- display \n\t\n\tvec3 col = vec3(0.); \n\tcol.rg = tile1(mod(uv,L),L,zoom);\n\n\tfragColor = (!keyToggle(67)) ? vec4(col.r+col.g) : vec4(col.r,col.g,0.,1.);\n}","name":"","description":"","type":"image"}]}}