{"Shader":{"ver":"0.1","info":{"id":"MsdGz2","date":"1451086242","viewed":2289,"name":"Alien cocoons","username":"XT95","description":"Trying to implement \"Approximating Translucency for a Fast, Cheap and Convincing Subsurface Scattering Look\" by Colin Barr\u00e9 Brisebois!<br\/>","likes":50,"published":3,"flags":64,"tags":["sss","scattering","translucency","subsurface"],"hasliked":0},"renderpass":[{"inputs":[{"id":47,"src":"\/presets\/tex19.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":510,"src":"https:\/\/soundcloud.com\/pandadubarchives\/2007-2008-panda-dub-02","ctype":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by anatole duprat - XT95\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\/\/ Approximating Translucency for a Fast, Cheap and Convincing Subsurface Scattering Look :\n\/\/ http:\/\/colinbarrebrisebois.com\/2011\/03\/07\/gdc-2011-approximating-translucency-for-a-fast-cheap-and-convincing-subsurface-scattering-look\/\n\nconst float PI = 3.14159265359;\n\nvec3 raymarche( in vec3 ro, in vec3 rd, in vec2 nfplane );\nvec3 normal( in vec3 p );\nfloat map( in vec3 p );\nmat3 lookat( in vec3 fw, in vec3 up );\nmat3 rotate( in vec3 v, in float angle);\nfloat thickness( in vec3 p, in vec3 n, float maxDist, float falloff );\nfloat ambientOcclusion( in vec3 p, in vec3 n, float maxDist, float falloff );\nfloat noise(vec3 p);\nfloat smin( float a, float b, float k );\n\n\nvec3 lpos1,lpos2,lpos3;\n\n\n\n\/\/Map\nfloat map( in vec3 p )\n{\n\tp.xz = mod(p.xz+100., 200.)-100.;\n\tfloat d = p.y+texture2D(iChannel0, p.xz*.05).r*1.5;\n    d = min(d, length(p-lpos1)-1.);\n    d = min(d, length(p-lpos2)-1.);\n\n\tvec2 id = floor(p.xz\/60.);\n\tp.xz = mod(p.xz, 60.)-30.;\n\tp = rotate(vec3(0.,1.,0.), p.y*.05*cos(iGlobalTime+sin(iGlobalTime*1.5+id.x*5.)+id.y*42.))*p;\n\td = min(d, smin(length(p-vec3(0.,12.,0.))-3.-noise(p*.3)*3., length(p-vec3(0.,7.,0.))-3.,4.)+texture2D(iChannel0, p.xz*.2).r*.25);\n\n\tfloat branch = length( (rotate(vec3(.5,0.,.5), 1.2)*p-vec3(6.,0.,-6.)).xz)-.5;\n\tbranch = smin(branch, length( (rotate(vec3(-.5,0.,.5), 1.2)*p-vec3(6.,0.,6.)).xz)-.5,1.);\n\tbranch = smin(branch, length( (rotate(vec3(.5,0.,-.5), 1.2)*p-vec3(-6.,0.,-6.)).xz)-.5,1.);\n\tbranch = smin(branch, length( (rotate(vec3(-.5,0.,-.5), 1.2)*p-vec3(-6.,0.,6.)).xz)-.5,1.);\n\tbranch = max(branch, p.y-10.);\n\tbranch = branch-texture2D(iChannel0, p.xz*.1).r*.25;\n\treturn smin(d, branch, 5.) ;\n}\n\n\nvec3 skyColor( in vec3 rd )\n{\n    vec3 sundir = normalize( vec3(.0, .1, 1.) );\n    \n    float yd = min(rd.y, 0.);\n    rd.y = max(rd.y, 0.);\n    \n    vec3 col = vec3(0.);\n    \n    col += vec3(.4, .4 - exp( -rd.y*20. )*.3, .0) * exp(-rd.y*9.); \/\/ Red \/ Green \n    col += vec3(.3, .5, .6) * (1. - exp(-rd.y*8.) ) * exp(-rd.y*.9) ; \/\/ Blue\n    \n    col = mix(col*1.2, vec3(.3),  1.-exp(yd*100.)); \/\/ Fog\n    \n    return clamp(col,vec3(0.),vec3(1.));\n}\n\n\/\/Shading\nvec3 shade( in vec3 p, in vec3 n, in vec3 ro, in vec3 rd )\n{\t\t\n    float fog = pow(min( length(p-ro)\/450., 1.),200.);\n\tp.xz = mod(p.xz+100., 200.)-100.;\n    \n    vec3 skyCol = skyColor(rd);\n    \n\tvec3 ldir1 = normalize(lpos1-p);\t\n\tvec3 ldir2 =  normalize(lpos2-p);\t\n\tvec3 ldir3 =  normalize(lpos3-p);\t\t\n\tfloat latt1 = pow( length(lpos1-p)*.15, 3. ) \/ (pow(texture2D( iChannel1, vec2(64.\/256.,0.25) ).x,2.)*2.+.1);\n\tfloat latt2 = pow( length(lpos2-p)*.15, 3. ) \/ (pow(texture2D(iChannel1, vec2(20.\/256.,0.25)).r*1.2,2.)*3.+.1);\n\tfloat latt3 = pow( length(lpos3-p)*.15, 2.5 ) \/ (pow(texture2D( iChannel1, vec2(128.\/256.,0.25) ).x,2.)*5.+.1);\n\n\tfloat thi = thickness(p,n, 10., 1.);\n\tfloat occ = pow( ambientOcclusion(p,n, 10., 1.), 5.);\n\n\tvec3 diff1 = vec3(.0,.5,1.) * (max(dot(n,ldir1),0.) ) \/ latt1;\n\tvec3 diff2 = vec3(.5,1.,.1) * (max(dot(n,ldir2),0.) ) \/ latt2;\n\tvec3 diff3 = vec3(1.,1.,1.) * (max(dot(n,ldir3),0.) ) \/ latt3;\n\n    vec3 col =  diff1*3. + diff2 + diff3;\n\n\tfloat trans1 =  pow( clamp( dot(-rd, -ldir1+n), 0., 1.), 1.) + 1.;\n\tfloat trans2 =  pow( clamp( dot(-rd, -ldir2+n), 0., 1.), 1.) + 1. ;\n\tfloat trans3 =  pow( clamp( dot(-rd, -ldir3+n), 0., 1.), 1.) + 1. ;\n\n\tcol += vec3(1.,.2,.05) * (trans1\/latt1 + trans2\/latt2 + trans3\/latt3)*thi + skyColor(vec3(0.,1.,0.))*(occ*.05) ;\n\n    col = mix(col, skyCol*.1, fog );\n\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy\/iResolution.xy;\n\tvec2 v = -1.0+2.0*q;\n\tv.x *= iResolution.x\/iResolution.y;\n    \n\t\/\/define lights pos\n    lpos1 = vec3( cos(iGlobalTime*.25)*30., 12., 30.);\n\tlpos2 = vec3( cos(iGlobalTime*.4)*35., 15.+cos(iGlobalTime*.3)*5., sin(iGlobalTime*.5)*35.);\n\tlpos3 = vec3( 30., 12., -30.);\n    \n\t\/\/camera ray\n    vec3 ro = vec3(cos(-iGlobalTime*.1+.75)*50.,13.+cos(iGlobalTime*.2+1.5)*5.,sin(-iGlobalTime*.1+.75)*50.);\n\tvec3 rd = normalize( vec3(v.x, v.y, 1.5-length(q*2.-1.)) );\n\trd = lookat( vec3(0.)-ro, vec3(0.,1.,0.))*rd;\n    \n\t\/\/classic raymarching by distance field\n\tvec3 p = raymarche(ro, rd, vec2(1., 500.) );\n\tvec3 n = normal(p.xyz);\n\tvec3 col = shade(p, n, ro, rd);\n\t\n\t\/\/Gamma correction\n    col = pow(col, vec3(1.\/2.2));\n    col = clamp(col,0.,1.) * (.5 + .5*pow( q.x*q.y*(1.-q.x)*(1.-q.y)*50., .5));\n    \n        \n    \n\tfragColor = vec4(col,1.0)*min(iGlobalTime*.25,1.);\n}\n\n\n    \n\nvec3 raymarche( in vec3 ro, in vec3 rd, in vec2 nfplane )\n{\n\tvec3 p = ro+rd*nfplane.x;\n\tfloat t = 0.;\n\tfor(int i=0; i<128; i++)\n\t{\n        float d = map(p);\n        t += d;\n        p += rd*d;\n\t\tif( d < 0.001 || t > nfplane.y )\n            break;\n            \n\t}\n\t\n\treturn p;\n}\n\nvec3 normal( in vec3 p )\n{\n\tvec3 eps = vec3(0.001, 0.0, 0.0);\n\treturn normalize( vec3(\n\t\tmap(p+eps.xyy)-map(p-eps.xyy),\n\t\tmap(p+eps.yxy)-map(p-eps.yxy),\n\t\tmap(p+eps.yyx)-map(p-eps.yyx)\n\t) );\n}\n\n\nmat3 lookat( in vec3 fw, in vec3 up )\n{\n\tfw = normalize(fw);\n\tvec3 rt = normalize( cross(fw, normalize(up)) );\n\treturn mat3( rt, cross(rt, fw), fw );\n}\n\nmat3 rotate( in vec3 v, in float angle)\n{\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\t\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\nfloat noise(vec3 p) \/\/Thx to Las^Mercury\n{\n\tvec3 i = floor(p);\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n\tvec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\n\ta = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n\ta.xy = mix(a.xz, a.yw, f.y);\n\treturn mix(a.x, a.y, f.z)*.5+.5;\n}\nfloat smin( float a, float b, float k ) \/\/Thx to iq^rgba\n{\n    float h = clamp( 0.5+0.5*(b-a)\/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat hash( float n )\/\/->0:1\n{\n    return fract(sin(n)*3538.5453);\n}\nvec3 randomSphereDir(vec2 rnd)\n{\n\tfloat s = rnd.x*PI*2.;\n\tfloat t = rnd.y*2.-1.;\n\treturn vec3(sin(s), cos(s), t) \/ sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n\tvec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );\n\treturn v * sign(dot(v, dir));\n}\n\nfloat ambientOcclusion( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tconst int nbIte = 32;\n    const float nbIteInv = 1.\/float(nbIte);\n    const float rad = 1.-1.*nbIteInv; \/\/Hemispherical factor (self occlusion correction)\n    \n\tfloat ao = 0.0;\n    \n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash(float(i))*maxDist;\n        vec3 rd = normalize(n+randomHemisphereDir(n, l )*rad)*l; \/\/ mix direction with the normal\n        \t\t\t\t\t\t\t\t\t\t\t\t\t    \/\/ for self occlusion problems!\n        \n        ao += (l - map( p + rd )) \/ pow(1.+l, falloff);\n    }\n\t\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n\nfloat thickness( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tconst int nbIte = 6;\n    const float nbIteInv = 1.\/float(nbIte);    \n\tfloat ao = 0.0;\n    \n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash(float(i))*maxDist;\n        vec3 rd = normalize(-n)*l;\n        ao += (l + map( p + rd )) \/ pow(1.+l, falloff);\n    }\n\t\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n","name":"","description":"","type":"image"}]}}