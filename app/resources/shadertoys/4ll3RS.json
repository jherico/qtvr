{"Shader":{"ver":"0.1","info":{"id":"4ll3RS","date":"1422988697","viewed":276,"name":"Ico-Twirl","username":"dr2","description":"Sometimes you need a REAL polyhedron (joke)...","likes":3,"published":3,"flags":0,"tags":["raymarch","symmetry","polyhedron"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ \"Ico-Twirl\" by dr2 - 2015\n\/\/ License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nint idObj;\nmat3 rMat[20];\nvec3 ltDir, qHit;\nfloat tCur, eLen, faLen, faThk, faRot;\nconst float dstFar = 20.;\nconst float C_ab = -0.364863828, C_ia = 0.55357435, C_d = 0.288675135,\n   C_r = 0.80901699;\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float s = 0.;\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return s;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nvec3 WoodColP (vec2 p)\n{\n  return mix (vec3 (0.35, 0.2, 0.1), vec3 (0.25, 0.1, 0.),\n     Fbm2 (p * vec2 (2., 20.)));\n}\n\nfloat FacetDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d, df, dc, a;\n  q = p;\n  q.z -= C_r * eLen;\n  q.yz = Rot2D (q.yz, C_ab);\n  q.y += C_d * eLen;\n  q.z += 0.5 * C_r * eLen;\n  dc = PrCylDf (q, 0.05, 0.5 * C_r * eLen);\n  q.z -= 0.5 * C_r * eLen;\n  df = PrCylDf (q, 0.75 * faLen, faThk);\n  a = faRot;\n  df = max (df, dot (q, vec3 (sin (a), cos (a), C_ab)) - C_d * faLen);\n  a += (2.\/3.) * pi;\n  df = max (df, dot (q, vec3 (sin (a), cos (a), C_ab)) - C_d * faLen);\n  a += (2.\/3.) * pi;\n  df = max (df, dot (q, vec3 (sin (a), cos (a), C_ab)) - C_d * faLen);\n  d = min (df, dc);\n  if (d < dHit) {\n    dHit = d;\n    qHit = q;\n    if (df < dc) idObj = 1;\n    else idObj = 2;\n  }\n  return dHit;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float d, dHit;\n  dHit = dstFar;\n  q = p * rMat[0] ;  dHit = FacetDf (q, dHit);\n  q = p * rMat[1] ;  dHit = FacetDf (q, dHit);\n  q = p * rMat[2] ;  dHit = FacetDf (q, dHit);\n  q = p * rMat[3] ;  dHit = FacetDf (q, dHit);\n  q = p * rMat[4] ;  dHit = FacetDf (q, dHit);\n  q = p * rMat[5] ;  dHit = FacetDf (q, dHit);\n  q = p * rMat[6] ;  dHit = FacetDf (q, dHit);\n  q = p * rMat[7] ;  dHit = FacetDf (q, dHit);\n  q = p * rMat[8] ;  dHit = FacetDf (q, dHit);\n  q = p * rMat[9] ;  dHit = FacetDf (q, dHit);\n  q = p * rMat[10];  dHit = FacetDf (q, dHit);\n  q = p * rMat[11];  dHit = FacetDf (q, dHit);\n  q = p * rMat[12];  dHit = FacetDf (q, dHit);\n  q = p * rMat[13];  dHit = FacetDf (q, dHit);\n  q = p * rMat[14];  dHit = FacetDf (q, dHit);\n  q = p * rMat[15];  dHit = FacetDf (q, dHit);\n  q = p * rMat[16];  dHit = FacetDf (q, dHit);\n  q = p * rMat[17];  dHit = FacetDf (q, dHit);\n  q = p * rMat[18];  dHit = FacetDf (q, dHit);\n  q = p * rMat[19];  dHit = FacetDf (q, dHit);\n  d = PrSphDf (p, 0.2);\n  if (d < dHit) { dHit = d;  idObj = 2;  qHit = p; }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nmat3 RotToRMat (vec3 v, float a)\n{\n  mat3 m;\n  float c, s, a1, a2;\n  c = cos (a);\n  s = sin (a);\n  m[0][0] = (1. - c) * v.x * v.x + c;\n  m[1][1] = (1. - c) * v.y * v.y + c;\n  m[2][2] = (1. - c) * v.z * v.z + c;\n  a1 = (1. - c) * v.x * v.y;\n  a2 = -s * v.z;\n  m[0][1] = a1 + a2;\n  m[1][0] = a1 - a2;\n  a1 = (1. - c) * v.z * v.x;\n  a2 = -s * v.y;\n  m[2][0] = a1 + a2;\n  m[0][2] = a1 - a2;\n  a1 = (1. - c) * v.y * v.z;\n  a2 = -s * v.x;\n  m[1][2] = a1 + a2;\n  m[2][1] = a1 - a2;\n  return m;\n}\n\nvoid BuildRMats ()\n{\n  mat3 axMat[3];\n  axMat[0] = RotToRMat (vec3 (1., 0., 0.), pi);\n  axMat[1] = RotToRMat (vec3 (0., cos (C_ia), sin (C_ia)), 0.4 * pi);\n  axMat[2] = RotToRMat (vec3 (0., 1., 0.), pi);\n  for (int i = 0; i < 3; i ++) {\n    for (int j = 0; j < 3; j ++) rMat[0][i][j] = 0.;\n    rMat[0][i][i] = 1.;\n  }\n  rMat[1]  = axMat[0];\n  rMat[2]  = axMat[1];\n  rMat[3]  = rMat[2] * axMat[1];\n  rMat[4]  = rMat[3] * axMat[1];\n  rMat[5]  = rMat[4] * axMat[1];\n  rMat[6]  = rMat[1] * axMat[1];\n  rMat[7]  = rMat[6] * axMat[1];\n  rMat[8]  = rMat[7] * axMat[1];\n  rMat[9]  = rMat[8] * axMat[1];\n  rMat[10] = axMat[2];\n  rMat[11] = rMat[1] * axMat[2];\n  rMat[12] = rMat[2] * axMat[2];\n  rMat[13] = rMat[3] * axMat[2];\n  rMat[14] = rMat[4] * axMat[2];\n  rMat[15] = rMat[5] * axMat[2];\n  rMat[16] = rMat[6] * axMat[2];\n  rMat[17] = rMat[7] * axMat[2];\n  rMat[18] = rMat[8] * axMat[2];\n  rMat[19] = rMat[9] * axMat[2];\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 objCol;\n  vec3 col, vn;\n  float dstHit, tSeq;\n  tSeq = mod (tCur, 30.);\n  eLen = 1. + 1.4 * SmoothBump (5., 25., 3., tSeq);\n  faRot = 0.;\n  if (tSeq > 8. && tSeq < 22.) faRot = 4. * pi * (tSeq - 8.) \/ 14.;\n  faLen = 1.01;\n  faThk = 0.2;\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  if (idObj < 0) dstHit = dstFar;\n  if (dstHit >= dstFar) col = vec3 (0.005, 0., 0.);\n  else {\n    ro += rd * dstHit;\n    vn = ObjNf (ro);\n    if (idObj == 1) {\n      qHit.xy = Rot2D (qHit.xy, faRot);\n      objCol = (qHit.z > 0.9 * faThk) ?\n        vec4 (WoodColP (qHit.xy), 0.3) :\n        vec4 (0.2, 0.15, 0.05, 0.1) *\n        (1. - 0.3 * Fbm2 (100. * qHit.xy));\n    } else objCol = vec4 (0.2, 0.4, 0.1, 1.);\n    col = objCol.rgb * (0.3 + 0.7 * max (dot (vn, ltDir), 0.)) +\n       objCol.a * pow (max (0., dot (ltDir, reflect (rd, vn))), 64.);\n  }\n  return sqrt (clamp (col, 0., 1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy \/ iResolution.xy - 1.;\n  uv.x *= iResolution.x \/ iResolution.y;\n  tCur = iGlobalTime;\n  mat3 vuMat;\n  vec3 ro, rd;\n  vec2 vEl, vAz;\n  float az, el;\n  el = 0.05 * tCur;\n  az = -0.11 * tCur;\n  vEl = vec2 (cos (el), sin (el));\n  vAz = vec2 (cos (az), sin (az));\n  vuMat = mat3 (1., 0., 0., 0., vEl.x, - vEl.y, 0., vEl.y, vEl.x) *\n     mat3 (vAz.x, 0., vAz.y, 0., 1., 0., - vAz.y, 0., vAz.x);\n  rd = normalize (vec3 (uv, 3.5)) * vuMat;\n  ro = - vec3 (0., 0., 8.) * vuMat;\n  ltDir = normalize (vec3 (1., 1., -1.)) * vuMat;\n  BuildRMats ();\n  vec3 col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n","name":"","description":"","type":"image"}]}}