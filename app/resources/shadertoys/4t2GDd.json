{"Shader":{"ver":"0.1","info":{"id":"4t2GDd","date":"1433775891","viewed":732,"name":"Splattered Sphere","username":"dgreensp","description":"An application of https:\/\/www.shadertoy.com\/view\/4ljGDd","likes":0,"published":3,"flags":0,"tags":["procedural","fractal","sphere"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"const float MAGIC_BOX_MAGIC = 0.56;\n\nfloat magicBox(vec3 p) {\n    \/\/ The fractal lives in a 1x1x1 box with mirrors on all sides.\n    \/\/ Take p anywhere in space and calculate the corresponding position\n    \/\/ inside the box, 0<(x,y,z)<1\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\n    \n    float tot = 0.0;\n    float L = length(p), L2;\n    \n    \/\/ This is the fractal.  More iterations gives a more detailed\n    \/\/ fractal at the expense of more computation.\n    p = abs(p)\/(L*L) - MAGIC_BOX_MAGIC; L2 = length(p); tot += abs(L2-L); L = L2;\n    p = abs(p)\/(L*L) - MAGIC_BOX_MAGIC; L2 = length(p); tot += abs(L2-L); L = L2;\n    p = abs(p)\/(L*L) - MAGIC_BOX_MAGIC; L2 = length(p); tot += abs(L2-L); L = L2;\n    p = abs(p)\/(L*L) - MAGIC_BOX_MAGIC; L2 = length(p); tot += abs(L2-L); L = L2;\n    p = abs(p)\/(L*L) - MAGIC_BOX_MAGIC; L2 = length(p); tot += abs(L2-L); L = L2;\n    p = abs(p)\/(L*L) - MAGIC_BOX_MAGIC; L2 = length(p); tot += abs(L2-L); L = L2;\n    p = abs(p)\/(L*L) - MAGIC_BOX_MAGIC; L2 = length(p); tot += abs(L2-L); L = L2;\n    p = abs(p)\/(L*L) - MAGIC_BOX_MAGIC; L2 = length(p); tot += abs(L2-L); L = L2;\n    p = abs(p)\/(L*L) - MAGIC_BOX_MAGIC; L2 = length(p); tot += abs(L2-L); L = L2;\n    p = abs(p)\/(L*L) - MAGIC_BOX_MAGIC; L2 = length(p); tot += abs(L2-L); L = L2;\n    p = abs(p)\/(L*L) - MAGIC_BOX_MAGIC; L2 = length(p); tot += abs(L2-L); L = L2;\n\n    \n    return tot;\n}\n\n\/\/ A random 3x3 unitary matrix, used to avoid artifacts from slicing the\n\/\/ volume along the same axes as the fractal's bounding box.\nconst mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                    0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                    -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2. * (fragCoord.xy - 0.5*iResolution.xy) \/ iResolution.yy;\n        \n    vec3 sph = vec3(uv.x, uv.y, sqrt(1.-dot(uv,uv)));\n    float ang = iGlobalTime*1.0;\n    mat3 rot = mat3(-sin(ang),0.0,cos(ang),0.,1.,0.,cos(ang),0.,sin(ang));\n    mat3 M2 = M*rot;\n    float q = magicBox(vec3(0.6,0.3,0.4)+0.2*M2*sph);\n    \n    float a = 1. - smoothstep(14., 16., q);\n    \n\tfragColor = vec4(vec3(a),1.0) * (vec4(0.3,1.0,0.3,1.0) * (0.3+0.7*dot(sph,normalize(vec3(-1.,1.,1.)))));\n    \n    if (dot(uv,uv) > 1.) fragColor=vec4(vec3(0.0),1.0);\n}","name":"","description":"","type":"image"}]}}