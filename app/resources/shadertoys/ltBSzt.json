{"Shader":{"ver":"0.1","info":{"id":"ltBSzt","date":"1445794081","viewed":491,"name":"sparkle effect","username":"erkaman","description":"This simple shader draws a sparkle particle effect.","likes":4,"published":3,"flags":0,"tags":["2d","sparkle"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Eric Arneb\u00e4ck - erkaman\/2015\n\/\/ This work is licensed under a \n\/\/ Creative Commons Attribution 4.0 International License\n\n\/*\nThis simple shader draws a sparkle particle effect.\nEvery particle is drawn as a superellipse. \n*\/\n\n#define PARTICLE_COUNT 70\n\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0;\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\n\/\/ 2D rotation matrix by approximately 36 degrees.\nmat2 m = mat2(0.8, 0.6, -0.6, 0.8);\n\nfloat fbm(vec2 r) {\n      \n    \n    float f;\n    \n    \/\/ rotate every octave to add more variation. \n    f  = 0.5000*noise( r ); r = r*m*2.01;\n    f += 0.2500*noise( r ); r = r*m*2.02;\n    f += 0.1250*noise( r ); r = r*m*2.03;\n    f += 0.0625*noise( r ); r = r*m*2.01;\n    \n    return f;   \n}\n\nfloat rand(float co){\n    return fract(sin(dot(vec2(co ,co ) ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand_range(float seed, float low, float high) {\n\treturn low + (high - low) * rand(seed);\n}\n\n\nvec3 rand_color(float seed, vec3 col, vec3 variation) {\n    return vec3(\n        col.x + rand_range(seed,-variation.x, +variation.x),\n        col.y + rand_range(seed,-variation.y, +variation.y),\n        col.z + rand_range(seed,-variation.z, +variation.z));\n}\n\n\n\/\/ Rotation matrix for rotating a point around the origin.\n\/\/ rot is in radians.\nmat2 rot_matrix(float rot) {\n    return mat2(    \n        cos(rot), -sin(rot),\n        sin(rot),  cos(rot)\n    );\n}\n\n\n\/\/ id = particle id\nvec4 sparkle(float time, float id, vec2 q) { \n   \n    float lifespan = rand_range(id*1232.23232, 3.0, 4.5);\n    \n    \/\/ pgen = particle generation\n    \/\/ every time a particle has outlived its lifespan,\n    \/\/ it is respawned as a new particle at a new position\n    \/\/ the generation of this new particle is one plus\n    \/\/ the generation of the old particle. \n    float pgen = float(int(time \/ lifespan));\n    \n    \/\/ how long the particle of the current generation has lived. \n    float lifetime = time - lifespan * pgen;\n    \n    \/\/ pseed is used to determine the random attributes of the particle.\n    \/\/ two particles with the same id but different generations\n    \/\/ are essentially different particles.\n    float pseed = id *12.2 + pgen * 50.3;\n    \n    \n    \/\/ we globally move all particles in an ellipse at this speed.\n    float rot_speed = 0.0454;\n    \n    \/\/ ranges from -0.2 to  0.9\n    float xsource = 0.35 + 0.55* cos(time*rot_speed);\n    \/\/float xsource = 0.2;\n    \n    \/\/ ranges from -0.40 to 0.15\n    float ysource = -0.125 + 0.27500 * sin(time*rot_speed);\n    \n    \/\/ inital particle position.\n    vec2 pos =  q - vec2(\n            rand_range(pseed*1.3+3.0, xsource - 0.2, xsource + 0.2),   \n            rand_range(pseed*113.2+0.6, ysource-0.02, ysource+0.02)          \n            );\n    \n    \/\/ particle velocity\n    vec2 vel = vec2(  \n        rand_range(pseed*-4.4314+123.3243, -0.012, +0.012),       \n        rand_range(pseed*-54.3232+33.323043, -0.06, -0.04)        \n            );\n    \n    \/\/ move particle based on velocity.\n    pos += vel * lifetime;\n    \n    \n    \n    \/\/ controls the diameter of the superellipse.\n    \/\/ we vary it over the lifetime to animate the particle.\n    float dx = 0.02 + 0.01*sin(9.0*(time+pseed*12.5454));\n    float dy = 0.02 + 0.01*sin(9.0*(time+pseed*223.323) );\n    \n    \n    \/\/ slightly rotate the superellipse randomly.\n    float rot = rand_range(pseed*23.33+3.4353, -0.10, 0.10);\n    pos = rot_matrix(rot) * pos;\n    \n    \/\/ every particle is described by a superellipse\n    \/\/ https:\/\/en.wikipedia.org\/wiki\/Superellipse\n    float func =\n        pow(abs(pos.x\/ (dx)  ), 0.5)  + pow(abs(pos.y\/dy), 0.5) - 0.5;\n    \n    vec4 res;\n    \n    vec3 start_color = rand_color(pseed *19.3232, \n                         vec3(0.9,0.9,0),\n                         vec3(0.4,0.4,0.4)\n                         );\n    \n    \/\/ now rgb-value over 1.0 allowed.\n    if(start_color.r > 1.0) {\n        start_color.r = 1.0;\n    } \n    if(start_color.g > 1.0) {\n        start_color.g = 1.0;\n    }\n    \n    vec3 end_color;\n    \n    if(start_color.r < 0.85 && start_color.r < 0.85) {\n    \n     \tend_color = start_color + vec3(0.10);\n       \n    } else {\n        \n        end_color = start_color - vec3(0.10);\n    }\n    \n    \/\/ slightly vary color over lifetime; \n    \/\/ makes for a small blinking effect.\n    float f= 1.0\/2.0 + (  sin(9.0*(time+12.5454))  ) \/ 2.0;\n    res.xyz = mix(start_color, end_color, f);\n    \n    \n    \n    \/\/ uncomment this section to overlay a noise function over the particles.\n    \/\/ this adds more color variation to the individual particles.\n    \/\/ however, be vary that this is VERY slow. \n    \/*\n    pos *= 100.0;\n      \n    vec3 rainbow = vec3(\n         fbm(pos + pseed * 10.430 + vec2(0.2,0.1)),\n         fbm(pos + pseed * 12.5443 + vec2(0.3554,0.94343)),\n         fbm(pos + pseed * -12.12 + vec2(1.8343,13.23454)) \n\n        );\n    \n    res.xyz = mix(res.xyz, rainbow, 0.3);\n    *\/\n    \n    \/\/ we use this value to combine the particle with the rest\n    \/\/ of the image.\n    res.w = smoothstep(0.0, 1.1, 1.0-func);\n    \n    \/\/fade out a particle quickly when its about to die. \n    \/\/ but before that time, leave it mostly unchanged.\n    f = 0.000976175 * exp(6.93187* (lifetime\/lifespan) );\n    res.w = mix(res.w, 0.0, f);\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    vec2 p = fragCoord.xy \/ iResolution.xy;\n    p.x *= iResolution.x\/iResolution.y;\n  \n    vec3 col = vec3(0,0,0); \/\/ black background color. \n\n    vec2 q = p - vec2(0.5,0.5);\n   \n    for(int i = 0; i <PARTICLE_COUNT; i += 1){\n       \n        \/\/ particle id\n        float id = float(i);\n         \n        vec4 res = sparkle(iGlobalTime, id, q);\n    \n        \/\/ combine particle with image.\n        col = mix(col, res.xyz, res.w);       \n    }\n    \n\n    fragColor = vec4(col,1.0);\n    \n    \n}","name":"","description":"","type":"image"}]}}