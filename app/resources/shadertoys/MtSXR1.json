{"Shader":{"ver":"0.1","info":{"id":"MtSXR1","date":"1441510647","viewed":945,"name":"2d ball collisions","username":"archee","description":"simplified continuously timed 2D ball physics with bounce sounds.","likes":13,"published":3,"flags":8,"tags":["2d","collision","sound","balls","physics"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ please don't  change any constants :)\nfloat gravity = 1.2;  \/\/ gravity value \nfloat bounceRatio = 0.8; \/\/ vertical speed multiplied by this at every bounce\nfloat diskrad = 0.05;\nfloat decayx = 0.2;\n\nconst int ballCount = 3;\nvec4 balldatas[ballCount];\nfloat balldatatimeshift[ballCount];\nvec3 ballcolors[ballCount];\nconst bool debugCollis = false;\nvec3 color=vec3(0.0);\nvec2 uv;\nfloat time;\n\nfloat soundout=0.0; \/\/ ignored in the image shader file\n\nvoid disk(vec2 pos,float radius,vec3 color2) \/\/ AA disk\n{\n    color = mix(color2,color,clamp((length(pos-uv)-radius)*iResolution.y+0.5,0.0,1.0)); \n}\n\nvec4 extrapolate(vec4 inp, float querytime)\n{\n    \/\/ this is compile time calculation, until the time value comes in\n    float startx = inp.x;\n    float starty = inp.y;\n    float startvelx = inp.z;\n    float startvely = inp.w;\n    \n    float startmaxheight = starty+startvely*startvely*0.5\/gravity;\n    float startbouncetime = sqrt(startmaxheight*8.0\/gravity);\n    float startbouncestarttime = startbouncetime\/(1.0\/bounceRatio-1.0);\n    float startbouncecount = log(startbouncestarttime)\/log(1.0\/bounceRatio);\n    float startphase = fract(startbouncecount);\n    float startfloorvel = startbouncetime*gravity*0.5;\n    float starttime = pow(1.0\/bounceRatio,startbouncecount+0.999) - startbouncetime*(startvely\/startfloorvel*-0.5+0.5);\n    \n    \/\/ bounce timing follow a logarythmic pattern\n    float ltime = max(starttime-querytime,0.01);\n    float bouncecount = floor(log(ltime)\/log(1.0\/bounceRatio)-startphase)+startphase;\n    float bouncestarttime = pow(1.0\/bounceRatio,bouncecount);\n    float bouncetime = (bouncestarttime)*(1.0\/bounceRatio-1.0);\n    float f = (ltime-bouncestarttime)\/bouncetime;\n    float y = f*(1.0-f)*bouncetime*bouncetime*gravity*0.5;\n    float vely = bouncetime*gravity*0.5*(f*2.0-1.0);\n    \n\/\/    float maxheight = bouncetime*bouncetime*gravity\/8.0;\n\/\/    if ( abs(maxheight-uv.y)<0.01 ) color.y=0.5;\n\/\/    if ( abs(starty-uv.y)<0.01 ) color.z=0.5;\n    \n    \/\/ bouncing on the side walls is fully elastic, just need to mirror them \n    float x = (1.0-exp(-querytime*decayx))*(startvelx\/decayx)+startx;\n    float velx = exp(-querytime*decayx)*startvelx;\n    float stime2 = 0.0;\n    if (x>0.0) \/\/ balls start outside the walls, negative X means no need to mirror it\n    {\n        if (x>0.5) stime2 = velx<0.0?  fract(-x)\/-velx : fract(x)\/velx;\n        x = mod(x,2.0);  \/\/ bounce left wall\n        if (x>1.0)  \n        {\n            x=2.0-x; \/\/ bounce right wall\n            velx *= -1.0;\n        }\n    }\n    \n    float stime = bouncetime-(ltime-bouncestarttime);\n    soundout+=clamp(sin(stime*(0.2-stime)*7000.0)*exp(stime*-60.0)*pow(bouncetime,0.7)*4.0,-0.3,0.3); \/\/ botton floor bounce sound\n    soundout+=clamp(sin(stime2*(0.2-stime2)*5000.0)*exp(stime2*-60.0)*4.0,-0.3,0.3); \/\/ wide wall bounce sound\n    \n    return vec4(x,y,velx,vely);\n}\n\nvoid collisSound(float starttime) \/\/ ball vs ball collision sound\n{\n    float stime = time-starttime;\n    soundout+=clamp(sin(stime*(0.18-stime)*10000.0)*exp(stime*-50.0)*3.0,-0.4,0.4);\n}\n\n\n\/\/ won't work as a function\n\/\/ this function finds out the balls position and velocity at a given timepoint\n\/\/ find the velocities after a collision\n\/\/ then sets up their parameter to start from their actual position with the new velocity\n#define collis(balla,ballb,collistime)     if (time>collistime) { collisSound(collistime);   vec4 resa = extrapolate(balldatas[balla],collistime-balldatatimeshift[balla]);    vec4 resb = extrapolate(balldatas[ballb],collistime-balldatatimeshift[ballb]);    vec2 bouncenormal = normalize((resa.xy-resb.xy));    vec2 bouncepos = (resa.xy+resb.xy)*0.5;    if (debugCollis) disk(bouncepos,0.003,vec3(0.0));    vec2 midvel = (resa.zw+resb.zw)*0.5;    vec2 newvela = resa.zw-midvel;    newvela -= bouncenormal*dot(bouncenormal,newvela)*(bounceRatio+1.0);    vec2 newvelb = resb.zw-midvel;    newvelb -= bouncenormal*dot(bouncenormal,newvelb)*(bounceRatio+1.0);    resa.x += 30.0;    resb.x += 30.0;    balldatas[balla] = vec4(resa.xy,newvela+midvel);    balldatas[ballb] = vec4(resb.xy,newvelb+midvel);    balldatatimeshift[balla] = collistime;    balldatatimeshift[ballb] = collistime;    }\n\nvoid rundemo(float timein) \n{\n    timein = mod(timein,30.0);\n    \n    ballcolors[0] = vec3(0.9,0.0,0.0);\n    ballcolors[1] = vec3(0.8,0.5,0.0);\n    ballcolors[2] = vec3(0.1,0.6,0.0);\n    \n    balldatas[0] = vec4(-0.2,0.5,0.5,0.5);\n    balldatatimeshift[0] = 0.0;\n    balldatas[1] = vec4(-0.2,0.7,0.7,0.5);\n    balldatatimeshift[1]= 0.0;\n    balldatas[2] = vec4(-0.4,0.7,0.6,0.6);\n    balldatatimeshift[2]= 0.0;\n        \n    color = vec3(1.0);\n    time = timein-1.5;\n    \n    float cameramove = pow(max((-time+2.0)\/4.0,0.0),2.0);\n    uv\/=1.2;\/\/clamp(timein-1.0,0.9,1.2);   \/\/ zoom\n    uv.x += 0.5-cameramove*1.5; \/\/ scroll world\n    uv.y -= 0.07;\n    \n\n    \/\/ precomputed collision ball vs ball times  note: wall collisions are fully automatic\n    collis(0,2,1.545);\n    collis(0,2,2.687);\n    collis(1,2,3.563);\n    collis(0,2,3.86);\n    collis(0,2,4.22);\n    collis(1,2,5.34);\n    collis(0,2,6.00);\n    collis(0,2,7.93);\n    collis(1,2,10.09);\n    collis(0,2,12.73);\n    collis(1,2,16.57);\n}\n\n\/\/ the part above this line is copied to the sound shader file\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tuv = fragCoord.xy \/ iResolution.xy;\n    uv.x -= 0.5;\n    uv.x*=16.0\/9.0;\n  \n    \n    rundemo(iGlobalTime);\n    if (uv.x>1.0+diskrad+0.02 || (uv.y>0.5 && time>3.0)) \/\/ optimization for the area where balls never go\n    {\n        fragColor = vec4(1.0);\n        return;\n    }\n    \n    \/\/ render balls\n    for(int i=0;i<ballCount;i++)\n    {\n        vec4 res = extrapolate(balldatas[i],time-balldatatimeshift[i]);\n        disk(res.xy,diskrad,ballcolors[i]);\n    }\n    \n    \/\/ render walls and floor\n    if ( abs(abs(uv.x-0.5)-0.5-diskrad-0.01)<0.01 && uv.y<0.5 && uv.y>-diskrad ) color=vec3(0.0);\n    if (  abs(uv.x-0.1) < 0.9+diskrad && uv.y<0.0-diskrad && uv.y>-0.02-diskrad) color=vec3(0.0);\n    \n\tfragColor = vec4(color,1.0);\n}","name":"","description":"","type":"image"},{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ please don't  change any constants :)\nfloat gravity = 1.2;  \/\/ gravity value \nfloat bounceRatio = 0.8; \/\/ vertical speed multiplied by this at every bounce\nfloat diskrad = 0.05;\nfloat decayx = 0.2;\n\nconst int ballCount = 3;\nvec4 balldatas[ballCount];\nfloat balldatatimeshift[ballCount];\nvec3 ballcolors[ballCount];\nconst bool debugCollis = false;\nvec3 color=vec3(0.0);\nvec2 uv;\nfloat time;\n\nfloat soundout=0.0; \/\/ ignored in the image shader file\n\nvoid disk(vec2 pos,float radius,vec3 color2) \/\/ AA disk\n{\n\/\/    color = mix(color2,color,clamp((length(pos-uv)-radius)*iResolution.y+0.5,0.0,1.0)); \n}\n\nvec4 extrapolate(vec4 inp, float querytime)\n{\n    \/\/ this is compile time calculation, until the time value comes in\n    float startx = inp.x;\n    float starty = inp.y;\n    float startvelx = inp.z;\n    float startvely = inp.w;\n    \n    float startmaxheight = starty+startvely*startvely*0.5\/gravity;\n    float startbouncetime = sqrt(startmaxheight*8.0\/gravity);\n    float startbouncestarttime = startbouncetime\/(1.0\/bounceRatio-1.0);\n    float startbouncecount = log(startbouncestarttime)\/log(1.0\/bounceRatio);\n    float startphase = fract(startbouncecount);\n    float startfloorvel = startbouncetime*gravity*0.5;\n    float starttime = pow(1.0\/bounceRatio,startbouncecount+0.999) - startbouncetime*(startvely\/startfloorvel*-0.5+0.5);\n    \n    \/\/ bounce timing follow a logarythmic pattern\n    float ltime = max(starttime-querytime,0.01);\n    float bouncecount = floor(log(ltime)\/log(1.0\/bounceRatio)-startphase)+startphase;\n    float bouncestarttime = pow(1.0\/bounceRatio,bouncecount);\n    float bouncetime = (bouncestarttime)*(1.0\/bounceRatio-1.0);\n    float f = (ltime-bouncestarttime)\/bouncetime;\n    float y = f*(1.0-f)*bouncetime*bouncetime*gravity*0.5;\n    float vely = bouncetime*gravity*0.5*(f*2.0-1.0);\n    \n\/\/    float maxheight = bouncetime*bouncetime*gravity\/8.0;\n\/\/    if ( abs(maxheight-uv.y)<0.01 ) color.y=0.5;\n\/\/    if ( abs(starty-uv.y)<0.01 ) color.z=0.5;\n    \n    \/\/ bouncing on the side walls is fully elastic, just need to mirror them \n    float x = (1.0-exp(-querytime*decayx))*(startvelx\/decayx)+startx;\n    float velx = exp(-querytime*decayx)*startvelx;\n    float stime2 = 0.0;\n    if (x>0.0) \/\/ balls start outside the walls, negative X means no need to mirror it\n    {\n        if (x>0.5) stime2 = velx<0.0?  fract(-x)\/-velx : fract(x)\/velx;\n        x = mod(x,2.0);  \/\/ bounce left wall\n        if (x>1.0)  \n        {\n            x=2.0-x; \/\/ bounce right wall\n            velx *= -1.0;\n        }\n    }\n    \n    float stime = bouncetime-(ltime-bouncestarttime);\n    soundout+=clamp(sin(stime*(0.2-stime)*7000.0)*exp(stime*-60.0)*pow(bouncetime,0.7)*4.0,-0.3,0.3); \/\/ botton floor bounce sound\n    soundout+=clamp(sin(stime2*(0.2-stime2)*5000.0)*exp(stime2*-60.0)*4.0,-0.3,0.3); \/\/ wide wall bounce sound\n    \n    return vec4(x,y,velx,vely);\n}\n\nvoid collisSound(float starttime) \/\/ ball vs ball collision sound\n{\n    float stime = time-starttime;\n    soundout+=clamp(sin(stime*(0.18-stime)*10000.0)*exp(stime*-50.0)*3.0,-0.4,0.4);\n}\n\n\n\/\/ won't work as a function\n\/\/ this function finds out the balls position and velocity at a given timepoint\n\/\/ find the velocities after a collision\n\/\/ then sets up their parameter to start from their actual position with the new velocity\n#define collis(balla,ballb,collistime)     if (time>collistime) { collisSound(collistime);   vec4 resa = extrapolate(balldatas[balla],collistime-balldatatimeshift[balla]);    vec4 resb = extrapolate(balldatas[ballb],collistime-balldatatimeshift[ballb]);    vec2 bouncenormal = normalize((resa.xy-resb.xy));    vec2 bouncepos = (resa.xy+resb.xy)*0.5;    if (debugCollis) disk(bouncepos,0.003,vec3(0.0));    vec2 midvel = (resa.zw+resb.zw)*0.5;    vec2 newvela = resa.zw-midvel;    newvela -= bouncenormal*dot(bouncenormal,newvela)*(bounceRatio+1.0);    vec2 newvelb = resb.zw-midvel;    newvelb -= bouncenormal*dot(bouncenormal,newvelb)*(bounceRatio+1.0);    resa.x += 30.0;    resb.x += 30.0;    balldatas[balla] = vec4(resa.xy,newvela+midvel);    balldatas[ballb] = vec4(resb.xy,newvelb+midvel);    balldatatimeshift[balla] = collistime;    balldatatimeshift[ballb] = collistime;    }\n\nvoid rundemo(float timein) \n{\n    timein = mod(timein,30.0);\n    \n    ballcolors[0] = vec3(0.9,0.0,0.0);\n    ballcolors[1] = vec3(0.8,0.5,0.0);\n    ballcolors[2] = vec3(0.1,0.6,0.0);\n    \n    balldatas[0] = vec4(-0.2,0.5,0.5,0.5);\n    balldatatimeshift[0] = 0.0;\n    balldatas[1] = vec4(-0.2,0.7,0.7,0.5);\n    balldatatimeshift[1]= 0.0;\n    balldatas[2] = vec4(-0.4,0.7,0.6,0.6);\n    balldatatimeshift[2]= 0.0;\n        \n    color = vec3(1.0);\n    time = timein-1.5;\n    \n    float cameramove = pow(max((-time+2.0)\/4.0,0.0),2.0);\n    uv\/=1.2;\/\/clamp(timein-1.0,0.9,1.2);   \/\/ zoom\n    uv.x += 0.5-cameramove*1.5; \/\/ scroll world\n    uv.y -= 0.07;\n    \n\n    \/\/ precomputed collision ball vs ball times  note: wall collisions are fully automatic\n    collis(0,2,1.545);\n    collis(0,2,2.687);\n    collis(1,2,3.563);\n    collis(0,2,3.86);\n    collis(0,2,4.22);\n    collis(1,2,5.34);\n    collis(0,2,6.00);\n    collis(0,2,7.93);\n    collis(1,2,10.09);\n    collis(0,2,12.73);\n    collis(1,2,16.57);\n}\n\nvec2 mainSound(float time2)\n{\n    \n    soundout = 0.0;\n    rundemo(time2);\n    for(int i=0;i<ballCount;i++) \/\/ bounce sounds\n    {\n        vec4 res = extrapolate(balldatas[i],time-balldatatimeshift[i]);\n    }\n    return vec2(soundout);\n}","name":"","description":"","type":"sound"}]}}