{"Shader":{"ver":"0.1","info":{"id":"ldj3Dm","date":"1389735599","viewed":12152,"name":"Fish swimming","username":"iq","description":"Swimming fish","likes":117,"published":3,"flags":0,"tags":["procedural","3d","raymarching","distancefield","fish"],"hasliked":0},"renderpass":[{"inputs":[{"id":7,"src":"\/presets\/tex06.jpg","ctype":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":8,"src":"\/presets\/tex07.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":10,"src":"\/presets\/tex09.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":15,"src":"\/presets\/tex10.png","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/-----------------------------------------------------------------------------------\n\nfloat hash1( float n ) { return fract(sin(n)*43758.5453123); }\n\nfloat noise1( in float x )\n{\n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix( hash1(p+0.0), hash1(p+1.0), f );\n}\n\n\/\/-----------------------------------------------------------------------------------\n\nvec2 sd2Segment( vec3 a, vec3 b, vec3 p )\n{\n\tvec3  pa = p - a;\n\tvec3  ba = b - a;\n\tfloat t = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\tvec3  v = pa - ba*t;\n\treturn vec2( dot(v,v), t );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\/\/-----------------------------------------------------------------------------------\n\nvec3 fishPos;\nfloat fishTime;\n\nvec3 sdFish( vec3 p )\n{\n    vec3 res = vec3( 1000.0, 0.0, 0.0 );\n\n\tp -= fishPos;\n\t\n\tif( dot(p,p)>16.0 ) return vec3(5.0);\n\n\tp *= vec3(1.2,0.8,1.2);\n\tvec3 q = p;\n\t\n    vec3 a = vec3(0.0,0.0,0.0);\n\ta.x -= 0.25*sin(8.0*0.2*fishTime);\n\tvec3 oa = a;\n\n\tfloat or = 0.0;\n\tfloat th = 0.0;\n\tfloat hm = 0.0;\n\n\t#define NUMI 7\n\t#define NUMF 7.0\n\tvec3 p1 = a; vec3 d1=vec3(0.0);\n\tvec3 p2 = a; vec3 d2=vec3(0.0);\n\tvec3 mp = a;\n\tfor( int i=0; i<NUMI; i++ )\n\t{\t\n\t\tfloat ih = float(i)\/NUMF;\n\t\t\n\t\tfloat an = or + 1.0*(0.2+0.8*ih)*sin(3.0*ih - 2.0*fishTime);\n\t\tfloat ll = 0.26;\n\t\tif( i==(NUMI-1) ) ll=0.4;\n\t\tvec3 b = a + ll*vec3(sin(an), 0.0, cos(an))*(16.0\/NUMF);\n\t\t\n\t\tvec2 dis = sd2Segment( a, b, p );\n\n\t\tif( dis.x<res.x ) {res=vec3(dis.x,ih+dis.y\/NUMF,0.0); mp=a+(b-a)*dis.y; }\n\t\t\n\t\tif( i==1 ) { p1=a; d1 = b-a; }\n\t\t\n\t\ta = b;\n\t}\n\tfloat h = res.y;\n\tfloat ra = 0.04 + h*(1.0-h)*(1.0-h)*2.7;\n\n\t\/\/ tail\n\tp.y \/= 1.0 + 14.0*(1.0-smoothstep( 0.0, 0.13, 1.0-h));\n    p.z += 0.08*(1.0-clamp(abs(p.y)\/0.075,0.0,1.0))*(1.0-smoothstep( 0.0,0.1,1.0-h));\n\tres.x = 0.75 * (distance(p,mp) - ra);\n\t\n\t\/\/ mouth\n\tfloat d3 = 0.75*(length( (p - oa)*vec3(0.5,2.0,1.0) )-0.12);\n\tres.x = max( -d3, res.x );\n\t\n\t\/\/ upper central fin\n\tfloat fh = smoothstep(0.15,0.2,h) - smoothstep(0.25,0.8,h);\n\tfh -= 0.2*pow(0.5+0.5*sin(210.0*h),0.2)*fh;\n\td3 = length(p.xz-mp.xz) - 0.01;\n    d3 = max( d3, p.y - (mp.y+ra+0.2*fh) );\n\td3 = max( d3, -p.y - 0.0 );\n\tres.x = min( res.x, d3 );\n\t\n\t\/\/ fins\n\td1.xz = normalize(d1.xz);\n\n\tfloat flap = 0.7 + 0.3*sin(2.0*8.0*0.2*fishTime);\n    vec2 dd = normalize(d1.xz + sign((p-p1).x)*flap*d1.zx*vec2(-1.0,1.0));\n\tmat2 mm = mat2( dd.y, dd.x, -dd.x, dd.y );\n\tvec3 sq = p-p1;\n\tsq.xz = mm*sq.xz;\n\tsq.y += 0.2;\n\tsq.x += -0.15;\n\tfloat d = length( (sq-vec3(0.5,0.0,0.0))*vec3(1.0,2.0,1.0) ) - 0.3;\n\td = 0.5*max( d, sdBox( sq, vec3(1.0,1.0,0.01) ) );\n    if( d<res.x ) res.z = smoothstep( 0.2, 0.7, sq.x );\n\tres.x = smin( d, res.x, 0.05 );\n\n\tsq = p-p1;\n\tsq.xz = mm*sq.xz;\n\tsq.y += 0.2;\n\tsq.x += 0.15;\n\td = length( (sq-vec3(-0.5,0.0,0.0))*vec3(1.0,2.0,1.0) ) - 0.3;\n\td = 0.5*max( d, sdBox( sq, vec3(1.0,1.0,0.01) ) );\n    if( d<res.x ) res.z = smoothstep( 0.2, 0.7, sq.x );\n\tres.x = smin( d, res.x, 0.05 );\n\n\treturn res;\n\n}\n\nvec4 map( in vec3 p )\n{\n\tfloat h = 1.0;\n\tvec3 q = p;\n\tfloat th = smoothstep( 0.1, 0.4, texture2D( iChannel0, 0.002*q.xz, -100.0 ).x );\n    float rr = smoothstep( 0.2, 0.5, texture2D( iChannel1, 2.0*0.02*q.xz, -100.0 ).y );\n\th = 0.9 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.1*(1.0-texture2D( iChannel0, 0.1*q.xz, -100.0 ).x);\n\th += th*1.25;\n    h -= 0.24*rr;\n\th *= 0.75;\n    vec4 res = vec4( (p.y+h)*0.3, p.x, 0.0, 0.0 );\n\t\t\n\tvec4 tmp = vec4( sdFish( p ), 1.0 ); if( tmp.x<res.x ) res=tmp;\n\n\treturn res;\n}\n\nvec4 intersect( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 20.0;\n\tconst float precis = 0.001;\n    float h = precis*3.0;\n    float t = 0.0;\n    float m = 0.0;\n\tfloat l = 0.0;\n\tfloat r = 0.0;\n    for( int i=0; i<80; i++ )\n    {\n        if( h<precis || t>maxd ) break;\n\n\t\tt += h;\n\t    vec4 res = map( ro+rd*t );\n        h = res.x;\n\t\tl = res.y;\n\t\tr = res.z;\n        m = res.w;\t\t\t\n    }\n\n    if( t>maxd ) m=-1.0;\n    return vec4( t, l, m, r);\n}\n\nvec3 calcNormal( in vec3 pos, in float e )\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    for( int i=0; i<40; i++ )\n    {\n        h = map(ro + rd*t).x;\n        res = min( res, smoothstep(0.0,1.0,k*h\/t) );\n\t\tt += clamp( h, 0.05, 0.5 );\n\t\tif( h<0.0001 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 lig = normalize(vec3(0.9,0.35,-0.2));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x\/iResolution.y;\n    vec2 m = vec2(0.5);\n\tif( iMouse.z>0.0 ) m = iMouse.xy\/iResolution.xy;\n\n\n    \/\/-----------------------------------------------------\n    \/\/ animate\n    \/\/-----------------------------------------------------\n\t\n\tfishTime = iGlobalTime + 3.5*noise1(0.2*iGlobalTime);\n\n\tfishPos = vec3( 0.0, 0.0, -0.7*fishTime );\n\t\n    \/\/-----------------------------------------------------\n    \/\/ camera\n    \/\/-----------------------------------------------------\n\n\tfloat an = 1.5 + 0.1*iGlobalTime - 12.0*(m.x-0.5);\n\n\tvec3 ta = fishPos - vec3(0.0,0.0,-2.0);\/\/vec3(0.0,1.0,2.0);\n\tvec3 ro = ta + vec3(4.0*sin(an),4.0,4.0*cos(an));\n\n    \/\/ shake\n\tro += 0.01*sin(4.0*iGlobalTime*vec3(1.1,1.2,1.3)+vec3(3.0,0.0,1.0) );\n\tta += 0.01*sin(4.0*iGlobalTime*vec3(1.7,1.5,1.6)+vec3(1.0,2.0,1.0) );\n\n    \/\/ camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t\n\t\/\/ create view ray\n    p.x += 0.012*sin( 3.0*sin(4.0*p.y+0.5*iGlobalTime) + 4.0*p.x + 0.5*iGlobalTime );\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n    \/\/-----------------------------------------------------\n\t\/\/ render\n    \/\/-----------------------------------------------------\n\n\tvec3 col = vec3(0.4,0.6,0.8);\n\tvec3 bcol = col;\n\t\n\tfloat pt = (1.0-ro.y)\/rd.y;\n\t\n\tvec3 oro = ro;\n\tif( pt>0.0 ) ro=ro+rd*pt;\n\t\n\t\/\/ raymarch\n    vec4 tmat = intersect(ro,rd);\n    if( tmat.z>-0.5 )\n    {\n\t\tfloat eps = 0.01 + 0.03*step(0.5,tmat.z);\n        \/\/ geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormal(pos,eps);\n\t\tvec3 ref = reflect( rd, nor );\n\n        \/\/ materials\n\t\tvec4 mate = vec4(0.5,0.5,0.5,0.0);\n\t\t\n\t\tif( tmat.z<0.5 )\n\t\t{\n\t\t\tvec3 te = texture2D( iChannel0, 0.1*pos.xz ).xyz;\n\t\t\tte = 0.05 + te;\n\t\t\t\n\t\t\tmate.xyz = 0.6*te;\n\t\t\tmate.w = 5.0*(0.5+0.5*te.x);\n\t\t\t\n\t\t\t\t\n\t\t\tfloat th = smoothstep( 0.1, 0.4, texture2D( iChannel0, 0.002*pos.xz ).x );\n\t\t\tvec3 dcol = mix( vec3(0.1, 0.1, 0.0), 0.4*vec3(0.65, 0.4, 0.2), 0.2+0.8*th );\n\n\t\t\tmate.xyz = mix( mate.xyz*0.5, dcol, th*smoothstep( 0.0, 1.0, nor.y ) );\n\n\t\t\tfloat rr = smoothstep( 0.2, 0.4, texture2D( iChannel1, 2.0*0.02*pos.xz ).y );\n\t\t\tmate.xyz *= mix( vec3(1.0), vec3(0.2,0.2,0.2)*1.5, rr );\n\t\t\t\n\t\t\tmate.xyz *= 1.5;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmate.w = 8.0;\n\t\t\tmate.xyz = 1.0*vec3(0.24,0.17,0.22);\n\n\t\t\tvec3 te = 0.8+2.2*texture2D( iChannel0, vec2(2.0*tmat.y,pos.y) ).xyz;\n\t\t\tmate.xyz *= te;\n\t\t\t\n\t\t\t\/\/ belly\/backfin\n\t\t\tfloat iscola = smoothstep( 0.0, 0.2, 1.0-tmat.y );\n\t\t\tmate.xyz = mix( mate.xyz, mix(vec3(te.x*0.5 + 1.5),\n\t\t\t\t\t\t\t\t\t\t  mix(1.0+0.5*sin(150.0*pos.y - sign(pos.y)*tmat.y*300.0),1.0,smoothstep( 0.0, 0.1, 1.0-tmat.y ))*vec3(2.6,1.5,1.0)*0.9 + 1.0*vec3(2.0,1.0,0.5)*(1.0-smoothstep( 0.0, 0.09, 1.0-tmat.y )),\n\t\t\t\t\t\t\t\t\t\t  1.0-iscola)*0.5, smoothstep(-0.4,0.0,-nor.y) );\n\t\t\t\n\t\t\t\/\/ stripes\n\t\t\tmate.xyz = mix( mate.xyz, (te.x+0.5)*1.0*vec3(0.5), 0.75*smoothstep( 0.5, 1.0, sin(1.0*te.x+tmat.y*100.0 + 13.0*nor.y) )*smoothstep(0.0,0.5,nor.y) );\n\n\t\t\t\/\/ escamas\n\t\t\tfloat ll = clamp( (tmat.y-0.2)\/(0.8-0.2), 0.0, 1.0 );\n\t\t\tfloat ha = 1.0-4.0*ll*(1.0-ll);\n\t\t\tfloat pa = smoothstep( -1.0+2.0*ha, 1.0, sin( 50.0*pos.y ) )* smoothstep( -1.0, 0.0, sin( 560.0*tmat.y ) );\n\t\t\tpa *= 1.0-smoothstep( 0.1, 0.2, nor.y );\n\t\t\tmate.xyz *= 0.5 + 0.5*vec3(1.0) * (1.0-pa);\n\t\t\t\n\t\t\t\/\/ eye\n\t\t\tfloat r = length(vec2(5.0*tmat.y,pos.y)-vec2(0.5,0.13) );\n\t\t\tr \/= 1.2;\n\t\t\tmate.xyz = mix( mate.xyz, vec3(1.5)*clamp(1.0-r*4.0,0.0,1.0), 0.5*(1.0-smoothstep(0.08,0.09,r)) );\n\t\t\tmate.xyz *= smoothstep(0.03,0.05,r);\n\t\t\tmate.xyz += vec3(4.0)*(1.0-smoothstep(0.0,0.1,r))*pow( texture2D( iChannel1, 4.0*vec2(0.2*fishPos.z+4.0*tmat.y,pos.y) ).x, 2.0 );\n\t\t\tr = length(vec2(5.0*tmat.y,pos.y)-vec2(0.48,0.14) );\n\t\t\tmate.xyz = mix( mate.xyz, vec3(2.0), (1.0-smoothstep(0.0,0.02,r)) );\n\t\t\t\n\t\t\t\/\/ mouth\n\t\t\tvec3 oa = fishPos;\n\t        oa.x -= 0.25*sin(8.0*0.2*fishTime);\n\t\t\tmate.xyz *= 0.1 + 0.9*step( 0.0, length( (pos - oa+vec3(0.0,0.0,-0.02))*vec3(1.5,2.0,1.0) ) - 0.14 );\n\t\t\t\n\t\t\t\/\/ top fin\n\t        float fh = smoothstep(0.15,0.2,tmat.y) - smoothstep(0.25,0.8,tmat.y);\n\t        float ra = 0.04 + tmat.y*(1.0-tmat.y)*(1.0-tmat.y)*2.7;\n\t\t\tfloat vv = clamp((pos.y-ra-0.1)\/0.2,0.0,1.0);\n\t\t\tvec3 fincol = mix(1.0+0.5*sin(520.0*tmat.y),1.0,vv)*mix(vec3(0.8,0.2,0.2),vec3(1.5,1.4,1.5),vv);\n            mate.xyz = mix( mate.xyz, fincol, fh*smoothstep(0.0,0.05,pos.y-ra-0.1) );\n\t\t\t\n\t\t\t\/\/ side fins\n\t\t\tfloat isFin = tmat.w;\n\t\t\tfincol = 0.5*vec3(3.0,2.0,2.0) * mix(1.0+0.2*sin(150.0*pos.y),1.0,0.0);\n            mate.xyz = mix( mate.xyz, fincol, isFin );\n\t\t\t\n\t\t\tmate.xyz *= 0.17;\n\t\t}\n\t\t\n\t\t\/\/ lighting\n        float sky = clamp(nor.y,0.0,1.0);\n\t\tfloat bou = clamp(-nor.y,0.0,1.0);\n\t\tfloat dif = max(dot(nor,lig),0.0);\n        float bac = max(0.3 + 0.7*dot(nor,-vec3(lig.x,0.0,lig.z)),0.0);\n\t\tfloat sha = 0.0; if( dif>0.001 ) sha=softshadow( pos+0.01*nor, lig, 0.0005, 32.0 );\n        float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 5.0 );\n        float spe = max( 0.0, pow( clamp( dot(lig,reflect(rd,nor)), 0.0, 1.0), mate.w ) ) * mate.w;\n\t\tfloat sss = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 3.0 );\n\t\t\n\t\t\/\/ lights\n\t\tvec3 lin = vec3(0.0);\n\t\tfloat cc  = 0.55*texture2D( iChannel2, 1.8*0.02*pos.xz + 0.007*iGlobalTime*vec2( 1.0, 0.0) ).x;\n\t\t      cc += 0.25*texture2D( iChannel2, 1.8*0.04*pos.xz + 0.011*iGlobalTime*vec2( 0.0, 1.0) ).x;\n\t\t      cc += 0.10*texture2D( iChannel2, 1.8*0.08*pos.xz + 0.014*iGlobalTime*vec2(-1.0,-1.0) ).x;\n\t\tcc = 0.6*(1.0-smoothstep( 0.0, 0.025, abs(cc-0.4))) + \n\t\t\t 0.4*(1.0-smoothstep( 0.0, 0.150, abs(cc-0.4)));\n\t\tdif *= 1.0 + 2.0*cc;\n\n\t\tlin += 3.5*dif*vec3(1.00,1.00,1.00)*sha;\n\t\tlin += 3.0*sky*vec3(0.10,0.20,0.35);\n\t\tlin += 1.0*bou*vec3(0.20,0.20,0.20);\n\t\tlin += 2.0*bac*vec3(0.50,0.60,0.70);\n        lin += 2.0*sss*vec3(0.20,0.20,0.20)*(0.2+0.8*dif*sha)*mate.w;\n\t\tlin += 2.0*spe*vec3(1.0)*sha*(0.3+0.7*fre);\n\t\t\n\t\t\/\/ surface-light interacion\n\t\tcol = mate.xyz * lin;\n\n\t\t\/\/ fog\n\t\ttmat.x = max(0.0,tmat.x-1.3); col *= 0.65;\n\t\tfloat hh = 1.0-exp(-0.2*tmat.x); \n\t\tcol = col*(1.0-hh)*(1.0-hh) + 1.25*vec3(0.0,0.12,0.2)*hh;\n\t}\n\t\n    \/\/ foam\t\n\tvec2 uv = (oro + rd*pt).xz;\n\tfloat sur = texture2D( iChannel3, 0.06*uv ).x;\n\tsur = smoothstep( 0.5, 1.0, sur )*0.5 + 0.5*sur*sur*smoothstep(0.2,1.0,texture2D( iChannel2, 1.0*uv ).x);\n\tcol = mix( col, vec3(1.0), 0.5*sur );\n\n\t\/\/ sun specular\n\tfloat sun = clamp( dot(lig, reflect( rd, vec3(0.0,1.0,0.0) ) ), 0.0, 1.0 );\n\tcol += 0.2*vec3(1.0,0.95,0.9)*pow(sun,16.0);\n\tcol += 0.5*vec3(1.0,0.95,0.9)*pow(sun,96.0);\n\n\t\/\/-----------------------------------------------------\n\t\/\/ postprocessing\n    \/\/-----------------------------------------------------\n\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\n    col = mix( col, vec3(dot(col,vec3(0.333))), -0.5 );\n\t\n\tcol = 0.5*col + 0.5*col*col*(3.0-2.0*col);\n\t\n\tcol *= 0.2 + 0.8*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n\tcol *= smoothstep( 0.0, 1.0, iGlobalTime );\n\t\n\tfragColor = vec4( col, 1.0 );\n}\n","name":"","description":"","type":"image"}]}}