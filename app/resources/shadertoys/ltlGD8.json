{"Shader":{"ver":"0.1","info":{"id":"ltlGD8","date":"1421791163","viewed":875,"name":"Space Patrol","username":"bergi","description":"It's space time 0.11, 0.81, 0.8. <br\/>The Space Patrol \"ltlGD8\" is making it's round in the nearby Kali star system, looking for glitches - and boy they found some!","likes":5,"published":3,"flags":0,"tags":["volume","marching","kaliset"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/** Space Patrol\n\n\t(c) 2015, stefan berke (aGPL3)\n\t\n\tLooked like a nice idea. \n\tThe volume tracer needs to be revised though, \n    or you have 4 recent GTX or Quadros SLIed together...\n\n\tupdate: added random start pos for tracing to remove banding\n\t\n\tParameter and path created via\n\thttps:\/\/www.shadertoy.com\/view\/XlsGDH\n*\/\n\n\/\/ ------------------ \"interface\" -----------------------\n\n#define QUALITY\t\t\t0\t\t\t\t\t\t\t\/\/ 0 = friendly but noisy, 1 = better, 2 = future\n#define RANDOMIZE\t\t1\t\t\t\t\t\t\t\/\/ randomize trace start\n#define POST_PROCESS\t1\t\t\t\t\t\t\t\/\/ cheap post-proc to hide the artefacts\n\nconst vec3 KALI_PARAM =\tvec3(0.11, 0.81, 0.8);\t\t\/\/ the magic number \nconst int  NUM_ITER =\t23;\t\t\t\t\t\t\t\/\/ number of iterations in kali set\n\nconst float MIX_ALPHA =\t1.;\t\t\t\t\t\t\t\/\/ opacity of the traced samples\n#if QUALITY == 0\nconst float DEPTH = \t0.04;\t\t\t\t\t\t\/\/ maximum depth to trace in volume\nconst int \tNUM_TRACE =\t40;\t\t\t\t\t\t\t\/\/ number traces through volume\n#elif QUALITY == 1\nconst float DEPTH = \t0.06;\t\t\t\t\nconst int \tNUM_TRACE =\t100;\t\t\t\t\t\n#elif QUALITY == 2\nconst float DEPTH = \t0.08;\t\t\t\t\nconst int \tNUM_TRACE =\t350;\t\t\t\t\t\n#endif\nconst float STEP = \t\tDEPTH \/ float(NUM_TRACE);\n\n\n\/\/ ----------------- kali set --------------------------\n\nvec3 kaliset(in vec3 p)\n{\n    vec3 c = vec3(0.);\n    for (int i=0; i<NUM_ITER; ++i)\n    {\n        p = abs(p) \/ dot(p, p) - KALI_PARAM;\n        c += p;\n    }\n    return c \/ float(NUM_ITER);\n}\n\n\/\/ ---------------------- renderer --------------------------\n\n\/\/ hash functions by Dave_Hoskins https:\/\/www.shadertoy.com\/view\/4djSRW\nfloat hash11(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\nfloat hash12(vec2 p)\n{\n\tp  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4337);\n}\n\n\/\/ brute force volume tracer\n\/\/ it starts at the end of the ray (pos + DEPTH * dir)\n\/\/ and moves towards the camera plane\n\/\/ mixing-in the colors from the kaliset() function\nvec3 trace(in vec3 pos, in vec3 dir)\n{\n#if RANDOMIZE != 0\n    pos += dir * STEP * hash12(dir.xy + iGlobalTime \/ 100.);\n#endif\n    \n    vec3 col = vec3(0.);\n    for (int i=0; i<NUM_TRACE; ++i)\n    {\n        float t = float(i) \/ float(NUM_TRACE);\n        \n        vec3 p = pos + DEPTH * (1.-t) * dir;\n        \n        vec3 k = clamp(kaliset(p), 0., 1.) * (0.01+0.99*t);\n      \n        float ka = dot(k, k) \/ 3.;\n              \n        col += ka * MIX_ALPHA * (k - col);\n        \n    }\n    \n    return col;\n}\n\n\nvec3 postproc(in vec3 col, vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy \/ iResolution.xy * 2. - 1.;\n    \n    col *= 0.8+0.2*sin(uv.y * 240. + iGlobalTime);\n    \n    col *= 1. - 4.*length(max(abs(uv)-.8, 0.));\n    col = min(vec3(1.), col*1.7);\n    \n    return col;\n}\n\n\n\/\/ --------------------- put it together -----------------------\n\n\/* The path more or less describes an ellipse on the x,y plane\n   with the big radius on x, so we follow the direction of these star stripes\n   most of the time. \n   By the way, the camera's up vector is z. *\/\nvec3 path(in float ti)\n{\n    return vec3(\n        0.28 + 0.16 * sin(ti),\n        2.91 + 0.02 * cos(ti) + 0.006 * sin(ti * 7.),\n        0.1  + 0.003 * sin(ti * 7.7)\n        );\n}\n\nvec2 rotate(in vec2 v, float r)\n{\n\tfloat s = sin(r), c = cos(r);\n    \treturn vec2(v.x * c - v.y * s, v.x * s + v.y * c);\n}\n                \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.y;\n\tfloat aspect = iResolution.x \/ iResolution.y;\n\n#if POST_PROCESS != 0    \n    float disto = hash11(uv.y\/100000. + iGlobalTime \/ 50.);\n    float distoamt = pow(hash11(iGlobalTime \/ 4200.), 10.);\n    disto = pow(disto, 100. - distoamt * 99.);\n    uv.x += disto * hash11(uv.y + iGlobalTime \/ 51.);\n#endif\n    \n    float ti = iGlobalTime \/ 24.;\n    vec3 pos = path(ti);\n    \n    vec3 look =  normalize(path(ti + .02) - path(ti - .02));\n    vec3 up =    normalize(vec3(0., look.y, 2.));\n\tvec3 right = normalize(cross(look, up));\n         look =  normalize(cross(up, right));\n\t\n\tconst float map_size = .2;\n    const vec2 map_pos = vec2(map_size + 0.01);\n    \n    vec2 mapuv = uv - map_pos;\n    float mapr = length(mapuv) \/ map_size;\n        \n    vec3 col;\n    \n    \/\/ paint map\n    if (mapr < 1.)\n    {\n        mapuv = mat2(vec2(look.y, -look.x), look.xy) * mapuv;\n        pos.z = path(0.).z; \/\/ avoid wandering through the map slice\n        col = kaliset(pos + 0.01 * vec3(mapuv \/ map_size, 0.));\n        col = max(col, vec3(0.5,1.,0.5) * smoothstep(0.9, 1., mapr));\n        col *= smoothstep(1., .95, mapr);\n    }\n    \/\/ render volume\n    else\n    {\n        uv -= vec2(aspect*.5, .5);\n        uv *= 2.;\n        \n        mat3 dirm = mat3(right, up, look);\n    \tvec3 dir = dirm * normalize(vec3(uv, 1.1));\n        col = trace(pos, dir);\n    }\n\t\n#if POST_PROCESS != 0\n    col = postproc(col,fragCoord);\n#endif\n    \n    fragColor = vec4(col, 1.);\n}","name":"","description":"","type":"image"}]}}