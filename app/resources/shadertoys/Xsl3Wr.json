{"Shader":{"ver":"0.1","info":{"id":"Xsl3Wr","date":"1368066334","viewed":1108,"name":"Logotype (Symbio)","username":"tsone","description":"Distance field is done with boxes, rings and subtracting planes. Distortion is caused by low ray steps, mirroring (X) distance field at when Z > 0, and doing traditional warping in xy-plane.","likes":13,"published":3,"flags":0,"tags":["text","logotype"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define ZNEAR        1.9\n#define ZFAR         2000.0\n#define STEP_MAX     6\n#define STEP_EPS\t 1.0\n#define NORMAL_EPS   1.0\n\n#define SX\t245.0\n#define YX\t168.0\n#define MX\t105.0\n#define BX\t-25.0\n#define IX\t-135.0\n#define OX\t-215.0\n\n\nfloat time = 0.5*iGlobalTime;\n\n\nfloat ring(in vec3 p, in vec2 r)\n{\n\treturn abs(length(p.xy)-r.x)-r.y;\n}\n\nfloat box(in vec3 p, in vec3 r)\n{\n\tvec3 d = abs(p)-r;\n\treturn max(d.x,d.y);\n}\n\nfloat sub(in float d1, in float d2)\n{\n\treturn max(d1,-d2);\n}\n\nmat3 rotz(in float a)\n{\n\tfloat ca = cos(a);\n\tfloat sa = sin(a);\n\treturn mat3(\n\t\tca,sa,0.0,\n\t\t-sa,ca,0.0,\n\t\t0.0,0.0,1.0\n\t);\n}\n\nmat3 rotx(in float a)\n{\n\tfloat ca = cos(a);\n\tfloat sa = sin(a);\n\treturn mat3(\n\t\t1.0,0.0,0.0,\n\t\t0.0,ca,-sa,\n\t\t0.0,sa,ca\n\t);\n}\n\nmat3 roty(in float a)\n{\n\tfloat ca = cos(a);\n\tfloat sa = sin(a);\n\treturn mat3(\n\t\tca,0.0,sa,\n\t\t0.0,1.0,0.0,\n\t\t-sa,0.0,ca\n\t);\n}\n\nfloat func(in vec3 p)\n{\n\tfloat ax = 0.3*sin(time);\n\tfloat ay = time;\/\/0.3*sin(5.0*time);\n\tif (iMouse.z > 0.5)\n\t{\n\t\tay = 3.14*(0.5-iMouse.x\/iResolution.x);\n\t\tax = 3.14*(-0.5+iMouse.y\/iResolution.y);\n\t}\n\tmat3 m = rotx(ax)*roty(ay);\n\tp = m*(p-vec3(0.0,0.0,350.0))*vec3(1.0,1.3,1.0);\n\tfloat d = ZFAR;\n\tfloat t;\n\tvec3 c;\n\t\n\t\/\/ Traditional warping.\n\tp.xy += (5.0-5.0*cos(1.0*time))\n\t\t*sin(0.04*p.yx+4.0*time);\n\t\n\t\/\/ Interesting trick. Flip X when Z > 0...?\n\tif (p.z > 0.0)\n\t{\n\t\tp.z = -p.z;\n\t\tp.x = -p.x;\n\t}\n\t\n\t\/\/ s\n\tc = p+vec3(SX,0.0,0.0);\n\t\n\tc = rotz(0.45)*c;\n\tt = ring(c+vec3(0.0,-22.0,0.0),vec2(22.0,10.0));\n\tt = sub(t,-c.x+1.0);\n\tt = sub(t,-p.x-SX+17.0);\n\td = min(d,t);\n\n\tt = ring(c+vec3(0.0,22.0,0.0),vec2(22.0,10.0));\n\tt = sub(t,(c.x+1.0));\n\tt = sub(t, p.x+SX+17.5);\n\td = min(d,t);\n\n\t\n\t\/\/ y\n\tc = p+vec3(YX,20.0,0.0);\n\t\n\tc = c*rotz(-0.35);\n\tt = box(c,vec3(10.0,100.0,10.0));\n\td = min(d,t);\n\n\tc = c*rotz(2.0*0.35);\n\tc += vec3(8.0,-45.0,0.0);\n\tt = box(c,vec3(10.0,50.0,10.0));\n\td = min(d,t);\n\t\n\t\/\/ this clips s & y\n\td = sub(d,-p.y+54.0);\n\td = sub(d,p.y+100.0);\n\n\n\t\/\/ m\n\tfloat mbd;\n\tc = p+vec3(MX,-10.0,0.0);\n\tmbd = box(c,vec3(10.0,54.0+10.0,10.0));\n\t\n\tc += vec3(-44.0,26.0,0.0);\n\tt = box(c,vec3(10.0,54.0-16.0,10.0));\n\tmbd = min(mbd,t);\n\n\tc += vec3(-44.0,0.0,0.0);\n\tt = box(c,vec3(10.0,54.0-16.0,10.0));\n\tmbd = min(mbd,t);\n\n\tc += vec3(22.0,-35.0,0.0);\n\tt = ring(c,vec2(22.0,10.0));\n\tc += vec3(44.0,0.0,0.0);\n\tt = min(t,ring(c,vec2(22.0,10.0)));\n\tt = sub(t,c.y);\n\tmbd = min(mbd,t);\n\n\n\t\/\/ b\n\tc = p+vec3(BX,-45.0,0.0);\n\tt = box(c, vec3(10.0,80.0,10.0));\n\tmbd = min(mbd,t);\n\n\tc += vec3(-30.0,45.0,0.0);\n\tt = ring(c, vec2(44.0,10.0));\n\tt = sub(t,c.x+40.0);\n\tmbd = min(mbd,t);\n\n\t\/\/ clip m & b\n\tfloat g = -0.34;\n\tfloat x = cos(g);\n\tfloat y = sin(g);\n\tmbd = sub(mbd,88.0+dot(p,-vec3(y,x,0.0)));\n\td = min(d,mbd);\n\n\n\t\/\/ i\n\tc = p+vec3(IX,-10.0,0.0);\n\tt = box(c,vec3(10.0,64.0,10.0));\n\tt = sub(t,5.0+dot(p,-vec3(y,x,0.0)));\n\td = min(d,t);\n\n\tc += vec3(0.0,-77.0,0.0);\n\tt = ring(c,vec2(5.0,10.0));\n\td = min(d,t);\n\t\n\n\t\/\/ o\n\tc = p+vec3(OX,0.0,0.0);\n\tt = ring(c,vec2(44.0,10.0));\n\td = min(d,t);\n\t\n\t\/\/ limit z\n\td = max(d,abs(p.z)-20.0);\n\n\treturn d;\n}\n\n\/\/ Normal calculation modified from one by PauloFalcao:\n\/\/ https:\/\/www.shadertoy.com\/view\/MsX3zr\nvec3 normal(in vec3 p)\n{\n\tconst float eps = NORMAL_EPS;\n\tfloat v1 = func(p+vec3( NORMAL_EPS,-NORMAL_EPS,-NORMAL_EPS));\n\tfloat v2 = func(p+vec3(-NORMAL_EPS,-NORMAL_EPS, NORMAL_EPS));\n\tfloat v3 = func(p+vec3(-NORMAL_EPS, NORMAL_EPS,-NORMAL_EPS));\n\tfloat v4 = func(p+vec3( NORMAL_EPS, NORMAL_EPS, NORMAL_EPS));\n\treturn normalize(v4+vec3(v1-v3-v2,v3-v1-v2,v2-v3-v1));\n}\n\nvec4 loop(in vec3 p, in vec3 dir, out int steps)\n{\n\tfloat totald = 0.0;\n\tsteps = 0;\n\tfor (int i=0; i < STEP_MAX; i++)\n\t{\n\t\tfloat stepd = func(p);\n\t\tif (stepd < STEP_EPS)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tp += stepd*dir;\n\t\ttotald += stepd;\n\t\tsteps++;\n\t}\n\treturn vec4(p,totald);\n}\n\nvec4 trace(out int steps, vec2 fragCoord)\n{\n\tfloat s = min(iResolution.x,iResolution.y);\n\tvec3 p = vec3((2.0*fragCoord.xy-iResolution.xy)\/s,ZNEAR);\n\tvec3 dir = normalize(p);\n\tvec4 pd = loop(p,dir,steps);\n\treturn pd;\n}\n\nvec4 shade(in vec4 pd, in int steps)\n{\n\tvec3 n = normal(pd.xyz);\n\tvec3 ldir = normalize(vec3(sin(time),1.0,cos(time)));\n\t\/\/vec3 ldir = normalize(vec3(1.0,1.0,-1.0));\n\tfloat ndotl = max(dot(n,ldir),0.0);\n\tfloat diff = 0.6*ndotl;\n\tfloat amb = 0.6*(ZFAR-pd.w)\/(ZFAR-ZNEAR);\n\tfloat what = dot(n,reflect(n,ldir));\n\tfloat tot = diff+amb+what;\n\tvec4 col = mix(\n\t\tvec4(1.0),\n\t\tvec4(1.0,0.55,0.0,1.0),\n\t\tfloat(steps-1)\/float(STEP_MAX-1)\n\t);\n\treturn tot*col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tint steps;\n\tvec4 pd = trace(steps,fragCoord);\n\tvec4 c = shade(pd,steps);\n\tfragColor = vec4(c.rgb,1.0);\n}","name":"","description":"","type":"image"}]}}