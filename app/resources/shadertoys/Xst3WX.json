{"Shader":{"ver":"0.1","info":{"id":"Xst3WX","date":"1452512152","viewed":163,"name":"Everyday011 - Rush","username":"Makio64","description":"Everyday011 - Rush - First try of FXAA as postprocess in Shadertoy, so far, so good <img src=\"\/img\/emoticonHappy.png\"\/>","likes":6,"published":3,"flags":32,"tags":["tunnel","yellow","fxaa","everyday","rush"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Everyday011 - Rush\n\/\/ By David Ronai \/ @Makio64\n\n\/\/ Check BufferA\n\/\/ FXAA from https:\/\/github.com\/mattdesl\/glsl-fxaa\n\n#define FXAA_REDUCE_MIN   (1.0\/ 128.0)\n#define FXAA_REDUCE_MUL   (1.0 \/ 8.0)\n#define FXAA_SPAN_MAX     16.0\n\nvoid texcoords(vec2 fragCoord, vec2 resolution,\n\t\t\tout vec2 v_rgbNW, out vec2 v_rgbNE,\n\t\t\tout vec2 v_rgbSW, out vec2 v_rgbSE,\n\t\t\tout vec2 v_rgbM) {\n\tvec2 inverseVP = 1.0 \/ resolution.xy;\n\tv_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n\tv_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n\tv_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n\tv_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n\tv_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\n            vec2 v_rgbNW, vec2 v_rgbNE, \n            vec2 v_rgbSW, vec2 v_rgbSE, \n            vec2 v_rgbM) {\n    vec4 color;\n    mediump vec2 inverseVP = vec2(1.0 \/ resolution.x, 1.0 \/ resolution.y);\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n    float rcpDirMin = 1.0 \/ (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n              dir * rcpDirMin)) * inverseVP;\n    vec3 rgbA = 0.5 * (\n        texture2D(tex, fragCoord * inverseVP + dir * (1.0 \/ 3.0 - 0.5)).xyz +\n        texture2D(tex, fragCoord * inverseVP + dir * (2.0 \/ 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n        texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mediump vec2 v_rgbNW;\n\tmediump vec2 v_rgbNE;\n\tmediump vec2 v_rgbSW;\n\tmediump vec2 v_rgbSE;\n\tmediump vec2 v_rgbM;\n\ttexcoords(fragCoord, iResolution.xy, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n    fragColor = fxaa( iChannel0, fragCoord, iResolution.xy, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);   \n}","name":"","description":"","type":"image"},{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Everyday011 - RUSH\n\/\/ By David Ronai \/ @Makio64\n\n\/\/------------------------------------------------------------------ VISUAL QUALITY\n#define POSTPROCESS\n#define RAYMARCHING_STEP 30\n#define RAYMARCHING_JUMP 1.\n\/\/------------------------------------------------------------------ DEBUG\n\/\/#define RENDER_DEPTH\n\/\/#define RENDER_NORMAL\n\/\/#define RENDER_AO\n\n#define SPEED 16.0\n\n\nconst float PI = 3.14159265359;\n\n\/\/------------------------------------------------------------------  OPERATIONS \/ PRIMITIVES\n\/\/http:\/\/mercury.sexy\/hg_sdf\/\nvoid pR(inout vec2 p, float a) {p = cos(a)*p + sin(a)*vec2(p.y, -p.x);}\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)\/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI\/repetitions;\n\tfloat a = atan(p.y, p.x) + angle\/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a\/angle);\n\ta = mod(a,angle) - angle\/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\tif (abs(c) >= (repetitions\/2.)) c = abs(c);\n\treturn c;\n}\n\n\/\/------------------------------------------------------------------ MAP\nfloat map( in vec3 pos ) {\n    pos.z +=5.;\n    \/\/pR(pos.xy,iGlobalTime\/10.);\n    float idx = pMod1(pos.z,10.4715);\n    vec3 q = pos;\n    pModPolar(q.xy,floor(2.+abs(sin(idx))*10.));\n    q.x -= 19.;\n    float f = smoothstep(-.8,.8,sin(idx*3.+iGlobalTime*2.));\n    f *= .8+.4*abs(sin(iGlobalTime));\n    float d = fSphere(q,f);\n    pR(pos.zy,PI\/2.);\n    d = fOpUnionRound(d,-fCylinder(pos,20.,30.),2.*f);\n    q.x += 2.*f;\n    d = max(-fSphere(q,3.5*f),d);\n    d = min(d,fSphere(q,1.*f));\n    return d;\n}\n\n\/\/------------------------------------------------------------------ RAYMARCHING\n#ifdef RENDER_DEPTH\nfloat castRay( in vec3 ro, in vec3 rd, inout float depth )\n#else\nfloat castRay( in vec3 ro, in vec3 rd )\n#endif\n{\n\tfloat t = 0.0;\n\tfloat res;\n\tfor( int i=0; i<RAYMARCHING_STEP; i++ )\n\t{\n\t\tvec3 pos = ro+rd*t;\n\t\tres = map( pos );\n\t\tif( res < 0.01 || t > 150. ) break;\n\t\tt += res*RAYMARCHING_JUMP;\n\t\t#ifdef RENDER_DEPTH\n\t\tdepth += 1.\/float(RAYMARCHING_STEP);\n\t\t#endif\n\t}\n\treturn t;\n}\n\nvec3 calcNormal(vec3 p) {\n\tfloat eps = 0.0001;\n\tconst vec3 v1 = vec3( 1.0,-1.0,-1.0);\n\tconst vec3 v2 = vec3(-1.0,-1.0, 1.0);\n\tconst vec3 v3 = vec3(-1.0, 1.0,-1.0);\n\tconst vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\treturn normalize( v1 * map( p + v1*eps ) +\n\t\t\t\t\t  v2 * map( p + v2*eps ) +\n\t\t\t\t\t  v3 * map( p + v3*eps ) +\n\t\t\t\t\t  v4 * map( p + v4*eps ) );\n}\n\nfloat hash( float n ){\n\treturn fract(sin(n)*3538.5453);\n}\n\nfloat calcAO( in vec3 p, in vec3 n, float maxDist, float falloff ){\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = n*l;\n\t\tao += (l - map( p + rd )) \/ pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao\/float(nbIte), 0., 1.);\n}\n\nfloat thickness( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = -n*l;\n\t\tao += (l + map( p + rd )) \/ pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao\/float(nbIte), 0., 1.);\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv )\n{\n\tvec3 col = vec3(.0,.0,1.2);\n\n\t#ifdef RENDER_DEPTH\n\tfloat depth = 0.;\n\tfloat t = castRay(ro,rd,depth);\n\t#else\n\tfloat t = castRay(ro,rd);\n\t#endif\n\n\t#ifdef RENDER_DEPTH\n\treturn vec3(depth\/10.,depth\/5.,depth);\n\t#endif\n\n\tvec3 pos = ro + t * rd;\n\tvec3 nor = calcNormal(pos);\n\n\t#ifdef RENDER_NORMAL\n\treturn nor;\n\t#endif\n\n\tfloat ao = calcAO(pos,nor,10.,1.2);\n\t#ifdef RENDER_AO\n\treturn vec3(ao);\n\t#endif\n\n    float thi = thickness(pos, nor, 4., 2.5);\n    col = vec3(.1);\n    col += vec3(.8,.8,.0)*smoothstep(-0.02,.02,sin(pos.z*.3));\n    col += max(0.,dot(nor,vec3(.2,.5,.0)));\n    col += max(0.,dot(nor,vec3(-.4,-.5,.0)));\n    col += reflect(1.,dot(nor,vec3(-.1,-.7,.0)))*-.2;\n    float d = distance(pos.xyz,vec3(0.));\n\tcol = max(vec3(.05),col);\n\tcol *= ao*thi*1.2;\n\tcol = mix(col, vec3(0.), smoothstep(0.,150.,t));\n\treturn col;\n}\n\n\/\/------------------------------------------------------------------ CAMERA\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\treturn mat3( cu, cv, cw );\n}\n\nvec3 orbit(float phi, float theta, float radius)\n{\n\treturn vec3(\n\t\tradius * sin( phi ) * cos( theta ),\n\t\tradius * cos( phi ),\n\t\tradius * sin( phi ) * sin( theta )\n\t);\n}\n\n\/\/------------------------------------------------------------------ POSTEFFECTS\n\n#ifdef POSTPROCESS\nvec3 postEffects( in vec3 col, in vec2 uv, in float time )\n{\n\t\/\/ vigneting\n\tcol += 1.-(0.9+0.1*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.6 ));\n\tcol *= 0.5+0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n\treturn col;\n}\n#endif\n\n\/\/------------------------------------------------------------------ MAIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec2 p = -1. + 2. * uv;\n    p.x *= iResolution.x \/ iResolution.y;\n    \n    \/\/Camera\n\tfloat radius = 50.;\n\tvec3 ro = orbit(PI\/2.,PI\/2.,radius);\n    ro.z -= SPEED*iGlobalTime;\n\tvec3 ta = vec3(0.);\n    ta.z -= SPEED*iGlobalTime;\n\tmat3 ca = setCamera( ro, ta, 0. );\n\tvec3 rd = ca * normalize( vec3(p.xy,1.2) );\n\n\t\/\/ Raymarching\n\tvec3 color = render( ro, rd, uv );\n\t#ifdef POSTPROCESS\n\tcolor = postEffects( color, uv, iGlobalTime );\n\t#endif\n\tfragColor = vec4(color,1.0);\n}","name":"","description":"","type":"buffer"}]}}