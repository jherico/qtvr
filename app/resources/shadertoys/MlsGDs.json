{"Shader":{"ver":"0.1","info":{"id":"MlsGDS","date":"1424997405","viewed":815,"name":"Water3D","username":"heyx3","description":"Raymarched water.","likes":2,"published":3,"flags":0,"tags":["3d","noise","water"],"hasliked":0},"renderpass":[{"inputs":[{"id":7,"src":"\/presets\/tex06.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define WATER_HEIGHT 7.0\n#define CAM_HEIGHT_MIN 8.0\n#define CAM_HEIGHT_MAX 12.0\n\n#define MARCH_ITERATIONS 250\n\n#define MARCH_STEP_DIST 0.02\n#define MARCH_STEP_DIST_INCREMENT 0.00075\n\n\/\/Fog stuff.\n#define MARCH_MAX_DIST 25.0\n#define FOG_DROPOFF_EXPONENT 1.0\n\n\/\/Used for computing normals.\n#define HEIGHTMAP_EPSILON 0.005\n \n#define FOG_COLOR vec3(0.6)\n#define WATER_COLOR vec3(0.1, 0.2, 1.0)\n\nvec3 LIGHT_DIR = normalize(vec3(-1.0, -1.0, -1.0));\n#define AMBIENT_LIGHT 0.6\n#define DIFFUSE_LIGHT (1.0 - AMBIENT_LIGHT)\n#define SPECULAR_LIGHT 0.5\n#define SPECULAR_INTENSITY 4.0\n\n#define FLOOR_DEPTH -6.0\n#define FLOOR_TEX_SCALE 0.08\n\n#define WATER_TRANSPARENCY 0.65\n\n\n\n\/\/Returns noise from 0 to 1.\nfloat noiseBasic(float seed)\n{\n    return fract(sin(seed * -34.0514) * 707.13618);\n}\n\n\/\/Returns a randomized, normalized gradient vector that shifts over time.\nvec2 noiseGradient(vec2 seed, float timeScale)\n{\n    float noise1 = noiseBasic(seed.x * seed.y);\n    vec2 noised = vec2(noise1, noiseBasic(noise1));\n    \n    \/\/Change the noise based on elapsed time.\n    \/\/The first few seconds of water look weird, so skip them.\n    float time = iGlobalTime + 2.0;\n    return sin(timeScale * time * noised);\n}\n\n\n\/\/Returns smooth Perlin noise shifting over time.\nfloat noiseSmooth(vec2 seedPos, vec2 gridInterval, float timeScale)\n{\n    seedPos *= gridInterval;\n    \n    vec2 fracPart = fract(seedPos),\n         lessPos = floor(seedPos),\n         morePos = ceil(seedPos);\n         \n    \n    vec2 minXMaxY = vec2(lessPos.x, morePos.y),\n         maxXMinY = vec2(morePos.x, lessPos.y);\n    \n    vec2 minXYGradient = noiseGradient(lessPos, timeScale),\n         maxXYGradient = noiseGradient(morePos, timeScale),\n         minXMaxYGradient = noiseGradient(minXMaxY, timeScale),\n         maxXMinYGradient = noiseGradient(maxXMinY, timeScale);\n    \n    float minXYDot = dot(minXYGradient, seedPos - lessPos),\n          maxXYDot = dot(maxXYGradient, seedPos - morePos),\n          minXMaxYDot = dot(minXMaxYGradient, seedPos - minXMaxY),\n          maxXMinYDot = dot(maxXMinYGradient, seedPos - maxXMinY);\n    \n    float val = mix(mix(minXYDot, maxXMinYDot,\n                        smoothstep(0.0, 1.0, fracPart.x)),\n                    mix(minXMaxYDot, maxXYDot,\n                        smoothstep(0.0, 1.0, fracPart.x)),\n                    smoothstep(0.0, 1.0, fracPart.y));\n    return smoothstep(0.0, 1.0, 0.5 + (0.5 * val));\n}\n\nfloat getHeightmap(vec2 inPos)\n{\n    float noise = 0.0;\n    \n#define ADD_INTERVAL(weight, offset, \t\t     scale, \t timeScale) noise += weight * noiseSmooth(inPos + offset, scale, timeScale);\n    ADD_INTERVAL(\t 1.0,    vec2(0.0, 0.0),   \t vec2(0.025), 1.5)\n    ADD_INTERVAL(\t 0.016,    vec2(9.1, -5.2611), vec2(0.5),  5.0)\n    ADD_INTERVAL(    0.005,   vec2(-5.51, 0.1812),vec2(2.5),  12.0)\n        \n    return noise * WATER_HEIGHT;\n}\n\nvec3 getHeightmapNormal(vec2 inPos)\n{\n    vec3 pos = vec3(inPos, getHeightmap(inPos));\n    vec2 moreX_2 = vec2(inPos.x + HEIGHTMAP_EPSILON, inPos.y),\n         moreY_2 = vec2(inPos.x, inPos.y + HEIGHTMAP_EPSILON);\n    vec3 moreX = vec3(moreX_2, getHeightmap(moreX_2));\n    vec3 moreY = vec3(moreY_2, getHeightmap(moreY_2));\n    \n    return cross(normalize(moreY - pos),\n                 normalize(moreX - pos));\n}\n\nstruct HitData\n{\n    vec3 pos;\n    float dist;\n};\nHitData marchRay(vec3 startPos, vec3 dir)\n{\n    HitData hitDat;\n    hitDat.pos = startPos;\n    hitDat.dist = 0.0;\n    \n    float distStep = MARCH_STEP_DIST;\n    \n    for (int i = 0; i < MARCH_ITERATIONS; ++i)\n    {\n        float height = getHeightmap(hitDat.pos.xy);\n        if (height >= hitDat.pos.z)\n        {\n            break;\n        }\n        \n        hitDat.pos += dir * distStep;\n        hitDat.dist += distStep;\n        \n        distStep += MARCH_STEP_DIST_INCREMENT;\n    }\n    \n    return hitDat;\n}\n\n\nfloat getBrightness(vec3 camPos, vec3 surfacePos, vec3 surfaceNormal)\n{\n    float dotted = max(dot(surfaceNormal, LIGHT_DIR), 0.0);\n    \n    vec3 fragToEye = normalize(camPos - surfacePos);\n    vec3 lightReflect = normalize(reflect(LIGHT_DIR, surfaceNormal));\n    \n    float specFactor = max(0.0, dot(fragToEye, lightReflect));\n    specFactor = pow(specFactor, SPECULAR_INTENSITY);\n    \n    return AMBIENT_LIGHT + (dotted * DIFFUSE_LIGHT) +\n           (specFactor * SPECULAR_LIGHT);\n}\n\n\n\/\/Gets the color of the floor below the water.\nvec3 getWaterRefractColor(vec3 rayDir, vec3 waterPos, vec3 waterSurfaceNormal)\n{\n    \/\/Refract the ray downward.\n\trayDir = -normalize(refract(rayDir, waterSurfaceNormal, 1.0 \/ 1.333));\n    \n    \/\/Trace downwards until the floor is hit.\n    float t = (FLOOR_DEPTH - waterPos.z) \/ rayDir.z;\n    vec2 horizontalPos = waterPos.xy + (t * rayDir.xy);\n    \n    \/\/Sample the texture at that floor.\n    return texture2D(iChannel0, horizontalPos * FLOOR_TEX_SCALE).xyz;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n\n    \n    \/\/Compute the camera positioning stuff.\n    vec3 camPos = vec3(0.0);\n\tcamPos.xy += iGlobalTime * 2.0;\n    camPos.z = mix(CAM_HEIGHT_MIN, CAM_HEIGHT_MAX,\n                   0.5 + (0.5 * sin(iGlobalTime * 0.5)));\n    vec3 camForward = normalize(vec3(cos(0.005 * iMouse.x),\n                                     sin(0.005 * iMouse.x),\n                                     -0.5));\n    vec3 camUpwards = vec3(0.0, 0.0, 1.0);\n    vec3 camSideways = cross(camForward, camUpwards);\n    camUpwards = -cross(camForward, camSideways);\n    \n    \/\/Compute the ray-march data.\n    const float camToViewPlaneDist = 1.0;\n    vec2 uvRemapped = (-1.0 + (2.0 * uv));\n    vec3 rayStart = camPos + (camForward * camToViewPlaneDist);\n    rayStart += (uvRemapped.x * camSideways) +\n                (uvRemapped.y * camUpwards * iResolution.y \/ iResolution.x);\n    vec3 rayDir = normalize(rayStart - camPos);\n\n    \/\/March the ray forward until the heightmap is hit.\n    HitData waterHit = marchRay(rayStart, rayDir);\n    vec3 normal = getHeightmapNormal(waterHit.pos.xy);\n\n    \/\/Compute the water surface's brightness.\n    float brightness = getBrightness(camPos, waterHit.pos, normal);\n    \n    \/\/Compute the color of the water surface.\n    vec3 waterColor = mix(WATER_COLOR,\n                          getWaterRefractColor(rayDir, waterHit.pos, normal),\n                          WATER_TRANSPARENCY);\n    waterColor *= brightness;\n\t\n    \n    \/\/Mix in some fog.\n    vec3 final = mix(waterColor,\n                     FOG_COLOR,\n                     clamp(0.0, 1.0,\n                           pow(waterHit.dist \/ MARCH_MAX_DIST,\n                         \t   FOG_DROPOFF_EXPONENT)));\n    \n    \/\/Output the final color.\n    fragColor = vec4(final, 1.0);\n    \n    \n    \/\/Below are some debug shader outputs\n    \/\/   that were used for testing various things.\n    \n    \/\/uv *= 5.0;\n    \n    \/\/float noise = getHeightmap(uv);\n    \/\/fragColor = vec4(noise, noise, noise, 1.0);\n    \n    \/\/vec3 norm = getHeightmapNormal(uv);\n    \/\/fragColor = vec4(0.5 + (0.5 * -norm), 1.0);\n    \n    \/\/vec3 refrct = getWaterRefractColor(rayDir, waterHit.pos, normal);\n    \/\/fragColor = vec4(refrct, 1.0);\n}","name":"","description":"","type":"image"}]}}