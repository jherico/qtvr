{"Shader":{"ver":"0.1","info":{"id":"4dSGW1","date":"1386732267","viewed":11833,"name":"Grid of Cylinders","username":"iq","description":"Using a 2D regular grid as acceleration structure for raytracing (an infinite amount of) cylinders. I trace across the 2D grid and then intersect the cylinder inside each cell. When the first intersection is found, the tracing can stop.","likes":99,"published":3,"flags":1,"tags":["procedural","3d","raytracing","grid","cylinder","regulargrid","vr"],"hasliked":0},"renderpass":[{"inputs":[{"id":2,"src":"\/presets\/tex01.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":6,"src":"\/presets\/tex05.jpg","ctype":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":17,"src":"\/presets\/tex12.png","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\/\/ Try 4, 15, 30 samples if yo have a powerful machine\n\n#define VIS_SAMPLES 1\n\n\nfloat hash1( float n ) { return fract(43758.5453123*sin(n)); }\nfloat hash1( vec2  n ) { return fract(43758.5453123*sin(dot(n,vec2(1.0,113.0)))); }\nvec2  hash2( float n ) { return fract(43758.5453123*sin(vec2(n,n+1.0))); }\n\nfloat gAnimTime;\nfloat map( vec2 p ) \n{\n\tfloat f = texture2D( iChannel0, p\/iChannelResolution[0].xy, -100.0 ).x;\n\t\n\tf *= sqrt( texture2D( iChannel2, (0.03*p + 2.0*gAnimTime)\/256.0 ).x );\n\treturn 22.0*f;\n}\n\nvec3 calcNormal( in vec3 pos, in float ic )\n{\n\treturn mix( normalize(vec3(pos.x,0.0,pos.z)), vec3(0.0,1.0,0.0), ic );\n}\n\nvec4 castRay( in vec3 ro, in vec3 rd )\n{\n\tvec2 pos = floor(ro.xz);\n\tvec2 ri = 1.0\/rd.xz;\n\tvec2 rs = sign(rd.xz);\n\tvec2 ris = ri*rs;\n\tvec2 dis = (pos-ro.xz+ 0.5 + rs*0.5) * ri;\n\t\n\tvec4 res = vec4( -1.0, 0.0, 0.0, 0.0 );\n\n    \/\/ traverse regular grid (in 2D)\n\tvec2 mm = vec2(0.0);\n\tfor( int i=0; i<200; i++ ) \n\t{\n\n\t\tfloat ma = map(pos);\n\t\t\n        \/\/ intersect capped cylinder\t\t\n\t\tvec3  ce = vec3( pos.x+0.5, 0.0, pos.y+0.5 );\n\t\tvec3  rc = ro - ce;\n\t\tfloat a = dot( rd.xz, rd.xz );\n\t\tfloat b = dot( rc.xz, rd.xz );\n\t\tfloat c = dot( rc.xz, rc.xz ) - 0.249;\n\t\tfloat h = b*b - a*c;\n\t\tif( h>=0.0 )\n\t\t{\n            \/\/ cylinder\t\t\t\n\t\t\tfloat s = (-b - sqrt( h ))\/a;\n\t\t\tif( s>0.0 && (ro.y+s*rd.y)<ma )\n\t\t\t{\n\t\t\t\tres = vec4( s, 0.0, pos );\n    \t\t\tbreak; \n\t\t\t}\n            \/\/ cap\t\t\t\n\t\t\ts = (ma - ro.y)\/rd.y;\n\t\t\tif( s>0.0 && (s*s*a+2.0*s*b+c)<0.0 )\n\t\t\t{\n\t\t\t\tres = vec4( s, 1.0, pos );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n        \/\/ step to next cell\t\t\n\t\tmm = step( dis.xy, dis.yx ); \n\t\tdis += mm*ris;\n        pos += mm*rs;\n\t}\n\n\n\treturn res;\n}\n\nfloat castShadowRay( in vec3 ro, in vec3 rd )\n{\n\tvec2 pos = floor(ro.xz);\n\tvec2 ri = 1.0\/rd.xz;\n\tvec2 rs = sign(rd.xz);\n\tvec2 ris = ri*rs;\n\tvec2 dis = (pos-ro.xz+ 0.5 + rs*0.5) * ri;\n\tfloat t = -1.0;\n\tfloat res = 1.0;\n\t\n    \/\/ first step we check noching\t\n\tvec2 mm = step( dis.xy, dis.yx ); \n\tdis += mm * ris;\n    pos += mm * rs;\n\t\n    \/\/ traverse regular grid (2D)\t\n\tfor( int i=0; i<16; i++ ) \n\t{\n\t\tfloat ma = map(pos);\n\t\t\n        \/\/ test capped cylinder\t\t\n\t\tvec3  ce = vec3( pos.x+0.5, 0.0, pos.y+0.5 );\n\t\tvec3  rc = ro - ce;\n\t\tfloat a = dot( rd.xz, rd.xz );\n\t\tfloat b = dot( rc.xz, rd.xz );\n\t\tfloat c = dot( rc.xz, rc.xz ) - 0.249;\n\t\tfloat h = b*b - a*c;\n\t\tif( h>=0.0 )\n\t\t{\n\t\t\tfloat t = (-b - sqrt( h ))\/a;\n\t\t\tif( (ro.y+t*rd.y)<ma )\n\t\t\t{\n\t\t\t\tres = 0.0;\n    \t\t\tbreak; \n\t\t\t}\n\t\t}\n\t\tmm = step( dis.xy, dis.yx ); \n\t\tdis += mm * ris;\n        pos += mm * rs;\n\t}\n\n\treturn res;\n}\n\nvec3 cameraPath( float t )\n{\n    \/\/ procedural path\t\n    vec2 p  = 200.0*sin( 0.01*t*vec2(1.2,1.0) + vec2(0.1,0.9) );\n\t     p += 100.0*sin( 0.02*t*vec2(1.1,1.3) + vec2(1.0,4.5) );\n\tfloat y = 15.0 + 4.0*sin(0.05*t);\n\t\n\t\/\/ collision\n\tfloat h;\n\th  = map( p+vec2(-1.0, 0.0) );\n\th += map( p+vec2( 1.0, 0.0) );\n\th += map( p+vec2( 0.0, 1.0) );\n\th += map( p+vec2( 0.0,-1.0) );\n\th \/= 4.0;\n\th += 5.0;\n\ty = max( y, h );\n\n\treturn vec3( p.x, y, p.y );\n}\n\nvec4 texcyl( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec4 x = texture2D( sam, vec2(p.y,0.5+0.5*atan(n.x,n.z)\/3.14) );\n\tvec4 y = texture2D( sam, p.xz );\n\treturn mix( x, y, abs(n.y) );\n}\n\nvec3 desat( in vec3 col, float a )\n{\n    return mix( col, vec3(dot(col,vec3(0.333))), a );\n}\n\nvec3 lig = normalize(vec3(-0.7,0.25,0.6));\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n        \/\/ background color\t\n\t\tfloat sun = clamp( dot( rd, lig ), 0.0, 1.0 );\n\n\t\tvec3 bgcol = vec3(0.9,0.9,0.8) + 0.3*pow(sun,4.0)*vec3(1.0,1.0,0.0);\n\n        \/\/ raytrace\n        vec3 col = bgcol;\n\t\tvec4 res = castRay( ro, rd );\n        vec2 vos = res.zw;\n        float t = res.x;\n        if( t>0.0 )\n        {\n            vec3  pos = ro + rd*t;\n\t\t\tfloat id  = hash1( vos );\n\t\t\tvec3  nor = calcNormal( fract(pos)-0.5, res.y );\n\t\t\tfloat h = map(vos);\n\n            \/\/ material color\t\t\t\n\t\t\tvec3 mate1 = 0.5 + 0.45*sin( 3.14*id + 0.8 + vec3(0.0,0.5,1.0) );\n\t\t\tvec3 mate2 = 0.5 + 0.45*sin( 6.28*id + vec3(0.0,0.5,1.0) );\n\t\t\tvec3 mate = mix( mate1, mate2, smoothstep( 9.0, 11.0, h) );\n\t\t\t\n\t\t\tvec3 uvw = pos - vec3(0.0,h,0.0);\n\t\t\tvec3 tex = texcyl( iChannel3, 0.2*uvw + 13.1*hash1(id), nor ).xyz;\n\t\t\tmate *= 0.2+4.0*pow( desat(tex,0.3), vec3(2.0) );\n            mate *= 1.5*sqrt(texture2D( iChannel0, pos.xz\/iChannelResolution[0].xy ).xyz);\n            mate *= 0.02 + 0.98*smoothstep( 0.1,0.11, hash1(id) );\t\n\t\t\t\n            \/\/ material cheap\/wrong bump\t\t\t \n            vec3 bn = -1.0 + 2.0*texcyl( iChannel1, 0.2*uvw*vec3(1.0,0.2,1.0) + 13.1*hash1(id), nor ).xyz;\n            \/\/nor = normalize(nor + 0.45*bn*(1.0-0.5*nor.y) );\n\t\t\t\n\t\t\t\/\/ procedural occlusion\n\t\t\tfloat occ = nor.y*0.75;\n\t\t\tocc += 0.5*clamp( nor.x,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2( 1.0, 0.0)) );\n\t\t\tocc += 0.5*clamp(-nor.x,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2(-1.0, 0.0)) );\n\t\t\tocc += 0.5*clamp( nor.z,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2( 0.0, 1.0)) );\n\t\t\tocc += 0.5*clamp(-nor.z,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2( 0.0,-1.0)) );\n\t\t\tocc = 0.2 + 0.8*occ;\n\t\t\tocc *= pow( clamp((0.1+pos.y)\/(0.1+map(floor(pos.xz))),0.0,1.0),2.0);\n\t\t\tocc = occ*0.5+0.5*occ*occ;\n\t\t\tfloat rim = pow( clamp( 1.0+dot(rd,nor), 0.0, 1.0 ),5.0 );\n \n            \/\/-------------\n            \/\/ lighitng\n            \/\/-------------\n\t\t\tfloat amb = 1.0;\n            \/\/-------------\n\t\t\tfloat bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z)) ), 0.0, 1.0 ) * clamp(1.0-pos.y\/20.0,0.0,1.0);;\n            \/\/-------------\n\t\t\tfloat sha = 0.0;\n\t\t\tfloat dif = dot( nor, lig );\n\t\t\tif( dif<0.0 ) dif=0.0; else sha = castShadowRay( pos, lig );\n            float spe = pow( clamp( dot(lig,reflect(rd,nor)), 0.0, 1.0 ),3.0 );\n            \/\/-------------\n\t\t\tvec3 lin  = 3.00*vec3(1.0,1.0,1.0)*0.7*sqrt(dif)*sha;\n\t\t\t     lin += 0.60*vec3(0.4,1.0,1.7)*amb*occ;\n\t\t\t     lin += 0.70*vec3(0.8,0.5,0.3)*bac*occ;\n\t\t\t\n\t\t\tcol = mate * lin + tex.x*1.5*vec3(1.0,1.0,1.0)*(0.3+0.7*rim)*spe*dif*sha;\n\n            \/\/ tone mapping\t\t\t\n\t\t\tcol *= 1.1 + 0.5*dot( rd, lig );\n\n            \/\/ fog\n            float ff = 1.0 - smoothstep( 0.0, 1.0, pow(t\/160.0,1.8) );\n\t\t\tcol = mix( col, bgcol, 1.0-ff );\n\t\t}\n\t\tcol += 0.2*pow(sun,8.0)*vec3(1.0,0.7,0.2);\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ inputs\t\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n\t\n    vec2 mo = iMouse.xy \/ iResolution.xy;\n    if( iMouse.w<=0.00001 ) mo=vec2(0.0);\n\t\n    gAnimTime = iGlobalTime;\n    \n\t\/\/ montecarlo\t\n\tvec3 tot = vec3(0.0);\n    #if VIS_SAMPLES<2\n\tint a = 0;\n\t{\n        vec2 p = -1.0 + 2.0*(fragCoord.xy) \/ iResolution.xy;\n        p.x *= iResolution.x\/ iResolution.y;\n        float time = 4.0*iGlobalTime + 50.0*mo.x;\n    #else\n\tfor( int a=0; a<VIS_SAMPLES; a++ )\n\t{\n\t\tvec4 rr = texture2D( iChannel1, (fragCoord.xy+floor(256.0*hash2(float(a))))\/iChannelResolution[1].xy );\n        vec2 p = -1.0 + 2.0*(fragCoord.xy+rr.xz) \/ iResolution.xy;\n        p.x *= iResolution.x\/ iResolution.y;\n\t\t#if VIS_SAMPLES>3\n        float time = 4.0*(iGlobalTime + 1.0*(0.4\/24.0)*rr.w) + 50.0*mo.x;\n\t\t#else\n        float time = 4.0*(iGlobalTime) + 50.0*mo.x;\n\t\t#endif\n    #endif\t\n\n\t\t\/\/ camera\n        vec3  ro = cameraPath( time );\n        vec3  ta = cameraPath( time+5.0 ); ta.y = ro.y - 5.5;\n        float cr = 0.2*cos(0.1*time*0.5);\n\t\n        \/\/ build ray\n        vec3 ww = normalize( ta - ro);\n        vec3 uu = normalize(cross( vec3(sin(cr),cos(cr),0.0), ww ));\n        vec3 vv = normalize(cross(ww,uu));\n        float r2 = p.x*p.x*0.32 + p.y*p.y;\n        p *= (7.0-sqrt(37.5-11.5*r2))\/(r2+1.0);\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n        \/\/ dof\n        #if VIS_SAMPLES>2\n        vec3 fp = ro + rd * 17.0;\n        ro += (uu*(-1.0+2.0*rr.y) + vv*(-1.0+2.0*rr.w))*0.035;\n        rd = normalize( fp - ro );\n        #endif\n\n\n        vec3 col = render( ro, rd );\n        \n\t\ttot += col;\n\t}\n\ttot \/= float(VIS_SAMPLES);\n\t\n\n\t\/\/ gamma\t\n\ttot = pow( clamp(tot,0.0,1.0), vec3(0.44) );\n\n\t\/\/ vignetting\t\n\ttot *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n\tfragColor = vec4( tot, 1.0 );\n}\n    \n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec3 cam = cameraPath( iGlobalTime );\n\n    gAnimTime = iGlobalTime*0.2;\n\n    vec3 ro = fragRayOri + cam + vec3(0.0,-2.0,0.0);\n    vec3 rd = fragRayDir*vec3(-1.0,1.0,-1.0);\n    vec3 col = render( ro, rd );\n\n    \/\/ gamma\t\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.44) );\n\n    fragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}