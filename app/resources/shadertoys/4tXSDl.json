{"Shader":{"ver":"0.1","info":{"id":"4tXSDl","date":"1440383322","viewed":777,"name":"Metaeaux - Metaballs","username":"metaeaux","description":"Creating metaballs with a polynomial smoothmin function","likes":2,"published":3,"flags":0,"tags":["raymarching","distancefields","smoothmin"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"const vec4 ambientColor = vec4(0.15, 0.2, 0.32, 1.0);\nconst vec4 skyColor = 0.3 * vec4(0.31, 0.47, 0.67, 1.0);\nconst float PI = 3.14159;\n\nfloat sphere(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat cube(vec3 p, vec3 size)\n{\n\tvec3 d = abs(p) - size;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(abs(p) - size, vec3(0.0)));\n}\n\nfloat cylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nvec3 repeat( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return q;\n}\n\nvec3 rotate(vec3 p, float theta)\n{\n    theta *= 2. * 3.14159;\n    mat3 ry = mat3(cos(theta), 0., sin(theta),\n                0., 1., 0.,\n                -sin(theta), 0., cos(theta));\n    return ry * p;\n}\n\nfloat smoothMin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)\/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sploosh(vec3 p, float sizeFac, float distFac) {\n    float d = sphere(p, .4);\n    const int n = 4;\n    float distX = 0.5 + 0.5 * sin(iGlobalTime);\n    float distY = 0.2 + 0.2 * sin(iGlobalTime);\n    float size = 0.2 + 0.1 * abs(cos(iGlobalTime));\n    vec3 q1 = p;\n    vec3 q2 = p;\n    vec3 q3 = p;\n    vec3 q4 = p;\n    \n    for (int i = 1; i < n; i++){\n        distX += distFac \/ float(i);\n        distY += distFac \/ float(i);\n        size -= sizeFac;\n        q1 += vec3(distX, distY, 0.);\n        q2 += vec3(-distX, distY, 0.);\n        q3 += vec3(distX, -distY, 0.);\n        q4 += vec3(-distX, -distY, 0.);\n    \tfloat d1 = sphere(q1, size);\n    \tfloat d2 = sphere(q2, size);\n    \tfloat d3 = sphere(q3, size);\n    \tfloat d4 = sphere(q4, size);\n    \tfloat blendDistance = 0.5;\n    \n    \td = smoothMin(d, smoothMin(d1, d2, blendDistance), blendDistance);\n        d = smoothMin(d, smoothMin(d3, d4, blendDistance), blendDistance);\n    }\n    \n    return d;\n}\n\nfloat distanceField(vec3 p) {\n    return sploosh(p, 0.01, .02);\n    \n    \n    float distX = 0.5 + 0.5 * sin(iGlobalTime);\n    float distY = 0.2 + 0.1 * sin(iGlobalTime);;\n    float size = 0.2 + 0.1 * abs(cos(iGlobalTime));\n    float d1 = sphere(p + vec3(distX, distY, 0.), size);\n    float d2 = sphere(p + vec3(.0, 0., 0.), .4);\n    float d3 = sphere(p + vec3(-distX, distY, 0.), size);\n    float d4 = sphere(p + vec3(distX, -distY, 0.), size);\n    float d5 = sphere(p + vec3(-distX, -distY, 0.), size);\n    float blendDistance = 0.1;\n    \n    float scene = smoothMin(d1, smoothMin(d2, d3, blendDistance), blendDistance);\n    scene = smoothMin(scene, smoothMin(d4, d5, blendDistance), blendDistance);\n    return scene;\n}\n\nvec3 getNormal(vec3 p)\n{\n\tfloat h = 0.0001;\n\n\treturn normalize(vec3(\n\t\tdistanceField(p + vec3(h, 0, 0)) - distanceField(p - vec3(h, 0, 0)),\n\t\tdistanceField(p + vec3(0, h, 0)) - distanceField(p - vec3(0, h, 0)),\n\t\tdistanceField(p + vec3(0, 0, h)) - distanceField(p - vec3(0, 0, h))));\n}\n\n\/\/ phong shading\nvec4 phong(vec3 p, vec3 normal, vec3 lightPos, vec4 lightColor)\n{\n\tfloat lightIntensity = 0.0;\n\tvec3 lightDirection = normalize(lightPos - p);\n    \n    \/\/ lambert shading\n\tlightIntensity = clamp(dot(normal, lightDirection), 0.0, 1.);\n    \n    \/\/ lambert shading\n    vec4 colour = lightColor * lightIntensity;\n    \n    \/\/ specular highlights\n    colour += pow(lightIntensity, 32.0) * (1.0 - lightIntensity*0.5);\n        \n    \/\/ ambient colour\n    colour += ambientColor * (1.0 - lightIntensity);\n    \n    \n\treturn colour;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float gridSize = 8.0;\n    float u = gl_FragCoord.x * gridSize \/ iResolution.x - gridSize \/ 2.;\n    float v = gl_FragCoord.y * gridSize \/ iResolution.y - gridSize \/ 2.;\n    float aspectRatio = iResolution.x \/ iResolution.y;\n    \n    \n    vec2 theta = 2. * 3.14159 * (iResolution.xy - iMouse.xy) \/ iResolution.xy;\n    \n    \/\/theta.x += iGlobalTime;\n    \n    vec3 camUp = vec3(0., 1., 0.);\n    vec3 camForward = vec3(sin(theta.x), 0., cos(theta.x));\n    vec3 camRight = cross(camForward, camUp); \/\/ vec3(1., 0., 0.);\n    float focalLength = 1.97;\n\n    vec3 ro = -vec3(sin(theta.x), 0., cos(theta.x)); \/\/vec3(0., 0., -1.);\n\tvec3 rd = normalize(camForward * focalLength + camRight * u * aspectRatio + camUp * v);\n    vec4 color = skyColor;\n\n    float t = 0.0;\n    const int maxSteps = 32;\n    for(int i = 0; i < maxSteps; ++i)\n    {\n        vec3 p = ro + rd * t;\n        float d = distanceField(p);\n        if(d < 0.002)\n        {\n            vec3 normal = getNormal(p);\n            color = phong(p, normal, vec3(2.0, 2.0, -2.0), vec4(1.0, 0.5, 0.5, 1.0));\n            \n            \/\/ fade to dark in the distance;\n            color *= pow(1. \/ t, 0.6);\n            \n            break;\n        }\n        \n        if(t > 100.)\n        {\n            break;\n        }\n\n        t += d;\n    }\n\n    fragColor = color;\n}","name":"","description":"","type":"image"}]}}