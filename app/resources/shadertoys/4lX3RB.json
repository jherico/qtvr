{"Shader":{"ver":"0.1","info":{"id":"4lX3RB","date":"1423568433","viewed":1512,"name":"kali-traps d","username":"bergi","description":"The kali-set - between round and hashy. <br\/>No other random function was hurt in the making of this film. ","likes":40,"published":3,"flags":0,"tags":["3d","raymarching","fractal","volume","kali","blackwhite","hybrid"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\n\/\/ \"kali-traps d\"\n\/\/ showing the different shape and scale relationships\n\/\/ between geographically different parts in the same parameter set\n\/\/ probably very float-accuracy dependent\n\/\/ in this case i'd say, less is more \n\n\/\/ License aGPLv3\n\/\/ 2015, stefan berke\n\n\nconst int NUM_TRACE = 40;\n\n\n\/\/ \"kali-set\" by Kali\nvec4 average;\nvec4 kali(in vec3 p)\n{\n    average = vec4(0.);\n\tfloat mag;\n    for (int i=0; i<31; ++i)\n    {\n        mag = dot(p, p);\n        p = abs(p) \/ mag;\n        average += vec4(p, mag);\n        p -= vec3(.5, .5, 1.1);\n    }\n\taverage \/= 31.;\n    mag = dot(p, p);\n    p = abs(p) \/ mag;\n    return vec4(p, mag);\n}\n\n\/\/ volume marcher with surface trap\nvec3 ray_color(vec3 pos, vec3 dir, float stp)\n{\n    vec3 p, col = vec3(0.);\n\tfloat t = 0., ld = 1.;\n\tfor (int i=0; i<NUM_TRACE; ++i)\n\t{\n\t\tp = pos + t * dir;\n\t\tvec4 k = kali(p);\n\n\t\tfloat pick = abs(k.x - .9);\n\t\tfloat mx = smoothstep(0.02, 0., abs(average.y-0.448));\n\t\tfloat bright = 1. \/ (1. + pick * (1.-0.9*mx) * 200.);\n\n        col += vec3(1., 1.-mx, 1.-mx) * bright;\n\n\t\tt += clamp(pick * stp, 0.00001, 0.0002);\n\t}\n    \n    return col \/ float(NUM_TRACE) * 5.;\n}\n\n\n\n\/\/ a few hand-picked turns\nvec3 path(float ti, float pid)\n{\n    vec3 pos = vec3(0.);\n    float id = mod(pid, 4.);\n    if (id < 1.)\n    {\n    \tti \/= 4.;\n    \tpos = vec3(12.966, 1.211, 1.603)\n        \t\t\t+ 0.003 * vec3(sin(ti), 0.2*sin(ti*2.1) + sin(ti\/3.1), cos(ti));\n\t}\n    else if (id < 2.)\n    {\n        ti \/= 30.;\n        pos = vec3(22., 1.86, 1.61)\n            + 0.04 * vec3(sin(-ti), 0.2*sin(ti*2.+1.6), 2.*cos(ti));\n    }\n    else if (id < 3.)\n    {\n        pos = vec3(8., 1.9, 1.6)\n            + 0.003 * vec3(sin(ti), 0.2*sin(ti*1.1) + sin(ti\/3.1), ti);\n    }\n    else if (id < 4.)\n    {\n        ti \/= 5.;\n        pos = vec3(1.2, 1.9, 1.92)\n            + 0.002 * vec3(sin(ti), 0.4*sin(ti*0.3), cos(ti));\n    }\n    \/\/ add some variation\n    id = floor(mod(pid, 12.));\n    if (id >= 3.)\n    \tpos += 0.0002*id;\n\treturn pos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy*.5) \/ iResolution.y * 2.;\n    \n    float ti = iGlobalTime;\n    \n    \/\/ image id\n    float pid = ti\/3. + uv.x;\n    \n    vec3 pos = path(ti, pid);\n    vec3 npos = path(ti+0.3, pid);\n    \n    vec3 dir = normalize(vec3(uv, 2. - .3 * length(uv)));\n    vec3 fwd = normalize(npos - pos);\n    vec3 up = normalize(vec3(0,.1,0));\n    \/\/ is it left or right? i always forget..\n    vec3 orth = normalize(cross(up, fwd));\n\tup = normalize(cross(fwd,orth));\n    dir = mat3(orth,up,fwd) * dir;\n    \n    fragColor = vec4(ray_color(pos, dir, 0.00035), 1.);\n}","name":"","description":"","type":"image"}]}}