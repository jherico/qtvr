{"Shader":{"ver":"0.1","info":{"id":"lllXWr","date":"1436018800","viewed":813,"name":"Disco Lighting","username":"eiffie","description":"I am a silent carrier of disco fever.","likes":12,"published":3,"flags":8,"tags":["disco","mirrorball","discoball"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\n\/\/only one ball when showing reflections on walls\n#define SHOW_WALL_REFLECTIONS\n\n#define MARCH_STEPS 32\n#define MAX_DEPTH 20.0\n#define MIN_DIST 0.001\n#define TILE_SIZE 0.125\n#define BALL_RADIUS 0.5\nfloat SPREAD=0.1+sin(iGlobalTime)*0.09,SPIN=-iGlobalTime*0.6;\n\nvec3 sph1=vec3(1.0,0.0,0.0),sph2=vec3(0.0,0.1,1.25),sph3=vec3(-0.5,0.15,0.0);\n\nfloat Sphere(vec3 pos, float r, vec3 ro, vec3 rd){\n\tvec3 p=pos-ro;\n\tfloat b=dot(p,rd),h=b*b-dot(p,p)+r*r;\n\tif(h>0.0)h=b-sqrt(h);\n\treturn h>0.0?h:MAX_DEPTH;\n}\nfloat Box(vec3 p, vec3 s, vec3 ro, vec3 rd){\/\/insideout box\n\tp-=ro;\n\tvec3 f=max((p-s)\/rd,(p+s)\/rd);\n\treturn min(f.x,min(f.y,f.z));\n}\nvec3 DiscoNormal(vec3 p){\n\tfloat a=atan(p.z,p.x)+SPIN,b=atan(p.y,length(p.xz));\n\tb-=mod(b,TILE_SIZE)-TILE_SIZE*0.5;\n\tfloat ts=TILE_SIZE+b*b*0.15;\n\ta-=mod(a+b,ts)-ts*0.5+SPIN;\n\tfloat cb=cos(b);\n\treturn vec3(cb*cos(a),sin(b),cb*sin(a));\n}\nvec4 VolLights(in vec3 p){\n#ifdef SHOW_WALL_REFLECTIONS\n\tfloat d1=max(-p.y,0.005*sin(p.y*150.0)+length(p.xz-sph3.xz));\n#else\n\tfloat d1=max(-p.y,0.005*sin(p.y*150.0)+min(length(p.xz-sph1.xz),min(length(p.xz-sph2.xz),length(p.xz-sph3.xz))));\n#endif\n\tp.y-=1.0;\/\/+=10.0;\n\tp.z=abs(p.z)-2.0;\n\tfloat a=atan(p.x,-p.y),b=a*0.5;\n\ta+=sin(iGlobalTime*2.4)*0.1;\n\ta=clamp(a,-SPREAD,SPREAD)*2.0-a;\n\ta=clamp(a,-SPREAD\/3.0,SPREAD\/3.0)*2.0-a;\n\tp.x=length(p.xy)*sin(a);\n\tfloat d=length(p.xz);\n\tif(d1<d){d=d1;b=-0.5;}\n\tvec3 col=vec3(0.5+b,0.3-b,1.0)*exp(-d*100.0);\n\treturn vec4(col,d);\n}\n\nvec3 Background(in vec3 rd){\n\tvec3 col=vec3(0.25)+vec3(0.125,0.05,0.125)*(rd+sin(rd*6.0+2.4*sin(rd.yzx*5.3+iGlobalTime)));\n\tcol+=pow(abs(rd),vec3(80.0))+pow(abs(rd.yzx),vec3(120.0));\n\treturn clamp(col,0.0,1.0);\n}\n\nvec3 trace(inout vec3 ro, inout vec3 rd){\n\tvec3 col=vec3(0.0),vol=vec3(0.0);\n\tfloat b3=Sphere(sph3,BALL_RADIUS,ro,rd);\n\tvec3 p=sph3;\n#ifndef SHOW_WALL_REFLECTIONS\n\tfloat b1=Sphere(sph1,BALL_RADIUS,ro,rd);\n\tfloat b2=Sphere(sph2,BALL_RADIUS,ro,rd);\n\tif(b1<b3){b3=b1;p=sph1;}\n\tif(b2<b3){b3=b2;p=sph2;}\n#endif\n\tfloat w=min(Box(vec3(4.0,-10.0,0.0),vec3(11.0),ro,rd),b3);\n\tfloat d,t=0.0;\n\tfor(int i=0;i<MARCH_STEPS;i++){\n\t\tif(t>w)continue;\n\t\tvec4 v=VolLights(ro+rd*t);\n\t\tvol+=v.rgb;\n\t\tt+=v.w;\n\t\t\/\/if(t>w)break;\n\t}\n\tif(b3<MAX_DEPTH){\n\t\tvec3 N=DiscoNormal(ro-p+rd*b3);\n\t\tvec3 L=normalize(vec3(-0.6,0.7,0.5));\n\t\tvec3 R=reflect(rd,N);\n\t\tfloat dif=max(dot(N,L),0.0);\n\t\tfloat amb=0.5+0.5*N.y;\n\t\tfloat spe=pow(max(dot(R,L),0.0),16.0);\n\t\tfloat vis=abs(dot(rd,N));\n\t\tvec3 brdf=dif*vec3(1.0)+amb*vec3(0.3)+spe*vec3(1.0);\n\t\tcol=mix(brdf,Background(R)*vis,1.0-vis*0.5);\n\t\tro+=rd*(b3-MIN_DIST);\n\t\trd=R;\n\t}else {\n\t\tcol=Background(rd)*0.2;\n\t\tro+=rd*w;\n#ifdef SHOW_WALL_REFLECTIONS\n\t\trd=normalize(ro-sph3);\n\t\tro=sph3+rd*(BALL_RADIUS+MIN_DIST);\n\t\trd=reflect(DiscoNormal(rd*BALL_RADIUS),-rd);\n#endif\n\t}\n\treturn col+vol;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\treturn mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy\/iResolution.xy;\n\tvec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x\/iResolution.y;\n\n\t\/\/ camera\t\n\tvec3 ro = vec3(cos(iGlobalTime*0.3)*2.0,sin(iGlobalTime*0.2)-0.25,sin(iGlobalTime*0.3)*3.0); \/\/camPath(time);\n\tvec3 ta = vec3(0.0);\n\n\t\/\/ camera-to-world transformation\n\tmat3 ca = setCamera( ro, ta, 0.0 );\n    \n\t\/\/ ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.5) );\n\t\n\t\/\/ render\t\n\tvec3 col=trace(ro,rd);\n\tcol+=trace(ro,rd)*0.75;\n\tcol+=trace(ro,rd)*0.5;\n\n\t\/\/col = pow( col, vec3(0.4545) );\n\n\tfragColor=vec4( col, 1.0 );\n} \n","name":"","description":"","type":"image"},{"inputs":[],"outputs":[{"channel":"0"}],"code":"#define PI 3.14159\n\nfloat rand(float t){return fract(sin(dot(vec2(t),vec2(12.9898,78.233)))*43758.5453);}\nfloat noyz(float t){return mix(rand(floor(t)),rand(floor(t)+1.0),fract(t));}\n\nvec2 mainSound(float time)\n{\n\ttime*=0.95;\n\t\/\/just making a snare - sorry i forgot who i stole the other drums from :(\n\tfloat beat=fract(time);\n\tfloat kick=sin(beat*1000.0*max(1.0-beat*6.0,0.441))*(1.0-beat);\n\tbeat=fract(time+0.5);\n\tfloat bt2=beat*2600.0*max(1.0-beat*6.0,0.666);\n\tfloat snare=sin(bt2)*noyz(bt2)*exp(-beat*16.0);\n\tfloat hihat=rand(time)\/pow(mod(time,0.125)+1.0,20.0)*(0.5+sin(time*PI*8.0)*0.45);\n\tbeat=fract(time+0.75);\n\tfloat openhat=rand(beat)*exp(-beat*15.0);\n\tfloat beats=kick+0.25*snare+0.05*hihat+0.1*openhat;\n\t\n\t\n\treturn clamp(vec2(beats),-1.0,1.0);\n}\n","name":"","description":"","type":"sound"}]}}