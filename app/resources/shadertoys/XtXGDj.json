{"Shader":{"ver":"0.1","info":{"id":"XtXGDj","date":"1425040767","viewed":742,"name":"Ray Marching Experiment 11","username":"aiekick","description":"Mouse X => Splitter (left positive displace \/ right negative displace with a zoom )<br\/>Mouse Y => cells density","likes":4,"published":3,"flags":0,"tags":["raymarching","voronoi","experiment"],"hasliked":0},"renderpass":[{"inputs":[{"id":23,"src":"\/presets\/cube01_0.png","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Stephane Cuillerdier - Aiekick\/2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/\/\/\/VARS\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nfloat yVar;\nvec2 s,g,m;\n\n#define ITERATIONS_MAX 100\n\n#define RUGOSITY_DENSITY 5.\n\n#define CELLS_DENSITY_MAX 10.\n#define CELLS_DENSITY_DEFAULT 1.6\n\n#define TIME_RATIO iGlobalTime\n\n\/\/ VORONOI based on IQ shader https:\/\/www.shadertoy.com\/view\/ldl3W8\n\/\/vec2 getHash2BasedTex(vec2 p) {return texture2D( iChannel0, (p+0.5)\/256.0, -100.0 ).xy;}\/\/texture based white noise\nvec2 getHash2BasedProc(vec2 p)\n{\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453); \/\/procedural white noise\n}\n\nvec3 getVoronoi(vec2 x)\n{\n    vec2 n=floor(x),f=fract(x),mr;\n    float md=5.;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ ){\n        vec2 g=vec2(float(i),float(j));\n\t\tvec2 o=0.5+0.5*sin(TIME_RATIO+6.2831*getHash2BasedProc(n+g));\/\/animated\n        vec2 r=g+o-f;\n        float d=dot(r,r);\n        if( d<md ) {md=d;mr=r;} }\n    return vec3(md,mr);\n}\n\n\/\/ sphere mapping of v2 voronoi\nvec3 voronoiSphereMapping(vec3 n)\n{\n\tvec2 uv=vec2(atan(n.x,n.z),acos(n.y));\n    float voroRatio = CELLS_DENSITY_DEFAULT;\n\tif ( iMouse.z > 0. ) {voroRatio = yVar * CELLS_DENSITY_MAX;}\n    return getVoronoi(voroRatio*uv);\n}\n\n\/\/\/\/\/\/\/\/MAP\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nfloat density=RUGOSITY_DENSITY;\n\nfloat map(vec3 p)\n{\n    float rugosity = cos(density*p.x)*sin(density*p.y)*sin(density*p.z)*cos(256.1)*sin(0.8);\n\t\n    float voro = length(vec4(voronoiSphereMapping(normalize(p)),1.))*0.4-0.8 + rugosity;\n    \n    \/\/ splitter choice\n    float disp = g.x<m.x?voro:-.55-voro;\n    \n    return length(p)-1.+disp;\n}\n\n\/\/\/\/\/\/\/\/MAIN\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    s = iResolution.xy;\n    g = fragCoord.xy;\n    m = iMouse.x==0.?m = s\/2.:iMouse.xy;\n    yVar = m.y\/s.y;\n   \t\n    float cam_a = 0.; \/\/ angle z\n    float cam_e = .5; \/\/ elevation\n    float cam_d = 2.; \/\/ distance to origin axis\n    vec3 camUp=vec3(0,1,0.);\/\/Change camere up vector here\n  \tvec3 camView=vec3(0,0,0); \/\/Change camere view here\n  \tfloat li = 0.63; \/\/ light intensity\n    float prec = 0.001; \/\/ ray marching precision\n    float maxd = 10.; \/\/ ray marching distance max\n    float refl_i = 0.8; \/\/ reflexion light intensity\n    float refr_a = 0.; \/\/ refraction angle\n    float refr_i = 0.2; \/\/ refraction light intensity\n    float bii = 0.35; \/\/ bright init intensity\n    \n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \n    vec2 su = iResolution.xy;\n\tvec2 uv = (2.*fragCoord.xy -su)\/su.y;\n    \n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(-sin(cam_a)*cam_d, cam_e, cos(cam_a)*cam_d); \/\/\n  \tvec3 rov = normalize(camView-ro);\n    vec3 u = normalize(cross(camUp,rov));\n  \tvec3 v = cross(rov,u);\n  \tvec3 rd = normalize(rov + uv.x*u + uv.y*v);\n    \n    float b = bii;\n    float c = prec;\n    float d = 0.;\n    for(int i=0;i<ITERATIONS_MAX;i++)\n    {      \n        if (c<prec||c>maxd) break;\n        c = map(ro+rd*d)*.8;\n        d += c;\n    }\n    \n    if (d<maxd)\n    {\n        vec2 e = vec2(-1., 1.)*0.005; \n    \tvec3 p = ro+rd*d;\n        vec3 n = normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );\n        vec3 np = normalize(p);\n        \n        vec3 voroCol = voronoiSphereMapping(np);\n        vec3 marchCol = vec3(max(0.,2.3-d));\n        col = mix(marchCol,voroCol,0.7);   \n        \n        vec3 coln = normalize(col); \/\/ cell teinte\n        \n        b+=dot(n, np)*li;\n        \n        vec3 reflRay = reflect(rd, n);\n        vec3 refrRay = refract(rd, n, refr_a);\n        vec3 cubeRefl = textureCube(iChannel0, reflRay).rgb * refl_i * coln;\n        vec3 cubeRefr = textureCube(iChannel0, refrRay).rgb * refr_i * coln;\n        \n        col = cubeRefl+cubeRefr+pow(b,15.);  \n    }\n    else\n    {\n        b+=0.1;\n        col = textureCube(iChannel0, rd).rgb;\n    }\n    \n    \/\/ splitter\n    col = mix( col, vec3(0.), 1.-smoothstep( 1., 2., abs(m.x-g.x) ) );    \n    \n\tfragColor = vec4(col,1.);\n}","name":"","description":"","type":"image"}]}}