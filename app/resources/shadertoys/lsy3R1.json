{"Shader":{"ver":"0.1","info":{"id":"lsy3R1","date":"1453350685","viewed":187,"name":"Stateful particle system","username":"oks2024","description":"A particle system with basic physics, and mouse interaction.<br\/><br\/>You can tweak the values of the defines to add particles, change their size, etc. With a smaller viewport you can add more particles with a good framerate.","likes":10,"published":3,"flags":32,"tags":["particles","physics","multipass","gpu"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ The total number of particles will be NB_PARTICLES * NB_PARTICLES.\n#define NB_PARTICLES 40\n#define PARTICLE_SIZE 0.006\n#define OPACITY 2.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    \n    vec2 pixelSize = 1.0 \/ iResolution.xy;\n    \n\tvec2 uv = fragCoord.xy * pixelSize;\n    \n    vec3 finalColor = vec3(0.0);\n    \n    int resx = int(iResolution.x);\n    int resy = int(iResolution.y);\n    \n    \/\/ Read each pixels of the position texture to find if some of them are \n    \/\/ close from the current pixel.\n    for (int x = 0; x < NB_PARTICLES; x++)\n    {\n        for (int y = 0; y < NB_PARTICLES; y++)\n        {\n            \/\/ This is the bottleneck of the shader, there might be a\n            \/\/ better way to read the particle textures.\n            vec4 currentParticle = texture2D(iChannel0, vec2(x, y) * pixelSize);\n            vec2 particlePixelVector = currentParticle.xy - uv;\n            \n            \/\/ If a particle is close to this pixel, add its color to the final color.\n            if (particlePixelVector.x * particlePixelVector.x + particlePixelVector.y * particlePixelVector.y  < pixelSize.x * PARTICLE_SIZE)\n            {\n                float val = (currentParticle.z * currentParticle.z + currentParticle.w * currentParticle.w) *0.000001;\n                vec3 velocityColor = vec3(-0.25 + val, 0.1, 0.25-val) * OPACITY;\n                finalColor += velocityColor.xyz;\n            } \n        }\n    }\n    \n\tfragColor = vec4(finalColor, 1.0);\n\n    \n    \n}","name":"","description":"","type":"image"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define BOUNCE_GROUND 0.5\n#define BOUNCE 0.2\n#define MAX_SPEED 800.0\n#define GRAVITY vec2(0.0, -5.0)\n#define ATTRACTION 60.0\n\n\n\/\/ Random function from https:\/\/www.shadertoy.com\/view\/4ssXRX\n\/\/ note: uniformly distributed, normalized rand, [0;1[\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec2 pixelSize = 1.0 \/ iResolution.xy;\n    \n    \/\/ Initialize the texture on the first frame with random positions and null velocity.\n    if (iFrame == 1)\n    {\n\t\tfragColor = vec4(vec2(nrand(uv), nrand(uv.yx)), 0.0 , 0.0);\n        return;\n    }\n    \n    \/\/ The texture stores the particle position in xy and the velocity in zw.\n    vec4 previousFrameValues = texture2D(iChannel0, uv);\n    vec2 position = previousFrameValues.xy;\n    vec2 velocity = previousFrameValues.zw;\n \n    \/\/ Gravity.\n    velocity += GRAVITY;\n    \n    \/\/Mouse attraction.\n    if (iMouse.w>0.01)\n    {\n    \tvec2 attractionVector = (iMouse.xy\/iResolution.xy) - position;\n    \tvelocity += ATTRACTION * (normalize(attractionVector));\n    }\n    \n    float randValue = nrand(uv.yx * iGlobalTime) * 0.5;\n    \n    \/\/ Collisions\n    if (position.x < 0.0)\n    {\t\n        velocity = vec2(abs(velocity.x) * (BOUNCE+randValue), velocity.y);\n    }\n\n    if (position.x > 1.0)\n    {\t\n        velocity = vec2(-abs(velocity.x) * (BOUNCE+randValue), velocity.y);\n    }\n\n    if (position.y < 0.0)\n    {\n        velocity = vec2(velocity.x, abs(velocity.y) * (BOUNCE_GROUND+randValue));\n    }\n\n    if (position.y > 1.0)\n    {\n        velocity = vec2(velocity.x, -abs(velocity.y) * (BOUNCE+randValue));\n    }\n    \n    \/\/ Update position.\n    position.xy += velocity * iTimeDelta * 0.001;\n    \n    if ( length(velocity) > MAX_SPEED)\n        velocity = normalize(velocity) * MAX_SPEED;\n    \n    \n    fragColor = vec4(position.xy, velocity.xy);\n}","name":"","description":"","type":"buffer"}]}}