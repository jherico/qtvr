{"Shader":{"ver":"0.1","info":{"id":"MdV3Wz","date":"1454184710","viewed":131,"name":"Fractal Explorer Multi-res.","username":"Dave_Hoskins","description":"Mandalay fractal. Thanks to 'rebb' for the fractal formula reference in Fractal city_242.<br\/>Multi-resolution rendering for speed up.","likes":15,"published":3,"flags":112,"tags":["3d","raymarching","fractal","dof","mandalay"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":1430,"src":"https:\/\/soundcloud.com\/nitenichiryu\/dubtechnoblogshowmixlr-2016-01-24","ctype":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Fractal Explorer Multi-res. January 2016\n\/\/ by David Hoskins\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ https:\/\/www.shadertoy.com\/view\/MdV3Wz\n\n\/\/ Mandalay fractal. Thanks to 'rebb' for the fractal fomula reference in Fractal city_242.\n\/\/ Here:- https:\/\/www.shadertoy.com\/view\/MsK3DR\n\n\/\/ Enable antialiasing...\n\/\/#define ANTIALIAS 1\n\n\/\/ * * CONTROLS * *\n\/\/ WASD or CURSOR keys\n\/\/ Mouse drag to turn.\n\/\/ SHIFT & SPACE for 2X speed\n\n\/\/--------------------------------------------------------------------------\n#define SUN_COLOUR vec3(1., .95, .9)\n#define FOG_COLOUR vec3(.12, 0.13, 0.14)\n#define HASHSCALE .1031\n#define TAU 6.28318530718\n\nvec2 fcoord;\n\nvec2 camStore = vec2(4.0,  0.0);\nvec2 rotationStore\t= vec2(1.,  0.);\nvec3 sunLight  = normalize(vec3(  0.4, 0.7,  0.4 ));\n\n\/\/ By TekF...\nvoid BarrelDistortion( inout vec3 ray, float degree )\n{\n\tray.z \/= degree;\n\tray.z = ( ray.z*ray.z - dot(ray.xy,ray.xy) );\n\tray.z = degree*sqrt(ray.z);\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 loadValue3( in vec2 re )\n{\n    return texture2D( iChannel0, (0.5+re) \/ iChannelResolution[0].xy, -100.0 ).xyz;\n}\nvec2 loadValue2( in vec2 re )\n{\n    return texture2D( iChannel0, (0.5+re) \/ iChannelResolution[0].xy, -100.0 ).xy;\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ From https:\/\/www.shadertoy.com\/view\/4djSRW\nfloat Hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\/\/----------------------------------------------------------------------------------------\nfloat Scale = 4.;\nfloat MinRad2 = 0.25;\n\nfloat sr = 4.0;\nvec3 fo =vec3 (0.7,.9528,.9);\nvec3 gh = vec3 (.8,.7,0.5638);\nvec3 gw = vec3 (.3, 0.5 ,.2);\nvec4 X = vec4( .1,0.5,0.1,.3);\nvec4 Y = vec4(.1, 0.8, .1, .1);\nvec4 Z = vec4(.2,0.2,.2,.45902);\nvec4 R = vec4(0.19,.1,.1,.2);\nvec4 orbitTrap = vec4(40000.0);\n\/\/--------------------------------------------------------------------------\nfloat DBFold(vec3 p, float fo, float g, float w){\n    if(p.z>p.y) p.yz=p.zy;\n    float vx=p.x-2.*fo;\n    float vy=p.y-4.*fo;\n    float v=max(abs(vx+fo)-fo,vy);\n    float v1=max(vx-g,p.y-w);\n    v=min(v,v1);\n    v1=max(v1,-abs(p.x));\n    return min(v,p.x);\n}\n\/\/the coordinates are pushed\/pulled in parallel\n\n\n\/\/the coordinates are pushed\/pulled in parallel\nvec3 DBFoldParallel(vec3 p, vec3 fo, vec3 g, vec3 w){\n\tvec3 p1=p;\n\tp.x=DBFold(p1,fo.x,g.x,w.x);\n\tp.y=DBFold(p1.yzx,fo.y,g.y,w.y);\n\tp.z=DBFold(p1.zxy,fo.z,g.z,w.z);\n\treturn p;\n}\n\/\/serial version\nvec3 DBFoldSerial(vec3 p, vec3 fo, vec3 g,vec3 w){\n\tp.x=DBFold(p,fo.x,g.x,w.x);\n\tp.y=DBFold(p.yzx,fo.y,g.y,w.y);\n\tp.z=DBFold(p.zxy,fo.z,g.z,w.z);\n\treturn p;\n}\nfloat Map(vec3 p)\n{\n\tvec4 JC=vec4(p,1.);\n\tfloat r2=dot(p,p);\n\tfloat dd = 1.;\n\tfor(int i = 0; i< 6; i++){\n\t\t\n\t\tp = p - clamp(p.xyz, -1.0, 1.0) * 2.0;  \/\/ mandelbox's box fold\n\n\t\t\/\/Apply pull transformation\n\t\tvec3 signs=sign(p);\/\/Save \tthe original signs\n\t\tp=abs(p);\n\t\tp=DBFoldParallel(p,fo,gh,gw);\n\t\t\n\t\tp*=signs;\/\/resore signs: this way the mandelbrot set won't extend in negative directions\n\t\t\n\t\t\/\/Sphere fold\n\t\tr2=dot(p,p);\n\t\tfloat  t = clamp(1.\/r2, 1., 1.\/MinRad2);\n\t\tp*=t; dd*=t;\n\t\t\n\t\t\/\/Scale and shift\n\t\tp=p*Scale+JC.xyz; dd=dd*Scale+JC.w;\n\t\tp=vec3(1.0,1.0,.92)*p;\n\n\t\tr2=dot(p,p);\n\t\torbitTrap = min(orbitTrap, abs(vec4(p.x,p.y,p.z,r2)));\t\n\t}\n\tdd=abs(dd);\n#if 1\n\treturn (sqrt(r2)-sr)\/dd;\/\/bounding volume is a sphere\n#else\n\tp=abs(p); return (max(p.x,max(p.y,p.z))-sr)\/dd;\/\/bounding volume is a cube\n#endif\n}\n\/\/--------------------------------------------------------------------------\nfloat Shadow( in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 0.06;\n\tfloat h;\n\t\n    for (int i = 0; i < 8; i++)\n\t{\n\t\th = Map( ro + rd*t );\n\t\tres = min(4.5*h \/ t, res);\n\t\tt += h+.15;\n\t}\n    return max(res, 0.0);\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 DoLighting(in vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float d, in float sh)\n{\n    vec3 sunLight  = normalize( vec3(  0.4, 0.4,  0.3 ) );\n\/\/\tsh = Shadow(pos,  sunLight);\n    \/\/ Light surface with 'sun'...\n\tvec3 col = mat * SUN_COLOUR*(max(dot(sunLight,normal), 0.0)) *sh;\n    col += mat *(max(dot(-sunLight,normal), 0.0))*.5;\n    \n    normal = reflect(eyeDir, normal); \/\/ Specular...\n    col += pow(max(dot(sunLight, normal), 0.0), 10.0)  * SUN_COLOUR * .4 *sh;\n    \/\/ Abmient..\n    col += mat * .2 * max(normal.y, 0.3)+.011;\n    col = mix(FOG_COLOUR,col, clamp(exp(-d*d*.05)+.03,0.0, 1.0));\n    \n\treturn col;\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 GetNormal(vec3 p, float sphereR)\n{\n\tvec2 eps = vec2(sphereR, 0.0);\n\treturn normalize( vec3(\n           Map(p+eps.xyy) - Map(p-eps.xyy),\n           Map(p+eps.yxy) - Map(p-eps.yxy),\n           Map(p+eps.yyx) - Map(p-eps.yyx) ) );\n}\n\n\/\/--------------------------------------------------------------------------\nfloat SphereRadius(in float t)\n{\n    t = t * .001*(500.\/iResolution.y);\n    return (t);\n}\n\n\/\/--------------------------------------------------------------------------\nfloat binarySubdivision(in vec3 rO, in vec3 rD, vec2 t)\n{\n\t\/\/ Home in on the surface by dividing by two and split...\n    float halfwayT;\n\tfor (int n = 0; n < 4; n++)\n\t{\n\t\thalfwayT = (t.x + t.y) * .5;\n        (Map(rO + halfwayT*rD) < SphereRadius(t.x)) ? t.x = halfwayT:t.y = halfwayT;\n\t}\n\treturn halfwayT;\n}\n\n\/\/--------------------------------------------------------------------------\nfloat Scene(in vec3 rO, in vec3 rD, in float t)\n{\n\t\n\tvec3 p = vec3(0.0);\n    float oldT = t;\n\n\tfor( int j=0; j < 60; j++ )\n\t{\n\t\tif (t > 8.0) break;\n\t\tp = rO + t*rD;\n\t\tfloat sphereR = SphereRadius(t);\n\t\tfloat de = Map(p);\n\t\tif(de < sphereR) break;\n        oldT = t;\n\t\tt +=  de*.75;\n\t}\n    if (t < 8.0) t = binarySubdivision(rO, rD, vec2(t, oldT));\n\n\treturn t;\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 PostEffects(vec3 rgb, vec2 xy)\n{\n\t\/\/ Gamma first...\n\trgb = pow(rgb, vec3(0.45));\n\n\t\/\/ Then...\n\t#define CONTRAST 1.7\n\t#define SATURATION 1.1\n\t#define BRIGHTNESS 1.3\n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\n\n\t\/\/ Vignette...\n\trgb *= .7+0.3*pow(220.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.3);\t\n\n\treturn clamp(rgb, 0.0, 1.0);\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 TexCube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec3 x = texture2D( sam, p.yz ).xzy;\n\tvec3 y = texture2D( sam, p.zx ).xyz;\n\tvec3 z = texture2D( sam, p.xy ).yzx;\n\treturn (x*abs(n.x) + y*abs(n.y) + z*abs(n.z))\/(abs(n.x)+abs(n.y)+abs(n.z));\n}\n\n\n\/\/----------------------------------------------------------------------------------------\n\nvec2 rot2D(inout vec2 p, float a)\n{\n    return cos(a)*p - sin(a) * vec2(p.y, -p.x);\n}\n\n\/\/--------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n\n\tfloat m = (iMouse.x\/iResolution.x)*20.0;\n\tfloat gTime = ((iGlobalTime+26.)*.2+m);\n    vec2 xy = fragCoord.xy \/ iResolution.xy;\n\tvec2 uv = (-1. + 2.0 * xy) * vec2(iResolution.x\/iResolution.y,1.0);\n    \n    vec3 cameraPos = texture2D( iChannel0, vec2(.5,.5)\/iResolution.xy, -100.0 ).xyz;\n    vec2 camRot = texture2D( iChannel0, vec2(1.5,.5)\/iResolution.xy, -100.0 ).xy;\n    camRot*= TAU;\n \n   \n\t\/\/ Recorded distance so far..\n    float recDis = texture2D( iChannel1, xy*.5, -100.0 ).x;\n\n    vec3 col = vec3(.0);\n#ifdef ANTIALIAS\n    for (int y = 0; y < 2; y++)\n    {\n    \tfor (int x = 0; x < 2; x++)\n        {\n            vec3 dir = normalize( vec3(uv+vec2(x,y)\/iResolution.xy, 1.2 ) );\n#else\n\t\t\tvec3 dir = normalize( vec3(uv, 1.2 ) );\n#endif\n\n            BarrelDistortion(dir, .5);\n            dir =  normalize(dir);\n\n            float roll = .05 * sin(iGlobalTime*.3);\n            dir.xy = dir.xy*cos(roll) + sin(roll)*vec2(1,-1)*dir.yx;\n            dir.zy = dir.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*dir.yz;\n            dir.xz = dir.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*dir.zx;\n\n            float dis = Scene(cameraPos, dir, recDis-.005* Hash(fragCoord)-.05);\t\n            if (dis < 8.0)\n            {\n\n                vec3 pos = cameraPos + dir * dis;\n\n                float sphereR = SphereRadius(dis);\n                vec3 normal = GetNormal(pos, sphereR);\n\n                float sha = Shadow(pos, sunLight);\n\n                vec3 alb =\tX.xyz*X.w*orbitTrap.x +\n\t\t\t\t\t\t\tY.xyz*Y.w*orbitTrap.y +\n\t\t\t\t\t\t\tZ.xyz*Z.w*orbitTrap.z +\n\t\t\t\t\t\t\tR.xyz*R.w*orbitTrap.w;\n\t\n\n                col += DoLighting(alb*.2, pos, normal, dir, dis, sha);\n            }else\n            {\n                col += FOG_COLOUR+pow(max(dot(sunLight, dir), 0.0), 8.0)  * SUN_COLOUR * .1;\n            }\n            col += pow(max(dot(sunLight, dir), 0.0), 2.0)  * SUN_COLOUR * .1;\n#ifdef ANTIALIAS\n        }\n    }\n        col\/=4.;\n#endif\n    \n\t   \n\tcol = PostEffects(col, xy) * smoothstep(.0, 2.0, iGlobalTime);\t\n\t\n    \/\/fragColour=vec4(col+vec3(recDis\/16., 0, 0), 1.);\n    \/\/fragColour=vec4(dis\/16.);\n    fragColour=vec4(col, 1.);\n}\n\n\/\/--------------------------------------------------------------------------","name":"","description":"","type":"image"},{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Adaption of Ben Quantock, WASD 2016 ( https:\/\/www.shadertoy.com\/view\/ldyGzW )\n\/\/ With speed limits and frame delta added by Dave Hoskins.\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define INVERT_Y 0\n\n#define ACCEL .01\n#define DECAY  .85 \/\/ how much velocity is preserved per frame (proportionally)\n#define MAX_SPEED  .01\n\n#if INVERT_Y\nconst float yMul = 1.0;\n#else\nconst float yMul = -1.0;\n#endif\nconst int KEY_W\t\t= 87;\nconst int KEY_A\t\t= 65;\nconst int KEY_S\t\t= 83;\nconst int KEY_D\t\t= 68;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_SPACE\t= 32;\nconst int KEY_SHIFT\t= 16;\n\n\/\/----------------------------------------------------------------------------------------\nfloat ReadKey( int key )\n{\n   \treturn step(.5,texture2D( iChannel3, vec2( (float(key)+.5)\/256.0, .25)).x);\n}\n\n\/\/----------------------------------------------------------------------------------------\n#define CSize vec3(1., 1.7, 1.)\n\nfloat Map( vec3 p )\n{\n\tp = p.xzy;\n\tfloat scale = 1.1;\n\tfor( int i=0; i < 8;i++ )\n\t{\n\t\tp = 2.0*clamp(p, -CSize, CSize) - p;\n\t\tfloat r2 = dot(p,p);\n        \/\/float r2 = dot(p,p+sin(p.z*.3)); \/\/Alternate fractal\n\t\tfloat k = max((2.)\/(r2), .5);\n\t\tp     *= k;\n\t\tscale *= k;\n\t}\n\tfloat l = length(p.xy);\n\tfloat rxy = l - 1.0;\n\tfloat n = l * p.z;\n\trxy = max(rxy, (n) \/ 8.);\n\treturn (rxy) \/ abs(scale);\n}\n\n\/\/----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n\n    if ( int(fragCoord.y) == 0 )\n    {\n        if ( int(fragCoord.x) == 0 )\n        {\n            vec3 camPos = texture2D( iChannel0, vec2(.5,.5)\/iResolution.xy, -100.0 ).xyz;\n            vec3 camVel = texture2D( iChannel0, vec2(3.5,.5)\/iResolution.xy, -100.0 ).xyz;\n            float time  = (iGlobalTime-texture2D( iChannel0, vec2(4.5,.5)\/iResolution.xy, -100.0 ).x)*30.0;\n             if (iFrame == 0)\n\t\t    {\n        \t\tfragColor = vec4(3.0, 4.2,1.5, 1.);\n            }else\n            {\n                camVel *= time*(1.0+ReadKey(KEY_SHIFT)+ReadKey(KEY_SPACE));\n                vec3 oldCam = camPos;\n                \/\/camPos.x += camVel.x;if (Map(camPos) < 0.002) camPos.x = oldCam.x;\n                \/\/camPos.y += camVel.y;if (Map(camPos) < 0.002) camPos.y = oldCam.y;\n                \/\/camPos.z += camVel.z;if (Map(camPos) < 0.002) camPos.z = oldCam.z;\n                camPos += camVel;\n            \tfragColor = vec4(camPos, 0);\n            }\n        }\n        else if ( int(fragCoord.x) <= 2 )\n        {\n            vec4 baseCamRot = texture2D( iChannel0, vec2(2.5,.5)\/iResolution.xy, -100.0 );\n            vec4 camRot = texture2D( iChannel0, vec2(1.5,.5)\/iResolution.xy, -100.0 );\n\n            vec2 mouseRot = (iMouse.yx\/iResolution.yx-.5)*vec2(.5*yMul,1.);\n            \n            camRot.w = iMouse.z;\n            \n            bool press = (camRot.w > .0);\n            bool lastPress = (baseCamRot.w > .0);\n            bool click = press && !lastPress;\n            if ( click )\n            {\n                baseCamRot.xy -= mouseRot;\n            }\n            \n            if ( press )\n            {\n                camRot.xy = baseCamRot.xy + mouseRot;\n            }\n            else\n            {\n                \/\/update the base pos\n                baseCamRot = camRot;\n            }\n\n            baseCamRot.w = camRot.w;\n            \n            \/\/ store\n            if ( int(fragCoord.x) == 1 )\n            {\n\t\t\t\tif (iFrame == 0)\n\t\t    \t{\n        \t\t\tfragColor = vec4(.0, .75, .0,0);\n            \t}else\n            \tfragColor = camRot;\n            }\n            else\n            {\n            \tfragColor = baseCamRot;\n            }\n        }\n        else if ( int(fragCoord.x) == 3 )\n        {\n            vec4 camVel = texture2D( iChannel0, vec2(3.5,.5)\/iResolution.xy, -100.0 );\n            vec4 camRot = texture2D( iChannel0, vec2(1.5,.5)\/iResolution.xy, -100.0 )*6.28318530718;\n            \n            vec3 forward = vec3(0,0,ACCEL);\n            vec3 right \t = vec3(ACCEL,0,0);\n\n            forward.zy = forward.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*forward.yz;\n            right.zy = right.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*right.yz;\n                \n            forward.xz = forward.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*forward.zx;\n\t\t    right.xz = right.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*right.zx;\n            \n            camVel.xyz += (ReadKey(KEY_W)-ReadKey(KEY_S)+ReadKey(KEY_UP)-ReadKey(KEY_DOWN)) * forward;\n            camVel.xyz += (ReadKey(KEY_D)-ReadKey(KEY_A)+ReadKey(KEY_RIGHT)-ReadKey(KEY_LEFT)) * right;\n            \n\n            camVel *= DECAY; \/\/ exponential decay\n            float lim = length(camVel);\n            if (lim > MAX_SPEED)\n            {\n                camVel = normalize(camVel) * MAX_SPEED;\n            }\n        \n            \n            fragColor = camVel;\n        }\n\t\telse if ( int(fragCoord.x) == 4 )\n        {\n\t\t\tfragColor = vec4(iGlobalTime);\n\t    }\n    }\n}\n","name":"","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Fractal Explorer Multi-res. January 2016\n\/\/ by David Hoskins\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ https:\/\/www.shadertoy.com\/view\/MdV3Wz\n\n\/\/ Mandalay fractal. Thanks to 'rebb' for the fractal fomula reference in Fractal city_242.\n\/\/ Here:- https:\/\/www.shadertoy.com\/view\/MsK3DR\n\n\n\/\/--------------------------------------------------------------------------\n#define TAU 6.28318530718\n\n\/\/ By TekF...\nvoid BarrelDistortion( inout vec3 ray, float degree )\n{\n\tray.z \/= degree;\n\tray.z = ( ray.z*ray.z - dot(ray.xy,ray.xy) );\n\tray.z = degree*sqrt(ray.z);\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 loadValue3( in vec2 re )\n{\n    return texture2D( iChannel0, (0.5+re) \/ iChannelResolution[0].xy, -100.0 ).xyz;\n}\nvec2 loadValue2( in vec2 re )\n{\n    return texture2D( iChannel0, (0.5+re) \/ iChannelResolution[0].xy, -100.0 ).xy;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat Scale = 4.;\nfloat MinRad2 = 0.25;\nfloat sr = 4.0;\nvec3 fo =vec3 (0.7,.9528,.9);\nvec3 gh = vec3 (.8,.7,0.5638);\nvec3 gw = vec3 (.3, 0.5 ,.2);\n\n\/\/--------------------------------------------------------------------------\nfloat DBFold(vec3 p, float fo, float g, float w){\n    if(p.z>p.y) p.yz=p.zy;\n    float vx=p.x-2.*fo;\n    float vy=p.y-4.*fo;\n    float v=max(abs(vx+fo)-fo,vy);\n    float v1=max(vx-g,p.y-w);\n    v=min(v,v1);\n    v1=max(v1,-abs(p.x));\n    return min(v,p.x);\n}\n\/\/the coordinates are pushed\/pulled in parallel\n\n\n\/\/the coordinates are pushed\/pulled in parallel\nvec3 DBFoldParallel(vec3 p, vec3 fo, vec3 g, vec3 w){\n\tvec3 p1=p;\n\tp.x=DBFold(p1,fo.x,g.x,w.x);\n\tp.y=DBFold(p1.yzx,fo.y,g.y,w.y);\n\tp.z=DBFold(p1.zxy,fo.z,g.z,w.z);\n\treturn p;\n}\n\/\/serial version\nvec3 DBFoldSerial(vec3 p, vec3 fo, vec3 g,vec3 w){\n\tp.x=DBFold(p,fo.x,g.x,w.x);\n\tp.y=DBFold(p.yzx,fo.y,g.y,w.y);\n\tp.z=DBFold(p.zxy,fo.z,g.z,w.z);\n\treturn p;\n}\nfloat Map(vec3 p)\n{\n\tvec4 JC=vec4(p,1.);\n\tfloat r2=dot(p,p);\n\tfloat dd = 1.;\n\tfor(int i = 0; i< 6; i++){\n\t\t\n\t\tp = p - clamp(p.xyz, -1.0, 1.0) * 2.0;  \/\/ mandelbox's box fold\n\n\t\t\/\/Apply pull transformation\n\t\tvec3 signs=sign(p);\/\/Save \tthe original signs\n\t\tp=abs(p);\n\t\tp=DBFoldParallel(p,fo,gh,gw);\n\t\t\n\t\tp*=signs;\/\/resore signs: this way the mandelbrot set won't extend in negative directions\n\t\t\n\t\t\/\/Sphere fold\n\t\tr2=dot(p,p);\n\t\tfloat  t = clamp(1.\/r2, 1., 1.\/MinRad2);\n\t\tp*=t; dd*=t;\n\t\t\n\t\t\/\/Scale and shift\n\t\tp=p*Scale+JC.xyz; dd=dd*Scale+JC.w;\n\t\tp=vec3(1.0,1.0,.92)*p;\n        \tr2=dot(p,p);\n\n\t}\n\tdd=abs(dd);\n#if 1\n\treturn (sqrt(r2)-sr)\/dd;\/\/bounding volume is a sphere\n#else\n\tp=abs(p); return (max(p.x,max(p.y,p.z))-sr)\/dd;\/\/bounding volume is a cube\n#endif\n}\n\n\/\/--------------------------------------------------------------------------\n\nfloat SphereRadius(in float t)\n{\n    t = t * .001*(500.\/iResolution.y);\n    return (t*2.);\n}\n\/\/--------------------------------------------------------------------------\nfloat binarySubdivision(in vec3 rO, in vec3 rD, vec2 t)\n{\n\t\/\/ Home in on the surface by dividing by two and split...\n    float halfwayT;\n\tfor (int n = 0; n < 4; n++)\n\t{\n\t\thalfwayT = (t.x + t.y) * .5;\n        (Map(rO + halfwayT*rD) < SphereRadius(t.x)) ? t.x = halfwayT:t.y = halfwayT;\n\t}\n\treturn halfwayT;\n}\n\/\/--------------------------------------------------------------------------\nfloat Scene(in vec3 rO, in vec3 rD)\n{\n\n\tfloat t = .01;\n    float oldT = t;\n\n\t\n\tvec3 p = vec3(0.0);\n\n\tfor( int j=0; j < 80; j++ )\n\t{\n\t\tif (t > 8.0) break;\n\t\tp = rO + t*rD;\n\t\tfloat sphereR = SphereRadius(t);\n\t\tfloat de = Map(p);\n\t\tif(de < sphereR) break;\n        \n        oldT = t;\n\t\tt +=  de*.75;\n\t}\n    \/\/if (t < 8.0) t = binarySubdivision(rO, rD, vec2(t, oldT));\n\n\treturn t;\n}\n\n\/\/--------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n\tfloat m = (iMouse.x\/iResolution.x)*20.0;\n\tfloat gTime = ((iGlobalTime+26.)*.2+m);\n    \n    \/\/ Only use a quarter of the screen for first pass...\n    vec2 xy = fragCoord.xy \/ iResolution.xy;\n    if(xy.x > .5 || xy.y > .5) discard;\n    xy *= 2.0;\n\tvec2 uv = (-1. + 2.0 * xy) * vec2(iResolution.x\/iResolution.y,1.0);\n    \n   \n    vec3 cameraPos = texture2D( iChannel0, vec2(.5,.5)\/iResolution.xy, -100.0 ).xyz;\n    vec2 camRot = texture2D( iChannel0, vec2(1.5,.5)\/iResolution.xy, -100.0 ).xy;\n\n    camRot*= TAU;\n    \n    vec3 dir = normalize( vec3(uv, 1.2 ) );\n    BarrelDistortion(dir, .5);\n    dir =  normalize(dir);\n\n    float roll = .05 * sin(iGlobalTime*.3);\n    dir.xy = dir.xy*cos(roll) + sin(roll)*vec2(1,-1)*dir.yx;\n    dir.zy = dir.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*dir.yz;\n    dir.xz = dir.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*dir.zx;\n  \n    float dis = Scene(cameraPos, dir);\n\t\n\tfragColour = vec4(dis);\n}\n\n\/\/--------------------------------------------------------------------------","name":"","description":"","type":"buffer"}]}}