{"Shader":{"ver":"0.1","info":{"id":"4tjXDV","date":"1446927056","viewed":513,"name":"2015\/11\/06","username":"hughsk","description":"This one's a day late <img src=\"\/img\/emoticonHappy.png\"\/> Playing with change over time and ray\/sphere casting.","likes":6,"published":3,"flags":0,"tags":["reactive","light","voxel","audio","fog","progression"],"hasliked":0},"renderpass":[{"inputs":[{"id":35,"src":"\/presets\/mzk06.mp3","ctype":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"float t = iChannelTime[0];\n\nvec2 noiseOffset = vec2(-t * 0.15, 0);\n\nvec2 squareFrame_6_0(vec2 screenSize, vec2 coord) {\n  vec2 position = 2.0 * (coord.xy \/ screenSize.xy) - 1.0;\n  position.x *= screenSize.x \/ screenSize.y;\n  return position;\n}\n\n\n\nmat3 calcLookAtMatrix_8_1(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\n\n\n\nvec3 getRay_7_2(mat3 camMat, vec2 screenPos, float lensLength) {\n  return normalize(camMat * vec3(screenPos, lensLength));\n}\n\nvec3 getRay_7_2(vec3 origin, vec3 target, vec2 screenPos, float lensLength) {\n  mat3 camMat = calcLookAtMatrix_8_1(origin, target, 0.0);\n  return getRay_7_2(camMat, screenPos, lensLength);\n}\n\n\n\n\nvoid orbitCamera_2_3(\n  in float camAngle,\n  in float camHeight,\n  in float camDistance,\n  in vec2 screenResolution,\n  out vec3 rayOrigin,\n  out vec3 rayDirection,\n  in vec2 fragCoord\n) {\n  vec2 screenPos = squareFrame_6_0(screenResolution, fragCoord);\n  vec3 rayTarget = vec3(0.0);\n\n  rayOrigin = vec3(\n    camDistance * sin(camAngle),\n    camHeight,\n    camDistance * cos(camAngle)\n  );\n\n  rayDirection = getRay_7_2(rayOrigin, rayTarget, screenPos, 2.25);\n}\n\n\n\n\/\/\n\/\/ Description : Array and textureless GLSL 2D\/3D\/4D simplex\n\/\/               noise functions.\n\/\/      Author : Ian McEwan, Ashima Arts.\n\/\/  Maintainer : ijm\n\/\/     Lastmod : 20110822 (ijm)\n\/\/     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n\/\/               Distributed under the MIT License. See LICENSE file.\n\/\/               https:\/\/github.com\/ashima\/webgl-noise\n\/\/\n\nvec3 mod289_1_4(vec3 x) {\n  return x - floor(x * (1.0 \/ 289.0)) * 289.0;\n}\n\nvec4 mod289_1_4(vec4 x) {\n  return x - floor(x * (1.0 \/ 289.0)) * 289.0;\n}\n\nvec4 permute_1_5(vec4 x) {\n     return mod289_1_4(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_1_6(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise_1_7(vec3 v)\n  {\n  const vec2  C = vec2(1.0\/6.0, 1.0\/3.0) ;\n  const vec4  D_1_8 = vec4(0.0, 0.5, 1.0, 2.0);\n\n\/\/ First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n\/\/ Other corners\n  vec3 g_1_9 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_1_9;\n  vec3 i1 = min( g_1_9.xyz, l.zxy );\n  vec3 i2 = max( g_1_9.xyz, l.zxy );\n\n  \/\/   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  \/\/   x1 = x0 - i1  + 1.0 * C.xxx;\n  \/\/   x2 = x0 - i2  + 2.0 * C.xxx;\n  \/\/   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; \/\/ 2.0*C.x = 1\/3 = C.y\n  vec3 x3 = x0 - D_1_8.yyy;      \/\/ -1.0+3.0*C.x = -0.5 = -D.y\n\n\/\/ Permutations\n  i = mod289_1_4(i);\n  vec4 p = permute_1_5( permute_1_5( permute_1_5(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n\/\/ Gradients: 7x7 points over a square, mapped onto an octahedron.\n\/\/ The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; \/\/ 1.0\/7.0\n  vec3  ns = n_ * D_1_8.wyz - D_1_8.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  \/\/  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    \/\/ mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  \/\/vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  \/\/vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1_1_10 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0_1_11 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1_1_10.xy,h.z);\n  vec3 p3 = vec3(a1_1_10.zw,h.w);\n\n\/\/Normalise gradients\n  vec4 norm = taylorInvSqrt_1_6(vec4(dot(p0_1_11,p0_1_11), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_1_11 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n\/\/ Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0_1_11,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\n\nfloat orenNayarDiffuse_5_12(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float albedo) {\n  \n  float LdotV = dot(lightDirection, viewDirection);\n  float NdotL = dot(lightDirection, surfaceNormal);\n  float NdotV = dot(surfaceNormal, viewDirection);\n\n  float s = LdotV - NdotL * NdotV;\n  float t = mix(1.0, max(NdotL, NdotV), step(0.0, s));\n\n  float sigma2 = roughness * roughness;\n  float A = 1.0 + sigma2 * (albedo \/ (sigma2 + 0.13) + 0.5 \/ (sigma2 + 0.33));\n  float B = 0.45 * sigma2 \/ (sigma2 + 0.09);\n\n  return albedo * max(0.0, NdotL) * (A + B * s \/ t) \/ 3.14159265;\n}\n\n\nfloat gaussianSpecular_3_13(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float shininess) {\n  vec3 H = normalize(lightDirection + viewDirection);\n  float theta = acos(dot(H, surfaceNormal));\n  float w = theta \/ shininess;\n  return exp(-w*w);\n}\n\n\nfloat fogFactorExp2_4_14(\n  const float dist,\n  const float density\n) {\n  const float LOG2 = -1.442695;\n  float d = density * dist;\n  return 1.0 - clamp(exp2(d * d * LOG2), 0.0, 1.0);\n}\n\n\n\n  \nfloat voxelModel(vec3 p, vec3 ro, vec2 beats) {\n  float d = snoise_1_7(p.xyz * 0.08 + vec3(0, noiseOffset.x, 0));\n  d -= max(0.0, p.y + 6.) * 0.05;\n  return d > 0.0 ? 1.0 : 0.0;\n}\n  \nvec2 raymarchVoxel(vec3 ro, vec3 rd, out vec3 nor, vec2 beats) {\n  vec3 pos = floor(ro);\n  vec3 ri = 1.0 \/ rd;\n  vec3 rs = sign(rd);\n  vec3 dis = (pos - ro + 0.5 + rs * 0.5) * ri;\n  \n  float res = -1.0;\n  vec3 mm = vec3(0.0);\n  \n  for (int i = 0; i < 38; i++) {\n    float k = voxelModel(pos, ro, beats);\n    if (k > 0.5) {\n      res = k;\n      break;\n    }\n     \n    mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\tdis += mm * rs * ri;\n    pos += mm * rs;\n  }\n  \n  if (res < -0.5) {\n    return vec2(-1.0);\n  }\n  \n  nor = -mm * rs;\n  \n  vec3 vpos = pos;\n  vec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n  float t = max(mini.x, max(mini.y, mini.z));\n  \n  return vec2(t, 0.0);\n}\n\nfloat attenuate(float d) {\n  return pow(clamp(1.0 - d \/ 20.0, 0.0, 1.0), 2.95);\n}\n\nfloat intersectRaySphere(vec3 ray, vec3 dir, vec3 center, float radius)\n{\n\tvec3 rc = ray-center;\n\tfloat c = dot(rc, rc) - (radius*radius);\n\tfloat b = dot(dir, rc);\n\tfloat d = b*b - c;\n\tfloat t = -b - sqrt(abs(d));\n\tfloat st = step(0.0, min(t,d));\n\treturn mix(-1.0, t, st);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord.xy \/ iResolution.xy * 2.0 - 1.0;\n  vec3 color = vec3(0, 0, 0);\n  vec3 ro, rd;\n  float fadeIn = clamp(t, 0., 1.);\n  float fadeOut = clamp(73. - t, 0., 1.);\n  float appear1 = clamp(t - 17., 0., 1.0);\n  float appear2 = clamp(t - 1., 0., 1.);\n  float pulse = clamp(t - 51., 0., 0.5) * 2.;\n\n  float rotation = t * 0.134;\/\/ sin(t * 0.124) * 0.3 + iMouse.x \/ iResolution.x * 3.14;\n  float height   = 9.0;\/\/ + (sin(t)) * 3.5;\n  float dist     = 7.1;\n  orbitCamera_2_3(rotation, height, dist, iResolution.xy, ro, rd, fragCoord);\n  \n  ro.z -= t * 5.;\n  ro.y += 12.;\n    \n  vec2 beats = vec2(\n    max(0., texture2D(iChannel0, vec2(0.02)).r),\n    max(0., texture2D(iChannel0, vec2(0.3)).r) * 3.\n  ) * 2.;\n    \n  vec3 lorigin = vec3(ro.x, 19, ro.z) - vec3(sin(rotation), 0, cos(rotation)) * 1.75;\n  vec3 lrotation = (\n      vec3(sin(t), 0, cos(t)) +\n      vec3(sin(t * 0.3), 0, cos(t * 0.3))\n  ) * 0.5;\n  vec3 lpos1 = lorigin + lrotation - vec3(0, 1.5, 0);\n  vec3 lpos2 = lorigin - lrotation;\n  vec3 lcol1 = vec3(4.5, 1.5, 0.4);\n  vec3 lcol2 = vec3(0.4, 3.5, 8.5);\n\n  vec3 nor;\n  vec2 t = raymarchVoxel(ro, rd, nor, beats);\n  float s1 = intersectRaySphere(ro, rd, lpos1, 0.0550 * beats.y * appear1);\n  float s2 = intersectRaySphere(ro, rd, lpos2, 0.0275 * beats.x * appear2);\n  bool si1 = s1 > 0.0 && (s1 < t.x || t.x <= -0.5);\n  bool si2 = s2 > 0.0 && (s2 < t.x || t.x <= -0.5);\n    \n  lcol1 *= beats.x;\n  lcol2 *= beats.y;\n    \n  if (si1 || si2) {\n    color = s1 < s2 ? lcol1 : lcol2;\n  } else\n  if (t.x > -0.5) {\n    vec3 pos = ro + rd * t.x;\n    vec3 mat = abs(fract(pos + 0.5));\n    \n    mat = fract(smoothstep(-0.3, 0.15, mat - 0.5) + 0.5);\n    mat = pow(1.0 - (mat) * 4., vec3(0.8));\n    mat = 1.0 - clamp(vec3(mat.x * mat.y + mat.y * mat.z + mat.x * mat.z), 0.2, 0.35);\n      \n    mat += pulse * (\n        (1.0 - max(0.0, dot(nor, vec3(0, 1, 0)))) *\n        max(0.0, sin(pos.y * 15. + beats.x * 10.)) * vec3(0, 9, 10)\n    );\n      \n    mat = mix(mat, mat * 2., clamp(dot(nor, vec3(0, 1, 0)), 0., 1.));\n      \n    vec3 ldir1 = normalize(lpos1 - pos);\n    float att1 = attenuate(length(lpos1 - pos)) * appear2;\n    float dif1 = orenNayarDiffuse_5_12(ldir1, -rd, nor, 0.3, 3.0);\n    vec3 ldir2 = normalize(lpos2 - pos);\n    float att2 = attenuate(length(lpos2 - pos)) * appear1;\n    float dif2 = orenNayarDiffuse_5_12(ldir2, -rd, nor, 0.3, 3.0);\n    \n    color = mix(color,\n      att1 * lcol1 * dif1 * mat +\n      att2 * lcol2 * dif2 * mat ,\n      1.0 - fogFactorExp2_4_14(t.x, 0.028 - pos.y * 0.001)\n    );\n  }\n\n  color *= fadeIn * fadeOut;\n  color.b += 0.045;\n  color.g += 0.012;\n  color.r += 0.028;\n  color = pow(color, vec3(0.55));\n  color.rg *= 1.0 - dot(uv, uv) * 0.215;\n  fragColor.rgb = color;\n  fragColor.a   = 1.0;\n}","name":"","description":"","type":"image"}]}}