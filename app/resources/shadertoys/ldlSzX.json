{"Shader":{"ver":"0.1","info":{"id":"ldlSzX","date":"1405250870","viewed":3191,"name":"synthetic aperture","username":"FabriceNeyret2","description":"Synthetic aperture tunes sources phase so as to concentrate interferences on a target (emit or ear). ex:MIMO<br\/>Target: mouse.  S or SPACE:  linear\/circular sources distrib.   R: random spacing.    P: dist fading or not<br\/>W: display waves instead of energy. ","likes":34,"published":3,"flags":0,"tags":["interferences"],"hasliked":0},"renderpass":[{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define N 23    \t\/\/ number of sources\n\nint MODE = 5;\t\t\/\/ source distrib\nfloat POW = 1.;\t\t\/\/ fading with distance\n\n\nconst float k = 2.*3.14159\/.04,  \/\/ 2 Pi \/ wavelenght\n\t        c = 0.1;\t\t\t \/\/ wavespeed\n\nfloat t = iGlobalTime;\n\nbool keyToggle(int ascii) {\n\treturn (texture2D(iChannel2,vec2((.5+float(ascii))\/256.,0.75)).x > 0.);\n}\n\nfloat rnd(float i) {\n\treturn mod(4000.*sin(23464.345*i+45.345),1.);\n}\nfloat srnd(float i) { return 2.*rnd(i)-1.; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.*(fragCoord.xy \/ iResolution.y-vec2(.9,.5));\n\n\t\/\/ --- controls\n\n\tvec2 mouse = 2.*(iMouse.xy\/iResolution.y-vec2(.9,.5));\n\tif (iMouse.z<=0.) \n\t\t\tmouse = vec2(1.5*cos(.2345*t)-.7*sin(t),sin(.3214*t)+.5*cos(1.234*t))\/1.5;\n\n\tbool DISPLAY = keyToggle(64+23);  \t\t\t\t\t\/\/ waves vs energy\n\tbool RND = keyToggle(64+18);\t\t\t\t\t\t\/\/ even vs random source distrib\n\tMODE = ( (keyToggle(32)||keyToggle(64+19)) ? 1 : 3 ) + ( (RND) ?0:1); \t\/\/ line or circle source\n\tPOW = (keyToggle(64+16)) ? 0. : 1.; \t\t\t\t\/\/ 1\/r decrease or not\n\t\t\n\t\/\/ --- calc sources contribs\n\t\n\tfloat x = -.75, y=-.7, \n\t\t  xt = x  +((keyToggle(64+20))?.03*t:0.);\n\tconst float step = 1.54\/float(N);\n\t\n\tfloat Phi[N],D2[N];\n\tfor (int i=0; i<N; i++) {\n\t\tvec2 P;\t\/\/ generates sources distribution\n\t\tif \t\t(MODE==1) { P = vec2(x,-.9); x+= step;}\n\t\telse if (MODE==2) { P = vec2(x,-.9); x+= step*(1.+srnd(float(i))); }\n\t\telse if (MODE==3) { P = .99*vec2(sin(4.*xt),-cos(4.*xt)); xt+= step;}\n\t\telse if (MODE==4) { P = .99*vec2(sin(4.*xt),-cos(4.*xt)); xt+= step*(1.+.7*srnd(float(i)));}\n\t\telse if (MODE==5) { P = vec2(2.*x,y); x+= 1.4*sqrt(step); \n\t\t\t\t\t\t    if (x>.7) { x=-.7; y+=sqrt(1.4*step);} }\n\t\t\/\/ the key: wave's phase pixel to source calibrated by wave phase mouse to source\n\t\tfloat dm = length(mouse-P),\tphim = dm, \/\/   -c*t,\n\t\t\t  d  = length(uv-P),\tphi  = d -c*t;\n\t\tPhi[i] = k*(phi-phim);  \/\/ stores wave attributes\n\t\tD2[i] = pow(d,POW);\n\n\t\tif (d<0.01) { fragColor = vec4(0.,0.,1.,0.); return; }\n\t}\n\t\n\t\/\/ --- combines waves or energy\n\t\n\tfloat v = 0.;\n\tif (DISPLAY)   \t\t\t\t\/\/ waves \t\t\n\t\tfor (int i=0; i<N; i++)\n\t\t\tv += cos(Phi[i])\/D2[i];\n\n\t\telse {\t\t\t\t\t\t\/\/ energy . is int_t{ ( sum_i{waves(i,x,t)} )^2 }\n#if 1\n\t\t\tfor (int i=0; i<N; i++) {\n\t\t\t\tfor (int j=0; j<N; j++) \n\t\t\t\t\tv += cos(Phi[j]-Phi[i]) \/ (D2[i]*D2[j]);\t\t\t\n\t\t\t\t\/\/\tif (j<i) v += 2.*cos(Phi[j]-Phi[i]) \/ (D2[i]*D2[j]); \/\/ not faster !\n\t\t\t\t\/\/v += 1.\/ (D2[i]*D2[i]);\n\t\t\t}\n#else\n\t\tfor (int i=0; i<N; i++)\n\t\t\tv += 1.\/ (D2[i]*D2[i]);\n\t\tint i=0, j=N-1;\n\t\tfor (int k=0; k<N*(N-1)\/2; k++) {\n\t\t\tif (i>=j) { i=0; j--; }\n\t\t\tv += 2.*cos(Phi[j]-Phi[i]) \/ (D2[i]*D2[j]);\n\t\t}\t\t\n#endif\t\t\t\n\t\tv = sqrt(v\/2.);\n\t}\n\tv = v*4.5\/float(N);\n\tfragColor = vec4(v,v\/2.,v\/4.,1.);\n}","name":"","description":"","type":"image"}]}}