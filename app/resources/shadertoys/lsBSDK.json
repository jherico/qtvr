{"Shader":{"ver":"0.1","info":{"id":"lsBSDK","date":"1415902084","viewed":1009,"name":"Auto Overstep","username":"eiffie","description":"I've been out of the loop so this has probably been done before (please point me to it!)<br\/>The paper \"Enhanced Sphere Tracing\" describes a simple overstep method that assures no surface is missed. This is the result of my experiments \"improving\" it. <img src=\"\/img\/emoticonHappy.png\"\/>","likes":19,"published":3,"flags":0,"tags":["overstep"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ auto-overstep by eiffie\n\/\/ playing with the overstep method described in the paper...\n\/\/ http:\/\/erleuchtet.org\/~cupe\/permanent\/enhanced_sphere_tracing.pdf\n\/\/ by adding an automated overstep calculation similar to huwb's...\n\/\/ https:\/\/www.shadertoy.com\/view\/Mdj3W3\n\/\/ and bisecting the overstep error until no overstep is found\n\n\/\/ in \"real world\" examples I was able to get a 10% increase in speed by adding\n\/\/ 6 lines of code\n\/\/ in this example I rarely see my \"improvements\" doing better than the method\n\/\/ outlined in the paper\n\n\/\/ comment the following two lines to see the original method\n#define AUTO_OVERSTEP\n#define BISECT_OVERSTEP_ERROR\n\n\n#define size iResolution\n#define time iGlobalTime\nfloat Tube(vec2 pa, vec2 ba){return length(pa-ba*clamp(dot(pa,ba)\/dot(ba,ba),0.0,1.0));}\n\nfloat DE(vec2 pt){\n\tfloat d=100.0,f=0.0005,ft=floor(time*0.2)*1.3;\n\tvec2 p0=vec2(-1.65,-0.6),p1;\n\tfor(int i=0;i<11;i++){\n\t\tp1=p0+vec2(0.3,f+sin(float(i)*1.3+ft)*0.3);\n\t\td=min(d,Tube(pt-p0,p1-p0));\n\t\tp0=p1;f+=f;\n\t}\n\treturn d;\n}\nfloat DE_Circle(vec2 pt, vec2 c, float r){\n\treturn abs(distance(pt,c)-r);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pt=(2.0*fragCoord.xy-size.xy)\/size.y;\n\t\n\tvec3 clr=vec3(1.0);\/\/white background\n\tclr=mix(vec3(0.0),clr,smoothstep(0.0,0.02,DE(pt)));\/\/draw the surface\n\tfloat dR=100.0,dB=100.0,dG=100.0;\n\tvec2 ro=vec2(-1.5,0.0),rd=vec2(1.0,0.0);\/\/this method works the same with vec3\n\tfloat t=0.0;\t\/\/total distance\n\tfloat d=0.0;\t\/\/estimated distance\n\tfloat pd=10.0;\/\/previous estimate\n\tfloat os=0.0;\t\/\/overstep\n\tfloat sf=fract(time*0.2)*0.5;\n\tfor(int i=0;i<10;i++){\/\/march with overstepping\n\t\td=DE(ro+rd*t);\/\/get the distance estimat to surface\n\t\tif(d>os){\t\/\/we have NOT stepped over anything\n\t\t\tdB=min(dB,DE_Circle(pt,ro+rd*t,d));\/\/for drawing only\n\t\t\tdG=min(dG,DE_Circle(pt,ro+rd*t,0.01));\/\/for drawing only\n#ifdef AUTO_OVERSTEP\n\t\t\tos=sf*d*d\/pd;\/\/calc overstep based on ratio of this step to last\n\t\t\tpd=d;\t\/\/save this step length for next calc\n#else\n\t\t\tos=sf*d;\/\/this is the normal overstep outlined in the paper\n#endif\n\t\t\tt+=d+os;\/\/add in the overstep\t\t\n\t\t}else{\t\t\/\/we MAY have stepped over something\n\t\t\tdR=min(dR,DE_Circle(pt,ro+rd*t,d));\/\/for drawing only\n\t\t\tdR=min(dR,Tube(pt-(ro+rd*t),-rd*os)-0.01);\/\/for drawing only\n#ifdef BISECT_OVERSTEP_ERROR\n\t\t\tos*=0.5;\/\/bisect the overstep\n\t\t\tt-=os;\t\/\/and back up\n#else\n\t\t\tt-=os;\t\/\/back up\n\t\t\tos=0.0;\t\/\/and remove overstep\n#endif\n\t\t}\n\t}\n\tclr=mix(vec3(1.0,0.0,0.0),clr,smoothstep(0.0,0.01,dR));\/\/draw overstepped in red\n\tclr=mix(vec3(0.0,1.0,0.0),clr,smoothstep(0.0,0.02,dG));\/\/draw normal march steps in green\n\tclr=mix(vec3(0.0,0.0,1.0),clr,smoothstep(0.0,0.01,dB));\/\/draw understepped in blue\n\tfragColor = vec4(clr,1.0);\n}\n","name":"","description":"","type":"image"}]}}