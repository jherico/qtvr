{"Shader":{"ver":"0.1","info":{"id":"4st3Rn","date":"1447782493","viewed":409,"name":"Flow Of Goods","username":"movAX13h","description":"From one of those superfancy Euclideon videos... https:\/\/youtu.be\/Irf-HJ4fBls?t=184<br\/>I know, I should look into translucent raymarching... feel free to enhance this, if you like.","likes":11,"published":3,"flags":0,"tags":["raymarcher","visualisation"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Flow of goods, fragment shader by movAX13h, Nov.2015\n\n#define SHADOW\n#define EDGES\n#define SUN_POS vec3(15.0, 15.0, -8.0)\n\n#define GAMMA 2.2\n\n\/\/---\nfloat sdBox(vec3 p, vec3 b)\n{\t\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdHexPrism(vec3 p, vec2 h)\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+q.y*0.5,q.y)-h.x);\n}\n\nfloat sdTriPrism(vec3 p, vec2 h)\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nvec2 rotate(vec2 p, float a)\n{\n\tvec2 r;\n\tr.x = p.x*cos(a) - p.y*sin(a);\n\tr.y = p.x*sin(a) + p.y*cos(a);\n\treturn r;\n}\n\n\/\/ globals\nfloat T = iGlobalTime;\nvec3 sun = normalize(SUN_POS);\nconst float focus = 5.0;\nconst float far = 50.0;\nconst vec3 green = vec3(0.2, 1.0, 0.9);\nconst vec3 red = vec3(0.9, 0.3, 0.3);\n\nstruct Hit\n{\n\tfloat d;\n\tvec3 col;\n};\n\nHit scene(vec3 p)\n{\n    Hit hit = Hit(1e6,vec3(0.01));\n    if (p.z > 4.0) return hit;\n    \n    vec3 r = p;\n    float side = sign(p.z);\n\tvec3 c = mix(green,red,side);\n    \n    p.x = mod(-side*p.x-3.0*iGlobalTime,5.5)-2.75;\n\tp.z = mod(p.z, 6.0)-3.0;\n    \n    hit.d = sdBox(p-vec3(0.0, -0.9, 0.0), vec3(8.0, 0.2, 1.3)); \/\/ road\n    float arrow = smoothstep(0.6, 0.65, abs(mod(side*r.x, 2.6)-0.6-abs(p.z)));\n    hit.col = mix(hit.col, green, arrow*(0.4 + max(0.0, 0.6*sin(0.1*r.x+side*4.0*iGlobalTime))));\n    hit.col = mix(hit.col, vec3(1.0), smoothstep(0.5, 1.9, abs(p.z)));\n        \n    float t = sdHexPrism(p-vec3(1.1, -0.1, 0.0), vec2(0.3, 0.3)); \/\/ truck\n    t = min(t, sdBox(p-vec3(0.0, 0.0, 0.0), vec3(0.9, 0.4, 0.4)));\n    t = min(t, sdBox(p-vec3(1.35, -0.3, 0.0), vec3(0.1, 0.2, 0.3)));\n    t = min(t, sdBox(p-vec3(-0.8, -0.3, 0.0), vec3(0.1, 0.2, 0.4)));\n    if (t < hit.d) { hit = Hit(t,vec3(1.0)); }\n    \n    vec3 q = p-vec3(0.19, 0.0, 0.0); \/\/ arrow\n    q.xy = rotate(q.xy, -0.5);\n    t = sdTriPrism(q, vec2(0.2, 0.41));\n    t = min(t, sdBox(p-vec3(-0.14, 0.0, 0.0), vec3(0.25, 0.1, 0.41)));\n    if (t < hit.d) { hit = Hit(t,c); }\n    \n\treturn hit;\n}\n\nvec3 normal(vec3 p)\n{\n\tfloat c = scene(p).d;\n\tvec2 h = vec2(0.01, 0.0);\n\treturn normalize(vec3(scene(p + h.xyy).d - c, \n\t\t\t\t\t\t  scene(p + h.yxy).d - c, \n\t\t                  scene(p + h.yyx).d - c));\n}\n\nfloat edges(vec3 p) \/\/ by srtuss\n{\n\tfloat acc = 0.0;\n\tfloat h = 0.01;\n\tacc += scene(p + vec3(-h, -h, -h)).d;\n\tacc += scene(p + vec3(-h, -h, +h)).d;\n\tacc += scene(p + vec3(-h, +h, -h)).d;\n\tacc += scene(p + vec3(-h, +h, +h)).d;\n\tacc += scene(p + vec3(+h, -h, -h)).d;\n\tacc += scene(p + vec3(+h, -h, +h)).d;\n\tacc += scene(p + vec3(+h, +h, -h)).d;\n\tacc += scene(p + vec3(+h, +h, +h)).d;\n\treturn acc \/ h;\n}\n\nvec3 colorize(Hit hit, vec3 n, vec3 dir, const in vec3 lightPos)\n{\n\tfloat diffuse = 0.3*max(0.0, dot(n, lightPos));\n\t\n\tvec3 ref = normalize(reflect(dir, n));\n\tfloat specular = 0.4*pow(max(0.0, dot(ref, lightPos)), 6.5);\n    \n\treturn (hit.col + \n\t\t\tdiffuse * vec3(0.9) +\n\t\t\tspecular * vec3(1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec2 pos = (fragCoord.xy*2.0 - iResolution.xy) \/ iResolution.y;\n\t\n\tvec3 cp = vec3(15.0, 8.0, -13.0); \n    vec3 ct = vec3(0.0, 0.0, 0.0);\n   \tvec3 cd = normalize(ct-cp);\n    vec3 cu  = vec3(0.0, 1.0, 0.0);\n    vec3 cs = cross(cd, cu);\n    vec3 dir = normalize(cs*pos.x + cu*pos.y + cd*focus);\t\n\t\n    Hit h;\n\tvec3 col = vec3(0.16);\n\tvec3 ray = cp;\n\tfloat dist = 0.0;\n\tvec3 glowCol = vec3(0.0);\n        \n\t\/\/ raymarch scene\n    for(int i=0; i < 60; i++) \n\t{\n        h = scene(ray);\n        \n\t\tif(h.d < 0.0001) break;\n\t\t\n\t\tdist += h.d;\n\t\tray += dir * h.d * 0.9;\n\n        if(dist > far) \n\t\t{ \n\t\t\tdist = far; \n\t\t\tbreak; \n\t\t}\n    }\n\n\tfloat m = (1.0 - dist\/far);\n\tvec3 n = normal(ray);\n\tcol = colorize(h, n, dir, sun)*m;\n\n    #ifdef EDGES\n\tfloat edge = edges(ray);\n    col = mix(col, vec3(0.0), min(0.1*edge, 1.0));\n    #endif\n\t\n\t\/\/ SHADOW with low number of rm iterations (from obj to sun)\n\t#ifdef SHADOW\n\tvec3 ray1 = ray;\n\tdir = normalize(SUN_POS - ray1);\n\tray1 += n*0.002;\n\t\n\tfloat sunDist = length(SUN_POS-ray1);\n\tdist = 0.0;\n\t\n\tfor(int i=0; i < 35; i++) \n\t{\n\t\th = scene(ray1 + dir*dist);\n\t\tdist += h.d;\n\t\tif (abs(h.d) < 0.001) break;\n\t}\n\n\tcol -= 0.24*smoothstep(0.5, -0.3, min(dist, sunDist)\/max(0.0001,sunDist));\n\t#endif\n    \n\tcol -= 0.2*smoothstep(0.0,2.0,length(pos));\n\tcol = clamp(col, vec3(0.0), vec3(1.0));\n\tcol = pow(col, vec3(2.2, 2.4, 2.3)) * 2.1;\n\tcol = pow(col, vec3(1.0 \/ GAMMA));\n    \n\tfragColor = vec4(col, 1.0);\n}\n","name":"","description":"","type":"image"}]}}