{"Shader":{"ver":"0.1","info":{"id":"ltSGRw","date":"1427546751","viewed":717,"name":"Permutations","username":"baldand","description":"All 40320 permutations of 8 items. Takes about 10 minutes.<br\/><br\/>Each row has a different combination (permutation) of the same 8 items. ","likes":1,"published":3,"flags":0,"tags":["2d","permutations"],"hasliked":0},"renderpass":[{"inputs":[{"id":6,"src":"\/presets\/tex05.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":7,"src":"\/presets\/tex06.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Permutations \n\/\/ Copyright (c) Andrew Baldwin 2015\n\/\/ This work is licensed under a Creative Commons Attribution 4.0 International License.\n\n\/*\nCalculation permuted value a from o items\nwith permutation number p\np has up to 16 values each mod(index+2)\nThis can calculate unique permutations for up to 17 items\n17! (355,687,428,096,000) combinations\nHere we only use 8 items\n*\/\nfloat perm(mat4 p,float a,float o) {\n    float sa = floor(a)+1.;\n    float fi = 0.;\n    for (int y=0;y<4;y++) {\n        for (int x=0;x<4;x++) {\n            int i = y*4+x;\n            fi = float(i);\n            if (fi>(o-3.0)) {\n                sa = floor(mod(p[y][x]+sa,o));\n                break;\n            }\n        \tsa = (1.0+floor(mod(fi + p[y][x] + sa,fi+2.0)))\n                *step(o-2.0-fi,a);\n        }\n        if (fi>(o-3.0)) break;\n    }\n    return sa;\n}\n\nvec4 colour(float index) {\n    float blue = mod(index,2.0);\n    float green = mod(floor(index*0.5),2.0);\n    float red = mod(floor(index*0.25),2.0);\n    return vec4(red,green,blue,1.0);    \n}\n\nvec4 tilecolour(vec2 block) {\n    vec4 v = vec4(0,0,0,0);\n    mat4 p; p[0]=v;p[1]=v;p[2]=v;p[3]=v; \n    p[0][0]=mod(floor(block.y),2.);\n    p[0][1]=mod(floor(block.y\/2.),3.);\n    p[0][2]=mod(floor(block.y\/6.),4.);\n    p[0][3]=mod(floor(block.y\/24.),5.);\n    p[1][0]=mod(floor(block.y\/120.),6.);\n    p[1][1]=mod(floor(block.y\/720.),7.);\n    p[1][2]=mod(floor(block.y\/5040.),8.);\n    float index = block.x;\n    float permindex = perm(p,index,8.);\n    vec4 stone = (0.9+0.1*texture2D(iChannel1,block*.1));\n\treturn (0.2+0.8*colour(permindex))*stone;\n}\n\nvec4 tile(vec2 block) {\n    vec2 intile = fract(block);\n    float l = length(2.0*(intile-0.5));\n    float ls = 1.0-length(2.0*(intile-0.5)-.1);\n    float s = max(intile.x+intile.y,0.);\n    vec4 c = tilecolour(block)*(1.2-l*s);\n    c.a = smoothstep(0.85,0.9,l);\n    c = mix(c,vec4(0.,0.,0.,.5+.5*smoothstep(.3,.0,ls)),c.a);\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.x;\n    vec2 block = (uv*8.0);\n    block.y = block.y;\n    block = (block + vec2(0.,iGlobalTime*100.-1000.0*sin(iGlobalTime*.1)));\n    float speed = 1.-cos(iGlobalTime*.1);\n    vec4 m = vec4(0.);\n    for (int i=0;i<10;i++) {\n        vec2 s = vec2(0.,float(i)*speed*.05);\n\t    vec4 t = tile(block+s);\n\t    vec4 b = texture2D(iChannel0,(block+s)*.2);\n        m += mix(t,b,t.a);\n    }\n    fragColor = m*.1;\n}","name":"","description":"","type":"image"}]}}