{"Shader":{"ver":"0.1","info":{"id":"MlsGRl","date":"1424445730","viewed":880,"name":"Descending Splats","username":"eiffie","description":"Choose a few random splats and reposition them in front of the ray using gradient descent. The idea seems sound - the implementation not so much.","likes":7,"published":3,"flags":0,"tags":["splats","parametericsurface"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/Descending Splats by eiffie\n\n\/\/more splats will give better coverage near intersections\n#define SPLATS 10\n\/\/more \"gradient descent\" steps fill in the surfaces\n#define DESCENT 10\n\n\/\/total map calls = SPLATS x DESCENT x 3\n\n\/\/if you want to watch the descent\n#define WATCH\n\nfloat SphereD(vec3 po, vec3 rd){\n\tfloat b=dot(po,rd);\n\treturn sqrt(abs(dot(po,po)-b*b));\n}\n\nvec3 sphere( in vec2 t )\n{\n     vec2 q = vec2( t.x*3.1416, acos(t.y) );\n     return vec3( cos(q.x)*sin(q.y), t.y, sin(q.x)*sin(q.y) );\n}\nvec3 cylinder( in vec2 t )\n{\n    float q = t.x*3.1416;\n    return vec3( 0.5*cos(q), t.y, 0.5*sin(q) );\n}\nvec3 quad( in vec2 t )\n{\n    return vec3( t.x, 0.0, t.y );\n}\n\nfloat DE(in vec2 t, in vec3 ro, in vec3 rd){\n\tvec3 s=sphere(t),c=cylinder(t)+vec3(2.0,0.0,0.0),q=2.0*quad(t)+vec3(0.75,-1.0,0.0);\n\treturn min(SphereD(s-ro,rd),min(SphereD(c-ro,rd),SphereD(q-ro,rd)));\n}\nvec2 rnd2(vec2 c){\n\treturn vec2(fract(sin(c.x+c.y+c.x*c.y)*415.231),fract(sin(c.x-c.y-c.x*c.x+c.y*c.y)*113.2537))*2.0-1.0;\n}\n\nmat3 lookat(vec3 fw){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0.0,1.0,0.0)));return mat3(rt,cross(rt,fw),fw);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec3 ro=vec3(sin(iGlobalTime)*5.0,1.0+sin(iGlobalTime*0.7)*0.75,cos(iGlobalTime)*5.0);\n\tvec3 rd=lookat(vec3(1.0,0.0,0.0)-ro)*normalize(vec3((2.0*fragCoord.xy-iResolution.xy)\/iResolution.y,2.0));\n\t\/\/ro=eye;rd=normalize(dir);\n\tfloat d=100.0;\n  for(int j=0;j<SPLATS;j++){\n      float fj=float(j);\n\tvec2 t=rnd2(fragCoord.xy+vec2(fj,fj*3.1))*0.8,dt=rnd2(fragCoord.yx+vec2(fj*1.3,fj*5.1))*0.05,ff=vec2(0.43);\n#ifdef WATCH\n\tt=rnd2(vec2(fj,fj*3.1))*0.8;dt=rnd2(vec2(fj*1.3,fj*5.1))*0.05;ff=vec2(0.43);\n#endif\n\n\t\/*float d1=DE(t,ro,rd),d2;\n\tfor(int i=0;i<DESCENT;i++){\n\t\tt.x+=dt.x;\n\t\tt.x=clamp(t.x,-1.0,1.0);\n\t\td2=DE(t,ro,rd);\n\t\td=min(d,d2);\n\t\tfloat g=clamp(dt.x\/(d1-d2),-1.0,1.0);\n\t\tdt.x=ff.x*g*d2;\n\t\td1=d2;\n\t\tt.y+=dt.y;\n\t\tt.y=clamp(t.y,-1.0,1.0);\n\t\td2=DE(t,ro,rd);\n\t\td=min(d,d2);\n\t\tg=clamp(dt.y\/(d1-d2),-1.0,1.0);\n\t\tdt.y=ff.y*g*d2;\n\t\td1=d2;\n\t}*\/\n      for(int i=0;i<DESCENT;i++){\/\/a more legit descent but uses more DE checks\n            float d1=DE(t,ro,rd);\n            d=min(d,d1);\n            vec2 d2=vec2(DE(t+vec2(dt.x,0.0),ro,rd),DE(t+vec2(0.0,dt.y),ro,rd));\n            dt=ff*log(d2+1.0)*clamp(dt\/(vec2(d1)-d2),-1.0,1.0);\n            t=clamp(t+dt,-1.0,1.0);\n      }\n  }\n\td=smoothstep(0.0,0.1,d);\n\tvec3 col=vec3(sqrt(d),d*d,d);\n\tfragColor = vec4(col,1.0);\n}\n","name":"","description":"","type":"image"}]}}