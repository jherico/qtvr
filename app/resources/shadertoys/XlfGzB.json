{"Shader":{"ver":"0.1","info":{"id":"XlfGzB","date":"1422809344","viewed":779,"name":"Attack of the Smarties","username":"GrosPoulet","description":"Shadertoy rocks :-)","likes":4,"published":3,"flags":0,"tags":["pixelate","fordcircles","smarties"],"hasliked":0},"renderpass":[{"inputs":[{"id":8,"src":"\/presets\/tex07.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Variation on Ford's Circles stuff: http:\/\/nrich.maths.org\/6594\n\/\/ Inspired by Sarconix: https:\/\/www.shadertoy.com\/view\/4dsXWs\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ defines\n\/\/ Diameter of biggest circle\n#define DIAMETER 100.0\n\/\/ Nb of iterations = nb of circles of decreasing size to build\n#define ITERATIONS 50\n\/\/ Time in second(s) to zoom in or out\n#define ZOOM_TIME 10.0\n\/\/ Heightmap coef [0.0 100.0]\n#define HEIGHT_COEF 4.0\n\/\/ Light direction\n#define LIGHT_DIR vec3(1.0, 1.0, 1.0) \n\/\/ Ambiant lighting\n#define LIGHT_AMBIANT vec3(0.1, 0.1, 0.1)\n\/\/ Mix between original texture\/procedural circles [0.0 1.0]\n#define MIX_FACTOR 0.5\n\/\/ Point of view\n#define EYE vec3(0.57735, 0.57735, 0.57735)\n\/\/ Strength of specular reflection [0.0 1.0]\n#define SPEC_FACTOR 0.45\n\n#define pi 3.1415926535897932384626433832795\n#define hfpi 1.5707963267948966192313216916398\n#define PI pi\n#define HFPI hfpi\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ methods\n\/\/ Most important method: Ford\n\nfloat AnimateDiameter()\n{\n    float i = floor(iGlobalTime \/ ZOOM_TIME);\n    float r = (iGlobalTime - ZOOM_TIME * i) \/ ZOOM_TIME;\n    float sinr = pow(sin(HFPI * r), 2.0);\n    float k = ( mod(i, 2.0) == 0.0 ? sinr : 1.0 - sinr );\n \treturn max(k*DIAMETER, 1.0);\n}\n\n\/\/ Compute normal at position pos, as if we were on an half-sphere with center (0,0)\nvec3 ComputeNormal(vec2 pos, float radius)\n{\n    \/\/ Determine the distance to the center of the circle.\n\tfloat d = length(pos);\n\tfloat h = sqrt(radius*radius - d*d);\n\treturn (normalize(vec3(pos.x,pos.y,HEIGHT_COEF*h)));\n}\n\nvec3 Ford(vec2 posSample)\n{   \n    float diameter = AnimateDiameter();\n    float radius = diameter \/ 2.0;\n    \n    vec2 screenPos = posSample*iResolution.xy - (iResolution.xy \/ 2.0);\n    \n    \/\/position of sample relative to circle: (0,0) = center\n\tvec2 pos = vec2(0.0);\n    \n    bool inside = false; \/\/true iff sample is in a circle\n\tfloat rSmall = 0.0;\n    \n    \/\/ Build biggest circles of radius: r0\n\tfloat r0 = radius;\n\tpos = mod(screenPos, vec2(diameter, diameter)) - vec2(r0, r0);\n\tif (length(pos) < r0)\n\t{\n\t\tinside = true;\n\t\trSmall = r0;\n\t}\n    \n    \/\/ Build smaller circles surrounded by 4 big circles\n    float r1 = 0.0;\n\tvec2 mod1 = vec2(0.0);\n\tif (!inside)\n\t{\n        mod1 = mod(screenPos + vec2(r0, r0), vec2(diameter, diameter)) - vec2(r0, r0);\n\t\tr1 = (sqrt(2.0) - 1.0)*r0;\n\t\tpos = mod1;\n\t\tif (length(pos) < r1)\n\t\t{\n\t\t\tinside = true;\n\t\t\trSmall = r1;\n\t\t}\n\t}\n    \n    \/\/ Iterations - begin\n\t\/\/ We build circles smaller at each iteration\n\t\/\/ radius r[n] of nth circle is given by:\n\t\/\/\n\t\/\/            (r[0] - r[1] - 2*r[2] - ... - 2*r[n-1])^2      \n\t\/\/ r[n] = ----------------------------------------------------\n\t\/\/         2 * (r[0] + r[0] - r[1] - 2*r[2] - ... - 2*r[n-1])\n\t\/\/\n\t\/\/ \n\t\n\tif (!inside)\n\t{\n\t\tfloat rBig = 0.0;\n\t\tfloat distLeft = r0 - r1; \/\/distance to 2 big circles point-of-contact\n\t\tfloat r = r1; \/\/radius of current circle\n\t\t\n\t\tfor (int n=0; n<ITERATIONS; n++)\n\t\t{\t\t\n\t\t\tif (!inside)\n\t\t\t{\n\t\t\t\trSmall = (distLeft - 2.0*rBig)*(distLeft - 2.0*rBig)\/(2.0*(r0 + distLeft - 2.0*rBig));\t\n\t\t\t\n\t\t\t\t\/\/West\n\t\t\t\tpos = mod1 + vec2(rBig + rSmall + r, 0.0);\n\t\t\t\tif (length(pos) < rSmall)\n\t\t\t\t{\n\t\t\t\t\tinside = true;\n\t\t\t\t}\n\t\t\t\tif (!inside)\n\t\t\t\t{\n\t\t\t\t\t\/\/East\n\t\t\t\t\tpos = mod1 - vec2(rBig + rSmall + r, 0.0);\n\t\t\t\t\tif (length(pos) < rSmall)\n\t\t\t\t\t{\n\t\t\t\t\t\tinside = true;\n\t\t\t\t\t}\t\n\t\t\t\t\tif (!inside)\n\t\t\t\t\t{\n\t\t\t\t\t\t\/\/North\n\t\t\t\t\t\tpos = mod1 - vec2(0.0, rBig + rSmall + r);\n\t\t\t\t\t\tif (length(pos) < rSmall)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tinside = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!inside)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\/\/South\n\t\t\t\t\t\t\tpos = mod1 + vec2(0.0, rBig + rSmall + r);\n\t\t\t\t\t\t\tif (length(pos) < rSmall)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tinside = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\/\/updates for next iteration\n\t\t\t\tr = r + rBig + rSmall;\n\t\t\t\tdistLeft = distLeft - 2.0*rBig;\n\t\t\t\trBig = rSmall;\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\/\/ Iterations - end\n    \n\t\/\/ Now we're done with building circles, we give them some 3d look & feel\t\n        \n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ post-production\n    \n    \/\/heightmap\n    vec3 normal = vec3(0.57735);\n    vec2 centerC = vec2(0.0);\n    float distance2center = radius;\n    if (inside)\n\t{\n\t\tcenterC = posSample - pos\/iResolution.xy;\n\t\tdistance2center = length(pos) + r0;\n\t\tnormal = ComputeNormal(pos, rSmall);\n\t}\n    \n    \/\/sample texture using coordinates of circle's center\n    \/\/ NOTE: Use a large negative bias to effectively disable mipmapping, which would otherwise lead\n    \/\/ to sampling artifacts where the UVs change abruptly at the pixelated block boundaries.\n    centerC.y = 1.0 - centerC.y; \/\/upside-down correction\n\tvec3 colTex = texture2D(iChannel0, centerC, -32.0).rgb;        \n\t\n\tvec3 light = normalize(LIGHT_DIR);\n\t\n\t\/\/ Point light\n    vec3 colProc = vec3(0.8, 0.8, 0.8) * clamp(dot(normal, light), 0.0, 1.0);\n\n\t\/\/ Ambiant ligth\n    colProc += LIGHT_AMBIANT;\n\t\t\t\n\tvec3 colFinal = mix(colTex, colProc, MIX_FACTOR);\t\n\t\n\t\/\/ Reflection\n\tvec3 eye = normalize(EYE);\n    vec3 ref = reflect(eye, normal);\n        \n    \/\/ Specular\n    float spec = pow(clamp(dot(light, ref), 0.0, 1.0), 16.0);\n    colFinal += SPEC_FACTOR * spec;\t\n\t\n\t\t\n    \/\/ Set the final fragment color.\n\treturn colFinal;\n} \n\n\/\/ Sample a procedural texture (anti-aliasing)\n\/\/ Stolen from IQ: https:\/\/www.shadertoy.com\/view\/MdjGR1\nvec3 FordAA( vec2 uv )\n{\n\t#define SAMPLING_STRENGTH 1000000000.0\n\t#define NB_SAMPLES 3 \/\/0: no anti-aliasing\n\t\n\tif (NB_SAMPLES == 0)\n\t{\n\t\treturn Ford( uv );\n\t}\n\telse\n\t{\n\t\t\/\/ calc texture sampling footprint\t\t\n\t\tvec2 ddx = dFdx( uv ); \n\t\tvec2 ddy = dFdy( uv ); \n\t\n\t\tint sx = 1 + int( clamp( SAMPLING_STRENGTH*length(ddx), 0.0, float(NB_SAMPLES-1) ) );\n\t\tint sy = 1 + int( clamp( SAMPLING_STRENGTH*length(ddy), 0.0, float(NB_SAMPLES-1) ) );\n\n\t\tvec3 no = vec3(0.0);\n\n\t\tfor( int j=0; j<NB_SAMPLES; j++ )\n\t\tfor( int i=0; i<NB_SAMPLES; i++ )\n\t\t{\n\t\t\tif( j<sy && i<sx )\n\t\t\t{\n\t\t\t\tvec2 st = vec2( float(i), float(j) ) \/ vec2( float(sx),float(sy) );\n\t\t\t\tno += Ford( uv + st.x*ddx + st.y*ddy );\n\t\t\t}\n\t\t}\n\n\t\treturn no \/ float(sx*sy);\n\t}\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;   \n   \n    \/\/pan\n  \tuv -= iMouse.xy \/ iResolution.xy;\n\t\t\n\tvec3 col = FordAA( uv );\n\t\n    \/\/ Set the final fragment color.\n\tfragColor = vec4(col,1.0);\n}","name":"","description":"","type":"image"}]}}