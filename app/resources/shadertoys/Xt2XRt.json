{"Shader":{"ver":"0.1","info":{"id":"Xt2XRt","date":"1445882650","viewed":441,"name":"infinite circle pattern","username":"erkaman","description":"a simple circle pattern.","likes":2,"published":3,"flags":0,"tags":["2d","circle","pattern"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Eric Arneb\u00e4ck - erkaman\/2015\n\/\/ This work is licensed under a \n\/\/ Creative Commons Attribution 4.0 International License\n\n\/*\nThis simple shader draws a circular pattern.\n*\/\n\n#define R 0.1\n#define r 0.00005\n\n\nfloat rand(float co){\n    return fract(sin(dot(vec2(co ,co ) ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nint rand_range_int(float seed, float low, float high) {\n\treturn int(low + (high - low) * rand(seed));\n}\n\n\/\/ set union.\nfloat un(float c1, float c2) {\n    return min(c1,c2);\n    \n}\n\nfloat circleNE(vec2 q, vec2 pos ) {\n    vec2 p = q - pos;\n    \n    if(p.x > 0.0 && p.y > 0.0) {\n        return pow(R - sqrt(p.x*p.x + p.y*p.y ), 2.0) - r;\n    } else {\n        return 10.0;\n    }\n}\n\nfloat circleNW(vec2 q, vec2 pos ) {\n    vec2 p = q - pos;\n    \n    if(p.x < 0.0 && p.y > 0.0) {\n        return pow(R - sqrt(p.x*p.x + p.y*p.y ), 2.0) - r;\n    } else {\n        return 10.0;\n    }\n}\n\nfloat circleSW(vec2 q, vec2 pos ) {\n    vec2 p = q - pos;\n    \n    if(p.x < 0.0 && p.y < 0.0) {\n        return pow(R - sqrt(p.x*p.x + p.y*p.y ), 2.0) - r;\n    } else {\n        return 10.0;\n    }\n}\n\nfloat circleSE(vec2 q, vec2 pos ) {\n    vec2 p = q - pos;\n    \n    if(p.x > 0.0 && p.y < 0.0) {\n        return pow(R - sqrt(p.x*p.x + p.y*p.y ), 2.0) - r;\n    } else {\n        return 10.0;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy \/ iResolution.xy;\n    \n    \/\/ make all coordinates positive. This simplifies things a lot. \n    p += vec2(0.5);\n    \n   \n    p += iGlobalTime * vec2(0.2) + 0.45*sin(1.0*iGlobalTime) * vec2(-0.2, 0.2);\n\n    \n    p.x *= iResolution.x\/iResolution.y;\n  \n    vec3 col = vec3(0.0,0.0,0.0); \/\/ black background color. \n\n    vec2 q = p - vec2(0.5,0.5);\n   \n    float c1;\n    float c2;\n    \n    \n    \/\/ the pattern is created by first laying out lots of \n    \/\/ 2D toruses in a grid formation, thus creating a very regular\n    \/\/ pattern. \n    \/\/ Segments are then  randomly  removed from the toruses to create the\n    \/\/ pattern seen on the screen.\n    \n    vec2 grid = vec2( int(q.x\/(2.0*(R+r))),int(q.y\/(2.0*(R+r))));\n    \n    \n    vec2 cp = vec2(grid*(2.0*(R+r)) + (R+r));   \/\/  vec2(-0.2,0.0);\n     \n    c1 = 1.0;\n    \n    \/\/ every torus consists of four segments.\n    \/\/ NE = North east\n    \/\/ NW = North west\n    \/\/ SW = south west\n    \/\/ SE = south east.\n    c2 = circleNE(q, cp);\n    c1 = un(c1, c2);\n           \n    c2 = circleNW(q, cp);             \n    c1 = un(c1, c2);\n       \n    c2 = circleSW(q, cp);           \n    c1 = un(c1, c2);   \n    \n    c2 = circleSE(q, cp);            \n    c1 = un(c1, c2);\n      \n    \n    if(mod(grid.x, \n           float(rand_range_int((grid.x+grid.y)*2.32, 1.0, 4.0))) != 0.0 ) {\n    \n    c2 = circleSW(q, cp +vec2(R,R));             \n    c1 = un(c1, c2);\n    }\n    \n    if(mod(grid.x+grid.y, \n           float(rand_range_int((grid.x+grid.y)*2.32, 5.0, 10.0))) != 0.0 ) {\n    \n    c2 = circleNW(q, cp +vec2(R,-R));            \n    c1 = un(c1, c2); \n    }\n\n    \n    if(mod(grid.y, \n           float(rand_range_int((grid.x+grid.y)*32.113212, 3.0, 8.0))) != 0.0 ) {\n    \n    c2 = circleNE(q, cp +vec2(-R,-R));            \n    c1 = un(c1, c2);\n    }\n        \n    \n    if(mod(grid.y+grid.x, \n           float(rand_range_int((grid.x+grid.y)*131.113212, 1.0, 4.0))) != 0.0 ) {\n    \n    c2 = circleSE(q, cp +vec2(-R,R));            \n    c1 = un(c1, c2);\n    }\n\n   \n    float res = smoothstep(0.00009, 0.0,c1  );\n   \n    \/\/ noise texture over torus. \n    col += texture2D(iChannel0, p * 0.9).rrr * res;\n    \n    \n    fragColor = vec4(col,1.0);\n    \n}","name":"","description":"","type":"image"}]}}