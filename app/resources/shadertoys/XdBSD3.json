{"Shader":{"ver":"0.1","info":{"id":"XdBSD3","date":"1416287460","viewed":1000,"name":"Useless Box","username":"movAX13h","description":"Alien examining human technology; Mouse enabled; SFX by srtuss.","likes":13,"published":3,"flags":0,"tags":["reflection","raymarch","shadow","hand"],"hasliked":0},"renderpass":[{"inputs":[{"id":24,"src":"\/presets\/cube02_0.jpg","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Useless Box, fragment shader by movAX13h, Nov. 2014\n\n#define ALIENHAND\n#define LID\n#define FLOOR\n\/\/#define FLOOR2\n#define SWITCH\n#define THING\n\n#define SHADOW\n#define REFLECTION\n\n\/\/ --\n#define resolution iResolution\n#define mouse iMouse\n\n#define pi2 6.2831853071795\n#define pih 1.5707963267949\n\n\nfloat rand(float x)\n{\n    return fract(sin(x) * 4358.5453123);\n}\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5357);\n}\n\nfloat rand(vec3 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5357 * co.z);\n}\n\nfloat sdBox( vec3 p, vec3 b ) \n{\t\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox(vec3 p, vec3 b, float r)\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdSegment(vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n\treturn length(p)-r;\n}\n\nfloat sdCappedCylinderZ( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedCylinderY(vec3 p, vec2 h)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\nvec2 rotate(vec2 p, float a, vec2 offset)\n{\n    p += offset;\n\tvec2 r;\n\tr.x = p.x*cos(a) - p.y*sin(a);\n\tr.y = p.x*sin(a) + p.y*cos(a);\n    r -= offset;\n\treturn r;\n}\n\nfloat opS(float d1, float d2)\n{\n    return max(-d1,d2);\n}\n\nfloat opI(float d1, float d2)\n{\n    return max(d1,d2);\n}\n\n\/\/ polynomial smooth min (k = 0.1); by iq\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5+0.5*(b-a)\/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat time = iGlobalTime + 7.0;\nvec3 sunPos = vec3(10.0, 15.0, -10.0);\nvec3 sun = normalize(sunPos);\nfloat focus = 9.0+2.0*cos(0.35*time);\nfloat far = 30.0;\n\nstruct Hit\n{\n\tfloat d;\n\tvec3 color;\n\tfloat ref;\n\tfloat spec;\n};\n\n#define fingerStart(a,b,c) from=vec3(a, b, c)\n#define seg(t,r) d=smin(d,sdSegment(p, from, t, r), 0.06); from=t\n#define seg2(t,r,s) d=smin(d,sdSegment(p, from, t, r), s); from=t\nfloat alienHand(vec3 p, float cycle)\n{\n    p.x -= 0.2*cycle;\n    p.xy = rotate(p.xy, -0.5+cycle*0.2, vec2(0.0));\n\tp.z *= 0.8;\n    p.y += 0.01*sin(time);\n    \n    float a1 = sin(3.6*time);\n    float a2 = sin(0.7*time+1.333)*a1;\n    \n    float a1s = 0.02*a1;\n    float a2s = 0.05*a2;\n    \n\tvec3 from, to;\n\tfloat d = 1.0e6;\n\t\n\t\/\/ ringfinger\n\tfingerStart(0.4+0.7*a2s, -0.65+a1s, -0.1);\n\tseg(vec3(0.6, -0.35+a1s, -0.1), 0.06);\n\tseg(vec3(1.1, -0.1, -0.1), 0.065);\n\tseg(vec3(2.0, -0.24, -0.07), 0.08);\n\t\n\t\/\/ pinky\n\tfingerStart(0.75+a2s, -0.95+a1s, -0.2);\n\tseg(vec3(0.85, -0.5+a1s, -0.21), 0.05);\n\tseg(vec3(1.18, -0.23, -0.18), 0.06);\n\tseg(vec3(2.0, -0.24, -0.09), 0.07);\n\t\n\t\/\/ thumb\n\tfingerStart(1.0, -0.5, 0.26);\n\tseg(vec3(1.3, -0.2, 0.27), 0.07);\n\tseg(vec3(1.65, -0.2, 0.18), 0.08);\n\tseg(vec3(2.0, -0.2, 0.1), 0.09);\n\t\n\t\/\/ arm\n\tfrom = vec3(1.6, -0.2, 0.0);\n\tseg2(vec3(4.0, -1.2, 0.0), 0.08, 0.3);\n\tseg(vec3(2.0, -0.3, 0.05), 0.14);\n\n\t\/\/ pointer\n\tfingerStart(0.0, 0.5*a1s, 0.0);\n\tseg(vec3(0.5, 0.08+0.3*a1s, 0.02), 0.06);\n\tseg(vec3(1.1, -0.03+abs(0.2*a1s), 0.04), 0.07);\n\tseg(vec3(2.0, -0.2, 0.06), 0.07);\n    \n\treturn d;\n}    \n    \nHit scene(vec3 p)\n{\n    \/\/p.xz = mod(p.xz, 3.0)-1.5;\n    \n\tvec3 q = p;\n    float t = 1.5*time;\n\tfloat cycle = max(0.0, sin(t)-0.3);\n    \n\tHit h = Hit(1.0e6, vec3(0.0,0.1,0.3), 0.1, 0.2);\n\n\t\/\/ box\n\tfloat a = opS(sdBox(p, vec3(0.5, 0.3, 0.14)), sdBox(p, vec3(1.0, 0.5, 0.75)));\n\tfloat b = sdBox(p-vec3(-0.8, 0.54, 0.0), vec3(0.8, 0.4, 0.8));\n\th.d = opS(b, a);\n\n\t\/\/ lid\n\t#ifdef LID\n\tq = p;\n\tq.xy = rotate(q.xy, -max(0.004, 0.2*smoothstep(0.0, 0.3, cycle)), vec2(1.0, -0.11));\n\t\n\ta = sdBox(q-vec3(-0.501, 0.32, 0.0), vec3(0.5, 0.18, 0.75));\n\tb = sdBox(q-vec3(-0.401, 0.26, 0.0), vec3(0.46, 0.2, 0.71));\n\th.d = min(h.d, opS(b, a));\n\t#endif\n\t\n\t\/\/ thing\n    #ifdef THING\n\tq = p;\n\tq.xy = rotate(q.xy, -abs(1.26*smoothstep(0.3, 0.5, 1.0-cycle)), vec2(-0.1, -0.2));\n\t\n\ta = opS(sdCappedCylinderZ(q-vec3(0.1, 0.18, 0.0), vec2(0.4, 0.2)), sdCappedCylinderZ(q-vec3(0.1, 0.18, 0.0), vec2(0.5, 0.08)));\n\tb = sdBox(q-vec3(0.7, 0.36, 0.0), vec3(0.5));\n\th.d = min(h.d, opS(b, a));\n\t#endif\n    \n\t\/\/ switch\n    #ifdef SWITCH\n\tb = sdSegment(p, vec3(0.24, 0.5, 0.0), vec3(0.18+0.14*step(-0.6, sin(t-1.99)), 0.7, 0.0), 0.03);\n\tb = min(b, sdCappedCylinderY(p-vec3(0.24, 0.42, 0.0), vec2(0.1, 0.1)));\n    b = min(b, sdTorus(p-vec3(0.24, 0.525, 0.0), vec2(0.05, 0.018)));\n\t\n\tif (b < h.d) \n\t{\n\t\th.d = b;\n\t\th.color = vec3(0.1);\n\t\th.spec = 0.7;\n\t\th.ref = 0.3;\n\t}\n\t#endif\n    \n    #ifdef ALIENHAND\n    a = alienHand(p-vec3(0.4, 0.71, 0.0), smoothstep(1.0, 0.8, sin(t-4.2)));\n    if (a < h.d)\n    {\n        h.d = a;\n        h.color = vec3(0.4);\n        h.spec = 0.0;\n        h.ref = 0.0;\n    }\n    #endif\n    \n    #ifdef FLOOR\n    \n    #ifdef FLOOR2\n    a = dot(p,vec3(0.0, 1.0, 0.0)) + 0.5;\n    #else\n    a = sdBox(p-vec3(0.0, -0.5, 0.0), vec3(2.0, 0.01, 2.0));\n    #endif\n    if (a < h.d)\n    {\n        h.d = a;\n        #ifdef FLOOR2\n        h.color = vec3(0.5*mod(sin(p.z)-sin(p.x), 0.4)+0.5);\n\t\t\/\/h.color = vec3(0.3+0.5*mod(p.z, 0.4));\n        #else\n        h.color = vec3(0.8);\n\t\t#endif\n        h.spec = 0.2;\n        h.ref = 0.2;\n    }\n    #endif\n    \n\treturn h;\n}\n\nvec3 normal(vec3 p)\n{\n\tfloat c = scene(p).d;\n\tvec2 h = vec2(0.01, 0.0);\n\treturn normalize(vec3(scene(p + h.xyy).d - c, \n\t\t\t\t\t\t  scene(p + h.yxy).d - c, \n\t\t                  scene(p + h.yyx).d - c));\n}\n\n\nvec3 colorize(const vec3 col, const float spec, const vec3 n, const vec3 dir, const in vec3 lightPos)\n{\n\tfloat diffuse = 0.2*max(0.0, dot(n, lightPos));\n\tvec3 ref = normalize(reflect(dir, n));\n\tfloat specular = spec*pow(max(0.0, dot(ref, lightPos)), 3.5);\n\treturn (col + diffuse * vec3(0.9) +\tspecular * vec3(1.0));\n}\n\nvec3 tex3D(vec3 dir)\n{\n    return textureCube(iChannel0, dir).bgr;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec2 pos = (fragCoord.xy*2.0 - resolution.xy) \/ resolution.y;\n\t\n\tfloat d = 9.0;\n\tfloat t = 1.2*sin(time*0.1+35.0) ;\n\tvec3 cp = vec3(d*cos(t), 6.0+sin(0.2*time), d*sin(t)); \/\/ circle center\n    \n\tif (mouse.x > 10.0)\n\t{\n\t\tvec2 mrel = 3.0*(mouse.xy\/resolution.xy-0.5);\n\t\td = 10.0;\n        focus = 9.0 + 4.0*mrel.y;\n\t\tcp = vec3(d*cos(-mrel.x*pih), 6.0, d*sin(-mrel.x*pih));\n\t}\n\t\n    vec3 ct = vec3(0.0, 0.1, 0.0);\n   \tvec3 cd = normalize(ct-cp);\n    vec3 cu  = vec3(0.0, 1.0, 0.0);\n    vec3 cs = cross(cd, cu);\n    vec3 dir = normalize(cs*pos.x + cu*pos.y + cd*focus);\t\n\t\n    Hit h;\n\tvec3 col = vec3(0.16);\n\tvec3 ray = cp;\n\tfloat dist = 0.0;\n\t\n\t\/\/ raymarch scene\n    for(int i=0; i < 60; i++) \n\t{\n        h = scene(ray);\n\t\t\n\t\tif(h.d < 0.0001) break;\n\t\t\n\t\tdist += h.d;\n\t\tray += dir * h.d * 0.8;\n\n        if(dist > far) \n\t\t{ \n\t\t\tdist = far; \n\t\t\tbreak; \n\t\t}\n    }\n\n\tfloat m = (1.0 - dist\/far);\n\tvec3 n = normal(ray);\n\tcol = colorize(h.color, h.spec, n, dir, sun)*m;\n\n\tif (dist < far)\n\t{\t\n\t\t\/\/ MIRROR (from obj to reflected normal direction)\n\t\t#ifdef REFLECTION\n\t\tHit h2;\n\t\tdir = reflect(dir, n);\n\t\tvec3 neb = tex3D(dir);\n\t\t\n\t\tvec3 ray2 = ray + dir*0.008;\n\n\t\tdist = 0.0;\n\t\t\n\t\tfor(int i=0; i < 35; i++) \n\t\t{\n\t\t\th2 = scene(ray2 + dir*dist);\n\t\t\tdist += h2.d;\n\t\t\tif (h2.d < 0.001) break;\n\t\t}\n\n\t\tif (dist > far) col += h.ref*neb;\n\t\telse col += h.ref*colorize(h2.color, h2.spec, normal(ray2+dir*dist), dir, sun)*(1.0 - dist\/far);\n\t\t#endif\t\n\t\t\n\t\t\/\/ HARD SHADOW with low number of rm iterations (from obj to sun)\n\t\t#ifdef SHADOW\n\t\tvec3 ray1 = ray;\n\t\tdir = normalize(sunPos - ray1);\n\t\tray1 += n*0.006;\n\t\t\n\t\tfloat sunDist = length(sunPos-ray1);\n\t\tdist = 0.0;\n\t\t\n\t\tfor(int i=0; i < 35; i++) \n\t\t{\n\t\t\th = scene(ray1 + dir*dist);\n\t\t\tdist += h.d;\n\t\t\tif (abs(h.d) < 0.001) break;\n\t\t}\n\n\t\tcol -= 0.2*smoothstep(0.5, -0.3, min(dist, sunDist)\/max(0.0001,sunDist));\n\t\t#endif\n\t}\n\telse col = tex3D(dir);\n    \n\tcol = clamp(col, vec3(0.0), vec3(1.0));\n\tcol = pow(col, vec3(2.2, 2.4, 2.5)) * 3.7; \/\/ farbton & s\u00e4ttigung\n\tcol = pow(col, vec3(1.0 \/ 2.2)); \/\/ gamma\t\n\t\n\tfragColor = vec4(col, 1.0);\n}\n","name":"","description":"","type":"image"},{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Sound FX by srtuss\n\nfloat hash(float x)\n{\n    return (fract(cos(x * 115.5782) * 1000.0 + sin(x * 0.5782) * 333.333) - 0.5) * 1.0;\n}\n\nfloat nse(float t)\n{\n    float fl = floor(t);\n    return mix(hash(fl), hash(fl + 1.0), smoothstep(0.0, 1.0, fract(t)));\n}\n\nfloat f1(float t, float ts, float tl, float k)\n{\n\tfloat o1 = clamp(t - ts, 0.0, tl);\n\tfloat o2 = max(t - (ts + tl), 0.0);\n\n\treturn o1 * o1 * k \/ (2.0 * tl) + o2 * k;\n}\n\nfloat phase(float t)\n{\n    float p;\n    \n    float tb = 0.0, td = 1.0;\n    float fl = 4.0, fn = 10.6;\n    \n    p = fl * t;\n    p += f1(t, tb, 0.3, fn - fl); fl = fn; tb += 1.0;\n    fn = (10.0);\n    p += f1(t, tb, 0.5, fn - fl); fl = fn; tb += 0.4;\n    fn = (9.3);\n    p += f1(t, tb, 0.5, fn - fl); fl = fn; tb += 1.0;\n    fn = (0.001);\n    p += f1(t, tb, 0.3, fn - fl); fl = fn; tb += 0.3;\n    \n    \n    return p;\n}\n\n\nfloat wf2(float x)\n{\n    return nse(fract((sin(x * 300.0) * 0.001 + x) * 100.0) * 26.0);\n}\n\nfloat nseh(float x, float h)\n{\n    return nse(x + h) - nse(x - h);\n}\n\nfloat click(float x)\n{\n    x *= 1.5;\n    float v;\n    float y = x;\n    y *= 800.0;\n    y = y * y;\n    v = exp(-y) * 0.0;\n    y = x;\n    y *= 5000.0;\n    y = y * y;\n    v += exp(-y) * 0.2;\n    v += nseh(x * 6000.0, 0.1) * exp(-50.0 * max(x, 0.0)) * step(0.0, x) * 0.3;\n    return v;\n}\n\nfloat motor(float x)\n{\n    x = phase(x);\n    return nseh(mod(x, 0.3333) * 5300.0, 0.06) * 0.9 + wf2(x) * 0.3;\n}\n\nvec2 mainSound(float time)\n{\n    float swtime = mod(time - 0.015, 4.1887902047863909846168578443727) - 1.0;\n    float v = click(swtime) + click((swtime - 1.25) * 0.9);\n    \n    v += motor(swtime) * smoothstep(0.6, 1.0, swtime) * smoothstep(0.1 + 2.2, 2.2, swtime) * 0.2;\n    \n    float q = abs(swtime - 0.65);\n    v += nse(swtime * 1000.0) * exp(q * q * -2000.0) * 0.05;\n    q = abs(swtime - 2.2);\n    v += nse(swtime * 1000.0) * exp(q * q * -2000.0) * 0.1;\n    \n    return vec2(v * 1.2);\n}","name":"","description":"","type":"sound"}]}}