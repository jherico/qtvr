{"Shader":{"ver":"0.1","info":{"id":"Msc3z8","date":"1448013358","viewed":573,"name":"Shadering Chameleon V2.0","username":"iapafoto","description":"Antialiasing only on edges - use 2 technics to find inner and outter edge pixels<br\/>Decomment \"#define SHOW_EDGES\" to see where antialiasing is applied<br\/>","likes":32,"published":3,"flags":0,"tags":["cute","mandelbrot","spiral","antialiasing","animation","edge","chameleon"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by sebastien durand - 2015\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/-----------------------------------------------------\n\n\/\/ Change this to improve quality - Rq only applied on edge\n#define ANTIALIASING 5\n\n\/\/ decomment this to see where antialiasing is applied\n\/\/#define SHOW_EDGES\n\n#define RAY_STEP 40\n\/\/#define NOISE_SKIN\n\n#define PI 3.14159279\n\n\nbool WithChameleon;\t    \/\/ for optim : true if the ray intersect the bounding sphere of the chameleon\n\nfloat Anim;\t\t\t\t\/\/ pos in animation\nmat2 Rotanim, Rotanim2, Rot3; \/\/ rotation matrix\nfloat ca3, sa3;         \/\/ pre calculater sin and cos\nfloat closest;\t\t\t\/\/ min distance to chameleon on the ray (use for glow light) \n\n\/\/ ----------------------------------------------------\n\nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\n\n\n#ifdef NOISE_SKIN\n\/\/ By Shane -----\n\n\/\/ Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n    n = max((abs(n) - 0.2)*7., 0.001); \/\/ n = max(abs(n), 0.001), etc.\n    n \/= (n.x + n.y + n.z );  \n    \n\treturn (texture2D(tex, p.yz)*n.x + texture2D(tex, p.zx)*n.y + texture2D(tex, p.xy)*n.z).xyz;\n}\n\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\n    const float eps = 0.001;\n    float ref = (tex3D(tex,  p , nor)).x;                 \n    vec3 grad = vec3( (tex3D(tex, vec3(p.x-eps, p.y, p.z), nor).x)-ref,\n                      (tex3D(tex, vec3(p.x, p.y-eps, p.z), nor).x)-ref,\n                      (tex3D(tex, vec3(p.x, p.y, p.z-eps), nor).x)-ref )\/eps;\n             \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n}\n\n#endif\n\n\n\/\/ ----------------------------------------------------\n\nbool intersectSphere(in vec3 ro, in vec3 rd, in vec3 c, in float r) {\n    ro -= c;\n\tfloat b = dot(rd,ro), d = b*b - dot(ro,ro) + r*r;\n\treturn (d>0. && -sqrt(d)-b > 0.);\n}\n\n\/\/ ----------------------------------------------------\n\nfloat udRoundBox( vec3 p, vec3 b, float r ){\n  \treturn length(max(abs(p)-b,0.))-r;\n}\n\n\/\/ capsule with bump in the middle -> use for arms and legs\nvec2 sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)\/dot(ba,ba), 0., 1. );\n    float dd = cos(3.14*h*2.5);  \/\/ Little adaptation\n    return vec2(length(pa - ba*h) - r*(1.-.1*dd+.4*h), 30.-15.*dd); \n}\n\nvec2 smin(in vec2 a, in vec2 b, in float k ) {\n\tfloat h = clamp( .5 + (b.x-a.x)\/k, 0., 1. );\n\treturn mix( b, a, h ) - k*h*(1.-h);\n}\n\nfloat smin(in float a, in float b, in float k ) {\n\tfloat h = clamp( .5 + (b-a)\/k, 0., 1. );\n\treturn mix(b, a, h) - k*h*(1.-h);\n}\n\nvec2 min2(in vec2 a, in vec2 b) {\n\treturn a.x<b.x?a:b;\n}\n\n\/\/ ----------------------------------------------------\n\nvec2 spiralTail(in vec3 p) {\n    float a = atan(p.y,p.x)+.2*Anim;\n\tfloat r = length(p.xy);\n    float lr = log(r);\n    float th = 0.475-.25*r; \/\/ thickness according to distance\n    float d = fract(.5*(a-lr*10.)\/PI); \/\/apply rotation and scaling.\n\t\n    d = (0.5-abs(d-0.5))*2.*PI*r\/10.;\n  \td *= 1.1-1.1*lr;  \/\/ space fct of distance\n   \n    r+=.05*cos(a*60.); \/\/ radial bumps\n    r+=(.2-.2*(smoothstep(0.,.08, abs(p.z))));\n\n    return vec2(\n        max(max(sqrt(d*d+p.z*p.z)-th*r, length(p.xy-vec2(.185,-.14))-1.05), -length(p.xy-vec2(.4,1.5))+.77),\n        abs(30.*cos(10.*d)) + abs(20.*cos(a*10.)));\n}\n\nvec2 body(in vec3 p) {\n    const float scale = 3.1;\n    \n    p.y=-p.y;\n    p.x += 2.;\n    p\/=scale;\n    \n    float a = atan(p.y,p.x);\n\tfloat r = length(p.xy);\n    float d = (.5*a-log(r))\/PI; \/\/apply rotation and scaling.\n    float th = .4*(1.-smoothstep(.0,1.,abs(a+.35-Anim*.05)));    \n \n    d = (1.-2.*abs(d-.5))*r*1.5;\n    \n   \/\/ r +=.005*cos(80.*d); \/\/ longitudinal bumps\n    r+=.01*cos(a*200.); \/\/ radial bumps\n    r-=.2*(smoothstep(0.,.1,abs(p.z)));\n    \n    float dis = sqrt(d*d+p.z*p.z)-th*r;\n \tdis *= scale;\n    dis = max(dis, length(p.xy-vec2(.86,-.07))-.7);\n    return vec2(dis, abs(30.*cos(17.*d)) + abs(20.*cos(a*20.)));\n}\n\nvec2 head(in vec3 p) {\n \/\/   p.yz *= Rotanim;  \/\/ small rotation of head \n   \n   \n    p.z = abs(p.z);\n    \n    p.y += .25+.03*Anim;\n    p.x += .03+.03*Anim;\n    p.xy *= Rotanim;\n\n    vec3 pa1 = p, ba = vec3(1.,-.2,-.3);\n    pa1.z = p.z-.22;\n    \n    float h = clamp(dot(pa1, ba), 0.0, 1.0 );\n    pa1.x -= h;\n\n    \/\/ Head\n\tfloat dh = length(pa1) - .8*(-.5+1.3*sqrt(abs(cos(1.5701+h*1.5701))))+.08*(1.+h)*smoothstep(0.,.2,abs(p.z));\n    dh = max(-p.y-.2, dh); \n    dh += -.04+.04*(smoothstep(0.,.2,abs(p.z)));\n    dh = min(dh, max(p.x-1.35,max(p.y+.3, length(p-vec3(1.-.035*Anim,.25,-.1))-.85)));\n    dh += .01*cos(40.*h) -.06;\n    \n    \/\/ Eyes\n    vec3 eye = vec3(-.2,-.0105,.15);\n  \teye.zy *= Rotanim2;\n    float de = max(length(p-vec3(.7,.26,.45))-.3, -(length(p-vec3(.7,.26,.45) - eye)-.13*clamp(Anim+.2,.7,1.1)));\n    vec2 dee = min2(vec2(de,20.+1000.*abs(dot(p,eye))), vec2(length(p-vec3(.7,.26,.45))-.2, -102.));\n  \n    return smin(dee, vec2(dh*.8, 40.- abs(20.*cos(h*3.))) ,.06); \n}\n    \nvec2 support(vec3 p, vec2 c, float th) {\n    p-=vec3(-2.5,-.7,0);\n    float d1 = length(p-vec3(0,-6.5,0)) - 3.;          \n    float d = length(max(abs(p-vec3(0,-2,.75))-vec3(.5,2.5,.1),0.))-.11;     \n    p.xy *= Rot3; \n    d = min(d, max(length(max(abs(p)-vec3(4,3,.1),0.))-.1,\n                  -length(max(abs(p)-vec3(3.5,2.5,.5),0.))+.1));\n    return min2(vec2(d1,-105.),\n        min2(vec2(d,-100.), \n                 vec2(length(max(abs(p-vec3(0,0,.2))-vec3(3.4,2.4,.01),0.))-.3, -103.)));\n}\n\n\n\/\/----------------------------------------------------------------------\n\nvec2 map(in vec3 pos) {\n    \/\/ Ground\n    vec2 res1 = vec2( pos.y+4.2, -101.0 );\n    \/\/ Screen\n\tres1 = min2(support(pos+vec3(2.5,-0.56,0), vec2(.1,15.), 0.05), res1);\n    \n    if (WithChameleon) {\n        \/\/ Tail + Body\n        vec2 res = smin(spiralTail(pos.xyz-vec3(0,-.05-.05*Anim,0)), body( pos.xyz-vec3(-.49,1.5,0)),.1 ); \n        \/\/ Head\n        res = smin(res, head(pos - vec3(-2.8,3.65,0)), .5);\n        pos.z = abs(pos.z);\n        \/\/ legs\n        res = min2(res, min2(sdCapsule(pos, vec3(.23,-.1*Anim+1.3,.65), vec3(.75,-.1*Anim+.6,.05),.16),\n                             sdCapsule(pos, vec3(.23,-.1*Anim+1.3,.65), vec3(-.35,1.35,.3),.16)));\n        res = min2(res, vec2(length(pos-vec3(-.35,1.35,.1))- .33, 30.));   \n        \/\/ arms \n        res = smin(res, min2(sdCapsule(pos, vec3(-.8+.06*Anim,2.5,.85),vec3(-1.25+.03*Anim,3.,.2), .16),\n                             sdCapsule(pos, vec3(-.8+.06*Anim,2.5,.85), vec3(-1.25,2.1,.3),.16)),.15);\n        res = min2(res, vec2(length(pos-vec3(-1.55,1.9,.1))- .3, 30.));\n        \n        if (res.x < closest) {\n            closest = abs(res.x);\n        }\n        return min2(res, res1);\n    }\n    else {\n        return res1;\n    }\n}\n\n\n\/\/----------------------------------------------------------------------\n#define EDGE_WIDTH 0.15\n\nvec2 castRay(in vec3 ro, in vec3 rd, in float maxd, inout float hmin) {\n    closest = 9999.; \/\/ reset closest trap\n\tfloat precis = .0006, h = EDGE_WIDTH+precis, t = 2., m = -1.;\n    hmin = 0.;\n    for( int i=0; i<RAY_STEP; i++) {\n        if( abs(h)<t*precis || t>maxd ) break;\n        t += h;\n\t    vec2 res = map(ro+rd*t);\n        if (h < EDGE_WIDTH && res.x > h + 0.001) {\n\t\t\thmin = 10.0;\n\t\t}\n        h = res.x;\n\t    m = res.y;\n    }\n    \n\t\/\/if (hmin != h) hmin = 10.;\n    if( t>maxd ) m = -200.0;\n    return vec2( t, m );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k) {\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<26; i++ ) {\n\t\tif( t>maxt ) break;\n        float h = map( ro + rd*t ).x;\n        res = min( res, k*h\/t );\n        t += h;\n    }\n    return clamp( res, 0., 1.);\n}\n\n\/\/ normal with kali edge finder\nfloat Edge=0.;\nvec3 calcNormal(vec3 p, vec3 rd, float t) { \n    float pitch = .2 * t \/ iResolution.x; \n\tpitch = max( pitch, .015 );\n\n\tvec3 e = vec3(0.0,2.*pitch,0.0);\n\tfloat d1=map(p-e.yxx).x,d2=map(p+e.yxx).x;\n\tfloat d3=map(p-e.xyx).x,d4=map(p+e.xyx).x;\n\tfloat d5=map(p-e.xxy).x,d6=map(p+e.xxy).x;\n\tfloat d=map(p).x;\n    \n\tEdge=abs(d-0.5*(d2+d1))+abs(d-0.5*(d4+d3))+abs(d-0.5*(d6+d5)); \/\/edge finder\n\tEdge=min(1.,pow(Edge,.55)*15.);\n    \n    vec3 grad = vec3(d2-d1,d4-d3,d6-d5);\n\treturn normalize(grad - max(.0,dot (grad,rd ))*rd);\n}\n\n\n\n\nfloat calcAO( in vec3 pos, in vec3 nor) {\n\tfloat totao = 0.0;\n    float sca = 1.0;\n    for( int aoi=0; aoi<5; aoi++ ) {\n        float hr = 0.01 + 0.05*float(aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        totao += -(dd-hr)*sca;\n        sca *= .75;\n    }\n    return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );\n}\n\nvec3 mandelbrot(in vec2 uv, vec3 col) {\n    uv.x += 1.5;\n    uv.x = -uv.x;\n\n    float a=.05*sqrt(abs(Anim)), ca = cos(a), sa = sin(a);\n    mat2 rot = mat2(ca,-sa,sa,ca);\n    uv *= rot;\n\tfloat kk=0., k = abs(.15+.01*Anim);\n    uv *= mix(.02, 2., k);\n\tuv.x-=(1.-k)*1.8;\n    vec2 z = vec2(0);\n    vec3 c = vec3(0);\n    for(int i=0;i<50;i++) {\n        if(length(z) >= 4.0) break;\n        z = vec2(z.x*z.x-z.y*z.y, 2.*z.y*z.x) + uv;\n        if(length(z) >= 4.0) {\n            kk = float(i)*.07;\n            break; \/\/ does not works on some engines !\n        }\n    }\n    return clamp(mix(vec3(.1,.1,.2), clamp(col*kk*kk,0.,1.), .6+.4*Anim),0.,1.);\n}\n\nvec3 screen(in vec2 uv, vec3 scrCol) {\n    \/\/ tv effect with horizontal lines and color switch\n    vec3 oricol = mandelbrot(vec2(uv.x,uv.y), scrCol);\n    vec3 col;\n\tfloat colorShift = .2*cos(.5*iGlobalTime);\n    col.r = mandelbrot(vec2(uv.x,uv.y+colorShift), scrCol).x;\n    col.g = oricol.y;\n    col.b = mandelbrot(vec2(uv.x,uv.y-colorShift), scrCol).z;\n    \n\tuv *= Rot3;\t\n\tcol =(.5*scrCol+col)*(.5+.5*cos(iGlobalTime*5.))*cos(iGlobalTime*10.+40.*uv.y);  \n    return col*col;\n}\n\n\/\/ clean lines on the ground\nfloat isGridLine(vec2 p, vec2 v) {\n    vec2 k = smoothstep(.1,.9,abs(mod(p+v*.5, v)-v*.5)\/.08);\n    return k.x * k.y;\n}\n\nvec3 render( in vec3 ro, in vec3 rd, inout float hmin) { \n    \/\/ Test bounding sphere (optim)\n    WithChameleon = intersectSphere(ro,rd,vec3(-.5,1.65,0),3.15); \/\/2.95);\n    \n    vec2 res = castRay(ro,rd,60.0, hmin);\n    float distCham = abs(closest);\n    \n#ifdef SHOW_EDGES\n     if( res.y>-150.)  {\n           vec3 pos = ro + res.x*rd;\n     \tvec3 nor = calcNormal(pos, rd, res.x);\n     }\n    return vec3(1);\n#else\n    \n    float t = res.x;\n\tfloat m = res.y;\n    vec3 cscreen = vec3(sin(.1+1.1*iGlobalTime), cos(.1+1.1*iGlobalTime),.5);\n    cscreen *= cscreen;\n \n    vec3 col;\n\tfloat dt;\n    float glow = 1.-smoothstep(Anim + cos(iGlobalTime),.9+1.15,2.2);\n    glow *= step(.3, hash(iGlobalTime)); \/\/floor(.01+10.5*iGlobalTime)));\n    \n    if( m>-150.)  { \n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos, rd, t);\n\n        if( m>0. ) { \/\/ Chameleon\n\t\t\tcol = vec3(.4) + .35*cscreen + .3*sin(1.57*.5*iGlobalTime + vec3(.05,.09,.1)*(m-1.) );\n#ifdef NOISE_SKIN\n            nor = doBumpMap(iChannel0, pos*.5, nor, 0.05);\n#endif            \n        } else if (m<-104.5) {  \/\/ bottom of screen\n            col = vec3(.92);\n            dt = dot(normalize(pos-vec3(-4,-4,0)), vec3(0,0,-1));\n            col += (dt>0.) ? (.75*glow+.3)*dt*cscreen: vec3(0); \n        } else if (m<-102.5) {\n           \tif (pos.z<0.) { \/\/ screen\n            \tcol = screen(pos.xy,cscreen);\n                col += 20.*glow*col;\n            } else { \/\/ back of screen\n                col = vec3(.92);\n            \tdistCham *= .25; \/\/ Hack for chameleon light on screen\n            }\n        } else if (m<-101.5) {\n            col = .2+3.5*cscreen;\n        } else if(m<-100.5) {  \/\/ Ground\n            float f = mod( floor(2.*pos.z) + floor(2.*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.);\n            col = .1+.9*col*isGridLine(pos.xz, vec2(2.));\n            dt = dot(normalize(pos-vec3(-4,-4,0)), vec3(0,0,-1));\n \t\t\tcol += (dt>0.) ? (.75*glow+.3)*dt*cscreen: vec3(0);     \n    \t\t\/\/col = clamp(col,0.,1.);\n        } else {  \/\/ Screen\n            col = vec3(.92);\n            distCham *= .25; \/\/ Hack for chameleon light on screen\n        }\n\t\t\n        float ao = calcAO( pos, nor );\n\n\t\tvec3 lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\n\t\tfloat sh = 1.0;\n\t\tif( dif>0.02 ) { \n            WithChameleon = intersectSphere(pos,lig,vec3(-.5,1.65,0),2.95);\n            sh = softshadow( pos, lig, 0.02, 13., 8.0 ); \n            dif *= sh; \n        }\n\n\t\tvec3 brdf = vec3(0.0);\n\t\tbrdf += 1.80*amb*vec3(0.10,0.11,0.13)*ao;\n        brdf += 1.80*bac*vec3(0.15,0.15,0.15)*ao;\n        brdf += 0.8*dif*vec3(1.00,0.90,0.70)*ao;\n\n\t\tfloat pp = clamp( dot( reflect(rd,nor), lig ), 0.0, 1.0 );\n\t\tfloat spe = 1.2*sh*pow(pp,16.0);\n\t\tfloat fre = ao*pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n\t\tcol = col*brdf*(.5+.5*sh) + vec3(.25)*col*spe + 0.2*fre*(0.5+0.5*col);\n        \n        float rimMatch =  1. - max( 0. , dot( nor , -rd ) );\n        col += vec3((.1+cscreen*.1 )* pow( rimMatch, 10.));\n\t}\n\n\tcol *= 2.5*exp( -0.01*t*t );\n    float BloomFalloff = 15000.; \/\/mix(1000.,5000., Anim);\n \tcol += .5*glow*cscreen\/(1.+distCham*distCham*distCham*BloomFalloff);\n    \n\treturn vec3( clamp(col,0.0,1.0) );\n#endif    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \/\/ animation\n    float GlobalTime = iGlobalTime; \/\/ + .1*hash(iGlobalTime);\n    \n    Anim = clamp(5.6*cos(GlobalTime)*cos(4.*GlobalTime),-2.5,1.2);\n    ca3 = cos(.275+.006*Anim); sa3 = sin(.275+.006*Anim);   \n\tRot3 = mat2(ca3,-sa3,sa3,ca3);\n    float a=.1+.05*Anim, ca = cos(a), sa = sin(a);\n    Rotanim = mat2(ca,-sa,sa,ca);\n    float b = mod(GlobalTime,12.)>10.?cos(8.*GlobalTime):.2*cos(4.*GlobalTime), cb = cos(b), sb = sin(b);\n    Rotanim2 = mat2(cb,-sb,sb,cb);\n    float time = 17. + \/*14.5 +*\/ GlobalTime;\n    \n    \/\/ mouse\n    vec2 mo = iMouse.xy\/iResolution.xy;\n    \n    \/\/ camera\t\n    float dist = 13.;\n    vec3 ro = vec3( -0.5+dist*cos(0.1*time + 6.0*mo.x), 3.5 + 10.0*mo.y, 0.5 + dist*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( -3.5, .5, 0. );\n\n    \/\/ camera tx\n    vec3 cw = normalize( ta-ro );\n    vec3 cp = vec3( 0.0, 1.0, 0.0 );\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n\n    \/\/ render\n    vec3 colorSum = vec3(0);\n    int nbSample = 0;\n    \n #if (ANTIALIASING == 1)\t\n\tint i=0;\n#else\n\tfor (int i=0;i<ANTIALIASING;i++) {\n#endif\n        float randPix = 0.; \/\/hash(iGlobalTime); \/\/ Use frame rate to improve antialiasing ... not sure of result\n\t\tvec2 subPix = .4*vec2(cos(randPix+6.28*float(i)\/float(ANTIALIASING)),\n                              sin(randPix+6.28*float(i)\/float(ANTIALIASING)));\n\t\t\/\/vec3 ray = Ray(2.0,fragCoord.xy+subPix);\n\t\tvec2 q = (fragCoord.xy+subPix)\/iResolution.xy;\n\t\t\/\/vec2 q = (fragCoord.xy+.4*vec2(cos(6.28*float(i)\/float(ANTIALIASING)),sin(6.28*float(i)\/float(ANTIALIASING))))\/iResolution.xy;\n        vec2 p = -1.0+2.0*q;\n        p.x *= iResolution.x\/iResolution.y;\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n        \n        nbSample++;\n        float hmin = 100.;\n        colorSum += sqrt(render( ro, rd, hmin));\n        \n#ifdef SHOW_EDGES\n \t\tcolorSum = vec3(1);\n        if (Edge>0.3) colorSum = vec3(.6);  \n        if (hmin>0.5) colorSum = vec3(0,0,0);   \n        break;\n#endif\n        \n#if (ANTIALIASING > 1)\n        \/\/ optim : use antialiasing only on objects edges \/\/exit if far from objects\n        if (Edge<0.3 && hmin<0.5 ) break;\n\t}\n#endif\n    \n    fragColor = vec4(colorSum\/float(nbSample), 1.);\n}","name":"","description":"","type":"image"}]}}