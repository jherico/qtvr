{"Shader":{"ver":"0.1","info":{"id":"MlB3RV","date":"1430344705","viewed":710,"name":"Marquetry","username":"xbe","description":"Continuing with same algo as \"Psyche Nimix II\" but this time to produce tiles of wood marquetry. There is 20 differents patterns generated (not equally nice though <img src=\"\/img\/emoticonHappy.png\"\/> )<br\/>Updated: Add Lighting and bumpmap","likes":4,"published":3,"flags":0,"tags":["2d","cheap","bump","wood","tile"],"hasliked":0},"renderpass":[{"inputs":[{"id":6,"src":"\/presets\/tex05.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Xavier Benech\n\/\/ Marquetry\n\/\/\n\/\/ Updated with bumpmap and lighting\n\/\/\n\/\/ Adapted bump map from: \"Basic Bump Mapping\" by Hamneggs\n\/\/ https:\/\/www.shadertoy.com\/view\/ld2GRh\n\/\/\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI 3.14159265\n#define NUM 10.\n\nfloat aspect = iResolution.x\/iResolution.y;\nfloat delta = 0.005 + 0.0425*(1.-exp(-0.00025*iResolution.x));\n\nmat2 rotate(in float a)\n{\n    float c = cos(a), s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat tri(in float x)\n{\n    return abs(fract(x)-.5);\n}\n\nvec2 tri2(in vec2 p)\n{\n    return vec2(tri(p.x+tri(p.y*2.)),tri(p.y+tri(p.x*2.)));\n}\n\nmat2 trinoisemat = mat2( 0.970,  0.242, -0.242,  0.970 );\n\nfloat triangleNoise(in vec2 p)\n{\n    float z=1.5;\n    float z2=1.5;\n\tfloat rz = 0.;\n    vec2 bp = 2.*p;\n\tfor (float i=0.; i<=4.; i++ )\n\t{\n        vec2 dg = tri2(bp*2.)*.8;\n        dg *= rotate(0.314);\n        p += dg\/z2;\n\n        bp *= 1.6;\n        z2 *= .6;\n\t\tz *= 1.8;\n\t\tp *= 1.2;\n        p*= trinoisemat;\n        \n        rz+= (tri(p.x+tri(p.y)))\/z;\n\t}\n\treturn rz;\n}\n\nfloat arc(in vec2 plr, in float radius, in float thickness, in float la, in float ha)\n{\n    \/\/ clamp arc start\/end\n    float res = step(la, plr.y) * step(plr.y, ha);\n    \/\/ smooth outside\n    res *= smoothstep(plr.x, plr.x+delta,radius+thickness);\n    \/\/ smooth inside\n    float f = radius - thickness;\n    res *= smoothstep( f, f+delta, plr.x);\n    \/\/ smooth start\n    res *= smoothstep( la, la+delta, plr.y);\n    \/\/ smooth end\n    res *= 1. - smoothstep( ha-delta, ha, plr.y);\n    return res;\n}\n\nvec3 marquetry(vec2 uv)\n{\n    vec2 p = uv;\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    p = 2.*abs(fract(p)-0.5);\n    \n    float k = clamp(fract(iGlobalTime\/(10.*PI)), 0.,1.);    \n    float sum = 0.;\n    float s = 1.\/10.;\n    float ss = s;\n    for (int i=0; i<10; i++)\n    {\n        sum += step(k, ss);\n        ss += s;\n    }\n    float k0 = 4.*36.+36.*sum;\n    k = clamp(fract(iGlobalTime\/(20.*PI)), 0.,1.);\n    float k2 = 1. - 2.*step(k, 0.5);\n    p *= rotate(PI*(k0)\/180.);\n    p.y = 2. - ( 0.2 + k2 )*(1.-exp(-abs(p.y)));\n    \n    float lp = length(p);\n    float id = floor(lp*NUM+.5)\/NUM;\n    vec4 n = texture2D( iChannel0, vec2(id, 0.0025*iGlobalTime));\n    \n    \/\/polar coords\n    vec2 plr = vec2(lp, atan(p.y, p.x));\n    \n    \/\/Draw concentric arcs\n    float rz = arc(plr, id, 0.425\/NUM+delta, 0., PI);\n    \n    float m = rz;\n    rz *= (triangleNoise(p)*0.5+0.5);\n    vec4 nn = texture2D(iChannel0, vec2(0.123, id));\n\tvec3 col = (texture2D(iChannel1, uv+nn.xy).rgb*nn.z+0.25) * rz;\n\tcol *= 1.25;\n    col = smoothstep(0., 1., col);\n   \tcol = exp(col) - 1.;\n    col = clamp(col, 0., 1.);\n    \n    return col;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Adapted bump map from: \"Basic Bump Mapping\" by Hamneggs\n\/\/ https:\/\/www.shadertoy.com\/view\/ld2GRh\n\n#define diff .001\n#define timeScale 0.5\n#define lightPathRadius 1.25\n#define lightPathCenter vec3(0, 0, 1.725)\n#define lightColor vec3(1.0, 1.0, 1.0)\n#define lightStrength 2.0\n#define specularFactor 8.0\n#define specularRatio 5.0\n#define specularMapRatio 8.0\n\nvec3 genLightCoords()\n{\n\tvec3 lightCoords = vec3(lightPathCenter.x + (sin(iGlobalTime*timeScale)*lightPathRadius), \n\t\t\t\tlightPathCenter.y + (cos(iGlobalTime*timeScale)*lightPathRadius),\n\t\t\t\tlightPathCenter.z);\n\treturn lightCoords;\n}\n\nvec3 surfaceNormal(vec2 coord)\n{\n\tfloat diffX = marquetry(vec2(coord.x+diff, coord.y)).r - marquetry(vec2(coord.x-diff, coord.y)).r;\n\tfloat diffY = marquetry(vec2(coord.x, coord.y+diff)).r - marquetry(vec2(coord.x, coord.y-diff)).r;\n\tvec2 localDiff = vec2(diffX, diffY);\n\tlocalDiff *= -1.0;\n\tlocalDiff = (localDiff\/2.0)+.5;\n\tfloat localDiffMag = length(localDiff);\n\tfloat z = sqrt(max(0.,1.0-pow(localDiffMag, 2.0)));\n\treturn vec3(localDiff, z);\n}\n\nfloat incidenceCosine(vec3 lightIncidence, vec3 normal)\n{\n\tnormal.xy -= .5;\n\tnormal.xy *= 2.0;\n\tnormal = normalize(normal);\n\tlightIncidence = normalize(lightIncidence);\n\treturn dot(lightIncidence, normal);\n}\n\nvec3 lighting(vec2 coord)\n{\n\tvec3 lightPos = genLightCoords();\n\tfloat cosine = incidenceCosine(lightPos - vec3(coord, 0.), surfaceNormal(coord));\n\t\n\tfloat dist = distance(lightPos, vec3(coord, 0.0));\n\tfloat att = exp(-dist);\n    \n\tvec3 ambient = vec3(0.75);\n\tvec3 diffuse = vec3(1.0);\n\tdiffuse *= att*lightStrength*cosine*lightColor;\n\t\n\tvec3 specular = vec3(1.0);\n\tspecular *= pow(abs(cosine), specularFactor*specularRatio);\n\tspecular *= att*lightStrength*lightColor;\n\tspecular *= specularMapRatio;\n\t\n\treturn ambient+diffuse+specular;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec2 q = uv*2.-1.;\n\tq.x *= aspect;\n\n    \/\/ shutter\n    float k = clamp(exp(1.-abs(sin(iGlobalTime)))-exp(0.5), 0., 1.);\n    float shutter = 1.0 - smoothstep( 0., 1., 10.*(k-0.75) );\n    \n    vec3 col = marquetry(q);\n    col *= lighting(q);\n    \n    \/\/ Vignetting\n\tvec2 r = -1.0 + 2.0*(uv);\n\tfloat vb = max(abs(r.x), abs(r.y));\n\tcol *= (0.15 + 0.85*(1.0-exp(-(1.0-vb)*30.0)));\n    \n    col *= shutter;\n\n    fragColor = vec4(col,1.0);\n}\n","name":"","description":"","type":"image"}]}}