{"Shader":{"ver":"0.1","info":{"id":"4dlGW2","date":"1379692263","viewed":1473,"name":"Tileable Noise","username":"Dave_Hoskins","description":"There are all sorts of weird and wonderful noise tiling sources on the Net, including 4D noise creation and cylinder wrapping. So here's my contribution, it should be a lot faster. <img src=\"\/img\/emoticonHappy.png\"\/><br\/>Remove define at the top to see single tile. Mouse to scroll about.","likes":12,"published":3,"flags":0,"tags":["noise","tiled","fbm","tileable"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ https:\/\/www.shadertoy.com\/view\/4dlGW2\n\n\/\/ Tileable noise, for creating useful textures. By David Hoskins, Sept. 2013.\n\/\/ It can be extrapolated to other types of randomised texture.\n\n#define SHOW_TILING\n#define TILES 2.0 \/\/ Use 1.0 for normal tiling across whole texture.\n\n\/\/----------------------------------------------------------------------------------------\nfloat Hash(in vec2 p, in float scale)\n{\n\t\/\/ This is tiling part, adjusts with the scale...\n\tp = mod(p, scale);\n\treturn fract(sin(dot(p, vec2(27.16898, 38.90563))) * 5151.5473453);\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat Noise(in vec2 p, in float scale )\n{\n\tvec2 f;\n\t\n\tp *= scale;\n\n\t\/\/ Movement, just for tiling demonstation...\n\tp += vec2(sin(iGlobalTime * .3), cos(iGlobalTime * .33+scale*.23))*(scale*.03) + iMouse.xy*.1;\n\t\n\tf = fract(p);\t\t\/\/ Separate integer from fractional\n    p = floor(p);\n\t\n    f = f*f*(3.0-2.0*f);\t\/\/ Cosine interpolation approximation\n\t\n    float res = mix(mix(Hash(p, \t\t\t\t scale),\n\t\t\t\t\t\tHash(p + vec2(1.0, 0.0), scale), f.x),\n\t\t\t\t\tmix(Hash(p + vec2(0.0, 1.0), scale),\n\t\t\t\t\t\tHash(p + vec2(1.0, 1.0), scale), f.x), f.y);\n    return res;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat fBm(in vec2 p)\n{\n\tfloat f = 0.0;\n\t\/\/ Change starting scale to any integer value...\n\tfloat scale = 4.0;\n\tfloat amp   = 0.5;\n\t\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tf += Noise(p, scale) * amp;\n\t\tamp *= .65;\n\t\t\/\/ Scale must be multiplied by an integer value...\n\t\tscale *= 2.0;\n\t}\n\t\/\/ Clamp it just in case....\n\treturn min(f, 1.0);\n}\n\n\/\/----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\n\t#ifdef SHOW_TILING\n\tuv *= TILES;\n\t#endif\n\t\n\t\/\/ Do the noise cloud (fractal Brownian motion)\n\tfloat bri = fBm(uv);\n\t\n\tbri = pow(bri, 1.2); \/\/ ...cranked up the contrast for demo.\n\tvec3 col = vec3(bri);\n\t\n\t#ifdef SHOW_TILING\n\t\/\/ Flash tile borders...\n\tvec2 pixel = TILES \/ iResolution.xy;\n\tif (mod(iGlobalTime-2.0, 4.0) < 2.0)\n\t{\n\t\tvec2 first \t\t= step(pixel, uv);\n\t\tuv  = step(fract(uv), pixel);\t\/\/ Only add one line of pixels per tile.\n\t\tcol = mix(col, vec3(1.0, 1.0, 0.0), (uv.x + uv.y) * first.x * first.y);\n\t}\n\t#endif\n\n\tfragColor = vec4(col,1.0);\n}","name":"","description":"","type":"image"}]}}