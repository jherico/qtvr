{"Shader":{"ver":"0.1","info":{"id":"ldtGDX","date":"1452565308","viewed":665,"name":"Sculpt Things! ","username":"elias","description":"See shader comments for controls.","likes":44,"published":3,"flags":49,"tags":["sculpt"],"hasliked":0},"renderpass":[{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":259,"src":"\/presets\/previz\/buffer02.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/* CC BY-NC-SA 3.0 - Elias Sch\u00fctt | https:\/\/creativecommons.org\/licenses\/by-nc-sa\/3.0\/\n\n==============\n== Controls ==\n==============\n\nSpace + Drag = rotate view\n\nU = toggle UI \/ settings\nQ = toggle brush inversion\n\nN = display normal map\nH = display height map\nP = display color map\n\nC = clear canvas\nESDF = move camera (flymode)\n\n==================\n== Shader Setup ==\n==================\n\nBuf A = Sculpting\nBuf B = Painting\nBuf C = UI & Logic\n\nBuf A and B contain a simplified version of the scene\nand cast rays from the mouse position into it.\n\nThe canvas resolution is now fixed so that\nthe fullscreen view shows the same area.\n\nYou can change the resolution via the SIZE constant below.\nDon't forget to change the constant inside Buf A and B as well.\nBe careful not to set it larger than min(iResolution.x,iResoution.y).\n\nMy fake ambient occlusion looks more like an edge detection,\nI don't have much experience with this, sorry. D:\n\n=============\n== Credits ==\n=============\n\nBit Packed Sprites by Flyguy (Font rendering)\nhttps:\/\/www.shadertoy.com\/view\/XtsGRl\n\nHSV2RGB\nhttp:\/\/lolengine.net\/blog\/2013\/07\/27\/rgb-to-hsv-in-glsl\n\nAnd of course special thanks to \u00cd\u00f1go Qu\u00edlez\nand the Shadertoy community for being awesome. :)\n\n*\/\n\n\/\/#define HIGH_QUALITY\n\n#ifndef HIGH_QUALITY\n\n    #define S 300   \/\/ Max Steps\n    #define R 5.    \/\/ Marching step subdevision\n\n#else\n\n\t#define S 500   \/\/ Max Steps\n    #define R 10.   \/\/ Marching step subdevision\n\n#endif\n\n#define P 0.005 \/\/ Precision\n#define D 3.    \/\/ Max depth\n#define V 50.   \/\/ Voxel size\n#define K 3.    \/\/ Shadow blur\n\n#define SIZE 280.\n#define load(a,b) texture2D(b,(a+0.5)\/iResolution.xy)\n\nstruct Ray    { vec3 o, d; };\nstruct Camera { vec3 p, d; };\nstruct Hit    { vec3 p; float t, d; };\n\n\/* ===================== *\/\n\/* ====== Globals ====== *\/\n\/* ===================== *\/\n\nCamera _cam = Camera(vec3(0,0.4,-0.5), normalize(vec3(0,-1,1)));\n\nbool _perspective = true;\nvec3 _up = vec3(0,1,0);\nvec2 _uv;\n\nfloat _d1, _d2, _d3;\nfloat _key_n, _key_h, _key_u, _key_p, _zoom;\n\nbool _displayOcclusion;\nbool _displayShadows;\nbool _displayVoxel;\nbool _displayVoxelXY;\nbool _displayVoxelY;\nbool _displayWater;\nbool _useColorBand;\n\n\/* =================== *\/\n\/* ====== Utils ====== *\/\n\/* =================== *\/\n\nmat3 rotX(float a){float c=cos(a),s=sin(a);return mat3(1,0,0,0,c,-s,0,s,c);}\nmat3 rotY(float a){float c=cos(a),s=sin(a);return mat3(c,0,-s,0,1,0,s,0,c);}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p)-b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\/* ====================== *\/\n\/* ====== Marching ====== *\/\n\/* ====================== *\/\n\nfloat scene(vec3 p)\n{\n\tif (_displayVoxelY == true)\n\t{ p.y = floor(p.y*V+0.5)\/V; }\n\telse if (_displayVoxelXY == true)\n\t{ p = floor(p*V+0.5)\/V; }\n\n\t\/\/ box\n\t_d1 = max(\n\t\tsdBox(p+vec3(0,1,0),vec3(0.52,1,0.52)),\n\t\t-sdBox(p,vec3(0.51,1,0.51))\n\t);\n\t\n\t\/\/ sculpture\n\t_d2 = max(\n\t\tp.y-texture2D(iChannel0, (p.xz+0.5)*SIZE\/iResolution.xy).x,\n\t\tsdBox(p,vec3(0.50,1,0.50))\n\t);\n\n\t\/\/ water\n\t_d3 = _displayWater == true\n\t\t? sdBox(p+vec3(0,0.01,0),vec3(0.49,0.01,0.49))\n\t\t: 1e10;\n\t\n\treturn min(min(_d1,_d2),_d3);\n}\n   \nvec3 getNormal(vec3 p)\n{    \n\tvec2 e = vec2(P,0);\n\n\tvec3 n = normalize(vec3(\n\t\tscene(p+e.xyy)-scene(p-e.xyy),\n\t\tscene(p+e.yxy)-scene(p-e.yxy),\n\t\tscene(p+e.yyx)-scene(p-e.yyx)\n\t));\n\n    \/\/ Correct voxel normals\n    if (_displayVoxel == true)\n    {\n        if (acos(dot(n,vec3(0,1,0))) < 1.0) { n = vec3(0,1,0); }\n\n        if (_displayVoxelXY == true && _displayVoxelY == false)\n        { \n            if (acos(dot(n,vec3( 1, 0, 0))) < 1.0) { n = vec3( 1, 0, 0); } \n            if (acos(dot(n,vec3( 0, 0, 1))) < 1.0) { n = vec3( 0, 0, 1); }\n            if (acos(dot(n,vec3(-1, 0, 0))) < 1.0) { n = vec3(-1, 0, 0); }\n            if (acos(dot(n,vec3( 0, 0,-1))) < 1.0) { n = vec3( 0, 0,-1); }\n        }\n    }\n\t\n\treturn n;\n}\n\nHit march(Ray r)\n{\n\tfloat t = 0.0, d;\n\n\tfor(int i = 0; i < S; i++)\n\t{\n\t\td = scene(r.o+r.d*t); t += d\/R;\n\t\tif (d <= P || t > D) { break; }\n\t}\n\n\treturn Hit(r.o+r.d*t, t, d);\n}\n\nRay lookAt(Camera cam, vec2 c)\n{\n\tvec3 dir = normalize(cam.d);\n\tvec3 right = normalize(cross(dir,_up));\n\tvec3 up = cross(right, dir);\n \n\tif (_perspective == true)    \n\treturn Ray(cam.p, normalize(right*c.x + up*c.y + dir));\n\telse\n\treturn Ray(cam.p + (right*c.x + up*c.y)*0.5, dir);\n}\n\nmat3 lookAt(Camera cam)\n{\n\tvec3 dir = normalize(cam.d);\n\tvec3 right = normalize(cross(dir,_up));\n\tvec3 up = cross(right, dir);\n \n\treturn mat3(up, right, -dir);\n}\n\n\/*\nfloat getEdge(Hit h) \n{    \n\tvec2 e = vec2(10.\/iResolution.x,0);\n\t\n\tif (_displayVoxel == true) { e.x\/= 2.; }\n\n\tvec2 uv = (2.*gl_FragCoord.xy-iResolution.xy)\/iResolution.xx;\n\t\n\tfloat d = pow(abs(min(\n\t\t(h.t-march(lookAt(_cam,uv+e.xy)).t)+\n\t\t(h.t-march(lookAt(_cam,uv-e.xy)).t)+\n\t\t(h.t-march(lookAt(_cam,uv+e.yx)).t)+\n\t\t(h.t-march(lookAt(_cam,uv-e.yx)).t)\n\t,0.0)),2.);\n\n\treturn clamp(1.-d*500.,0.,1.);\n}\n*\/\n\t\nfloat getSSAO(Hit h) \n{    \n\tvec2 e = vec2(10.\/iResolution.x,0);\t\n\tif (_displayVoxel == true) { e.x\/= 2.; }\n\t\n\tfloat d = min(h.t-(\n\t\tmarch(lookAt(_cam,_uv+e.xy)).t+\n\t\tmarch(lookAt(_cam,_uv-e.xy)).t+\n\t\tmarch(lookAt(_cam,_uv+e.yx)).t+\n\t\tmarch(lookAt(_cam,_uv-e.yx)).t\n\t)\/4.,0.002);\n\n\treturn clamp(1.-d*100.,0.,1.);\n}\n\n\/* ======================= *\/\n\/* ====== Rendering ====== *\/\n\/* ======================= *\/\n\nfloat getShadow(vec3 source, vec3 target)\n{\n\tfloat r = length(target-source);\n\tfloat t = _displayVoxel == true ? 0.05 : 0.01;\n\tfloat s = 1.0;\n\tfloat d;\n\t\n\tvec3 dir = normalize(target-source);\n\t\n\tfor(int i = 0; i < S; i++)\n\t{\n\t\td = scene(source+dir*t);\n\t\t\n\t\tif (d < P) { return 0.0; }\n\t\tif (t > r) { break; }\n\t\t\n\t\ts = min(s,K*d\/t);\n\t\tt += d\/R;\n\t}\n\t\n\treturn s;\n}\n\nvec3 getColor(Hit h)\n{    \n\tif (h.d > P) { return vec3(0.1); }\n\tif (_key_n > 0.0) { return normalize(getNormal(h.p)+1.0); }\n\t\n\tvec3 col = vec3(0);\n\tvec3 light = _displayShadows == true ? vec3(0.5) : _cam.p;\n\n\tfloat d = 1e10;\n\t\n\t\/\/ Box\n\tif (_d1 < d) { col = vec3(0); d = _d1; }\n\t\/\/ Terrain\n\tif (_d2 < d) { col = _useColorBand == true ? texture2D(iChannel1,vec2(0.975,0.39+h.p.y*0.37)).rgb : vec3(1); }\n\t\n\tfor(int i = 0; i < 2; i++)\n\t{\n\t\tvec3 c = col;\n\t\tvec3 n = getNormal(h.p);\n\t\tfloat height = load((h.p.xz+0.5)*SIZE,iChannel0).x;\n\n\t\tc *= max(dot(n,normalize(light-h.p)),0.0);\n\t\tc *= min(1.\/exp(log2(length(light-h.p))),1.0);\n\n        \/\/ funnily enough, this is faster than a simple if-clause\n\t\tc *= _displayShadows   == true ? getShadow(h.p,light) : 1.0;\n\t\tc *= _displayOcclusion == true ? getSSAO(h)           : 1.0;\n\n\t\tif (height >= 0.0 || _displayWater == false)\n\t\t{\n\t\t\tvec3 bufCol = load((h.p.xz+0.5)*SIZE,iChannel2).rgb;\n\t\t\tcol = mix(col,c*bufCol,i==0?0.8:0.6);\n\t\t\t\/\/if (i==0) { col *= h.t; }\n\t\t\tbreak;\n\t\t}\n\n\t\t\/\/ specular lighting\n\t\tc += pow(max(dot(reflect(normalize(h.p-light),n),normalize(_cam.p)),0.0),100.0);\n\t\tcol = mix(col,c,0.5);\n\n\t\t\/\/ march again for water reflections\n\t\tn = normalize(reflect(h.p-_cam.p,n));\n\t\th = march(Ray(h.p+n*0.01,n));\n\t}\n\t\n\treturn col;\n}\n\nvoid displayUI(inout vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 coord = fragCoord.xy;\n\tvec4 ui = load(coord-0.5,iChannel1);\n\tfloat brush = load(vec2(9,0),iChannel1).x;\n\t\n\t\/\/ Hide pixels used for settings\n\tif (coord.y == 0.5) { coord.y += 1.0; }\n\t\/\/ Hide color picker & band if paint tool is not selected\n\tif (brush != 0.4 && fragCoord.x > iResolution.x\/2.) { ui.a = -1.; }\n\n\tif (_key_u < 1.0 && ui.a > 0.0)\n\t{\n\t\tfragColor.rgb = fragColor.rgb*(1.-ui.a) + ui.rgb*ui.a;\n\t}\n}\n\nbool init(inout vec4 fragColor, in vec2 fragCoord, bool is_vr)\n{\n\t_uv = (2.*fragCoord.xy-iResolution.xy)\/iResolution.xx;\n\n\t_key_n = texture2D(iChannel3, vec2(78.5\/256.,1)).x;\n\t_key_h = texture2D(iChannel3, vec2(72.5\/256.,1)).x;\n\t_key_p = texture2D(iChannel3, vec2(80.5\/256.,1)).x;\n\t_key_u = texture2D(iChannel3, vec2(85.5\/256.,1)).x;\n\n\t\/\/ Display height map\n\tif (_key_h > 0.0)\n\t{\n\t\tvec2 uv = fragCoord.xy\/pow(iResolution.xy,vec2(2.))*SIZE;\n\t\tfragColor = vec4((texture2D(iChannel0, uv).xxx+1.)\/2., 1.0);\n\t\treturn true;\n\t}\n\n\t\/\/ Display paint map\n\tif (_key_p > 0.0)\n\t{\n\t\tvec2 uv = fragCoord.xy\/pow(iResolution.xy,vec2(2.))*SIZE;\n\t\tfragColor = vec4(texture2D(iChannel2, uv).rgb, 1.0);\n\t\treturn true;\n\t}\n\t\n\t\/\/ Display normal map\n\telse if (_key_n > 0.0)\n\t{\n\t\tvec2 uv = (2.*fragCoord.xy-iResolution.xy)\/iResolution.xy*vec2(-1,1);\n\t\t\n\t\t_cam.p = vec3(0,0.5,0);\n\t\t_cam.d = vec3(0,-1,0);\n\t\t\n\t\t_up = vec3(0,0,1);\n\t\t_perspective = false;\n\t\t\n\t\tfragColor = vec4(getColor(march(lookAt(_cam,uv))),1);\n\t\treturn true;\n\t}\n\t\n\t_zoom             = load(vec2( 7,0), iChannel1).x * 2.0;\n\t_displayShadows   = load(vec2(10,0), iChannel1).x == 1.0;\n\t_displayOcclusion = load(vec2(11,0), iChannel1).x == 1.0;\n\t_displayWater     = load(vec2(12,0), iChannel1).x == 1.0;\n\t_displayVoxelXY   = load(vec2(13,0), iChannel1).x == 1.0;\n\t_displayVoxelY    = load(vec2(14,0), iChannel1).x == 1.0;\n\t_useColorBand     = load(vec2(16,0), iChannel1).x == 1.0;\n\t_displayVoxel     = _displayVoxelXY == true || _displayVoxelY == true;\n\n\n\tfloat fly = load(vec2(15,0),iChannel1).x;\n\tvec2 rot = load(vec2(fly,0), iChannel1).xy;\n\tvec3 pos = load(vec2(3,0),iChannel1).xyz*1e4;\n\n\tif (fly < 1.0)\n\t{\n\t\t_cam.p *= rotX(rot.x)*rotY(rot.y) * _zoom;\n\t\t_cam.d = -_cam.p;\n\t}\n\telse\n\t{\n\t\t_cam.p += pos;\n\t\t_cam.d *= rotX(rot.x)*rotY(rot.y);\n\t}\n\n\treturn false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tif (init(fragColor, fragCoord, false) == true) return;\n\n\tfragColor = vec4(getColor(march(lookAt(_cam,_uv))),1);\n\t\n\tdisplayUI(fragColor, fragCoord);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n\tif (init(fragColor, fragCoord, true) == true) return;\n\t\n\tmat3 m = lookAt(_cam);\n\tfragColor = vec4(getColor(march(Ray(_cam.p + m*fragRayOri, m*fragRayDir))),1);\n\n\tdisplayUI(fragColor, fragCoord);\n}","name":"","description":"","type":"image"},{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":47,"src":"\/presets\/tex19.png","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":259,"src":"\/presets\/previz\/buffer02.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define P 0.005 \/\/ Precision\n#define S 300   \/\/ Max Steps\n#define D 3.    \/\/ Max depth\n#define R 5.    \/\/ Marching step subdevision\n\n#define SIZE 280.\n\n#define inside(a) (fragCoord.x == a.x+0.5 && fragCoord.y == a.y+0.5)\n#define load(a,b) texture2D(b,(a+0.5)\/iResolution.xy)\n#define save(a,b) if(inside(a)){fragColor=b;return;}\n\nstruct Ray    { vec3 o, d; };\nstruct Camera { vec3 p, d; };\nstruct Hit    { vec3 p; float t, d; };\n\n\/* ===================== *\/\n\/* ====== Globals ====== *\/\n\/* ===================== *\/\n\nCamera _cam = Camera(vec3(0,0.4,-0.5), normalize(vec3(0,-1,1)));\n\n\/* =================== *\/\n\/* ====== Utils ====== *\/\n\/* =================== *\/\n\nmat3 rotX(float a){float c=cos(a),s=sin(a);return mat3(1,0,0,0,c,-s,0,s,c);}\nmat3 rotY(float a){float c=cos(a),s=sin(a);return mat3(c,0,-s,0,1,0,s,0,c);}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p)-b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdLine(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b-a;\n    float t = dot(p-a,ab)\/dot(ab,ab);\n    return length(p-a-ab*clamp(t,0.,1.))-r;\n}\n\n\/* =================== *\/\n\/* ====== Noise ====== *\/\n\/* =================== *\/\n\nfloat f(float t) { return 6.0*t*t*t*t*t-15.0*t*t*t*t+10.0*t*t*t; }\n\nvec2 noise(vec2 p){\n\treturn (vec2(\n\t\tfract(sin(dot(p.xy, vec2(50159.91193,49681.51239))) * 73943.1699),\n\t\tfract(sin(dot(p.xy, vec2(90821.40973,2287.62201))) * 557.96557)\n\t)-0.5)*2.0;\n}\n\nfloat perlin(vec2 p)\n{\n\tint X = int(floor(p.x));\n\tint Y = int(floor(p.y));\n\t\n\tp.x -= float(X);\n\tp.y -= float(Y);\n\t\n\tvec2 g00 = noise(vec2(X  , Y  ));\n\tvec2 g01 = noise(vec2(X  , Y+1));\n\tvec2 g10 = noise(vec2(X+1, Y  ));\n\tvec2 g11 = noise(vec2(X+1, Y+1));\n\t\n\tfloat q00 = dot(g00, vec2(p.x    , p.y    ));\n\tfloat q01 = dot(g01, vec2(p.x    , p.y-1.0));\n\tfloat q10 = dot(g10, vec2(p.x-1.0, p.y    ));\n\tfloat q11 = dot(g11, vec2(p.x-1.0, p.y-1.0));\n\n\tp.x = f(p.x);\n\tp.y = f(p.y);\n\t\n\tfloat qx0 = mix(q00, q10, p.x);\n\tfloat qx1 = mix(q01, q11, p.x);\n\tfloat qxy = mix(qx0, qx1, p.y);\n\n\treturn qxy;\n}\n\nfloat fbm(vec2 p)\n{\n    float f = 1.0;\n    \n    f += perlin(p\/16.)*16.;\n    f += perlin(p\/8.)*8.;\n    f += perlin(p\/4.)*4.;\n    f += perlin(p\/2.)*2.;\n    f += perlin(p\/1.)*1.;\n    \n    return f\/(1.+2.+4.+8.+16.);\n}\n\n\/* ====================== *\/\n\/* ====== Marching ====== *\/\n\/* ====================== *\/\n\nfloat scene(vec3 p)\n{\n\t\/\/ box\n\tfloat d1 = max(\n\t\tsdBox(p+vec3(0,1,0),vec3(0.52,1,0.52)),\n\t\t-sdBox(p,vec3(0.51,1,0.51))\n\t);\n\t\n\t\/\/ sculpture\n\tfloat d2 = max(\n\t\tp.y-texture2D(iChannel0, (p.xz+0.5)*SIZE\/iResolution.xy).x,\n\t\tsdBox(p,vec3(0.50,1,0.50))\n\t);\n\t\n\treturn min(d1,d2);\n}\n\nHit march(Ray r)\n{\n\tfloat t = 0.0, d;\n\n\tfor(int i = 0; i < S; i++)\n\t{\n\t\td = scene(r.o+r.d*t); t += d\/R;\n\t\tif (d <= P || t > D) { break; }\n\t}\n\n\treturn Hit(r.o+r.d*t, t, d);\n}\n\nRay lookAt(Camera cam, vec2 c)\n{\n    vec3 dir = normalize(cam.d);\n    vec3 right = normalize(cross(dir, vec3(0,1,0)));\n    vec3 up = cross(right, dir);\n \n    return Ray(cam.p, normalize(right*c.x + up*c.y + dir));\n}\n\n\/\/ from https:\/\/www.shadertoy.com\/view\/llj3Rz\nmat3 setCameraVR( in vec3 ro, in vec3 rt, in float cr )\n{\n    vec3 cw = normalize(rt-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nvec3 getNormal(vec3 p)\n{\n\tvec2 e = vec2(P,0);\n\n\treturn normalize(vec3(\n\t\tscene(p+e.xyy)-scene(p-e.xyy),\n\t\tscene(p+e.yxy)-scene(p-e.yxy),\n\t\tscene(p+e.yyx)-scene(p-e.yyx)\n\t));\n}\n\n\/* ===================== *\/\n\/* ====== Drawing ====== *\/\n\/* ===================== *\/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x > SIZE || fragCoord.y > SIZE) discard;\n    \n    vec2 uv = fragCoord.xy\/iResolution.xy;\n    vec2 uvm = iMouse.xy\/iResolution.yy;\n    fragColor = texture2D(iChannel0,uv);\n    \n   \tfloat brush  = load(vec2(9,0),iChannel1).x;\n    if (brush == 0.4) { return; }\n    \n    float key_c  = texture2D(iChannel3, vec2(67.5\/256.,0)).x;\n    float key_q  = texture2D(iChannel3, vec2(81.5\/256.,1)).x;\n    float key_sp = texture2D(iChannel3, vec2(32.5\/256.,0)).x;\n    float key_u  = texture2D(iChannel3, vec2(85.5\/256.,1)).x;\n    float key_s  = texture2D(iChannel3, vec2(83.5\/256.,0)).x;\n    float key_e  = texture2D(iChannel3, vec2(69.5\/256.,0)).x;\n    float key_f  = texture2D(iChannel3, vec2(70.5\/256.,0)).x;\n    float key_d  = texture2D(iChannel3, vec2(68.5\/256.,0)).x;\n    float dir    = key_q > 0.0 ? -1. : 1.;\n\n    \/\/ Clear canvas\n    if (key_c > 0.0)\n    {\n        if (abs(fragColor.x) < 0.001)\n        { fragColor.x = 0.0; }\n        else\n        { fragColor.x *= 0.9; }\n        return;\n    }\n    \n    if (iMouse.w > 0.0 && key_sp < 1.0 && (key_e < 1.0 && key_s < 1.0 && key_d < 1.0 && key_f < 1.0) && (key_u > 0.0 || (key_u < 1.0 && uvm.x > 0.3)))\n    {\n        uv \/= SIZE\/iResolution.xy;\n        \n        float size  = load(vec2(4,0),iChannel1).x*20.;\n        float blur  = load(vec2(5,0),iChannel1).x;\n        float force = load(vec2(6,0),iChannel1).x\/0.25;\n        float zoom  = load(vec2(7,0),iChannel1).x\/0.5;\n        float scale = load(vec2(8,0),iChannel1).x\/0.5;\n        float fly   = load(vec2(15,0),iChannel1).x;\n        float rel   = load(vec2(17,0),iChannel1).x;\n\n        vec4 iMouseLast = load(vec2(2,0),iChannel1);\n        if (iMouseLast.w < 1.0) { iMouseLast.xy = iMouse.xy; }\n\n        vec2 rot = load(vec2(fly,0),iChannel1).xy;\n        vec3 pos = load(vec2(3,0),iChannel1).xyz*1e4;\n\n        if (fly < 1.0)\n        {\n            _cam.p *= rotX(rot.x)*rotY(rot.y) * zoom;\n            _cam.d = -_cam.p;\n        }\n        else\n        {\n            _cam.p += pos;\n            _cam.d *= rotX(rot.x)*rotY(rot.y);\n        }\n\n\n        Hit c1 = march(lookAt(_cam,(2.*iMouse.xy-iResolution.xy)\/iResolution.xx));\n        Hit c2 = march(lookAt(_cam,(2.*iMouseLast.xy-iResolution.xy)\/iResolution.xx));\n        \n        if (rel > 0.0)\n        {\n            size *= c1.t\/D*20.;\n           \/\/force *= c1.t\/D*10.;\n        }\n        \n        float h = texture2D(iChannel0, (c1.p.xz+0.5)*SIZE\/iResolution.xy).x;\n        float d = sdLine(vec3(uv.x-0.5,h,uv.y-0.5),c1.p,c2.p,0.01*size);\n        float f = smoothstep(d,d+0.1-(1.-blur)*0.09,0.0)*0.1\/size*clamp(blur,0.1,0.9)*force;\n        \n        if (brush == 0.0)\n\t\tfragColor.x += dir*f;\n        else if (brush == 0.1)\n\t\tfragColor.x += f*(h-fragColor.x)*10.;\n        else if (brush == 0.2)\n        fragColor.x += dir*f*(fbm((uv)*500.*scale)+0.5);\n        else if (brush == 0.3)\n        fragColor.x += dir*f*texture2D(iChannel2,uv*scale*2.).x;\n    }\n}","name":"","description":"","type":"buffer"},{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":259,"src":"\/presets\/previz\/buffer02.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define P 0.005 \/\/ Precision\n#define S 300   \/\/ Max Steps\n#define D 3.    \/\/ Max depth\n#define R 5.    \/\/ Marching step subdevision\n\n#define SIZE 280.\n\n#define inside(a) (fragCoord.x == a.x+0.5 && fragCoord.y == a.y+0.5)\n#define load(a,b) texture2D(b,(a+0.5)\/iResolution.xy)\n#define save(a,b) if(inside(a)){fragColor=b;return;}\n\nstruct Ray    { vec3 o, d; };\nstruct Camera { vec3 p, d; };\nstruct Hit    { vec3 p; float t, d; };\n\n\/* ===================== *\/\n\/* ====== Globals ====== *\/\n\/* ===================== *\/\n\nCamera _cam = Camera(vec3(0,0.4,-0.5), normalize(vec3(0,-1,1)));\n\n\/* =================== *\/\n\/* ====== Utils ====== *\/\n\/* =================== *\/\n\n\/\/ http:\/\/lolengine.net\/blog\/2013\/07\/27\/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nfloat udBox(vec2 p, vec2 s)\n{\n    return length(max(abs(p)-s,0.0));\n}\n\nmat3 rotX(float a){float c=cos(a),s=sin(a);return mat3(1,0,0,0,c,-s,0,s,c);}\nmat3 rotY(float a){float c=cos(a),s=sin(a);return mat3(c,0,-s,0,1,0,s,0,c);}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p)-b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdLine(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b-a;\n    float t = dot(p-a,ab)\/dot(ab,ab);\n    return length(p-a-ab*clamp(t,0.,1.))-r;\n}\n\n\/* =================== *\/\n\/* ====== Noise ====== *\/\n\/* =================== *\/\n\nfloat f(float t) { return 6.0*t*t*t*t*t-15.0*t*t*t*t+10.0*t*t*t; }\n\nvec2 noise(vec2 p){\n\treturn (vec2(\n\t\tfract(sin(dot(p.xy, vec2(50159.91193,49681.51239))) * 73943.1699),\n\t\tfract(sin(dot(p.xy, vec2(90821.40973,2287.62201))) * 557.96557)\n\t)-0.5)*2.0;\n}\n\nfloat perlin(vec2 p)\n{\n\tint X = int(floor(p.x));\n\tint Y = int(floor(p.y));\n\t\n\tp.x -= float(X);\n\tp.y -= float(Y);\n\t\n\tvec2 g00 = noise(vec2(X  , Y  ));\n\tvec2 g01 = noise(vec2(X  , Y+1));\n\tvec2 g10 = noise(vec2(X+1, Y  ));\n\tvec2 g11 = noise(vec2(X+1, Y+1));\n\t\n\tfloat q00 = dot(g00, vec2(p.x    , p.y    ));\n\tfloat q01 = dot(g01, vec2(p.x    , p.y-1.0));\n\tfloat q10 = dot(g10, vec2(p.x-1.0, p.y    ));\n\tfloat q11 = dot(g11, vec2(p.x-1.0, p.y-1.0));\n\n\tp.x = f(p.x);\n\tp.y = f(p.y);\n\t\n\tfloat qx0 = mix(q00, q10, p.x);\n\tfloat qx1 = mix(q01, q11, p.x);\n\tfloat qxy = mix(qx0, qx1, p.y);\n\n\treturn qxy;\n}\n\nfloat fbm(vec2 p)\n{\n    float f = 1.0;\n    \n    f += perlin(p\/16.)*16.;\n    f += perlin(p\/8.)*8.;\n    f += perlin(p\/4.)*4.;\n    f += perlin(p\/2.)*2.;\n    f += perlin(p\/1.)*1.;\n    \n    return f\/(1.+2.+4.+8.+16.);\n}\n\n\/* ====================== *\/\n\/* ====== Marching ====== *\/\n\/* ====================== *\/\n\nfloat scene(vec3 p)\n{\n\t\/\/ box\n\tfloat d1 = max(\n\t\tsdBox(p+vec3(0,1,0),vec3(0.52,1,0.52)),\n\t\t-sdBox(p,vec3(0.51,1,0.51))\n\t);\n\t\n\t\/\/ sculpture\n\tfloat d2 = max(\n\t\tp.y-texture2D(iChannel0, (p.xz+0.5)*SIZE\/iResolution.xy).x,\n\t\tsdBox(p,vec3(0.50,1,0.50))\n\t);\n\t\n\treturn min(d1,d2);\n}\n\nHit march(Ray r)\n{\n\tfloat t = 0.0, d;\n\n\tfor(int i = 0; i < S; i++)\n\t{\n\t\td = scene(r.o+r.d*t); t += d\/R;\n\t\tif (d <= P || t > D) { break; }\n\t}\n\n\treturn Hit(r.o+r.d*t, t, d);\n}\n\n\nRay lookAt(Camera _cam, vec2 c)\n{\n    vec3 dir = normalize(_cam.d);\n    vec3 right = normalize(cross(dir, vec3(0,1,0)));\n    vec3 up = cross(right, dir);\n \n    return Ray(_cam.p, normalize(right*c.x + up*c.y + dir));\n}\n\nmat3 lookAt(Camera cam)\n{\n\tvec3 dir = normalize(cam.d);\n    vec3 right = normalize(cross(dir,vec3(0,1,0)));\n\tvec3 up = cross(right, dir);\n \n\treturn mat3(up, right, -dir);\n}\n\nvec3 getNormal(vec3 p)\n{\n\tvec2 e = vec2(P,0);\n\n\treturn normalize(vec3(\n\t\tscene(p+e.xyy)-scene(p-e.xyy),\n\t\tscene(p+e.yxy)-scene(p-e.yxy),\n\t\tscene(p+e.yyx)-scene(p-e.yyx)\n\t));\n}\n\n\/* ===================== *\/\n\/* ====== Drawing ====== *\/\n\/* ===================== *\/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    if (fragCoord.x > SIZE || fragCoord.y > SIZE) discard;\n    \n\tfloat brush = load(vec2(9,0),iChannel1).x;\n\n    vec2 uv = fragCoord.xy\/iResolution.xy;\n    vec2 uvm = iMouse.xy\/iResolution.yy;\n    \n    fragColor = texture2D(iChannel2,uv);\n    if (fragColor.a == 0.0) { fragColor = vec4(1); }\n    if (brush != 0.4) { return; }\n    \n    float key_c  = texture2D(iChannel3, vec2(67.5\/256.,0)).x;\n    float key_sp = texture2D(iChannel3, vec2(32.5\/256.,0)).x;\n    float key_u  = texture2D(iChannel3, vec2(85.5\/256.,1)).x;\n    float key_s  = texture2D(iChannel3, vec2(83.5\/256.,0)).x;\n    float key_e  = texture2D(iChannel3, vec2(69.5\/256.,0)).x;\n    float key_f  = texture2D(iChannel3, vec2(70.5\/256.,0)).x;\n    float key_d  = texture2D(iChannel3, vec2(68.5\/256.,0)).x;\n    \n    \/\/ Clear canvas\n    if (key_c > 0.0)\n    {\n        fragColor = vec4(1);\n        return;\n    }\n    \n    float aspect = iResolution.x\/iResolution.y;\n    \n    \/\/ Color band\n    vec4 bandArea = vec4(aspect-0.045,1.-0.61, 0.035,0.47);\n   \tfloat dband = udBox(uvm-bandArea.xy,bandArea.zw);\n    \n    vec4 pickerArea = vec4(aspect-0.15,1.-0.12,0.15,0.12);\n    float dpicker = udBox(uvm-pickerArea.xy,pickerArea.zw);\n    \n    if (iMouse.w > 0.0 && key_sp < 1.0 && dpicker != 0.0 && dband != 0.0 && (key_e < 1.0 && key_s < 1.0 && key_d < 1.0 && key_f < 1.0) && (key_u > 0.0 || (key_u < 1.0 && uvm.x > 0.3)))\n    {\n        uv \/= SIZE\/iResolution.xy;\n        \n        float size  = load(vec2( 4,0),iChannel1).x*20.;\n        float blur  = load(vec2( 5,0),iChannel1).x;\n        float force = load(vec2( 6,0),iChannel1).x\/0.25;\n        float zoom  = load(vec2( 7,0),iChannel1).x\/0.5;\n        float fly   = load(vec2(15,0),iChannel1).x;\n        vec4 picker = load(vec2(18,0),iChannel1); \n        \n        vec4 iMouseLast = load(vec2(2,0),iChannel1);\n        if (iMouseLast.w < 1.0) { iMouseLast.xy = iMouse.xy; }\n\n        vec2 rot = load(vec2(fly,0),iChannel1).xy;\n        vec3 pos = load(vec2(3,0),iChannel1).xyz*1e4;\n\n        if (fly < 1.0)\n        {\n            _cam.p *= rotX(rot.x)*rotY(rot.y) * zoom;\n            _cam.d = -_cam.p;\n        }\n        else\n        {\n            _cam.p += pos;\n            _cam.d *= rotX(rot.x)*rotY(rot.y);\n        }\n        \n        vec3 c1 = march(lookAt(_cam,(2.*iMouse.xy-iResolution.xy)\/iResolution.xx)).p;\n        vec3 c2 = march(lookAt(_cam,(2.*iMouseLast.xy-iResolution.xy)\/iResolution.xx)).p;\n\n        float h = texture2D(iChannel0, (c1.xz+0.5)*SIZE\/iResolution.xy).x;\n        float d = sdLine(vec3(uv.x-0.5,h,uv.y-0.5),c1,c2,0.01*size);\n        float f = smoothstep(d,d+0.1-(1.-blur)*0.09,0.0)*0.1\/size*clamp(blur,0.1,0.9)*force;\n\n        vec4 col = vec4(hsv2rgb(vec3(clamp(picker.w,0.,1.),picker.xy)),clamp(f*100.,0.,1.));\n\t\tfragColor.rgb = fragColor.rgb*(1.-col.a) + col.rgb*col.a;\n    }\n}","name":"","description":"","type":"buffer"},{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":259,"src":"\/presets\/previz\/buffer02.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/* ======================= *\/\n\/* ====== Font Code ====== *\/\n\/* ======================= *\/\n\n\/\/ Bit Packed Sprites by Flyguy\n\/\/ https:\/\/www.shadertoy.com\/view\/XtsGRl\n\n#define CHAR_SIZE vec2(3, 7)\n#define CHAR_SPACING vec2(4, 8)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\n\/*\nTop left pixel is the most significant bit.\nBottom right pixel is the least significant bit.\n\n \u2588     010    \n\u2588 \u2588    101    \n\u2588 \u2588    101    \n\u2588\u2588\u2588 -> 111 -> 010 101 101 111 101 101 101 -> 712557\n\u2588 \u2588    101    \n\u2588 \u2588    101    \n\u2588 \u2588    101    \n*\/\n\n\/\/Automatically generated from a sprite sheet.\nfloat ch_sp = 0.0;\nfloat ch_a = 712557.0;\nfloat ch_b = 1760622.0;\nfloat ch_c = 706858.0;\nfloat ch_d = 1760110.0;\nfloat ch_e = 2018607.0;\nfloat ch_f = 2018596.0;\nfloat ch_g = 706922.0;\nfloat ch_h = 1498989.0;\nfloat ch_i = 1909911.0;\nfloat ch_j = 1872746.0;\nfloat ch_k = 1498477.0;\nfloat ch_l = 1198375.0;\nfloat ch_m = 1571693.0;\nfloat ch_n = 1760109.0;\nfloat ch_o = 711530.0;\nfloat ch_p = 711972.0;\nfloat ch_q = 711675.0;\nfloat ch_r = 1760621.0;\nfloat ch_s = 2018927.0;\nfloat ch_t = 1909906.0;\nfloat ch_u = 1497963.0;\nfloat ch_v = 1497938.0;\nfloat ch_w = 1498109.0;\nfloat ch_x = 1496429.0;\nfloat ch_y = 1496210.0;\nfloat ch_z = 2004271.0;\nfloat ch_1 = 730263.0;\nfloat ch_2 = 693543.0;\nfloat ch_3 = 693354.0;\nfloat ch_4 = 1496649.0;\nfloat ch_5 = 1985614.0;\nfloat ch_6 = 707946.0;\nfloat ch_7 = 1873042.0;\nfloat ch_8 = 709994.0;\nfloat ch_9 = 710250.0;\nfloat ch_0 = 711530.0;\nfloat ch_per = 2.0;\nfloat ch_que = 693378.0;\nfloat ch_exc = 599170.0;\nfloat ch_com = 10.0;\nfloat ch_scl = 65556.0;\nfloat ch_col = 65552.0;\nfloat ch_usc = 7.0;\nfloat ch_crs = 11904.0;\nfloat ch_dsh = 3584.0;\nfloat ch_ast = 21824.0;\nfloat ch_fsl = 304292.0;\nfloat ch_bsl = 1189001.0;\nfloat ch_lpr = 346385.0;\nfloat ch_rpr = 1118804.0;\nfloat ch_lba = 862355.0;\nfloat ch_rpa = 1647254.0;\n\nvec2 res = iResolution.xy \/ 4.0;\nvec2 print_pos = vec2(2,2);\n\n\/\/Extracts bit b from the given number.\nfloat extract_bit(float n, float b)\n{\n\treturn floor(mod(floor(n \/ pow(2.0,floor(b))),2.0));   \n}\n\n\/\/Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(float spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    \/\/Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    \/\/Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0)));\n    bounds = bounds && all(lessThan(uv,size));\n    \n    return bounds ? extract_bit(spr, bit) : 0.0;\n\n}\n\n\/\/Prints a character and moves the print position forward by 1 character width.\nfloat char(float ch, vec2 uv)\n{\n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\n\/\/Returns the digit sprite for the given number.\nfloat get_digit(float d)\n{\n    d = floor(d);\n    \n    if(d == 0.0) return ch_0;\n    if(d == 1.0) return ch_1;\n    if(d == 2.0) return ch_2;\n    if(d == 3.0) return ch_3;\n    if(d == 4.0) return ch_4;\n    if(d == 5.0) return ch_5;\n    if(d == 6.0) return ch_6;\n    if(d == 7.0) return ch_7;\n    if(d == 8.0) return ch_8;\n    if(d == 9.0) return ch_9;\n    return 0.0;\n}\n\n\/\/Prints out the given number starting at pos.\nfloat print_number(float number,vec2 pos, vec2 uv)\n{\n\tvec2 dec_pos = pos;\n    float result = 0.0;\n    \n\tfor(int i = 3;i >= 0;i--)\n    {\n        float clip = float(abs(number) > pow(10.0, float(i)) || i == 0); \/\/Clip off leading zeros.\n        \n        float digit = mod(number \/ pow(10.0, float(i)),10.0);\n        \n        result += sprite(get_digit(digit),CHAR_SIZE, uv - dec_pos) * clip;\n        \n        dec_pos.x += CHAR_SPACING.x * clip;\n    }\n    \n    return result;\n}\n\n\/* ========================= *\/\n\/* ====== UI\/Settings ====== *\/\n\/* ========================= *\/\n\n#define inside(a) (_fragCoord.x == a.x+0.5 && _fragCoord.y == a.y+0.5)\n#define load(a,b) texture2D(b,(a+0.5)\/iResolution.xy)\n#define save(a,b) if(inside(a)){fragColor=b;return;}\n#define add(uiElem) if(uiElem == true) return;\n\n\/* ===================== *\/\n\/* ====== Globals ====== *\/\n\/* ===================== *\/\n\nvec2 _uv, _uvm;\nvec2 _fragCoord;\n\nfloat _d = 1e10;\nvec3 _hiCol = vec3(0,1,0.8);\n\n\/* =================== *\/\n\/* ====== Utils ====== *\/\n\/* =================== *\/\n\nmat3 rotX(float a){float c=cos(a);float s=sin(a);return mat3(1,0,0,0,c,-s,0,s,c);}\nmat3 rotY(float a){float c=cos(a);float s=sin(a);return mat3(c,0,-s,0,1,0,s,0,c);}\n\n\/\/ http:\/\/lolengine.net\/blog\/2013\/07\/27\/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat udBox(vec2 p, vec2 s)\n{\n    return length(max(abs(p)-s,0.0));\n}\n\nfloat sdBox(vec2 p, vec2 b)\n{\n    vec2 d = abs(p)-b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdLine(vec2 p, vec2 a, vec2 b, float r)\n{\n    vec2 ab = b-a;\n    float t = dot(p-a,ab)\/dot(ab,ab);\n    return length(p-a-ab*clamp(t,0.,1.))-r;\n}\n\n\nbool hSlider(vec2 c, vec2 p, vec2 s, float x, inout vec4 fragColor)\n{\n   s \/= 2.;\n    \n   if (inside(c))\n   {\n       if (iMouse.w > 0.0 && udBox(_uvm-p-s, s+vec2(s.y\/4.,0)) == 0.0)\n       {\n           fragColor.x = (_uvm.x-p.x)\/(s.x*2.);\n       }\n       \n       if (fragColor.x == 0.0) { fragColor.x = x; }\n       \n       return true;\n   }\n    \n   x = load(c, iChannel0).x;\n    \n   float d1 = udBox(_uv-p-s, s);\n   float d2 = udBox(_uv-p-s-vec2((x-0.5)*2.*(s.x-s.y\/4.),0), vec2(s.y\/4.,s.y));\n   \n   _d = min(_d,min(d1,d2));\n    \n   if (_d>0.0) { fragColor.w = -1.; return false; }\n   if (_d==d1) { fragColor = vec4(_hiCol,1); }\n   if (_d==d2) { fragColor = vec4(1); }\n    \n   return false;\n}\n\nbool radioButton(vec3 c, vec2 p, float r, inout vec4 fragColor)\n{\n    float x = load(c.xy, iChannel0).x;\n    float d1 = max(length(_uv-p)-r,-length(_uv-p)+r*0.7);\n    float d2 = length(_uv-p)-r*0.8;\n    \n    if (inside(c.xy) && iMouse.w > 0.0 && length(_uvm-p)-r < 0.0)\n    {\n        fragColor.x = c.z;\n        return true;\n    }\n\n    _d = min(_d,min(d1,d2));\n    \n    if (_d>0.0) { fragColor.w = -1.; return false; }\n    if (_d==d1) { fragColor = vec4(_hiCol,1); }\n    if (_d==d2) { fragColor = x == c.z ? vec4(_hiCol,1) : vec4(vec3(0),0.8); }\n    \n    return false;\n}\n\nbool checkBox(vec2 c, vec2 p, float r, inout vec4 fragColor)\n{\n    float x = load(c, iChannel0).x;\n    float d1 = udBox(_uv-p, vec2(r));\n    float d2 = udBox(_uv-p, vec2(r*0.7));\n    \n    if (inside(c.xy) && iMouse.w > 0.0 && udBox(_uvm-p, vec2(r)) == 0.0 && (iGlobalTime-fragColor.y > 0.3 || iGlobalTime == fragColor.y))\n    {\n        fragColor.x = fragColor.x == 1.0 ? 0.0 : 1.0;\n        fragColor.y = iGlobalTime;\n        return true;\n    }\n\n    _d = min(_d,min(d1,d2));\n    \n    if (_d>0.0) { fragColor.w = -1.; return false; }\n    if (_d==d1) { fragColor = vec4(_hiCol,1); }\n    if (_d==d2) { fragColor = x == 1.0 ? vec4(_hiCol,1) : vec4(0,0,0,0.8); }\n    \n    return false;\n}\n\nbool colorPicker(vec2 c, vec2 p, vec2 s, float hue, inout vec4 fragColor)\n{\n   s \/= 2.;\n    \n   if (inside(c))\n   {\n       fragColor = load(c,iChannel0);\n       if (fragColor.w == 0.0) { fragColor = vec4(0.5); }       \n       \n       float d1 = udBox(_uvm-p-vec2(s.x-s.x\/4.,s.y), vec2(s.x-s.x\/4.,s.y));\n       float d2 = udBox(_uvm-p-vec2(2.*(s.x)-s.x\/5.,s.y), vec2(s.x\/5.,s.y+0.01));\n       \n       float d = min(d1,d2);\n       if (d > 0.0 || iMouse.w < 1.0) { return false; }\n       \n       p = (_uvm-p)\/vec2(2.*(s.x)-s.x\/5.,2.*s.y);\n       \n       if (d == d1)\n       { fragColor.xy = p.xy; }\n       else\n       { fragColor.w = p.y; }\n       \n       return true;\n   }\n    \n   vec4 data = load(c,iChannel0);\n   vec2 picker = data.xy*vec2(2.*(s.x)-s.x\/5.,2.*s.y)+p;\n    \n   hue = clamp(data.w,0.,1.);\n\n   \/\/ spectrum\n   float d1 = udBox(_uv-p-vec2(s.x-s.x\/4.,s.y), vec2(s.x-s.x\/4.,s.y));\n   \/\/ hue slider\n   float d2 = udBox(_uv-p-vec2(2.*(s.x)-s.x\/5.,(2.*s.y-0.01)*hue+0.005), vec2(s.x\/5.,0.005));\n   \/\/ hue band\n   float d3 = udBox(_uv-p-vec2(2.*(s.x)-s.x\/5.,s.y), vec2(s.x\/5.,s.y));\n   \/\/ picker circle\n   float d4 = max(max(length(_uv-picker)-0.01,-length(_uv-picker)+0.007),sdBox(_uv-p-s,s));\n    \n   _d = min(_d,min(min(min(d1,d2),d3),d4));\n    \n   if (_d > 0.0)\n   {\n       fragColor.w = -1.;\n       return false;\n   }\n    \n   if (_d==d1)\n   {\n       p = (_uv-p)\/vec2(2.*(s.x)-s.x\/5.,2.*s.y);\n       fragColor = vec4(hsv2rgb(vec3(hue,p)),1);\n   }\n   else if (_d==d2)\n   {\n       fragColor = vec4(1);\n   }\n   else if (_d==d3)\n   {\n       p = (_uv-p)\/vec2(2.*s.x\/5.,2.*s.y);\n       fragColor = vec4(hsv2rgb(vec3(p.y,1,1)),1);\n   }\n   else if (_d==d4)\n   {\n       \n       fragColor = vec4(1);\n   }\n    \n   return false;\n}\n\n\n\/* ======================= *\/\n\/* ====== Rendering ====== *\/\n\/* ======================= *\/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    _uv = fragCoord.xy\/iResolution.yy;\n    _uvm = iMouse.xy\/iResolution.yy;\n\n    _fragCoord = fragCoord;\n    fragColor = texture2D(iChannel0, fragCoord.xy\/iResolution.xy);\n    \n    float aspect = iResolution.x\/iResolution.y;\n    float key_sp = texture2D(iChannel3, vec2(32.5\/256.,0)).x;\n    float flymode = load(vec2(15,0),iChannel0).x;\n\n    \/\/ Drag rotate\n    if (inside(vec2(0,0)) && flymode < 1.0 && key_sp > 0.0)\n    {\n\t    vec4 iMouseLast = load(vec2(2,0), iChannel0);\n\t    if (iMouseLast.w < 1.0) { iMouseLast.xy = iMouse.xy; }\n        fragColor.yx += (iMouseLast.xy-iMouse.xy)\/iResolution.xy*vec2(-1,1)*2.;\n        return;\n    }\n    \n    \/\/ Drag rotate (flymode)\n    if (inside(vec2(1,0)) && flymode > 0.0 && key_sp > 0.0)\n    {\n\t    vec4 iMouseLast = load(vec2(2,0), iChannel0);\n\t    if (iMouseLast.w < 1.0) { iMouseLast.xy = iMouse.xy; }\n        fragColor.yx += (iMouseLast.xy-iMouse.xy)\/iResolution.xy*vec2(-1,1)*2.;\n        return;\n    }\n\n    \/\/ Last mouse position\n    if (inside(vec2(2,0)))\n    {\n        fragColor = iMouse;\n        return;\n    }\n    \n    \/\/ Camera movement\n    if (inside(vec2(3,0)) && flymode > 0.0)\n    {\n        vec3 cam_d = normalize(vec3(0,-1,1));\n        vec2 rot = load(vec2(flymode,0),iChannel0).xy;     \n        cam_d *= rotX(rot.x)*rotY(rot.y);\n        \n        vec3 right = normalize(cross(cam_d,vec3(0,1,0)));\n        \n        float key_left  = texture2D(iChannel3, vec2(83.5\/256.,0)).x;\n        float key_up    = texture2D(iChannel3, vec2(69.5\/256.,0)).x;\n        float key_right = texture2D(iChannel3, vec2(70.5\/256.,0)).x;\n        float key_down  = texture2D(iChannel3, vec2(68.5\/256.,0)).x;\n        \n        float x = key_left > 0.0 ? -1. : key_right > 0.0 ? 1. : 0.0;\n        float z = key_down > 0.0 ? -1. : key_up    > 0.0 ? 1. : 0.0;\n\n        fragColor.xyz += (right*x + normalize(cam_d)*z)\/1e6*2.;\n        \n        return;\n    }\n\n    \/\/ UI Background\n    if (fragCoord.y > 0.5)\n    {\n        float d = udBox(_uv-vec2(0.15,0),vec2(0.15,1));\n\n        _d = min(_d,d);\n\n        if (_d == d) { fragColor = vec4(vec3(0),clamp(pow(1.-_uv.x\/0.6,2.),0.,1.)); }\n    }\n    \n    float y = 0.05;\n    \n    \/\/ Settings\n    add(hSlider(vec2(4,0), vec2(0.12,1.-y), vec2(0.13,0.03), 0.30, fragColor)); y += 0.04;\n    add(hSlider(vec2(5,0), vec2(0.12,1.-y), vec2(0.17,0.03), 1.00, fragColor)); y += 0.04;\n    add(hSlider(vec2(6,0), vec2(0.12,1.-y), vec2(0.17,0.03), 0.25, fragColor)); y += 0.04;\n    add(hSlider(vec2(7,0), vec2(0.12,1.-y), vec2(0.17,0.03), 0.5, fragColor)); y += 0.04;\n    add(hSlider(vec2(8,0), vec2(0.12,1.-y), vec2(0.17,0.03), 0.5, fragColor)); y += 0.1;\n\n    add(radioButton(vec3(9,0,0.0), vec2(0.04,1.-y), 0.015, fragColor)); y += 0.04;\n    add(radioButton(vec3(9,0,0.1), vec2(0.04,1.-y), 0.015, fragColor)); y += 0.04;\n    add(radioButton(vec3(9,0,0.2), vec2(0.04,1.-y), 0.015, fragColor)); y += 0.04;\n    add(radioButton(vec3(9,0,0.3), vec2(0.04,1.-y), 0.015, fragColor)); y += 0.04;\n    add(radioButton(vec3(9,0,0.4), vec2(0.04,1.-y), 0.015, fragColor)); y += 0.123;\n    \n    add(checkBox(vec2(10,0), vec2(0.04,1.-y), 0.02, fragColor)); y += 0.05;\n    add(checkBox(vec2(11,0), vec2(0.04,1.-y), 0.02, fragColor)); y += 0.05;\n    add(checkBox(vec2(12,0), vec2(0.04,1.-y), 0.02, fragColor)); y += 0.05;\n    add(checkBox(vec2(13,0), vec2(0.04,1.-y), 0.02, fragColor)); y += 0.05;\n    add(checkBox(vec2(14,0), vec2(0.04,1.-y), 0.02, fragColor)); y += 0.05;\n    add(checkBox(vec2(15,0), vec2(0.04,1.-y), 0.02, fragColor)); y += 0.05;\n    add(checkBox(vec2(16,0), vec2(0.04,1.-y), 0.02, fragColor)); y += 0.05;\n    add(checkBox(vec2(17,0), vec2(0.275,1.-0.035), 0.015, fragColor));\n    \n    float brush = load(vec2(9,0),iChannel0).x;\n\n    \/\/ Color picker\n    add(colorPicker(vec2(18,0), vec2(aspect-0.28,1.-0.22), vec2(0.26,0.2), 0.02, fragColor));\n\n    \/\/ Color band\n    {\n        vec4 bandArea = vec4(aspect-0.045,1.-0.61, 0.025,0.37);\n\n        if(udBox(_uv-bandArea.xy,bandArea.zw) == 0.0)\n        {\n            vec2 uv = fragCoord.xy\/iResolution.xy;\n\n            if (fragCoord.x > 0.5) { uv.x = 0.975; }\n\n            fragColor = texture2D(iChannel0,uv);\n            \n            if (fragColor.a <= 0.0) { fragColor = vec4(1); }\n            if (iMouse.w < 1.0 || brush != 0.4) { return; }\n            \n            if(udBox(_uvm-bandArea.xy,bandArea.zw) == 0.0)\n            {\n                float size  = load(vec2(4,0),iChannel0).x*20.;\n                float blur  = load(vec2(5,0),iChannel0).x;\n                float force = load(vec2(6,0),iChannel0).x\/0.25;\n                vec4 picker = load(vec2(18,0),iChannel0);\n\n                vec4 iMouseLast = load(vec2(2,0),iChannel0);\n                if (iMouseLast.w < 1.0) { iMouseLast.xy = iMouse.xy; }\n\n                float d = sdLine(_uv,_uvm,iMouseLast.xy\/iResolution.yy,0.01*size);\n                float f = smoothstep(d,d+0.1-(1.-blur)*0.09,0.0)*0.1\/size*clamp(blur,0.1,0.9)*force;\n\n                vec4 col = vec4(hsv2rgb(vec3(clamp(picker.w,0.,1.),picker.xy)),clamp(f*100.,0.,1.));\n                fragColor.rgb = fragColor.rgb*(1.-col.a) + col.rgb*col.a;\n            }\n            \n            return;\n        }\n    }\n    \n    \/\/ Letters\n    if (fragCoord.y > 0.5)\n    {\n        vec2 s = vec2(300);\n        vec2 uv = _uv*s;\n        \n        float d = 0.0;\n        y = 0.956;\n        float key_q = texture2D(iChannel3, vec2(81.5\/256.,1)).x;\n\n        print_pos = floor(vec2(0.02,y)*s);\n\n        d += char(ch_s,uv);\n        d += char(ch_i,uv);\n        d += char(ch_z,uv);\n        d += char(ch_e,uv);\n        \n        print_pos = floor(vec2(0.02,y-=0.04)*s);\n        \n        d += char(ch_b,uv);\n        d += char(ch_l,uv);\n        d += char(ch_u,uv);\n        d += char(ch_r,uv);\n        \n        print_pos = floor(vec2(0.02,y-=0.04)*s);\n        \n        d += char(ch_f,uv);\n        d += char(ch_o,uv);\n        d += char(ch_r,uv);\n        d += char(ch_c,uv);\n        d += char(ch_e,uv);\n        \n        print_pos = floor(vec2(0.02,y-=0.04)*s);\n\n        d += char(ch_z,uv);\n        d += char(ch_o,uv);\n        d += char(ch_o,uv);\n        d += char(ch_m,uv);\n\n        print_pos = floor(vec2(0.02,y-=0.04)*s);\n        \n        d += char(ch_s,uv);\n        d += char(ch_c,uv);\n        d += char(ch_a,uv);\n        d += char(ch_l,uv);\n        d += char(ch_e,uv);        \n        \n        print_pos = floor(vec2(0.02,y-=0.06)*s);\n        \n        d += char(ch_b,uv);\n        d += char(ch_r,uv);\n        d += char(ch_u,uv);\n        d += char(ch_s,uv);\n        d += char(ch_h,uv);\n        \n        if (key_q > 0.0)\n        {\n            d += char(ch_sp,uv);\n            d += char(ch_lpr,uv);\n            d += char(ch_i,uv);\n            d += char(ch_n,uv);\n            d += char(ch_v,uv);\n            d += char(ch_e,uv);\n            d += char(ch_r,uv);\n            d += char(ch_t,uv);\n            d += char(ch_e,uv);\n            d += char(ch_d,uv);\n            d += char(ch_rpr,uv);\n        }\n        \n        print_pos = floor(vec2(0.08,y-=0.055)*s);\n        \n        d += char(ch_s,uv);\n        d += char(ch_c,uv);\n        d += char(ch_u,uv);\n        d += char(ch_l,uv);\n        d += char(ch_p,uv);\n        d += char(ch_t,uv);\n        \n        print_pos = floor(vec2(0.08,y-=0.04)*s);\n        \n        d += char(ch_s,uv);\n        d += char(ch_m,uv);\n        d += char(ch_o,uv);\n        d += char(ch_o,uv);\n        d += char(ch_t,uv);\n        d += char(ch_h,uv);\n        d += char(ch_e,uv);\n        d += char(ch_n,uv);\n        \n        print_pos = floor(vec2(0.08,y-=0.04)*s);\n        \n        d += char(ch_n,uv);\n        d += char(ch_o,uv);\n        d += char(ch_i,uv);\n        d += char(ch_s,uv);\n        d += char(ch_e,uv);\n        \n        print_pos = floor(vec2(0.08,y-=0.04)*s);\n        \n        d += char(ch_t,uv);\n        d += char(ch_e,uv);\n        d += char(ch_x,uv);\n        d += char(ch_t,uv);\n        d += char(ch_u,uv);\n        d += char(ch_r,uv);\n        d += char(ch_e,uv);\n        \n        print_pos = floor(vec2(0.08,y-=0.04)*s);\n        \n        d += char(ch_p,uv);\n        d += char(ch_a,uv);\n        d += char(ch_i,uv);\n        d += char(ch_n,uv);\n        d += char(ch_t,uv);\n        \n        print_pos = floor(vec2(0.02,y-=0.06)*s);\n        \n        d += char(ch_s,uv);\n        d += char(ch_c,uv);\n        d += char(ch_e,uv);\n        d += char(ch_n,uv);\n        d += char(ch_e,uv);  \n        \n        print_pos = floor(vec2(0.08,y-=0.06)*s);\n        \n        d += char(ch_s,uv);\n        d += char(ch_h,uv);\n        d += char(ch_a,uv);\n        d += char(ch_d,uv);\n        d += char(ch_o,uv);\n        d += char(ch_w,uv);\n        d += char(ch_s,uv);\n        \n        print_pos = floor(vec2(0.08,y-=0.05)*s);\n        \n        d += char(ch_o,uv);\n        d += char(ch_c,uv);\n        d += char(ch_c,uv);\n        d += char(ch_l,uv);\n        d += char(ch_u,uv);\n        d += char(ch_s,uv);\n        d += char(ch_i,uv);\n        d += char(ch_o,uv);\n        d += char(ch_n,uv);\n        \n        print_pos = floor(vec2(0.08,y-=0.05)*s);\n        \n        d += char(ch_w,uv);\n        d += char(ch_a,uv);\n        d += char(ch_t,uv);\n        d += char(ch_e,uv);\n        d += char(ch_r,uv);\n        \n        print_pos = floor(vec2(0.08,y-=0.05)*s);\n        \n        d += char(ch_v,uv);\n        d += char(ch_o,uv);\n        d += char(ch_x,uv);\n        d += char(ch_e,uv);\n        d += char(ch_l,uv);\n        d += char(ch_sp,uv);\n        d += char(ch_lpr,uv);\n        d += char(ch_x,uv);\n        d += char(ch_y,uv);\n        d += char(ch_rpr,uv);\n        \n        print_pos = floor(vec2(0.08,y-=0.05)*s);\n        \n        d += char(ch_v,uv);\n        d += char(ch_o,uv);\n        d += char(ch_x,uv);\n        d += char(ch_e,uv);\n        d += char(ch_l,uv);\n        d += char(ch_sp,uv);\n        d += char(ch_lpr,uv);\n        d += char(ch_y,uv);\n        d += char(ch_rpr,uv);    \n        \n        print_pos = floor(vec2(0.08,y-=0.05)*s);\n        \n        d += char(ch_f,uv);\n        d += char(ch_l,uv);\n        d += char(ch_y,uv);\n        d += char(ch_m,uv);\n        d += char(ch_o,uv);\n        d += char(ch_d,uv);\n        d += char(ch_e,uv);\n        \n        print_pos = floor(vec2(0.08,y-=0.05)*s);\n        \n        d += char(ch_c,uv);\n        d += char(ch_o,uv);\n        d += char(ch_l,uv);\n        d += char(ch_o,uv);\n        d += char(ch_r,uv);\n        d += char(ch_b,uv);\n        d += char(ch_a,uv);\n        d += char(ch_n,uv);\n        d += char(ch_d,uv);\n        \n        if (d > 0.0) { fragColor = vec4(1); }\n    }\n}","name":"","description":"","type":"buffer"}]}}