{"Shader":{"ver":"0.1","info":{"id":"4tS3Rw","date":"1427429353","viewed":940,"name":"Preparations","username":"movAX13h","description":"An army is moving east. <br\/>Mixture of a 3D scene with 2D sprites.","likes":15,"published":3,"flags":0,"tags":["night","ants","sandy"],"hasliked":0},"renderpass":[{"inputs":[{"id":3,"src":"\/presets\/tex02.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":26,"src":"\/presets\/cube04_0.png","ctype":"cubemap","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"id":35,"src":"\/presets\/mzk06.mp3","ctype":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ Preparations, fragment shader by movAX13h, March 2015\n\/\/ 3D scene, animated 2D sprites\n\n#define time iGlobalTime\n\n\/\/----------------------------------------------------\n\n#define MAX_SLICES 10\n#define MAX_COLORS 5\n#define MAX_FRAMES 3\n\nstruct Frame\n{\n\tint s[MAX_SLICES];  \/\/ slices\n\tvec3 c[MAX_COLORS]; \/\/ colors\n};\n\nFrame iAnt[MAX_FRAMES];\nFrame iAnt2[MAX_FRAMES];\n\t\nvoid loadSprites()\n{\n\tiAnt[0].c[0]=vec3(0.0); iAnt[0].c[1]=vec3(0.289,0.258,0.223); iAnt[0].c[2]=vec3(0.387,0.387,0.387); iAnt[0].c[3]=vec3(0.191,0.160,0.129);\t\n\tiAnt[0].s[0]=6295616; iAnt[0].s[1]=4525316; iAnt[0].s[2]=7668992; iAnt[0].s[3]=12852484; iAnt[0].s[4]=7407888; iAnt[0].s[5]=6310160; iAnt[0].s[6]=1024; \n\tiAnt[1].s[0]=6291520; iAnt[1].s[1]=4545792; iAnt[1].s[2]=7685376; iAnt[1].s[3]=12848385; iAnt[1].s[4]=7407888; iAnt[1].s[5]=6359312; iAnt[1].s[6]=1028;\n\tiAnt[2].s[0]=6291520; iAnt[2].s[1]=4525312; iAnt[2].s[2]=7607556; iAnt[2].s[3]=12864784; iAnt[2].s[4]=7407888; iAnt[2].s[5]=6297860; iAnt[2].s[6]=1024; \n\n\tiAnt2[0].c[0]=vec3(0.0); iAnt2[0].c[1]=vec3(0.289,0.258,0.223); iAnt2[0].c[2]=vec3(0.258,0.223,0.191); iAnt2[0].c[3]=vec3(0.387,0.387,0.387); iAnt2[0].c[4]=vec3(0.191,0.160,0.129);\t\n\tiAnt2[0].s[0]=0; iAnt2[0].s[1]=6292544; iAnt2[0].s[2]=6592011; iAnt2[0].s[3]=8983056; iAnt2[0].s[4]=18452; iAnt2[0].s[5]=657698; iAnt2[0].s[6]=4325408; iAnt2[0].s[7]=10240; iAnt2[0].s[8]=1056; iAnt2[0].s[9]=160; \n\tiAnt2[1].s[0]=0; iAnt2[1].s[1]=6292544; iAnt2[1].s[2]=6590987; iAnt2[1].s[3]=8983056; iAnt2[1].s[4]=18452; iAnt2[1].s[5]=4327696; iAnt2[1].s[6]=1114144; iAnt2[1].s[7]=8208; iAnt2[1].s[8]=65680; iAnt2[1].s[9]=128; \n\tiAnt2[2].s[0]=0; iAnt2[2].s[1]=6292544; iAnt2[2].s[2]=6590987; iAnt2[2].s[3]=8983056; iAnt2[2].s[4]=18452; iAnt2[2].s[5]=1181856; iAnt2[2].s[6]=4194336; iAnt2[2].s[7]=2176; iAnt2[2].s[8]=1280; iAnt2[2].s[9]=34;\n}\n\n\/\/ constant array index workaround --\nFrame frame(Frame frames[MAX_FRAMES], int id) \n{\n\tfor(int i = 0; i < MAX_FRAMES; i++)\t{ if (i == id) return frames[i]; }\n\treturn frames[1];\n}\n\nfloat slice(int id, in Frame f) \n{\n\tfor(int i = 0; i < MAX_SLICES; i++)\t{ if (i == id) return float(f.s[i]); }\n\treturn 0.0;\t\n}\n\nvec3 color(int id, in Frame f) \n{\n\tfor(int i = 0; i < MAX_COLORS; i++) { if (i == id) return f.c[i]; }\n\treturn vec3(0.0);\n}\n\/\/ --\n\nint sprite(vec2 p, in Frame f, vec2 size, in int pxPerInt, in int bitsPerPx)\n{\n\tint d = 0; p = floor(p);\n\tp.x = size.x - p.x - 1.0; \/\/ correction\n\tif (clamp(p.x, 0.0, size.x-1.0) == p.x && clamp(p.y, 0.0, size.y-1.0) == p.y)\n\t{\n\t\tfloat k = p.x + size.x*p.y, s = floor(k \/ float(pxPerInt)), n = slice(int(s), f);\n\t\tk = floor((k - s*float(pxPerInt))*float(bitsPerPx));\n\t\tif (int(mod(n\/(exp2(k)),2.0)) == 1) d += 1;\n\t\tif (bitsPerPx > 1 && int(mod(n\/(exp2(k+1.0)),2.0)) == 1) d += 2;\n\t\tif (bitsPerPx > 2 && int(mod(n\/(exp2(k+2.0)),2.0)) == 1) d += 4;\n\t}\n\treturn d;\n}\n\nvoid antV(inout vec3 col, vec2 p)\n{\n\tp.y = mod(p.y, 20.0);\n\t\n\tfloat f = floor(iGlobalTime * 18.0);\n\t\n\tif (p.x <= 0.0)\n\t{\n\t\tp.x -= step(p.x, 0.0);\n\t\tp.x = abs(p.x);\t\n\t\tf++;\n\t}\n\t\n\tf = floor(mod(f, 3.0));\n\t\n\tint i = sprite(p, frame(iAnt, int(f)), vec2(6.0, 13.0), 12, 2);\n\tcol = mix(col, color(i, iAnt[0]), min(0.8, float(i)));\n    \n    col = mix(col, vec3(0.0), 0.5*smoothstep(5.0, 0.0, length(vec2(1.0, 0.6)*p-vec2(2.0, 7.0)))); \/\/ shadow\n}\n\nvoid antH(inout vec3 col, vec2 p)\n{\n\tfloat id = floor(p.x \/ 20.0);\n\tp.x = mod(p.x, 20.0);\n\t\n\tfloat f = -floor(iGlobalTime * 13.0) + id;\n\tf = floor(mod(f, 3.0));\n\t\n\tint i = sprite(p, frame(iAnt2, int(f)), vec2(13.0, 6.0), 8, 3);\n\tcol = mix(col, color(i, iAnt2[0]), min(0.7, float(i)));\n    \n    col = mix(col, vec3(0.0), 0.4*smoothstep(5.0, 0.0, length(vec2(0.6, 1.0)*p-vec2(6.0, 5.0)))); \/\/ shadow\n}\n\n\/\/----------------------------------------------------\n\n\nfloat rand(float n)\n{\n    return fract(sin(n * 0.84949385) * 43758.5453123);\n}\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 floorTex(vec2 uv)\n{\n\treturn texture2D(iChannel0, uv * 0.4).b * vec3(0.6, 0.4, 0.2);\n}\n\nfloat height(vec2 p)\n{\n    float r = length(p);\n    return 0.25*r + 0.14*cos(5.0*r);\n}\n\nvec4 scene(vec3 p)\n{\n\t\/\/ plane\n\tvec3 ft = floorTex(p.xz);\n\tfloat d = abs(p.y - 0.08 + height(p.xz) + 0.3 - 0.1*smoothstep(0.0, 0.5, ft.b));\n\tvec3 col = ft*2.4 - 0.5*abs(sin(p.x));\n\treturn vec4(col, d);\n}\n\t\nvec3 normal(vec3 p)\n{\n\tfloat c = scene(p).w;\n\tvec2 h = vec2(0.01, 0.0);\n\treturn normalize(vec3(scene(p + h.xyy).w - c, \n\t\t\t\t\t\t  scene(p + h.yxy).w - c, \n\t\t                  scene(p + h.yyx).w - c));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec2 pos = (fragCoord.xy*2.0 - iResolution.xy) \/ iResolution.y;\n    float focus = 3.14;\n    float far = 6.5;\n\tfloat dist = 0.0;\n\t\n    float a = 0.8*sin(0.2*time);\n\t\n    vec3 cp;\n    int at;\n    float ad;\n    \n\tvec3 ct = vec3(0.0, -0.2, 0.0);\n    float t = mod(time, 15.0);\n\n    if (t < 5.0)\n    {\n        cp = vec3(1.8, 0.7, -1.8);\n        at = 0;\n        ad = 1.0;\n    }\n    else if (t < 10.0)\n    {\n        cp = vec3(2.2, 2.7, 0.2);\n        at = 1;\n        ad = 1.0;\n    }\n    else\n    {\n        cp = vec3(2.2, 1.7, 2.2);\n        at = 2;\n        ad = -1.0;\n\t\tct = vec3(1.0, -0.2, 0.0);\n    }\n    \n\t\n    #if 0\n\tif (iMouse.z > 0.0)\n\t{\n\t\tfloat d = (iResolution.y-iMouse.y)*0.01+0.5;\n\t\tcp = vec3(sin(iMouse.x*0.01)*d, 1.4*sin(2.8+iMouse.y*0.001)*d, cos(iMouse.x*0.01)*d);\n\t}\n    #endif\n\t\n\tvec3 cd = normalize(ct-cp);\n\tvec3 cu  = vec3(0.0, 1.0, 0.0);\n\tvec3 cs = cross(cd, cu);\n\tvec3 dir = normalize(cs*pos.x + cu*pos.y + cd*focus);\n\tvec3 ray = cp;\n\tbool hit = true;\n\tvec3 col = vec3(0.0);\n\tvec4 s;\n    \n    for(int i=0; i < 80; i++) \n\t{\n        s = scene(ray);\n        s.w *= 0.2;\n        dist += s.w;\n        ray += dir * s.w;\n\n        col = s.rgb;\n\t\t\n        if(dist > far) \n\t\t{\n\t\t\tdist = far;\n            hit = false;\n\t\t\tbreak;\n\t\t}\n    }\n\t\n    float b = 1.0 - dist\/far;\n\tcol = b * s.rgb;\n\n    if (!hit)\n    {\n        dir.y *= 0.5;\n        vec3 q = 0.9*textureCube(iChannel2, dir).rgb;\n        q.b *= smoothstep(0.5, 0.7, q.g);\n    \tcol = q;\n    }\n \t\n    \/\/ ants\n    loadSprites();\n    vec2 p;\n    float id;\n   \tp.x = fragCoord.x - iResolution.x * 0.5;    \n    \n    if (at == 0)\n    {\n\t    p.y = fragCoord.y - iResolution.y * (0.44 - 0.37*height(vec2(3.0*p.x\/iResolution.x, 0.0)));\n        float ax = ad*time*50.0-p.x;\n        id = floor(ax \/ 20.0);\n        p.y += 40.0*rand(id);\n        antH(col, vec2(ad*ax, -p.y));\n    }\n    else if (at == 1)\n    {\n        p.y = fragCoord.y - iResolution.y * 0.48;\n        p *= 0.7+0.5*fragCoord.y\/iResolution.y;\n        float ay = time*60.0-p.y;\n        id = floor(ay \/ 20.0);\n        float r = rand(id);\n        p.x += -10.0 + 80.0*r - 0.4*p.y;\n        p.x += 20.0*r*sin(time*r+r*123.3844);\n\t   \tantV(col, vec2(p.x, ay));\n    } \n    else\n    {\n\t    p.y = fragCoord.y - iResolution.y * (0.6 - 0.3*height(vec2(1.0+3.0*p.x\/iResolution.x, 0.0)));\n        float ax = ad*time*50.0-p.x;\n        id = floor(ax \/ 20.0);\n        p.y += 40.0*rand(id);\n        antH(col, vec2(ad*ax, -p.y));\n    }\n    \n    \/\/ color correction & post processing\n\tcol = clamp(col, vec3(0.0), vec3(1.0));\n\tcol = pow(col, vec3(2.2, 2.4, 2.5)) * 3.5;\n\tcol = pow(col, vec3(1.0 \/ 2.5));    \n\tcol -= smoothstep(0.4, 1.0, abs(pos.y));\n    col *= 1.0 - 0.2*rand(pos);\n    col *= min(1.0, abs(2.6*sin(3.1415*time\/5.0))); \/\/ blend\n    \n\tfragColor = vec4(col, 1.0);\n}\n","name":"","description":"","type":"image"}]}}