{"Shader":{"ver":"0.1","info":{"id":"Mdy3RW","date":"1453406360","viewed":207,"name":"Granular Vibration","username":"dr2","description":"Simulation of a vertically vibrated granular layer","likes":18,"published":3,"flags":32,"tags":["simulation","dynamics","multipass","grains"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ \"Granular Vibration\" by dr2 - 2016\n\/\/ License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n\/*\nSimulation of a vertically vibrated granular layer. Standing waves are\nsometimes observed. There are many parameters that can be changed to explore\nthe problem (e.g., period doubling).\n\nA standard granular particle model with velocity-dependent damping is used. Side\nboundaries are periodic.\n\n(See \"Molecular Dynamics\" shader for brief technical comments.)\n\nMouse click restarts run.\n*\/\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 32.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi = float (idVar);\n  return texture2D (txBuf, (vec2 (mod (fi, txRow), floor (fi \/ txRow)) + 0.5) \/\n     txSize);\n}\n\nconst int nMolEdge = 24;\nconst int nMol = nMolEdge * nMolEdge;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec3 col;\n  vec2 uv, ut, q;\n  float bFac, dMin, b, yBase, bLen;\n  uv = 2. * fragCoord \/ iResolution.xy - 1.;\n  uv.x *= iResolution.x \/ iResolution.y;\n  ut = abs (uv) - vec2 (1.);\n  b = max (ut.x, ut.y);\n  ut = abs (ut);\n  if (b > 0.003) col = vec3 (0.82);\n  else {\n    stDat = Loadv4 (nMol);\n    bFac = stDat.y;\n    yBase = stDat.z;\n    bLen = 0.5 * (bFac * float (nMolEdge) + 0.5);\n    q = (bLen - 0.5) * uv;\n    q.y -= 1.;\n    dMin = 1000.;\n    for (int n = 0; n < nMol; n ++)\n       dMin = min (dMin, length (q - Loadv4 (n).xy));\n    col = mix (vec3 (0.2),  vec3 (1., 1., 0.), 1. - smoothstep (0.35, 0.45, dMin));\n    col = mix (col, vec3 (0., 1., 0.),\n       1. - smoothstep (0.2, 0.3, abs (q.y + bLen - yBase + 0.2)));\n  }\n  fragColor = vec4 (col, 1.);\n}\n","name":"","description":"","type":"image"},{"inputs":[{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ \"Granular Vibration\" by dr2 - 2016\n\/\/ License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n#define mPtr iMouse\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\nconst float txRow = 32.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi = float (idVar);\n  return texture2D (txBuf, (vec2 (mod (fi, txRow), floor (fi \/ txRow)) + 0.5) \/\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi = float (idVar);\n  vec2 d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi \/ txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n\nconst int nMolEdge = 24;\nconst int nMol = nMolEdge * nMolEdge;\nconst float pi = 3.14159;\nfloat bFac, nStep, yBase, dt;\n\nvec4 Step (int mId)\n{\n  vec4 p, pp;\n  vec2 dr, dv, f;\n  float fOvlap, fric, grav, rSep, bLen;\n  fOvlap = 1000.;\n  fric = 20.;\n  grav = 10.;\n  f = vec2 (0.);\n  p = Loadv4 (mId);\n  bLen = bFac * float (nMolEdge);\n  for (int n = 0; n < nMol; n ++) {\n    pp = Loadv4 (n);\n    dr = p.xy - pp.xy;\n    if (abs (dr.x) > 0.5 * bLen) dr.x -= bLen * sign (dr.x);\n    dv = p.zw - pp.zw;\n    rSep = length (dr);\n    if (n != mId && rSep < 1.) f += (fOvlap * (1. \/ rSep - 1.) -\n       fric * dot (dr, dv) \/ (rSep * rSep)) * dr;\n  }\n  dr.y = 0.5 * (bLen + 1.) - p.y;\n  if (dr.y < 1.) {\n    dr.y = - dr.y;\n    rSep = abs (dr.y);\n    f.y += fOvlap * (1. \/ rSep - 1.) * dr.y;\n  }\n  dr.y = 0.5 * (bLen + 1.) - yBase + p.y;\n  if (dr.y < 1.) {\n    rSep = abs (dr.y);\n    f.y += fOvlap * (1. \/ rSep - 1.) * dr.y;\n  }\n  f.y -= grav;\n  p.zw += dt * f;\n  p.xy += dt * p.zw;\n  if (abs (p.x) > 0.5 * bLen) p.x -= bLen * sign (p.x);\n  return p;\n}\n\nvec4 Init (int mId)\n{\n  vec4 p;\n  float x, y, t, vel;\n  y = float (mId \/ nMolEdge);\n  x = float (mId) - float (nMolEdge) * y;\n  t = 0.25 * (2. * mod (y, 2.) - 1.);\n  p.xy = 1.2 * (vec2 (x + t, y) - 0.5 * float (nMolEdge - 1));\n  t = 2. * pi * Hashff (float (mId));\n  vel = 3.;\n  p.zw = vel * vec2 (cos (t), sin (t));\n  return p;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat, p;\n  vec2 iFrag;\n  float freq, amp;\n  int mId;\n  iFrag = floor (fragCoord);\n  mId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || mId > nMol) discard;\n  freq = 0.5;\n  amp = 2.;\n  dt = 0.005;\n  if (iFrame < 5) {\n    bFac = 3.;\n    stDat = vec4 (0., bFac, 0., 0.);\n    if (mId < nMol) p = Init (mId);\n  } else {\n    stDat = Loadv4 (nMol);\n    nStep = stDat.x;\n    ++ stDat.x;\n    bFac = stDat.y;\n    yBase = amp * (1. - cos (2. * pi * freq * nStep * dt));\n    stDat.z = yBase;\n    if (mId < nMol) p = Step (mId);\n    if (mPtr.z > 0. && stDat.x > 100.) {\n      stDat.x = 0.;\n      if (mId < nMol) p = Init (mId);\n    }\n  }\n  Savev4 (mId, ((mId < nMol) ? p : stDat), fragColor, fragCoord);\n}\n","name":"","description":"","type":"buffer"},{"inputs":[{"id":259,"src":"\/presets\/previz\/buffer02.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ \"Granular Vibration\" by dr2 - 2016\n\/\/ License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n#define mPtr iMouse\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\nconst float txRow = 32.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi = float (idVar);\n  return texture2D (txBuf, (vec2 (mod (fi, txRow), floor (fi \/ txRow)) + 0.5) \/\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi = float (idVar);\n  vec2 d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi \/ txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n\nconst int nMolEdge = 24;\nconst int nMol = nMolEdge * nMolEdge;\nconst float pi = 3.14159;\nfloat bFac, nStep, yBase, dt;\n\nvec4 Step (int mId)\n{\n  vec4 p, pp;\n  vec2 dr, dv, f;\n  float fOvlap, fric, grav, rSep, bLen;\n  fOvlap = 1000.;\n  fric = 20.;\n  grav = 10.;\n  f = vec2 (0.);\n  p = Loadv4 (mId);\n  bLen = bFac * float (nMolEdge);\n  for (int n = 0; n < nMol; n ++) {\n    pp = Loadv4 (n);\n    dr = p.xy - pp.xy;\n    if (abs (dr.x) > 0.5 * bLen) dr.x -= bLen * sign (dr.x);\n    dv = p.zw - pp.zw;\n    rSep = length (dr);\n    if (n != mId && rSep < 1.) f += (fOvlap * (1. \/ rSep - 1.) -\n       fric * dot (dr, dv) \/ (rSep * rSep)) * dr;\n  }\n  dr.y = 0.5 * (bLen + 1.) - p.y;\n  if (dr.y < 1.) {\n    dr.y = - dr.y;\n    rSep = abs (dr.y);\n    f.y += fOvlap * (1. \/ rSep - 1.) * dr.y;\n  }\n  dr.y = 0.5 * (bLen + 1.) - yBase + p.y;\n  if (dr.y < 1.) {\n    rSep = abs (dr.y);\n    f.y += fOvlap * (1. \/ rSep - 1.) * dr.y;\n  }\n  f.y -= grav;\n  p.zw += dt * f;\n  p.xy += dt * p.zw;\n  if (abs (p.x) > 0.5 * bLen) p.x -= bLen * sign (p.x);\n  return p;\n}\n\nvec4 Init (int mId)\n{\n  vec4 p;\n  float x, y, t, vel;\n  y = float (mId \/ nMolEdge);\n  x = float (mId) - float (nMolEdge) * y;\n  t = 0.25 * (2. * mod (y, 2.) - 1.);\n  p.xy = 1.2 * (vec2 (x + t, y) - 0.5 * float (nMolEdge - 1));\n  t = 2. * pi * Hashff (float (mId));\n  vel = 3.;\n  p.zw = vel * vec2 (cos (t), sin (t));\n  return p;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat, p;\n  vec2 iFrag;\n  float freq, amp;\n  int mId;\n  iFrag = floor (fragCoord);\n  mId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || mId > nMol) discard;\n  freq = 0.5;\n  amp = 2.;\n  dt = 0.005;\n  if (iFrame < 5) {\n    bFac = 3.;\n    stDat = vec4 (0., bFac, 0., 0.);\n    if (mId < nMol) p = Init (mId);\n  } else {\n    stDat = Loadv4 (nMol);\n    nStep = stDat.x;\n    ++ stDat.x;\n    bFac = stDat.y;\n    yBase = amp * (1. - cos (2. * pi * freq * nStep * dt));\n    stDat.z = yBase;\n    if (mId < nMol) p = Step (mId);\n    if (mPtr.z > 0. && stDat.x > 100.) {\n      stDat.x = 0.;\n      if (mId < nMol) p = Init (mId);\n    }\n  }\n  Savev4 (mId, ((mId < nMol) ? p : stDat), fragColor, fragCoord);\n}\n","name":"","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ \"Granular Vibration\" by dr2 - 2016\n\/\/ License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n#define mPtr iMouse\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\nconst float txRow = 32.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi = float (idVar);\n  return texture2D (txBuf, (vec2 (mod (fi, txRow), floor (fi \/ txRow)) + 0.5) \/\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi = float (idVar);\n  vec2 d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi \/ txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n\nconst int nMolEdge = 24;\nconst int nMol = nMolEdge * nMolEdge;\nconst float pi = 3.14159;\nfloat bFac, nStep, yBase, dt;\n\nvec4 Step (int mId)\n{\n  vec4 p, pp;\n  vec2 dr, dv, f;\n  float fOvlap, fric, grav, rSep, bLen;\n  fOvlap = 1000.;\n  fric = 20.;\n  grav = 10.;\n  f = vec2 (0.);\n  p = Loadv4 (mId);\n  bLen = bFac * float (nMolEdge);\n  for (int n = 0; n < nMol; n ++) {\n    pp = Loadv4 (n);\n    dr = p.xy - pp.xy;\n    if (abs (dr.x) > 0.5 * bLen) dr.x -= bLen * sign (dr.x);\n    dv = p.zw - pp.zw;\n    rSep = length (dr);\n    if (n != mId && rSep < 1.) f += (fOvlap * (1. \/ rSep - 1.) -\n       fric * dot (dr, dv) \/ (rSep * rSep)) * dr;\n  }\n  dr.y = 0.5 * (bLen + 1.) - p.y;\n  if (dr.y < 1.) {\n    dr.y = - dr.y;\n    rSep = abs (dr.y);\n    f.y += fOvlap * (1. \/ rSep - 1.) * dr.y;\n  }\n  dr.y = 0.5 * (bLen + 1.) - yBase + p.y;\n  if (dr.y < 1.) {\n    rSep = abs (dr.y);\n    f.y += fOvlap * (1. \/ rSep - 1.) * dr.y;\n  }\n  f.y -= grav;\n  p.zw += dt * f;\n  p.xy += dt * p.zw;\n  if (abs (p.x) > 0.5 * bLen) p.x -= bLen * sign (p.x);\n  return p;\n}\n\nvec4 Init (int mId)\n{\n  vec4 p;\n  float x, y, t, vel;\n  y = float (mId \/ nMolEdge);\n  x = float (mId) - float (nMolEdge) * y;\n  t = 0.25 * (2. * mod (y, 2.) - 1.);\n  p.xy = 1.2 * (vec2 (x + t, y) - 0.5 * float (nMolEdge - 1));\n  t = 2. * pi * Hashff (float (mId));\n  vel = 3.;\n  p.zw = vel * vec2 (cos (t), sin (t));\n  return p;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat, p;\n  vec2 iFrag;\n  float freq, amp;\n  int mId;\n  iFrag = floor (fragCoord);\n  mId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || mId > nMol) discard;\n  freq = 0.5;\n  amp = 2.;\n  dt = 0.005;\n  if (iFrame < 5) {\n    bFac = 3.;\n    stDat = vec4 (0., bFac, 0., 0.);\n    if (mId < nMol) p = Init (mId);\n  } else {\n    stDat = Loadv4 (nMol);\n    nStep = stDat.x;\n    ++ stDat.x;\n    bFac = stDat.y;\n    yBase = amp * (1. - cos (2. * pi * freq * nStep * dt));\n    stDat.z = yBase;\n    if (mId < nMol) p = Step (mId);\n    if (mPtr.z > 0. && stDat.x > 100.) {\n      stDat.x = 0.;\n      if (mId < nMol) p = Init (mId);\n    }\n  }\n  Savev4 (mId, ((mId < nMol) ? p : stDat), fragColor, fragCoord);\n}\n","name":"","description":"","type":"buffer"}]}}