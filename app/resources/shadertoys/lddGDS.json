{"Shader":{"ver":"0.1","info":{"id":"lddGDS","date":"1452045039","viewed":167,"name":"Everyday006 - hangover01","username":"Makio64","description":"Everyday006 - hangover01<br\/>Yesterday we celebrate the new year with dot by dot inc. team and this morning.. <img src=\"\/img\/emoticonHappy.png\"\/><br\/>\u660e\u3051\u307e\u3057\u3066\u304a\u3081\u3067\u3068\u3046\u3054\u3056\u3044\u307e\u3059!","likes":2,"published":3,"flags":0,"tags":["reflection","specular","capsule","everyday","uvplay","colortrick"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Everyday006 - hangover01\n\/\/ By David Ronai \/ @Makio64\n\n\/\/------------------------------------------------------------------ VISUAL QUALITY\n#define POSTPROCESS\n#define RAYMARCHING_STEP 45\n#define RAYMARCHING_JUMP 1.\n\/\/------------------------------------------------------------------ DEBUG\n\/\/#define RENDER_DEPTH\n\/\/#define RENDER_NORMAL\n\nconst float PI = 3.14159265359;\nconst float PI2 = 6.28318530718;\n\nvec3 orbit(float phi, float theta, float radius)\n{\n\treturn vec3(\n\t\tradius * sin( phi ) * cos( theta ),\n\t\tradius * cos( phi ),\n\t\tradius * sin( phi ) * sin( theta )\n\t);\n}\n\n\/\/------------------------------------------------------------------  SIGNED PRIMITIVES\n\/\/http:\/\/mercury.sexy\/hg_sdf\/\n\n#define saturate(x) clamp(x, 0., 1.)\n\nvec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5)\/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\n\/\/ Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n\tvec3 ab = b - a;\n\tfloat t = saturate(dot(p - a, ab) \/ dot(ab, ab));\n\treturn length((ab*t + a) - p);\n}\n\n\/\/ Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\nfloat vmax(vec3 v) {return max(max(v.x, v.y), v.z);}\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nvec3 color;\n\n\/\/------------------------------------------------------------------ MAP\nfloat map( in vec3 pos ) {\n    vec3 q = pos;\n    vec3 o = orbit(sin(iGlobalTime)*PI2,cos(iGlobalTime)*PI2,8.);\n    pMod3(q, vec3(50.,40.,50.));\n    float d = fCapsule(q,o,-o,5.);\n    float dist = distance(-o,q);\n    float dist2 = distance(o,q);\n    if(dist>dist2){color = vec3(1.,1.1,1.1);}\n    if(dist<=dist2){color = vec3(1.,0.,1.);}\n    return d;\n}\n\n\/\/------------------------------------------------------------------ RAYMARCHING\nfloat castRay( in vec3 ro, in vec3 rd, inout float depth )\n{\n\tfloat t = 15.0;\n\tfloat res;\n\tfor( int i=0; i<RAYMARCHING_STEP; i++ )\n\t{\n\t\tvec3 pos = ro+rd*t;\n\t\tres = map( pos );\n\t\tif( res < 0.01 || t > 150. ) break;\n\t\tt += res*RAYMARCHING_JUMP;\n\t\tdepth += 1.\/float(RAYMARCHING_STEP);\n\t}\n\treturn t;\n}\n\nvec3 calcNormal(vec3 p) {\n\tfloat eps = 0.001;\n\tconst vec3 v1 = vec3( 1.0,-1.0,-1.0);\n\tconst vec3 v2 = vec3(-1.0,-1.0, 1.0);\n\tconst vec3 v3 = vec3(-1.0, 1.0,-1.0);\n\tconst vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\treturn normalize( v1 * map( p + v1*eps ) +\n\t\t\t\t\t  v2 * map( p + v2*eps ) +\n\t\t\t\t\t  v3 * map( p + v3*eps ) +\n\t\t\t\t\t  v4 * map( p + v4*eps ) );\n}\n\n\/\/------------------------------------------------------------------ POSTEFFECTS\n\n#ifdef POSTPROCESS\nvec3 postEffects( in vec3 col, in vec2 uv, in float time )\n{\n\t\/\/ vigneting\n\tcol *= 0.4+0.6*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.5 );\n\treturn col;\n}\n#endif\n\nvec3 addLight(in vec3 lpos, inout vec3 col, in vec3 pos, in vec3 nor, in vec3 rd, in float thi){\n\tvec3 ldir = normalize(lpos-pos);\n\tfloat latt = pow( length(lpos-pos)*.03, .5 );\n    float trans =  pow( clamp( max(0.,dot(-rd, -ldir+nor)), 0., 1.), 1.) + 1.;\n\t\/\/col = vec3(.2,.1,.1) * (max(dot(nor,ldir),0.) ) \/ latt;\n\tcol += vec3(.3,.3,.1) * (trans\/latt)*thi;\n    return col;\n   \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv )\n{\n\tfloat depth = 0.;\n\tfloat t = castRay(ro,rd,depth);\n\n\t#ifdef RENDER_DEPTH\n\treturn vec3(depth\/10.,depth\/5.,depth);\n\t#endif\n\n\tvec3 pos = ro + t * rd;\n\tvec3 nor = calcNormal(pos);\n\n\t#ifdef RENDER_NORMAL\n\treturn nor;\n\t#endif\n\n    \/\/ lighitng        \n    vec3 lig = vec3(-0.6, 0.7, -0.5);\n    vec3 ref = reflect( rd, nor );\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    float specular = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n\n\tvec3 bg = vec3(sin(uv.x),cos(uv.y),1.+abs(sin(iGlobalTime)));\t\n    vec3 col = bg;\n    if(t<150.){\n        col \/= 3.;\n    \tcol += max(0.,dot(nor,lig))*color;\n        col += specular*.2; \n        col += fre*.2;\n    }\n    col = max(vec3(.05),col);\n\tcol += depth*vec3(1.,1.,1.)*.2;\n    col = mix( col, bg, 1.0-exp( -0.000001*t*t*t ));\n\treturn col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\treturn mat3( cu, cv, cw );\n}\n\n\n\/\/------------------------------------------------------------------ MAIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    uv.y+=sin(iGlobalTime*5.+uv.x*25.)*mod(uv.x+iGlobalTime\/3.,.5)*.15+.1;\n    uv.x+=cos(iGlobalTime\/2.+uv.y*2.)*.1+.1;\n    uv\/=1.3;\n    vec2 p = -1. + 2. * uv;\n    p.x *= iResolution.x \/ iResolution.y;\n    \n    \/\/Camera\n\tfloat radius = 50.;\n\tvec3 ro = orbit(PI\/2.-.4,PI\/2.+iGlobalTime\/5.,radius);\n\tvec3 ta  = vec3(0.);\n\tmat3 ca = setCamera( ro, ta, 0. );\n\tvec3 rd = ca * normalize( vec3(p.xy,1.) );\n\n\t\/\/ Raymarching\n\tvec3 color = render( ro, rd, uv );\n\t#ifdef POSTPROCESS\n\tcolor = postEffects( color, uv, iGlobalTime );\n\t#endif\n\tfragColor = vec4(color,1.0);\n}","name":"","description":"","type":"image"}]}}