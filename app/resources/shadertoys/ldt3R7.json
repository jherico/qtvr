{"Shader":{"ver":"0.1","info":{"id":"ldt3R7","date":"1448811790","viewed":330,"name":"mandala thing","username":"macbooktall","description":"tweaked copy of https:\/\/www.shadertoy.com\/view\/Xds3zN by inigo quilez - iq\/2013<br\/>Using palette from http:\/\/www.iquilezles.org\/www\/articles\/palettes\/palettes.htm<br\/>Thanks to Cabbibo for the suggestion!! <3","likes":13,"published":3,"flags":0,"tags":["raymarch"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ tweaked copy of https:\/\/www.shadertoy.com\/view\/Xds3zN by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec2 rotate(vec2 v, float a){\n\tfloat t = atan(v.y,v.x)+a;\n    float d = length(v);\n    v.x = cos(t)*d;\n    v.y = sin(t)*d;\n    return v;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nvec2 map( in vec3 pos )\n{\n    const float height = .22;\n    const float depth = .05;\n    const float t = 0.01;\n    pos.z = mod(pos.z,depth*10.)-0.5*depth*10.;\n\tpos.y = mod(pos.y,height*2.2)-0.5*height*2.2;\n\tpos.x = mod(pos.x,height*2.2)-0.5*height*2.2;\n    \n   \tfloat cyl = sdHexPrism( pos, vec2(height-t, depth+t));\n   \tfloat scyl = sdHexPrism( pos, vec2(height-t*2.0, depth+t+.001));\n\n    return vec2(opS(scyl, cyl), 1.5);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 0.0;\n    float tmax = 80.0;\n    \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<80; i++ )\n    {\n   \t\tvec2 res = map( ro+rd*t );\n        if(  t>tmax ) break;\n        t += res.x;\n\t\tm = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(1.0);\n    vec2 res = castRay(ro,rd);\n\n    const vec3 a = vec3(0.5, 0.5, 0.5);\n    const vec3 b = vec3(0.5, 0.5, 0.5);\n    const vec3 c = vec3(2., 1., 0.);\n    const vec3 d = vec3(0.5, 0.2, 0.25);\n\n    col = palette(res.x, a, b, c, d);\n    col = mix( col, vec3(1.0), 1.0-exp( -.25*res.x*res.x ) );\n\n\treturn col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\nvec3 cw = normalize(ta-ro);\nvec3 cp = vec3(sin(cr), cos(cr),0.0);\nvec3 cu = normalize( cross(cw,cp) );\nvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy\/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x\/iResolution.y;\n    p = rotate(p,2.*atan(p.y, p.x));\n \n\t\/\/ camera\n\tvec3 ro = vec3(0., 0.,iGlobalTime*0.2 );\n\t\n    vec3 ta = ro+vec3( 0., 0.,1. );\n\t\n    \/\/ camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 3.14159\/2.0 );\n\n    \/\/ ray direction\n\tvec3 rd = ca * normalize(vec3(p.xy,.5));\n\n    \/\/ render\n    vec3 col = render( ro, rd );\n\n    fragColor=vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}}