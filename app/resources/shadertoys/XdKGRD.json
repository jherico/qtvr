{"Shader":{"ver":"0.1","info":{"id":"XdKGRD","date":"1453494776","viewed":127,"name":"2D Radial Repeat : Hex GridClick","username":"aiekick","description":"Based on the hex pattern from a shader of nimitz ( i not find the shader anymore <img src=\"\/img\/emoticonHappy.png\"\/>)<br\/>ckick on cells for full screen","likes":10,"published":3,"flags":0,"tags":["2d","radial","hex","repeat"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by Stephane Cuillerdier - @Aiekick\/2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ Tuned via XShade (http:\/\/www.funparadigm.com\/xshade\/)\n\/\/ here the XShade file i used for tuning the shader : http:\/\/www.funparadigm.com\/2016\/01\/23\/2d-radial-repeat-hex\/\n\/\/ there is some dedicated widget already configured, ready to tune. enjoy :)\n\nconst vec2 gridSize = vec2(3.,3.);\/\/grid size (columns, rows)  \nconst vec3 startColor = vec3(1,0.26,0);\nconst vec3 endColor = vec3(0.33,0.2,0.49);\n\nvec3 pattern(vec2 uv, vec4 v, vec3 k)\n{\n\tfloat a = atan(uv.x, uv.y)\/3.14159*floor(k.y);\n\tfloat r = length(uv)*4.;\n\tuv = vec2(a,r);\n\tuv.x *= floor(uv.y)-k.x;\n\tuv.x += iGlobalTime ;\n\tvec3 color = mix(startColor, endColor, vec3(floor(uv.y)\/6.));\n\tuv = abs(fract(uv)-0.5);\n\tfloat x = uv.x*v.x;\n\tfloat y = uv.y*v.y;\n\tfloat z = uv.y*v.z;\n\treturn color \/ (abs(max(x + y,z) - v.w)*k.z);\n}\n\nfloat EncID(vec2 s, vec2 h, vec2 sz) \/\/ encode id from coord \/\/ s:screenSize \/ h:pixelCoord \/ sz=gridSize\n{\n    float cx = floor(h.x\/(s.x\/sz.x));\n    float cy = floor(h.y\/(s.y\/sz.y));\n    return cy*sz.x+cx;\n}\n\nvec2 DecID(float id, vec2 sz) \/\/ decode id to coord \/\/ id:cellId \/ sz=gridSize\n{\n    float cx = mod(float(id), sz.x);\n    float cy = (float(id)-cx)\/sz.x;\n    return vec2(cx,cy);\n}\n\nvec3 getcell(vec2 s, vec2 h, vec2 sz) \/\/ return id \/ uv\n{\n    float cx = floor(h.x\/(s.x\/sz.x));\n    float cy = floor(h.y\/(s.y\/sz.y));\n    \n    float id = cy*sz.x+cx;\n    \n    vec2 size = s\/sz;\n    float ratio = size.x\/size.y;\n    vec2 uv = (2.*(h)-size)\/size.y - vec2(cx*ratio,cy)*2.;\n    uv*=1.5;\n    \n    return vec3(id, uv);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cell = getcell(iResolution.xy,gl_FragCoord.xy,gridSize);\n    if(iMouse.z>0.) \n\t{\n\t\tcell.x = EncID(iResolution.xy,iMouse.xy,gridSize);\n\t\tcell.yz = gl_FragCoord.xy;\n\t}\n\t\n\tvec2 uv = 1.6 * (2.*gl_FragCoord.xy - iResolution.xy)\/iResolution.y;\n\t\n\tvec4 p;\n    \n\tvec3 k = vec3(-.3, 5, 4); \/\/ alternance, density, glow\n\n\tif (cell.x == 0.) {p = vec4(1.2,0.92,1.88,0.8);}\n\tif (cell.x == 1.) {p = vec4(2.2,0,1.88,0.8);}\n\tif (cell.x == 2.) {p = vec4(2.2,0,4,0.8);}\n\tif (cell.x == 3.) {p = vec4(1,0,4,0.8);}\n\tif (cell.x == 4.) {p = vec4(1.2,0,2.12,0.64);}\n\tif (cell.x == 5.) {p = vec4(4,4,1,0.8);}\n\tif (cell.x == 6.) {p = vec4(1,2.96,4,0.8);}\n\tif (cell.x == 7.) {p = vec4(1.5,0.96,1.8,0.4);}\n\tif (cell.x == 8.) {p = vec4(1.2,2.24,0,0.68);}\n\t\n\tvec3 hex = clamp(pattern(uv, p, k),0.,1.);\n\t\n\tfragColor = vec4(hex, 1.0);\n}\n","name":"","description":"","type":"image"}]}}