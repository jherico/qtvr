{"Shader":{"ver":"0.1","info":{"id":"ldc3zN","date":"1448698547","viewed":451,"name":"Sphere vs Zomboy","username":"jcowles","description":"sphere + bwaaaaa bwaaaaa bwaaa pew pew pew","likes":6,"published":3,"flags":0,"tags":["raymarched","sphere","audio","demo"],"hasliked":0},"renderpass":[{"inputs":[{"id":15,"src":"\/presets\/tex10.png","ctype":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":24,"src":"\/presets\/cube02_0.jpg","ctype":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"id":261,"src":"https:\/\/soundcloud.com\/zomboy\/skull-n-bones","ctype":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\n\n\/\/ ---------------------------------------------------------------------- \/\/\n\/\/ External code\n\/\/ ---------------------------------------------------------------------- \/\/\n\/\/ http:\/\/iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nfloat sdCylinder(vec3 p, vec3 c) {return length(p.xz-c.xy)-c.z;}\nfloat sdSphere(vec3 p, float s) {return length(p)-s;}\n\/\/ http:\/\/www.neilmendoza.com\/glsl-rotation-about-an-arbitrary-axis\/\nmat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);float s = sin(angle);float c = cos(angle);float oc = 1.0 - c;\n    return mat4(oc*axis.x*axis.x+c,       oc*axis.x*axis.y-axis.z*s,oc*axis.z*axis.x+axis.y*s,0.0,\n                oc*axis.x*axis.y+axis.z*s,oc*axis.y*axis.y+c,       oc*axis.y*axis.z-axis.x*s,0.0,\n                oc*axis.z*axis.x-axis.y*s,oc*axis.y*axis.z+axis.x*s,oc*axis.z*axis.z+c,       0.0,\n                0.0,0.0,0.0,1.0);\n}\n\/\/ ---------------------------------------------------------------------- \/\/\n\nfloat bumpAmt = 0.0;\nfloat strobeAmt = 10.0;\nfloat globalTime = 0.0;\nfloat darkAmt = 0.0;\nfloat lightAmt = 0.0;\nvec4 _m;\n\nfloat noise1(vec2 uv){\n\treturn texture2D(iChannel1, uv).x;   \n}\nfloat noise1s(vec2 uv){\n\treturn noise1(uv)*2.0 - 1.0;\n}\nvec4 getMusic(){\n    return _m;\n}\nvec4 blinnPhong(vec3 l, vec3 p, vec3 n, vec3 c)\n{\n    \/\/ Diffuse\n    vec4 diff = vec4(c * max(dot(n, (l - p) \/ length(l - p)), 0.0) * 1., 1.0);\n    \/\/ Specular\n    return diff + vec4(c * \n                   pow(max(\n                       dot(n, normalize(((l - p) \/ length(l - p)) \n                                        + normalize(-p))), 0.0), 64.0) * 1., 1.0);\n}\nvec2 intersect(vec3 ro, vec3 rd, \n               out vec3 pOut, out vec3 nOut)\n{\n    vec3 xf = vec3(0.0, 0.0, 0.);\n    float r = mix(.4,\n                  getMusic().x * getMusic().x*.9,\n                  .5*bumpAmt);\n    \n    \/\/ Matrix constructed as inverse.\n    mat4 rot = rotationMatrix(vec3(0,0,1), 3.1415\/2.);\n    \/\/ Translation after roation\n    rot[3].xyz = vec3(-1., 1., 0.);\n            \n    \/\/ ray parameter\n    float t = 0.0;\n    \n    for (float i = 0.0; i < 40.0; i += 1.) {\n       \tvec3 p = ro + rd * t;\n        vec4 pCyl = rot*vec4(p,1.0);\n        float dd = sdSphere(p-xf, r);\n        \n        if (abs(dd) < 0.01) {\n            pOut = p;\n            nOut = normalize(p-xf);\n\t\t\treturn vec2(t, 1.0);\n        }\n        \n\t\tfloat dc = sdCylinder((pCyl).xyz, vec3(0.,0.,.1));\n        if (abs(dc) < 0.01) {\n            pOut = (vec4(p,1.)*rot).xyz;\n            nOut = vec3(0);\/\/normalize(p-xf);\n\t\t\treturn vec2(t, 2.0);\n        }\n        \n        float dc2 = sdCylinder(vec3(0.,0.,.4+ getMusic().z)+(pCyl).xyz, vec3(0.,0.,.1));\n        if (abs(dc2) < 0.01) {\n            pOut = (vec4(p,1.)*rot).xyz;\n            nOut = vec3(0); \/\/normalize(p-xf);\n\t\t\treturn vec2(t, 2.0);\n        }\n        \n        float dc3 = sdCylinder(vec3(0.,0.,-.4- getMusic().z)+(pCyl).xyz, vec3(0.,0.,.1));\n        if (abs(dc3) < 0.01) {\n            pOut = (vec4(p,1.)*rot).xyz;\n            nOut = vec3(0); \/\/normalize(p-xf);\n\t\t\treturn vec2(t, 2.0);\n        }\n\n        t += min(min(min(abs(dd), abs(dc))\n                 ,dc2)\n                 ,dc3)-.008;\n    }\n    \n   \tnOut = vec3(0);\n    pOut = vec3(0);\n    \n    return vec2(0.0, 0.0);\n}\n\/\/ Specialized intersector just for tubes to make secondary rays\n\/\/ super fast.\nvec2 intersectTubes(vec3 ro, vec3 rd)\n{\n    mat4 rot = rotationMatrix(vec3(0,0,1), 3.1415\/2.);\n    rot[3].xyz = vec3(-1., 1., 0.);\n    float t = 0.0;\n    \n    vec3 offsetPlus = vec3(0.,0.,.4+ getMusic().z);\n    vec3 offsetMinus = vec3(0.,0.,-.4- getMusic().z);\n    \n    for (float i = 0.0; i < 10.0; i += 1.) {\n       \tvec3 p = ro + rd * t;\n        vec3 pCyl = (rot*vec4(p,1.0)).xyz;\n\t\tfloat dc = sdCylinder(pCyl, vec3(0.,0.,.1));        \n        dc = min(dc, sdCylinder(offsetPlus+pCyl, vec3(0.,0.,.1)));\n        dc = min(dc, sdCylinder(offsetMinus+pCyl, vec3(0.,0.,.1)));\n        if (abs(dc) < 0.01) {\n\t\t\treturn vec2(t, 2.0);\n        }\n\n        t += dc -.001;\n    }\n        \n    return vec2(0.0, 0.0);\n}\nvec4 getColor2(vec3 ro, vec3 rd)\n{\n    \/\/ For speed, only accept hits from the tubes.\n    return mix(vec4(0),\n               vec4(1),\n               vec4(intersectTubes(ro, rd).y == 2.0));\n}\nvec4 getColor(vec3 ro, vec3 rd, vec3 offset) {\n    \/\/ Intersection\n    vec3 p, n;\n    vec2 hit;\n    \n    \/\/ hit.x = ray parameter\n    \/\/ hit.y = object id\n    hit = intersect(ro, rd, p, n);\n    if (hit.x == 0.0) {\n        return vec4(.5*textureCube(iChannel0, rd-offset)\n                   +.5*textureCube(iChannel0, rd+offset));\n    }\n    vec4 normColor = vec4(.5 * n + .5, 1.0);\n    vec4 hitColor = vec4(.0,.0,.0, 1.0);\n    \n    \/\/ Lighting\n    \n    \/\/return hitColor;\n    hitColor += .75*vec4(textureCube(iChannel0, reflect(rd, n)).rgb, 1.0);\n    \n    hitColor += .8*getColor2(p + n*.01, reflect(rd,n));\n    \n    float flake = texture2D(iChannel1, n.yz*3.0).x;\n    flake += .1*texture2D(iChannel1, n.xz).x;\n    float fresnelDarken = dot(-rd,n);\n    vec3 c = .5*vec3(1.,1,1.);\n    fresnelDarken *= fresnelDarken;\n    hitColor += fresnelDarken*flake*blinnPhong(vec3(3,1,0), p, n, c);\n    hitColor += fresnelDarken*flake*blinnPhong(vec3(-3,1,0), p, n, c);\n    hitColor += fresnelDarken*flake*blinnPhong(vec3(0,1,0), p, n, c);\n    \n    return mix(hitColor,\n               vec4(1),\n               vec4(hit.y != 1.0));    \n}\nvec4 strobe(vec4 color) \n{\n    return 1.7*color \n         * 1.5 * vec4(getMusic().x*.6, getMusic().x*.4, .3*getMusic().x, 1.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ XXX: should be vec2(0.), but requres vec2(1.,0.)\n    _m = texture2D(iChannel2, vec2(1.0,0.));\n    \/\/ Mouse controls\n    vec2 mo = iMouse.xy\/iResolution.xy;\n    mo -= vec2(.5,.5);\n\n    globalTime = iChannelTime[2] + .4;\n    \/\/ drop\n    float fadeIntro = mix(0.0, 1.0, globalTime\/5.85);\n    float fadeIn = smoothstep(60.0, 61.0, globalTime);\n    float fadeSpin = smoothstep(17.0, 20.5, globalTime);\n    float fadeBump = smoothstep(20.0, 30.5, globalTime);\n    float fadeCamSpaz = fadeBump;\n    float fadeFirstBreak = smoothstep(28.0, 30.5, globalTime);\n    bumpAmt = .1+fadeBump;\n    \n    fadeSpin = fadeSpin*(.9+getMusic().x\/45.);\n        \n    \/\/ Fade in: 6s\n\tif (fadeIntro < 1.0) {\n        fragColor = vec4(vec3(fadeIntro-.15), 1.0);\n        return;\n    }\n    \n    if (globalTime < 16.25) {\n\t\tbumpAmt = 1.0;   \n    }\n\n    if (globalTime > 28.0 && globalTime < 39.2) {\n        fadeCamSpaz = 0.0;\n        fadeSpin = 0.0;\n        bumpAmt = mix(0.2,0.6, (globalTime-28.0)\/(39.2-28.0));\n    }\n        \n    if (globalTime > 228.) {\n    \tfragColor = vec4(vec3(1.-(globalTime-228.)\/(233.-228.)),1.0);\n    }\n    \n    \/\/ Calm, looing up from below\n    if (globalTime > 27.0 && globalTime < 59.5) {\n        float s = globalTime\/59.5;\n     \tfadeCamSpaz = mix(0.0, fadeCamSpaz, s);\n        fadeSpin  = mix(0.0, fadeSpin, s);\n        bumpAmt = mix(0.0, bumpAmt, s);\n        \n        \/\/ Build up, looking down\n        if (globalTime < 39.2) {\n    \t    mo += vec2(.5, 1.0);\n        }\n        if (globalTime > 59.5 && globalTime < 60.) {\n\t\t\tmo += vec2(.5, 1.0);\n        }\n    }\n    \n    \/\/ First Drop, looking up from below\n    if (globalTime > 61.0 && globalTime < 85.) {\n        mo += vec2(.5, 1.0);\n    }\n\n    \/\/ 1:25 - grr, looking up from below\n    if (globalTime > 126.8 && globalTime < 128.) {\n        mo += vec2(.5, 1.0)+.4*getMusic().x;\n        \/\/darkAmt = 1.0;\n    }\n    \n    \/\/ faster at 116\n    \/\/ 138 - drop out\n    \/\/ 148 - build\n    \/\/ 160 - drop in\n    if (( globalTime > 0.5 && fadeIntro >= 1.0 && globalTime < 6.1)\n       ||(globalTime > 16.25 && fadeIn < 1.0) \n       ||(globalTime > 104.5 && globalTime < 160.5)\n    ) {\n    \tstrobeAmt = fadeIn = getMusic().x;\n        float s = (globalTime-104.5)\/(160.0-104.5);\n     \tfadeCamSpaz = mix(0.0, fadeCamSpaz, s);\n        \/\/fadeSpin  = 0.5; \/\/mix(0., 0.1, globalTime\/110.); \/\/mix(0.0, fadeSpin, s);\n        fadeSpin  = mix(0.0, fadeSpin, s);\n        bumpAmt = mix(0.0, bumpAmt, s);\n\n        if ((globalTime > 60. && globalTime < 116.) \n            || (globalTime > 138. && globalTime < 140.5)\n            || (globalTime > 143.5 && globalTime < 146.5 )\n        ) {\n    \t    mo += vec2(.5, 1.0);\n        }\n    }\n    \n    if (globalTime > 160.5 && globalTime < 204.) {\n     \tdarkAmt = mix(0.3, 1.0, (globalTime-160.5)\/(204.-160.5));\n        if (globalTime < 170. || globalTime > 171.5)\n        \tmo += vec2(.5, 1.0);\n    }\n    \n    if ((globalTime > 203. && globalTime < 320.))\n    {\n    \tstrobeAmt = fadeIn = getMusic().x;\n        float s = (globalTime-204.)\/(220.0-204.);\n     \tfadeCamSpaz = mix(0.0, fadeCamSpaz, s);\n        fadeSpin  = getMusic().x\/45.; \/\/mix(0.0, fadeSpin, s);\n        bumpAmt = mix(0.0, bumpAmt, s);\n        lightAmt = mix(0.0, 1.0, s);\n        darkAmt = mix(1.0, 0.0, s);\n    }\n    \n    if (( globalTime > 11.0 && globalTime < 11.2))\n\t{\n        strobeAmt = fadeIn = getMusic().x;\n\t}\n    \t\n    \n    \/\/ Camera, spherical coords\n\tfloat an1 = -6.2831*mo.x + 1.55 \n        \t\t+ mix(1.0,\n                      (.1*globalTime*10.0 + noise1(vec2(globalTime)*.2)),\n                      fadeSpin)\n        \t;\n\tfloat an2 = clamp(1.0  + 1.5*mo.y, 0.3, 3.35)\n        \t\t+ mix(mix(0.0, noise1(vec2(globalTime)*.2), fadeCamSpaz),\n                      0.0, fadeFirstBreak);\n    vec3 ro = normalize(vec3(sin(an2)*cos(an1), cos(an2)-0.5, sin(an2)*sin(an1)));\n    \n\tvec2 uv = (2.*fragCoord.xy - iResolution.xy) \/ iResolution.y;\n    \n    \/\/ Camera Transform\n    vec3 ww = normalize(vec3(0.,0.,0.) - ro);\n    vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));\n    vec3 vv = normalize(cross(ww,uu));\n    \/\/ Ray Direction\n    vec3 rd = normalize(uv.x*uu + uv.y*vv + 1.4*ww);\n    \n    vec3 offset;\n    {\n    \tfloat m = getMusic().x*.02;\n    \tfloat n1 = noise1s(vec2(globalTime));\n    \tfloat n2 = noise1s(vec2(globalTime*7.));\n    \tfloat n3 = noise1s(vec2(globalTime*3.));\n    \toffset = vec3(m*n1,m*n2,m*n3);   \n    }\n    \n    vec4 c = getColor(ro, rd, offset);\n    \n    c.r = mix(c.r,\n        \t  getColor(ro, rd \n        \t\t\t       +vec3(noise1(uv+sin(globalTime)*1e7)*.04 \n                      \t   \t\t      +(getMusic().x*.12-.066)),\n                       offset).r,\n    \t\t  float(  (globalTime > 126.8 && globalTime < 128.)\n        \t\t\t|| (globalTime > 80.5 && globalTime < 83.)\n        \t\t\t|| (globalTime > 92.0 && globalTime < 93.5)\n        \t\t\t|| (globalTime > 103.5 && globalTime < 105.)\n        \t\t\t|| (globalTime > 138.0 && globalTime < 139.)\n        \t\t\t|| (globalTime > 158. && globalTime < 160.)\n        \t\t\t|| (globalTime > 180.5 && globalTime < 182.5)\n        \t\t\t|| (globalTime > 191.5 && globalTime < 193.0)\n        \t\t\t|| (globalTime > 203. && globalTime < 204.0)\n        \t\t\t|| (globalTime > 59.5 && globalTime < 61.) \n       \t\t\t\t)\n             );\n\n    \n    c.b += mix(.0,  getMusic().x*.5, fadeIn);\n    c.rgb = pow(c.rgb, vec3(1.3));\n   \tfragColor = mix(strobe(c), c, \n                    1.0 - \n                    fadeIn*strobeAmt * \n                    (.5+.5*sin(2.*globalTime)));\n    fragColor = mix(fragColor,\n                    fragColor - .7*(length(uv)*length(uv)),\n                    darkAmt);\n    fragColor = mix(fragColor,\n                    fragColor + .7*(length(uv)*length(uv)),\n                    lightAmt);    \n    fragColor = fragColor - .02*(length(uv)*length(uv)*length(uv)*length(uv));\n}\n\n","name":"","description":"","type":"image"}]}}