{"Shader":{"ver":"0.1","info":{"id":"Msy3zw","date":"1453703788","viewed":169,"name":"Soft CSG Superlogic","username":"paniq","description":"A design for a function that unifies hard and soft and\/or\/sub CSG operations","likes":8,"published":3,"flags":0,"tags":["intersection","sub","soft","smooth","difference","union","and","or"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/#define ALTSMOOTH\n\n\/\/ a, b: input distances\n\/\/ s.x,s.y: -1\/1 signs to switch comparison polarity\n\/\/ s.z,s.w: radius & scaling factor, as returned by soft_coeffs()\n#ifdef ALTSMOOTH\nfloat csg_op (float a, float b, vec4 s) {\n\ta *= s.x;\n    b *= s.y;\n    return s.x*(length(max(vec2(a,b) + s.z,0.0)) + min(-s.z,max(a,b))); \n}\n#else\nfloat csg_op (float a, float b, vec4 s) {\n\ta *= s.x;\n    b *= s.y;\n    float d = abs(a - b);\n    float e = max(s.z + d*s.w, 0.0);\n    return s.x*(max(a, b) + e*e);\n}\n#endif\n\nvec2 soft_coeffs(float r) {\n#ifdef ALTSMOOTH\n    return vec2(r);\n#else\n    float w = (r > 0.0)?0.5*inversesqrt(r):0.0;\n    return vec2(r*w, -w);\n#endif\n}\n\nvec4 csg_and (float r) {\n    return vec4(1.0,1.0,soft_coeffs(r));\n}\n\nvec4 csg_sub (float r) {\n    return vec4(1.0,-1.0,soft_coeffs(r));\n}\n\nvec4 csg_or (float r) {\n    return vec4(-1.0,-1.0,soft_coeffs(r));\n}\n\n#define OP_COUNT 6.0\nvec4 getfactor (int i) {\n    if (i == 0) { \/\/ or\n        return csg_or(0.0);\n    } else if (i == 1) { \/\/ soft or \n        return csg_or(0.2);\n    } else if (i == 2) { \/\/ soft sub \n        return csg_sub(0.2);\n    } else if (i == 3) { \/\/ sub \n        return csg_sub(0.0);\n    } else if (i == 4) { \/\/ soft and\n        return csg_and(0.0);\n    } else { \/\/ soft and\n        return csg_and(0.2);\n\t}\n}\n\n\/\/-------------------------------------------------------\n\nfloat circle (vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat square (vec2 p, float r) {\n    p = abs(p) - r;\n    return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\nvec2 circles (vec2 p) {\n    float r = 0.6;\n    return vec2(\n        square(p - vec2(-r*0.7, 0.0), r), \n        circle(p - vec2(r*0.4, 0.0), r*0.7));\n}\n\n\/\/-------------------------------------------------------\n\nfloat outline (float d) {\n    return 1.0 - smoothstep(0.0, 3.0 \/ iResolution.y, abs(d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec2 p = uv * 2. - 1.;\n    p.x *= iResolution.x \/ iResolution.y;\n    \n    vec2 m = (iMouse.xy \/ iResolution.xy)*2.0-1.0;\n    m.x *= iResolution.x \/ iResolution.y;\n\n    float k = iGlobalTime*0.5;\n    float u = smoothstep(0.0,1.0,smoothstep(0.0,1.0,fract(k)));\n    int s1 = int(mod(k,OP_COUNT));\n    int s2 = int(mod(k+1.0,OP_COUNT));\n    vec4 op1 = getfactor(s1);\n    vec4 op2 = getfactor(s2);\n    vec4 args = mix(op1,op2,u);\n\n    vec2 c = circles(p);\n    float d = csg_op(c.x, c.y, args);\n\n    vec2 c2 = circles(m);\n    float d2 = abs(csg_op(c2.x, c2.y, args));\n    \n    float s = abs(mod(d, 0.1)\/0.1 - 0.5);    \n\tfragColor = vec4(((iMouse.z > 0.5)?outline(circle(p-m,d2)):0.0)+s+vec3(outline(d) + 0.3 * step(d,0.0)),1.0);\n}","name":"","description":"","type":"image"}]}}