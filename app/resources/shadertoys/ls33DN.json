{"Shader":{"ver":"0.1","info":{"id":"ls33DN","date":"1449667918","viewed":323,"name":"70s Wallpaper","username":"Shane","description":"A 2D, square Truchet pattern, in under a tweet.","likes":12,"published":3,"flags":0,"tags":["2d","truchet","minified"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/*\n\n\t70s Wallpaper\n\t-------------\n\n\t2D, square Truchet pattern, in under a tweet. I was looking at Fabrice and JT's\n\t2D Truchet efforts, and got to wondering just how few characters would be necessary\n\tto achieve a passable pattern.\n\n\tI didn't make a great effort to \"code golf\" this, because I wanted it to be readable, \n\tor at least a little bit. I also prefer to maintain a modicum of accuracy and \n\tefficiency. However, I'm sure someone out there could shave off a few characters.\n\n\tBy the way, just for kicks, I included a slightly obfuscated. one line version below.\n\n    More sophisticated examples:\n    \n    TruchetFlip - jt \/\/ Simple, square tiling.\n    https:\/\/www.shadertoy.com\/view\/4st3R7\n    \n    TruchetFlip2 - FabriceNeyret2 \/\/ The checkerboard flip is really clever.\n    https:\/\/www.shadertoy.com\/view\/lst3R7\n\n\tTwisted Tubes - Shane \/\/ 3D, cube-based Truchet example. Several tweets. :)\n\thttps:\/\/www.shadertoy.com\/view\/lsc3DH\n\n*\/\n\n\nvoid mainImage( out vec4 o, vec2 p ){\n    \n    \/\/ Screen coordinates. I kind of feel like I'm cheating with the constant divide.\n    \/\/ 834144373 and iapafoto suggested that I could incorporate the first line into the \n    \/\/ line below like so:\n    \/\/\n    \/\/ p.x *= sign(cos(length(ceil(p\/=50.))*99.)); \n\t\/\/ \n    \/\/ I'm going to trust the compiler and do it, but here's the original two lines.\n    \/\/ \n    \/\/ p \/= 50.;\n    \/\/ p.x *= sign(cos(length(ceil(p))*99.));\n\t\n    \/\/ Randomly flipping the tile, based on its unique ID (ceil(p)), which in turn, is based \n    \/\/ on its position. The idea to use \"ceil\" instead of \"floor\" came from Fabrice's example.\n    p.x *= sign(cos(length(ceil(p \/= 50.))*99.));\n    \n    \/\/ Drawing the tile, which consists of two arcs: tileArc = min(length(p), length(p-1.));\n    \/\/ Using \"cos\" to repeat the arcs... more or less: value = cos(tileArc*2*PI*repeatFactor);\n    \/\/ The figure \"44\" is approximately PI*2*7, or TAU*7.\n    o = o - o + cos(min(length(p = fract(p)), length(--p))*44.); \/\/ --p - Thanks, Coyote.\n    \n    \/\/ Gaudy color, yet still not garish enough for the 70s. :)\n    \/\/o = sqrt(2.*cos(min(length(p = fract(p)), length(--p))*vec4(1, 3, 3, 1)*6.3));\n    \/\/o = cos(min(length(p = fract(p)), length(--p))*vec4(1, 3, 3, 1)*12.6);\n    \n    \/\/o =  cos( min( length(p = fract(p)),  length(--p) )  * 31.4*vec4(2, 1, .2,0) ); \/\/ Fabrice coloring. :)\n    \n}\n\n\n\/*\n\/\/ One line version. Also under a tweet.\nvoid mainImage( out vec4 o, vec2 p ){\n    \n    \/\/ Ridiculous (as in stupid) one liner:\n    o = o - o + cos(min(length(p = fract(p *= vec2(sign(cos(length(ceil(p\/=50.))*99.)), 1))), length(--p))*44.);\n\n}\n*\/\n\n\/*\n\/\/ Here a more trustworthy version.\nvoid mainImage( out vec4 o, in vec2 p ){\n\n\tp \/= iResolution.y*.1;\n\t\n    p.x *= sign(fract(sin(dot(floor(p), vec2(41, 289)))*43758.5453)-.5);\n                \n    p = fract(p);\n                \n    o = o - o + cos(min(length(p), length(p - 1.))*6.283*7.);\n    \n}\n*\/","name":"","description":"","type":"image"}]}}