{"Shader":{"ver":"0.1","info":{"id":"ltsXzl","date":"1439096222","viewed":786,"name":"Cubic Hermite Rectangle","username":"demofox","description":"Using ray marching to render a cubic hermite rectangle.  Raytrace bounding box, raymarch interior.  The control points of the rectangle are 1d, which makes it easier to render, but limits the control points to only moving on the Y axis.","likes":1,"published":3,"flags":0,"tags":["3d","hermite"],"hasliked":0},"renderpass":[{"inputs":[{"id":24,"src":"\/presets\/cube02_0.jpg","ctype":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"#define SHOW_BOUNDINGBOX   0\n#define SHOW_CONTROLPOINTS 1\n\nfloat scale = 0.5;\nfloat offset = 0.5;\n\nfloat CP00 = (sin(iGlobalTime*0.30) * 0.5 + 0.5) * scale + offset;\nfloat CP01 = (sin(iGlobalTime*0.10) * 0.5 + 0.5) * scale + offset;\nfloat CP02 = (sin(iGlobalTime*0.70) * 0.5 + 0.5) * scale + offset;\nfloat CP03 = (sin(iGlobalTime*0.52) * 0.5 + 0.5) * scale + offset;\n\nfloat CP10 = (sin(iGlobalTime*0.20) * 0.5 + 0.5) * scale + offset;\nfloat CP11 = (sin(iGlobalTime*0.40) * 0.5 + 0.5) * scale + offset;\nfloat CP12 = (sin(iGlobalTime*0.80) * 0.5 + 0.5) * scale + offset;\nfloat CP13 = (sin(iGlobalTime*0.61) * 0.5 + 0.5) * scale + offset;\n\nfloat CP20 = (sin(iGlobalTime*0.50) * 0.5 + 0.5) * scale + offset;\nfloat CP21 = (sin(iGlobalTime*0.90) * 0.5 + 0.5) * scale + offset;\nfloat CP22 = (sin(iGlobalTime*0.60) * 0.5 + 0.5) * scale + offset;\nfloat CP23 = (sin(iGlobalTime*0.32) * 0.5 + 0.5) * scale + offset;\n\nfloat CP30 = (sin(iGlobalTime*0.27) * 0.5 + 0.5) * scale + offset;\nfloat CP31 = (sin(iGlobalTime*0.64) * 0.5 + 0.5) * scale + offset;\nfloat CP32 = (sin(iGlobalTime*0.18) * 0.5 + 0.5) * scale + offset;\nfloat CP33 = (sin(iGlobalTime*0.95) * 0.5 + 0.5) * scale + offset;\n\n#define FLT_MAX 3.402823466e+38\n\n\/\/=======================================================================================\nfloat CubicHermite (float A, float B, float C, float D, float t)\n{\n\tfloat t2 = t*t;\n    float t3 = t*t*t;\n    float a = -A\/2.0 + (3.0*B)\/2.0 - (3.0*C)\/2.0 + D\/2.0;\n    float b = A - (5.0*B)\/2.0 + 2.0*C - D \/ 2.0;\n    float c = -A\/2.0 + C\/2.0;\n   \tfloat d = B;\n    \n    return a*t3 + b*t2 + c*t + d;\n}\n\n\n\/\/=======================================================================================\nfloat HeightAtPos(vec2 P)\n{\n    float CP0X = CubicHermite(CP00, CP01, CP02, CP03, P.x);\n    float CP1X = CubicHermite(CP10, CP11, CP12, CP13, P.x);\n    float CP2X = CubicHermite(CP20, CP21, CP22, CP23, P.x);\n    float CP3X = CubicHermite(CP30, CP31, CP32, CP33, P.x);\n    \n    return CubicHermite(CP0X, CP1X, CP2X, CP3X, P.y);\n}\n\n\/\/=======================================================================================\nvec3 NormalAtPos( vec2 p )\n{\n\tfloat eps = 0.01;\n    vec3 n = vec3( HeightAtPos(vec2(p.x-eps,p.y)) - HeightAtPos(vec2(p.x+eps,p.y)),\n                         2.0*eps,\n                         HeightAtPos(vec2(p.x,p.y-eps)) - HeightAtPos(vec2(p.x,p.y+eps)));\n    return normalize( n );\n}\n\n\/\/=======================================================================================\nbool RayIntersectAABoxNoY (vec2 boxMin, vec2 boxMax, in vec3 rayPos, in vec3 rayDir, out vec2 time)\n{\n\tvec2 roo = rayPos.xz - (boxMin+boxMax)*0.5;\n    vec2 rad = (boxMax - boxMin)*0.5;\n\n    vec2 m = 1.0\/rayDir.xz;\n    vec2 n = m*roo;\n    vec2 k = abs(m)*rad;\n\t\n    vec2 t1 = -n - k;\n    vec2 t2 = -n + k;\n\n    time = vec2( max( t1.x, t1.y ),\n                 min( t2.x, t2.y ));\n\t\n    return time.y>time.x && time.y>0.0;\n}\n\n\/\/=======================================================================================\nfloat RayIntersectSphere (vec4 sphere, in vec3 rayPos, in vec3 rayDir)\n{\n\t\/\/get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    \/\/get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t\/\/exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn -1.0;\n\n\t\/\/calculate discriminant\n\tfloat discr = b * b - c;\n\n\t\/\/a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn -1.0;\n\n\t\/\/ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat collisionTime = -b - sqrt(discr);\n\n\t\/\/if t is negative, ray started inside sphere so clamp t to zero and remember that we hit from the inside\n\tif(collisionTime < 0.0)\n\t\tcollisionTime = -b + sqrt(discr);\n    \n    return collisionTime;\n}\n\n\/\/=======================================================================================\nvec3 DiffuseColor (in vec3 pos)\n{\n\t\/\/ checkerboard pattern\n    return vec3(mod(floor(pos.x * 10.0) + floor(pos.z * 10.0), 2.0) < 1.0 ? 1.0 : 0.4);\n}\n\n\/\/=======================================================================================\nvec3 ShadePoint (in vec3 pos, in vec3 rayDir, float time, bool fromUnderneath)\n{\n\tvec3 diffuseColor = DiffuseColor(pos);\n\tvec3 reverseLightDir = normalize(vec3(1.0,1.0,-1.0));\n\tvec3 lightColor = vec3(0.95,0.95,0.95);\t\n\tvec3 ambientColor = vec3(0.05,0.05,0.05);\n\n\tvec3 normal = NormalAtPos(pos.xz);\n    normal *= fromUnderneath ? -1.0 : 1.0;\n\n    \/\/ diffuse\n\tvec3 color = diffuseColor * ambientColor;\n\tfloat dp = dot(normal, reverseLightDir);\n\tif(dp > 0.0)\n\t\tcolor += (diffuseColor * dp * lightColor);\n    \n    \/\/ specular\n    vec3 reflection = reflect(reverseLightDir, normal);\n    dp = dot(rayDir, reflection);\n    if (dp > 0.0)\n        color += pow(dp, 15.0) * vec3(0.5);\t\t\n    \n    \/\/ reflection (environment mappping)\n    reflection = reflect(rayDir, normal);\n    color += textureCube(iChannel0, reflection).rgb * 0.25;    \n    \n    return color;\n}\n\n\/\/=======================================================================================\nvec3 HandleRay (in vec3 rayPos, in vec3 rayDir, in vec3 pixelColor, out float hitTime)\n{\n\tfloat time = 0.0;\n\tfloat lastHeight = 0.0;\n\tfloat lastY = 0.0;\n\tfloat height;\n\tbool hitFound = false;\n    hitTime = FLT_MAX;\n    bool fromUnderneath = false;\n    \n    vec2 timeMinMax = vec2(0.0);\n    if (!RayIntersectAABoxNoY(vec2(0.0), vec2(1.0), rayPos, rayDir, timeMinMax))\n        return pixelColor;\n    \n    time = timeMinMax.x;\n    \n    const int c_numIters = 100;\n    float deltaT = (timeMinMax.y - timeMinMax.x) \/ float(c_numIters);\n    \n    vec3 pos = rayPos + rayDir * time;\n    float firstSign = sign(pos.y - HeightAtPos(pos.xz));\n    \n\tfor (int index = 0; index < c_numIters; ++index)\n\t{\t\t\n\t\tpos = rayPos + rayDir * time;\n        \n        height = HeightAtPos(pos.xz);\n        \n        if (sign(pos.y - height) * firstSign < 0.0)\n        {\n            fromUnderneath = firstSign < 0.0; \n        \thitFound = true;\n\t\t\tbreak;\n        }\n\t\t\n\t\ttime += deltaT;\t\t\n\t\tlastHeight = height;\n\t\tlastY = pos.y;\n    }\n    \n\t\n\tif (hitFound) {\n\t\ttime = time - deltaT + deltaT*(lastHeight-lastY)\/(pos.y-lastY-height+lastHeight);\n\t\tpos = rayPos + rayDir * time;\n\t\tpixelColor = ShadePoint(pos, rayDir, time, fromUnderneath);\n        hitTime = time;\n\t}\n    else\n    {\n        #if SHOW_BOUNDINGBOX\n        \tpixelColor += vec3(0.2);\n        #endif\n    }\n    \n\treturn pixelColor;\n}\n\n\/\/=======================================================================================\nvec3 HandleControlPoints (in vec3 rayPos, in vec3 rayDir, in vec3 pixelColor, inout float hitTime)\n{\n    const float c_controlPointRadius = 0.02;\n    #if SHOW_CONTROLPOINTS\n    float cpHitTime = RayIntersectSphere(vec4(-1.0, CP00, -1.0, c_controlPointRadius), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(1.0,0.0,0.0);\n    }\n    cpHitTime = RayIntersectSphere(vec4(0.0, CP01, -1.0, c_controlPointRadius), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(1.0,0.0,0.0);\n    }    \n    cpHitTime = RayIntersectSphere(vec4(1.0, CP02, -1.0, c_controlPointRadius), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(1.0,0.0,0.0);\n    }    \n    cpHitTime = RayIntersectSphere(vec4(2.0, CP03, -1.0, c_controlPointRadius), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(1.0,0.0,0.0);\n    }        \n    \n    \n    cpHitTime = RayIntersectSphere(vec4(-1.0, CP10, 0.0, c_controlPointRadius), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(0.0,1.0,0.0);\n    }\n    cpHitTime = RayIntersectSphere(vec4(0.0, CP11, 0.0, c_controlPointRadius), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(0.0,1.0,0.0);\n    }    \n    cpHitTime = RayIntersectSphere(vec4(1.0, CP12, 0.0, c_controlPointRadius), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(0.0,1.0,0.0);\n    }       \n    cpHitTime = RayIntersectSphere(vec4(2.0, CP13, 0.0, c_controlPointRadius), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(0.0,1.0,0.0);\n    }      \n    \n    \n    cpHitTime = RayIntersectSphere(vec4(-1.0, CP20, 1.0, c_controlPointRadius), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(0.0,0.0,1.0);\n    }\n    cpHitTime = RayIntersectSphere(vec4(0.0, CP21, 1.0, c_controlPointRadius), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(0.0,0.0,1.0);\n    }    \n    cpHitTime = RayIntersectSphere(vec4(1.0, CP22, 1.0, c_controlPointRadius), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(0.0,0.0,1.0);\n    }     \n    cpHitTime = RayIntersectSphere(vec4(2.0, CP23, 1.0, c_controlPointRadius), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(0.0,0.0,1.0);\n    }     \n    \n    \n    cpHitTime = RayIntersectSphere(vec4(-1.0, CP30, 2.0, c_controlPointRadius), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(1.0,1.0,0.0);\n    }\n    cpHitTime = RayIntersectSphere(vec4(0.0, CP31, 2.0, c_controlPointRadius), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(1.0,1.0,0.0);\n    }    \n    cpHitTime = RayIntersectSphere(vec4(1.0, CP32, 2.0, c_controlPointRadius), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(1.0,1.0,0.0);\n    }     \n    cpHitTime = RayIntersectSphere(vec4(2.0, CP33, 2.0, c_controlPointRadius), rayPos, rayDir);\n    if (cpHitTime > 0.0 && cpHitTime < hitTime)\n    {\n        hitTime = cpHitTime;\n        pixelColor = vec3(1.0,1.0,0.0);\n    }       \n    #endif\n    \n    return pixelColor;\n}\n\n\/\/=======================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\t\n    \/\/----- camera\n    vec2 mouse = iMouse.xy \/ iResolution.xy;\n\n    vec3 cameraAt \t= vec3(0.5,0.5,0.5);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14 + iGlobalTime * 0.25;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.5;\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 5.0;\n    cameraPos += vec3(0.5,0.5,0.5);\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y \/ iResolution.x;\n    float cameraDistance\t= 6.0;  \/\/ intuitively backwards!\n\t\n\t\t\n\t\/\/ Objects\n\tvec2 rawPercent = (fragCoord.xy \/ iResolution.xy);\n\tvec2 percent = rawPercent - vec2(0.5,0.5);\n\t\n\tvec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n\t\t\t\t   - (cameraLeft * percent.x * cameraViewWidth)\n\t\t           + (cameraUp * percent.y * cameraViewHeight);\n\tvec3 rayDir = normalize(rayTarget);\n\t\n\t\n    float hitTime = FLT_MAX;\n\tvec3 pixelColor = textureCube(iChannel0, rayDir).rgb;\n    pixelColor = HandleRay(cameraPos, rayDir, pixelColor, hitTime);\n    pixelColor = HandleControlPoints(cameraPos, rayDir, pixelColor, hitTime);\n    \n    fragColor = vec4(clamp(pixelColor,0.0,1.0), 1.0);\n}","name":"","description":"","type":"image"}]}}