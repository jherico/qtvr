{"Shader":{"ver":"0.1","info":{"id":"MsXSzn","date":"1395714295","viewed":1298,"name":"Point Based Global Illumination","username":"XT95","description":"An approximation of global illumination (noise free) by a disk to disk approach.<br\/>Distance field is only used to show the cornell box, not to compute the GI.<br\/>","likes":11,"published":3,"flags":0,"tags":["raymarching","gi","globalillumination","ambientocclusion","pointbased","surfel"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Created by anatole duprat - XT95\/2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Papers :\n\/\/ http:\/\/http.developer.nvidia.com\/GPUGems2\/gpugems2_chapter14.html\n\/\/ http:\/\/graphics.pixar.com\/library\/PointBasedColorBleeding\/paper.pdf\n\/\/ http:\/\/graphics.pixar.com\/library\/PointBasedGlobalIlluminationForMovieProduction\/paper.pdf\n\n\/\/I think the \"4 lights\" bugs on the small box it's because i generate only one surfel by plane.\n\/\/Maybe by making a function who compute many surfels by plane, it would be a lot better!\n\n\nstruct Surfel\n{\n\tvec3 pos,n,col;\n\tfloat area;\n};\n\t\n#define NBSURFEL 18\nSurfel surfel[NBSURFEL];\nvoid generateSurfelsList();\n\n\n\n\/\/Maths\nconst float PI = 3.14159265359;\nmat3 rotate( in vec3 v, in float angle)\n{\n\tfloat c = cos(radians(angle));\n\tfloat s = sin(radians(angle));\n\t\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\nmat3 lookat( in vec3 fw, in vec3 up )\n{\n\tfw = normalize(fw);\n\tvec3 rt = normalize( cross(fw, normalize(up)) );\n\treturn mat3( rt, cross(rt, fw), fw );\n}\nfloat occ( float cosE, float cosR, float a, float d) \/\/ Element to element occlusion\n{\n\treturn ( clamp(cosE,0.,1.) * clamp(4.*cosR,0.,1.) ) \/ sqrt( a\/PI + d*d );\n}\nfloat radiance( float cosE, float cosR, float a, float d) \/\/ Element to element radiance transfer\n{\n\treturn (a * max(cosE,0.) * max(cosR,0.) ) \/ ( PI*d*d + a );\n}\n\n\/\/Raymarching \nfloat map( in vec3 p );\nfloat box( in vec3 p, in vec3 data )\n{\n    return max(max(abs(p.x)-data.x,abs(p.y)-data.y),abs(p.z)-data.z);\n}\nvec4 raymarche( in vec3 org, in vec3 dir, in vec2 nfplane )\n{\n\tfloat d = 1.0, g = 0.0, t = 0.0;\n\tvec3 p = org+dir*nfplane.x;\n\t\n\tfor(int i=0; i<64; i++)\n\t{\n\t\tif( d > 0.001 && t < nfplane.y )\n\t\t{\n\t\t\td = map(p);\n\t\t\tt += d;\n\t\t\tp += d * dir;\n\t\t\tg += 1.\/64.;\n\t\t}\n\t}\n\t\n\treturn vec4(p,g);\n}\nvec3 normal( in vec3 p )\n{\n\tvec3 eps = vec3(0.001, 0.0, 0.0);\n\treturn normalize( vec3(\n\t\tmap(p+eps.xyy)-map(p-eps.xyy),\n\t\tmap(p+eps.yxy)-map(p-eps.yxy),\n\t\tmap(p+eps.yyx)-map(p-eps.yyx)\n\t) );\n}\n\n\n\n\/\/Geometry\nfloat map( in vec3 p )\n{\n\tfloat d = -box(p-vec3(0.,10.,0.),vec3(10.));\n\td = min(d, box(rotate(vec3(0.,1.,0.), 0.)*(p-vec3(4.,5.,6.)), vec3(3.,5.,3.)) );\n\td = min(d, box(rotate(vec3(0.,1.,0.), 0.)*(p-vec3(-4.,2.,0.)), vec3(2.)) );\n\td = max(d, -p.z-9.);\n\t\n\treturn d;\n}\n\n\n\n\/\/Shading\nvec3 shade( in vec4 p, in vec3 n, in vec3 org, in vec3 dir )\n{\t\t\n\t\/\/wall color\n\tvec3 amb = vec3(.5);\n\tif(p.x<-9.999)\n\t\tamb = vec3(1.,0.,0.);\n\telse if(p.x>9.999)\n\t\tamb = vec3(.0,0.,1.);\n\telse\n\t\tamb = vec3(1);\n\t\t\n\t\n\t\/\/computing GI and ambient occlusion with the surfels\n\tvec3 gi = vec3(0.);\n\tvec3 glossy = vec3(0.);\n\tfloat ao = 0.;\n\tfor(int i=0; i<NBSURFEL; i++)\n\t{\n\t\tvec3 v = surfel[i].pos - p.xyz; \/\/ recever to emitter vector\n\t\tfloat d = length( v );\n\t\tv = normalize( v );\n\t\t\n\t\tfloat cosE = dot( -v, surfel[i].n );\n\t\tfloat cosR = dot( v, n );\n\t\tfloat cosR2 = dot( v, reflect(dir,n));\n\t\t\n\t\tgi += surfel[i].col * radiance( cosE, cosR, surfel[i].area, d);\n\t\tglossy += surfel[i].col * radiance( cosE, cosR2, surfel[i].area, d);\n\t\t\n\t\tao += occ( cosE, cosR, surfel[i].area, d);\n\t}\n\tvec3 col = ( amb*ao + gi + glossy ) ;\n\t\n\treturn col;\n}\n\n\/\/Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tgenerateSurfelsList();\n\t\n\n\t\/\/screen coords\n\tvec2 q = fragCoord.xy\/iResolution.xy;\n\tvec2 v = -1.0+2.0*q;\n\tv.x *= iResolution.x\/iResolution.y;\n\t\n\t\/\/camera ray\n\tfloat ctime = (iGlobalTime)*.25;\n\tvec3 org = vec3( cos(ctime)*5.,10.+cos(ctime*.5)*3.,-13.+sin(ctime) );\n\tvec3 dir = normalize( vec3(v.x, v.y, 1.5) );\n\tdir = lookat( -org + vec3(0., 5., 0.), vec3(0., 1., 0.) ) * dir;\n\t\n\t\/\/classic raymarching by distance field\n\tvec4 p = raymarche(org, dir, vec2(1., 30.) );\n\tvec3 n = normal(p.xyz);\n\tvec3 col = shade(p, n, org, dir);\n\t\n\t\n\tfragColor = vec4( col, 1. );\n}\n\n\n\n\/\/ -- Must be pre-computed on CPU with more precision --\nvoid generateSurfelsList()\n{\n\t\/\/cornell box\n\tsurfel[0].pos = vec3( 10., 10.,  0.); surfel[0].n = vec3(-1., 0., 0.); surfel[0].area = 100.; surfel[0].col = vec3(.0,.0,2.);\n\tsurfel[1].pos = vec3(-10., 10.,  0.); surfel[1].n = vec3( 1., 0., 0.); surfel[1].area = 100.; surfel[1].col = vec3(2.,.0,0.);\n\tsurfel[2].pos = vec3(  0., 10., 10.); surfel[2].n = vec3( 0., 0.,-1.); surfel[2].area = 100.; surfel[2].col = vec3(.0);\n\tsurfel[3].pos = vec3(  0., 20.,  0.); surfel[3].n = vec3( 0.,-1., 0.); surfel[3].area = 100.; surfel[3].col = vec3(.0);\n\tsurfel[4].pos = vec3(  0.,  0.,  0.); surfel[4].n = vec3( 0., 1., 0.); surfel[4].area = 100.; surfel[4].col = vec3(.0);\n\tsurfel[5].pos = vec3(  0., 10.,-10.); surfel[5].n = vec3( 0., 0., 1.); surfel[5].area = 100.; surfel[5].col = vec3(.0);\n\t\n\t\/\/big cube\n\tsurfel[6].pos = vec3(  4.,  0., 6.); surfel[6].n = vec3( 0., 1., 0.); surfel[6].area = 9.; surfel[6].col = vec3(.0);\n\tsurfel[7].pos = vec3(  4., 10., 6.); surfel[7].n = vec3( 0.,-1., 0.); surfel[7].area = 9.; surfel[7].col = vec3(.0);\n\tsurfel[8].pos = vec3(  7.,  5., 6.); surfel[8].n = vec3( 1., 0., 0.); surfel[8].area = 9.; surfel[8].col = vec3(.0);\n\tsurfel[9].pos = vec3(  1.,  5., 6.); surfel[9].n = vec3(-1., 0., 0.); surfel[9].area = 9.; surfel[9].col = vec3(.0);\n\tsurfel[10].pos = vec3(  4.,  5., 3.); surfel[10].n = vec3( 0., 0., -1); surfel[10].area = 9.; surfel[10].col = vec3(.0);\n\tsurfel[11].pos = vec3(  4.,  5., 9.); surfel[11].n = vec3( 0., 0.,  1); surfel[11].area = 9.; surfel[11].col = vec3(.0);\n\t\n\t\/\/small cube\n\tsurfel[12].pos = vec3( -4.,  0., 0.); surfel[12].n = vec3( 0., 1., 0.); surfel[12].area = 4.; surfel[12].col = vec3(.0);\n\tsurfel[13].pos = vec3( -4., 2., 0.); surfel[13].n = vec3( 0.,-1., 0.); surfel[13].area = 4.; surfel[13].col = vec3(.0);\n\tsurfel[14].pos = vec3( -2.,  1., 0.); surfel[14].n = vec3( 1., 0., 0.); surfel[14].area = 4.; surfel[14].col = vec3(.0);\n\tsurfel[15].pos = vec3( -6.,  1., 0.); surfel[15].n = vec3(-1., 0., 0.); surfel[15].area = 4.; surfel[15].col = vec3(.0);\n\tsurfel[16].pos = vec3( -4.,  1., -2.); surfel[16].n = vec3( 0., 0., -1); surfel[16].area = 4.; surfel[16].col = vec3(.0);\n\tsurfel[17].pos = vec3( -4.,  1., 2.); surfel[17].n = vec3( 0., 0.,  1); surfel[17].area = 4.; surfel[17].col = vec3(.0);\n\t\n\n}\t\n","name":"","description":"","type":"image"}]}}