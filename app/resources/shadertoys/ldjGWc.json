{"Shader":{"ver":"0.1","info":{"id":"ldjGWc","date":"1394660740","viewed":835,"name":"Variations on Noise","username":"FabriceNeyret2","description":"variation on https:\/\/www.shadertoy.com\/view\/Xs23D3<br\/>mouse.x: zoom   S: mouse.x controls lacunarity instead <br\/>E:   mouse.y = exponent (=vicinity)<br\/>N+B: noise type:   00: smooth 10: abs 11: 1-abs 10:1\/n<br\/>T: add or mul <br\/>C: toggles colors   G: toggles galaxy","likes":4,"published":3,"flags":0,"tags":["fractal","noise","perlin","filtering","multiscale"],"hasliked":0},"renderpass":[{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"\/\/ variations on noise \n\n#define SCALE_LACUNARITY 8. \/\/ when exponent is active\n#define NOctaves 12.    \t\/\/ max scales\n#define LimitDetails 2. \t\/\/ Anti aliasing\n#define ANIM 0\t\t\t\t\/\/ Manual \/ Auto\n#define ClampLevel 1.\t\t\/\/ Colormap\n\n\n\/\/ widgets from https:\/\/www.shadertoy.com\/view\/lsXXzN\n\nfloat t = iGlobalTime;\nvec2 FragCoord;\nvec4 FragColor;\n\n\/\/ --- key toggles -----------------------------------------------------\n\nbool keyToggle(int ascii) {\n\treturn (texture2D(iChannel2,vec2((.5+float(ascii))\/256.,0.75)).x > 0.);\n}\n\n\/\/ --- Digit display ----------------------------------------------------\n\n\/\/ all functions return true or seg number if something was drawn -> caller can then exit the shader.\n\n\/\/     ... adapted from Andre in https:\/\/www.shadertoy.com\/view\/MdfGzf\n\nfloat segment(vec2 uv, bool On) {\n\treturn (On) ?  (1.-smoothstep(0.08,0.09+float(On)*0.02,abs(uv.x)))*\n\t\t\t       (1.-smoothstep(0.46,0.47+float(On)*0.02,abs(uv.y)+abs(uv.x)))\n\t\t        : 0.;\n}\n\nfloat sevenSegment(vec2 uv,int num) {\n\tfloat seg= 0.;\n    seg += segment(uv.yx+vec2(-1., 0.),num!=-1 && num!=1 && num!=4                    );\n\tseg += segment(uv.xy+vec2(-.5,-.5),num!=-1 && num!=1 && num!=2 && num!=3 && num!=7);\n\tseg += segment(uv.xy+vec2( .5,-.5),num!=-1 && num!=5 && num!=6                    );\n   \tseg += segment(uv.yx+vec2( 0., 0.),num!=-1 && num!=0 && num!=1 && num!=7          );\n\tseg += segment(uv.xy+vec2(-.5, .5),num==0 || num==2 || num==6 || num==8           );\n\tseg += segment(uv.xy+vec2( .5, .5),num!=-1 && num!=2                              );\n    seg += segment(uv.yx+vec2( 1., 0.),num!=-1 && num!=1 && num!=4 && num!=7          );\t\n\treturn seg;\n}\n\nfloat showNum(vec2 uv,int nr, bool zeroTrim) { \/\/ nr: 2 digits + sgn . zeroTrim: trim leading \"0\"\n\tif (abs(uv.x)>2.*1.5 || abs(uv.y)>1.2) return 0.;\n\n\tif (nr<0) {\n\t\tnr = -nr;\n\t\tif (uv.x>1.5) {\n\t\t\tuv.x -= 2.;\n\t\t\treturn segment(uv.yx,true); \/\/ <<<< signe. bug\n\t\t}\n\t}\n\t\n\tif (uv.x>0.) {\n\t\tnr \/= 10; if (nr==0 && zeroTrim) nr = -1;\n\t\tuv -= vec2(.75,0.);\n\t} else {\n\t\tuv += vec2(.75,0.); \n\t\tnr = int(mod(float(nr),10.));\n\t}\n\n\treturn sevenSegment(uv,nr);\n}\n\nfloat dots(vec2 uv, int dot) {\n\tfloat point0 = float(dot\/2),\n\t\t  point1 = float(dot)-2.*point0; \n\tuv.y -= .5;\tfloat l0 = 1.-point0+length(uv); if (l0<.13) return (1.-smoothstep(.11,.13,l0));\n\tuv.y += 1.;\tfloat l1 = 1.-point1+length(uv); if (l1<.13) return (1.-smoothstep(.11,.13,l1));\n\treturn 0.;\n}\n\/\/    ... end of digits adapted from Andre\n\n#define STEPX .875\nfloat _offset=0.; \/\/ auto-increment useful for successive \"display\" call\n\n\/\/ 2digit int + sign\nbool display(vec2 pos, float scale, float offset, int number, int dot) { \/\/ dot: draw separator\n\tvec2 uv = FragCoord.xy\/iResolution.y;\n\tuv = (uv-pos)\/scale*2.; \n    uv.x = .5-uv.x + STEPX*offset;\n\tuv.y -= 1.;\n\t\n\tfloat seg = showNum(uv,number,false);\n\toffset += 2.;\n\t\n\tif (dot>0) {\n\t\tuv.x += STEPX*offset; \n\t\tseg += dots(uv,dot);\n\t\toffset += 2.;\n\t}\n\n\tFragColor += seg*vec4(0.,.5,1.,1.);  \/\/ change color here\n\t_offset = offset;\n\treturn (seg>0.);\n}\n\n\/\/ 2.2 float + sign\nbool display(vec2 pos, float scale, float offset, float val) { \/\/ dot: draw separator\n\tif (display( pos, scale, 0., int(val), 1)) return true;\n    if (display( pos, scale, _offset, int(fract(val)*100.), 0)) return true;\n\treturn false;\n}\n\n\/\/ --- noise functions from https:\/\/www.shadertoy.com\/view\/XslGRr\n\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec2 hash( vec2 p ) {  \t\t\t\t\t\t\/\/ rand in [-1,1]\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\treturn -1. + 2.*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {                     \/\/ noise in [-1,1]\n    vec2 i = floor(p), f = fract(p);\n\tvec2 u = f*f*(3.-2.*f);\n    return mix( mix( dot( hash( i + vec2(0.,0.) ), f - vec2(0.,0.) ), \n                     dot( hash( i + vec2(1.,0.) ), f - vec2(1.,0.) ), u.x),\n                mix( dot( hash( i + vec2(0.,1.) ), f - vec2(0.,1.) ), \n                     dot( hash( i + vec2(1.,1.) ), f - vec2(1.,1.) ), u.x), u.y);\n}\n\n\nvec3 colormap(float value) {\n\tfloat maxv = ClampLevel;\n\tvec3 c1,c2;\n\tfloat t;\n\tif (value < maxv \/ 3.) {\n\t\tc1 = vec3(0.);   \t c2 = vec3(1.,0.,0.); \tt =  1.\/3.;\n\t} else if (value < maxv * 2. \/ 3.) {\n\t\tc1 = vec3(1.,0.,0.); c2 = vec3(1.,1.,.5);\tt =  2.\/3. ;\n\t} else {\n\t\tc1 = vec3(1.,1.,.5); c2 = vec3(1.);      \tt =  1.;\n\t}\n\tt = (t*maxv-value)\/(maxv\/3.);\n\treturn t*c1 + (1.-t)*c2;\n}\n\n\/\/ ===============================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { \n    vec2 uv = 2.*(fragCoord.xy\/ iResolution.y- vec2(.5*iResolution.x\/iResolution.y,.5));\n\tvec4 mouse = iMouse \/ iResolution.xyxy;\n\tFragCoord=fragCoord;\n    FragColor=fragColor=vec4(0);\n    \n\t\/\/ --- tunings ------------------------------\n\n\tif (iMouse.x+iMouse.y==0.) mouse = vec4(.5);\n\t\n #if ANIM\n\tfloat cycle = cos(mod(-t,100.)\/100.*2.*3.14);\n\tfloat zoom = exp(cycle*cycle*20.);\n#else\n\tfloat zoom = 0.;\n\tzoom = (keyToggle(83)) ? abs(mouse.z) : mouse.x ;\n\tzoom = exp(-6. + zoom*9.);\n#endif\n\t\n\tif (!keyToggle(68)) { \/\/ 'D' : switch on\/off display mouse.xy\n\t\tvec2 pos ; float scale = 0.1;\n        pos = vec2(.2,.8); if (display( pos, scale, 0., mouse.x*100.)) { fragColor=FragColor; return; }\n        pos.y -= .15;\t   if (display( pos, scale, 0., mouse.y*100.)) { fragColor=FragColor; return; }\n\t}\n\t\n\tint TYPE = (keyToggle(84)) ? 0 : 1;\t\/\/ 0: additive perlin  1: multiplicative perlin\n\n\n\tif (keyToggle(71)) { \/\/ 'G' : map on galaxy\n\t\tfloat r = length(uv), a = atan(uv.y,uv.x);  \/\/ to polar\n\t\tif (!keyToggle(64+25)) { \/\/ 'Y'\n\t\t\tr = 1.*log(r\/.1); \t\t\t\t\t\t    \/\/ restore aspect ratio\n\t\t\ta -= r;           \t\t\t\t\t\t\t\/\/ slight slant\n\t\t\tuv = vec2(a,2.*r-1.);\n\t\t} \n\t\telse {\n\t\t\ta -= r;\n\t\t\tuv = vec2(r*cos(a),r*sin(a));\n\t\t}\n\t}\n\t\n\tif (keyToggle(64+23)) { \/\/ 'W' : gravity waves ( = galaxy spirals)\n#define AMP .1\n\t\tfloat phi = 3.*(uv.x-.5*iGlobalTime);\n\t\tuv.x -= AMP*sin(phi);\n\t\tmouse.y = 6.*AMP*(1.+cos(phi))\/2.;\n\t}\n\t\n\t\/\/ zoom and centering\n\tuv *= zoom; \n\t\n\tif (keyToggle(64+26)) { \/\/ 'Z'  mapping reference\n\t\tuv *= 8.;\n\t\tfloat n = 20.*2.*sign(mod(uv.x,1.)-.5)*sign(mod(uv.y,1.)-.5)-1.;\n\t\tfragColor=vec4(n); return;\n\t}\n\t\n\tfloat theta = 4. + float(ANIM)*.01*t; \/\/ some rotations, not compulsory\n    mat2 m = 2.*mat2( cos(theta),sin(theta), \n\t\t\t\t\t -sin(theta),cos(theta) );\n\t\t\n\t\/\/ noise type:   0: smooth  1: abs  2: 1-abs  3: 1\/(1+x)\n\tint NOISE = ((keyToggle(78))?1:0) + ((keyToggle(66))?2:0);\n\t\n\t\n\t\/\/ --- computation of the noise cascade ----------------------------\n\t\n\tfloat d = (TYPE==0) ? 0.:.5; \/\/ density\n\tfloat q = zoom;\n\t\n\tfor (float i = 0.; i < NOctaves; i++) { \/\/ cumulates scales from large to small\n\t\t\n\t\tif (TYPE==1) if(d < 1e-2) continue;\n\t\tfloat crit = iResolution.x\/(q*LimitDetails)-1.;\n\t\tif (crit < 0.) continue; \/\/ otherwise, smaller than pixel\n\t\n\t\t\/\/ --- base noise     normalization should ensure constant average\n\t\t\n\t\tfloat n = noise(uv + 10.*i*i); \/\/ base noise [-1,1]\n#define GAIN 1. \/\/ 5.*mouse.y \/\/ 5.\n\t\t\/\/ n = clamp(GAIN*n,-1.,1.); \/\/ to cancel poor stddev\n\t\tif (NOISE == 0)\n\t\t\tn = (1.+n)*.95; \/\/ [0.,1.]\n\t\telse if (NOISE == 1)\n\t\t\tn = abs(n)*8.5;\n\t\telse if (NOISE == 3)\n\t\t\tn = (1.-abs(n)) * 1.1;\n\t\telse if (NOISE == 2)\n\t\t\tn = 1.\/(1.+n)*.9;\n\n\t\t\t\n\t\t\/\/ --- lacunarity ( = vicinity at largest scale )\n\t\t\t\n\t\tif (keyToggle(69)) \/\/ 'E' : mouse.y tune exponent\n\t\t{ \n\t\t\tfloat P = mouse.y*10.; \/\/  power to control high-scale lacunarity\n\t\t\t\/\/ lacunarity fall-off with scale.   'S' : mouse.x tune scales of lacunarity\n\t\t\tfloat lac = SCALE_LACUNARITY * ( (keyToggle(83)) ? 2.*mouse.x : 1.);\n\t\t\tP = 1. + P*exp(-i\/lac);\n#define FACTOR 1.5\n\t\t\tn = clamp(n,0.,FACTOR); \n\t\t\tn = pow(n,P); \n\t\t}\n\t\t\n\n\t\t\/\/ --- fading zone to avoid aliasing\n\t\tif (crit<1.)   \n\t\t\tn = n*crit + (1.-crit); \n\n\t\t\/\/ --- cumulates cascade bands\n\t\tif (TYPE==1)\n\t\t\td *= n; \t\t\t\/\/ cumulates multiplicatively\n\t\telse\n\t\t\td += .4*n*zoom\/q;   \/\/ cumulates additively\n\t\t\n\t\tuv = m*uv; q*= 2.; \/\/ go to the next octave\n\t}\n\n\tfragColor.xyz = (keyToggle(67)) ?  vec3(d) : colormap(d) ;\n}","name":"","description":"","type":"image"}]}}