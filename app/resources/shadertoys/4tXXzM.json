{"Shader":{"ver":"0.1","info":{"id":"4tXXzM","date":"1450883092","viewed":268,"name":"PBR GGX Materials","username":"BiiG","description":"Test case for PBR GGX lighting formula","likes":7,"published":3,"flags":0,"tags":["ggxmaterialsamples"],"hasliked":0},"renderpass":[{"inputs":[{"id":9,"src":"\/presets\/tex08.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":26,"src":"\/presets\/cube04_0.png","ctype":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"id":27,"src":"\/presets\/cube05_0.png","ctype":"cubemap","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0"}],"code":"const float cDetailNormalPower = 0.3;\n\nvec3 gv3View = vec3(0.0,0.0,-1.0);\nvec3 gv3LightDir = vec3(0.0,0.0,-1.0);\nvec3 gv3LightColor = vec3(1.0,1.0,1.0);\n\n\nfloat G1V(float NdotV, float k)\n{\n\treturn 1.0\/(NdotV*(1.0-k)+k);\n}\n\nfloat SpecGGX(vec3 N, vec3 V, vec3 L, float roughness, float F0 )\n{\n\tfloat SqrRoughness = roughness*roughness;\n\n\tvec3 H = normalize(V+L);\n\n\tfloat NdotL = clamp(dot(N,L),0.0,1.0);\n\tfloat NdotV = clamp(dot(N,V),0.0,1.0);\n\tfloat NdotH = clamp(dot(N,H),0.0,1.0);\n\tfloat LdotH = clamp(dot(L,H),0.0,1.0);\n\n\t\/\/ Geom term\n\tfloat RoughnessPow4 = SqrRoughness*SqrRoughness;\n\tfloat pi = 3.14159;\n\tfloat denom = NdotH * NdotH *(RoughnessPow4-1.0) + 1.0;\n\tfloat D = RoughnessPow4\/(pi * denom * denom);\n\n\t\/\/ Fresnel term \n\tfloat LdotH5 = 1.0-LdotH;\n    LdotH5 = LdotH5*LdotH5*LdotH5*LdotH5*LdotH5;\n\tfloat F = F0 + (1.0-F0)*(LdotH5);\n\n\t\/\/ Vis term \n\tfloat k = SqrRoughness\/2.0;\n\tfloat Vis = G1V(NdotL,k)*G1V(NdotV,k);\n\n\tfloat specular = NdotL * D * F * Vis;\n    \n\treturn specular;\n}\n\nvec3 GetGIReflexion(in vec3 Normal, in float Roughness)\n{\n    vec3 R0 = textureCube (iChannel1,reflect(-Normal,gv3View) ).rgb;\n    vec3 R1 = textureCube (iChannel2,reflect(-Normal,gv3View) ).rgb;\n    return mix ( R0, R1, Roughness );\n}\n\nvec3 Sphere( in vec2 uv, in vec2 center, in float radius, in float roughness, in float Metallicness )\n{        \n    vec2 delta = center-uv;\n    \n    float l = dot ( delta, delta);     \n    \n    float sqrRadius = radius*radius;\n        \n    l = ((sqrRadius - l) \/ sqrRadius);\n    l = max ( l, 0.0 );     \n    \n    float IsInSphere = 1.0-step(l,0.0);\n    delta = delta;\n    \n    \/\/ Compute normal\n    vec3 normal = vec3(delta.xy\/radius,radius-sqrt(l));\n    normal = normalize ( normal );   \n    \n    \/\/ Generate UV from normal\n    vec2 texUV = normal.xy\/normal.z;    \n    texUV = texUV+vec2(0.5,0.5);        \n    vec3 textureColor = texture2D(iChannel0,texUV).rgb;\n    \n    \/\/ Use albedo R as a tangent space normal map\n    normal.xyz += textureColor.r * cDetailNormalPower;\n    normal = normalize ( normal );    \n\n    \/\/ Compute light contribution\n    float Diffuse = dot ( normal, gv3LightDir );\n    float Spec = SpecGGX(normal,gv3View,gv3LightDir,roughness,Metallicness);\n     \n    \/\/ Fresnel\n    float NdotV = clamp(dot(normal,gv3View),0.0,1.0);\n\tNdotV = pow(1.0-NdotV,5.0);    \n\tfloat Fresnel = Metallicness + (1.0-Metallicness)*(NdotV);\n\n    \/\/ Tint lights\n    vec3 SpecColor = Spec * gv3LightColor;\n    vec3 DiffColor = Diffuse * gv3LightColor * (1.0 - Fresnel);\n    \n    \/\/ Add GI\n    const float\tcAmbientMin = 0.04;    \n    float\t\tambient = cAmbientMin * (IsInSphere);    \n    vec3\t\tColorAmbient = vec3(ambient,ambient,ambient);\n    vec3\t\tGIReflexion = GetGIReflexion ( normal, roughness );\n    \n    \n    ColorAmbient = GIReflexion * cAmbientMin;\n        \n    vec3 lightSum = max(((DiffColor + SpecColor)*(1.0-cAmbientMin) ),vec3(0.0,0.0,0.0));\n       \n    return ( lightSum + ColorAmbient + ( Fresnel * GIReflexion ) ) * IsInSphere;\n      \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t    \n    \/\/ Compute normalized UV\n    vec2 uv = fragCoord.xy \/ iResolution.xy;    \n    \/\/ Adapt coord to aspect ratio\n    uv = uv * vec2(1.0,iResolution.y\/iResolution.x);\n    \n    \n    \/\/ Rotate light\n    gv3LightDir = vec3(sin(iGlobalTime),cos(iGlobalTime)+0.2,cos(iGlobalTime));\n    gv3LightDir = normalize (gv3LightDir);\n        \n    \/\/ Compute all spheres lighting\n    vec3 color = vec3(0.0,0.0,0.0);\t\n    for ( float Roughness=0.05; Roughness<1.0; Roughness+=0.1)\n    {\n        for ( float Metallicness=0.05; Metallicness<1.0; Metallicness+=0.1)\n        {\n            const float Radius = 0.04;\n            color += Sphere ( uv,vec2( Roughness , Metallicness*0.8 ), Radius, Roughness, Metallicness );\n        }\n    }    \n    \n    \n\tfragColor = vec4 (color,1.0);\n}","name":"","description":"","type":"image"}]}}