{"Shader":{"ver":"0.1","info":{"id":"XdjSDG","date":"1415545852","viewed":782,"name":"graphene","username":"FabriceNeyret2","description":"mouse controls camera.<br\/>If your graphics card allows, change LX,LY,LZ","likes":6,"published":3,"flags":0,"tags":["raytracing","implicit","hypertexture"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ camera\nvec3 pos    = vec3(0.,0.,-10.);\nfloat zoom  = 2.;\nvec3 up     = vec3(0.,1.,0.);\nvec3 target = vec3(0.,0.,0.);\n\n\/\/ lighting & materials\nvec3 lum    = normalize(vec3(-.2,1.,-.5));\nvec3 color  = vec3(1.,0.,0.);\nvec3 amb   = .12*color;\nvec3 diff  = .9*color;\nvec3 spec  = vec3(1.);\nfloat highlight = 100.;\nfloat fog = 0.05;\nvec3 fogColor = vec3(1.);\n\n\/\/ shape\n#define LX 2\t\t\t\/\/ grid size\n#define LY 2\n#define LZ 0\n\n#define radius 1.3      \/\/ spheroids size\n#define D 3.1           \/\/ spheroids distance\n#define thickness .8    \/\/ displacement amplitude\n#define scale .3        \/\/ noise scale\n#define chaos .75       \/\/ noise sharpness\n#define NOISE_TYPE 1\n\n\/\/ perfs\/precision\n#define range 20.       \/\/ max depth\n#define NB 40           \/\/ for first guess\n#define eps 0.001       \/\/ for dichotomy\n\n#define time iGlobalTime\n\n\/\/ --- noise functions inspired from https:\/\/www.shadertoy.com\/view\/XslGRr\n\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nmat3 m = mat3( 0.00,  0.80,  0.60,  -0.80,  0.36, -0.48,   -0.60, -0.48,  0.64 );\nfloat hash( float n ) {  \/\/ base rand in [0,1]; \n\treturn fract(sin(n-765.36334)*43758.5453);\n}\nfloat noise( in vec3 x ) { \/\/ base noise in [0,1]; \n    x += 2.*time*(1.,2.,1.);\n    vec3 p = floor(x), f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n#if NOISE_TYPE==1\n\treturn res;\n#elif NOISE_TYPE==2\n\treturn abs(2.*res-1.);\n#elif NOISE_TYPE==3\n\treturn 1.-abs(2.*res-1.);\n#endif\n}\n\nfloat fbm( vec3 p ) { \/\/ turbulent (=fractal) noise in [-1,1]; \n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return 2.*f-1.;\n}\n\/\/ --- End of: Created by inigo quilez --------------------\n\n\n\/\/ --- shapes construction --------------------------------------------------\n\/\/ smooth sets: density = proba = 1 inside, 0 outside\n\nfloat sphere(vec3 P,vec3 pos, float r) {\n    float d = length(P-pos)-r;\t\t\t       \/\/ signed distance to surface ( positive outside)\n    return (1.-clamp(d\/thickness,-1.,1.))\/2.;  \/\/ density. blurry transition in a shell (thickness)\n}\nfloat inter(float d0, float d1) { return d0*d1; }     \/\/ smooth intersect operator\nfloat add(float d0, float d1) { return d0+d1-d0*d1; } \/\/ smooth union operator\n\nfloat f(vec3 P) { \/\/ signed distance to complex surface\n#if 1\n    float d=-1.;\n    for (int k=-LZ; k<=LZ; k++)\n      for (int j=-LY; j<=LY; j++)\n        for (int i=-LX; i<=LX; i++) {\n            float i0 = mod(float(i),2.); \/\/ hexa hole\n            if (mod(float(j)-i0+1.,3.)==0.) continue;\n            \/\/vec3 pos = D*vec3(float(i),float(j),float(k)); \/\/ pos += .2*vec3(2.*noise(pos)-1.); \/\/ 4-grid\n            vec3 pos = .89*D*vec3(float(i),2.\/sqrt(3.)*(float(j)+.5*i0),float(k));  \/\/ 6-grid\n            pos.z += .2*(sin(length(pos.xy)+5.*time));\n            float di = sphere(P,pos,radius); \/\/ one blob\n            d = add(d,di); \t\t\t\t\t \/\/ union of blobs\n        }\n    d=-d;\n#else\n\tfloat d1 = .5-(length(P+vec3(.5*D,0.,0.))-radius)\/thickness,\n\t      d2 = .5-(length(P-vec3(.5*D,0.,0.))-radius)\/thickness,\n           d =  .5- (d1+d2-d1*d2); d \/= 2.;\n    P += .3*iGlobalTime*(1.,2.,1.);\n#endif\n    if (abs(d)>chaos*scale) return d; \/\/ too far for noise change the sign -> saving\n\treturn d + chaos*scale*fbm(P\/scale);\n}\n\n\/\/ --- geometric functions --------------------------------------------------------------\n\nfloat intersec(vec3 pos, vec3 ray, float t0) {\n    float t1=t0,t2;  vec3 P1; float v1;\n    \/\/ 1st, search for a point inside matter\n    for (int i=0; i<=NB; i++) { \n       t0 = t1; \n       t1 = range*float(i)\/float(NB); P1 = pos+t1*ray; v1 = f(P1);\n       if (v1<0.) break;\n    }\n    \/\/ then, search the surface point by dichotomy\n    vec3 P0 = pos+t0*ray; float v0 = f(P0);\n    if (v0*v1>0.) return 0.;\n    for(int i=0; i<NB; i++) {  \/\/ ( do-while not implemented )\n    \tt2 = (t0+t1)\/2.; \n        vec3 P2 = pos+t2*ray; float v2 = f(P2);\n    \tif (v0*v2>0.) {t0=t2; v0=v2; P0=P2;} else {t1=t2; v1=v2; P1=P2; }\n        if (abs(v2)<eps) return t2;\n    }\n    return t2;\n}\nvec3 get_N(vec3 P) {\n    float v = f(P);\n    float dfx = f(P+eps*vec3(1.,0.,0.))-v,\n          dfy = f(P+eps*vec3(0.,1.,0.))-v,\n          dfz = f(P+eps*vec3(0.,0.,1.))-v;\n    return normalize(vec3(dfx,dfy,dfz));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \/\/ --- scene ray-tracing -------------------------------------------------\n{\n    vec2 m = 2.*(iMouse.xy\/iResolution.xy-vec2(.5,.5));\n    if (iMouse.z <=0.) m=vec2(cos(.1*time),sin(.1*2.*time));\n    vec2 angle = 3.1415*m;\n    \/\/ --- set camera\n    float c=cos(angle.x),s=sin(+angle.x); pos.xz = mat2(c,-s,s,c)*pos.xz;\n          c=cos(angle.y),s=sin(-angle.y); pos.yz = mat2(c,-s,s,c)*pos.yz;\n    mat3 cam;\n    cam[0] = normalize(target-pos);\n    cam[2] = normalize(up -dot(up,cam[0])*cam[0]);\n    cam[1] = cross(cam[0],cam[2]);\n    \n\tvec2 uv = 2.*(fragCoord.xy\/iResolution.y-vec2(.9,.5));\n    vec3 ray = normalize(cam*vec3(zoom,uv.x,uv.y)); float t=0.;\n    vec3 col = vec3(0.); float trsp = 1.;\n    \n    \/\/ --- calc intersection and shading\n    t = intersec(pos,ray,t);\n    if (t>0.) {\n        vec3 H = normalize(-cam[0]+lum);\n        vec3 N = get_N(pos+t*ray);\n        col = amb + diff*max(dot(N,lum),0.) + spec*pow(max(dot(N,H),0.),highlight);\n    } else t=1e10;\n    \n    \/\/ --- compose final color\n    trsp  = exp(-fog*t);\n    col = (1.-trsp)*fogColor + trsp*col;\n\tfragColor = vec4(col,1.0);\n}","name":"","description":"","type":"image"}]}}