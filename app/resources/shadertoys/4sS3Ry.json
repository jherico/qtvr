{"Shader":{"ver":"0.1","info":{"id":"4sS3Ry","date":"1389894654","viewed":1034,"name":"Life","username":"HLorenzi","description":"Trying to circumvent GLSL's array access limitations! Simulates 3 generations of random initial cells every 4 seconds on a 5 x 5 torus grid! Is probably broken on many machines...","likes":14,"published":3,"flags":0,"tags":["2d","game","simulation","life","cell","dot","conway"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"\/\/ Life by HLorenzi!\n\n#define WIDTH 5\n#define HEIGHT 5\n\n#define pX int(mod(float(i + 1), float(WIDTH)))\n#define  X int(mod(float(i), float(WIDTH)))\n#define mX int(mod(float(i - 1), float(WIDTH)))\n#define pY int(mod(float((i \/ HEIGHT) + 1), float(WIDTH))) * WIDTH\n#define  Y int(mod(float((i \/ HEIGHT)), float(WIDTH))) * WIDTH\n#define mY int(mod(float((i \/ HEIGHT) - 1), float(WIDTH))) * WIDTH\n\t\t\t\t\n\nint world1[WIDTH * HEIGHT];\nint world2[WIDTH * HEIGHT];\n\nvoid generateWorld2()\n{\n\tfor(int i = 0; i < WIDTH * HEIGHT; i++)\n\t{\n\t\tint neighbors = world1[mX + mY] + world1[ X + mY] + world1[pX + mY] +\n\t\t\t\t\t\tworld1[mX +  Y] +                   world1[pX +  Y] +\n\t\t\t\t\t\tworld1[mX + pY] + world1[ X + pY] + world1[pX + pY];\n\t\t\n\t\tint cell = world1[i];\n\t\t\n\t\tif (cell == 1)\n\t\t{\n\t\t\tworld2[i] = (neighbors < 2 || neighbors > 3) ? 0 : 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tworld2[i] = (neighbors == 3) ? 1 : 0;\n\t\t}\n\t}\n}\n\nvoid generateWorld1()\n{\n\tfor(int i = 0; i < WIDTH * HEIGHT; i++)\n\t{\n\t\tint neighbors = world2[mX + mY] + world2[ X + mY] + world2[pX + mY] +\n\t\t\t\t\t\tworld2[mX +  Y] +                   world2[pX +  Y] +\n\t\t\t\t\t\tworld2[mX + pY] + world2[ X + pY] + world2[pX + pY];\n\t\t\n\t\tint cell = world2[i];\n\t\t\n\t\tif (cell == 1)\n\t\t{\n\t\t\tworld1[i] = (neighbors < 2 || neighbors > 3) ? 0 : 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tworld1[i] = (neighbors == 3) ? 1 : 0;\n\t\t}\n\t}\n}\n\nfloat hash(float x)\n{\n\treturn fract(sin(x) * 43712.34183);\n}\n\nfloat hashNeg(float x)\n{\n\treturn fract(sin(x) * 43712.34183) * 2.0 - 1.0;\n}\n   \nvoid simulate(float g, int iteration) {\n\tfor(int i = 0; i < WIDTH * HEIGHT; i++)\n\t\tworld1[i] = (hash(float(i) * (g + 2.951)) < 0.3 + hash(g + 3.817) * 0.2) ? 1 : 0;\n\t\n\tfor(int steps = 0; steps < 4; steps++)\n\t{\n\t\tif (steps <= iteration)\n\t\t{\n\t\t\tif (mod(float(steps), 2.0) == 0.0)\n\t\t\t{\n\t\t\t\tgenerateWorld2();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tgenerateWorld1();\n\t\t\t}\n\t\t}\n\t}\n}\n\nvec4 HSVtoRGB(vec3 c)\n{\n    c.x \/= 360.0;\n    vec4 K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return vec4( c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y), 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n\tq = q * 2.0 - 1.0;\n\tq.x *= iResolution.x \/ iResolution.y;\n\t\n\tfloat seq = floor(iGlobalTime \/ 4.0);\n\tfloat sub = mod(iGlobalTime, 4.0);\n\t\n\tfloat a = hashNeg(seq * 7.31) * 0.5;\n\tmat2 m = mat2(cos(a),-sin(a),sin(a),cos(a));\n\t\t\n\tvec2 uv = q * 5.0;\n\tuv += vec2(hashNeg(seq + 1.38),hashNeg(seq + 9.134));\n\t\t\n\tuv *= 5.0 - sub;\n\tuv = m * uv;\n\t\n\tvec2 pixel = (mod(floor(uv + vec2(0.5,0.5)), 5.0));\n\t\n\tfloat r = distance(uv,floor(uv + vec2(0.5,0.5)));\n\t\n\tint iteration = int(mod(floor(iGlobalTime), 4.0));\n\t\n\tsimulate(seq, iteration);\n\t\n\t\t\n\tint lastcell = 0;\n\tint cell = 0;\n\t\n\t\/\/ Hack to access a random array index\n\tfor(int i = 0; i < WIDTH * HEIGHT; i++)\n\t{\n\t\tif (int(pixel.y) * WIDTH + int(pixel.x) == i)\n\t\t{\n\t\t\tcell = (mod(float(iteration),2.0) == 0.0 ? world1[i] : world2[i]);\n\t\t\tlastcell = (mod(float(iteration),2.0) == 0.0 ? world2[i] : world1[i]);\n\t\t}\n\t}\n\t\n\tfloat cellcolor = (cell == 0 ? 0.0 : 0.5);\n\tfloat lastcellcolor = (lastcell == 0 ? 0.0 : 0.5);\n\t\n\tfloat c;\n\t\n\tif (r < mix(cellcolor,lastcellcolor,clamp((iGlobalTime - floor(iGlobalTime)) * 8.0, 0.0, 1.0)))\n\t\tc = 0.4;\n\telse if (r < 0.5)\n\t\tc = 0.8;\n\telse\n\t\tc = 0.85;\n\t\t\n\tfloat transition = sin(min(mod(iGlobalTime + 0.1, 4.0),0.2) \/ 0.2 * 3.14159);\n\t\n\t\t\n\tfragColor = mix(HSVtoRGB(vec3(hash(seq * 891.3 + 76.4) * 360.0, 0.8, c)),\n\t\t\t\t\tvec4(0.9,0.9,0.9,1), transition) * clamp(1.0 - length(q) \/ 4.0, 0.0, 1.0);\n}","name":"","description":"","type":"image"}]}}