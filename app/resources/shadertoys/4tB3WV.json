{"Shader":{"ver":"0.1","info":{"id":"4tB3WV","date":"1432346492","viewed":771,"name":"Implicit Plotter","username":"Flyguy","description":"An updated version of an implicit plotter I posted on GLSL Sandbox a while ago.","likes":7,"published":3,"flags":0,"tags":["math","graph","plot","implicit"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"channel":"0"}],"code":"float pi = atan(1.0) * 4.0;\n\n\/\/Implicit \/ f(x) plotter thing.\n\n\/\/XY range of the display.\n#define DISP_SCALE 16.0 \n\n\/\/Line thickness (in pixels).\n#define LINE_SIZE 2.0\n\n\/\/Grid line & axis thickness (in pixels).\n#define GRID_LINE_SIZE 1.0\n#define GRID_AXIS_SIZE 2.0\n\n\/\/Number of grid lines per unit.\n#define GRID_LINES 1.0\n\n\/\/Clip areas outside DISP_SCALE\n\/\/#define CLIP_EDGES\n\nconst vec2 GRAD_OFFS = vec2(0.001, 0);\n\n#define GRAD(f, p) (vec2(f(p) - f(p + GRAD_OFFS.xy), f(p) - f(p + GRAD_OFFS.yx)) \/ GRAD_OFFS.xx)\n\n\/\/PLOT(Function, Color, Destination, Screen Position)\n#define PLOT(f, c, d, p) d = mix(c, d, smoothstep(0.0, (LINE_SIZE \/ iResolution.y * DISP_SCALE), abs(f(p) \/ length(GRAD(f,p)))))\n\nfloat Line(vec2 p)\n{\n\tfloat m = (2.0 \/ 1.0);\n\tfloat b = 0.0;\n\t\n\tfloat y = m*p.x + b;\n\t\n\treturn p.y - y;\n}\n\nfloat Parabola(vec2 p)\n{\n\tfloat a = 0.5;\n\tfloat b = 0.0;\n\tfloat c = -6.0;\n\t\n\tfloat y = a*p.x*p.x + b*p.x + c;\n\t\n\treturn p.y - y;\n}\n\nfloat Sine(vec2 p)\n{\n\tfloat amp = 2.0;\n\tfloat freq = 0.25;\n\t\n\tfloat y = amp * sin(2.0 * pi * p.x * freq);\n\t\n\treturn p.y - y;\n}\n\nfloat Circle(vec2 p)\n{\n\tfloat z = sqrt(p.x*p.x + p.y*p.y) - 6.0;\n\t\n\treturn z;\n}\n\nfloat Heart(vec2 p)\n{\n\tfloat z = pow(p.x, 2.0) + pow(p.y - pow(pow(p.x, 2.0),1.0 \/ 3.0), 2.0) - 4.0;\n\t\n\treturn z;\n}\n\nfloat grid(vec2 p);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 aspect = iResolution.xy \/ iResolution.y;\n\tvec2 uv = ( fragCoord.xy \/ iResolution.y ) - aspect \/ 2.0;\n\tuv *= DISP_SCALE;\n\t\n\tvec3 col = vec3(grid(uv) * 0.25 + 0.75);\n    \n    PLOT(Sine, vec3(0,1,0), col, uv);\n    \n    PLOT(Circle, vec3(0,0,1), col, uv);\n    \n    PLOT(Line, vec3(1,0.5,0), col, uv);\n    \n    PLOT(Heart, vec3(1,0,0), col, uv);\n    \n    PLOT(Parabola, vec3(1,0,1), col, uv);\n    \n\t#ifdef CLIP_EDGES \n\t\tcol *= 1.0 - step(DISP_SCALE \/ 2.0, abs(uv.x));    \n\t#endif\n\t\n\tfragColor = vec4( vec3(col), 1.0 );\n}\n\nfloat grid(vec2 p)\n{\n\tvec2 uv = mod(p,1.0 \/ GRID_LINES);\n\t\n\tfloat halfScale = 1.0 \/ GRID_LINES \/ 2.0;\n\t\n\tfloat gridRad = (GRID_LINE_SIZE \/ iResolution.y) * DISP_SCALE;\n\tfloat grid = halfScale - max(abs(uv.x - halfScale), abs(uv.y - halfScale));\n\tgrid = smoothstep(0.0, gridRad, grid);\n\t\n\tfloat axisRad = (GRID_AXIS_SIZE \/ iResolution.y) * DISP_SCALE;\n\tfloat axis = min(abs(p.x), abs(p.y));\n\taxis = smoothstep(axisRad-0.05, axisRad, axis);\n\t\n\treturn min(grid, axis);\n}\n","name":"","description":"","type":"image"}]}}